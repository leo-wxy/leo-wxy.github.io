---
title: JVM相关合集整理
date: 2020-05-02 10:02:46
tags: JVM
top: 11
---

> 本章主要针对JVM基础知识的整理以及拓展

## JVM内存区域

<!--1.8前后有差异，需要列出来-->

> JVM在执行Java程序的过程中会把管理的内存分为若干个不同的数据区域。
>
> **JDK1.8前后分区略有不同**

<div align="center">
<img style="margin-right:30px" src="/images/jvm/jvm1.8前.jpg" width="35%" alt="JDK 1.8之前" ><img style="margin-left:30px" src="/images/jvm/jvm1.8.jpg" width="50%" alt="JDK1.8之后" >    
</div>



根据上述两图，运行时数据区域按照`线程是否私有`分为两部分：

- `线程私有`：程序计数器、虚拟机栈、本地方法栈
- `线程共享`：堆、方法区

### 程序计数器

> **线程私有**，当前线程所执行的字节码的`行号指示器`，记录当前线程执行的位置。

程序计数器主要有两个作用：

1. 字节码解释器通过改变`程序计数器`来依次读取指令，从而实现代码的流程控制
2. 在多线程的情况下，`程序计数器`用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到何处。
   - 线程执行Java方法时，计数器记录了`当前正在执行的字节码指令地址`。
   - 线程执行Native方法时，计数器值为`Undefined`。

**`程序计数器`是唯一一个不会出现`OutOfMemory`的内存区域，它的生命周期随着线程的创建而创建，随线程的结束而死亡。**

### 虚拟机栈

> **线程私有**，描述`Java方法执行的内存模型`，每次方法调用的数据都是通过栈传递的。

Java内存可以粗糙的分为**堆内存(Heap)**和**栈内存(Stack)**，栈内存位于虚拟机栈上。

**栈内存**：存储`局部变量`和`方法调用`

**堆内存**：存储`Java中的对象(无论成员变量、局部变量、类变量)`

*如果局部变量是`基本数据类型`，那局部变量的值存储于栈上；若局部变量是`对象`，该变量的引用存在于栈上，但是对象存储于堆中。*

> 基本数据类型：`boolean、byte、char、short、int、float、long、double`

</br>

#### 栈帧

`虚拟机栈`由一个个**栈帧**组成，`栈帧`也叫`过程活动记录`，是用于支持虚拟机调用/执行程序方法的数据结构，记录了每一个方法从调用直至执行完成的过程。*栈帧随着方法的调用而创建，执行完成而销毁。*

`栈帧`主要由以下四部分组成：

{% fullimage /images/jvm/栈帧结构.png,操作指令-异常指令,操作指令-异常指令%}

##### 局部变量表

> 用于存储方法参数和定义在方法体的局部变量，包含了编译器可知的各种基本数据类型、对象引用、returnAddress类型。

局部变量表的大小在编译期就已经确定了，对应了字节码中`Code属性表中的max_locals`。

##### 操作数栈

> 通过入栈、出栈操作来完成一次数据访问，本质是一个**临时数据存储区域**。
>
> 是一个后入先出栈(LIFO)

操作数栈的大小在编译期已经确定，对应字节码中的`Code属性表中的max_stacks`

##### 动态链接

> 为了支持方法调用过程中的动态连接，调用编译期无法被确定的方法。
>
> **在运行期将符号引用转换为所在内存地址的直接引用。**

静态链接：被调用的目标方法在编译期可知且运行期保持不变时，那么这种情况下调用方法的符号引用可以转换为直接引用。

##### 返回地址

> 记录方法被调用的位置，可以在方法执行结束后回到被调用处继续向下执行程序。

当一个方法开始执行后，只有两种方式可以退出这个方法：

- **正常退出**：方法中的代码正常执行完成，或者遇到任意一个方法返回的字节码指令(`return`)并退出，将返回值传递给上层的方法调用者，没有抛出任何异常。
- **异常退出**：执行方法过程中出现异常，并且没有处理该异常，导致方法退出。

一般方法退出正常值为`调用者的PC计数器数值`。

<br>

在`虚拟机栈`会出现两种异常情况：

- `StackOverflowError`：请求栈深度超出虚拟机栈说允许的深度时抛出
- `OutOfMemoryError`：无法申请到足够的内存时抛出

### 本地方法栈

> **线程私有**，虚拟机执行Native方法的服务，和`虚拟机栈`功能类似。

在`本地方法栈`会出现两种异常情况：

- `StackOverflowError`：请求栈深度超出虚拟机栈说允许的深度时抛出
- `OutOfMemoryError`：无法申请到足够的内存时抛出

### **Java堆**

> **线程共享**
>
> JVM所管理内存中的最大一块，该区域唯一目的是**存放对象实例**，几乎所有对象实例都在这里分配内存。
>
> 因此他也是垃圾收集管理的主要区域，因此也被称作`GC堆`。

由于现在基本都采用分代垃圾回收算法，按照对象存储时间的不同，还可以细分为`新生代(分为Eden和Survivor，大致比例为8:1:1)`和`老年代`。

{% fullimage /images/jvm/Java堆结构.jpg,Java堆结构,Java堆结构%}

在`Java堆`中会出现以下异常情况：

- `OutOfMemoryError`：无法申请到足够的内存时抛出

#### Tips

JVM堆内存溢出后，其他线程是否继续正常工作？

发生OOM之后会不会影响其他线程正常工作需要具体的场景分析。一般情况下，发生OOM的现场都会被终结，然后该线程持有的对象占用就会被GC，释放内存。

### 方法区(版本区别较大)

> **线程共享**
>
> 用于存储`已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据`。
>
> `方法区`还有一个别名叫做`Non-Heap`，可以与上述的`Java堆`进行区分。

#### JDK 1.8前

那时`方法区`也被称为`永久代`，GC在该区域是比较少出现的，但是不代表不进行GC操作。常见的异常为`java.lang.OutOfMemoryError:PermGen space`表示了`永久代异常信息`。

#### JDK 1.8

这时`永久代`已被移除，代替它的是`元空间(meta space)`，`元空间`位于`直接内存`中，因此`元空间`的最大占用就是系统的内存空间，用户可通过`-XX:MetaspaceSize`设置`元空间`最大占用，避免占用过量内存。

#### Why

- 由于`永久代`内存经常会溢出，导致OOM发生，因此JVM开发者希望这块内存可以被更灵活的管理，减少OOM错误的出现。
- `永久代`会为GC带来不必要的复杂度，并且回收效率偏低。
- `永久代`的大小难以确定，太小容易造成`方法区`发生OOM

在`方法区`会出现两种异常情况：

- `StackOverflowError`：请求栈深度超出虚拟机栈说允许的深度时抛出
- `OutOfMemoryError`：无法申请到足够的内存时抛出



#### Tips

如何使方法区发生OOM?

借助`CGLib`这类字节码技术，不断动态生成新类，新方法。或者使用不同的ClassLoader去加载同一个类(`不同的ClassLoader加载的同一个类也是不同的`)

- JDK1.8之前

  可以通过配置`-XX:Maxpermsize`设置一个较小的值

- JDK1.8

  上述方法由于移除了`永久代`无法生效，可以通过配置`-XX:MetaspaceSize`一个较小的值，也可以模拟这个异常。

### 常量池

<!--String.intern()来举例-->

> Java中常量池的概念主要有三个：
>
> - `字符串常量池`
> - `Class文件常量池`
> - `运行时常量池`
>
> 其中`Class文件常量池`存在于class文件中，不受JDK版本影响。
>
> `字符串常量池`在JDK1.6前位于`方法区`中，之后的版本存在于`Java堆`上
>
> `运行时常量池`在JDk1.7前位于`方法区`中，之后的版本存在于`元空间`上

#### Class文件常量池(`Class Constant Pool`)

> class文件除了包含`类的版本、字段、方法、接口等描述信息`外，还有一项信息就是`Class文件常量池`，用于存放编译器生成的`各种字面量和符号引用`。

##### 字面量

> 接近Java语言层面的常量

- 文本字符串

  ```java
  public String s = "abc";//其中abc为字面量
  
  对应字节码常量池数据为
  #31 = Utf8               abc
  ```

- 8种基本类型的值

  ```java
  public int value = 1;
  
  对应字节码常量池数据为
  #7 = Utf8               value
  #8 = Utf8               I
  ```

  常量池只保留了字段描述符(I)和字段名称(value)，字面量不存在于常量池中。

- 用`final`修饰的成员变量，包括`静态变量、实例变量，局部变量`

  ```java
  public final static int f = 2;//其中2为字面量
  
  对应字节码常量池数据为
  #11 = Integer               2
  ```

  

##### 符号引用

> 用一组符号描述所引用的目标，符号可以是任何形式的字面量。

- 类和接口的全限定名

  ```java
  public String s = "abc";
  
  对应字节码常量池数据为
  #5 = Class              #10            // java/lang/String
  #10 = Utf8              Ljava/lang/String;
  
  ```

  其中`String`对应全限定名为`java/lang/String`存储于常量池中

  **主要用于在运行时解析得到类的直接引用**

  

- 字段的名称和描述符

  字段：类或接口中声明的变量，包括类级别变量和实例级的变量

  ```java
  public int value = 1;
  
  对应字节码常量池数据为
  #4 = Fieldref           #5.#32         // JavaBasicKnowledge/JavaBean.value:I
   #5 = Class              #33            // JavaBasicKnowledge/JavaBean
   #32 = NameAndType       #7:#8          // value:I
  
   #7 = Utf8               value
   #8 = Utf8               I
  ```

  *对于方法中的局部变量名，class常量池中仅仅保存字段名*

  ```java
  public void XX(int v){
     int temp = 3;
  }
  
  对应字节码常量池数据为
   #23 = Utf8               v
   #24 = Utf8               temp
  
  ```

  

- 方法的名称和描述符

  保存的是`方法名、参数类型+返回值`

  ```java
  public void XX(int v){
  ...
  }
  
  对应字节码常量池数据为
    #21 = Utf8               XX  //方法名
    #22 = Utf8               (I)V //参数类型+返回值
  ```

  

#### 字符串常量池(`String Constant Pool`)

> 在JDK1.7及之后版本中，`字符串常量池`被移动到`Java堆`中(可能是因为方法区的内存空间太小)。
>
> - JDK1.7之前
>
>   `字符串常量池`的位置在`方法区`，此时存储的是**字符串对象**。
>
> - JDK1.7及之后
>
>   字符串常量池中的内容是在类加载完成，经过`验证、准备`阶段之后在`Java堆`中生成字符串对象实例，然后将该对象实例引用值存在`字符串常量池`中。**字符串常量池中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间进行存放的。**

在HotSpot VM里实现的`String Pool`对应一个`StringTable`类，实际是一个Hash表，默认值大小长度为`1009`(如果放入过多，导致Hash冲突使链表变长，导致查询性能大幅下降)。该`StringTable`在每个VM的实例只有一份，被所有的类共享。

在JDK1.7版本中，`StringTable`长度可以通过配置参数指定——`-XX:StringTableSize=${num}`指定长度。

##### 创建字符串对象

```java
// 编译期就已经确定该字面量，会直接进入class文件常量池中，在字符串常量池中会保存一个引用
String s0 = "Hello";
// 调用了String的构造函数，创建的字符串对象是在堆内存上
String s1 = new String("Hello");
```

##### 字面量何时进入常量池

1. 加载类的时候，那些字面量会进入到当前类的`运行时常量池`，不会进入全局的`字符串常量池`中
2. 当字面量赋值的时候，会翻译成字节码中的`ldc`指令，将常量从常量池中推送至栈顶。

#### 运行时常量池

> 在JDK1.7及之后的版本已将`运行时常量池`从`方法区`移了出来，在`Java堆`中开辟一块区域存放运行时常量池。
>
> 为了**存储class文件常量池中的符号信息**，在`解析`的时候会去查询`字符串常量池`，以保证运行时常量池所引用的字符串与`字符串常量池`中是一致的。

JVM在执行某个类的时候，必须经过**加载、链接(验证，准备，解析)、初始化**过程。

当类执行`加载`过程后，JVM将`class常量池`中的内容存放到`运行时常量池`中，已知`class文件常量池`中存储的内容是`字面量与符号引用`。

`准备`阶段在`Java堆`中生成字符串的实例对象，将生成的实例对象引用放置于`字符串常量池`。

`解析`阶段将`class文件常量池`中的`符号引用`翻译成`直接引用`也是存储于`运行时常量池`中。

##### 动态性

Java规范并不要求常量只在运行时才能产生，也就是表示*运行时常量池的内容不一定都来自于class文件常量池*，在运行时可以通过代码生成常量放置于`运行时常量池`中，例如`String.intern()`

##### String.intern()

> - JDK 1.7之前
>
>   `intern`的处理是：**先判断字符串是否存在于`字符串常量池`中，如果存在直接返回该常量；如果没有找到，则将字符串常量加入到`字符串常量池`中。**
>
> - JDK 1.7及之后
>
>   `intern`的处理是：先判断字符串是否存在于`字符串常量池`中，如果存在直接返回该常量；如果没找到，表示该字符串常量在堆中，然后把`Java堆`该对象的引用加入到`字符串常量池`中，以后别人拿到的就是该字符串常量的引用，实际字符串存在于堆中。

### 直接内存

> 直接内存并不是JVM的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，可能导致OOM的出现。

在JDK1.4新加入了`NIO`类，引入一种基于`通道(Channel)`和`缓冲区(Buffer)`的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存在`Java堆`的对象作为这块内存的应用进行操作。

## Java对象创建过程以及访问方式

### Java对象创建过程

在Java语言层面上，创建对象只需要调用`new`关键字。

在JVM中，实际需要执行以下几步：

#### 类加载检查

遇到一条`new`指令时，先检查指令对应的参数是否在`常量池`中可以定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，需要执行相应的`类加载过程`。

#### 分配内存

`类加载检查`通过后，JVM将为新生对象`分配内存`，对象所需大小在类加载完成后便可以确定。

这块内存由`Java堆`划分出来。内存的分配方式由**Java堆中内存是否规整**决定，而`内存是否规整`由**采用的垃圾收集器是否带有压缩整理功能决定**。

- **指针碰撞**

  > `Java堆内存规整`，把指针向空闲空间挪动对象大小的距离

  对应GC收集器：Serial、ParNew

  **关键看GC收集器采用了`标记-整理、标记-压缩、复制`算法进行回收**

- **空闲列表**

  > `Java堆内存不规整`，虚拟机维护一个列表记录内存块中的可用区域，在分配内存的时候，找到一块儿足够大的空间划分给对象实例

  对应GC收集器：CMS

  **关键看GC收集器采用了`标记-清除`算法进行回收**

##### 内存分配并发问题

创建对象是一个很频繁的事情，就会涉及一个很重要的问题——**线程安全**。作为虚拟机来讲，必须要保证线程安全，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试**

  > CAS是乐观锁的一种实现方式
  >
  > 乐观锁：假设没有冲突而去完成某项操作，若发生冲突就重试直到成功为止。

  采用这种方式可以保证更新操作的原子性。

- **TLAB**(本地线程分配缓存)

  > 每个线程预先在`Java堆`中分配一块内存，JVM在给对象分配内存时，首先在`TLAB`分配。如果分配的对象大于`TLAB`的剩余内存或`TLAB`内存已用尽时，再采用上述CAS方式进行内存分配。

#### 初始化零值

**内存分配完成时，虚拟机需要将分配到的内存空间初始化为零值(不包括对象头)。**这一步操作可以保证对象的实例字段在代码中可以不赋值就直接使用，程序也可以访问到这些字段的数据类型所对应的零值。

#### 设置对象头

`初始化零值`完成后，**虚拟机要对对象进行必要的设置**。将`类的元数据信息、对象的哈希码、对象的GC分代年龄`等信息，存放到`对象头`中。另外根据虚拟机运行状态的不同，如是否启用偏向锁等，对象头都会进行存储。

可以在`对象内存布局`这节看到对象头相关内容。

#### 执行`<init>`方法

从虚拟机角度来说，一个新的对象已经产生了。从代码角度来说，对象才刚开始创建，在执行`<init>`方法之前，所有的字段都还为零。一般执行完`new`指令后会接着执行`<init>`方法，把对象按照意愿进行初始化，这时就产生了一个真正可用的对象。



{%fullimage /images/Jvm对象创建过程.png,Jvm对象创建过程,Jvm对象创建过程%}



### 对象内存布局

对象内存布局分为以下三块区域：

#### 对象头(Header)

必须先了解 HotSpot虚拟机的对象(**对象头部分**)的内存布局：分为两部分

##### Mark Word

存储自身的运行时数据，如：`HashCode、GC分代年龄和锁信息`，这部分数据的长度在32和64位中的JVM中分别为32bit和64bit。**它是实现轻量级锁和偏向锁的关键。**

{% fullimage /images/MarkWord.png,Mark Word,Mark Word %}

##### 类型指针

存储指向方法区对象类型数据的指针，如果是数组对象的话，额外会存储数据的长度。JVM通过这个指针来确定该对象是哪个类的实例。

#### 实例数据(Instance Data)

对象真正存储的有效信息，即在代码里面所定义的各种类型的字段内容。

#### 对齐填充(Padding)

并非必然存在的，也没有特别的含义，仅仅起着**占位符**的作用。

### Java对象访问方式

Java程序通过栈上的refrence数据来操作堆上的具体对象。



#### 句柄访问

`Java堆`可能会划分一块内存作为句柄池，refrence存储的就是`对象的句柄地址`，句柄中包含了对象的实例数据与类型数据的各自具体地址信息。

 {% fullimage /images/jvm/get_object_by_handle.png, alt,流程图 %}

**refrence中存储的稳定句柄地址，在对象被移动时(例如GC时)只会改变句柄中的实例数据指针，refrence本身不需要修改。**

#### 直接访问

`Java堆`中对象的内存布局就必须考虑如何设置访问类型数据的相关信息，refrence直接存储的就是`对象地址`。

 {% fullimage /images/jvm/get_object_direct.png, alt,流程图 %}

**最大好处就是速度快，节省了一次指针定位的时间开销。**在HotSpot虚拟机中很常用。

## 类加载机制

> JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为虚拟机的类加载机制。

### 类的生命周期

一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历**加载、验证、准备、解析、初始化、使用、卸载**七个阶段，其中`准备、解析、初始化`称为**连接**。

{% fullimage /images/jvm/class_lifecycle.png, 类的生命周期,类的生命周期 %}

#### 类的卸载

> 由JVM自带的类加载器(`BootstrapClassLoader根加载器、ExtensionClassLoader拓展加载器、ApplicationClassLoader应用加载器`)所加载的类，在虚拟机的生命周期中，都不会被卸载。
>
> **只有由用户自定义的类加载器所加载的类是可以被卸载的。**

类卸载的触发条件：

- 该类所有的实例都已被GC，在JVM中不存在任何该类的实例
- 加载该类的ClassLoader也被GC
- 该类的Class对象没有被任何地方调用，反射也无法访问该类

执行类卸载后，在方法区的二进制数据会被卸载。

### 类加载过程

> 类加载过程包括上述的五步：`加载、验证、准备、解析、初始化`。

#### 加载

> JVM找到class文件问生成字节流，然后根据字节流创建java.lang.class对象的过程。

JVM在此过程需要完成三件事：

- 通过一个类的 `全限定名(包名+类名)`来查找.class文件，并生成二进制字节流(**使用ClassLoader进行加载**)。其中字节码来源不一定是.class文件，也可以是jar包、zip包，甚至是来源于网络的字节流。
- 将字节流所代表的静态存储结构转化为JVM的特定的数据结构，并存储在`方法区`
- 在内存中创建一个`java.lang.Class`类型的对象，作为方法区这个类的各种数据的访问入口。

一个非数组类的加载阶段(加载阶段获取二进制字节流的动作)是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式(重写类加载器的`findClass()`或`loadClass()`)。

对于数组类而言，数组类本身不通过类加载器创建，由JVM直接在内存中动态创建。



##### 加载时机

一个项目经过编译之后，往往会产生大量.class文件，程序运行时，JVM不会一次性将这些文件全部加载到内存中，而是有一定的加载时机去进行加载操作。

###### 隐式装载

在程序运行过程中，当碰到通过`new`生成对象时，系统会隐式调用ClassLoader装载对应class到内存中(`loadClass()`)

```jaba
protected Class<?> loadClass(String name, boolean resolve)
```



###### 显示装载

在编写源代码时，主动调用`Class.forName()`也会进行class装载操作。执行时会默认调用静态代码块`static{...}`以及分配静态变量存储空间

```java
public static Class<?> forName(String name, /*要加载的Class名字*/
										 boolean initialize,/*默认为true,是否需要初始化-调用静态代码快及静态变量初始化*/
                               ClassLoader loader/*指定ClassLoader进行加载*/)
```

#### 验证

> 确保.class文件的字节流中包含的信息符合虚拟机规范的全部要求，并且不会危及虚拟机本身的安全。

若代码被反复验证和使用过，可以通过配置`-XVerify:none`关闭大部分的验证措施，缩短加载时间

主要包含以下四个方面的验证：

##### 文件格式验证

> 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。

这一阶段可能包含以下验证点：

- 是否以魔数`0xCAFEBABE`开头
- 主次Java版本号是否在当前JVM接受范围内
- ...

##### 元数据验证

> 对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java语言规范的要求

这一阶段可能包含以下验证点：

- 这个类是否有父类(除了 java.lang.Object外，都应该有父类)
- 这个类是否继承了不允许被继承的类(被final修饰的类)
- ...

##### 字节码验证

> 通过数据流分析和控制流分析，确定程序语义是合法、符合逻辑的

这一阶段可能包含以下验证点：

- 任意时刻操作数栈的数据类型与指令代码序列都配合工作
- 任何跳转指令都不会跳到方法体以外的的字节码指令中
- ...



##### 符号引用验证

> 发生于JVM将`符号引用`转换`直接引用`的时候。
>
> 对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验。通俗来说就是，该类是否缺少或者被禁止访问她依赖的某些外部类、方法、字段等资源。

这一阶段可能包含以下验证点：

- 符号引中通过字符串描述的全限定名能否找到对应的类
- 在指定类是否存在符合方法的字段描述符及简单名称所描述的方法和字段
- ...



#### 准备

> 正式为类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置为变量初始值(`零值`)的阶段，不包括实例变量。

```java
public static int value = 100;
```

在准备阶段，JVM会为value分配内存，并将其设置为0。真正的100需要在初始化阶段进行设置。

| 数据类型  | 零值     |
| --------- | -------- |
| Int       | 0        |
| long      | 0L       |
| short     | (short)0 |
| char      | ‘\u0000’ |
| byte      | (byte)0  |
| boolean   | false    |
| float     | 0.0f     |
| double    | 0.0d     |
| reference | Null     |

以上是通常情况下初始值是`零值`，还是会存在一些特殊情况——静态常量。

```java
public static final int value = 100;
```

此时value的初始值就为100。

#### 解析

> 把常量池中的符号引用转换为直接引用，也就是具体的内存地址。JVM会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。

##### 符号引用

以一组符号描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。

##### 直接引用

直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。**对象真正的内存地址**



解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。

#### 初始化

> 类加载的最后一个步骤，直到这一步，JVM才真正开始执行类中编写的Java代码。
>
> **执行类构造器<clinit>()的过程，并真正初始化类变量(前面准备过程的零值在此时被赋予真正的值)**

##### 初始化执行时机

JVM规范严格规定类class初始化的时机，主要有以下几种情况：

- 虚拟机启动时，初始化包含`main()`的主类

- 遇到`new(创建对象实例)、getstatic(读取类静态字段)、putstatic(设置类静态字段)、invokestatic(调用类的静态方法)`这四条字节码指令时，如果目标对象没有经过初始化，需要执行初始化操作

- 当需要对类进行反射调用时，如果类型没有进行初始化，需要执行初始化操作

- 当初始化子类的时候，发现父类还没有进行初始化，需要执行父类的初始化操作

- 在第一次调用`java.lang.invoke.MethodHandle`实例时，需要初始化MethodHandle指向方法所在的类。*JDK7之后*

- 当一个接口中定义了JDK8新加入的默认方法(`default`关键字修饰)，如果实现了这个接口的类进行初始化，那么接口需要执行初始化操作

  ```java
  public interface DefaultInterface {
      //默认接口方法
      default void test(){
          System.err.println("Default Interface Method");
      }
  
      void test1();
  }
  ```

以上6种情况在JVM中被称为**主动引用**，除此之外的其他应用方式都被称为**被动引用**，不会出发Class的初始化操作。

例如以下几种情况：

- 通过子类调用父类的静态变量，不会导致子类初始化

  ```java
  public class Parent{
    public static int value = 1;
    static {
      System.out.println("Parent");
    }
  }
  
  public class Child extends Parent{
    static {
      System.out.println("Child");
    }
  }
  
  public class Test{
    public static void main(String[] args){
      Child.value = 2;
    }
  }
  
  日志输出
  java NonInitTest
  Parent
  ```

  只有直接定义这个字段的类才会被初始化，所以子类不会进行初始化。

- 静态常量引用时，不会出发定义常量类的初始化

  ```java
  public class ConstClass{
    static {
      System.out.println("Const");
    }
    
    public static final String value ="Value";
  }
  
  public class Test{
    public static void main(String[] args){
      System.out.println(ConstClass.value);
    }
  }
  
  日志输出
  Value
  ```

  常量实际在编译阶段直接存储在Test类的常量池中，已于ConstClass无关，所以不会导致初始化。



##### Class初始化和对象的创建顺序

在代码中使用`new`创建对象实例时，类中`静态代码块、非静态代码块、构造函数`之间的执行顺序是如何的？

```java
Parent.java
 
public class Parent {
    public static String value = "Parent";

    static {
        System.err.println("Parent Static Block");
    }

    {
        System.err.println("Parent non-static Block");
    }

    public Parent(){
        System.err.println("Parent Constructor");
    }
}


Child.java

public class Child extends Parent{
    static {
        System.err.println("Child Static Block");
    }

    {
        System.err.println("Child Non-Static Block");
    }

    public Child(){
        System.err.println("Child Constructor");
    }
}

Test.java

public class Test {
    public static void main(String[] args) {
        Parent p =new Child();
        System.err.println("~~~~~~~~~~");
        p = new Child();
    }
}
```

输出内容为

```java
Parent Static Block
Child Static Block
Parent non-static Block
Parent Constructor
Child Non-Static Block
Child Constructor
~~~~~~~~~~
Parent non-static Block
Parent Constructor
Child Non-Static Block
Child Constructor
```

按照上述输出内容，可以总结初始化顺序为：

```java
1.父类静态变量和静态代码块
2.子类静态变量和静态代码块
3.父类普通成员变量和普通代码块
4.父类的构造函数
5.子类普通成员变量和普通代码块
6.子类的构造函数
```

基础规则：**静态变量/静态代码块 -> 普通变量/普通代码块 -> 构造函数**。



特殊情况

```java
public class StaticTest {
    public static void main(String[] args) {
        staticFun();
    }
    //特殊之处
    static StaticTest st = new StaticTest();

    static {
        System.err.println("1");
    }

    {
        System.err.println("2");
    }

    StaticTest() {
        System.err.println("3");
        System.err.println("a" + a + " b" + b);
    }

    public static void staticFun() {
        System.err.println("4");
    }

    int a = 100;
    static int b = 100;
}

```

TODO：需要好好分析流程。

### 类加载器

<!--包括Android加载器-->



### 双亲委托模型





## JVM内存分配策略



## JVM垃圾回收机制(GC)



## Java内存模型(JMM)



## Class文件结构(字节码)



## DVM&ART(Android虚拟机)



## 参考链接

[彻底弄懂Java中的常量池](https://cloud.tencent.com/developer/article/1450501)

[字符串常量池相关问题](https://www.cnblogs.com/gxyandwmm/p/9495923.html)