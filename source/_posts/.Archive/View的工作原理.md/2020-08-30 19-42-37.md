---
title: View的工作原理
date: 2018-12-14 16:47:21
tags: Android
top: 11
---

# View的工作原理

<!--MeasureSpec是什么？有什么作用？，自定义View/ViewGroup需要注意什么？invalidate()和postInvalidate()的区别？,invalidate和postInvalidate的区别及使用 Requestlayout，onlayout，onDraw，DrawChild区别与联系  View刷新机制  View绘制流程  计算一个view的嵌套层级（递归）  onMeasure的具体过程，先measure子view还是自己  onDraw的具体过程，先draw子view还是自己  实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展 view的工作原理及measure、layout、draw流程。哪一个流程可以放在子线程中去执行？draw方法中需要注意的问题？Invalidate、postInvalidate、requestLayout应用场景-->

{% fullimage /images/View工作原理.png,View工作原理,View工作原理%}

<!-- more -->

## ViewRoot以及DecorView的概念和何时关联

### ViewRoot

*ViewRoot对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程均需通过ViewRoot完成。*

### DecorView

**DecorView是整个Window界面的最顶层View。** *可以使用Android Studio自带的Layout Inspector查看页面层级*

一般情况下`DecorView`会包含一个竖直方向的LinearLayout，该LinearLayout分为上下两个部分，上面是标题栏(`titlebar`)，下面是内容栏(`继承自FrameLayout 且id为content`)。因此我们设置Activity的布局方法叫做`setContentView()`，因为他们都被加进了`id为content的FrameLayout`中。

我们可以利用`ViewGroup content = findViewById(R.android.id.content)`获取conetnt。使用`content.getChildAt(0)`获取设置的Activity布局。

```java
// ../android/app/Activity.java
    public <T extends View> T findViewById(@IdRes int id) {
        //从Window中去获取View
        return getWindow().findViewById(id);
    }

// ../android/view/Window.java
    public <T extends View> T findViewById(@IdRes int id) {
        //从DecorView获取View
        return getDecorView().findViewById(id);
    }
```

所有的View都会从DecorView中开始检索，所以**View层的事件都会先经过DecorView，再传递到我们定义的View上**。

### 如何关联

当Activity创建时，最终是调用到`ActivityThread`的`handleLaunchActivity`来创建Activity。

```java
// ../android/app/ActivityThread.java
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
 ...
      //创建一个Activity 会调用到onCreate()方法 从而完成DecroView的创建
      Activity a = performLaunchActivity(r, customIntent);
        if (a != null) {
            r.createdConfig = new Configuration(mConfiguration);
            reportSizeConfigurations(r);
            Bundle oldState = r.state;
            
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
            ...
        }
    ...
}
```

上述方法后续调用到了`handleResumeActivity()`,在这个方法中调用到了`WindowManager.addView()`将View传递至WindowManager

```java
// ../android/app/ActivityThread.java
final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
         ActivityClientRecord r = mActivities.get(token);
        if (!checkAndUpdateLifecycleSeq(seq, r, "resumeActivity")) {
            return;
        }
        unscheduleGcIdler();
        mSomeActivitiesChanged = true;

        // 在这里会调用到生命周期中的onResume方法
        r = performResumeActivity(token, clearHide, reason);
        ...
            if(r!=null){
                ...
                final Activity a = r.activity;
                ...
                //获得当前Activty的Window对象
                r.window = r.activity.getWindow();
                //获得当前Window的DecorView
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                //获得当前Activity的WindowManager对象
                ViewManager wm = a.getWindowManager();
                WindowManager.LayoutParams l = r.window.getAttributes();
                a.mDecor = decor;
                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
                l.softInputMode |= forwardBit;
                if (r.mPreserveWindow) {
                    a.mWindowAdded = true;
                    r.mPreserveWindow = false;
                    ViewRootImpl impl = decor.getViewRootImpl();
                    if (impl != null) {
                        impl.notifyChildRebuilt();
                    }
                }
                if (a.mVisibleFromClient) {
                    if (!a.mWindowAdded) {
                        a.mWindowAdded = true;
                        //将DecorView添加到PhoneWindow中
                        wm.addView(decor, l);
                    } else {
                        a.onWindowAttributesChanged(l);
                    }
                }

            // If the window has already been added, but during resume
            // we started another activity, then don't yet make the
            // window visible.
            } else if (!willBeVisible) {
                if (localLOGV) Slog.v(
                    TAG, "Launch " + r + " mStartedActivity set");
                r.hideForNow = true;
            }    
            }
...
    }
```

后续调用到了`wm.addView()`。将对应的DecorView传递进去。

```java
// ../android/view/WindowManagerImpl.java
public final class WindowManagerImpl implements WindowManager {
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    private final Window mParentWindow;
    ...
    @Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        //调用到了WindowManagerGlobal中的addView
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }   
    ...
}

// ../android/view/WindowManagerGlobal.java
public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        ...

        ViewRootImpl root;
        View panelParentView = null;
        synchronized (mLock) {
            ...
            //创建了ViewRootImpl实例
            root = new ViewRootImpl(view.getContext(), display);
            view.setLayoutParams(wparams);
            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
            // do this last because it fires off messages to start doing things
            try {
                //调用setView 将传进来的DecorView添加到PhoneWindow中。 
                root.setView(view, wparams, panelParentView);
            } catch (RuntimeException e) {
                // BadTokenException or InvalidDisplayException, clean up.
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
                throw e;
            }
        }
    }

```

上述流程走完后，就把DecorView加载到了Window中。**这个流程中将ViewRootImpl对象与DecorView进行了关联**。

## View绘制流程

上节中，调用了`ViewRootImpl.setView(decorView)`将DecorView与ViewRootImpl进行了关联。View的绘制流程就是从ViewRoot开始的。

```java
 public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
     synchronized(this){
         //传进来的DecorView作为全局变量使用
          mView = view;
         ...
          // Schedule the first layout -before- adding to the window
                // manager, to make sure we do the relayout before receiving
                // any other events from the system.
          //绘制整个布局
          requestLayout();   
         ...
     }   
 }

//请求刷新整个布局
    @Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            checkThread();
            mLayoutRequested = true;
            scheduleTraversals();
        }
    }

    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //添加同步屏障
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            if (!mUnbufferedInputDispatch) {
                scheduleConsumeBatchedInput();
            }
            notifyRendererOfFramePending();
            pokeDrawLockIfNeeded();
        }
    }

    final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            doTraversal();
        }
    }
    final TraversalRunnable mTraversalRunnable = new TraversalRunnable();

    void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            //移除同步屏障
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            if (mProfile) {
                Debug.startMethodTracing("ViewAncestor");
            }
            //这里开始View的绘制流程
            performTraversals();

            if (mProfile) {
                Debug.stopMethodTracing();
                mProfile = false;
            }
        }
    }
```

`ViewRootImpl.setView()`中最后调用到了`performTraversals()`在这个方法中开始View的绘制流程

```java
private void performTraversals() {
  ...
   boolean layoutRequested = mLayoutRequested && (!mStopped || mReportNextDraw);
   
   ...
   if (!mStopped || mReportNextDraw) {
      int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
	  int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
      ...
        if(layoutRequested){
          //开始Measure过程，定义View的宽高
          performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
          ...
        }
   }
  
    final boolean didLayout = layoutRequested && (!mStopped || mReportNextDraw);
    if(didLayout){
        //开始Layout过程，决定View的位置
        performLayout(lp, mWidth, mHeight);
        ...
    }
    
     if (!cancelDraw && !newSurface) {
            if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
                for (int i = 0; i < mPendingTransitions.size(); ++i) {
                    mPendingTransitions.get(i).startChangingAnimations();
                }
                mPendingTransitions.clear();
            }
            //开始Draw过程，决定了View的显示，这个过程结束才可以看到内容
            performDraw();
     }
}        
```

通过以上流程分析：**View的绘制流程是从`ViewRootImpl`中开始的，先调用`performTraversals()`开始绘制，随后调用内部的`performMeasure()`开始Measure过程，调用`performLayout()`，开始Layout过程，最后调用`performDraw()`开始Draw，完成后就可以现在在屏幕上。**

{% fullimage /images/View绘制流程.png,View绘制流程,View绘制流程 %}

如上图所示，`performTraversals()`依次调用`performMeasure()，performLayout(),performDraw()`完成View的绘制。

## MeasureSpec

### 结构

> MeasureSpec代表一个32位int值，高2位代表SpecMode(测量模式)，低30位代表SpecSize(某种测量模式下的规格大小)。

作用：父控件提供给子View的一个参数，作为设定自身大小参考，实际大小还是有子View自身决定。

```java
 public static class MeasureSpec {
        private static final int MODE_SHIFT = 30;
        private static final int MODE_MASK  = 0x3 << MODE_SHIFT;

        /** @hide */
        @IntDef({UNSPECIFIED, EXACTLY, AT_MOST})
        @Retention(RetentionPolicy.SOURCE)
        public @interface MeasureSpecMode {}
     
      public static final int UNSPECIFIED = 0 << MODE_SHIFT;
      public static final int EXACTLY     = 1 << MODE_SHIFT;
      public static final int AT_MOST     = 2 << MODE_SHIFT;
      public static int makeMeasureSpec(@IntRange(from = 0, to = (1 << MeasureSpec.MODE_SHIFT) - 1) int size,
                                          @MeasureSpecMode int mode) {
            if (sUseBrokenMakeMeasureSpec) {
                return size + mode;
            } else {
                return (size & ~MODE_MASK) | (mode & MODE_MASK);
            }
          
      public static int makeSafeMeasureSpec(int size, int mode) {
            if (sUseZeroUnspecifiedMeasureSpec && mode == UNSPECIFIED) {
                return 0;
            }
            return makeMeasureSpec(size, mode);
        }
          
      @MeasureSpecMode
       public static int getMode(int measureSpec) {
            //noinspection ResourceType
            return (measureSpec & MODE_MASK);
        }
          
       public static int getSize(int measureSpec) {
            return (measureSpec & ~MODE_MASK);
        }
```

`MeasureSpec`涉及到了很多的位运算，会新开一篇文章介绍。{% post_link 位运算 %}

`SpecMode`分为三类：

- UNSPECIFIED：未指定模式。父控件不对子控件家人和我束缚，子元素可以为任意大小，一般用于系统内部的测量。比如ScrollView
- EXACTLY：精确模式。父控件为子View指定精确大小，希望子View完全按照自己给的尺寸处理大小。一般是设置了明确的值或是`MATCH_PARENT`
- AT_MOST：最大模式。父控件为子View指定最大尺寸，希望子View不要超过这个尺寸。一般对应`WRAP_CONTENT`

### MeasureSpec与LayoutParams的对应关系

每一个View，都持有一个MeasureSpec，里面保存了View的尺寸。我们也可以使用`LayoutParams`指定View的尺寸。所以在View测量的时候，系统会将`LayoutParams`在父容器的约束下转换成`MeasureSpec`，然后根据转换后的值确定宽高。

**转换后的MeasureSpec是由LayoutParams和父容器的MeasureSpec一起决定的。**

#### DecorView转换MeasureSpec

> DecorView的转换由Window的尺寸和自身的LayoutParams决定。

```java
// ../android/view/ViewRootImpl.java
private void performTraversals() {
    ...
       //DecorView Measure过程
       int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
       int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
       performMeasure(childWidthMeasureSpec,childHeightMeasureSpec)
    ...  
}

//在方法中生成了DecoeView的MeasureSpec 根据Window的尺寸和自身的LayoutParams
private static int getRootMeasureSpec(int windowSize/*Window尺寸*/, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {
       
        case ViewGroup.LayoutParams.MATCH_PARENT:
            //MeasureSpec中的specSize就是窗口尺寸,specMode为EXACTLY 精确模式
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            //MeasureSpec中的specSize为窗口尺寸,specMode为aT_MOST 最大模式，最大值为窗口尺寸
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            //MeasureSpec中的specSize为固定尺寸,specMode为EXACTLY 精确模式
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
    }

```



#### 普通View转换MeasureSpec

> 普通View的MeasureSpec由父容器的MeasureSpec和自身的LayoutParams决定。

| 下：childLayoutParams 右：parentSpecMode | EXACTLY                                    | AT_MOST                                    | UNSPECIFIED           |
| ---------------------------------------- | ------------------------------------------ | ------------------------------------------ | --------------------- |
| 固定大小                                 | Exactly<br>childSize                       | Exactly<br/>childSize                      | Exactly<br/>childSize |
| match_parent                             | Exactly<br/>parentSize(父容器剩余空间)     | AT_MOST<br/>parentSize(最大父容器剩余空间) | UNSPECIFIED<br>0      |
| wrap_content                             | AT_MOST<br/>parentSize(最大父容器剩余空间) | AT_MOST<br/>parentSize(最大父容器剩余空间) | UNSPECIFIED<br/>0     |

根据`ViewGroup.getChildMeasureSpec()`得出上表。

## View工作流程

> 主要是指`measure(测量)`,`layout(布局)`,`draw(绘制)`三大流程。

### measure

measure过程分为两种。

#### View的measure过程

主要是由`measure()`方法完成

```java
// ../android/view/View.java
public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
    //这个类是final的，所以子类无法重新该方法
    ...
    onMeasure(widthMeasureSpec,heightMeasureSpec);
        ...
}
```

在`measure()`中调用`onMeasure()`去进行实际的测量

```java
//../android/view/View.java
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(
            getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    }

   //设置View的宽高
   protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
        boolean optical = isLayoutModeOptical(this);
        if (optical != isLayoutModeOptical(mParent)) {
            Insets insets = getOpticalInsets();
            int opticalWidth  = insets.left + insets.right;
            int opticalHeight = insets.top  + insets.bottom;

            measuredWidth  += optical ? opticalWidth  : -opticalWidth;
            measuredHeight += optical ? opticalHeight : -opticalHeight;
        }
        setMeasuredDimensionRaw(measuredWidth, measuredHeight);
    }

    private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {
        mMeasuredWidth = measuredWidth;
        mMeasuredHeight = measuredHeight;
        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
    }

    //返回View的MeasureSpec中的specSize
    public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
        //这段代码中可以分析得出 一个直接继承View的自定义View 定义为wrap_content和match_parent大小都是一致的.
            result = specSize;
            break;
        }
        return result;
    }

    protected int getSuggestedMinimumHeight() {
        return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());
    }

//如果View没有设置背景，返回minWidth值，默认为0。若设置了背景就取背景宽度和最小宽度中的最大值返回。
    protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
    }

    
// ../android/graphics/drawable/Drawable.java
public int getMinimumWidth(){
    final int intrinsicWidth = getIntrinsicWidth();
    return intrinsicWidth > 0 ? intrinsicWidth : 0;
}


```

{% fullimage /images/View-Measure.png,View的Measure过程,View的Measure过程%}

结合上述流程图，简单分析View的Measure过程

- 系统在绘制开始时回去调用`View.measure()`，这个类是final的们无法被重写
- 后续调用`View.onMeasure()`,自定义View时可以按照自己的需求对这个方法进行重写
- `onMeasure()`中调用到`setMeasureDimension()`对View进行宽高的设置
- 需要使用`getDefaultSize()`去获取最终显示出的宽高
- 在`getDefaultSize()`中需要对传进来的`MeasureSpec`进行分析处理
  - SpecMode若为`UNSPECIFIED`，则最终尺寸为传进来的`SpecSize`
  - SpecMode为`AT_MOST`,`EXACTLY`，还需要额外判断View是否有背景
    - 有背景，最终尺寸就为View的最小尺寸和背景尺寸的最大值
    - 没背景，最终尺寸就为View的最小尺寸
- 取到最终尺寸后，数据回溯到`onMeasure()`中，即完成测量(`Measure`)过程

在上述分析中，自定义View中使用`wrap_content`时，specMode为`AT_MOST`，尺寸为父控件剩余大小，效果与使用`match_parent`一致。这也是自定义View中常碰到的问题 *为何自定义View是wrap_content无效？* 解决方法就是 自己重写`onMeasure()`对`wrap_content`特殊处理。

```java
public void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
    super.onMeasure(widthMeasureSpec,heightMeasureSpec);
    int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
    int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
    int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
    int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
    
    if(widthSpecMode = MeasureSpec.AT_MOST && heightSpecMode = MeasureSpec.AT_MOST){
        setMeasureDimension(mWidth,mHeight);
    }else if(widthSpecMode = MeasureSpec.AT_MOST){
        setMeasureDimension(mWidth,heightSpecSize);
    }else if(heightSpecMode = MeasureSpec.AT_MOST){
        setMeasureDimension(widthSpecSize,mHeight);
    }
    
}
```

#### ViewGroup的measure过程

> 除了完成自身的measure过程之外，还要去遍历调用所有子元素的measure方法，各个子元素再去递归执行这个过程。
>
> **先Measure子View，再Measure自己**

ViewGroup中没有定义`onMeasure()`，定义了一个`measureChildren()`。

```java
// ../android/view/ViewGroup.java
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
        final int size = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i < size; ++i) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {
                //遍历对每一个子元素进行测量过程
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
            }
        }
    }
```

循环调用`measureChild()`

```java
// ../android/view/ViewGroup.java
protected void measureChild(View child, int parentWidthMeasureSpec,
            int parentHeightMeasureSpec) {
        //获得子View的LayoutParams
        final LayoutParams lp = child.getLayoutParams();
        //
        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }

 //子View的MEasureSpec由父View的MEasureSpec以及自身的LayoutParams共同决定
    public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        //padding代指父View已占用的空间，子View无法使用，所以子View的空间需要减去padding部分
        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    }
```

由于ViewGroup有不同布局的需要，很难统一，所以没有提供统一的`onMeasure()`方法，而是让子类自己去实现`onMeasure()`。

{% fullimage /images/ViewGroup-Measure.png,ViewGroup测量过程,ViewGroup测量过程%}

根据上述流程图，简单总结一下：

- ViewGroup调用自身的`measureChildren()`，里面遍历自己的子View
- 遍历后调用`measureChild()`，准备给每一个子View计算它的`MeasureSpec`
- 调用`getChildMeasureSpec()`计算子View的`MeasureSpec`，需要结合父布局的`MeasureSpec`以及子View的`LayoutParams`共同得出结果
- 调用子View的`measure()`，完成子View的测量过程。

- #### 拓展

  1. 在Activity启动时获取View的尺寸？
     - 在 Activity#onWindowFocusChanged 回调中获取宽高。<br>`当Activity得到焦点或失去焦点的时候，这个方法都会被频繁调用`
     - view.post(runnable)，在 runnable 中获取宽高。
       `利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。`
     - ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。
       `监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露`
     - 调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高<br>`手动对view进行measure来得到View的尺寸。`

### layout

>ViewGroup用来确定子元素的位置，当ViewGroup位置被确定后，在`onLayout()`中遍历所有子View，并调用其`layout()`。
>
>**先layout自身后layout子元素。**

#### View的layout过程

主要是由View的`layout()`方法实现

```java
// ../android/view/View.java   
public void layout(int l, int t, int r, int b) {
        if ((mPrivateFlags3 & PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        
        //左上角顶点距父容器左边的距离
        int oldL = mLeft;
        //左上角顶点距父容器上边的距离
        int oldT = mTop;
        //右下角顶点距父容器上边的距离
        int oldB = mBottom;
        //右下角顶点距父容器上边的距离
        int oldR = mRight;
        //
        boolean changed = isLayoutModeOptical(mParent) ?
                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

        if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
            onLayout(changed, l, t, r, b);
            ...
        }
        ...
    }

//由于子View下是没有子类了，所以该方法内不没有任何代码实现 一般自定义View是不需要重写该方法的
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    
    }

private boolean setOpticalFrame(int left, int top, int right, int bottom) {
        Insets parentInsets = mParent instanceof View ?
                ((View) mParent).getOpticalInsets() : Insets.NONE;
        Insets childInsets = getOpticalInsets();
        //根据特效边框重新计算四个顶点的位置，然后调用setFrame重新计算
        return setFrame(
                left   + parentInsets.left - childInsets.left,
                top    + parentInsets.top  - childInsets.top,
                right  + parentInsets.left + childInsets.right,
                bottom + parentInsets.top  + childInsets.bottom);
    }

protected boolean setFrame(int left, int top, int right, int bottom) {
             boolean changed = false;

        if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
            changed = true;

            // Remember our drawn bit
            int drawn = mPrivateFlags & PFLAG_DRAWN;

            int oldWidth = mRight - mLeft;
            int oldHeight = mBottom - mTop;
            int newWidth = right - left;
            int newHeight = bottom - top;
            boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);

            // Invalidate our old position
            invalidate(sizeChanged);
            //重新计算View的四个顶点距父布局左上边框的距离
            mLeft = left;
            mTop = top;
            mRight = right;
            mBottom = bottom;
            mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);
            ...
        }
}


//判断当前View是否存在阴影或者外发光等边框效果
public static boolean isLayoutModeOptical(Object o) {
        return o instanceof ViewGroup && ((ViewGroup) o).isLayoutModeOptical();
    }
```

{% fullimage /images/View-Layout.png,View的Layout过程,View的Layout过程%}

按照流程图总结一下：

- View调用`layout()`开始布局过程(`确定最终宽高以及四个顶点的位置`)
- 根据是否有边缘效果(`例如发光，阴影`)
  - 有边缘效果，调用`setOpticalFrame()`去除边缘的影响，最终还是调用`setFrame()`设立自己的四个顶点
  - 无边缘效果，调用`setFrame()`设立自己的四个顶点
- 最后调用`onLayout()`最终确立宽高以及四点坐标。



#### ViewGroup的layout过程

当有子View存在的时候，需要遍历子View进行`layout`过程。即需要在`onLayout()`方法实现子View的`layout`。

```java
//源码与上述相同 由于ViewGroup中所有子View的layout都需要实现，所以需要实现 onLayout() 方法
protected void onLayout(boolean changed,int left,int top,int right,int bottom){
    for (int i =0 ; i <getChildCount();i++){
        View child = getChildAt(i);
        
        //在这里可以添加 顶点变化逻辑
        int childTop = Top;
        int childLeft = Left;
        int childBottom = Bottom;
        int childRight = Right;
         
        ...
        setChildFrame(child,childLeft,childTop,childRight,childBottom);
    }
}

private void setChildFrame(child,int l,int t,int r,int b){
    //按照上一节流程走
    child.layout(l,t,r,b);
}
```

{% fullimage /images/ViewGroup-Layout.png,ViewGroup的Layout过程,ViewGroup的Layout过程%}

按照流程图简单总结一下：

- 先调用ViewGroup的`layout()`，先对ViewGroup进行布局过程
- 在ViewGroup的`onLayout()`中实现子View的遍历布局过程
- 对遍历的子View按照ViewGroup的要求进行顶点坐标的计算，计算完成后调用子View的`layout()`



拓展：

1. View的测量宽/高(`getMeasureWidth()/getMeasureHeight()`)与最终得到的宽/高(`getWidth()/getHeight()`)有什么区别？

   ```java
   //	获得View在测量过程中的宽
   public final int getMeasuredWidth() {
           return mMeasuredWidth & MEASURED_SIZE_MASK;
       }
   //	获得View在测量过程中的高
   public final int getMeasuredHeight() {
           return mMeasuredHeight & MEASURED_SIZE_MASK;
       }
   //	上节 measure 源码分析中就是调用了该方法 进行View的测量
   private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {
           mMeasuredWidth = measuredWidth;
           mMeasuredHeight = measuredHeight;
           mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
       }
   //获得View最终宽
   public final int getWidth() {
           return mRight - mLeft;
       }
   //获得View最终高
   public final int getHeight() {
           return mBottom - mTop;
       }
   ```

   > 两者的比较



| 类型                                                      | 何时赋值            | 赋值方法                                  | 使用场景                        |
| :-------------------------------------------------------- | ------------------- | ----------------------------------------- | ------------------------------- |
| View测量结束宽/高<br>getMeasureWidth()/getMeasureHeight() | View的`measure`过程 | `setMeasureDimension()`                   | 在`onLayout()`获取View的宽/高   |
| View最终宽/高<br>getWidth()/getHeight()                   | View的`layout`过程  | `layout()`对top,left,right,bottom进行操作 | `onLayout()`结束后获取最终宽/高 |

   **一般情况下，二者返回的数据是相同的，除非人为对View的`layout()`进行重写。**

   ```java
   public void layout(int l,int t,int r,int b){
       super.layout(j,t,r+100,b+100);
   }
   ```

   上述代码就会导致View最终结果与测量时不同。

### draw

> draw作用主要将View绘制在屏幕上面
>
> **draw过程，先draw自身再draw子View**

#### View的draw过程

View的draw过程，从`View.draw()`开始

```java
// ../android/view/View.java
public void draw(Canvas canvas) {
    //标记当前View是否需要绘制背景
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&
                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    
    int saveCount;
        //1. 绘制背景
    if (!dirtyOpaque) {
            drawBackground(canvas);
        }
    final int viewFlags = mViewFlags;
    //是否有水平边缘
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    //是否有竖直边缘
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if(!horizontalEdges && !verticalEdges){
       // 3.绘制View本身
          if (!dirtyOpaque) onDraw(canvas);

       // 4.绘制子View
          dispatchDraw(canvas);
        
       // 6.绘制装饰 例如滚动条
          onDrawForeground(canvas);
        
    ...
       return; 
    }
    
    //如果有竖直边缘或者水平边缘 例如divide
    
    // 2. 保存当前Canvas层
        saveCount = canvas.getSaveCount();
        int solidColor = getSolidColor();
        if (solidColor == 0) {
            final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
            if (drawTop) {
                canvas.saveLayer(left, top, right, top + length, null, flags);
            }
            if (drawBottom) {
                canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
            }
            if (drawLeft) {
                canvas.saveLayer(left, top, left + length, bottom, null, flags);
            }
            if (drawRight) {
                canvas.saveLayer(right - length, top, right, bottom, null, flags);
            }
        } else {
            scrollabilityCache.setFadeColor(solidColor);
        }
    ...
        // 3.绘制View本身
          if (!dirtyOpaque) onDraw(canvas);

       // 4.绘制子View
          dispatchDraw(canvas);
    
    ...
        // 5.绘制边缘效果 例如阴影
        canvas.restoreToCount(saveCount);
    ...
        
       // 6.绘制装饰 例如滚动条
          onDrawForeground(canvas);
    ...
    
}

//绘制View本身的背景
private void drawBackground(Canvas canvas) {
        final Drawable background = mBackground;
        if (background == null) {
            return;
        }
        //设置View的背景边界
        setBackgroundBounds();
        ...
          
        final int scrollX = mScrollX;
        final int scrollY = mScrollY;
        if ((scrollX | scrollY) == 0) {
            background.draw(canvas);
        } else {
            //将画布偏移 然后在偏移后的画布上进行背景绘制
            canvas.translate(scrollX, scrollY);
            background.draw(canvas);
            canvas.translate(-scrollX, -scrollY);
        }
    }

//绘制View本身的内容
protected void onDraw(Canvas canvas) {
    // 默认空实现 需要子类复写该方法以实现内容的绘制 ，自定义View中必须执行该方法
    }

//绘制子View的内容
protected void dispatchDraw(Canvas canvas) {
    //由于View不存在子View，所以不需要实现
    }

//绘制装饰 例如滚动条 前景图片
public void onDrawForeground(Canvas canvas) {
        onDrawScrollIndicators(canvas);
        onDrawScrollBars(canvas);

        final Drawable foreground = mForegroundInfo != null ? mForegroundInfo.mDrawable : null;
        if (foreground != null) {
            if (mForegroundInfo.mBoundsChanged) {
                mForegroundInfo.mBoundsChanged = false;
                final Rect selfBounds = mForegroundInfo.mSelfBounds;
                final Rect overlayBounds = mForegroundInfo.mOverlayBounds;

                if (mForegroundInfo.mInsidePadding) {
                    selfBounds.set(0, 0, getWidth(), getHeight());
                } else {
                    selfBounds.set(getPaddingLeft(), getPaddingTop(),
                            getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());
                }

                final int ld = getLayoutDirection();
                Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),
                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);
                foreground.setBounds(overlayBounds);
            }

            foreground.draw(canvas);
        }
    }
```

{% fullimage /images/View-Draw.png,View的Draw流程,View的Draw流程%}

结合上述流程图分析Draw过程：

- 先调用`View.draw()`方法开始Draw流程
- 如果需要`dirtyOpaque`，就绘制背景`drawBackground()`
- 如果需要显示边缘效果，就进行保存画布`canvas.saveLayer()`
- 如果需要`dirtyOpaque`，绘制自身的内容`onDraw()` -- **自定义View必须实现**
- 调用`dispatchDraw()`绘制子View
- 如果需要显示边缘效果，绘制后，还原画布`canvas.restore()`
- 调用`drawForeground()`绘制装饰，例如滚动条或前景

#### ViewGroup的draw过程

ViewGroup的draw过程主要调整了上述源码中的`dispatchDraw()`，在其内部进行了子View的遍历以及绘制过程

```java
 // ../android/view/ViewGroup.java
protected void dispatchDraw(Canvas canvas) {
        boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
        final int childrenCount = mChildrenCount;
        final View[] children = mChildren;
    ...
        for (int i = 0; i < childrenCount; i++) {
            while (transientIndex >= 0 && mTransientIndices.get(transientIndex) == i) {
                final View transientChild = mTransientViews.get(transientIndex);
                if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE ||
                        transientChild.getAnimation() != null) {
                    more |= drawChild(canvas, transientChild, drawingTime);
                }
                transientIndex++;
                if (transientIndex >= transientCount) {
                    transientIndex = -1;
                }
            }

            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                more |= drawChild(canvas, child, drawingTime);
            }
        }
    ...
}

//绘制子View
protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
      //调用子View的draw方法
      return child.draw(canvas, this, drawingTime);
}


```

{% fullimage /images/ViewGroup-Draw.png,ViewGroup的Draw流程,ViewGroup的Draw流程%}

结合上述流程图分析ViewGroup的Draw过程：

- draw过程与上述`View的draw过程一致`
- `dispatchDraw()`默认实现，内部包含了子View的遍历以及绘制

拓展：

1. `View.setWillNotDraw()`有什么意义?

   ```java
       public void setWillNotDraw(boolean willNotDraw) {
           //设置 不需绘制 标记位
           setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);
       }
   ```

   如果一个View不需要绘制任何内容，设置这个标记为`true`，系统就会进行相应优化。

   ***View默认不开启`willNotDraw`标记位，ViewGroup默认开启。***
   
2. `ViewGroup`修改子View绘制顺序

   ```java ViewGroup.java
   protected void dispatchDraw(Canvas canvas){
     ...
       //设置自定义绘制顺序
      final ArrayList<View> preorderedList = usingRenderNodeProperties
                   ? null : buildOrderedChildList();
           //是否允许自定义绘制顺序
           final boolean customOrder = preorderedList == null
                   && isChildrenDrawingOrderEnabled();
           for (int i = 0; i < childrenCount; i++) {
               while (transientIndex >= 0 && mTransientIndices.get(transientIndex) == i) {
                   final View transientChild = mTransientViews.get(transientIndex);
                   if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE ||
                           transientChild.getAnimation() != null) {
                       more |= drawChild(canvas, transientChild, drawingTime);
                   }
                   transientIndex++;
                   if (transientIndex >= transientCount) {
                       transientIndex = -1;
                   }
               }
   
               final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
               final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
               if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                   more |= drawChild(canvas, child, drawingTime);
               }
           }
     ...
   }

       protected boolean isChildrenDrawingOrderEnabled() {
           return (mGroupFlags & FLAG_USE_CHILD_DRAWING_ORDER) == FLAG_USE_CHILD_DRAWING_ORDER;
       }
   //设置是否允许自定义绘制顺序
       protected void setChildrenDrawingOrderEnabled(boolean enabled) {
           setBooleanFlag(FLAG_USE_CHILD_DRAWING_ORDER, enabled);
       }
   
    //初始子View的绘制顺序 按照z轴的值调整绘制顺序，z轴从大到小绘制
       ArrayList<View> buildOrderedChildList() {
           final int childrenCount = mChildrenCount;
           if (childrenCount <= 1 || !hasChildWithZ()) return null;
   
           if (mPreSortedChildren == null) {
               mPreSortedChildren = new ArrayList<>(childrenCount);
           } else {
               // callers should clear, so clear shouldn't be necessary, but for safety...
               mPreSortedChildren.clear();
               mPreSortedChildren.ensureCapacity(childrenCount);
           }
   
           final boolean customOrder = isChildrenDrawingOrderEnabled();
           for (int i = 0; i < childrenCount; i++) {
               // add next child (in child order) to end of list
               final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
               final View nextChild = mChildren[childIndex];
               final float currentZ = nextChild.getZ();
   
               // insert ahead of any Views with greater Z
               int insertIndex = i;
               while (insertIndex > 0 && mPreSortedChildren.get(insertIndex - 1).getZ() > currentZ) {
                   insertIndex--;
               }
               mPreSortedChildren.add(insertIndex, nextChild);
           }
           return mPreSortedChildren;
       }
   
       //确定当前子View的绘制顺序
       private int getAndVerifyPreorderedIndex(int childrenCount, int i, boolean customOrder) {
           final int childIndex;
           if (customOrder) {
               final int childIndex1 = getChildDrawingOrder(childrenCount, i);
               if (childIndex1 >= childrenCount) {
                   throw new IndexOutOfBoundsException("getChildDrawingOrder() "
                           + "returned invalid index " + childIndex1
                           + " (child count is " + childrenCount + ")");
               }
               childIndex = childIndex1;
           } else {
               childIndex = i;
           }
           return childIndex;
       }
   //需要重写该方法，调整绘制顺序
       protected int getChildDrawingOrder(int childCount, int i) {
           return i;
       }
   
   //调整当前子View顺序
       private static View getAndVerifyPreorderedView(ArrayList<View> preorderedList, View[] children,
               int childIndex) {
           final View child;
           if (preorderedList != null) {
               child = preorderedList.get(childIndex);
               if (child == null) {
                   throw new RuntimeException("Invalid preorderedList contained null child at index "
                           + childIndex);
               }
           } else {
               child = children[childIndex];
           }
           return child;
       }
   ```
   
   根据上述源码，默认的绘制顺序按照z轴从大到小的进行绘制，如果需要修改绘制顺序的话，需要执行以下两步：
   
   1. `setChildrenDrawingEnabled(true)`打开自定义设置开关
   2. 继承`ViewGroup`后，重写`getChildDrawingOrder()`方法，设置对应的绘制顺序
   
   常用的`RecyclerView`、`ViewPager`都实现了该方法，其中`RecyclerView`通过设置`ChildDrawingOrderCallback`也可以实现这个功能。

## 自定义View

> 自定义View需要了解View的层次、View的事件分发机制以及View的工作流程。

### 分类

#### 1.继承View重写`onDraw()`

> 主要用于实现一些不规则的效果，不方便通过布局的组合方法可以直接实现，往往需要静态或者动态的显示一些不规则图形(圆形啥的)。
>
> 特殊形状的这种就需要重写`onDraw()`实现。**一般需要额外支持wrtap_content，并且也需要处理padding方法。**

#### 2.继承ViewGroup派生特殊的Layout

> 主要用于实现自定义的布局，除了常用的一些布局外。实现的是几种View的组合形式
>
> **实现稍微复杂，需要合适的处理ViewGroup的`onMeasure()，onLayout()`以及子View的`onMeasure()，onLayout()`**

#### 3.继承特定的View(例如TextView)

> 这种比较常见，一般用于拓展已有View的功能。
>
> **实现比较简单，无需自己处理wrap_content以及padding**

#### 4.继承特定的ViewGroup(例如LinearLayout)

> 比较常见，当某种效果看起来很像几种View组合在一起的时候
>
> **实现比较简单，无需自己处理测量以及布局过程**

### 注意事项

#### 1.让View支持wrap_content

> 直接继承View或ViewGroup的控件，不重写`onMeasure()`并对`AT_MOST`进行处理，就无法达到需要的显示效果。

#### 2.需要的话，让View支持padding

> 直接继承View的控件，需要在`draw`过程处理padding属性，不然padding属性无法起作用。
>
> 直接继承ViewGroup的控件，需要在`onMeasure()，onLayout()`处理自身的padding以及子View的margin

#### 3.尽量不要在View中使用Handler

> View内部提供了`post`方法，可以替代Handler使用

#### 4.View中如果有线程或动画，需要及时停止

> 1. 不处理有可能造成内存泄漏，View不可见时也需要停止线程和动画
> 2. 包含View的Activity启动时，View的`onAccachedToWindow()`会调用
> 3. 包含View的Activity退出或当前View被移除时，调用`View.onDetachedFromWindow()`时关闭线程和动画

#### 5.View若有滑动冲突情况，需要处理

### 实例

{% post_link 自定义View实践%}

{% post_link 自定义ViewGroup实践%}

## 拓展

### Invalidate、postInvalidate、requestLayout源码及应用场景

#### invalidate

> `invalidate()`必须在主线程调用，用于请求View的重绘，意味着只影响View的`draw`过程。

```java
// ../android/view/View.java
 public void invalidate() {
        invalidate(true);
    }

 public void invalidate(boolean invalidateCache) {
        invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);
    }

 void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,
            boolean fullInvalidate) {
     //View不可见或者在移动中 不进行重绘
     if (skipInvalidate()) {
            return;
        }
     
     if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)
                || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)
                || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED
                || (fullInvalidate && isOpaque() != mLastIsOpaque)) {
            //需要全部重绘
            if (fullInvalidate) {
                mLastIsOpaque = isOpaque();
                //修改绘制完成标记
                mPrivateFlags &= ~PFLAG_DRAWN;
            }
            //修改正在绘制标记
            mPrivateFlags |= PFLAG_DIRTY;
            //清除缓存
            if (invalidateCache) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            }

            // Propagate the damage rectangle to the parent view.
            final AttachInfo ai = mAttachInfo;
            final ViewParent p = mParent;
            if (p != null && ai != null && l < r && t < b) {
                final Rect damage = ai.mTmpInvalRect;
                damage.set(l, t, r, b);
                //设置重绘区域 并把自身传递到父布局
                p.invalidateChild(this, damage);
            }

            // Damage the entire projection receiver, if necessary.
            if (mBackground != null && mBackground.isProjected()) {
                final View receiver = getProjectionReceiver();
                if (receiver != null) {
                    receiver.damageInParent();
                }
            }
        }     
     
 }
```

上述代码修改标记完成后，调用父类的`invalidateChild()`将需要重绘的区域(`脏区域`)传入。(`ViewGroup以及ViewRootImpl都继承自ViewParent类`)

> 脏区域：*为了保证绘制的效率，控件树仅对需要绘制的区域进行重绘，需要重绘的区域成为`脏区域`*。

```java
//../android/view/VireGroup.java
    public final void invalidateChild(View child, final Rect dirty) {
        final AttachInfo attachInfo = mAttachInfo;
        //需要在开启硬件加速的情况下 会调用新的重绘方案
        if (attachInfo != null && attachInfo.mHardwareAccelerated) {
            // HW accelerated fast path
            onDescendantInvalidated(child, child);
            return;
        }

        ViewParent parent = this;
        if (attachInfo != null) {
          ...
            //开始遍历循环 从当前View不断向上调用父布局的绘制方法
            do {
                View view = null;
                // 当前父布局还为ViewGroup
                if (parent instanceof View) {
                    view = (View) parent;
                }else {
                  // 当前父布局到了ViewRootImpl
                }
                

                if (drawAnimation) {
                    if (view != null) {
                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                    } else if (parent instanceof ViewRootImpl) {
                        ((ViewRootImpl) parent).mIsAnimating = true;
                    }
                }

                // If the parent is dirty opaque or not dirty, mark it dirty with the opaque
                // flag coming from the child that initiated the invalidate
                // 父布局为实心 就需要设置 privateFlag标记
                if (view != null) {
                    if ((view.mViewFlags & FADING_EDGE_MASK) != 0 &&
                            view.getSolidColor() == 0) {
                        opaqueFlag = PFLAG_DIRTY;
                    }
                    if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {
                        view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;
                    }
                }
                //递归调用父布局的重绘方法
                parent = parent.invalidateChildInParent(location, dirty);
                if (view != null) {
                    // Account for transform on current parent
                    Matrix m = view.getMatrix();
                    if (!m.isIdentity()) {
                        RectF boundingRect = attachInfo.mTmpTransformRect;
                        boundingRect.set(dirty);
                        m.mapRect(boundingRect);
                       //将子View的脏区域 转换 父布局中的一块区域
                        dirty.set((int) Math.floor(boundingRect.left),
                                (int) Math.floor(boundingRect.top),
                                (int) Math.ceil(boundingRect.right),
                                (int) Math.ceil(boundingRect.bottom));
                    }
                }
            } while (parent != null);
        }
    }

    //将子视图坐标位置转化为当前视图的显示位置 
    public ViewParent invalidateChildInParent(final int[] location, final Rect dirty) {
        if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != 0) {
            // either DRAWN, or DRAWING_CACHE_VALID
            //ViewGroup中没有动画在执行 或者 已完成
            if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE))
                    != FLAG_OPTIMIZE_INVALIDATE) {
                dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,
                        location[CHILD_TOP_INDEX] - mScrollY);
                if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                    dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
                }

                final int left = mLeft;
                final int top = mTop;

                if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                    if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                        dirty.setEmpty();
                    }
                }

                location[CHILD_LEFT_INDEX] = left;
                location[CHILD_TOP_INDEX] = top;
            } else {
                
                if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                    dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
                } else {
                    // in case the dirty rect extends outside the bounds of this container
                    dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
                }
                location[CHILD_LEFT_INDEX] = mLeft;
                location[CHILD_TOP_INDEX] = mTop;

                mPrivateFlags &= ~PFLAG_DRAWN;
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
            }

            return mParent;
        }

        return null;
    }
```

当`parent`不为View时，说明已经到达了最顶层即`ViewRootImpl`

> 为什么最顶层会是`ViewRootImpl`?
>
> ```java
> 在ViewRoot与DecorView关联时讲到最后 WindowManagerGlobal 调用了 ViewRootImpl.setView() 传递进去DecorView
> public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
>    //设置当前ViewRootImpl为DecorView的parent
>    view.assignParent(this);
> }
> //给当前View设置父布局
> void assignParent(ViewParent parent) {
>         if (mParent == null) {
>             mParent = parent;
>         } else if (parent == null) {
>             mParent = null;
>         } else {
>             throw new RuntimeException("view " + this + " being added, but"
>                     + " it already has a parent");
>         }
>     }
> ```
>
> 不断向上回溯的过程中，最终走到DecorView `getParent()`就为ViewRootImpl

走到最后调用到了ViewRootImpl的`invalidateChild`方法，内部实现为`invalidateChildInParent()`

```java
// ../android/view/ViewRootImpl.java
    public void invalidateChild(View child, Rect dirty) {
        invalidateChildInParent(null, dirty);
    }

    public ViewParent invalidateChildInParent(int[] location, Rect dirty) {
        //判断当前线程是否与View线程相同
        checkThread();
        if (DEBUG_DRAW) Log.v(mTag, "Invalidate child: " + dirty);

        if (dirty == null) {
            //整个窗口重绘
            invalidate();
            return null;
        } else if (dirty.isEmpty() && !mIsAnimating) {
            //需要重绘区域为空 就不管了
            return null;
        }
        //设置 重绘区域偏移
        if (mCurScrollY != 0 || mTranslator != null) {
            mTempRect.set(dirty);
            dirty = mTempRect;
            if (mCurScrollY != 0) {
                dirty.offset(0, -mCurScrollY);
            }
            if (mTranslator != null) {
                mTranslator.translateRectInAppWindowToScreen(dirty);
            }
            if (mAttachInfo.mScalingRequired) {
                dirty.inset(-1, -1);
            }
        }

        invalidateRectOnScreen(dirty);

        return null;
    }
    //在屏幕上找到对应的重绘区域进行重绘
    private void invalidateRectOnScreen(Rect dirty) {
        final Rect localDirty = mDirty;
        if (!localDirty.isEmpty() && !localDirty.contains(dirty)) {
            mAttachInfo.mSetIgnoreDirtyState = true;
            mAttachInfo.mIgnoreDirtyState = true;
        }

        // Add the new dirty rect to the current one
        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);
        // Intersect with the bounds of the window to skip
        // updates that lie outside of the visible region
        final float appScale = mAttachInfo.mApplicationScale;
        final boolean intersected = localDirty.intersect(0, 0,
                (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));
        if (!intersected) {
            localDirty.setEmpty();
        }
        if (!mWillDrawSoon && (intersected || mIsAnimating)) {
            //真正执行绘制的地方
            scheduleTraversals();
        }
    }
```

最终调用到了`scheduleTraversals()`，在上面讲到`View的绘制流程`时，有提到最初就是从`performTraversals()`开始，这里的`scheduleTraversals()`就是去触发一次`performTraversals()`开始一次绘制流程。

> 由于`scheduleTraversals`是在主线程执行的，所以调用`invalidate()`时由于请求还未处理该消息，当多次调用重绘请求时，重绘也不会发生多次，提升效率。
>
> 调用到`performTraversals()`按道理会重新走一遍绘制流程即`measure->layout->draw`，由于重绘时，设置`layoutRequested为false`就不会重新触发`measure及layout`流程。

{% fullimage /images/View-Invalidate.png,View的重绘流程,View的重绘流程%}

根据上述流程图，简单总结：

- View调用`invalidate()`时，会调用父布局的`invalidateChild()`并传入自身View以及需要重绘区域
- ViewGroup接收到传参时，会开启循环(`条件为直到没有父布局为止`)，调用自身的`invalidateChildInParent()-主要功能为将子布局区域转换成当前布局的区域`向父布局层层传递
- 当父布局不为ViewGroup时，意味着已经到了最顶层的DecorView(`因为它的parent为ViewRootImpl`)，所以最终会执行到`ViewRootImpl.invalidateChild()`
- ViewRootImpl执行`invalidateChild()`最终调用到的就是`performTraversals()`进行View的绘制流程(`draw`)，由于设置了`mLayoutRequested`限制了`measure,layout`的执行，所以只会发生`draw`

#### postInvalidate

> `postInvalidate`就是可以在子线程重绘View。实际的实现还是调用`invalidate()`

```java
// ../android/view/View.java
    public void postInvalidate() {
        postInvalidateDelayed(0);
    }

    public void postInvalidate(int left, int top, int right, int bottom) {
        postInvalidateDelayed(0, left, top, right, bottom);
    }

    public void postInvalidateDelayed(long delayMilliseconds, int left, int top,
            int right, int bottom) {

        // We try only with the AttachInfo because there's no point in invalidating
        // if we are not attached to our window
        final AttachInfo attachInfo = mAttachInfo;
        if (attachInfo != null) {
            final AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.obtain();
            info.target = this;
            info.left = left;
            info.top = top;
            info.right = right;
            info.bottom = bottom;

            attachInfo.mViewRootImpl.dispatchInvalidateRectDelayed(info, delayMilliseconds);
        }
    }

// ../android/view/ViewRootImpl.java
public void dispatchInvalidateDelayed(View view, long delayMilliseconds) {
    Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);
    mHandler.sendMessageDelayed(msg, delayMilliseconds);
}

final ViewRootHandler mHandler = new ViewRootHandler();
final class ViewRootHandler extends Handler {
  ..
     @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
            case MSG_INVALIDATE:
                //最终调用到了 invalidate 
                ((View) msg.obj).invalidate();
                break;
                ...
            }
       }
  ...
}
```



#### requestLayout

> 强制重新布局，重新走一遍View的绘制流程。

```java
// ../android/view/View.java
    public void requestLayout() {
        if (mMeasureCache != null) mMeasureCache.clear();

        if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == null) {
            // Only trigger request-during-layout logic if this is the view requesting it,
            // not the views in its parent hierarchy
            ViewRootImpl viewRoot = getViewRootImpl();
            if (viewRoot != null && viewRoot.isInLayout()) {
                if (!viewRoot.requestLayoutDuringLayout(this)) {
                    return;
                }
            }
            mAttachInfo.mViewRequestingLayout = this;
        }
        //设置强制刷新标记
        mPrivateFlags |= PFLAG_FORCE_LAYOUT;
        mPrivateFlags |= PFLAG_INVALIDATED;

        if (mParent != null && !mParent.isLayoutRequested()) {
            //向父布局继续请求刷新布局
            mParent.requestLayout();
        }
        if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == this) {
            mAttachInfo.mViewRequestingLayout = null;
        }
    }

```

不断向父布局请求重新布局，逐层传递直到ViewRootImpl层。

```java
    @Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            checkThread();
            //设置标记 重新布局
            mLayoutRequested = true;
            scheduleTraversals();
        }
    }
```

上文中提到`mLayoutRequested`就是防止`invalidate`重新走一遍绘制流程，这里设置为`true`，意味着需要走一遍`measure,layout`。

由于`measure`过程设置了`mPrivateTags PFLAG_LAYOUT_REQUIRED`所以