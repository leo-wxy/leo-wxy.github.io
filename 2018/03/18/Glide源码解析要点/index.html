

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Glide源码解析要点 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
                Glide源码解析要点
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-03-18 19:36" pubdate>
        2018年3月18日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      173
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Glide源码解析要点</h1>
            
            <div class="markdown-body" id="post-body">
              <!-- TODO Glide如何加载大图 BitmapPool的使用-->
<blockquote>
<p>该源码解析是基于最新的Glide 4.8.0进行的</p>
</blockquote>
<h2 id="Glide基本流程分析"><a href="#Glide基本流程分析" class="headerlink" title="Glide基本流程分析"></a>Glide基本流程分析</h2><p>Glide的基本使用代码</p>
<pre><code class="hljs java">Glide.with(context).load($img$).apply(RequestOptions().transform(MultiTransformation(CenterCrop(),CircleCrop())).placeholder(R.drawable.ic_default_avatar)).into(imageView);</code></pre>
<p>按照上述的基本使用代码，Glide的加载过程可以分为以下几步：</p>
<h3 id="Glide对象初始化"><a href="#Glide对象初始化" class="headerlink" title="Glide对象初始化"></a><code>Glide对象初始化</code></h3><p>初始化代码是从<code>Glide.get()</code>开始的，在其中主要做了一些事情</p>
<pre><code class="hljs java"> <span class="hljs-meta">@NonNull</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Glide <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;
    <span class="hljs-comment">//Glide对象时一个单例模式</span>
    <span class="hljs-keyword">if</span> (glide == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">synchronized</span> (Glide.class) &#123;
        <span class="hljs-keyword">if</span> (glide == <span class="hljs-keyword">null</span>) &#123;
          checkAndInitializeGlide(context);
        &#125;
      &#125;
    &#125;

    <span class="hljs-keyword">return</span> glide;
  &#125;

<span class="hljs-comment">//检查Glide对象是否初始化完毕</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkAndInitializeGlide</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;
    <span class="hljs-comment">// In the thread running initGlide(), one or more classes may call Glide.get(context).</span>
    <span class="hljs-comment">// Without this check, those calls could trigger infinite recursion.</span>
    <span class="hljs-keyword">if</span> (isInitializing) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"You cannot call Glide.get() in registerComponents(),"</span>
          + <span class="hljs-string">" use the provided Glide instance instead"</span>);
    &#125;
    isInitializing = <span class="hljs-keyword">true</span>;
    <span class="hljs-comment">//真正初始化Glide的代码</span>
    initializeGlide(context);
    isInitializing = <span class="hljs-keyword">false</span>;
  &#125;</code></pre>
<p>初始化Glide时再调用到<code>initializeGlide()</code>去进行真正的初始化工作</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeGlide</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;
  initializeGlide(context, <span class="hljs-keyword">new</span> GlideBuilder());
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeGlide</span><span class="hljs-params">(@NonNull Context context, @NonNull GlideBuilder builder)</span> </span>&#123;
  Context applicationContext = context.getApplicationContext();
  GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
  List&lt;com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule&gt; manifestModules = Collections.emptyList();
  <span class="hljs-comment">//是否使用Manifest配置的GlideModule</span>
  <span class="hljs-keyword">if</span> (annotationGeneratedModule == <span class="hljs-keyword">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) &#123;
    manifestModules = <span class="hljs-keyword">new</span> ManifestParser(applicationContext).parse();
  &#125;

  <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-keyword">null</span>
      &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;
    Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses =
        annotationGeneratedModule.getExcludedModuleClasses();
    Iterator&lt;com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule&gt; iterator = manifestModules.iterator();
    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
      com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule current = iterator.next();
      <span class="hljs-keyword">if</span> (!excludedModuleClasses.contains(current.getClass())) &#123;
        <span class="hljs-keyword">continue</span>;
      &#125;
      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;
        Log.d(TAG, <span class="hljs-string">"AppGlideModule excludes manifest GlideModule: "</span> + current);
      &#125;
      iterator.remove();
    &#125;
  &#125;

  <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;
    <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule glideModule : manifestModules) &#123;
      Log.d(TAG, <span class="hljs-string">"Discovered GlideModule from manifest: "</span> + glideModule.getClass());
    &#125;
  &#125;

  RequestManagerRetriever.RequestManagerFactory factory =
      annotationGeneratedModule != <span class="hljs-keyword">null</span>
          ? annotationGeneratedModule.getRequestManagerFactory() : <span class="hljs-keyword">null</span>;
  builder.setRequestManagerFactory(factory);
  <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule <span class="hljs-keyword">module</span> : manifestModules) &#123;
    <span class="hljs-comment">//循环调用Module中的 applyOptions方法</span>
    <span class="hljs-comment">//applyOptions的作用是 配置Glide加载时的图片缓存路径以及缓存空间大小</span>
    <span class="hljs-keyword">module</span>.applyOptions(applicationContext, builder);
  &#125;
  <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-comment">//调用注解配置Module中的 applyOptions方法</span>
    <span class="hljs-comment">//applyOptions的作用是 配置Glide加载时的图片缓存路径以及缓存空间大小</span>
    annotationGeneratedModule.applyOptions(applicationContext, builder);
  &#125;
  <span class="hljs-comment">//创建Glide对象</span>
  Glide glide = builder.build(applicationContext);
  <span class="hljs-comment">//循环调用Module中的 registerComponents()</span>
  <span class="hljs-comment">//registerComponents的作用是 注册指定类型的数据源，以及加载图片使用ModelLoader</span>
  <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule <span class="hljs-keyword">module</span> : manifestModules) &#123;
    <span class="hljs-keyword">module</span>.registerComponents(applicationContext, glide, glide.registry);
  &#125;
  <span class="hljs-comment">//调用注解配置Module中的 registerComponents()</span>
  <span class="hljs-comment">//registerComponents的作用是 注册指定类型的数据源，以及加载图片使用ModelLoader</span>
  <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-keyword">null</span>) &#123;
    annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
  &#125;
  applicationContext.registerComponentCallbacks(glide);
  Glide.glide = glide;
&#125;</code></pre>
<p>源码中发现<code>GlideModule</code>分为两种<code>manifestModules</code>和<code>annotationGeneratedModule</code>，其中<code>manifestModules</code>是为了兼容V3版本，以前的都是配置在<code>AndroidManifest.xml</code>中，而V4版本采用注解的方式，取消了清单文件中的配置。</p>
<pre><code class="hljs java"><span class="hljs-meta">@GlideModule</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomGlideModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppGlideModule</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyOptions</span><span class="hljs-params">(Context context, GlideBuilder builder)</span> </span>&#123;

        MemorySizeCalculator calculator = <span class="hljs-keyword">new</span> MemorySizeCalculator.Builder(context).build();
        <span class="hljs-keyword">int</span> defaultMemoryCacheSize = calculator.getMemoryCacheSize();
        <span class="hljs-keyword">int</span> defaultBitmapPoolSize = calculator.getBitmapPoolSize();

        <span class="hljs-keyword">int</span> customMemoryCacheSize = (<span class="hljs-keyword">int</span>) (<span class="hljs-number">1.2</span> * defaultMemoryCacheSize);
        <span class="hljs-keyword">int</span> customBitmapPoolSize = (<span class="hljs-keyword">int</span>) (<span class="hljs-number">1.2</span> * defaultBitmapPoolSize);

        builder.setMemoryCache(<span class="hljs-keyword">new</span> LruResourceCache(customMemoryCacheSize));
        builder.setBitmapPool(<span class="hljs-keyword">new</span> LruBitmapPool(customBitmapPoolSize));
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerComponents</span><span class="hljs-params">(Context context, Glide glide, Registry registry)</span> </span>&#123;
        registry.replace(GlideUrl.class, InputStream.class, <span class="hljs-keyword">new</span> OkHttpUrlLoader.Factory(ProgressManager.getOkHttpClient()));
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isManifestParsingEnabled</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
&#125;</code></pre>
<p>配置好<code>GlideModule</code>文件后，就需要去调用其中的<code>applyOptions()</code>设置Glide加载基本配置项，然后调用到了<code>GlideBuilder.build()</code>去构造Glide对象，最后调用其中的<code>regeisterComponents()</code>设置加载器。</p>
<p>接下来分析构造Glide对象的方法——<code>GlideBuilder.build()</code></p>
<pre><code class="hljs java"><span class="hljs-meta">@NonNull</span>
<span class="hljs-function">Glide <span class="hljs-title">build</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;
  <span class="hljs-comment">//设置加载图片的线程池</span>
  <span class="hljs-keyword">if</span> (sourceExecutor == <span class="hljs-keyword">null</span>) &#123;
    sourceExecutor = GlideExecutor.newSourceExecutor();
  &#125;
  <span class="hljs-comment">//写入本地磁盘缓存的线程池</span>
  <span class="hljs-keyword">if</span> (diskCacheExecutor == <span class="hljs-keyword">null</span>) &#123;
    diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
  &#125;
  <span class="hljs-comment">//执行动画的线程池</span>
  <span class="hljs-keyword">if</span> (animationExecutor == <span class="hljs-keyword">null</span>) &#123;
    animationExecutor = GlideExecutor.newAnimationExecutor();
  &#125;
  <span class="hljs-comment">//计算内存缓存大小</span>
  <span class="hljs-keyword">if</span> (memorySizeCalculator == <span class="hljs-keyword">null</span>) &#123;
    memorySizeCalculator = <span class="hljs-keyword">new</span> MemorySizeCalculator.Builder(context).build();
  &#125;

  <span class="hljs-keyword">if</span> (connectivityMonitorFactory == <span class="hljs-keyword">null</span>) &#123;
    connectivityMonitorFactory = <span class="hljs-keyword">new</span> DefaultConnectivityMonitorFactory();
  &#125;
  <span class="hljs-comment">//bitmap缓存池</span>
  <span class="hljs-keyword">if</span> (bitmapPool == <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-keyword">int</span> size = memorySizeCalculator.getBitmapPoolSize();
    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;
      bitmapPool = <span class="hljs-keyword">new</span> LruBitmapPool(size);
    &#125; <span class="hljs-keyword">else</span> &#123;
      bitmapPool = <span class="hljs-keyword">new</span> BitmapPoolAdapter();
    &#125;
  &#125;

  <span class="hljs-keyword">if</span> (arrayPool == <span class="hljs-keyword">null</span>) &#123;
    arrayPool = <span class="hljs-keyword">new</span> LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
  &#125;
  <span class="hljs-comment">//内存缓存</span>
  <span class="hljs-keyword">if</span> (memoryCache == <span class="hljs-keyword">null</span>) &#123;
    memoryCache = <span class="hljs-keyword">new</span> LruResourceCache(memorySizeCalculator.getMemoryCacheSize());
  &#125;
  <span class="hljs-comment">//硬盘缓存</span>
  <span class="hljs-keyword">if</span> (diskCacheFactory == <span class="hljs-keyword">null</span>) &#123;
    diskCacheFactory = <span class="hljs-keyword">new</span> InternalCacheDiskCacheFactory(context);
  &#125;
  
  <span class="hljs-keyword">if</span> (engine == <span class="hljs-keyword">null</span>) &#123;
    engine =
        <span class="hljs-keyword">new</span> Engine(
            memoryCache,
            diskCacheFactory,
            diskCacheExecutor,
            sourceExecutor,
            GlideExecutor.newUnlimitedSourceExecutor(),
            GlideExecutor.newAnimationExecutor(),
            isActiveResourceRetentionAllowed);
  &#125;

  <span class="hljs-keyword">if</span> (defaultRequestListeners == <span class="hljs-keyword">null</span>) &#123;
    defaultRequestListeners = Collections.emptyList();
  &#125; <span class="hljs-keyword">else</span> &#123;
    defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);
  &#125;

  RequestManagerRetriever requestManagerRetriever =
      <span class="hljs-keyword">new</span> RequestManagerRetriever(requestManagerFactory);

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Glide(
      context,
      engine,
      memoryCache,
      bitmapPool,
      arrayPool,
      requestManagerRetriever,
      connectivityMonitorFactory,
      logLevel,
      defaultRequestOptions.lock(),
      defaultTransitionOptions,
      defaultRequestListeners,
      isLoggingRequestOriginsEnabled);
&#125;</code></pre>
<p>当<code>GlideBuilder.build()</code>执行完毕后，最终调用到<code>new Glide()</code>完成初始化。其中关键参数为<code>Registry</code>后续的操作都需要用到该参数。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with()"></a><code>with()</code></h3><blockquote>
<p>对Glide的生命周期进行管理。</p>
</blockquote>
<p>Glide对象初始化完毕后，首先会调用到的就是<code>with()</code></p>
<pre><code class="hljs java"><span class="hljs-meta">@NonNull</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;
    <span class="hljs-keyword">return</span> getRetriever(context).get(context);
  &#125;

  <span class="hljs-meta">@NonNull</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;
    <span class="hljs-keyword">return</span> getRetriever(activity).get(activity);
  &#125;

  <span class="hljs-meta">@NonNull</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull FragmentActivity activity)</span> </span>&#123;
    <span class="hljs-keyword">return</span> getRetriever(activity).get(activity);
  &#125;

  <span class="hljs-meta">@NonNull</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull Fragment fragment)</span> </span>&#123;
    <span class="hljs-keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);
  &#125;

  <span class="hljs-meta">@NonNull</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull View view)</span> </span>&#123;
    <span class="hljs-keyword">return</span> getRetriever(view.getContext()).get(view);
  &#125;</code></pre>
<p><code>with()</code>有5种重载方法，最后调用到的都是<code>getRetriever(context).get()</code></p>
<pre><code class="hljs java"><span class="hljs-meta">@NonNull</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;
  <span class="hljs-keyword">if</span> (context == <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"You cannot start a load on a null Context"</span>);
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="hljs-keyword">instanceof</span> Application)) &#123;
    <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> FragmentActivity) &#123;
      <span class="hljs-keyword">return</span> get((FragmentActivity) context);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> Activity) &#123;
      <span class="hljs-keyword">return</span> get((Activity) context);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> ContextWrapper) &#123;
      <span class="hljs-keyword">return</span> get(((ContextWrapper) context).getBaseContext());
    &#125;
  &#125;

  <span class="hljs-keyword">return</span> getApplicationManager(context);
&#125;

<span class="hljs-meta">@NonNull</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull FragmentActivity activity)</span> </span>&#123;
  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;
    <span class="hljs-keyword">return</span> get(activity.getApplicationContext());
  &#125; <span class="hljs-keyword">else</span> &#123;
    assertNotDestroyed(activity);
    FragmentManager fm = activity.getSupportFragmentManager();
    <span class="hljs-keyword">return</span> supportFragmentGet(
        activity, fm, <span class="hljs-comment">/*parentHint=*/</span> <span class="hljs-keyword">null</span>, isActivityVisible(activity));
  &#125;
&#125;

<span class="hljs-meta">@NonNull</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Fragment fragment)</span> </span>&#123;
  Preconditions.checkNotNull(fragment.getActivity(),
        <span class="hljs-string">"You cannot start a load on a fragment before it is attached or after it is destroyed"</span>);
  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;
    <span class="hljs-keyword">return</span> get(fragment.getActivity().getApplicationContext());
  &#125; <span class="hljs-keyword">else</span> &#123;
    FragmentManager fm = fragment.getChildFragmentManager();
    <span class="hljs-keyword">return</span> supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
  &#125;
&#125;

<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"deprecation"</span>)
<span class="hljs-meta">@NonNull</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;
  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;
    <span class="hljs-keyword">return</span> get(activity.getApplicationContext());
  &#125; <span class="hljs-keyword">else</span> &#123;
    assertNotDestroyed(activity);
    android.app.FragmentManager fm = activity.getFragmentManager();
    <span class="hljs-keyword">return</span> fragmentGet(
        activity, fm, <span class="hljs-comment">/*parentHint=*/</span> <span class="hljs-keyword">null</span>, isActivityVisible(activity));
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull View view)</span> </span>&#123;
  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;
    <span class="hljs-keyword">return</span> get(view.getContext().getApplicationContext());
  &#125;

  Preconditions.checkNotNull(view);
  Preconditions.checkNotNull(view.getContext(),
      <span class="hljs-string">"Unable to obtain a request manager for a view without a Context"</span>);
  Activity activity = findActivity(view.getContext());
  <span class="hljs-comment">// The view might be somewhere else, like a service.</span>
  <span class="hljs-keyword">if</span> (activity == <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-keyword">return</span> get(view.getContext().getApplicationContext());
  &#125;

  <span class="hljs-comment">// Support Fragments.</span>
  <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> FragmentActivity) &#123;
    Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
    <span class="hljs-keyword">return</span> fragment != <span class="hljs-keyword">null</span> ? get(fragment) : get(activity);
  &#125;

  <span class="hljs-comment">// Standard Fragments.</span>
  android.app.Fragment fragment = findFragment(view, activity);
  <span class="hljs-keyword">if</span> (fragment == <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-keyword">return</span> get(activity);
  &#125;
  <span class="hljs-keyword">return</span> get(fragment);
&#125;</code></pre>
<p>简单分析上述源码可知，调用流程如下：</p>
<ul>
<li>首先判断当前调用是否在子线程，在子线程的话，直接调用<code>ApplicationContext</code>获取<code>ReqeustManager</code></li>
<li>不在子线程即运行在主线程时，需要判断<code>context</code>类型<ul>
<li><code>support.Fragment或者support.FragmentActivity</code>：调用<code>supportFragmentGet()</code></li>
<li><code>app.Activity或者app.fragment</code>：调用<code>fragmentGet()</code></li>
<li><code>Application</code>：调用<code>getApplicationManager()</code></li>
<li><code>view.getContext</code>：需要判断view的context类型，然后再走一次上面的步骤</li>
</ul>
</li>
</ul>
<p>根据流程分析，监听生命周期的方式主要是通过<code>监听一个无UI的Fragment(位于主线程且有对应的context存在)</code>和<code>监听Application(当位于后台线程或者contxt为Application)</code>。</p>
<p>其中<code>无UI的Fragment</code>对应源码中的两个类<code>RequestManagerFragment</code>、<code>SupportRequestFragment</code>在其中构造了<code>ActivityFragmentLifecycle</code>对象，在其中的关键生命周期进行联动，就可以对应的去进行加载和取消加载操作了。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-keyword">super</span>.onStart();
   lifecycle.onStart();
 &#125;

 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-keyword">super</span>.onStop();
   lifecycle.onStop();
 &#125;

 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-keyword">super</span>.onDestroy();
   lifecycle.onDestroy();
   unregisterFragmentWithRoot();
 &#125;</code></pre>
<p>然后最后返回的<code>RequestManager</code>对象自身也会实现<code>LifecycleListener</code>接口，就可以根据对应调用跳转加载过程</p>
<pre><code class="hljs java"><span class="hljs-comment">//实现了LifecycleListener接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LifecycleListener</span></span>&#123;
 
  <span class="hljs-comment">//主线程中执行</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable addSelfToLifecycle = <span class="hljs-keyword">new</span> Runnable() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
      lifecycle.addListener(RequestManager.<span class="hljs-keyword">this</span>);
    &#125;
  &#125;;
...
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;
    resumeRequests();
    targetTracker.onStart();<span class="hljs-comment">//targetTracker监听</span>
  &#125;
  
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;
    pauseRequests();
    targetTracker.onStop();<span class="hljs-comment">//targetTracker监听</span>
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resumeRequests</span><span class="hljs-params">()</span> </span>&#123;
    Util.assertMainThread();
    requestTracker.resumeRequests();<span class="hljs-comment">//requestTracker监听</span>
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pauseRequests</span><span class="hljs-params">()</span> </span>&#123;
    Util.assertMainThread();
    requestTracker.pauseRequests();<span class="hljs-comment">//requestTracker监听</span>
  &#125;
  
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;
    targetTracker.onDestroy();<span class="hljs-comment">//targetTracker监听</span>
    <span class="hljs-keyword">for</span> (Target&lt;?&gt; target : targetTracker.getAll()) &#123;
      clear(target);
    &#125;
    targetTracker.clear();<span class="hljs-comment">//targetTracker监听</span>
    requestTracker.clearRequests();<span class="hljs-comment">//requestTracker监听</span>
    lifecycle.removeListener(<span class="hljs-keyword">this</span>);
    lifecycle.removeListener(connectivityMonitor);
    mainHandler.removeCallbacks(addSelfToLifecycle);
    glide.unregisterRequestManager(<span class="hljs-keyword">this</span>);
  &#125;
&#125;</code></pre>
<p>完成上述流程后，RequestManager就可以实现对Fragment的监听，也就等同于实现了Glide的生命周期。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide的with.png" srcset="/img/loading.gif" class="full-image" alt="Glide的with过程" title="Glide的with过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="load"><a href="#load" class="headerlink" title="load()"></a><code>load()</code></h3><blockquote>
<p>传入需要加载的图片信息，通过<code>with()</code>得到的<code>RequestManager</code>进行加载。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-meta">@NonNull</span>
 <span class="hljs-meta">@CheckResult</span>
 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Bitmap bitmap)</span> </span>&#123;
   <span class="hljs-keyword">return</span> asDrawable().load(bitmap);
 &#125;

 <span class="hljs-meta">@NonNull</span>
 <span class="hljs-meta">@CheckResult</span>
 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Drawable drawable)</span> </span>&#123;
   <span class="hljs-keyword">return</span> asDrawable().load(drawable);
 &#125;

 <span class="hljs-meta">@NonNull</span>
 <span class="hljs-meta">@CheckResult</span>
 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable String string)</span> </span>&#123;
   <span class="hljs-keyword">return</span> asDrawable().load(string);
 &#125;

 <span class="hljs-meta">@NonNull</span>
 <span class="hljs-meta">@CheckResult</span>
 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Uri uri)</span> </span>&#123;
   <span class="hljs-keyword">return</span> asDrawable().load(uri);
 &#125;

 <span class="hljs-meta">@NonNull</span>
 <span class="hljs-meta">@CheckResult</span>
 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable File file)</span> </span>&#123;
   <span class="hljs-keyword">return</span> asDrawable().load(file);
 &#125;

 <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"deprecation"</span>)
 <span class="hljs-meta">@NonNull</span>
 <span class="hljs-meta">@CheckResult</span>
 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@RawRes @DrawableRes @Nullable Integer resourceId)</span> </span>&#123;
   <span class="hljs-keyword">return</span> asDrawable().load(resourceId);
 &#125;

 <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"deprecation"</span>)
 <span class="hljs-meta">@CheckResult</span>
 <span class="hljs-meta">@Override</span>
 <span class="hljs-meta">@Deprecated</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable URL url)</span> </span>&#123;
   <span class="hljs-keyword">return</span> asDrawable().load(url);
 &#125;

 <span class="hljs-meta">@NonNull</span>
 <span class="hljs-meta">@CheckResult</span>
 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable <span class="hljs-keyword">byte</span>[] model)</span> </span>&#123;
   <span class="hljs-keyword">return</span> asDrawable().load(model);
 &#125;

 <span class="hljs-meta">@NonNull</span>
 <span class="hljs-meta">@CheckResult</span>
 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Object model)</span> </span>&#123;
   <span class="hljs-keyword">return</span> asDrawable().load(model);
 &#125;</code></pre>
<p>经过<code>load()</code>分析，Glide加载的类型支持<code>Bitmap</code>、<code>Drawable</code>、<code>String(图片地址)</code>、<code>Uri</code>、<code>File(图片文件)</code>、<code>Integer(图片ResourceId)</code>、<code>URL</code>、<code>byte</code>，<code>Object</code>。</p>
<p>实际内部调用到的是<code>asDrawable.load()</code></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">asDrawable</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">return</span> as(Drawable.class);
&#125;

<span class="hljs-meta">@NonNull</span>
<span class="hljs-meta">@CheckResult</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Bitmap&gt; <span class="hljs-title">asBitmap</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">return</span> as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
&#125;

<span class="hljs-meta">@NonNull</span>
<span class="hljs-meta">@CheckResult</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;GifDrawable&gt; <span class="hljs-title">asGif</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">return</span> as(GifDrawable.class).apply(DECODE_TYPE_GIF);
&#125;

<span class="hljs-meta">@NonNull</span>
<span class="hljs-meta">@CheckResult</span>
<span class="hljs-keyword">public</span> &lt;ResourceType&gt; <span class="hljs-function">RequestBuilder&lt;ResourceType&gt; <span class="hljs-title">as</span><span class="hljs-params">(
    @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="hljs-keyword">this</span>, resourceClass, context);
&#125;</code></pre>
<p>通过<code>asDrawable()</code>得到<code>RequestBuilder</code>对象，接下来走到<code>ReqeustBuilder.load()</code></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Bitmap bitmap)</span> </span>&#123;
    <span class="hljs-keyword">return</span> loadGeneric(bitmap)
        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Drawable drawable)</span> </span>&#123;
    <span class="hljs-keyword">return</span> loadGeneric(drawable)
        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable String string)</span> </span>&#123;
    <span class="hljs-keyword">return</span> loadGeneric(string);
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Uri uri)</span> </span>&#123;
    <span class="hljs-keyword">return</span> loadGeneric(uri);
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable File file)</span> </span>&#123;
    <span class="hljs-keyword">return</span> loadGeneric(file);
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">loadGeneric</span><span class="hljs-params">(@Nullable Object model)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.model = model;
    isModelSet = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Object model)</span> </span>&#123;
    <span class="hljs-keyword">return</span> loadGeneric(model);
  &#125;</code></pre>
<p>上述的<code>load()</code>都调用到了<code>loadGeneric()</code>然后进行了赋值操作，确定了<code>model</code>数据，然后完成了load流程。</p>
<p>//TODO 流程图</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a><code>apply()</code></h3><blockquote>
<p>设置一些额外配置，例如占位图、加载错误图片、图片显示类型，圆角什么的</p>
</blockquote>
<p><code>load()</code>流程结束后就得到了<code>RequestBuilder</code>对象，调用其中的<code>apply()</code></p>
<pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestBuilder</span>&lt;<span class="hljs-title">TranscodeType</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRequestOptions</span>&lt;<span class="hljs-title">RequestBuilder</span>&lt;<span class="hljs-title">TranscodeType</span>&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">ModelTypes</span>&lt;<span class="hljs-title">RequestBuilder</span>&lt;<span class="hljs-title">TranscodeType</span>&gt;&gt; </span>&#123;
      ...
  <span class="hljs-meta">@NonNull</span>
  <span class="hljs-meta">@CheckResult</span>
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">apply</span><span class="hljs-params">(@NonNull BaseRequestOptions&lt;?&gt; requestOptions)</span> </span>&#123;
    Preconditions.checkNotNull(requestOptions);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.apply(requestOptions);
  &#125;
      
      ...
&#125;</code></pre>
<p>调用到了<code>super.apply()</code>其实就是<code>BaseRequestOptions.apply()</code></p>
<pre><code class="hljs java"><span class="hljs-meta">@NonNull</span>
 <span class="hljs-meta">@CheckResult</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">apply</span><span class="hljs-params">(@NonNull BaseRequestOptions&lt;?&gt; o)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (isAutoCloneEnabled) &#123;
     <span class="hljs-keyword">return</span> clone().apply(o);
   &#125;
   BaseRequestOptions&lt;?&gt; other = o;

   <span class="hljs-keyword">if</span> (isSet(other.fields, SIZE_MULTIPLIER)) &#123;
     sizeMultiplier = other.sizeMultiplier;
   &#125;
   ...
   fields |= other.fields;
   options.putAll(other.options);

   <span class="hljs-keyword">return</span> selfOrThrowIfLocked();
 &#125;</code></pre>
<p><code>isSet()</code>是判断该属性是否设置，若已设置过则替换，设置完毕后，得到一个<code>RequestBuilder</code>对象，不过已经设置了<code>RequestOptions</code>里面包含了一些显示上以及缓存上的配置。</p>
<h3 id="into-——最关键步骤"><a href="#into-——最关键步骤" class="headerlink" title="into()——最关键步骤"></a><code>into()</code>——最关键步骤</h3><blockquote>
<p>进行图片的加载与显示</p>
</blockquote>
<h4 id="创建请求Request"><a href="#创建请求Request" class="headerlink" title="创建请求Request"></a>创建请求<code>Request</code></h4><p>起点是从<code>RequestBuilder.into()</code>开始</p>
<pre><code class="hljs java"><span class="hljs-meta">@NonNull</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="hljs-title">into</span><span class="hljs-params">(@NonNull ImageView view)</span> </span>&#123;
  Util.assertMainThread();
  Preconditions.checkNotNull(view);
  <span class="hljs-comment">//获取apply()设置的 RequestOptions</span>
  BaseRequestOptions&lt;?&gt; requestOptions = <span class="hljs-keyword">this</span>;
  <span class="hljs-comment">//是否设置了RequestOptions的ScaleType，未设置则使用ImageView的android:scaleType</span>
  <span class="hljs-keyword">if</span> (!requestOptions.isTransformationSet()
      &amp;&amp; requestOptions.isTransformationAllowed()
      &amp;&amp; view.getScaleType() != <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-keyword">switch</span> (view.getScaleType()) &#123;
      <span class="hljs-keyword">case</span> CENTER_CROP:
        requestOptions = requestOptions.clone().optionalCenterCrop();
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> CENTER_INSIDE:
        requestOptions = requestOptions.clone().optionalCenterInside();
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> FIT_CENTER:
      <span class="hljs-keyword">case</span> FIT_START:
      <span class="hljs-keyword">case</span> FIT_END:
        requestOptions = requestOptions.clone().optionalFitCenter();
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> FIT_XY:
        requestOptions = requestOptions.clone().optionalCenterInside();
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> CENTER:
      <span class="hljs-keyword">case</span> MATRIX:
      <span class="hljs-keyword">default</span>:
        <span class="hljs-comment">// Do nothing.</span>
    &#125;
  &#125;

  <span class="hljs-keyword">return</span> into(
      glideContext.buildImageViewTarget(view, transcodeClass),
      <span class="hljs-comment">/*targetListener=*/</span> <span class="hljs-keyword">null</span>,
      requestOptions,
      Executors.mainThreadExecutor());
&#125;

<span class="hljs-keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="hljs-function">Y <span class="hljs-title">into</span><span class="hljs-params">(
    @NonNull Y target,
    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,
    BaseRequestOptions&lt;?&gt; options,
    Executor callbackExecutor)</span> </span>&#123;
  Preconditions.checkNotNull(target);
  <span class="hljs-keyword">if</span> (!isModelSet) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"You must call #load() before calling #into()"</span>);
  &#125;
  <span class="hljs-comment">//构建Request请求对象</span>
  Request request = buildRequest(target, targetListener, options, callbackExecutor);
  
  Request previous = target.getRequest();
  <span class="hljs-keyword">if</span> (request.isEquivalentTo(previous)
      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;
    request.recycle();
    <span class="hljs-keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;
      previous.begin();
    &#125;
    <span class="hljs-keyword">return</span> target;
  &#125;

  requestManager.clear(target);
  <span class="hljs-comment">//给当前View设置请求</span>
  target.setRequest(request);
  requestManager.track(target, request);

  <span class="hljs-keyword">return</span> target;
&#125;</code></pre>
<p>通过<code>buildRequest()</code>构建图片加载请求对象。</p>
<pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">buildRequest</span><span class="hljs-params">(
      Target&lt;TranscodeType&gt; target,
      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,
      BaseRequestOptions&lt;?&gt; requestOptions,
      Executor callbackExecutor)</span> </span>&#123;
    <span class="hljs-keyword">return</span> buildRequestRecursive(
        target,
        targetListener,
        <span class="hljs-comment">/*parentCoordinator=*/</span> <span class="hljs-keyword">null</span>,
        transitionOptions,
        requestOptions.getPriority(),
        requestOptions.getOverrideWidth(),
        requestOptions.getOverrideHeight(),
        requestOptions,
        callbackExecutor);
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">buildRequestRecursive</span><span class="hljs-params">(...)</span> </span>&#123;
    
    ErrorRequestCoordinator errorRequestCoordinator = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">//判断当前是否设置了 RequestBuilder.error()</span>
    <span class="hljs-keyword">if</span> (errorBuilder != <span class="hljs-keyword">null</span>) &#123;
      errorRequestCoordinator = <span class="hljs-keyword">new</span> ErrorRequestCoordinator(parentCoordinator);
      parentCoordinator = errorRequestCoordinator;
    &#125;
    <span class="hljs-comment">//生成可能带有缩略图显示的Request</span>
    Request mainRequest =
        buildThumbnailRequestRecursive(...);
    
    <span class="hljs-keyword">if</span> (errorRequestCoordinator == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> mainRequest;
    &#125;
    <span class="hljs-comment">//生成带有错误处理的Request</span>
    Request errorRequest =
        errorBuilder.buildRequestRecursive(...);
    errorRequestCoordinator.setRequests(mainRequest, errorRequest);
    <span class="hljs-keyword">return</span> errorRequestCoordinator;
    ...
      
  &#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">buildThumbnailRequestRecursive</span><span class="hljs-params">(...)</span> </span>&#123;
    <span class="hljs-comment">//是否设置了 RequestBuilder.thumbnailBuilder(RequestBuilder thumbnailBuilder)</span>
    <span class="hljs-keyword">if</span> (thumbnailBuilder != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (isThumbnailBuilt) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"You cannot use a request as both the main request and a "</span>
            + <span class="hljs-string">"thumbnail, consider using clone() on the request(s) passed to thumbnail()"</span>);
      &#125;

      TransitionOptions&lt;?, ? <span class="hljs-keyword">super</span> TranscodeType&gt; thumbTransitionOptions =
          thumbnailBuilder.transitionOptions;

      <span class="hljs-comment">// Apply our transition by default to thumbnail requests but avoid overriding custom options</span>
      <span class="hljs-comment">// that may have been applied on the thumbnail request explicitly.</span>
      <span class="hljs-keyword">if</span> (thumbnailBuilder.isDefaultTransitionOptionsSet) &#123;
        thumbTransitionOptions = transitionOptions;
      &#125;

      Priority thumbPriority = thumbnailBuilder.isPrioritySet()
          ? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);

      <span class="hljs-keyword">int</span> thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();
      <span class="hljs-keyword">int</span> thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();
      <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)
          &amp;&amp; !thumbnailBuilder.isValidOverride()) &#123;
        thumbOverrideWidth = requestOptions.getOverrideWidth();
        thumbOverrideHeight = requestOptions.getOverrideHeight();
      &#125;

      ThumbnailRequestCoordinator coordinator = <span class="hljs-keyword">new</span> ThumbnailRequestCoordinator(parentCoordinator);
ThumbnailRequestCoordinator coordinator = <span class="hljs-keyword">new</span> ThumbnailRequestCoordinator(parentCoordinator);
      Request fullRequest =
          obtainRequest(...);
      isThumbnailBuilt = <span class="hljs-keyword">true</span>;
      <span class="hljs-comment">// Recursively generate thumbnail requests.</span>
      Request thumbRequest =
          thumbnailBuilder.buildRequestRecursive(...);
      isThumbnailBuilt = <span class="hljs-keyword">false</span>;
      coordinator.setRequests(fullRequest, thumbRequest);
      <span class="hljs-keyword">return</span> coordinator;
    &#125;
  <span class="hljs-comment">//是否设置了 RequestBuilder.thumbnailBuilder(floar thumbSizeMultiplier)  对应的缩放比例</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thumbSizeMultiplier != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.</span>
      ThumbnailRequestCoordinator coordinator = <span class="hljs-keyword">new</span> ThumbnailRequestCoordinator(parentCoordinator);
      Request fullRequest = obtainRequest(...);
      BaseRequestOptions&lt;?&gt; thumbnailOptions =
          requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);

      Request thumbnailRequest =
          obtainRequest(...);

      coordinator.setRequests(fullRequest, thumbnailRequest);
      <span class="hljs-keyword">return</span> coordinator;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// 没有设置 thunbmail相关参数</span>
      <span class="hljs-keyword">return</span> obtainRequest(...);
    &#125;
  &#125;

 <span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">obtainRequest</span><span class="hljs-params">(
      Target&lt;TranscodeType&gt; target,
      RequestListener&lt;TranscodeType&gt; targetListener,
      BaseRequestOptions&lt;?&gt; requestOptions,
      RequestCoordinator requestCoordinator,
      TransitionOptions&lt;?, ? <span class="hljs-keyword">super</span> TranscodeType&gt; transitionOptions,
      Priority priority,
      <span class="hljs-keyword">int</span> overrideWidth,
      <span class="hljs-keyword">int</span> overrideHeight,
      Executor callbackExecutor)</span> </span>&#123;
    <span class="hljs-keyword">return</span> SingleRequest.obtain(...);
  &#125;</code></pre>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide创建请求.png" srcset="/img/loading.gif" class="full-image" alt="Glide创建请求" title="Glide创建请求"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>总结一下创建请求的流程，最后调用的是<code>SingleRequest</code>对象。</p>
<ul>
<li><p>通过<code>RequestBuilder.buildRequest()</code>创建<code>Request</code>对象，调用到<code>buildRequestRecursive()</code>执行创建逻辑</p>
</li>
<li><p>先判断设置过<code>RequestBuilder.error()</code>参数，如果设置过<code>errorRequest</code>，需要通过<code>errorRequest</code>和<code>mainRequest</code>得到<code>ErrorRequestCoordinator(实现Request接口)</code>对象。</p>
</li>
<li><p>没设置过<code>RequestBuilder.error()</code>参数，则向下判断是否设置过<code>ReqeustBuilder.thumbnail()</code>参数，设置<code>ReqeustBuilder.thumbnail()</code>有两种方法：</p>
<ul>
<li><code>ReqeustBuilder.thumbnail(RequestBuilder thumbnailBuilder)</code>：自定义要显示的缩略图</li>
<li><code>ReqeustBuilder.thumbnail(float thumbSizeMultiper)</code>：设置原图缩放比例</li>
</ul>
<p>只要设置了其中的一种，就会产生<code>thumbRequest</code>对象，然后与<code>fullRequest</code>得到<code>ThumbnailRequestCoordinator(实现Request接口)</code>对象。</p>
</li>
<li><p><code>ReqeustBuilder.thumbnail()</code>也未设置，则最终调用<code>SingleRequest.obtain()</code>得到<code>SingleRequest(实现Request接口)</code>对象。</p>
</li>
</ul>
<blockquote>
<p> <code>errorRequest</code>表示了加载错误的请求</p>
<p> <code>thumbRequest</code>表示了缩略图加载请求</p>
<p> <code>mainRequest</code>和<code>fullRequest</code>都代表了原始图片加载请求。</p>
</blockquote>
<p>上述创建请求流程执行完毕后，就是发送请求。</p>
<h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><blockquote>
<p>发送请求通过调用<code>Request</code>实现。</p>
</blockquote>
<p>在<a href="#创建请求">创建请求</a>中，创建完成后会调用到<code>requestManager.track(target, request);</code>去发送请求</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">track</span><span class="hljs-params">(@NonNull Target&lt;?&gt; target, @NonNull Request request)</span> </span>&#123;
  <span class="hljs-comment">//监听target的生命周期</span>
  targetTracker.track(target);
  <span class="hljs-comment">//开启请求</span>
  requestTracker.runRequest(request);
&#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runRequest</span><span class="hljs-params">(@NonNull Request request)</span> </span>&#123;
  requests.add(request);
  <span class="hljs-keyword">if</span> (!isPaused) &#123;
    <span class="hljs-comment">//开始启动</span>
    request.begin();
  &#125; <span class="hljs-keyword">else</span> &#123;
    request.clear();
    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;
      Log.v(TAG, <span class="hljs-string">"Paused, delaying request"</span>);
    &#125;
    pendingRequests.add(request);
  &#125;
&#125;</code></pre>
<p>接下来就是调用到<code>Request.begin()</code>，<code>Request</code>是一个接口，<code>singleRequest</code>是具体的实现类，即调用到<code>SingleRequest.begin()</code></p>
<pre><code class="hljs java">  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;
    assertNotCallingCallbacks();
    stateVerifier.throwIfRecycled();
    startTime = LogTime.getLogTime();
    <span class="hljs-keyword">if</span> (model == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;
        width = overrideWidth;
        height = overrideHeight;
      &#125;
      <span class="hljs-keyword">int</span> logLevel = getFallbackDrawable() == <span class="hljs-keyword">null</span> ? Log.WARN : Log.DEBUG;
      <span class="hljs-comment">//返回加载失败</span>
      onLoadFailed(<span class="hljs-keyword">new</span> GlideException(<span class="hljs-string">"Received null model"</span>), logLevel);
      <span class="hljs-keyword">return</span>;
    &#125;
    
    <span class="hljs-keyword">if</span> (status == Status.RUNNING) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot restart a running request"</span>);
    &#125;
    <span class="hljs-comment">//加载完成</span>
    <span class="hljs-keyword">if</span> (status == Status.COMPLETE) &#123;
      onResourceReady(resource, DataSource.MEMORY_CACHE);
      <span class="hljs-keyword">return</span>;
    &#125;
    
    status = Status.WAITING_FOR_SIZE;
    <span class="hljs-comment">//判断设置大小是否合理</span>
    <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;
      onSizeReady(overrideWidth, overrideHeight);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">//不合理 获取ImageView的size</span>
      target.getSize(<span class="hljs-keyword">this</span>);
    &#125;

    <span class="hljs-keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
        &amp;&amp; canNotifyStatusChanged()) &#123;
      <span class="hljs-comment">//回调Target onLoadStarted()</span>
      target.onLoadStarted(getPlaceholderDrawable());
    &#125;
    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;
      logV(<span class="hljs-string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));
    &#125;
  &#125;

<span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSizeReady</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;
    stateVerifier.throwIfRecycled();
    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;
      logV(<span class="hljs-string">"Got onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));
    &#125;
    <span class="hljs-keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;
      <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-comment">//更新请求状态为 请求中</span>
    status = Status.RUNNING;

    <span class="hljs-keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();
    <span class="hljs-keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);
    <span class="hljs-keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);

    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;
      logV(<span class="hljs-string">"finished setup for calling load in "</span> + LogTime.getElapsedMillis(startTime));
    &#125;
    <span class="hljs-comment">//开始加载图片</span>
    loadStatus = engine.load(...);
    <span class="hljs-keyword">if</span> (status != Status.RUNNING) &#123;
      loadStatus = <span class="hljs-keyword">null</span>;
    &#125;
    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;
      logV(<span class="hljs-string">"finished onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));
    &#125;
  &#125;</code></pre>
<p>上述流程主要是去计算得到 被加载图片的尺寸信息，如果手动设置了尺寸通过<code>override</code>那么通过合法性校验后，加载的图片大小就会为用户设置尺寸，否则使用<code>Target</code>的尺寸信息。</p>
<blockquote>
<p><code>Target</code>是一个接口，主要意义是提供View的确切尺寸信息以及对回调结果进行处理。</p>
</blockquote>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide发送请求.png" srcset="/img/loading.gif" class="full-image" alt="Glide发送请求" title="Glide发送请求"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h4><p>接下来调用<code>Engine.load()</code>开始加载图片，包括三级缓存的部分。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; <span class="hljs-function">LoadStatus <span class="hljs-title">load</span><span class="hljs-params">(...)</span> </span>&#123;
    <span class="hljs-keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="hljs-number">0</span>;

    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
        resourceClass, transcodeClass, options);
    <span class="hljs-comment">//读取内存中的弱引用</span>
    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);
    <span class="hljs-keyword">if</span> (active != <span class="hljs-keyword">null</span>) &#123;
      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;
        logWithTimeAndKey(<span class="hljs-string">"Loaded resource from active resources"</span>, startTime, key);
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    <span class="hljs-comment">//读取内存缓存</span>
    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);
    <span class="hljs-keyword">if</span> (cached != <span class="hljs-keyword">null</span>) &#123;
      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;
        logWithTimeAndKey(<span class="hljs-string">"Loaded resource from cache"</span>, startTime, key);
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    
    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);
    <span class="hljs-keyword">if</span> (current != <span class="hljs-keyword">null</span>) &#123;
      current.addCallback(cb, callbackExecutor);
      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;
        logWithTimeAndKey(<span class="hljs-string">"Added to existing load"</span>, startTime, key);
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadStatus(cb, current);
    &#125;

    EngineJob&lt;R&gt; engineJob =
        engineJobFactory.build(
            key,
            isMemoryCacheable,
            useUnlimitedSourceExecutorPool,
            useAnimationPool,
            onlyRetrieveFromCache);

    DecodeJob&lt;R&gt; decodeJob =
        decodeJobFactory.build(...);

    jobs.put(key, engineJob);

    engineJob.addCallback(cb, callbackExecutor);
    <span class="hljs-comment">//若从两级内存缓存中 都没有找到 则开启DecodeJob去加载图片</span>
    engineJob.start(decodeJob);

    <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;
      logWithTimeAndKey(<span class="hljs-string">"Started new load"</span>, startTime, key);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadStatus(cb, engineJob);
  &#125;</code></pre>
<p>在<code>Engine.load()</code>，主要执行逻辑是：先从<code>一级内存缓存-弱引用</code>中查找指定资源，找不到则去<code>二级内存缓存-LRUCache</code>中去查找，再没有就转到<code>DecodeJob</code>去加载图片。</p>
<p>加载图片的具体实现细节会单独在<a href="#Glide缓存实现原理">Glide缓存实现原理</a>说明。</p>
<h4 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h4><p>当图片从三级缓存中取出后，最终得到的是一个<code>Resource</code>对象，然后再回调到<code>SingleRequest.onResourceReady()</code>中</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReady</span><span class="hljs-params">(Resource&lt;?&gt; resource, DataSource dataSource)</span> </span>&#123;
  stateVerifier.throwIfRecycled();
  loadStatus = <span class="hljs-keyword">null</span>;
  <span class="hljs-keyword">if</span> (resource == <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-comment">//回调加载失败事件</span>
    onLoadFailed(exception);
    <span class="hljs-keyword">return</span>;
  &#125;

  Object received = resource.get();
  <span class="hljs-keyword">if</span> (received == <span class="hljs-keyword">null</span> || !transcodeClass.isAssignableFrom(received.getClass())) &#123;
    <span class="hljs-comment">//回收资源</span>
    releaseResource(resource);

    onLoadFailed(exception);
    <span class="hljs-keyword">return</span>;
  &#125;

  <span class="hljs-keyword">if</span> (!canSetResource()) &#123;
    releaseResource(resource);
    <span class="hljs-comment">// 设置加载状态完成</span>
    status = Status.COMPLETE;
    <span class="hljs-keyword">return</span>;
  &#125;

  onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReady</span><span class="hljs-params">(Resource&lt;R&gt; resource, R result, DataSource dataSource)</span> </span>&#123;
  <span class="hljs-comment">// We must call isFirstReadyResource before setting status.</span>
  <span class="hljs-keyword">boolean</span> isFirstResource = isFirstReadyResource();
  status = Status.COMPLETE;
  <span class="hljs-keyword">this</span>.resource = resource;

  <span class="hljs-keyword">if</span> (glideContext.getLogLevel() &lt;= Log.DEBUG) &#123;
    Log.d(GLIDE_TAG, <span class="hljs-string">"Finished loading "</span> + result.getClass().getSimpleName() + <span class="hljs-string">" from "</span>
        + dataSource + <span class="hljs-string">" for "</span> + model + <span class="hljs-string">" with size ["</span> + width + <span class="hljs-string">"x"</span> + height + <span class="hljs-string">"] in "</span>
        + LogTime.getElapsedMillis(startTime) + <span class="hljs-string">" ms"</span>);
  &#125;

  isCallingCallbacks = <span class="hljs-keyword">true</span>;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">boolean</span> anyListenerHandledUpdatingTarget = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (requestListeners != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">for</span> (RequestListener&lt;R&gt; listener : requestListeners) &#123;
        anyListenerHandledUpdatingTarget |=
            listener.onResourceReady(result, model, target, dataSource, isFirstResource);
      &#125;
    &#125;
    anyListenerHandledUpdatingTarget |=
        targetListener != <span class="hljs-keyword">null</span>
            &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);

    <span class="hljs-keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;
      Transition&lt;? <span class="hljs-keyword">super</span> R&gt; animation =
          animationFactory.build(dataSource, isFirstResource);
      target.onResourceReady(result, animation);
    &#125;
  &#125; <span class="hljs-keyword">finally</span> &#123;
    isCallingCallbacks = <span class="hljs-keyword">false</span>;
  &#125;
  
  notifyLoadSuccess();
&#125;</code></pre>
<p>在<code>SingleRequest.onSourceReady()</code>主要回调了<code>Target.onResourceReady()</code>，把<code>Resource</code>显示到<code>Target</code>上，实质就是<code>into()</code>传入的Target对象。</p>
<pre><code class="hljs java"> <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReady</span><span class="hljs-params">(@NonNull Z resource, @Nullable Transition&lt;? <span class="hljs-keyword">super</span> Z&gt; transition)</span> </span>&#123;
   <span class="hljs-keyword">if</span> (transition == <span class="hljs-keyword">null</span> || !transition.transition(resource, <span class="hljs-keyword">this</span>)) &#123;
     setResourceInternal(resource);
   &#125; <span class="hljs-keyword">else</span> &#123;
     maybeUpdateAnimatable(resource);
   &#125;
 &#125;

 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResourceInternal</span><span class="hljs-params">(@Nullable Z resource)</span> </span>&#123;
   <span class="hljs-comment">// Order matters here. Set the resource first to make sure that the Drawable has a valid and</span>
   <span class="hljs-comment">// non-null Callback before starting it.</span>
   setResource(resource);
   maybeUpdateAnimatable(resource);
 &#125;

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResource</span><span class="hljs-params">(@Nullable Z resource)</span></span>;</code></pre>
<p>其中有两个类继承了<code>ImageViewTarget</code>用于实现不同的功能。分别是<code>DrawableImageViewTarget</code>、<code>BitmapImageViewTarget</code>。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawableImageViewTarget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImageViewTarget</span>&lt;<span class="hljs-title">Drawable</span>&gt; </span>&#123;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DrawableImageViewTarget</span><span class="hljs-params">(ImageView view)</span> </span>&#123;
    <span class="hljs-keyword">super</span>(view);
  &#125;

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@deprecated</span> Use &#123;<span class="hljs-doctag">@link</span> #waitForLayout()&#125; instead.
   */</span>
  <span class="hljs-comment">// Public API.</span>
  <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"unused"</span>, <span class="hljs-string">"deprecation"</span>&#125;)
  <span class="hljs-meta">@Deprecated</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DrawableImageViewTarget</span><span class="hljs-params">(ImageView view, <span class="hljs-keyword">boolean</span> waitForLayout)</span> </span>&#123;
    <span class="hljs-keyword">super</span>(view, waitForLayout);
  &#125;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResource</span><span class="hljs-params">(@Nullable Drawable resource)</span> </span>&#123;
    view.setImageDrawable(resource);
  &#125;
&#125;</code></pre>
<p>最终通过<code>ImageView.setImageDrawable()</code>将图片显示在ImageView上。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide显示图片.png" srcset="/img/loading.gif" class="full-image" alt="Glide显示图片" title="Glide显示图片"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="Glide缓存实现原理"><a href="#Glide缓存实现原理" class="headerlink" title="Glide缓存实现原理"></a>Glide缓存实现原理</h2><blockquote>
<p>Glide的缓存主要分成了两个模块，一个是<strong>内存缓存</strong>，另一部分是<strong>硬盘缓存</strong>。</p>
<p><strong>内存缓存</strong>：防止应用重复将图片数据读取到内存当中</p>
<p><strong>硬盘缓存</strong>：防止应用重复从网络或其他地方重复下载和读取数据</p>
</blockquote>
<h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><p>1.在自定义的<code>GlideModule</code>中的<code>applyOptions()</code>中设置具体的缓存参数</p>
<pre><code class="hljs java"><span class="hljs-meta">@GlideModule</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomGlideModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppGlideModule</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyOptions</span><span class="hljs-params">(Context context, GlideBuilder builder)</span> </span>&#123;
        MemorySizeCalculator calculator = <span class="hljs-keyword">new</span> MemorySizeCalculator.Builder(context).build();
        <span class="hljs-keyword">int</span> defaultMemoryCacheSize = calculator.getMemoryCacheSize();
        <span class="hljs-keyword">int</span> defaultBitmapPoolSize = calculator.getBitmapPoolSize();
        <span class="hljs-keyword">int</span> customMemoryCacheSize = (<span class="hljs-keyword">int</span>) (<span class="hljs-number">1.2</span> * defaultMemoryCacheSize);
        <span class="hljs-keyword">int</span> customBitmapPoolSize = (<span class="hljs-keyword">int</span>) (<span class="hljs-number">1.2</span> * defaultBitmapPoolSize);
        builder.setMemoryCache(<span class="hljs-keyword">new</span> LruResourceCache(customMemoryCacheSize));
        builder.setBitmapPool(<span class="hljs-keyword">new</span> LruBitmapPool(customBitmapPoolSize));
    &#125;
&#125;</code></pre>
<p>2.在具体请求中设置缓存参数</p>
<pre><code class="hljs java"><span class="hljs-comment">//设置 不在磁盘中进行缓存且内存中也不缓存</span>
val requestBuilder =Glide.with(<span class="hljs-keyword">this</span>).asBitmap().apply(RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(<span class="hljs-keyword">true</span>)).load(path)</code></pre>
<h3 id="缓存Key"><a href="#缓存Key" class="headerlink" title="缓存Key"></a>缓存Key</h3><p>缓存功能，就需要有对应的缓存Key，应用可以根据这个Key找到对应的缓存文件。Glide的缓存Key生成代码如下</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; <span class="hljs-function">LoadStatus <span class="hljs-title">load</span><span class="hljs-params">(...）&#123;
      EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,resourceClass, transcodeClass, options)</span></span>;
...
&#125;</code></pre>
<p><code>model</code>对应的就是<code>load()</code>过程中传入的参数，例如传入<code>String(图片加载地址)</code>，那么对应的就是加载地址。决定生成Key的参数有很多。</p>
<p>如果设置了<code>override</code>修改了加载尺寸，那也会有不同的key生成。</p>
<h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>默认情况下，内存缓存是自动开启的，加载图片完成后，就会默认在内存中缓存，然后下次再调用时就会从内存中直接读取显示，无需重新加载。</p>
<blockquote>
<p>可以通过设置<code>skipMemoryCache(true)</code>来关闭内存缓存功能。</p>
</blockquote>
<p>Glide中的内存缓存主要分为两部分处理：<strong>弱引用复用机制</strong>和<strong>LRUCache</strong>。</p>
<h4 id="弱引用复用-——-ActiveResources"><a href="#弱引用复用-——-ActiveResources" class="headerlink" title="弱引用复用 —— ActiveResources"></a>弱引用复用 —— ActiveResources</h4><blockquote>
<p>从正在活动的资源中取出缓存进行复用</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; <span class="hljs-function">LoadStatus <span class="hljs-title">load</span><span class="hljs-params">(...)</span></span>&#123;
  ...
    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);
    <span class="hljs-keyword">if</span> (active != <span class="hljs-keyword">null</span>) &#123;
      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;
        logWithTimeAndKey(<span class="hljs-string">"Loaded resource from active resources"</span>, startTime, key);
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
  ...
&#125;

  <span class="hljs-meta">@Nullable</span>
 <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class="hljs-keyword">boolean</span> isMemoryCacheable) &#123;
    <span class="hljs-keyword">if</span> (!isMemoryCacheable) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    EngineResource&lt;?&gt; active = activeResources.get(key);
    <span class="hljs-keyword">if</span> (active != <span class="hljs-keyword">null</span>) &#123;
      active.acquire();
    &#125;
    <span class="hljs-keyword">return</span> active;
  &#125;</code></pre>
<p>对应的Resource文件要从<code>ActiveResource</code>中获取</p>
<pre><code class="hljs java"><span class="hljs-keyword">final</span> Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

  <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deactivate</span><span class="hljs-params">(Key key)</span> </span>&#123;
    ResourceWeakReference removed = activeEngineResources.remove(key);
    <span class="hljs-keyword">if</span> (removed != <span class="hljs-keyword">null</span>) &#123;
      removed.reset();
    &#125;
  &#125;

<span class="hljs-meta">@Nullable</span>
  <span class="hljs-keyword">synchronized</span> EngineResource&lt;?&gt; get(Key key) &#123;
    <span class="hljs-comment">//获取Key对应的弱引用对象</span>
    ResourceWeakReference activeRef = activeEngineResources.get(key);
    <span class="hljs-keyword">if</span> (activeRef == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    EngineResource&lt;?&gt; active = activeRef.get();
    <span class="hljs-keyword">if</span> (active == <span class="hljs-keyword">null</span>) &#123;
      cleanupActiveReference(activeRef);
    &#125;
    <span class="hljs-keyword">return</span> active;
  &#125;

  <span class="hljs-comment">//清除当前被GC的对象</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanupActiveReference</span><span class="hljs-params">(@NonNull ResourceWeakReference ref)</span> </span>&#123;
    <span class="hljs-keyword">synchronized</span> (listener) &#123;
      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
        activeEngineResources.remove(ref.key);
        <span class="hljs-keyword">if</span> (!ref.isCacheable || ref.resource == <span class="hljs-keyword">null</span>) &#123;
          <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">//创建新的Resource对象 ref.resource是强引用类型</span>
        EngineResource&lt;?&gt; newResource =
            <span class="hljs-keyword">new</span> EngineResource&lt;&gt;(ref.resource, <span class="hljs-comment">/*isCacheable=*/</span> <span class="hljs-keyword">true</span>, <span class="hljs-comment">/*isRecyclable=*/</span> <span class="hljs-keyword">false</span>);
        newResource.setResourceListener(ref.key, listener);
        <span class="hljs-comment">//将ref缓存进内存中</span>
        listener.onResourceReleased(ref.key, newResource);
      &#125;
    &#125;
  &#125;

 <span class="hljs-meta">@VisibleForTesting</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceWeakReference</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">EngineResource</span>&lt;?&gt;&gt; </span>&#123;
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"WeakerAccess"</span>) <span class="hljs-meta">@Synthetic</span> <span class="hljs-keyword">final</span> Key key;
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"WeakerAccess"</span>) <span class="hljs-meta">@Synthetic</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isCacheable;
    <span class="hljs-meta">@Nullable</span> <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"WeakerAccess"</span>) <span class="hljs-meta">@Synthetic</span> Resource&lt;?&gt; resource;
    <span class="hljs-meta">@Synthetic</span>
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"WeakerAccess"</span>)
    ResourceWeakReference(
        <span class="hljs-meta">@NonNull</span> Key key,
        <span class="hljs-meta">@NonNull</span> EngineResource&lt;?&gt; referent,
        <span class="hljs-meta">@NonNull</span> ReferenceQueue&lt;? <span class="hljs-keyword">super</span> EngineResource&lt;?&gt;&gt; queue,
        <span class="hljs-keyword">boolean</span> isActiveResourceRetentionAllowed) &#123;
      <span class="hljs-keyword">super</span>(referent, queue);
      <span class="hljs-keyword">this</span>.key = Preconditions.checkNotNull(key);
      <span class="hljs-keyword">this</span>.resource =
          referent.isCacheable() &amp;&amp; isActiveResourceRetentionAllowed
              ? Preconditions.checkNotNull(referent.getResource()) : <span class="hljs-keyword">null</span>;
      isCacheable = referent.isCacheable();
    &#125;
    <span class="hljs-comment">//清除强引用部分，方便回收</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;
      resource = <span class="hljs-keyword">null</span>;
      clear();
    &#125;
  &#125;</code></pre>
<p><code>listener</code>对应的就是<code>Engine</code>对象，调用到<code>Engine.onResourceReleased()</code></p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReleased</span><span class="hljs-params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> </span>&#123;   
  <span class="hljs-comment">//清除该key的强引用</span>
  activeResources.deactivate(cacheKey);
  <span class="hljs-keyword">if</span> (resource.isCacheable()) &#123;
    <span class="hljs-comment">//缓存数据到内存缓存LRUCache中</span>
    cache.put(cacheKey, resource);
  &#125; <span class="hljs-keyword">else</span> &#123;
    resourceRecycler.recycle(resource);
  &#125;
&#125;</code></pre>
<p><code>ActivieResources</code>采用<code>HashMap + WeakReference</code>来保存<code>EngineResource</code>，不会有上限。然后<code>get()</code>从<code>activeEngineResources</code>弱引用HashMap中获取数据，这里分为两种情况：</p>
<ol>
<li>获取到弱引用关联对象<code>EngineResource</code>，则直接返回结果</li>
<li>获取不到关联对象，则需进行清除工作调用<code>cleanupActiveResource()</code>，在<code>activeEngineResources</code>移除对应的key和引用，在判断是否开启缓存，若开启则缓存至<code>LRUCache</code>中。</li>
</ol>
<p>总结：</p>
<p><code>ActiveResources</code>采用弱引用的方式，里面存储的是<code>EngineResource</code>，同时采用强引用保存<code>EngineResource.resource</code>，在<code>ActiveResources</code>中还会有一个清理线程在运行，负责当<code>EngineResource</code>被回收时，就去取出对应的<code>EngineResource.resource</code>，然后创建一个新的<code>EngineResource</code>对象，回调到<code>Engine.onResourceReleased()</code>中，在其中做内存缓存，之后调用<code>ActivityResources.deactivate()</code>移除对应的强引用。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/内存缓存-弱引用机制.png" srcset="/img/loading.gif" class="full-image" alt="内存缓存-弱引用机制" title="内存缓存-弱引用机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h4><blockquote>
<p>在当前活动资源中没有对应的缓存时，就要从内存中去进行读取</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; <span class="hljs-function">LoadStatus <span class="hljs-title">load</span><span class="hljs-params">(...)</span></span>&#123;
  ...
    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);
    <span class="hljs-keyword">if</span> (cached != <span class="hljs-keyword">null</span>) &#123;
      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;
        logWithTimeAndKey(<span class="hljs-string">"Loaded resource from cache"</span>, startTime, key);
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;

  <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class="hljs-keyword">boolean</span> isMemoryCacheable) &#123;
    <span class="hljs-comment">//不允许缓存 直接返回null</span>
    <span class="hljs-keyword">if</span> (!isMemoryCacheable) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;

    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);①
    <span class="hljs-keyword">if</span> (cached != <span class="hljs-keyword">null</span>) &#123;
      cached.acquire();
      <span class="hljs-comment">//存入活动资源中</span>
      activeResources.activate(key, cached);②
    &#125;
    <span class="hljs-keyword">return</span> cached;
  &#125;

  <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;
    Resource&lt;?&gt; cached = cache.remove(key);③

    <span class="hljs-keyword">final</span> EngineResource&lt;?&gt; result;
    <span class="hljs-keyword">if</span> (cached == <span class="hljs-keyword">null</span>) &#123;
      result = <span class="hljs-keyword">null</span>;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cached <span class="hljs-keyword">instanceof</span> EngineResource) &#123;
      result = (EngineResource&lt;?&gt;) cached;
    &#125; <span class="hljs-keyword">else</span> &#123;
      result = <span class="hljs-keyword">new</span> EngineResource&lt;&gt;(cached, <span class="hljs-keyword">true</span> <span class="hljs-comment">/*isMemoryCacheable*/</span>, <span class="hljs-keyword">true</span> <span class="hljs-comment">/*isRecyclable*/</span>);
    &#125;
    <span class="hljs-keyword">return</span> result;
  &#125;</code></pre>
<p><code>loadFromCache()</code>实际调用到<code>getEngineResourceFromCache()</code>获取内存缓存中的资源，如果找到，缓存数量+1，然后会把<code>cached</code>放入<code>ActiveResources</code>中，变为活动资源，对应的要在<code>内存缓存</code>中移除引用。</p>
<p>①<code>getEngineResourceFromCache(key)</code>：从内存缓存中根据缓存key获取缓存</p>
<p>②<code>activeResources.activate(key, cached)</code>：取出的缓存数据存入到活动资源中</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">activate</span><span class="hljs-params">(Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;
  <span class="hljs-comment">//构件新的 弱引用对象</span>
  ResourceWeakReference toPut =
      <span class="hljs-keyword">new</span> ResourceWeakReference(
          key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);
  
  ResourceWeakReference removed = activeEngineResources.put(key, toPut);
  <span class="hljs-comment">//如果存在替换，也需要把旧数据回收</span>
  <span class="hljs-keyword">if</span> (removed != <span class="hljs-keyword">null</span>) &#123;
    removed.reset();
  &#125;
&#125;</code></pre>
<p>③<code>cache.remove(key)</code>：从内存缓存中移除对应缓存</p>
<p><code>cache</code>对应的是<code>MemoryCache</code>是一个接口，实现类为<code>LruResourceCache</code></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LruResourceCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LruCache</span>&lt;<span class="hljs-title">Key</span>, <span class="hljs-title">Resource</span>&lt;?&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">MemoryCache</span> </span>&#123;
  <span class="hljs-keyword">private</span> ResourceRemovedListener listener;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LruResourceCache</span><span class="hljs-params">(<span class="hljs-keyword">long</span> size)</span> </span>&#123;
    <span class="hljs-keyword">super</span>(size);
  &#125;

  <span class="hljs-comment">//监听资源移除</span>
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResourceRemovedListener</span><span class="hljs-params">(@NonNull ResourceRemovedListener listener)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.listener = listener;
  &#125;

  <span class="hljs-comment">//当前缓存被淘汰是调用</span>
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemEvicted</span><span class="hljs-params">(@NonNull Key key, @Nullable Resource&lt;?&gt; item)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (listener != <span class="hljs-keyword">null</span> &amp;&amp; item != <span class="hljs-keyword">null</span>) &#123;
      listener.onResourceRemoved(item);
    &#125;
  &#125;
  <span class="hljs-comment">//获取当前缓存大小</span>
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(@Nullable Resource&lt;?&gt; item)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (item == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getSize(<span class="hljs-keyword">null</span>);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-keyword">return</span> item.getSize();
    &#125;
  &#125;

  <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">"InlinedApi"</span>)
  <span class="hljs-meta">@Override</span>
  <span class="hljs-comment">//内存不足时 触发</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimMemory</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (level &gt;= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) &#123;
      clearMemory();
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level &gt;= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) &#123;
      trimToSize(getMaxSize() / <span class="hljs-number">2</span>);
    &#125;
  &#125;
&#125;</code></pre>
<p><code>LruResourceCache</code>继承自<code>LruCache</code>，不过内部计算缓存大小是通过<code>Resource</code>对象的大小累计，还增加了资源移除监听，为了和<code>ActiveResources</code>进行联动。</p>
<p><code>LruResourceCache</code>的<code>size</code>是在自定义<code>GlideModule</code>中的 <code>applyOptions()</code>时设置进来的，如果未设置会采用<code>MemorySizeCalculator.getMemoryCacheSize()</code>设置。</p>
<p>当前在内存中缓存的对象都是<code>Resource</code>，而不是通常认为的Bitmap，下面会介绍到转码的过程。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/内存缓存-LruCache.png" srcset="/img/loading.gif" class="full-image" alt="内存缓存-LruCache" title="内存缓存-LruCache"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在<code>内存缓存</code>中，分为两种方案：<strong>从弱引用中获取</strong>、<strong>从内存缓存中获取</strong>。两者的关系简单概括就是：</p>
<blockquote>
<p>读取内存缓存时，会优先从<code>ActiveResources</code>中读取，读取到的话，需要判断当前包装<code>Resource</code>的弱引用对象是否被回收，未回收则直接返回。被回收的话，需要重新包装<code>EngineResource.resource</code>然后存入到内存缓存中并需要移除<code>ActiveResources</code>对其的引用。</p>
<p>从<code>ActiveResources</code>中没有获取到对应缓存时，就从<code>LruResourceCache</code>中去获取，获取到的话，就需要从当前内存缓存中移除对应缓存引用，并存入到<code>ActiveResources</code>中。</p>
<p><strong>实现了正在使用的图片通过弱引用进行缓存，未使用的图片通过LruCache进行缓存。</strong></p>
<p><code>ActiveResources</code>优先级高于<code>LruResourceCache</code>。</p>
</blockquote>
<p>比较两者之间的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>弱引用获取</th>
<th>内存缓存获取</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础实现</td>
<td>HashMap</td>
<td>LinkedHashMap(<em>LruCache</em>)</td>
</tr>
<tr>
<td>可否禁用</td>
<td>用户无法禁用</td>
<td>通过<code>skipMemoryCache(true)</code>禁用</td>
</tr>
<tr>
<td>运行位置</td>
<td>内存</td>
<td>内存</td>
</tr>
<tr>
<td>释放时机</td>
<td>依赖垃圾回收机制<br><strong>弱引用实现，GC时被回收</strong></td>
<td>采用<strong>最近最少使用</strong>来淘汰数据</td>
</tr>
</tbody>
</table>
<h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><blockquote>
<p>当内存中不存在缓存时，就会向下从硬盘中去读取缓存数据</p>
<p>通过设置<code>diskCacheStrategy(DiskCacheStrategy.NONE)</code>来关闭硬盘缓存功能。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; <span class="hljs-function">LoadStatus <span class="hljs-title">load</span><span class="hljs-params">(...)</span></span>&#123;
  ...
    <span class="hljs-comment">//判断当前是否存在该任务 EngineJob</span>
    <span class="hljs-comment">// private final Map&lt;Key, EngineJob&lt;?&gt;&gt; jobs = new HashMap&lt;&gt;();</span>
    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);
    <span class="hljs-keyword">if</span> (current != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">//资源加载完毕通知回调</span>
      current.addCallback(cb, callbackExecutor);
      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;
        logWithTimeAndKey(<span class="hljs-string">"Added to existing load"</span>, startTime, key);
      &#125;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadStatus(cb, current);
    &#125;
    <span class="hljs-comment">//内部维护线程池，用来管理资源加载</span>
    EngineJob&lt;R&gt; engineJob =
        engineJobFactory.build(...);
    <span class="hljs-comment">//用来进行资源加载</span>
    DecodeJob&lt;R&gt; decodeJob =
        decodeJobFactory.build(... , engineJob);
    <span class="hljs-comment">//插入任务列表中</span>
    jobs.put(key, engineJob);

    engineJob.addCallback(cb, callbackExecutor);
    <span class="hljs-comment">//开始进行加载</span>
    engineJob.start(decodeJob);

&#125;</code></pre>
<p>从内存中读取不到缓存时，<code>Engine</code>尝试从<code>jobs</code>读取对应的<code>EngineJob</code>缓存，如存在就去回调<code>加载成功或加载失败</code>。不存在的话，就需要新建一个<code>EngineJob</code>以及<code>DecodeJob</code>去加载图片。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;
  <span class="hljs-keyword">this</span>.decodeJob = decodeJob;
  GlideExecutor executor = decodeJob.willDecodeFromCache()
      ? diskCacheExecutor
      : getActiveSourceExecutor();
  executor.execute(decodeJob);
&#125;</code></pre>
<p>通过线程池去执行<code>decodeJob</code>，<code>DecodeJob</code>实现了<code>Runnable</code>接口，<code>execute()</code>直接调用到<code>run()</code></p>
<pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"PMD.AvoidRethrowingException"</span>)
 <span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-comment">//统计执行时长</span>
   GlideTrace.beginSectionFormat(<span class="hljs-string">"DecodeJob#run(model=%s)"</span>, model);
   DataFetcher&lt;?&gt; localFetcher = currentFetcher;
   <span class="hljs-keyword">try</span> &#123;
     <span class="hljs-keyword">if</span> (isCancelled) &#123;
       notifyFailed();
       <span class="hljs-keyword">return</span>;
     &#125;
     <span class="hljs-comment">//实际执行逻辑</span>
     runWrapped();
   &#125; <span class="hljs-keyword">catch</span> (CallbackException e) &#123;
     <span class="hljs-keyword">throw</span> e;
   &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
     <span class="hljs-keyword">if</span> (stage != Stage.ENCODE) &#123;
       throwables.add(t);
       notifyFailed();
     &#125;
     <span class="hljs-keyword">if</span> (!isCancelled) &#123;
       <span class="hljs-keyword">throw</span> t;
     &#125;
     <span class="hljs-keyword">throw</span> t;
   &#125; <span class="hljs-keyword">finally</span> &#123;
     <span class="hljs-comment">// Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call</span>
     <span class="hljs-comment">// close in all cases anyway.</span>
     <span class="hljs-keyword">if</span> (localFetcher != <span class="hljs-keyword">null</span>) &#123;
       localFetcher.cleanup();
     &#125;
     GlideTrace.endSection();
   &#125;
 &#125;

 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWrapped</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-keyword">switch</span> (runReason) &#123;
     <span class="hljs-keyword">case</span> INITIALIZE:
       stage = getNextStage(Stage.INITIALIZE);
       currentGenerator = getNextGenerator();
       runGenerators();
       <span class="hljs-keyword">break</span>;
     <span class="hljs-keyword">case</span> SWITCH_TO_SOURCE_SERVICE:
       runGenerators();
       <span class="hljs-keyword">break</span>;
     <span class="hljs-keyword">case</span> DECODE_DATA:
       <span class="hljs-comment">//解析数据并解码</span>
       decodeFromRetrievedData();
       <span class="hljs-keyword">break</span>;
     <span class="hljs-keyword">default</span>:
       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unrecognized run reason: "</span> + runReason);
   &#125;
 &#125;

 <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> RunReason &#123;
   <span class="hljs-comment">//第一次执行</span>
   INITIALIZE,
   <span class="hljs-comment">//从Cache中去读取数据失败，则从其他渠道读取</span>
   SWITCH_TO_SOURCE_SERVICE,
   <span class="hljs-comment">//解析数据</span>
   DECODE_DATA,
 &#125;</code></pre>
<p>调用<code>DecodeJob.run()</code>开始加载资源，内部调用<code>runWrapped()</code>，此时<code>runWrapped()</code>中会根据<code>runReason</code>执行不同的操作，<code>runReason</code>就是用于控制当前执行到的任务。</p>
<blockquote>
<p><code>INITIALIZE</code>：第一次调用<code>run()</code>，执行目的是从<code>diskcache</code>中获取缓存</p>
<p><code>SWITCH_TO_SOURCE_SERVICE</code>：从<code>diskcache</code>中获取缓存失败，需要从数据源获取</p>
<p><code>DECODE_DATA</code>：缓存数据成功，对数据进行解析</p>
</blockquote>
<h4 id="获取硬盘缓存数据"><a href="#获取硬盘缓存数据" class="headerlink" title="获取硬盘缓存数据"></a>获取硬盘缓存数据</h4><pre><code class="hljs java"><span class="hljs-comment">//通过 RequestOptions.diskCacheStrategy() 设置</span>
<span class="hljs-keyword">private</span> DiskCacheStrategy diskCacheStrategy;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runGenerators</span><span class="hljs-params">()</span> </span>&#123;
    currentThread = Thread.currentThread();
    startFetchTime = LogTime.getLogTime();
    <span class="hljs-keyword">boolean</span> isStarted = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="hljs-keyword">null</span>
        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;
      stage = getNextStage(stage);
      currentGenerator = getNextGenerator();

      <span class="hljs-keyword">if</span> (stage == Stage.SOURCE) &#123;
        reschedule();
        <span class="hljs-keyword">return</span>;
      &#125;
    &#125;
    <span class="hljs-comment">// We've run out of stages and generators, give up.</span>
    <span class="hljs-keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;
      notifyFailed();
    &#125;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">private</span> Stage <span class="hljs-title">getNextStage</span><span class="hljs-params">(Stage current)</span> </span>&#123;
    <span class="hljs-keyword">switch</span> (current) &#123;
      <span class="hljs-keyword">case</span> INITIALIZE:
        <span class="hljs-comment">//支持转换后的图片缓存 返回状态就是RESOURCE_CACHE</span>
        <span class="hljs-keyword">return</span> diskCacheStrategy.decodeCachedResource()
            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
      <span class="hljs-keyword">case</span> RESOURCE_CACHE:
        <span class="hljs-comment">//支持转换后的图片缓存 返回状态就是DATA_CACHE</span>
        <span class="hljs-keyword">return</span> diskCacheStrategy.decodeCachedData()
            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
      <span class="hljs-keyword">case</span> DATA_CACHE:
        <span class="hljs-comment">//如果缓存已存在 就返回结束 否则去加载远程图片</span>
        <span class="hljs-keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
      <span class="hljs-keyword">case</span> SOURCE:
      <span class="hljs-keyword">case</span> FINISHED:
        <span class="hljs-keyword">return</span> Stage.FINISHED;
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unrecognized stage: "</span> + current);
    &#125;
  &#125;

  <span class="hljs-comment">//根据不同的步骤 调用不同的Generator对象</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> DataFetcherGenerator <span class="hljs-title">getNextGenerator</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">switch</span> (stage) &#123;
      <span class="hljs-keyword">case</span> RESOURCE_CACHE:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">case</span> DATA_CACHE:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataCacheGenerator(decodeHelper, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">case</span> SOURCE:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SourceGenerator(decodeHelper, <span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">case</span> FINISHED:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unrecognized stage: "</span> + stage);
    &#125;
  &#125;

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> Stage &#123;
    <span class="hljs-comment">//加载初始状态</span>
    INITIALIZE,
    <span class="hljs-comment">//转换后图片的缓存</span>
    RESOURCE_CACHE,
    <span class="hljs-comment">//原图缓存</span>
    DATA_CACHE,
    <span class="hljs-comment">//远程图片</span>
    SOURCE,
    <span class="hljs-comment">//解析图片</span>
    ENCODE,
    <span class="hljs-comment">//加载完成</span>
    FINISHED,
  &#125;</code></pre>
<p><code>stage</code>对应<code>Stage</code>枚举类，可以通过<code>DiskCacheStrategy</code>得到<code>Stage</code>。</p>
<blockquote>
<p><code>DiskCacheStrategy</code>参数解释：</p>
<ul>
<li><code>NONE</code>：表示不缓存任何内容</li>
<li><code>DATA</code>：只缓存原始图片</li>
<li><code>RESOURCE</code>：只缓存转换后的图片</li>
<li><code>ALL</code>：原始图片和转换后的图片都进行缓存</li>
<li><code>AUTOMATIC</code>：尝试选择最佳策略。针对加载数据类型进行区分：<ul>
<li>加载本地图片：缓存原始图片</li>
<li>加载网络图片：缓存转换后的图片</li>
</ul>
</li>
</ul>
</blockquote>
<p><code>stage</code>默认尽量就是<code>INITIALIZE</code>，通过递归调用<code>getNextStage()</code>向下推进，并改变<code>stage</code>表示进行状态。<code>stage</code>的推进过程也表示了硬盘缓存的查找顺序。</p>
<table>
<thead>
<tr>
<th>Stage</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>INITIALIZE</td>
<td>初始状态</td>
</tr>
<tr>
<td>RESOURCE_CACHE</td>
<td>转换后缓存 调用<code>ResourceCacheGenerator</code></td>
</tr>
<tr>
<td>DATA_CACHE</td>
<td>原图缓存 调用<code>DataCacheGenerator</code></td>
</tr>
<tr>
<td>SOURCE</td>
<td>远程获取图片 调用<code>SourceGenerator</code></td>
</tr>
<tr>
<td>ENCODE</td>
<td>解析资源，生成<code>Resource</code>对象</td>
</tr>
<tr>
<td>FINISHED</td>
<td>解析完成</td>
</tr>
</tbody>
</table>
<p>查找缓存从<code>初始查找开始</code>-&gt;<code>查找转换后图片缓存</code>-&gt;<code>查找原图图片缓存</code>-&gt;<code>前面都没找到就去进行远程加载</code>-&gt;<code>加载完成后就开始解析数据</code>-&gt;<code>解析完成</code>。</p>
<p>查找缓存从<code>currentGenerator.startNext()</code>开始，就先从<code>ResourceCacheGenerator</code>开始</p>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> File cacheFile;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startNext</span><span class="hljs-params">()</span> </span>&#123;
  List&lt;Key&gt; sourceIds = helper.getCacheKeys();
  <span class="hljs-keyword">if</span> (sourceIds.isEmpty()) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
  &#125;
  List&lt;Class&lt;?&gt;&gt; resourceClasses = helper.getRegisteredResourceClasses();
  <span class="hljs-keyword">if</span> (resourceClasses.isEmpty()) &#123;
    <span class="hljs-keyword">if</span> (File.class.equals(helper.getTranscodeClass())) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(
       <span class="hljs-string">"Failed to find any load path from "</span> + helper.getModelClass() + <span class="hljs-string">" to "</span>
           + helper.getTranscodeClass());
  &#125;
  <span class="hljs-keyword">while</span> (modelLoaders == <span class="hljs-keyword">null</span> || !hasNextModelLoader()) &#123;
    resourceClassIndex++;
    <span class="hljs-keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) &#123;
      sourceIdIndex++;
      <span class="hljs-keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
      &#125;
      resourceClassIndex = <span class="hljs-number">0</span>;
    &#125;

    Key sourceId = sourceIds.get(sourceIdIndex);
    Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);
    Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);
    <span class="hljs-comment">//构建磁盘缓存key</span>
    currentKey =
        <span class="hljs-keyword">new</span> ResourceCacheKey(<span class="hljs-comment">// NOPMD AvoidInstantiatingObjectsInLoops</span>
            helper.getArrayPool(),
            sourceId,
            helper.getSignature(),
            helper.getWidth(),
            helper.getHeight(),
            transformation,
            resourceClass,
            helper.getOptions());
    <span class="hljs-comment">//根据Key去获取cacheFile</span>
    cacheFile = helper.getDiskCache().get(currentKey);
    <span class="hljs-keyword">if</span> (cacheFile != <span class="hljs-keyword">null</span>) &#123;
      sourceKey = sourceId;
      modelLoaders = helper.getModelLoaders(cacheFile);
      modelLoaderIndex = <span class="hljs-number">0</span>;
    &#125;
  &#125;

  loadData = <span class="hljs-keyword">null</span>;
  <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;
  <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;
    <span class="hljs-comment">//使用FileLoader去加载对应cache文件</span>
    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);
    loadData = modelLoader.buildLoadData(cacheFile,
        helper.getWidth(), helper.getHeight(), helper.getOptions());
    <span class="hljs-keyword">if</span> (loadData != <span class="hljs-keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;
      started = <span class="hljs-keyword">true</span>;
      loadData.fetcher.loadData(helper.getPriority(), <span class="hljs-keyword">this</span>);
    &#125;
  &#125;

  <span class="hljs-keyword">return</span> started;
&#125;</code></pre>
<p>根据相关参数生成对应的<code>cacheKey</code>，然后从<code>DiskCache</code>中取出对应的<code>cacheFile</code>，然后使用<code>FileLoader</code>解析该文件。</p>
<blockquote>
<p><code>helper.getDiskCache()</code>对应的就是<code>DiskLruCacheWrapper</code>类，内部包装了<code>DiskLruCache</code>，内部实现了整套的文件读写功能。</p>
</blockquote>
<h4 id="远程获取数据"><a href="#远程获取数据" class="headerlink" title="远程获取数据"></a>远程获取数据</h4><p>若为初次加载的数据，肯定不会在<code>diskCache</code>中获取到，就需要远程加载。</p>
<pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startNext</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">//判断当前是否存在缓存</span>
    <span class="hljs-keyword">if</span> (dataToCache != <span class="hljs-keyword">null</span>) &#123;
      Object data = dataToCache;
      dataToCache = <span class="hljs-keyword">null</span>;
      
      cacheData(data);
    &#125;
    <span class="hljs-comment">//存在缓存</span>
    <span class="hljs-keyword">if</span> (sourceCacheGenerator != <span class="hljs-keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    sourceCacheGenerator = <span class="hljs-keyword">null</span>;

    loadData = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;
      loadData = helper.getLoadData().get(loadDataListIndex++);
      <span class="hljs-keyword">if</span> (loadData != <span class="hljs-keyword">null</span> &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;
        started = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">//加载远程图片</span>
        loadData.fetcher.loadData(helper.getPriority(), <span class="hljs-keyword">this</span>);
      &#125;
    &#125;
    <span class="hljs-keyword">return</span> started;
  &#125;
<span class="hljs-comment">//缓存至磁盘中</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheData</span><span class="hljs-params">(Object dataToCache)</span> </span>&#123;
    <span class="hljs-keyword">long</span> startTime = LogTime.getLogTime();
    <span class="hljs-keyword">try</span> &#123;
      Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);
      DataCacheWriter&lt;Object&gt; writer =
          <span class="hljs-keyword">new</span> DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());
      originalKey = <span class="hljs-keyword">new</span> DataCacheKey(loadData.sourceKey, helper.getSignature());
      helper.getDiskCache().put(originalKey, writer);
      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;
        Log.v(TAG, <span class="hljs-string">"Finished encoding source to cache"</span>
            + <span class="hljs-string">", key: "</span> + originalKey
            + <span class="hljs-string">", data: "</span> + dataToCache
            + <span class="hljs-string">", encoder: "</span> + encoder
            + <span class="hljs-string">", duration: "</span> + LogTime.getElapsedMillis(startTime));
      &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
      loadData.fetcher.cleanup();
    &#125;

    sourceCacheGenerator =
        <span class="hljs-keyword">new</span> DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, <span class="hljs-keyword">this</span>);
  &#125;

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDataReady</span><span class="hljs-params">(Object data)</span> </span>&#123;
    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();
    <span class="hljs-keyword">if</span> (data != <span class="hljs-keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;
      <span class="hljs-comment">//上面判断是否cache</span>
      dataToCache = data;
      cb.reschedule();
    &#125; <span class="hljs-keyword">else</span> &#123;
      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,
          loadData.fetcher.getDataSource(), originalKey);
    &#125;
  &#125;</code></pre>
<p>在<code>SourceGenerator.startNext()</code>会优先判断数据是否在<code>DiskCache</code>中，若存在调用<code>cacheData()</code>创建<code>DataCacheGenerator</code>调用其<code>startNext()</code>。不存在则循环去获取<code>loadData</code>，通过<code>DecodeHelper.getLoadData()</code>，然后继续执行<code>loadData.fetch.loadData()</code>去加载数据，加载成功后回调到<code>onDataReady()</code>。</p>
<p>现在开始按步骤分析：</p>
<h5 id="加载远程数据——地址加载-HttpUrlFetcher"><a href="#加载远程数据——地址加载-HttpUrlFetcher" class="headerlink" title="加载远程数据——地址加载(HttpUrlFetcher)"></a>加载远程数据——地址加载(<code>HttpUrlFetcher</code>)</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">(Priority priority, DataCallback&lt;? <span class="hljs-keyword">super</span> InputStream&gt; callback)</span> </span>&#123;
   <span class="hljs-keyword">try</span> &#123;
     InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, glideUrl.getHeaders());
     callback.onDataReady(result);
   &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
     callback.onLoadFailed(e);
   &#125; <span class="hljs-keyword">finally</span> &#123;
   &#125;
 &#125;</code></pre>
<h5 id="加载本地数据——本地文件加载-ByteBufferFetcher"><a href="#加载本地数据——本地文件加载-ByteBufferFetcher" class="headerlink" title="加载本地数据——本地文件加载(ByteBufferFetcher)"></a>加载本地数据——本地文件加载(<code>ByteBufferFetcher</code>)</h5><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufferFetcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DataFetcher</span>&lt;<span class="hljs-title">ByteBuffer</span>&gt; </span>&#123;
  ...
     <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">(@NonNull Priority priority,
        @NonNull DataCallback&lt;? <span class="hljs-keyword">super</span> ByteBuffer&gt; callback)</span> </span>&#123;
      ByteBuffer result;
      <span class="hljs-keyword">try</span> &#123;
        result = ByteBufferUtil.fromFile(file);
      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
        <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;
          Log.d(TAG, <span class="hljs-string">"Failed to obtain ByteBuffer for file"</span>, e);
        &#125;
        callback.onLoadFailed(e);
        <span class="hljs-keyword">return</span>;
      &#125;

      callback.onDataReady(result);
    &#125;
&#125;</code></pre>
<p><code>loadData()</code>成功后，回调到<code>SourceGenerator.onDataReady()</code>中。这时需要判断是否开启了硬盘缓存，如果关闭了直接回调到<code>DecodeJob.onDataFetcherReady()</code>，开启了的话，就继续调用到<code>DecodeJob.reschedule()</code>。</p>
<pre><code class="hljs jave">@Override
 public void reschedule() &#123;
   runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
   callback.reschedule(this);
 &#125;

 @Override
 public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,
     DataSource dataSource, Key attemptedKey) &#123;
   this.currentSourceKey = sourceKey;
   this.currentData = data;
   this.currentFetcher = fetcher;
   this.currentDataSource = dataSource;
   this.currentAttemptingKey = attemptedKey;
   if (Thread.currentThread() != currentThread) &#123;
     //向下执行 数据解析
     runReason = RunReason.DECODE_DATA;
     //再次调用到 runWrapped() 此时会走向 decodeFromRetrievedData()
     callback.reschedule(this);
   &#125; else &#123;
     GlideTrace.beginSection(&quot;DecodeJob.decodeFromRetrievedData&quot;);
     try &#123;
       // 解析数据的真正逻辑
       decodeFromRetrievedData();
     &#125; finally &#123;
       GlideTrace.endSection();
     &#125;
   &#125;
 &#125;
 
 private void runWrapped() &#123;
   switch (runReason) &#123;
     case INITIALIZE:
       stage = getNextStage(Stage.INITIALIZE);
       currentGenerator = getNextGenerator();
       runGenerators();
       break;
     case SWITCH_TO_SOURCE_SERVICE:
       runGenerators();
       break;
     case DECODE_DATA:
       //解析数据并解码
       decodeFromRetrievedData();
       break;
     default:
       throw new IllegalStateException(&quot;Unrecognized run reason: &quot; + runReason);
   &#125;
 &#125;</code></pre>
<p>在<code>reschedule()</code>，把<code>runReason</code>设为<code>SWITCH_TO_SOURCE_SERVICE</code>，继续调用到<code>EngineJob.reschedule()</code>，再次执行到<code>DecodeJob.run()</code>不过已经在一个新的线程池中继续执行。</p>
<p>在<code>onDataFetcherReady()</code>中，会判断当前线程是否相同，不同的话，设置<code>runReason</code>为<code>DECODE_DATA</code>，重新执行<code>EngineJob.reschedule()</code>还会走到<code>run()</code>中，继续执行到<code>decodeFromRetrievedData()</code>，线程相同则直接执行。</p>
<h4 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h4><blockquote>
<p>此时拿到的数据类型还是<code>InputStream</code>或者<code>ByteBuffer</code>，需要解析成常用的<code>File</code>或者<code>Bitmap</code>。</p>
</blockquote>
<p>此时<code>runReason</code>为<code>DECODE_DATA</code>，调用到<code>decodeFromRetrievedData()</code></p>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> Object currentData;  
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decodeFromRetrievedData</span><span class="hljs-params">()</span> </span>&#123;
    ...
    Resource&lt;R&gt; resource = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;
      resource = decodeFromData(currentFetcher, currentData, currentDataSource);
    &#125; <span class="hljs-keyword">catch</span> (GlideException e) &#123;
      e.setLoggingDetails(currentAttemptingKey, currentDataSource);
      throwables.add(e);
    &#125;
    <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;
      notifyEncodeAndRelease(resource, currentDataSource);
    &#125; <span class="hljs-keyword">else</span> &#123;
      runGenerators();
    &#125;
  &#125;

  <span class="hljs-keyword">private</span> &lt;Data&gt; <span class="hljs-function">Resource&lt;R&gt; <span class="hljs-title">decodeFromData</span><span class="hljs-params">(DataFetcher&lt;?&gt; fetcher, Data data,
      DataSource dataSource)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;
    <span class="hljs-keyword">try</span> &#123;
      ...
      Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);
      <span class="hljs-keyword">return</span> result;
    &#125; <span class="hljs-keyword">finally</span> &#123;
      fetcher.cleanup();
    &#125;
  &#125;

  <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
  <span class="hljs-keyword">private</span> &lt;Data&gt; <span class="hljs-function">Resource&lt;R&gt; <span class="hljs-title">decodeFromFetcher</span><span class="hljs-params">(Data data, DataSource dataSource)</span>
      <span class="hljs-keyword">throws</span> GlideException </span>&#123;
    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());
    <span class="hljs-keyword">return</span> runLoadPath(data, dataSource, path);
  &#125;

  <span class="hljs-keyword">private</span> &lt;Data, ResourceType&gt; <span class="hljs-function">Resource&lt;R&gt; <span class="hljs-title">runLoadPath</span><span class="hljs-params">(Data data, DataSource dataSource,
      LoadPath&lt;Data, ResourceType, R&gt; path)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;
    Options options = getOptionsWithHardwareConfig(dataSource);
    DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data);
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-keyword">return</span> path.load(
          rewinder, options, width, height, <span class="hljs-keyword">new</span> DecodeCallback&lt;ResourceType&gt;(dataSource));
    &#125; <span class="hljs-keyword">finally</span> &#123;
      rewinder.cleanup();
    &#125;
  &#125;</code></pre>
<p>调用<code>decodeFromRetrievedData</code>开始解析加载返回的数据，数据格式可能为<code>InputSteam</code>、<code>ByteBuffer</code>。向下调用到<code>decodeFromData()</code>，再到<code>decodeFromFetcher()</code>，最终通过<code>DecodeHelper.getLoadPath()</code>得到的<code>LoadPath</code>去对获取的数据进行解析。</p>
<pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> Resource&lt;Transcode&gt; <span class="hljs-title">load</span><span class="hljs-params">(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, <span class="hljs-keyword">int</span> width,
      <span class="hljs-keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;
    List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-keyword">return</span> loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);
    &#125; <span class="hljs-keyword">finally</span> &#123;
      listPool.release(throwables);
    &#125;
  &#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> Resource&lt;Transcode&gt; <span class="hljs-title">loadWithExceptionList</span><span class="hljs-params">(DataRewinder&lt;Data&gt; rewinder,
      @NonNull Options options,
      <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback,
      List&lt;Throwable&gt; exceptions)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;
    Resource&lt;Transcode&gt; result = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">//noinspection ForLoopReplaceableByForEach to improve perf</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = decodePaths.size(); i &lt; size; i++) &#123;
      DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);
      <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">//又传递到DecodePath上</span>
        result = path.decode(rewinder, width, height, options, decodeCallback);
      &#125; <span class="hljs-keyword">catch</span> (GlideException e) &#123;
        exceptions.add(e);
      &#125;
      <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">break</span>;
      &#125;
    &#125;

    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlideException(failureMessage, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(exceptions));
    &#125;

    <span class="hljs-keyword">return</span> result;
  &#125;</code></pre>
<pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> Resource&lt;Transcode&gt; <span class="hljs-title">decode</span><span class="hljs-params">(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height,
     @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;
   Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);
   Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);
   <span class="hljs-keyword">return</span> transcoder.transcode(transformed, options);
 &#125;

 <span class="hljs-meta">@NonNull</span>
 <span class="hljs-function"><span class="hljs-keyword">private</span> Resource&lt;ResourceType&gt; <span class="hljs-title">decodeResource</span><span class="hljs-params">(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width,
     <span class="hljs-keyword">int</span> height, @NonNull Options options)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;
   List&lt;Throwable&gt; exceptions = Preconditions.checkNotNull(listPool.acquire());
   <span class="hljs-keyword">try</span> &#123;
     <span class="hljs-keyword">return</span> decodeResourceWithList(rewinder, width, height, options, exceptions);
   &#125; <span class="hljs-keyword">finally</span> &#123;
     listPool.release(exceptions);
   &#125;
 &#125;

<span class="hljs-meta">@NonNull</span>
 <span class="hljs-function"><span class="hljs-keyword">private</span> Resource&lt;ResourceType&gt; <span class="hljs-title">decodeResourceWithList</span><span class="hljs-params">(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width,
     <span class="hljs-keyword">int</span> height, @NonNull Options options, List&lt;Throwable&gt; exceptions)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;
   Resource&lt;ResourceType&gt; result = <span class="hljs-keyword">null</span>;
   <span class="hljs-comment">//noinspection ForLoopReplaceableByForEach to improve perf</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = decoders.size(); i &lt; size; i++) &#123;
     ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);
     <span class="hljs-keyword">try</span> &#123;
       <span class="hljs-comment">//数据解析器</span>
       DataType data = rewinder.rewindAndGet();
       <span class="hljs-keyword">if</span> (decoder.handles(data, options)) &#123;
         data = rewinder.rewindAndGet();
         result = decoder.decode(data, width, height, options);
       &#125;
     &#125; <span class="hljs-keyword">catch</span> (IOException | RuntimeException | OutOfMemoryError e) &#123;

     &#125;

     <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
       <span class="hljs-keyword">break</span>;
     &#125;
   &#125;

   <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;
     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlideException(failureMessage, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(exceptions));
   &#125;
   <span class="hljs-keyword">return</span> result;
 &#125;</code></pre>
<p><code>LoadPath.load()</code>通过调用<code>loadWithExceptionList()</code>，循环获取<code>DecodePath</code>对象，然后调用其自身的<code>decode()</code>进行数据解析。<code>DecodePath</code>与<code>LoadPath</code>逻辑相似，最终在<code>DecodePath.decodeResourceWithList()</code>中循环获取<code>ResourceDecoder</code>对象，通过<code>DateRewinder.rewindAndGet()</code>获取要解析数据的格式(比如<code>ByteBuffer，InputStream</code>)，然后调用<code>decoder.decode</code>继续解析数据。</p>
<h5 id="获取数据格式"><a href="#获取数据格式" class="headerlink" title="获取数据格式"></a>获取数据格式</h5><p>由上述流程可知，我们能获得的数据类型为<code>InputStream</code>和<code>ByteBuffer</code>，对应的就会有两种<code>DataRewinder</code></p>
<pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RecyclableBufferedInputStream bufferedStream;
<span class="hljs-meta">@NonNull</span>
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">rewindAndGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    bufferedStream.reset();
    <span class="hljs-keyword">return</span> bufferedStream;
  &#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-meta">@NonNull</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title">rewindAndGet</span><span class="hljs-params">()</span> </span>&#123;
  buffer.position(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> buffer;
&#125;</code></pre>
<p>将传进来的data可以转换成对应的数据格式。</p>
<h5 id="根据格式转换相应类型"><a href="#根据格式转换相应类型" class="headerlink" title="根据格式转换相应类型"></a>根据格式转换相应类型</h5><p>得到对应数据格式后，就需要通过<code>ResourceDecoder.decode()</code>去解析数据。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResourceDecoder</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">Z</span>&gt; </span>&#123;
  <span class="hljs-comment">//判断这两个组合参数是否能进行解析</span>
  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">handles</span><span class="hljs-params">(@NonNull T source, @NonNull Options options)</span> <span class="hljs-keyword">throws</span> IOException</span>;

   */
  <span class="hljs-meta">@Nullable</span>
  <span class="hljs-function">Resource&lt;Z&gt; <span class="hljs-title">decode</span><span class="hljs-params">(@NonNull T source, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, @NonNull Options options)</span>
      <span class="hljs-keyword">throws</span> IOException</span>;
&#125;</code></pre>
<p><code>T</code>代表需要被解析的类型(例如InputStream、ByteBuffer)，<code>Z</code>代表解析的结果类型(例如Bitmap、Drawable)。</p>
<p><code>ResourceDecoder</code>在原码中有很多实现类，<code>StreamBitmapDecoder</code>、<code>ButeBufferBitmapDecoder</code>，此处拿出常用的<code>StreamBitmapDecoder</code>进行分析。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">handles</span><span class="hljs-params">(@NonNull InputStream source, @NonNull Options options)</span> </span>&#123;
  <span class="hljs-keyword">return</span> downsampler.handles(source);
&#125;

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Resource&lt;Bitmap&gt; <span class="hljs-title">decode</span><span class="hljs-params">(@NonNull InputStream source, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height,
    @NonNull Options options)</span>
    <span class="hljs-keyword">throws</span> IOException </span>&#123;

  <span class="hljs-comment">// Use to fix the mark limit to avoid allocating buffers that fit entire images.</span>
  <span class="hljs-keyword">final</span> RecyclableBufferedInputStream bufferedStream;
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> ownsBufferedStream;
  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> RecyclableBufferedInputStream) &#123;
    bufferedStream = (RecyclableBufferedInputStream) source;
    ownsBufferedStream = <span class="hljs-keyword">false</span>;
  &#125; <span class="hljs-keyword">else</span> &#123;
    bufferedStream = <span class="hljs-keyword">new</span> RecyclableBufferedInputStream(source, byteArrayPool);
    ownsBufferedStream = <span class="hljs-keyword">true</span>;
  &#125;
  ExceptionCatchingInputStream exceptionStream =
      ExceptionCatchingInputStream.obtain(bufferedStream);

  MarkEnforcingInputStream invalidatingStream = <span class="hljs-keyword">new</span> MarkEnforcingInputStream(exceptionStream);
  UntrustedCallbacks callbacks = <span class="hljs-keyword">new</span> UntrustedCallbacks(bufferedStream, exceptionStream);
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">return</span> downsampler.decode(invalidatingStream, width, height, options, callbacks);
  &#125; <span class="hljs-keyword">finally</span> &#123;
    exceptionStream.release();
    <span class="hljs-keyword">if</span> (ownsBufferedStream) &#123;
      bufferedStream.release();
    &#125;
  &#125;
&#125;</code></pre>
<p><code>ResourceDecode.decode()</code>内部是通过<code>Downsampler.decode()</code>进行解析</p>
<pre><code class="hljs java"> <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"resource"</span>, <span class="hljs-string">"deprecation"</span>&#125;)
 <span class="hljs-function"><span class="hljs-keyword">public</span> Resource&lt;Bitmap&gt; <span class="hljs-title">decode</span><span class="hljs-params">(InputStream is, <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight,
     Options options, DecodeCallbacks callbacks)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
   ...
   <span class="hljs-keyword">try</span> &#123;
     Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
         downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,
         requestedHeight, fixBitmapToRequestedDimensions, callbacks);
     <span class="hljs-keyword">return</span> BitmapResource.obtain(result, bitmapPool);
   &#125; <span class="hljs-keyword">finally</span> &#123;
     releaseOptions(bitmapFactoryOptions);
     byteArrayPool.put(bytesForOptions);
   &#125;
 &#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> Bitmap <span class="hljs-title">decodeFromWrappedStreams</span><span class="hljs-params">(InputStream is,
     BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
     DecodeFormat decodeFormat, <span class="hljs-keyword">boolean</span> isHardwareConfigAllowed, <span class="hljs-keyword">int</span> requestedWidth,
     <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">boolean</span> fixBitmapToRequestedDimensions,
     DecodeCallbacks callbacks)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
  
     Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);
     callbacks.onDecodeComplete(bitmapPool, downsampled);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">decodeStream</span><span class="hljs-params">(InputStream is, BitmapFactory.Options options,
     DecodeCallbacks callbacks, BitmapPool bitmapPool)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
   ...
   TransformationUtils.getBitmapDrawableLock().lock();
   <span class="hljs-keyword">try</span> &#123;
     result = BitmapFactory.decodeStream(is, <span class="hljs-keyword">null</span>, options);
   &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;
     ...
     <span class="hljs-keyword">throw</span> bitmapAssertionException;
   &#125; <span class="hljs-keyword">finally</span> &#123;
     TransformationUtils.getBitmapDrawableLock().unlock();
   &#125;
  ...
 &#125;</code></pre>
<p><code>Downsampler.decode()</code>内部主要实现依靠<code>decodeFromWrapperStreams()</code>，内部主要是配置<code>BitmapFactory.Options</code>。去控制图片的缩放(scale)、旋转(rotate)、复用(inBitmap)等方面配置。最后通过<code>decodeStream</code>解析输入流，最后生成Bitmap对象返回。</p>
<h5 id="获取图片后继续处理-例如圆角"><a href="#获取图片后继续处理-例如圆角" class="headerlink" title="获取图片后继续处理(例如圆角)"></a>获取图片后继续处理(例如圆角)</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Resource&lt;Transcode&gt; <span class="hljs-title">decode</span><span class="hljs-params">(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height,
    @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;
  <span class="hljs-comment">//上述步骤已完成</span>
  Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);
  <span class="hljs-comment">//加载完成的回调 调用Transform</span>
  Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);
  <span class="hljs-keyword">return</span> transcoder.transcode(transformed, options);
&#125;</code></pre>
<p><code>decodeResource</code>最终会调到<code>DecodeJob.onResourceDecoded()</code>进行<code>Transform</code>处理。</p>
<pre><code class="hljs java"> &lt;Z&gt; <span class="hljs-function">Resource&lt;Z&gt; <span class="hljs-title">onResourceDecoded</span><span class="hljs-params">(DataSource dataSource,
      @NonNull Resource&lt;Z&gt; decoded)</span> </span>&#123;
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
    Class&lt;Z&gt; resourceSubClass = (Class&lt;Z&gt;) decoded.get().getClass();
    Transformation&lt;Z&gt; appliedTransformation = <span class="hljs-keyword">null</span>;
    Resource&lt;Z&gt; transformed = decoded;
    <span class="hljs-keyword">if</span> (dataSource != DataSource.RESOURCE_DISK_CACHE) &#123;
      <span class="hljs-comment">//获取到的是 RequestOptions.getTransformations()这个集合</span>
      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
      transformed = appliedTransformation.transform(glideContext, decoded, width, height);
    &#125;
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make this the responsibility of the Transformation.</span>
    <span class="hljs-keyword">if</span> (!decoded.equals(transformed)) &#123;
      decoded.recycle();
    &#125;
<span class="hljs-keyword">if</span> (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
        encodeStrategy)) &#123;
      <span class="hljs-keyword">if</span> (encoder == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Registry.NoResultEncoderAvailableException(transformed.get().getClass());
      &#125;
      <span class="hljs-keyword">final</span> Key key;
      <span class="hljs-keyword">switch</span> (encodeStrategy) &#123;
        <span class="hljs-keyword">case</span> SOURCE:
          key = <span class="hljs-keyword">new</span> DataCacheKey(currentSourceKey, signature);
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> TRANSFORMED:
          key =
              <span class="hljs-keyword">new</span> ResourceCacheKey(
                  decodeHelper.getArrayPool(),
                  currentSourceKey,
                  signature,
                  width,
                  height,
                  appliedTransformation,
                  resourceSubClass,
                  options);
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unknown strategy: "</span> + encodeStrategy);
      &#125;
    ...
    &#125;
    <span class="hljs-keyword">return</span> result;
  &#125;</code></pre>
<blockquote>
<p>从这里可看出 保存原图和保存转换后图片的缓存key是不一致的。</p>
<p>缓存原图用的是<code>DataCacheKey</code>，保存转换后图片用的是<code>ResourceCacheKey</code></p>
</blockquote>
<p>上述数据处理完毕后，层层回溯到达了<code>decodeFromRetrievedData</code>()</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decodeFromRetrievedData</span><span class="hljs-params">()</span> </span>&#123;
    ...
    Resource&lt;R&gt; resource = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;
      resource = decodeFromData(currentFetcher, currentData, currentDataSource);
    &#125; <span class="hljs-keyword">catch</span> (GlideException e) &#123;
      e.setLoggingDetails(currentAttemptingKey, currentDataSource);
      throwables.add(e);
    &#125;
    <span class="hljs-comment">//这时Resource已经赋值完毕</span>
    <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;
      notifyEncodeAndRelease(resource, currentDataSource);
    &#125; <span class="hljs-keyword">else</span> &#123;
      runGenerators();
    &#125;
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyEncodeAndRelease</span><span class="hljs-params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (resource <span class="hljs-keyword">instanceof</span> Initializable) &#123;
      ((Initializable) resource).initialize();
    &#125;

    notifyComplete(result, dataSource);
    <span class="hljs-comment">//加载完毕后 回到初始状态</span>
    stage = Stage.ENCODE;
    ...
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyComplete</span><span class="hljs-params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;
    setNotifiedOrThrow();
    callback.onResourceReady(resource, dataSource);
  &#125;</code></pre>
<p>经过解析数据那一套流程下来后，数据已经加载完成，然后回到<code>DecodeJob.decodeFromRetrieveData()</code>，这时Resource对象不为空，向下继续调用<code>notifyEncodeAndRelease()</code>，内部调用到<code>notifyComplete()</code>再回调到<code>EngineJob.onResourceReady()</code>。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReady</span><span class="hljs-params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;
  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
    <span class="hljs-keyword">this</span>.resource = resource;
    <span class="hljs-keyword">this</span>.dataSource = dataSource;
  &#125;
  notifyCallbacksOfResult();
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyCallbacksOfResult</span><span class="hljs-params">()</span> </span>&#123;
  ResourceCallbacksAndExecutors copy;
  Key localKey;
  EngineResource&lt;?&gt; localResource;

  listener.onEngineJobComplete(<span class="hljs-keyword">this</span>, localKey, localResource);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;
    entry.executor.execute(<span class="hljs-keyword">new</span> CallResourceReady(entry.cb));
  &#125;
  decrementPendingCallbacks();
&#125;</code></pre>
<p><code>EngineJob.onResourceReady()</code>资源加载完成后，通过<code>notifyCallbacksOfResulr()</code>调用到<code>Engine.onEngineJobComplete()</code></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEngineJobComplete</span><span class="hljs-params">(
    EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;
  <span class="hljs-comment">// A null resource indicates that the load failed, usually due to an exception.</span>
  <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;
    resource.setResourceListener(key, <span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">if</span> (resource.isCacheable()) &#123;
      activeResources.activate(key, resource);
    &#125;
  &#125;

  jobs.removeIfCurrent(key, engineJob);
&#125;</code></pre>
<p>加载完成后，把对应资源插入到<code>ActiveResources</code>中作为活动资源。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide-硬盘缓存.png" srcset="/img/loading.gif" class="full-image" alt="Glide-硬盘缓存" title="Glide-硬盘缓存"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="Glide高级用法"><a href="#Glide高级用法" class="headerlink" title="Glide高级用法"></a>Glide高级用法</h2><p>处理带有后缀的图片类型，可能为了保证安全，不同的用户获取的图片除了图片地址外还会有一段标识用户的token。而且token并不一定是固定的，这样我们再去加载图片时，由于缓存key不一致，导致重复加载。</p>
<p>这里涉及到了<a href="#缓存key">缓存key</a>的生成，其中有一个重要参数为远程图片加载地址，对于上述情况，因为地址的变化，key不同则查找缓存时也无法命中，解决这个情况就需要排除掉变化的部分。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGlideUrl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GlideUrl</span></span>&#123;

    <span class="hljs-keyword">private</span> String mUrl;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyGlideUrl</span><span class="hljs-params">(String url)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(url);
        mUrl = url;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCacheKey</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> mUrl.replace(replaceTokenParam(),<span class="hljs-string">""</span>);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">replaceTokenParam</span><span class="hljs-params">()</span></span>&#123;
        String tokenParam=<span class="hljs-string">""</span>;
        <span class="hljs-keyword">int</span> tokenIndex = mUrl.contains(<span class="hljs-string">"?.token"</span>) ? mUrl.indexOf(<span class="hljs-string">"?token"</span>):mUrl.indexOf(<span class="hljs-string">"&amp;token"</span>);
        <span class="hljs-keyword">if</span>(tokenIndex!=-<span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">int</span> nextAndIndex = mUrl.indexOf(<span class="hljs-string">"&amp;"</span>,tokenIndex+<span class="hljs-number">1</span>);
            <span class="hljs-keyword">if</span> (nextAndIndex!=-<span class="hljs-number">1</span>)&#123;
                tokenParam = mUrl.substring(tokenIndex+<span class="hljs-number">1</span>,nextAndIndex+<span class="hljs-number">1</span>);
            &#125;<span class="hljs-keyword">else</span>&#123;
                tokenParam = mUrl.substring(tokenIndex);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> tokenParam;
    &#125;
&#125;


Glide.with(mContext).load(MyGlideUrl(imgUrl)).into(imageView);</code></pre>
<h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5c31fbdff265da610e803d4e#heading-14" target="_blank" rel="noopener">Glide主流源码分析</a></p>
<p><a href="https://juejin.im/post/5c2dffa8f265da611d66c8b6#heading-2" target="_blank" rel="noopener">Glide4.8源码拆解（二）核心加载流程</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/源码解析/">源码解析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/03/19/Android-Study-Plan-XI/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android-Study-Plan-XI</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/03/18/Android-Study-Plan-IX/">
                        <span class="hidden-mobile">Android Study Plan IX - ClassLoaderß</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
