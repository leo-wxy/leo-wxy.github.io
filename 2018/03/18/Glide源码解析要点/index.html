

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Glide源码解析要点 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Glide源码解析要点">
              
                Glide源码解析要点
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-03-18 19:36" pubdate>
        2018年3月18日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      176
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Glide源码解析要点</h1>
            
            <div class="markdown-body">
              <!-- TODO Glide如何加载大图 BitmapPool的使用-->
<blockquote>
<p>该源码解析是基于最新的Glide 4.8.0进行的</p>
</blockquote>
<h2 id="Glide基本流程分析"><a href="#Glide基本流程分析" class="headerlink" title="Glide基本流程分析"></a>Glide基本流程分析</h2><p>Glide的基本使用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Glide.with(context).load($img$).apply(RequestOptions().transform(MultiTransformation(CenterCrop(),CircleCrop())).placeholder(R.drawable.ic_default_avatar)).into(imageView);<br></code></pre></td></tr></table></figure>
<p>按照上述的基本使用代码，Glide的加载过程可以分为以下几步：</p>
<h3 id="Glide对象初始化"><a href="#Glide对象初始化" class="headerlink" title="Glide对象初始化"></a><code>Glide对象初始化</code></h3><p>初始化代码是从<code>Glide.get()</code>开始的，在其中主要做了一些事情</p>
<figure class="highlight java"><figcaption><span>Glide.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"> @NonNull<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Glide get(@NonNull Context context) &#123;<br>    //Glide对象时一个单例模式<br>    <span class="hljs-keyword">if</span> (glide == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span> (Glide.class) &#123;<br>        <span class="hljs-keyword">if</span> (glide == <span class="hljs-keyword">null</span>) &#123;<br>          checkAndInitializeGlide(context);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    return glide;<br>  &#125;<br><br>//检查Glide对象是否初始化完毕<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> checkAndInitializeGlide(@NonNull Context context) &#123;<br>    // In the thread running initGlide(), one or more classes may call Glide.get(context).<br>    // Without <span class="hljs-keyword">this</span> check, those calls could trigger infinite recursion.<br>    <span class="hljs-keyword">if</span> (isInitializing) &#123;<br>      throw new IllegalStateException("You cannot call Glide.get() in registerComponents(),"<br>          + " use the provided Glide instance instead");<br>    &#125;<br>    isInitializing = <span class="hljs-keyword">true</span>;<br>    //真正初始化Glide的代码<br>    initializeGlide(context);<br>    isInitializing = <span class="hljs-keyword">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>初始化Glide时再调用到<code>initializeGlide()</code>去进行真正的初始化工作</p>
<figure class="highlight java"><figcaption><span>Glide.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> initializeGlide(@NonNull Context context) &#123;<br>  initializeGlide(context, new GlideBuilder());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) &#123;<br>  Context applicationContext = context.getApplicationContext();<br>  GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();<br>  List&lt;com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule&gt; manifestModules = Collections.emptyList();<br>  //是否使用Manifest配置的GlideModule<br>  <span class="hljs-keyword">if</span> (annotationGeneratedModule == <span class="hljs-keyword">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) &#123;<br>    manifestModules = new ManifestParser(applicationContext).parse();<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-keyword">null</span><br>      &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;<br>    Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses =<br>        annotationGeneratedModule.getExcludedModuleClasses();<br>    Iterator&lt;com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule&gt; iterator = manifestModules.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>      com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule current = iterator.next();<br>      <span class="hljs-keyword">if</span> (!excludedModuleClasses.contains(current.getClass())) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;<br>        Log.d(TAG, "AppGlideModule excludes manifest GlideModule: " + current);<br>      &#125;<br>      iterator.remove();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;<br>    <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule glideModule : manifestModules) &#123;<br>      Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());<br>    &#125;<br>  &#125;<br><br>  RequestManagerRetriever.RequestManagerFactory factory =<br>      annotationGeneratedModule != <span class="hljs-keyword">null</span><br>          ? annotationGeneratedModule.getRequestManagerFactory() : <span class="hljs-keyword">null</span>;<br>  builder.setRequestManagerFactory(factory);<br>  <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule <span class="hljs-keyword">module</span> : manifestModules) &#123;<br>    //循环调用Module中的 applyOptions方法<br>    //applyOptions的作用是 配置Glide加载时的图片缓存路径以及缓存空间大小<br>    <span class="hljs-keyword">module</span>.applyOptions(applicationContext, builder);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-keyword">null</span>) &#123;<br>    //调用注解配置Module中的 applyOptions方法<br>    //applyOptions的作用是 配置Glide加载时的图片缓存路径以及缓存空间大小<br>    annotationGeneratedModule.applyOptions(applicationContext, builder);<br>  &#125;<br>  //创建Glide对象<br>  Glide glide = builder.build(applicationContext);<br>  //循环调用Module中的 registerComponents()<br>  //registerComponents的作用是 注册指定类型的数据源，以及加载图片使用ModelLoader<br>  <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule <span class="hljs-keyword">module</span> : manifestModules) &#123;<br>    <span class="hljs-keyword">module</span>.registerComponents(applicationContext, glide, glide.registry);<br>  &#125;<br>  //调用注解配置Module中的 registerComponents()<br>  //registerComponents的作用是 注册指定类型的数据源，以及加载图片使用ModelLoader<br>  <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-keyword">null</span>) &#123;<br>    annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);<br>  &#125;<br>  applicationContext.registerComponentCallbacks(glide);<br>  Glide.glide = glide;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>源码中发现<code>GlideModule</code>分为两种<code>manifestModules</code>和<code>annotationGeneratedModule</code>，其中<code>manifestModules</code>是为了兼容V3版本，以前的都是配置在<code>AndroidManifest.xml</code>中，而V4版本采用注解的方式，取消了清单文件中的配置。</p>
<figure class="highlight java"><figcaption><span>示例配置文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">@GlideModule<br><span class="hljs-keyword">public</span> class CustomGlideModule extends AppGlideModule &#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> applyOptions(Context context, GlideBuilder builder) &#123;<br><br>        MemorySizeCalculator calculator = new MemorySizeCalculator.Builder(context).build();<br>        <span class="hljs-keyword">int</span> defaultMemoryCacheSize = calculator.getMemoryCacheSize();<br>        <span class="hljs-keyword">int</span> defaultBitmapPoolSize = calculator.getBitmapPoolSize();<br><br>        <span class="hljs-keyword">int</span> customMemoryCacheSize = (<span class="hljs-keyword">int</span>) (1.2 * defaultMemoryCacheSize);<br>        <span class="hljs-keyword">int</span> customBitmapPoolSize = (<span class="hljs-keyword">int</span>) (1.2 * defaultBitmapPoolSize);<br><br>        builder.setMemoryCache(new LruResourceCache(customMemoryCacheSize));<br>        builder.setBitmapPool(new LruBitmapPool(customBitmapPoolSize));<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> registerComponents(Context context, Glide glide, Registry registry) &#123;<br>        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(ProgressManager.getOkHttpClient()));<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isManifestParsingEnabled() &#123;<br>        return <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置好<code>GlideModule</code>文件后，就需要去调用其中的<code>applyOptions()</code>设置Glide加载基本配置项，然后调用到了<code>GlideBuilder.build()</code>去构造Glide对象，最后调用其中的<code>regeisterComponents()</code>设置加载器。</p>
<p>接下来分析构造Glide对象的方法——<code>GlideBuilder.build()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java">@NonNull<br>Glide build(@NonNull Context context) &#123;<br>  //设置加载图片的线程池<br>  <span class="hljs-keyword">if</span> (sourceExecutor == <span class="hljs-keyword">null</span>) &#123;<br>    sourceExecutor = GlideExecutor.newSourceExecutor();<br>  &#125;<br>  //写入本地磁盘缓存的线程池<br>  <span class="hljs-keyword">if</span> (diskCacheExecutor == <span class="hljs-keyword">null</span>) &#123;<br>    diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();<br>  &#125;<br>  //执行动画的线程池<br>  <span class="hljs-keyword">if</span> (animationExecutor == <span class="hljs-keyword">null</span>) &#123;<br>    animationExecutor = GlideExecutor.newAnimationExecutor();<br>  &#125;<br>  //计算内存缓存大小<br>  <span class="hljs-keyword">if</span> (memorySizeCalculator == <span class="hljs-keyword">null</span>) &#123;<br>    memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (connectivityMonitorFactory == <span class="hljs-keyword">null</span>) &#123;<br>    connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();<br>  &#125;<br>  //bitmap缓存池<br>  <span class="hljs-keyword">if</span> (bitmapPool == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">int</span> size = memorySizeCalculator.getBitmapPoolSize();<br>    <span class="hljs-keyword">if</span> (size &gt; 0) &#123;<br>      bitmapPool = new LruBitmapPool(size);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      bitmapPool = new BitmapPoolAdapter();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (arrayPool == <span class="hljs-keyword">null</span>) &#123;<br>    arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());<br>  &#125;<br>  //内存缓存<br>  <span class="hljs-keyword">if</span> (memoryCache == <span class="hljs-keyword">null</span>) &#123;<br>    memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());<br>  &#125;<br>  //硬盘缓存<br>  <span class="hljs-keyword">if</span> (diskCacheFactory == <span class="hljs-keyword">null</span>) &#123;<br>    diskCacheFactory = new InternalCacheDiskCacheFactory(context);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (engine == <span class="hljs-keyword">null</span>) &#123;<br>    engine =<br>        new Engine(<br>            memoryCache,<br>            diskCacheFactory,<br>            diskCacheExecutor,<br>            sourceExecutor,<br>            GlideExecutor.newUnlimitedSourceExecutor(),<br>            GlideExecutor.newAnimationExecutor(),<br>            isActiveResourceRetentionAllowed);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (defaultRequestListeners == <span class="hljs-keyword">null</span>) &#123;<br>    defaultRequestListeners = Collections.emptyList();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);<br>  &#125;<br><br>  RequestManagerRetriever requestManagerRetriever =<br>      new RequestManagerRetriever(requestManagerFactory);<br><br>  return new Glide(<br>      context,<br>      engine,<br>      memoryCache,<br>      bitmapPool,<br>      arrayPool,<br>      requestManagerRetriever,<br>      connectivityMonitorFactory,<br>      logLevel,<br>      defaultRequestOptions.lock(),<br>      defaultTransitionOptions,<br>      defaultRequestListeners,<br>      isLoggingRequestOriginsEnabled);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当<code>GlideBuilder.build()</code>执行完毕后，最终调用到<code>new Glide()</code>完成初始化。其中关键参数为<code>Registry</code>后续的操作都需要用到该参数。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with()"></a><code>with()</code></h3><blockquote>
<p>对Glide的生命周期进行管理。</p>
</blockquote>
<p>Glide对象初始化完毕后，首先会调用到的就是<code>with()</code></p>
<figure class="highlight java"><figcaption><span>Glide.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">@NonNull<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager with(@NonNull Context context) &#123;<br>    return getRetriever(context).get(context);<br>  &#125;<br><br>  @NonNull<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager with(@NonNull Activity activity) &#123;<br>    return getRetriever(activity).get(activity);<br>  &#125;<br><br>  @NonNull<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager with(@NonNull FragmentActivity activity) &#123;<br>    return getRetriever(activity).get(activity);<br>  &#125;<br><br>  @NonNull<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager with(@NonNull Fragment fragment) &#123;<br>    return getRetriever(fragment.getActivity()).get(fragment);<br>  &#125;<br><br>  @NonNull<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager with(@NonNull View view) &#123;<br>    return getRetriever(view.getContext()).get(view);<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>with()</code>有5种重载方法，最后调用到的都是<code>getRetriever(context).get()</code></p>
<figure class="highlight java"><figcaption><span>RequestManagerRetriever.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java">@NonNull<br><span class="hljs-keyword">public</span> RequestManager get(@NonNull Context context) &#123;<br>  <span class="hljs-keyword">if</span> (context == <span class="hljs-keyword">null</span>) &#123;<br>    throw new IllegalArgumentException("You cannot start a load on a <span class="hljs-keyword">null</span> Context");<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="hljs-keyword">instanceof</span> Application)) &#123;<br>    <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> FragmentActivity) &#123;<br>      return get((FragmentActivity) context);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> Activity) &#123;<br>      return get((Activity) context);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> ContextWrapper) &#123;<br>      return get(((ContextWrapper) context).getBaseContext());<br>    &#125;<br>  &#125;<br><br>  return getApplicationManager(context);<br>&#125;<br><br>@NonNull<br><span class="hljs-keyword">public</span> RequestManager get(@NonNull FragmentActivity activity) &#123;<br>  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;<br>    return get(activity.getApplicationContext());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    assertNotDestroyed(activity);<br>    FragmentManager fm = activity.getSupportFragmentManager();<br>    return supportFragmentGet(<br>        activity, fm, /*parentHint=*/ <span class="hljs-keyword">null</span>, isActivityVisible(activity));<br>  &#125;<br>&#125;<br><br>@NonNull<br><span class="hljs-keyword">public</span> RequestManager get(@NonNull Fragment fragment) &#123;<br>  Preconditions.checkNotNull(fragment.getActivity(),<br>        "You cannot start a load on a fragment before it is attached or after it is destroyed");<br>  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;<br>    return get(fragment.getActivity().getApplicationContext());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    FragmentManager fm = fragment.getChildFragmentManager();<br>    return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());<br>  &#125;<br>&#125;<br><br>@SuppressWarnings("deprecation")<br>@NonNull<br><span class="hljs-keyword">public</span> RequestManager get(@NonNull Activity activity) &#123;<br>  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;<br>    return get(activity.getApplicationContext());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    assertNotDestroyed(activity);<br>    android.app.FragmentManager fm = activity.getFragmentManager();<br>    return fragmentGet(<br>        activity, fm, /*parentHint=*/ <span class="hljs-keyword">null</span>, isActivityVisible(activity));<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> RequestManager get(@NonNull View view) &#123;<br>  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;<br>    return get(view.getContext().getApplicationContext());<br>  &#125;<br><br>  Preconditions.checkNotNull(view);<br>  Preconditions.checkNotNull(view.getContext(),<br>      "Unable to obtain a request manager <span class="hljs-keyword">for</span> a view without a Context");<br>  Activity activity = findActivity(view.getContext());<br>  // The view might be somewhere <span class="hljs-keyword">else</span>, like a service.<br>  <span class="hljs-keyword">if</span> (activity == <span class="hljs-keyword">null</span>) &#123;<br>    return get(view.getContext().getApplicationContext());<br>  &#125;<br><br>  // Support Fragments.<br>  <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> FragmentActivity) &#123;<br>    Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);<br>    return fragment != <span class="hljs-keyword">null</span> ? get(fragment) : get(activity);<br>  &#125;<br><br>  // Standard Fragments.<br>  android.app.Fragment fragment = findFragment(view, activity);<br>  <span class="hljs-keyword">if</span> (fragment == <span class="hljs-keyword">null</span>) &#123;<br>    return get(activity);<br>  &#125;<br>  return get(fragment);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>简单分析上述源码可知，调用流程如下：</p>
<ul>
<li>首先判断当前调用是否在子线程，在子线程的话，直接调用<code>ApplicationContext</code>获取<code>ReqeustManager</code></li>
<li>不在子线程即运行在主线程时，需要判断<code>context</code>类型<ul>
<li><code>support.Fragment或者support.FragmentActivity</code>：调用<code>supportFragmentGet()</code></li>
<li><code>app.Activity或者app.fragment</code>：调用<code>fragmentGet()</code></li>
<li><code>Application</code>：调用<code>getApplicationManager()</code></li>
<li><code>view.getContext</code>：需要判断view的context类型，然后再走一次上面的步骤</li>
</ul>
</li>
</ul>
<p>根据流程分析，监听生命周期的方式主要是通过<code>监听一个无UI的Fragment(位于主线程且有对应的context存在)</code>和<code>监听Application(当位于后台线程或者contxt为Application)</code>。</p>
<p>其中<code>无UI的Fragment</code>对应源码中的两个类<code>RequestManagerFragment</code>、<code>SupportRequestFragment</code>在其中构造了<code>ActivityFragmentLifecycle</code>对象，在其中的关键生命周期进行联动，就可以对应的去进行加载和取消加载操作了。</p>
<figure class="highlight java"><figcaption><span>RequestManagerFragment.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">@Override<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onStart() &#123;<br>   <span class="hljs-keyword">super</span>.onStart();<br>   lifecycle.onStart();<br> &#125;<br><br> @Override<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onStop() &#123;<br>   <span class="hljs-keyword">super</span>.onStop();<br>   lifecycle.onStop();<br> &#125;<br><br> @Override<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onDestroy() &#123;<br>   <span class="hljs-keyword">super</span>.onDestroy();<br>   lifecycle.onDestroy();<br>   unregisterFragmentWithRoot();<br> &#125;<br></code></pre></td></tr></table></figure>
<p>然后最后返回的<code>RequestManager</code>对象自身也会实现<code>LifecycleListener</code>接口，就可以根据对应调用跳转加载过程</p>
<figure class="highlight java"><figcaption><span>RequestManager.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">//实现了LifecycleListener接口<br><span class="hljs-keyword">public</span> class RequestManager implements LifecycleListener&#123;<br> <br>  //主线程中执行<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable addSelfToLifecycle = new Runnable() &#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>      lifecycle.addListener(RequestManager.<span class="hljs-keyword">this</span>);<br>    &#125;<br>  &#125;;<br>...<br>  @Override<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onStart() &#123;<br>    resumeRequests();<br>    targetTracker.onStart();//targetTracker监听<br>  &#125;<br>  <br>  @Override<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onStop() &#123;<br>    pauseRequests();<br>    targetTracker.onStop();//targetTracker监听<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> resumeRequests() &#123;<br>    Util.assertMainThread();<br>    requestTracker.resumeRequests();//requestTracker监听<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> pauseRequests() &#123;<br>    Util.assertMainThread();<br>    requestTracker.pauseRequests();//requestTracker监听<br>  &#125;<br>  <br>  @Override<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onDestroy() &#123;<br>    targetTracker.onDestroy();//targetTracker监听<br>    <span class="hljs-keyword">for</span> (Target&lt;?&gt; target : targetTracker.getAll()) &#123;<br>      clear(target);<br>    &#125;<br>    targetTracker.clear();//targetTracker监听<br>    requestTracker.clearRequests();//requestTracker监听<br>    lifecycle.removeListener(<span class="hljs-keyword">this</span>);<br>    lifecycle.removeListener(connectivityMonitor);<br>    mainHandler.removeCallbacks(addSelfToLifecycle);<br>    glide.unregisterRequestManager(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>完成上述流程后，RequestManager就可以实现对Fragment的监听，也就等同于实现了Glide的生命周期。</p>
{% fullimage /images/Glide的with.png,Glide的with过程,Glide的with过程%}
<h3 id="load"><a href="#load" class="headerlink" title="load()"></a><code>load()</code></h3><blockquote>
<p>传入需要加载的图片信息，通过<code>with()</code>得到的<code>RequestManager</code>进行加载。</p>
</blockquote>
<figure class="highlight java"><figcaption><span>RequestManager.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java">@NonNull<br> @CheckResult<br> @Override<br> <span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; load(@Nullable Bitmap bitmap) &#123;<br>   return asDrawable().load(bitmap);<br> &#125;<br><br> @NonNull<br> @CheckResult<br> @Override<br> <span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; load(@Nullable Drawable drawable) &#123;<br>   return asDrawable().load(drawable);<br> &#125;<br><br> @NonNull<br> @CheckResult<br> @Override<br> <span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; load(@Nullable String string) &#123;<br>   return asDrawable().load(string);<br> &#125;<br><br> @NonNull<br> @CheckResult<br> @Override<br> <span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; load(@Nullable Uri uri) &#123;<br>   return asDrawable().load(uri);<br> &#125;<br><br> @NonNull<br> @CheckResult<br> @Override<br> <span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; load(@Nullable File file) &#123;<br>   return asDrawable().load(file);<br> &#125;<br><br> @SuppressWarnings("deprecation")<br> @NonNull<br> @CheckResult<br> @Override<br> <span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; load(@RawRes @DrawableRes @Nullable Integer resourceId) &#123;<br>   return asDrawable().load(resourceId);<br> &#125;<br><br> @SuppressWarnings("deprecation")<br> @CheckResult<br> @Override<br> @Deprecated<br> <span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; load(@Nullable URL url) &#123;<br>   return asDrawable().load(url);<br> &#125;<br><br> @NonNull<br> @CheckResult<br> @Override<br> <span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; load(@Nullable <span class="hljs-keyword">byte</span>[] model) &#123;<br>   return asDrawable().load(model);<br> &#125;<br><br> @NonNull<br> @CheckResult<br> @Override<br> <span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; load(@Nullable Object model) &#123;<br>   return asDrawable().load(model);<br> &#125;<br></code></pre></td></tr></table></figure>
<p>经过<code>load()</code>分析，Glide加载的类型支持<code>Bitmap</code>、<code>Drawable</code>、<code>String(图片地址)</code>、<code>Uri</code>、<code>File(图片文件)</code>、<code>Integer(图片ResourceId)</code>、<code>URL</code>、<code>byte</code>，<code>Object</code>。</p>
<p>实际内部调用到的是<code>asDrawable.load()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; asDrawable() &#123;<br>  return as(Drawable.class);<br>&#125;<br><br>@NonNull<br>@CheckResult<br><span class="hljs-keyword">public</span> RequestBuilder&lt;Bitmap&gt; asBitmap() &#123;<br>  return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);<br>&#125;<br><br>@NonNull<br>@CheckResult<br><span class="hljs-keyword">public</span> RequestBuilder&lt;GifDrawable&gt; asGif() &#123;<br>  return as(GifDrawable.class).apply(DECODE_TYPE_GIF);<br>&#125;<br><br>@NonNull<br>@CheckResult<br><span class="hljs-keyword">public</span> &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; as(<br>    @NonNull Class&lt;ResourceType&gt; resourceClass) &#123;<br>  return new RequestBuilder&lt;&gt;(glide, <span class="hljs-keyword">this</span>, resourceClass, context);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>asDrawable()</code>得到<code>RequestBuilder</code>对象，接下来走到<code>ReqeustBuilder.load()</code></p>
<figure class="highlight java"><figcaption><span>RequestBuilder.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; load(@Nullable Bitmap bitmap) &#123;<br>    return loadGeneric(bitmap)<br>        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; load(@Nullable Drawable drawable) &#123;<br>    return loadGeneric(drawable)<br>        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; load(@Nullable String string) &#123;<br>    return loadGeneric(string);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; load(@Nullable Uri uri) &#123;<br>    return loadGeneric(uri);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; load(@Nullable File file) &#123;<br>    return loadGeneric(file);<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) &#123;<br>    <span class="hljs-keyword">this</span>.model = model;<br>    isModelSet = <span class="hljs-keyword">true</span>;<br>    return <span class="hljs-keyword">this</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; load(@Nullable Object model) &#123;<br>    return loadGeneric(model);<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>上述的<code>load()</code>都调用到了<code>loadGeneric()</code>然后进行了赋值操作，确定了<code>model</code>数据，然后完成了load流程。</p>
<p>//TODO 流程图</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a><code>apply()</code></h3><blockquote>
<p>设置一些额外配置，例如占位图、加载错误图片、图片显示类型，圆角什么的</p>
</blockquote>
<p><code>load()</code>流程结束后就得到了<code>RequestBuilder</code>对象，调用其中的<code>apply()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> class RequestBuilder&lt;TranscodeType&gt; extends BaseRequestOptions&lt;RequestBuilder&lt;TranscodeType&gt;&gt; implements Cloneable, ModelTypes&lt;RequestBuilder&lt;TranscodeType&gt;&gt; &#123;<br>      ...<br>  @NonNull<br>  @CheckResult<br>  @Override<br>  <span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; apply(@NonNull BaseRequestOptions&lt;?&gt; requestOptions) &#123;<br>    Preconditions.checkNotNull(requestOptions);<br>    return <span class="hljs-keyword">super</span>.apply(requestOptions);<br>  &#125;<br>      <br>      ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用到了<code>super.apply()</code>其实就是<code>BaseRequestOptions.apply()</code></p>
<figure class="highlight java"><figcaption><span>BaseRequestOptions.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">@NonNull<br> @CheckResult<br> <span class="hljs-keyword">public</span> T apply(@NonNull BaseRequestOptions&lt;?&gt; o) &#123;<br>   <span class="hljs-keyword">if</span> (isAutoCloneEnabled) &#123;<br>     return clone().apply(o);<br>   &#125;<br>   BaseRequestOptions&lt;?&gt; other = o;<br><br>   <span class="hljs-keyword">if</span> (isSet(other.fields, SIZE_MULTIPLIER)) &#123;<br>     sizeMultiplier = other.sizeMultiplier;<br>   &#125;<br>   ...<br>   fields |= other.fields;<br>   options.putAll(other.options);<br><br>   return selfOrThrowIfLocked();<br> &#125;<br></code></pre></td></tr></table></figure>
<p><code>isSet()</code>是判断该属性是否设置，若已设置过则替换，设置完毕后，得到一个<code>RequestBuilder</code>对象，不过已经设置了<code>RequestOptions</code>里面包含了一些显示上以及缓存上的配置。</p>
<h3 id="into-——最关键步骤"><a href="#into-——最关键步骤" class="headerlink" title="into()——最关键步骤"></a><code>into()</code>——最关键步骤</h3><blockquote>
<p>进行图片的加载与显示</p>
</blockquote>
<h4 id="创建请求Request"><a href="#创建请求Request" class="headerlink" title="创建请求Request"></a>创建请求<code>Request</code></h4><p>起点是从<code>RequestBuilder.into()</code>开始</p>
<figure class="highlight java"><figcaption><span>RequestBuilder.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java">@NonNull<br><span class="hljs-keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; into(@NonNull ImageView view) &#123;<br>  Util.assertMainThread();<br>  Preconditions.checkNotNull(view);<br>  //获取apply()设置的 RequestOptions<br>  BaseRequestOptions&lt;?&gt; requestOptions = <span class="hljs-keyword">this</span>;<br>  //是否设置了RequestOptions的ScaleType，未设置则使用ImageView的android:scaleType<br>  <span class="hljs-keyword">if</span> (!requestOptions.isTransformationSet()<br>      &amp;&amp; requestOptions.isTransformationAllowed()<br>      &amp;&amp; view.getScaleType() != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (view.getScaleType()) &#123;<br>      <span class="hljs-keyword">case</span> CENTER_CROP:<br>        requestOptions = requestOptions.clone().optionalCenterCrop();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> CENTER_INSIDE:<br>        requestOptions = requestOptions.clone().optionalCenterInside();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> FIT_CENTER:<br>      <span class="hljs-keyword">case</span> FIT_START:<br>      <span class="hljs-keyword">case</span> FIT_END:<br>        requestOptions = requestOptions.clone().optionalFitCenter();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> FIT_XY:<br>        requestOptions = requestOptions.clone().optionalCenterInside();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> CENTER:<br>      <span class="hljs-keyword">case</span> MATRIX:<br>      <span class="hljs-keyword">default</span>:<br>        // Do nothing.<br>    &#125;<br>  &#125;<br><br>  return into(<br>      glideContext.buildImageViewTarget(view, transcodeClass),<br>      /*targetListener=*/ <span class="hljs-keyword">null</span>,<br>      requestOptions,<br>      Executors.mainThreadExecutor());<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(<br>    @NonNull Y target,<br>    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,<br>    BaseRequestOptions&lt;?&gt; options,<br>    Executor callbackExecutor) &#123;<br>  Preconditions.checkNotNull(target);<br>  <span class="hljs-keyword">if</span> (!isModelSet) &#123;<br>    throw new IllegalArgumentException("You must call #load() before calling #into()");<br>  &#125;<br>  //构建Request请求对象<br>  Request request = buildRequest(target, targetListener, options, callbackExecutor);<br>  <br>  Request previous = target.getRequest();<br>  <span class="hljs-keyword">if</span> (request.isEquivalentTo(previous)<br>      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;<br>    request.recycle();<br>    <span class="hljs-keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;<br>      previous.begin();<br>    &#125;<br>    return target;<br>  &#125;<br><br>  requestManager.clear(target);<br>  //给当前View设置请求<br>  target.setRequest(request);<br>  requestManager.track(target, request);<br><br>  return target;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>buildRequest()</code>构建图片加载请求对象。</p>
<figure class="highlight java"><figcaption><span>RequestBuilder.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> Request buildRequest(<br>      Target&lt;TranscodeType&gt; target,<br>      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,<br>      BaseRequestOptions&lt;?&gt; requestOptions,<br>      Executor callbackExecutor) &#123;<br>    return buildRequestRecursive(<br>        target,<br>        targetListener,<br>        /*parentCoordinator=*/ <span class="hljs-keyword">null</span>,<br>        transitionOptions,<br>        requestOptions.getPriority(),<br>        requestOptions.getOverrideWidth(),<br>        requestOptions.getOverrideHeight(),<br>        requestOptions,<br>        callbackExecutor);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> Request buildRequestRecursive(...) &#123;<br>    <br>    ErrorRequestCoordinator errorRequestCoordinator = <span class="hljs-keyword">null</span>;<br>    //判断当前是否设置了 RequestBuilder.error()<br>    <span class="hljs-keyword">if</span> (errorBuilder != <span class="hljs-keyword">null</span>) &#123;<br>      errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);<br>      parentCoordinator = errorRequestCoordinator;<br>    &#125;<br>    //生成可能带有缩略图显示的Request<br>    Request mainRequest =<br>        buildThumbnailRequestRecursive(...);<br>    <br>    <span class="hljs-keyword">if</span> (errorRequestCoordinator == <span class="hljs-keyword">null</span>) &#123;<br>      return mainRequest;<br>    &#125;<br>    //生成带有错误处理的Request<br>    Request errorRequest =<br>        errorBuilder.buildRequestRecursive(...);<br>    errorRequestCoordinator.setRequests(mainRequest, errorRequest);<br>    return errorRequestCoordinator;<br>    ...<br>      <br>  &#125;<br><br><span class="hljs-keyword">private</span> Request buildThumbnailRequestRecursive(...) &#123;<br>    //是否设置了 RequestBuilder.thumbnailBuilder(RequestBuilder thumbnailBuilder)<br>    <span class="hljs-keyword">if</span> (thumbnailBuilder != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (isThumbnailBuilt) &#123;<br>        throw new IllegalStateException("You cannot use a request as both the main request and a "<br>            + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");<br>      &#125;<br><br>      TransitionOptions&lt;?, ? <span class="hljs-keyword">super</span> TranscodeType&gt; thumbTransitionOptions =<br>          thumbnailBuilder.transitionOptions;<br><br>      // Apply our transition by <span class="hljs-keyword">default</span> to thumbnail requests but avoid overriding custom options<br>      // that may have been applied on the thumbnail request explicitly.<br>      <span class="hljs-keyword">if</span> (thumbnailBuilder.isDefaultTransitionOptionsSet) &#123;<br>        thumbTransitionOptions = transitionOptions;<br>      &#125;<br><br>      Priority thumbPriority = thumbnailBuilder.isPrioritySet()<br>          ? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);<br><br>      <span class="hljs-keyword">int</span> thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();<br>      <span class="hljs-keyword">int</span> thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();<br>      <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)<br>          &amp;&amp; !thumbnailBuilder.isValidOverride()) &#123;<br>        thumbOverrideWidth = requestOptions.getOverrideWidth();<br>        thumbOverrideHeight = requestOptions.getOverrideHeight();<br>      &#125;<br><br>      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);<br>ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);<br>      Request fullRequest =<br>          obtainRequest(...);<br>      isThumbnailBuilt = <span class="hljs-keyword">true</span>;<br>      // Recursively generate thumbnail requests.<br>      Request thumbRequest =<br>          thumbnailBuilder.buildRequestRecursive(...);<br>      isThumbnailBuilt = <span class="hljs-keyword">false</span>;<br>      coordinator.setRequests(fullRequest, thumbRequest);<br>      return coordinator;<br>    &#125;<br>  //是否设置了 RequestBuilder.thumbnailBuilder(floar thumbSizeMultiplier)  对应的缩放比例<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thumbSizeMultiplier != <span class="hljs-keyword">null</span>) &#123;<br>      // Base <span class="hljs-keyword">case</span>: thumbnail multiplier generates a thumbnail request, but cannot recurse.<br>      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);<br>      Request fullRequest = obtainRequest(...);<br>      BaseRequestOptions&lt;?&gt; thumbnailOptions =<br>          requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);<br><br>      Request thumbnailRequest =<br>          obtainRequest(...);<br><br>      coordinator.setRequests(fullRequest, thumbnailRequest);<br>      return coordinator;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      // 没有设置 thunbmail相关参数<br>      return obtainRequest(...);<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span> Request obtainRequest(<br>      Target&lt;TranscodeType&gt; target,<br>      RequestListener&lt;TranscodeType&gt; targetListener,<br>      BaseRequestOptions&lt;?&gt; requestOptions,<br>      RequestCoordinator requestCoordinator,<br>      TransitionOptions&lt;?, ? <span class="hljs-keyword">super</span> TranscodeType&gt; transitionOptions,<br>      Priority priority,<br>      <span class="hljs-keyword">int</span> overrideWidth,<br>      <span class="hljs-keyword">int</span> overrideHeight,<br>      Executor callbackExecutor) &#123;<br>    return SingleRequest.obtain(...);<br>  &#125;<br></code></pre></td></tr></table></figure>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide创建请求.png" srcset="/img/loading.gif" class="full-image" alt="Glide创建请求" title="Glide创建请求"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>总结一下创建请求的流程，最后调用的是<code>SingleRequest</code>对象。</p>
<ul>
<li><p>通过<code>RequestBuilder.buildRequest()</code>创建<code>Request</code>对象，调用到<code>buildRequestRecursive()</code>执行创建逻辑</p>
</li>
<li><p>先判断设置过<code>RequestBuilder.error()</code>参数，如果设置过<code>errorRequest</code>，需要通过<code>errorRequest</code>和<code>mainRequest</code>得到<code>ErrorRequestCoordinator(实现Request接口)</code>对象。</p>
</li>
<li><p>没设置过<code>RequestBuilder.error()</code>参数，则向下判断是否设置过<code>ReqeustBuilder.thumbnail()</code>参数，设置<code>ReqeustBuilder.thumbnail()</code>有两种方法：</p>
<ul>
<li><code>ReqeustBuilder.thumbnail(RequestBuilder thumbnailBuilder)</code>：自定义要显示的缩略图</li>
<li><code>ReqeustBuilder.thumbnail(float thumbSizeMultiper)</code>：设置原图缩放比例</li>
</ul>
<p>只要设置了其中的一种，就会产生<code>thumbRequest</code>对象，然后与<code>fullRequest</code>得到<code>ThumbnailRequestCoordinator(实现Request接口)</code>对象。</p>
</li>
<li><p><code>ReqeustBuilder.thumbnail()</code>也未设置，则最终调用<code>SingleRequest.obtain()</code>得到<code>SingleRequest(实现Request接口)</code>对象。</p>
</li>
</ul>
<blockquote>
<p> <code>errorRequest</code>表示了加载错误的请求</p>
<p> <code>thumbRequest</code>表示了缩略图加载请求</p>
<p> <code>mainRequest</code>和<code>fullRequest</code>都代表了原始图片加载请求。</p>
</blockquote>
<p>上述创建请求流程执行完毕后，就是发送请求。</p>
<h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><blockquote>
<p>发送请求通过调用<code>Request</code>实现。</p>
</blockquote>
<p>在<a href="#创建请求">创建请求</a>中，创建完成后会调用到<code>requestManager.track(target, request);</code>去发送请求</p>
<figure class="highlight java"><figcaption><span>RequestManager.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> track(@NonNull Target&lt;?&gt; target, @NonNull Request request) &#123;<br>  //监听target的生命周期<br>  targetTracker.track(target);<br>  //开启请求<br>  requestTracker.runRequest(request);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>RequestTracker.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> runRequest(@NonNull Request request) &#123;<br>  requests.add(request);<br>  <span class="hljs-keyword">if</span> (!isPaused) &#123;<br>    //开始启动<br>    request.begin();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    request.clear();<br>    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;<br>      Log.v(TAG, "Paused, delaying request");<br>    &#125;<br>    pendingRequests.add(request);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来就是调用到<code>Request.begin()</code>，<code>Request</code>是一个接口，<code>singleRequest</code>是具体的实现类，即调用到<code>SingleRequest.begin()</code></p>
<figure class="highlight java"><figcaption><span>SingleRequest.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java">  @Override<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> begin() &#123;<br>    assertNotCallingCallbacks();<br>    stateVerifier.throwIfRecycled();<br>    startTime = LogTime.getLogTime();<br>    <span class="hljs-keyword">if</span> (model == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;<br>        width = overrideWidth;<br>        height = overrideHeight;<br>      &#125;<br>      <span class="hljs-keyword">int</span> logLevel = getFallbackDrawable() == <span class="hljs-keyword">null</span> ? Log.WARN : Log.DEBUG;<br>      //返回加载失败<br>      onLoadFailed(new GlideException("Received <span class="hljs-keyword">null</span> model"), logLevel);<br>      return;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (status == Status.RUNNING) &#123;<br>      throw new IllegalArgumentException("Cannot restart a running request");<br>    &#125;<br>    //加载完成<br>    <span class="hljs-keyword">if</span> (status == Status.COMPLETE) &#123;<br>      onResourceReady(resource, DataSource.MEMORY_CACHE);<br>      return;<br>    &#125;<br>    <br>    status = Status.WAITING_FOR_SIZE;<br>    //判断设置大小是否合理<br>    <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;<br>      onSizeReady(overrideWidth, overrideHeight);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      //不合理 获取ImageView的size<br>      target.getSize(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)<br>        &amp;&amp; canNotifyStatusChanged()) &#123;<br>      //回调Target onLoadStarted()<br>      target.onLoadStarted(getPlaceholderDrawable());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;<br>      logV("finished run method in " + LogTime.getElapsedMillis(startTime));<br>    &#125;<br>  &#125;<br><br>@Override<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> onSizeReady(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height) &#123;<br>    stateVerifier.throwIfRecycled();<br>    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;<br>      logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;<br>      return;<br>    &#125;<br>    //更新请求状态为 请求中<br>    status = Status.RUNNING;<br><br>    <span class="hljs-keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();<br>    <span class="hljs-keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);<br>    <span class="hljs-keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);<br><br>    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;<br>      logV("finished setup <span class="hljs-keyword">for</span> calling load in " + LogTime.getElapsedMillis(startTime));<br>    &#125;<br>    //开始加载图片<br>    loadStatus = engine.load(...);<br>    <span class="hljs-keyword">if</span> (status != Status.RUNNING) &#123;<br>      loadStatus = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;<br>      logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>上述流程主要是去计算得到 被加载图片的尺寸信息，如果手动设置了尺寸通过<code>override</code>那么通过合法性校验后，加载的图片大小就会为用户设置尺寸，否则使用<code>Target</code>的尺寸信息。</p>
<blockquote>
<p><code>Target</code>是一个接口，主要意义是提供View的确切尺寸信息以及对回调结果进行处理。</p>
</blockquote>
{% fullimage /images/Glide发送请求.png,Glide发送请求,Glide发送请求%}
<h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h4><p>接下来调用<code>Engine.load()</code>开始加载图片，包括三级缓存的部分。</p>
<figure class="highlight java"><figcaption><span>Engine.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; LoadStatus load(...) &#123;<br>    <span class="hljs-keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;<br><br>    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,<br>        resourceClass, transcodeClass, options);<br>    //读取内存中的弱引用<br>    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);<br>    <span class="hljs-keyword">if</span> (active != <span class="hljs-keyword">null</span>) &#123;<br>      cb.onResourceReady(active, DataSource.MEMORY_CACHE);<br>      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;<br>        logWithTimeAndKey("Loaded resource from active resources", startTime, key);<br>      &#125;<br>      return <span class="hljs-keyword">null</span>;<br>    &#125;<br>    //读取内存缓存<br>    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);<br>    <span class="hljs-keyword">if</span> (cached != <span class="hljs-keyword">null</span>) &#123;<br>      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);<br>      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;<br>        logWithTimeAndKey("Loaded resource from cache", startTime, key);<br>      &#125;<br>      return <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <br>    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);<br>    <span class="hljs-keyword">if</span> (current != <span class="hljs-keyword">null</span>) &#123;<br>      current.addCallback(cb, callbackExecutor);<br>      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;<br>        logWithTimeAndKey("Added to existing load", startTime, key);<br>      &#125;<br>      return new LoadStatus(cb, current);<br>    &#125;<br><br>    EngineJob&lt;R&gt; engineJob =<br>        engineJobFactory.build(<br>            key,<br>            isMemoryCacheable,<br>            useUnlimitedSourceExecutorPool,<br>            useAnimationPool,<br>            onlyRetrieveFromCache);<br><br>    DecodeJob&lt;R&gt; decodeJob =<br>        decodeJobFactory.build(...);<br><br>    jobs.put(key, engineJob);<br><br>    engineJob.addCallback(cb, callbackExecutor);<br>    //若从两级内存缓存中 都没有找到 则开启DecodeJob去加载图片<br>    engineJob.start(decodeJob);<br><br>    <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;<br>      logWithTimeAndKey("Started new load", startTime, key);<br>    &#125;<br>    return new LoadStatus(cb, engineJob);<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>Engine.load()</code>，主要执行逻辑是：先从<code>一级内存缓存-弱引用</code>中查找指定资源，找不到则去<code>二级内存缓存-LRUCache</code>中去查找，再没有就转到<code>DecodeJob</code>去加载图片。</p>
<p>加载图片的具体实现细节会单独在<a href="#Glide缓存实现原理">Glide缓存实现原理</a>说明。</p>
<h4 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h4><p>当图片从三级缓存中取出后，最终得到的是一个<code>Resource</code>对象，然后再回调到<code>SingleRequest.onResourceReady()</code>中</p>
<figure class="highlight java"><figcaption><span>SingleRequest.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java">@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> onResourceReady(Resource&lt;?&gt; resource, DataSource dataSource) &#123;<br>  stateVerifier.throwIfRecycled();<br>  loadStatus = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">if</span> (resource == <span class="hljs-keyword">null</span>) &#123;<br>    //回调加载失败事件<br>    onLoadFailed(exception);<br>    return;<br>  &#125;<br><br>  Object received = resource.get();<br>  <span class="hljs-keyword">if</span> (received == <span class="hljs-keyword">null</span> || !transcodeClass.isAssignableFrom(received.getClass())) &#123;<br>    //回收资源<br>    releaseResource(resource);<br><br>    onLoadFailed(exception);<br>    return;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!canSetResource()) &#123;<br>    releaseResource(resource);<br>    // 设置加载状态完成<br>    status = Status.COMPLETE;<br>    return;<br>  &#125;<br><br>  onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> onResourceReady(Resource&lt;R&gt; resource, R result, DataSource dataSource) &#123;<br>  // We must call isFirstReadyResource before setting status.<br>  <span class="hljs-keyword">boolean</span> isFirstResource = isFirstReadyResource();<br>  status = Status.COMPLETE;<br>  <span class="hljs-keyword">this</span>.resource = resource;<br><br>  <span class="hljs-keyword">if</span> (glideContext.getLogLevel() &lt;= Log.DEBUG) &#123;<br>    Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "<br>        + dataSource + " <span class="hljs-keyword">for</span> " + model + " with size [" + width + "x" + height + "] in "<br>        + LogTime.getElapsedMillis(startTime) + " ms");<br>  &#125;<br><br>  isCallingCallbacks = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">boolean</span> anyListenerHandledUpdatingTarget = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (requestListeners != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">for</span> (RequestListener&lt;R&gt; listener : requestListeners) &#123;<br>        anyListenerHandledUpdatingTarget |=<br>            listener.onResourceReady(result, model, target, dataSource, isFirstResource);<br>      &#125;<br>    &#125;<br>    anyListenerHandledUpdatingTarget |=<br>        targetListener != <span class="hljs-keyword">null</span><br>            &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);<br><br>    <span class="hljs-keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;<br>      Transition&lt;? <span class="hljs-keyword">super</span> R&gt; animation =<br>          animationFactory.build(dataSource, isFirstResource);<br>      target.onResourceReady(result, animation);<br>    &#125;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    isCallingCallbacks = <span class="hljs-keyword">false</span>;<br>  &#125;<br>  <br>  notifyLoadSuccess();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>SingleRequest.onSourceReady()</code>主要回调了<code>Target.onResourceReady()</code>，把<code>Resource</code>显示到<code>Target</code>上，实质就是<code>into()</code>传入的Target对象。</p>
<figure class="highlight java"><figcaption><span>ImageViewTarget.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> @Override<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onResourceReady(@NonNull Z resource, @Nullable Transition&lt;? <span class="hljs-keyword">super</span> Z&gt; transition) &#123;<br>   <span class="hljs-keyword">if</span> (transition == <span class="hljs-keyword">null</span> || !transition.transition(resource, <span class="hljs-keyword">this</span>)) &#123;<br>     setResourceInternal(resource);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     maybeUpdateAnimatable(resource);<br>   &#125;<br> &#125;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> setResourceInternal(@Nullable Z resource) &#123;<br>   // Order matters here. Set the resource first to make sure that the Drawable has a valid and<br>   // non-<span class="hljs-keyword">null</span> Callback before starting it.<br>   setResource(resource);<br>   maybeUpdateAnimatable(resource);<br> &#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> setResource(@Nullable Z resource);<br></code></pre></td></tr></table></figure>
<p>其中有两个类继承了<code>ImageViewTarget</code>用于实现不同的功能。分别是<code>DrawableImageViewTarget</code>、<code>BitmapImageViewTarget</code>。</p>
<figure class="highlight java"><figcaption><span>DrawableImageViewTarget.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class DrawableImageViewTarget extends ImageViewTarget&lt;Drawable&gt; &#123;<br><br>  <span class="hljs-keyword">public</span> DrawableImageViewTarget(ImageView view) &#123;<br>    <span class="hljs-keyword">super</span>(view);<br>  &#125;<br><br>  /**<br>   * @deprecated Use &#123;@link #waitForLayout()&#125; instead.<br>   */<br>  // Public API.<br>  @SuppressWarnings(&#123;"unused", "deprecation"&#125;)<br>  @Deprecated<br>  <span class="hljs-keyword">public</span> DrawableImageViewTarget(ImageView view, <span class="hljs-keyword">boolean</span> waitForLayout) &#123;<br>    <span class="hljs-keyword">super</span>(view, waitForLayout);<br>  &#125;<br><br>  @Override<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> setResource(@Nullable Drawable resource) &#123;<br>    view.setImageDrawable(resource);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终通过<code>ImageView.setImageDrawable()</code>将图片显示在ImageView上。</p>
{% fullimage /images/Glide显示图片.png,Glide显示图片,Glide显示图片%}
<h2 id="Glide缓存实现原理"><a href="#Glide缓存实现原理" class="headerlink" title="Glide缓存实现原理"></a>Glide缓存实现原理</h2><blockquote>
<p>Glide的缓存主要分成了两个模块，一个是<strong>内存缓存</strong>，另一部分是<strong>硬盘缓存</strong>。</p>
<p><strong>内存缓存</strong>：防止应用重复将图片数据读取到内存当中</p>
<p><strong>硬盘缓存</strong>：防止应用重复从网络或其他地方重复下载和读取数据</p>
</blockquote>
<h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><p>1.在自定义的<code>GlideModule</code>中的<code>applyOptions()</code>中设置具体的缓存参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">@GlideModule<br><span class="hljs-keyword">public</span> class CustomGlideModule extends AppGlideModule &#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> applyOptions(Context context, GlideBuilder builder) &#123;<br>        MemorySizeCalculator calculator = new MemorySizeCalculator.Builder(context).build();<br>        <span class="hljs-keyword">int</span> defaultMemoryCacheSize = calculator.getMemoryCacheSize();<br>        <span class="hljs-keyword">int</span> defaultBitmapPoolSize = calculator.getBitmapPoolSize();<br>        <span class="hljs-keyword">int</span> customMemoryCacheSize = (<span class="hljs-keyword">int</span>) (1.2 * defaultMemoryCacheSize);<br>        <span class="hljs-keyword">int</span> customBitmapPoolSize = (<span class="hljs-keyword">int</span>) (1.2 * defaultBitmapPoolSize);<br>        builder.setMemoryCache(new LruResourceCache(customMemoryCacheSize));<br>        builder.setBitmapPool(new LruBitmapPool(customBitmapPoolSize));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2.在具体请求中设置缓存参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">//设置 不在磁盘中进行缓存且内存中也不缓存<br>val requestBuilder =Glide.with(<span class="hljs-keyword">this</span>).asBitmap().apply(RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(<span class="hljs-keyword">true</span>)).load(path)<br></code></pre></td></tr></table></figure>
<h3 id="缓存Key"><a href="#缓存Key" class="headerlink" title="缓存Key"></a>缓存Key</h3><p>缓存功能，就需要有对应的缓存Key，应用可以根据这个Key找到对应的缓存文件。Glide的缓存Key生成代码如下</p>
<figure class="highlight java"><figcaption><span>Engine.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; LoadStatus load(...）&#123;<br>      EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,resourceClass, transcodeClass, options);<br>...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>model</code>对应的就是<code>load()</code>过程中传入的参数，例如传入<code>String(图片加载地址)</code>，那么对应的就是加载地址。决定生成Key的参数有很多。</p>
<p>如果设置了<code>override</code>修改了加载尺寸，那也会有不同的key生成。</p>
<h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>默认情况下，内存缓存是自动开启的，加载图片完成后，就会默认在内存中缓存，然后下次再调用时就会从内存中直接读取显示，无需重新加载。</p>
<blockquote>
<p>可以通过设置<code>skipMemoryCache(true)</code>来关闭内存缓存功能。</p>
</blockquote>
<p>Glide中的内存缓存主要分为两部分处理：<strong>弱引用复用机制</strong>和<strong>LRUCache</strong>。</p>
<h4 id="弱引用复用-——-ActiveResources"><a href="#弱引用复用-——-ActiveResources" class="headerlink" title="弱引用复用 —— ActiveResources"></a>弱引用复用 —— ActiveResources</h4><blockquote>
<p>从正在活动的资源中取出缓存进行复用</p>
</blockquote>
<figure class="highlight java"><figcaption><span>Engine.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; LoadStatus load(...)&#123;<br>  ...<br>    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);<br>    <span class="hljs-keyword">if</span> (active != <span class="hljs-keyword">null</span>) &#123;<br>      cb.onResourceReady(active, DataSource.MEMORY_CACHE);<br>      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;<br>        logWithTimeAndKey("Loaded resource from active resources", startTime, key);<br>      &#125;<br>      return <span class="hljs-keyword">null</span>;<br>    &#125;<br>  ...<br>&#125;<br><br>  @Nullable<br> <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class="hljs-keyword">boolean</span> isMemoryCacheable) &#123;<br>    <span class="hljs-keyword">if</span> (!isMemoryCacheable) &#123;<br>      return <span class="hljs-keyword">null</span>;<br>    &#125;<br>    EngineResource&lt;?&gt; active = activeResources.get(key);<br>    <span class="hljs-keyword">if</span> (active != <span class="hljs-keyword">null</span>) &#123;<br>      active.acquire();<br>    &#125;<br>    return active;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>对应的Resource文件要从<code>ActiveResource</code>中获取</p>
<figure class="highlight java"><figcaption><span>ActiveResource.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = new HashMap&lt;&gt;();<br><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> deactivate(Key key) &#123;<br>    ResourceWeakReference removed = activeEngineResources.remove(key);<br>    <span class="hljs-keyword">if</span> (removed != <span class="hljs-keyword">null</span>) &#123;<br>      removed.reset();<br>    &#125;<br>  &#125;<br><br>@Nullable<br>  <span class="hljs-keyword">synchronized</span> EngineResource&lt;?&gt; get(Key key) &#123;<br>    //获取Key对应的弱引用对象<br>    ResourceWeakReference activeRef = activeEngineResources.get(key);<br>    <span class="hljs-keyword">if</span> (activeRef == <span class="hljs-keyword">null</span>) &#123;<br>      return <span class="hljs-keyword">null</span>;<br>    &#125;<br>    EngineResource&lt;?&gt; active = activeRef.get();<br>    <span class="hljs-keyword">if</span> (active == <span class="hljs-keyword">null</span>) &#123;<br>      cleanupActiveReference(activeRef);<br>    &#125;<br>    return active;<br>  &#125;<br><br>  //清除当前被GC的对象<br>  <span class="hljs-keyword">void</span> cleanupActiveReference(@NonNull ResourceWeakReference ref) &#123;<br>    <span class="hljs-keyword">synchronized</span> (listener) &#123;<br>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        activeEngineResources.remove(ref.key);<br>        <span class="hljs-keyword">if</span> (!ref.isCacheable || ref.resource == <span class="hljs-keyword">null</span>) &#123;<br>          return;<br>        &#125;<br>        //创建新的Resource对象 ref.resource是强引用类型<br>        EngineResource&lt;?&gt; newResource =<br>            new EngineResource&lt;&gt;(ref.resource, /*isCacheable=*/ <span class="hljs-keyword">true</span>, /*isRecyclable=*/ <span class="hljs-keyword">false</span>);<br>        newResource.setResourceListener(ref.key, listener);<br>        //将ref缓存进内存中<br>        listener.onResourceReleased(ref.key, newResource);<br>      &#125;<br>    &#125;<br>  &#125;<br><br> @VisibleForTesting<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> class ResourceWeakReference extends WeakReference&lt;EngineResource&lt;?&gt;&gt; &#123;<br>    @SuppressWarnings("WeakerAccess") @Synthetic <span class="hljs-keyword">final</span> Key key;<br>    @SuppressWarnings("WeakerAccess") @Synthetic <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isCacheable;<br>    @Nullable @SuppressWarnings("WeakerAccess") @Synthetic Resource&lt;?&gt; resource;<br>    @Synthetic<br>    @SuppressWarnings("WeakerAccess")<br>    ResourceWeakReference(<br>        @NonNull Key key,<br>        @NonNull EngineResource&lt;?&gt; referent,<br>        @NonNull ReferenceQueue&lt;? <span class="hljs-keyword">super</span> EngineResource&lt;?&gt;&gt; queue,<br>        <span class="hljs-keyword">boolean</span> isActiveResourceRetentionAllowed) &#123;<br>      <span class="hljs-keyword">super</span>(referent, queue);<br>      <span class="hljs-keyword">this</span>.key = Preconditions.checkNotNull(key);<br>      <span class="hljs-keyword">this</span>.resource =<br>          referent.isCacheable() &amp;&amp; isActiveResourceRetentionAllowed<br>              ? Preconditions.checkNotNull(referent.getResource()) : <span class="hljs-keyword">null</span>;<br>      isCacheable = referent.isCacheable();<br>    &#125;<br>    //清除强引用部分，方便回收<br>    <span class="hljs-keyword">void</span> reset() &#123;<br>      resource = <span class="hljs-keyword">null</span>;<br>      clear();<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>listener</code>对应的就是<code>Engine</code>对象，调用到<code>Engine.onResourceReleased()</code></p>
<figure class="highlight java"><figcaption><span>Engine.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> onResourceReleased(Key cacheKey, EngineResource&lt;?&gt; resource) &#123;   <br>  //清除该key的强引用<br>  activeResources.deactivate(cacheKey);<br>  <span class="hljs-keyword">if</span> (resource.isCacheable()) &#123;<br>    //缓存数据到内存缓存LRUCache中<br>    cache.put(cacheKey, resource);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    resourceRecycler.recycle(resource);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ActivieResources</code>采用<code>HashMap + WeakReference</code>来保存<code>EngineResource</code>，不会有上限。然后<code>get()</code>从<code>activeEngineResources</code>弱引用HashMap中获取数据，这里分为两种情况：</p>
<ol>
<li>获取到弱引用关联对象<code>EngineResource</code>，则直接返回结果</li>
<li>获取不到关联对象，则需进行清除工作调用<code>cleanupActiveResource()</code>，在<code>activeEngineResources</code>移除对应的key和引用，在判断是否开启缓存，若开启则缓存至<code>LRUCache</code>中。</li>
</ol>
<p>总结：</p>
<p><code>ActiveResources</code>采用弱引用的方式，里面存储的是<code>EngineResource</code>，同时采用强引用保存<code>EngineResource.resource</code>，在<code>ActiveResources</code>中还会有一个清理线程在运行，负责当<code>EngineResource</code>被回收时，就去取出对应的<code>EngineResource.resource</code>，然后创建一个新的<code>EngineResource</code>对象，回调到<code>Engine.onResourceReleased()</code>中，在其中做内存缓存，之后调用<code>ActivityResources.deactivate()</code>移除对应的强引用。</p>
{% fullimage /images/内存缓存-弱引用机制.png,内存缓存-弱引用机制,内存缓存-弱引用机制%}
<h4 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h4><blockquote>
<p>在当前活动资源中没有对应的缓存时，就要从内存中去进行读取</p>
</blockquote>
<figure class="highlight java"><figcaption><span>Engine.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; LoadStatus load(...)&#123;<br>  ...<br>    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);<br>    <span class="hljs-keyword">if</span> (cached != <span class="hljs-keyword">null</span>) &#123;<br>      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);<br>      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;<br>        logWithTimeAndKey("Loaded resource from cache", startTime, key);<br>      &#125;<br>      return <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br>  <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class="hljs-keyword">boolean</span> isMemoryCacheable) &#123;<br>    //不允许缓存 直接返回<span class="hljs-keyword">null</span><br>    <span class="hljs-keyword">if</span> (!isMemoryCacheable) &#123;<br>      return <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);①<br>    <span class="hljs-keyword">if</span> (cached != <span class="hljs-keyword">null</span>) &#123;<br>      cached.acquire();<br>      //存入活动资源中<br>      activeResources.activate(key, cached);②<br>    &#125;<br>    return cached;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;<br>    Resource&lt;?&gt; cached = cache.remove(key);③<br><br>    <span class="hljs-keyword">final</span> EngineResource&lt;?&gt; result;<br>    <span class="hljs-keyword">if</span> (cached == <span class="hljs-keyword">null</span>) &#123;<br>      result = <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cached <span class="hljs-keyword">instanceof</span> EngineResource) &#123;<br>      result = (EngineResource&lt;?&gt;) cached;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = new EngineResource&lt;&gt;(cached, <span class="hljs-keyword">true</span> /*isMemoryCacheable*/, <span class="hljs-keyword">true</span> /*isRecyclable*/);<br>    &#125;<br>    return result;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>loadFromCache()</code>实际调用到<code>getEngineResourceFromCache()</code>获取内存缓存中的资源，如果找到，缓存数量+1，然后会把<code>cached</code>放入<code>ActiveResources</code>中，变为活动资源，对应的要在<code>内存缓存</code>中移除引用。</p>
<p>①<code>getEngineResourceFromCache(key)</code>：从内存缓存中根据缓存key获取缓存</p>
<p>②<code>activeResources.activate(key, cached)</code>：取出的缓存数据存入到活动资源中</p>
<figure class="highlight java"><figcaption><span>ActiveResources.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> activate(Key key, EngineResource&lt;?&gt; resource) &#123;<br>  //构件新的 弱引用对象<br>  ResourceWeakReference toPut =<br>      new ResourceWeakReference(<br>          key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);<br>  <br>  ResourceWeakReference removed = activeEngineResources.put(key, toPut);<br>  //如果存在替换，也需要把旧数据回收<br>  <span class="hljs-keyword">if</span> (removed != <span class="hljs-keyword">null</span>) &#123;<br>    removed.reset();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>③<code>cache.remove(key)</code>：从内存缓存中移除对应缓存</p>
<p><code>cache</code>对应的是<code>MemoryCache</code>是一个接口，实现类为<code>LruResourceCache</code></p>
<figure class="highlight java"><figcaption><span>LruResourceCache.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class LruResourceCache extends LruCache&lt;Key, Resource&lt;?&gt;&gt; implements MemoryCache &#123;<br>  <span class="hljs-keyword">private</span> ResourceRemovedListener listener;<br><br>  <span class="hljs-keyword">public</span> LruResourceCache(<span class="hljs-keyword">long</span> size) &#123;<br>    <span class="hljs-keyword">super</span>(size);<br>  &#125;<br><br>  //监听资源移除<br>  @Override<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setResourceRemovedListener(@NonNull ResourceRemovedListener listener) &#123;<br>    <span class="hljs-keyword">this</span>.listener = listener;<br>  &#125;<br><br>  //当前缓存被淘汰是调用<br>  @Override<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> onItemEvicted(@NonNull Key key, @Nullable Resource&lt;?&gt; item) &#123;<br>    <span class="hljs-keyword">if</span> (listener != <span class="hljs-keyword">null</span> &amp;&amp; item != <span class="hljs-keyword">null</span>) &#123;<br>      listener.onResourceRemoved(item);<br>    &#125;<br>  &#125;<br>  //获取当前缓存大小<br>  @Override<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> getSize(@Nullable Resource&lt;?&gt; item) &#123;<br>    <span class="hljs-keyword">if</span> (item == <span class="hljs-keyword">null</span>) &#123;<br>      return <span class="hljs-keyword">super</span>.getSize(<span class="hljs-keyword">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      return item.getSize();<br>    &#125;<br>  &#125;<br><br>  @SuppressLint("InlinedApi")<br>  @Override<br>  //内存不足时 触发<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> trimMemory(<span class="hljs-keyword">int</span> level) &#123;<br>    <span class="hljs-keyword">if</span> (level &gt;= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) &#123;<br>      clearMemory();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level &gt;= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN<br>        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) &#123;<br>      trimToSize(getMaxSize() / 2);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>LruResourceCache</code>继承自<code>LruCache</code>，不过内部计算缓存大小是通过<code>Resource</code>对象的大小累计，还增加了资源移除监听，为了和<code>ActiveResources</code>进行联动。</p>
<p><code>LruResourceCache</code>的<code>size</code>是在自定义<code>GlideModule</code>中的 <code>applyOptions()</code>时设置进来的，如果未设置会采用<code>MemorySizeCalculator.getMemoryCacheSize()</code>设置。</p>
<p>当前在内存中缓存的对象都是<code>Resource</code>，而不是通常认为的Bitmap，下面会介绍到转码的过程。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/内存缓存-LruCache.png" srcset="/img/loading.gif" class="full-image" alt="内存缓存-LruCache" title="内存缓存-LruCache"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在<code>内存缓存</code>中，分为两种方案：<strong>从弱引用中获取</strong>、<strong>从内存缓存中获取</strong>。两者的关系简单概括就是：</p>
<blockquote>
<p>读取内存缓存时，会优先从<code>ActiveResources</code>中读取，读取到的话，需要判断当前包装<code>Resource</code>的弱引用对象是否被回收，未回收则直接返回。被回收的话，需要重新包装<code>EngineResource.resource</code>然后存入到内存缓存中并需要移除<code>ActiveResources</code>对其的引用。</p>
<p>从<code>ActiveResources</code>中没有获取到对应缓存时，就从<code>LruResourceCache</code>中去获取，获取到的话，就需要从当前内存缓存中移除对应缓存引用，并存入到<code>ActiveResources</code>中。</p>
<p><strong>实现了正在使用的图片通过弱引用进行缓存，未使用的图片通过LruCache进行缓存。</strong></p>
<p><code>ActiveResources</code>优先级高于<code>LruResourceCache</code>。</p>
</blockquote>
<p>比较两者之间的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>弱引用获取</th>
<th>内存缓存获取</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础实现</td>
<td>HashMap</td>
<td>LinkedHashMap(<em>LruCache</em>)</td>
</tr>
<tr>
<td>可否禁用</td>
<td>用户无法禁用</td>
<td>通过<code>skipMemoryCache(true)</code>禁用</td>
</tr>
<tr>
<td>运行位置</td>
<td>内存</td>
<td>内存</td>
</tr>
<tr>
<td>释放时机</td>
<td>依赖垃圾回收机制<br><strong>弱引用实现，GC时被回收</strong></td>
<td>采用<strong>最近最少使用</strong>来淘汰数据</td>
</tr>
</tbody>
</table>
<h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><blockquote>
<p>当内存中不存在缓存时，就会向下从硬盘中去读取缓存数据</p>
<p>通过设置<code>diskCacheStrategy(DiskCacheStrategy.NONE)</code>来关闭硬盘缓存功能。</p>
</blockquote>
<figure class="highlight java"><figcaption><span>Engine.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; LoadStatus load(...)&#123;<br>  ...<br>    //判断当前是否存在该任务 EngineJob<br>    // <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Key, EngineJob&lt;?&gt;&gt; jobs = new HashMap&lt;&gt;();<br>    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);<br>    <span class="hljs-keyword">if</span> (current != <span class="hljs-keyword">null</span>) &#123;<br>      //资源加载完毕通知回调<br>      current.addCallback(cb, callbackExecutor);<br>      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;<br>        logWithTimeAndKey("Added to existing load", startTime, key);<br>      &#125;<br>      return new LoadStatus(cb, current);<br>    &#125;<br>    //内部维护线程池，用来管理资源加载<br>    EngineJob&lt;R&gt; engineJob =<br>        engineJobFactory.build(...);<br>    //用来进行资源加载<br>    DecodeJob&lt;R&gt; decodeJob =<br>        decodeJobFactory.build(... , engineJob);<br>    //插入任务列表中<br>    jobs.put(key, engineJob);<br><br>    engineJob.addCallback(cb, callbackExecutor);<br>    //开始进行加载<br>    engineJob.start(decodeJob);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>从内存中读取不到缓存时，<code>Engine</code>尝试从<code>jobs</code>读取对应的<code>EngineJob</code>缓存，如存在就去回调<code>加载成功或加载失败</code>。不存在的话，就需要新建一个<code>EngineJob</code>以及<code>DecodeJob</code>去加载图片。</p>
<figure class="highlight java"><figcaption><span>EngineJob.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> start(DecodeJob&lt;R&gt; decodeJob) &#123;<br>  <span class="hljs-keyword">this</span>.decodeJob = decodeJob;<br>  GlideExecutor executor = decodeJob.willDecodeFromCache()<br>      ? diskCacheExecutor<br>      : getActiveSourceExecutor();<br>  executor.execute(decodeJob);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过线程池去执行<code>decodeJob</code>，<code>DecodeJob</code>实现了<code>Runnable</code>接口，<code>execute()</code>直接调用到<code>run()</code></p>
<figure class="highlight java"><figcaption><span>DecodeJob.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java">@SuppressWarnings("PMD.AvoidRethrowingException")<br> @Override<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>   //统计执行时长<br>   GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);<br>   DataFetcher&lt;?&gt; localFetcher = currentFetcher;<br>   <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-keyword">if</span> (isCancelled) &#123;<br>       notifyFailed();<br>       return;<br>     &#125;<br>     //实际执行逻辑<br>     runWrapped();<br>   &#125; <span class="hljs-keyword">catch</span> (CallbackException e) &#123;<br>     throw e;<br>   &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>     <span class="hljs-keyword">if</span> (stage != Stage.ENCODE) &#123;<br>       throwables.add(t);<br>       notifyFailed();<br>     &#125;<br>     <span class="hljs-keyword">if</span> (!isCancelled) &#123;<br>       throw t;<br>     &#125;<br>     throw t;<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>     // Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call<br>     // close in all cases anyway.<br>     <span class="hljs-keyword">if</span> (localFetcher != <span class="hljs-keyword">null</span>) &#123;<br>       localFetcher.cleanup();<br>     &#125;<br>     GlideTrace.endSection();<br>   &#125;<br> &#125;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> runWrapped() &#123;<br>   <span class="hljs-keyword">switch</span> (runReason) &#123;<br>     <span class="hljs-keyword">case</span> INITIALIZE:<br>       stage = getNextStage(Stage.INITIALIZE);<br>       currentGenerator = getNextGenerator();<br>       runGenerators();<br>       <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> SWITCH_TO_SOURCE_SERVICE:<br>       runGenerators();<br>       <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> DECODE_DATA:<br>       //解析数据并解码<br>       decodeFromRetrievedData();<br>       <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">default</span>:<br>       throw new IllegalStateException("Unrecognized run reason: " + runReason);<br>   &#125;<br> &#125;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> RunReason &#123;<br>   //第一次执行<br>   INITIALIZE,<br>   //从Cache中去读取数据失败，则从其他渠道读取<br>   SWITCH_TO_SOURCE_SERVICE,<br>   //解析数据<br>   DECODE_DATA,<br> &#125;<br></code></pre></td></tr></table></figure>
<p>调用<code>DecodeJob.run()</code>开始加载资源，内部调用<code>runWrapped()</code>，此时<code>runWrapped()</code>中会根据<code>runReason</code>执行不同的操作，<code>runReason</code>就是用于控制当前执行到的任务。</p>
<blockquote>
<p><code>INITIALIZE</code>：第一次调用<code>run()</code>，执行目的是从<code>diskcache</code>中获取缓存</p>
<p><code>SWITCH_TO_SOURCE_SERVICE</code>：从<code>diskcache</code>中获取缓存失败，需要从数据源获取</p>
<p><code>DECODE_DATA</code>：缓存数据成功，对数据进行解析</p>
</blockquote>
<h4 id="获取硬盘缓存数据"><a href="#获取硬盘缓存数据" class="headerlink" title="获取硬盘缓存数据"></a>获取硬盘缓存数据</h4><figure class="highlight java"><figcaption><span>DecodeJob.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java">//通过 RequestOptions.diskCacheStrategy() 设置<br><span class="hljs-keyword">private</span> DiskCacheStrategy diskCacheStrategy;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> runGenerators() &#123;<br>    currentThread = Thread.currentThread();<br>    startFetchTime = LogTime.getLogTime();<br>    <span class="hljs-keyword">boolean</span> isStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="hljs-keyword">null</span><br>        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;<br>      stage = getNextStage(stage);<br>      currentGenerator = getNextGenerator();<br><br>      <span class="hljs-keyword">if</span> (stage == Stage.SOURCE) &#123;<br>        reschedule();<br>        return;<br>      &#125;<br>    &#125;<br>    // We've run out of stages and generators, give up.<br>    <span class="hljs-keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;<br>      notifyFailed();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> Stage getNextStage(Stage current) &#123;<br>    <span class="hljs-keyword">switch</span> (current) &#123;<br>      <span class="hljs-keyword">case</span> INITIALIZE:<br>        //支持转换后的图片缓存 返回状态就是RESOURCE_CACHE<br>        return diskCacheStrategy.decodeCachedResource()<br>            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);<br>      <span class="hljs-keyword">case</span> RESOURCE_CACHE:<br>        //支持转换后的图片缓存 返回状态就是DATA_CACHE<br>        return diskCacheStrategy.decodeCachedData()<br>            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);<br>      <span class="hljs-keyword">case</span> DATA_CACHE:<br>        //如果缓存已存在 就返回结束 否则去加载远程图片<br>        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;<br>      <span class="hljs-keyword">case</span> SOURCE:<br>      <span class="hljs-keyword">case</span> FINISHED:<br>        return Stage.FINISHED;<br>      <span class="hljs-keyword">default</span>:<br>        throw new IllegalArgumentException("Unrecognized stage: " + current);<br>    &#125;<br>  &#125;<br><br>  //根据不同的步骤 调用不同的Generator对象<br>  <span class="hljs-keyword">private</span> DataFetcherGenerator getNextGenerator() &#123;<br>    <span class="hljs-keyword">switch</span> (stage) &#123;<br>      <span class="hljs-keyword">case</span> RESOURCE_CACHE:<br>        return new ResourceCacheGenerator(decodeHelper, <span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">case</span> DATA_CACHE:<br>        return new DataCacheGenerator(decodeHelper, <span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">case</span> SOURCE:<br>        return new SourceGenerator(decodeHelper, <span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">case</span> FINISHED:<br>        return <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">default</span>:<br>        throw new IllegalStateException("Unrecognized stage: " + stage);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> Stage &#123;<br>    //加载初始状态<br>    INITIALIZE,<br>    //转换后图片的缓存<br>    RESOURCE_CACHE,<br>    //原图缓存<br>    DATA_CACHE,<br>    //远程图片<br>    SOURCE,<br>    //解析图片<br>    ENCODE,<br>    //加载完成<br>    FINISHED,<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>stage</code>对应<code>Stage</code>枚举类，可以通过<code>DiskCacheStrategy</code>得到<code>Stage</code>。</p>
<blockquote>
<p><code>DiskCacheStrategy</code>参数解释：</p>
<ul>
<li><code>NONE</code>：表示不缓存任何内容</li>
<li><code>DATA</code>：只缓存原始图片</li>
<li><code>RESOURCE</code>：只缓存转换后的图片</li>
<li><code>ALL</code>：原始图片和转换后的图片都进行缓存</li>
<li><code>AUTOMATIC</code>：尝试选择最佳策略。针对加载数据类型进行区分：<ul>
<li>加载本地图片：缓存原始图片</li>
<li>加载网络图片：缓存转换后的图片</li>
</ul>
</li>
</ul>
</blockquote>
<p><code>stage</code>默认尽量就是<code>INITIALIZE</code>，通过递归调用<code>getNextStage()</code>向下推进，并改变<code>stage</code>表示进行状态。<code>stage</code>的推进过程也表示了硬盘缓存的查找顺序。</p>
<table>
<thead>
<tr>
<th>Stage</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>INITIALIZE</td>
<td>初始状态</td>
</tr>
<tr>
<td>RESOURCE_CACHE</td>
<td>转换后缓存 调用<code>ResourceCacheGenerator</code></td>
</tr>
<tr>
<td>DATA_CACHE</td>
<td>原图缓存 调用<code>DataCacheGenerator</code></td>
</tr>
<tr>
<td>SOURCE</td>
<td>远程获取图片 调用<code>SourceGenerator</code></td>
</tr>
<tr>
<td>ENCODE</td>
<td>解析资源，生成<code>Resource</code>对象</td>
</tr>
<tr>
<td>FINISHED</td>
<td>解析完成</td>
</tr>
</tbody>
</table>
<p>查找缓存从<code>初始查找开始</code>-&gt;<code>查找转换后图片缓存</code>-&gt;<code>查找原图图片缓存</code>-&gt;<code>前面都没找到就去进行远程加载</code>-&gt;<code>加载完成后就开始解析数据</code>-&gt;<code>解析完成</code>。</p>
<p>查找缓存从<code>currentGenerator.startNext()</code>开始，就先从<code>ResourceCacheGenerator</code>开始</p>
<figure class="highlight java"><figcaption><span>ResourceCacheGenerator.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> File cacheFile;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> startNext() &#123;<br>  List&lt;Key&gt; sourceIds = helper.getCacheKeys();<br>  <span class="hljs-keyword">if</span> (sourceIds.isEmpty()) &#123;<br>    return <span class="hljs-keyword">false</span>;<br>  &#125;<br>  List&lt;Class&lt;?&gt;&gt; resourceClasses = helper.getRegisteredResourceClasses();<br>  <span class="hljs-keyword">if</span> (resourceClasses.isEmpty()) &#123;<br>    <span class="hljs-keyword">if</span> (File.class.equals(helper.getTranscodeClass())) &#123;<br>      return <span class="hljs-keyword">false</span>;<br>    &#125;<br>    throw new IllegalStateException(<br>       "Failed to find any load path from " + helper.getModelClass() + " to "<br>           + helper.getTranscodeClass());<br>  &#125;<br>  <span class="hljs-keyword">while</span> (modelLoaders == <span class="hljs-keyword">null</span> || !hasNextModelLoader()) &#123;<br>    resourceClassIndex++;<br>    <span class="hljs-keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) &#123;<br>      sourceIdIndex++;<br>      <span class="hljs-keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) &#123;<br>        return <span class="hljs-keyword">false</span>;<br>      &#125;<br>      resourceClassIndex = 0;<br>    &#125;<br><br>    Key sourceId = sourceIds.get(sourceIdIndex);<br>    Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);<br>    Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);<br>    //构建磁盘缓存key<br>    currentKey =<br>        new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops<br>            helper.getArrayPool(),<br>            sourceId,<br>            helper.getSignature(),<br>            helper.getWidth(),<br>            helper.getHeight(),<br>            transformation,<br>            resourceClass,<br>            helper.getOptions());<br>    //根据Key去获取cacheFile<br>    cacheFile = helper.getDiskCache().get(currentKey);<br>    <span class="hljs-keyword">if</span> (cacheFile != <span class="hljs-keyword">null</span>) &#123;<br>      sourceKey = sourceId;<br>      modelLoaders = helper.getModelLoaders(cacheFile);<br>      modelLoaderIndex = 0;<br>    &#125;<br>  &#125;<br><br>  loadData = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;<br>    //使用FileLoader去加载对应cache文件<br>    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);<br>    loadData = modelLoader.buildLoadData(cacheFile,<br>        helper.getWidth(), helper.getHeight(), helper.getOptions());<br>    <span class="hljs-keyword">if</span> (loadData != <span class="hljs-keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;<br>      started = <span class="hljs-keyword">true</span>;<br>      loadData.fetcher.loadData(helper.getPriority(), <span class="hljs-keyword">this</span>);<br>    &#125;<br>  &#125;<br><br>  return started;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据相关参数生成对应的<code>cacheKey</code>，然后从<code>DiskCache</code>中取出对应的<code>cacheFile</code>，然后使用<code>FileLoader</code>解析该文件。</p>
<blockquote>
<p><code>helper.getDiskCache()</code>对应的就是<code>DiskLruCacheWrapper</code>类，内部包装了<code>DiskLruCache</code>，内部实现了整套的文件读写功能。</p>
</blockquote>
<h4 id="远程获取数据"><a href="#远程获取数据" class="headerlink" title="远程获取数据"></a>远程获取数据</h4><p>若为初次加载的数据，肯定不会在<code>diskCache</code>中获取到，就需要远程加载。</p>
<figure class="highlight java"><figcaption><span>SourceGenerator.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> startNext() &#123;<br>    //判断当前是否存在缓存<br>    <span class="hljs-keyword">if</span> (dataToCache != <span class="hljs-keyword">null</span>) &#123;<br>      Object data = dataToCache;<br>      dataToCache = <span class="hljs-keyword">null</span>;<br>      <br>      cacheData(data);<br>    &#125;<br>    //存在缓存<br>    <span class="hljs-keyword">if</span> (sourceCacheGenerator != <span class="hljs-keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;<br>      return <span class="hljs-keyword">true</span>;<br>    &#125;<br>    sourceCacheGenerator = <span class="hljs-keyword">null</span>;<br><br>    loadData = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;<br>      loadData = helper.getLoadData().get(loadDataListIndex++);<br>      <span class="hljs-keyword">if</span> (loadData != <span class="hljs-keyword">null</span> &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())<br>          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;<br>        started = <span class="hljs-keyword">true</span>;<br>        //加载远程图片<br>        loadData.fetcher.loadData(helper.getPriority(), <span class="hljs-keyword">this</span>);<br>      &#125;<br>    &#125;<br>    return started;<br>  &#125;<br>//缓存至磁盘中<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> cacheData(Object dataToCache) &#123;<br>    <span class="hljs-keyword">long</span> startTime = LogTime.getLogTime();<br>    <span class="hljs-keyword">try</span> &#123;<br>      Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);<br>      DataCacheWriter&lt;Object&gt; writer =<br>          new DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());<br>      originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());<br>      helper.getDiskCache().put(originalKey, writer);<br>      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;<br>        Log.v(TAG, "Finished encoding source to cache"<br>            + ", key: " + originalKey<br>            + ", data: " + dataToCache<br>            + ", encoder: " + encoder<br>            + ", duration: " + LogTime.getElapsedMillis(startTime));<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      loadData.fetcher.cleanup();<br>    &#125;<br><br>    sourceCacheGenerator =<br>        new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, <span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  @Override<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onDataReady(Object data) &#123;<br>    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();<br>    <span class="hljs-keyword">if</span> (data != <span class="hljs-keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;<br>      //上面判断是否cache<br>      dataToCache = data;<br>      cb.reschedule();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,<br>          loadData.fetcher.getDataSource(), originalKey);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>SourceGenerator.startNext()</code>会优先判断数据是否在<code>DiskCache</code>中，若存在调用<code>cacheData()</code>创建<code>DataCacheGenerator</code>调用其<code>startNext()</code>。不存在则循环去获取<code>loadData</code>，通过<code>DecodeHelper.getLoadData()</code>，然后继续执行<code>loadData.fetch.loadData()</code>去加载数据，加载成功后回调到<code>onDataReady()</code>。</p>
<p>现在开始按步骤分析：</p>
<h5 id="加载远程数据——地址加载-HttpUrlFetcher"><a href="#加载远程数据——地址加载-HttpUrlFetcher" class="headerlink" title="加载远程数据——地址加载(HttpUrlFetcher)"></a>加载远程数据——地址加载(<code>HttpUrlFetcher</code>)</h5><figure class="highlight java"><figcaption><span>HttpUrlFetcher.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> loadData(Priority priority, DataCallback&lt;? <span class="hljs-keyword">super</span> InputStream&gt; callback) &#123;<br>   <span class="hljs-keyword">try</span> &#123;<br>     InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, <span class="hljs-keyword">null</span>, glideUrl.getHeaders());<br>     callback.onDataReady(result);<br>   &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>     callback.onLoadFailed(e);<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<h5 id="加载本地数据——本地文件加载-ByteBufferFetcher"><a href="#加载本地数据——本地文件加载-ByteBufferFetcher" class="headerlink" title="加载本地数据——本地文件加载(ByteBufferFetcher)"></a>加载本地数据——本地文件加载(<code>ByteBufferFetcher</code>)</h5><figure class="highlight java"><figcaption><span>ByteBufferFileLoader.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> class ByteBufferFetcher implements DataFetcher&lt;ByteBuffer&gt; &#123;<br>  ...<br>     @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> loadData(@NonNull Priority priority,<br>        @NonNull DataCallback&lt;? <span class="hljs-keyword">super</span> ByteBuffer&gt; callback) &#123;<br>      ByteBuffer result;<br>      <span class="hljs-keyword">try</span> &#123;<br>        result = ByteBufferUtil.fromFile(file);<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;<br>          Log.d(TAG, "Failed to obtain ByteBuffer <span class="hljs-keyword">for</span> file", e);<br>        &#125;<br>        callback.onLoadFailed(e);<br>        return;<br>      &#125;<br><br>      callback.onDataReady(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>loadData()</code>成功后，回调到<code>SourceGenerator.onDataReady()</code>中。这时需要判断是否开启了硬盘缓存，如果关闭了直接回调到<code>DecodeJob.onDataFetcherReady()</code>，开启了的话，就继续调用到<code>DecodeJob.reschedule()</code>。</p>
<figure class="highlight plain"><figcaption><span>DecodeJob.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs jave">@Override<br> public void reschedule() &#123;<br>   runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;<br>   callback.reschedule(this);<br> &#125;<br><br> @Override<br> public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,<br>     DataSource dataSource, Key attemptedKey) &#123;<br>   this.currentSourceKey = sourceKey;<br>   this.currentData = data;<br>   this.currentFetcher = fetcher;<br>   this.currentDataSource = dataSource;<br>   this.currentAttemptingKey = attemptedKey;<br>   if (Thread.currentThread() != currentThread) &#123;<br>     //向下执行 数据解析<br>     runReason = RunReason.DECODE_DATA;<br>     //再次调用到 runWrapped() 此时会走向 decodeFromRetrievedData()<br>     callback.reschedule(this);<br>   &#125; else &#123;<br>     GlideTrace.beginSection(&quot;DecodeJob.decodeFromRetrievedData&quot;);<br>     try &#123;<br>       // 解析数据的真正逻辑<br>       decodeFromRetrievedData();<br>     &#125; finally &#123;<br>       GlideTrace.endSection();<br>     &#125;<br>   &#125;<br> &#125;<br> <br> private void runWrapped() &#123;<br>   switch (runReason) &#123;<br>     case INITIALIZE:<br>       stage = getNextStage(Stage.INITIALIZE);<br>       currentGenerator = getNextGenerator();<br>       runGenerators();<br>       break;<br>     case SWITCH_TO_SOURCE_SERVICE:<br>       runGenerators();<br>       break;<br>     case DECODE_DATA:<br>       //解析数据并解码<br>       decodeFromRetrievedData();<br>       break;<br>     default:<br>       throw new IllegalStateException(&quot;Unrecognized run reason: &quot; + runReason);<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>reschedule()</code>，把<code>runReason</code>设为<code>SWITCH_TO_SOURCE_SERVICE</code>，继续调用到<code>EngineJob.reschedule()</code>，再次执行到<code>DecodeJob.run()</code>不过已经在一个新的线程池中继续执行。</p>
<p>在<code>onDataFetcherReady()</code>中，会判断当前线程是否相同，不同的话，设置<code>runReason</code>为<code>DECODE_DATA</code>，重新执行<code>EngineJob.reschedule()</code>还会走到<code>run()</code>中，继续执行到<code>decodeFromRetrievedData()</code>，线程相同则直接执行。</p>
<h4 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h4><blockquote>
<p>此时拿到的数据类型还是<code>InputStream</code>或者<code>ByteBuffer</code>，需要解析成常用的<code>File</code>或者<code>Bitmap</code>。</p>
</blockquote>
<p>此时<code>runReason</code>为<code>DECODE_DATA</code>，调用到<code>decodeFromRetrievedData()</code></p>
<figure class="highlight java"><figcaption><span>DecodeJob.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object currentData;  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> decodeFromRetrievedData() &#123;<br>    ...<br>    Resource&lt;R&gt; resource = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      resource = decodeFromData(currentFetcher, currentData, currentDataSource);<br>    &#125; <span class="hljs-keyword">catch</span> (GlideException e) &#123;<br>      e.setLoggingDetails(currentAttemptingKey, currentDataSource);<br>      throwables.add(e);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;<br>      notifyEncodeAndRelease(resource, currentDataSource);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      runGenerators();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> &lt;Data&gt; Resource&lt;R&gt; decodeFromData(DataFetcher&lt;?&gt; fetcher, Data data,<br>      DataSource dataSource) <span class="hljs-keyword">throws</span> GlideException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      ...<br>      Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);<br>      return result;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      fetcher.cleanup();<br>    &#125;<br>  &#125;<br><br>  @SuppressWarnings("unchecked")<br>  <span class="hljs-keyword">private</span> &lt;Data&gt; Resource&lt;R&gt; decodeFromFetcher(Data data, DataSource dataSource)<br>      <span class="hljs-keyword">throws</span> GlideException &#123;<br>    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());<br>    return runLoadPath(data, dataSource, path);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> &lt;Data, ResourceType&gt; Resource&lt;R&gt; runLoadPath(Data data, DataSource dataSource,<br>      LoadPath&lt;Data, ResourceType, R&gt; path) <span class="hljs-keyword">throws</span> GlideException &#123;<br>    Options options = getOptionsWithHardwareConfig(dataSource);<br>    DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data);<br>    <span class="hljs-keyword">try</span> &#123;<br>      return path.load(<br>          rewinder, options, width, height, new DecodeCallback&lt;ResourceType&gt;(dataSource));<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      rewinder.cleanup();<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>调用<code>decodeFromRetrievedData</code>开始解析加载返回的数据，数据格式可能为<code>InputSteam</code>、<code>ByteBuffer</code>。向下调用到<code>decodeFromData()</code>，再到<code>decodeFromFetcher()</code>，最终通过<code>DecodeHelper.getLoadPath()</code>得到的<code>LoadPath</code>去对获取的数据进行解析。</p>
<figure class="highlight java"><figcaption><span>LoadPath.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> Resource&lt;Transcode&gt; load(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, <span class="hljs-keyword">int</span> width,<br>      <span class="hljs-keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback) <span class="hljs-keyword">throws</span> GlideException &#123;<br>    List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());<br>    <span class="hljs-keyword">try</span> &#123;<br>      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      listPool.release(throwables);<br>    &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span> Resource&lt;Transcode&gt; loadWithExceptionList(DataRewinder&lt;Data&gt; rewinder,<br>      @NonNull Options options,<br>      <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback,<br>      List&lt;Throwable&gt; exceptions) <span class="hljs-keyword">throws</span> GlideException &#123;<br>    Resource&lt;Transcode&gt; result = <span class="hljs-keyword">null</span>;<br>    //noinspection ForLoopReplaceableByForEach to improve perf<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0, size = decodePaths.size(); i &lt; size; i++) &#123;<br>      DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);<br>      <span class="hljs-keyword">try</span> &#123;<br>        //又传递到DecodePath上<br>        result = path.decode(rewinder, width, height, options, decodeCallback);<br>      &#125; <span class="hljs-keyword">catch</span> (GlideException e) &#123;<br>        exceptions.add(e);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;<br>      throw new GlideException(failureMessage, new ArrayList&lt;&gt;(exceptions));<br>    &#125;<br><br>    return result;<br>  &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>DecodePath.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> Resource&lt;Transcode&gt; decode(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height,<br>     @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback) <span class="hljs-keyword">throws</span> GlideException &#123;<br>   Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);<br>   Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);<br>   return transcoder.transcode(transformed, options);<br> &#125;<br><br> @NonNull<br> <span class="hljs-keyword">private</span> Resource&lt;ResourceType&gt; decodeResource(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width,<br>     <span class="hljs-keyword">int</span> height, @NonNull Options options) <span class="hljs-keyword">throws</span> GlideException &#123;<br>   List&lt;Throwable&gt; exceptions = Preconditions.checkNotNull(listPool.acquire());<br>   <span class="hljs-keyword">try</span> &#123;<br>     return decodeResourceWithList(rewinder, width, height, options, exceptions);<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>     listPool.release(exceptions);<br>   &#125;<br> &#125;<br><br>@NonNull<br> <span class="hljs-keyword">private</span> Resource&lt;ResourceType&gt; decodeResourceWithList(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width,<br>     <span class="hljs-keyword">int</span> height, @NonNull Options options, List&lt;Throwable&gt; exceptions) <span class="hljs-keyword">throws</span> GlideException &#123;<br>   Resource&lt;ResourceType&gt; result = <span class="hljs-keyword">null</span>;<br>   //noinspection ForLoopReplaceableByForEach to improve perf<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0, size = decoders.size(); i &lt; size; i++) &#123;<br>     ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);<br>     <span class="hljs-keyword">try</span> &#123;<br>       //数据解析器<br>       DataType data = rewinder.rewindAndGet();<br>       <span class="hljs-keyword">if</span> (decoder.handles(data, options)) &#123;<br>         data = rewinder.rewindAndGet();<br>         result = decoder.decode(data, width, height, options);<br>       &#125;<br>     &#125; <span class="hljs-keyword">catch</span> (IOException | RuntimeException | OutOfMemoryError e) &#123;<br><br>     &#125;<br><br>     <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>       <span class="hljs-keyword">break</span>;<br>     &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;<br>     throw new GlideException(failureMessage, new ArrayList&lt;&gt;(exceptions));<br>   &#125;<br>   return result;<br> &#125;<br></code></pre></td></tr></table></figure>
<p><code>LoadPath.load()</code>通过调用<code>loadWithExceptionList()</code>，循环获取<code>DecodePath</code>对象，然后调用其自身的<code>decode()</code>进行数据解析。<code>DecodePath</code>与<code>LoadPath</code>逻辑相似，最终在<code>DecodePath.decodeResourceWithList()</code>中循环获取<code>ResourceDecoder</code>对象，通过<code>DateRewinder.rewindAndGet()</code>获取要解析数据的格式(比如<code>ByteBuffer，InputStream</code>)，然后调用<code>decoder.decode</code>继续解析数据。</p>
<h5 id="获取数据格式"><a href="#获取数据格式" class="headerlink" title="获取数据格式"></a>获取数据格式</h5><p>由上述流程可知，我们能获得的数据类型为<code>InputStream</code>和<code>ByteBuffer</code>，对应的就会有两种<code>DataRewinder</code></p>
<figure class="highlight java"><figcaption><span>InputStreamRewinder.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RecyclableBufferedInputStream bufferedStream;<br>@NonNull<br>  @Override<br>  <span class="hljs-keyword">public</span> InputStream rewindAndGet() <span class="hljs-keyword">throws</span> IOException &#123;<br>    bufferedStream.reset();<br>    return bufferedStream;<br>  &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>ByteBufferRewinder.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">@NonNull<br>@Override<br><span class="hljs-keyword">public</span> ByteBuffer rewindAndGet() &#123;<br>  buffer.position(0);<br>  return buffer;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>将传进来的data可以转换成对应的数据格式。</p>
<h5 id="根据格式转换相应类型"><a href="#根据格式转换相应类型" class="headerlink" title="根据格式转换相应类型"></a>根据格式转换相应类型</h5><p>得到对应数据格式后，就需要通过<code>ResourceDecoder.decode()</code>去解析数据。</p>
<figure class="highlight java"><figcaption><span>ResourceDecoder.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> interface ResourceDecoder&lt;T, Z&gt; &#123;<br>  //判断这两个组合参数是否能进行解析<br>  <span class="hljs-keyword">boolean</span> handles(@NonNull T source, @NonNull Options options) <span class="hljs-keyword">throws</span> IOException;<br><br>   */<br>  @Nullable<br>  Resource&lt;Z&gt; decode(@NonNull T source, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, @NonNull Options options)<br>      <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>T</code>代表需要被解析的类型(例如InputStream、ByteBuffer)，<code>Z</code>代表解析的结果类型(例如Bitmap、Drawable)。</p>
<p><code>ResourceDecoder</code>在原码中有很多实现类，<code>StreamBitmapDecoder</code>、<code>ButeBufferBitmapDecoder</code>，此处拿出常用的<code>StreamBitmapDecoder</code>进行分析。</p>
<figure class="highlight java"><figcaption><span>StreamBitmapDecoder.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> handles(@NonNull InputStream source, @NonNull Options options) &#123;<br>  return downsampler.handles(source);<br>&#125;<br><br>@Override<br><span class="hljs-keyword">public</span> Resource&lt;Bitmap&gt; decode(@NonNull InputStream source, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height,<br>    @NonNull Options options)<br>    <span class="hljs-keyword">throws</span> IOException &#123;<br><br>  // Use to fix the mark limit to avoid allocating buffers that fit entire images.<br>  <span class="hljs-keyword">final</span> RecyclableBufferedInputStream bufferedStream;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> ownsBufferedStream;<br>  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> RecyclableBufferedInputStream) &#123;<br>    bufferedStream = (RecyclableBufferedInputStream) source;<br>    ownsBufferedStream = <span class="hljs-keyword">false</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    bufferedStream = new RecyclableBufferedInputStream(source, byteArrayPool);<br>    ownsBufferedStream = <span class="hljs-keyword">true</span>;<br>  &#125;<br>  ExceptionCatchingInputStream exceptionStream =<br>      ExceptionCatchingInputStream.obtain(bufferedStream);<br><br>  MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream);<br>  UntrustedCallbacks callbacks = new UntrustedCallbacks(bufferedStream, exceptionStream);<br>  <span class="hljs-keyword">try</span> &#123;<br>    return downsampler.decode(invalidatingStream, width, height, options, callbacks);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    exceptionStream.release();<br>    <span class="hljs-keyword">if</span> (ownsBufferedStream) &#123;<br>      bufferedStream.release();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ResourceDecode.decode()</code>内部是通过<code>Downsampler.decode()</code>进行解析</p>
<figure class="highlight java"><figcaption><span>Downsampler.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"> @SuppressWarnings(&#123;"resource", "deprecation"&#125;)<br> <span class="hljs-keyword">public</span> Resource&lt;Bitmap&gt; decode(InputStream is, <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight,<br>     Options options, DecodeCallbacks callbacks) <span class="hljs-keyword">throws</span> IOException &#123;<br>   ...<br>   <span class="hljs-keyword">try</span> &#123;<br>     Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,<br>         downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,<br>         requestedHeight, fixBitmapToRequestedDimensions, callbacks);<br>     return BitmapResource.obtain(result, bitmapPool);<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>     releaseOptions(bitmapFactoryOptions);<br>     byteArrayPool.put(bytesForOptions);<br>   &#125;<br> &#125;<br><br><span class="hljs-keyword">private</span> Bitmap decodeFromWrappedStreams(InputStream is,<br>     BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,<br>     DecodeFormat decodeFormat, <span class="hljs-keyword">boolean</span> isHardwareConfigAllowed, <span class="hljs-keyword">int</span> requestedWidth,<br>     <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">boolean</span> fixBitmapToRequestedDimensions,<br>     DecodeCallbacks callbacks) <span class="hljs-keyword">throws</span> IOException &#123;<br>  <br>     Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);<br>     callbacks.onDecodeComplete(bitmapPool, downsampled);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap decodeStream(InputStream is, BitmapFactory.Options options,<br>     DecodeCallbacks callbacks, BitmapPool bitmapPool) <span class="hljs-keyword">throws</span> IOException &#123;<br>   ...<br>   TransformationUtils.getBitmapDrawableLock().lock();<br>   <span class="hljs-keyword">try</span> &#123;<br>     result = BitmapFactory.decodeStream(is, <span class="hljs-keyword">null</span>, options);<br>   &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>     ...<br>     throw bitmapAssertionException;<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>     TransformationUtils.getBitmapDrawableLock().unlock();<br>   &#125;<br>  ...<br> &#125;<br></code></pre></td></tr></table></figure>
<p><code>Downsampler.decode()</code>内部主要实现依靠<code>decodeFromWrapperStreams()</code>，内部主要是配置<code>BitmapFactory.Options</code>。去控制图片的缩放(scale)、旋转(rotate)、复用(inBitmap)等方面配置。最后通过<code>decodeStream</code>解析输入流，最后生成Bitmap对象返回。</p>
<h5 id="获取图片后继续处理-例如圆角"><a href="#获取图片后继续处理-例如圆角" class="headerlink" title="获取图片后继续处理(例如圆角)"></a>获取图片后继续处理(例如圆角)</h5><figure class="highlight java"><figcaption><span>DecodePath.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Resource&lt;Transcode&gt; decode(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height,<br>    @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback) <span class="hljs-keyword">throws</span> GlideException &#123;<br>  //上述步骤已完成<br>  Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);<br>  //加载完成的回调 调用Transform<br>  Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);<br>  return transcoder.transcode(transformed, options);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>decodeResource</code>最终会调到<code>DecodeJob.onResourceDecoded()</code>进行<code>Transform</code>处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"> &lt;Z&gt; Resource&lt;Z&gt; onResourceDecoded(DataSource dataSource,<br>      @NonNull Resource&lt;Z&gt; decoded) &#123;<br>    @SuppressWarnings("unchecked")<br>    Class&lt;Z&gt; resourceSubClass = (Class&lt;Z&gt;) decoded.get().getClass();<br>    Transformation&lt;Z&gt; appliedTransformation = <span class="hljs-keyword">null</span>;<br>    Resource&lt;Z&gt; transformed = decoded;<br>    <span class="hljs-keyword">if</span> (dataSource != DataSource.RESOURCE_DISK_CACHE) &#123;<br>      //获取到的是 RequestOptions.getTransformations()这个集合<br>      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);<br>      transformed = appliedTransformation.transform(glideContext, decoded, width, height);<br>    &#125;<br>    // TODO: Make <span class="hljs-keyword">this</span> the responsibility of the Transformation.<br>    <span class="hljs-keyword">if</span> (!decoded.equals(transformed)) &#123;<br>      decoded.recycle();<br>    &#125;<br><span class="hljs-keyword">if</span> (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,<br>        encodeStrategy)) &#123;<br>      <span class="hljs-keyword">if</span> (encoder == <span class="hljs-keyword">null</span>) &#123;<br>        throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());<br>      &#125;<br>      <span class="hljs-keyword">final</span> Key key;<br>      <span class="hljs-keyword">switch</span> (encodeStrategy) &#123;<br>        <span class="hljs-keyword">case</span> SOURCE:<br>          key = new DataCacheKey(currentSourceKey, signature);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> TRANSFORMED:<br>          key =<br>              new ResourceCacheKey(<br>                  decodeHelper.getArrayPool(),<br>                  currentSourceKey,<br>                  signature,<br>                  width,<br>                  height,<br>                  appliedTransformation,<br>                  resourceSubClass,<br>                  options);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);<br>      &#125;<br>    ...<br>    &#125;<br>    return result;<br>  &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>从这里可看出 保存原图和保存转换后图片的缓存key是不一致的。</p>
<p>缓存原图用的是<code>DataCacheKey</code>，保存转换后图片用的是<code>ResourceCacheKey</code></p>
</blockquote>
<p>上述数据处理完毕后，层层回溯到达了<code>decodeFromRetrievedData</code>()</p>
<figure class="highlight java"><figcaption><span>DecodeJob.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> decodeFromRetrievedData() &#123;<br>    ...<br>    Resource&lt;R&gt; resource = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      resource = decodeFromData(currentFetcher, currentData, currentDataSource);<br>    &#125; <span class="hljs-keyword">catch</span> (GlideException e) &#123;<br>      e.setLoggingDetails(currentAttemptingKey, currentDataSource);<br>      throwables.add(e);<br>    &#125;<br>    //这时Resource已经赋值完毕<br>    <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;<br>      notifyEncodeAndRelease(resource, currentDataSource);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      runGenerators();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> notifyEncodeAndRelease(Resource&lt;R&gt; resource, DataSource dataSource) &#123;<br>    <span class="hljs-keyword">if</span> (resource <span class="hljs-keyword">instanceof</span> Initializable) &#123;<br>      ((Initializable) resource).initialize();<br>    &#125;<br><br>    notifyComplete(result, dataSource);<br>    //加载完毕后 回到初始状态<br>    stage = Stage.ENCODE;<br>    ...<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> notifyComplete(Resource&lt;R&gt; resource, DataSource dataSource) &#123;<br>    setNotifiedOrThrow();<br>    callback.onResourceReady(resource, dataSource);<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>经过解析数据那一套流程下来后，数据已经加载完成，然后回到<code>DecodeJob.decodeFromRetrieveData()</code>，这时Resource对象不为空，向下继续调用<code>notifyEncodeAndRelease()</code>，内部调用到<code>notifyComplete()</code>再回调到<code>EngineJob.onResourceReady()</code>。</p>
<figure class="highlight java"><figcaption><span>EngineJob.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onResourceReady(Resource&lt;R&gt; resource, DataSource dataSource) &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">this</span>.resource = resource;<br>    <span class="hljs-keyword">this</span>.dataSource = dataSource;<br>  &#125;<br>  notifyCallbacksOfResult();<br>&#125;<br><br><span class="hljs-keyword">void</span> notifyCallbacksOfResult() &#123;<br>  ResourceCallbacksAndExecutors copy;<br>  Key localKey;<br>  EngineResource&lt;?&gt; localResource;<br><br>  listener.onEngineJobComplete(<span class="hljs-keyword">this</span>, localKey, localResource);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;<br>    entry.executor.execute(new CallResourceReady(entry.cb));<br>  &#125;<br>  decrementPendingCallbacks();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>EngineJob.onResourceReady()</code>资源加载完成后，通过<code>notifyCallbacksOfResulr()</code>调用到<code>Engine.onEngineJobComplete()</code></p>
<figure class="highlight java"><figcaption><span>Engine.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> onEngineJobComplete(<br>    EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource) &#123;<br>  // A <span class="hljs-keyword">null</span> resource indicates that the load failed, usually due to an exception.<br>  <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;<br>    resource.setResourceListener(key, <span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-keyword">if</span> (resource.isCacheable()) &#123;<br>      activeResources.activate(key, resource);<br>    &#125;<br>  &#125;<br><br>  jobs.removeIfCurrent(key, engineJob);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>加载完成后，把对应资源插入到<code>ActiveResources</code>中作为活动资源。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide-硬盘缓存.png" srcset="/img/loading.gif" class="full-image" alt="Glide-硬盘缓存" title="Glide-硬盘缓存"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="Glide高级用法"><a href="#Glide高级用法" class="headerlink" title="Glide高级用法"></a>Glide高级用法</h2><p>处理带有后缀的图片类型，可能为了保证安全，不同的用户获取的图片除了图片地址外还会有一段标识用户的token。而且token并不一定是固定的，这样我们再去加载图片时，由于缓存key不一致，导致重复加载。</p>
<p>这里涉及到了<a href="#缓存key">缓存key</a>的生成，其中有一个重要参数为远程图片加载地址，对于上述情况，因为地址的变化，key不同则查找缓存时也无法命中，解决这个情况就需要排除掉变化的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">class MyGlideUrl extends GlideUrl&#123;<br><br>    <span class="hljs-keyword">private</span> String mUrl;<br><br>    <span class="hljs-keyword">public</span> MyGlideUrl(String url) &#123;<br>        <span class="hljs-keyword">super</span>(url);<br>        mUrl = url;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> String getCacheKey() &#123;<br>        return mUrl.replace(replaceTokenParam(),"");<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> String replaceTokenParam()&#123;<br>        String tokenParam="";<br>        <span class="hljs-keyword">int</span> tokenIndex = mUrl.contains("?.token") ? mUrl.indexOf("?token"):mUrl.indexOf("&amp;token");<br>        <span class="hljs-keyword">if</span>(tokenIndex!=-1)&#123;<br>            <span class="hljs-keyword">int</span> nextAndIndex = mUrl.indexOf("&amp;",tokenIndex+1);<br>            <span class="hljs-keyword">if</span> (nextAndIndex!=-1)&#123;<br>                tokenParam = mUrl.substring(tokenIndex+1,nextAndIndex+1);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tokenParam = mUrl.substring(tokenIndex);<br>            &#125;<br>        &#125;<br>        return tokenParam;<br>    &#125;<br>&#125;<br><br><br>Glide.with(mContext).load(MyGlideUrl(imgUrl)).into(imageView);<br></code></pre></td></tr></table></figure>
<h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5c31fbdff265da610e803d4e#heading-14" target="_blank" rel="noopener">Glide主流源码分析</a></p>
<p><a href="https://juejin.im/post/5c2dffa8f265da611d66c8b6#heading-2" target="_blank" rel="noopener">Glide4.8源码拆解（二）核心加载流程</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/源码解析/">源码解析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/03/19/Android-Study-Plan-XI/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android-Study-Plan-XI</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/03/18/Android-Study-Plan-IX/">
                        <span class="hidden-mobile">Android Study Plan IX - ClassLoaderß</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
