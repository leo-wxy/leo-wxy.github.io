<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="日常细节记录"><meta name="keywords" content="Android,Java"><meta name="author" content="Leo-Wxy"><meta name="copyright" content="Leo-Wxy"><title>日常细节记录 | Wxy的个人博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Leo-Wxy</div><div class="author-info__description text-center">如果我没有见过光明，那我本可以忍受黑暗</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">128</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Wxy的个人博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">日常细节记录</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-03</time></div><div class="article-container" id="post-content"><ol>
<li><p>强引用置为null时，不会立即回收对象，帮助回收器加快回收。但是会帮助GC 等到下次回收周期时即会回收</p>
</li>
<li><p>死锁的四个必要条件：互斥，占有且等待，不可抢占，循环等待</p>
</li>
<li><p>CAS(原子操作)是乐观锁用到的主要机制，乐观锁是不用加锁去执行操作，如果产生冲突则失败重试，直到成功为止，也叫做“自旋”。与乐观锁相对应的是悲观锁，synchronized就是悲观锁，也叫“独占锁”需要加锁进行操作，并且加锁代码块中的只能有一个线程进行操作。</p>
</li>
<li><p>点击App图标，系统最开始执行的是ActivityThread的main()方法</p>
</li>
<li><p>应用的启动方式：</p>
<ol>
<li>冷启动：启动应用时，后台没有该应用的进程。系统创建一个新的进程来进行重新分配。</li>
<li>热启动：启动应用时，后台已有该应用的进程。</li>
</ol>
</li>
<li><p>Application的生命周期：<code>onCreate()//应用开始时执行-&gt;onLowMemory()//内存低时执行-&gt;onTrimMemory()//关闭应用时执行  onTerminate()//在真机上不会调用</code></p>
</li>
<li><p>进程相关： <code>优先级最低的进程首先被杀死、进程的等级会因为其他进程的依赖而提高一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低</code> 按重要性分类：</p>
<ol>
<li>前台进程：进程持有一个正在与用户交互的Activity或者和交互Activity绑定的Service，前台运行的Service（执行<code>startForeground()</code>）,执行<code>onReceive()</code>的BroadcastReceiver</li>
<li>可见进程：进程持有一个被用户可见但没有显示在最前端的Activity(调用到了<code>onPause()</code>)或者和可见Activity绑定的Service</li>
<li>服务进程：进程持有一个<code>startService()</code>启动的Service进程，例如播放音乐，下载文件等Service</li>
<li>后台进程：进程持有一个用户不可见的Activity(调用到<code>onStop()</code>没有到<code>onDestroy()</code>)，进程被存放在一个LRU列表中，即很长时间没用的Activity会被优先杀死</li>
<li>空进程：进程不包含任何活跃的应用组件，唯一的作用是<code>为了缓存需要，缩短下次启动的时间</code></li>
</ol>
</li>
<li><p>统计应用启动时间：<code>adb shell am start -W [packageName]/[packageName.MainActivity]</code></p>
</li>
<li><p><code>volatile</code>作用是<code>可见性</code>(当一个线程修改了某一个全局变量的值，其他线程能否知道这个修改)，<code>有序性</code>（禁止指令重排优化,防止代码执行指令被重新排序）。<code>volatile</code>并不能保证线程安全即保证不了线程间操作的原子性。</p>
</li>
<li><p>SharedPreference中<code>apply</code>和<code>commit</code>方法的区别：<code>commit</code>同步保存更改，<code>apply</code>异步保存到磁盘，原子提交，性能较高，但不保存结果。SharedPreference不支持多线程操作，<code>MODE_MULTI_PROCESS</code>这个标记位并没有实际作用。可以利用<code>ContentProvider</code>去实现多进程，_方案后续会有介绍_。</p>
</li>
<li><p>MD5不是加密算法，是一种散列算法。加密算法一般是对称加密算法</p>
</li>
<li><p>使用ADB启动Activity：<code>adb shell am start -n 包名/需启动Activity路径</code></p>
</li>
<li><p>Fragment中<code>replace</code>与<code>add</code>区别：</p>
<ul>
<li><code>replcae</code>：把容器内所有内容进行替换，都需要重新走一遍fragment的生命周期</li>
<li><code>add</code>：添加不会清空容器内的内容。</li>
</ul>
</li>
<li><p>在三星手机上，进行原生分享文件时需要设置mimeType</p>
</li>
<li><p><code>invalidate()</code>、<code>postInvalidate()</code>和<code>requestLayout()</code>的区别：</p>
<ul>
<li><code>invalidate()</code>：当子View调用invalidate方法时，会给View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递至ViewRootImpl中，最终触发performTraversals方法，进行View的重绘（即调用onDraw方法）。<strong>该方法只能在UI线程中调用</strong></li>
<li><code>postInvalidate()</code>：与invalidate作用一致，都是使View进行重绘，<strong>该方法是在非UI线程中调用的</strong>。内部主要实现是提供一个Handler实现，然后直接调用了invalidate方法，继续执行重绘流程。</li>
<li><code>requestLayout()</code>：调用了这个方法会重新执行View的绘制流程，即重新执行测量(<code>onMeasure</code>)，布局(<code>onLayout</code>)，绘制(<code>onDraw</code>)方法。<strong>利用责任链模式-不断向上传递该事件，直到找到能处理该事件的上级</strong>。</li>
</ul>
</li>
<li><p>Bitmap所占用的内存 = 图片长度 x 图片宽度 x （屏幕分辨率÷图片资源目录分辨率）²×一个像素点占用的字节数</p>
</li>
<li><p>HashMap扩容机制 在1.8之前只要达到负载就进行扩容，1.8之后是防止Hash冲突才进行扩容，如果不冲突不会触发扩容。</p>
</li>
<li><p><code>px转换为dp</code>：<strong>px/(DPI/160) = dp</strong>，例如<code>1920 * 1080 , 480dpi</code>，最终转化就会得到360dp</p>
</li>
<li><p>内部类可以访问外部类 <code>private</code>变量。在内部类需要引用外部类的<code>private</code>变量时，会默认生成一个<code>access$XXX()</code>，内部会返回当前对象</p>
</li>
<li><p>Java与Dart一样都是采用了<strong>值传递</strong>的<code>求值策略</code>：</p>
<p>| 求值策略     | 求值时间 | 传值方式           |<br>| ———— | ——– | —————— |<br>| <strong>值传递</strong>   | 调用前   | 值的结果(值的副本) |<br>| <strong>引用传递</strong> | 调用前   | 原始值             |<br>| <strong>名传递</strong>   | 调用后   | 与值无关的一个名   |</p>
<p>其中最常见的是<strong>值传递</strong>(主要应用于Java、Dart、OC等)，然后是<strong>引用传递</strong>(C、C++、C#)。</p>
<p>这两者主要的区别如下：</p>
<blockquote>
<p><code>值传递</code>：调用函数时将参数<strong>复制</strong>一份传递到函数中，函数中对参数进行修改，也不会影响到实际参数<br><code>引用传递</code>：调用函数时传递的是<strong>实际参数的地址</strong>，函数中对参数进行修改时，也会影响到实际参数的值</p>
</blockquote>
<p><code>值传递</code>无论参数类型是<code>值类型或引用类型</code>，都会调用栈上创建的一个副本。</p>
<ul>
<li>对于<code>值类型</code>，栈上的副本是<strong>整个原始值的复制</strong></li>
<li>对于<code>引用类型</code>，由于<code>引用类型</code>的实例在堆上，栈上的副本是<strong>该变量在堆上的引用地址</strong></li>
</ul>
</li>
</ol>
<ol>
<li><p><code>UncaughtExceptionHandler</code>在<code>uncaughtException()</code>中接收应用所发生的异常，如果在该方法内再次发生异常<strong>就会导致进入无限崩溃状态</strong>。</p>
</li>
<li><p><code>build.gradle</code>中<code>compileSdkVersion</code>,<code>minSdkVersion</code>,<strong><code>targetSdkVersion</code></strong>这三个参数的说明：</p>
<p><code>compileSdkVersion</code>：编译应用使用的SDK版本，单纯在编译时使用。<em>使用最新的编译SDK的好处就在于可以及时了解到API的状态例如弃用并可以提前使用新的API。</em>此处需要注意一点：<strong>如果使用最新的<code>support library</code>，compileSdkVersion的版本至少要大于support的版本以保证编译通过。</strong></p>
<p><code>minSdkVersion</code>：<strong>应用可以运行的最低版本</strong>。<em>主要可以用于在应用使用高于该版本的api时进行提示，避免运行过程出现崩溃。</em>当依赖多个Module都制定了<code>minSdkVersion</code>时，自身推荐使用依赖库中最大的<code>minSdkVersion</code>避免出现问题。如果使用了比依赖库小的版本号，可以使用<code>tools:overrideLibrary</code>标志避免提示。</p>
<p><code>targetSdkVersion</code>：<strong>应用向前兼容的主要依据。</strong>为了保证老Apk在新版本系统上的兼容性，只要老Apk的<code>targetSdkVersion</code>版本不发生变化，在新系统依然会保持老系统上的行为。<br>Android系统通过获取<code>apk配置的targetSdkVersion</code>在调用系统对应Api时进行版本判断去执行不同的逻辑。</p>
</li>
</ol>
<p>这三者的大小顺序应该为<strong> minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</strong>这个是比较合理的顺序。</p>
<ol>
<li><p><code>==</code>与<code>equals()</code>的区别</p>
<ul>
<li><code>==</code>：所以基本类型比较的是<strong>值是否相等</strong>，所以引用类型比较的是<strong>两者在内存中存放的地址(堆内存地址)</strong>。</li>
<li><code>equals()</code>：默认比较的是<strong>对象的内存地址值</strong>，如果重写了<code>equals()</code>，则按照重写规则比较(例如String 重写了<code>equals()</code>这样就变成值比较)。<ul>
<li><code>hashcode()</code>：在比较<code>equals()</code>之前会先比较<code>hashcode</code>，如果不同则表示两个值不相等，若相同再进行<code>equals()</code>比较</li>
</ul>
</li>
</ul>
</li>
<li><p>自动装箱/拆箱相关知识</p>
<p>以下拿<code>int</code>，<code>Integer</code>举例：<code>int</code>就是原始类型，<code>Integer</code>就是包装类型。</p>
<p><code>自动装箱</code>：<strong>将原始类型转换为包装类型</strong> ── <code>Interger x = 1000</code>=&gt;<code>Integer x = Integer.valueOf(1000);</code>转换成如下代码</p>
<p><code>自动拆箱</code>：<strong>将包装类型转换为原始类型</strong>──<code>Integer x = 1000;System.out.println(x)</code>=&gt;<code>System.out.println(x.intValue())</code>转换成如下代码</p>
<p>拓展知识：</p>
<p><code>Integer</code>的缓存策略：<code>Integer</code>中存在一个缓存池(<code>IntegetCache</code>)将使用频繁的值进行缓存避免创建过多对象提高性能。默认缓存池范围为<code>-128~127</code>，如果在该范围内返回的就是 <code>IntegerCache</code>中的对象，否则返回<code>new Integer(XX)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">127</span>;</span><br><span class="line">Integer a1 = <span class="number">127</span>;</span><br><span class="line">  </span><br><span class="line">Integer b = <span class="number">128</span>;</span><br><span class="line">Integer b1 = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a==a1); <span class="comment">//true 返回的实际上是缓存池的对象</span></span><br><span class="line">System.out.println(a.equals(a1)); <span class="comment">//true</span></span><br><span class="line">System.out.println(b==b1); <span class="comment">//false 重新new Integer</span></span><br><span class="line">System.out.println(b.equals(b1)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>Linux中的<code>epoll、select、inotify</code>机制简析</p>
<p>都是<code>IO多路复用机制</code>，一个进程可以监视多个描述符，一旦某个描述符就位，就会通知系统回写。</p>
<blockquote>
<p><code>IO多路复用</code>：内核一旦发现进程指定的一个或者多个IO条件准备读取，就会通知该进程。</p>
<p>优势在于系统开销小，系统不需要创建进程/线程，也无需维护。</p>
</blockquote>
<ul>
<li><p><code>inotify</code>：允许监控程序打开一个独立文件描述符，并针对事件集监控一个或多个文件，例如：打开、关闭、重命名、创建、删除等功能。（用于<code></code>FileObserver`监听对应文件的打开、修改、创建等事件）</p>
<ul>
<li><code>inotify_init()</code>创建一个监听文件变动的inotify实例,并返回指向该实例的文件描述符（fd）</li>
<li><code>inotify_add_watch</code>增加对文件或目录的监控，并指定监控事件</li>
<li><code>inotify_rm_watch</code>移除对文件或目录的监控</li>
</ul>
</li>
<li><p><code>select</code>：允许进程指示内核等待多个事件的任何一个发送，并只有在一个或多个事件发生或经历一段指定的时间后才唤醒。</p>
<p><code>select</code>需要遍历所有句柄才可以获取到哪个句柄有事件通知，并且最多支持1024个句柄，超过则可能导致溢出异常。</p>
</li>
<li><p><code>epoll</code>：epoll使用一个文件描述符管理多个文件描述符，将用户关系的文件描述符的事件存放到一个内核的事件表中。</p>
<ul>
<li><p><code>epoll_create(int size)</code>：告诉内核需要监听的文件描述符个数</p>
</li>
<li><p><code>epoll_ctl(int epfd,int op,int fd,struct epoll_event *event)</code>：对指定文件描述符进行<code>op</code>操作</p>
<ul>
<li><p>epfd：epoll_create 返回的文件描述符</p>
</li>
<li><p>op：1)EPOLL_CTL_ADD 增加监听事件</p>
<p>​      2)EPOLL_CTL_DEL 删除监听事件</p>
<p>​      3)EPOLL_CTL_MOD 修改监听事件</p>
</li>
<li><p>fd：需要监听的文件描述符</p>
</li>
<li><p>event：告诉内核需要监听的事件</p>
</li>
</ul>
</li>
<li><p><code>epoll_wait()</code>：等待epfd的监听回调</p>
<p><code>epoll</code>对于句柄事件的选择不是遍历的，当事件响应时会通知到epoll。</p>
<p><code>epoll</code>有两种工作模式：</p>
<ul>
<li>LT模式-水平触发(默认模式)：<code>epoll_wait</code>检测到描述符事件时会通知到应用程序，应用程序可以不立即处理该事件，等待下次<code>epoll_wait</code>时会继续发出通知。<strong>效率较低但是不用担心数据丢失。</strong></li>
<li>ET模式-边缘触发：<code>epoll_wait</code>检测到描述符事件时会通知到应用程序，应用程序必须立即处理该事件，等待下次<code>epoll_wait</code>时不会继续发出通知。<strong>效率最高但是需要对每个请求进行处理，避免丢失事件造成影响。必须使用非阻塞套接口，避免堵塞造成任务堵死。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></p>
<ol>
<li><p>MarkDown在嵌套<code>&lt;html&gt;&lt;/html&gt;</code>时会产生多余的<code>&lt;br&gt;</code>，需要使用 <code>  包html table</code></p>
</li>
<li><p><code>i++</code>与<code>++i</code>的区别？</p>
<p><strong>1、 i++ 返回原来的值，++i 返回加1后的值。</strong><br><strong>2、 i++ 不能作为左值，而++i 可以。</strong></p>
</li>
</ol>
<p>   <strong>首先解释下什么是左值</strong>（以下两段引用自中文维基百科『右值引用』词条）。</p>
<blockquote>
<p>左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。</p>
</blockquote>
<p>   一般来说，<strong>左值是可以放到赋值符号左边的变量</strong>。但</p>
<blockquote>
<p>能否被赋值不是区分左值与右值的依据。比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。<strong>左值与右值的根本区别在于是否允许取地址&amp;运算符获得对应的内存地址。</strong></p>
</blockquote>
<p>   <code>i++</code>的字节码表示为：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">37</span>: lload         <span class="number">9</span></span><br><span class="line">  <span class="number">39</span>: dup2 <span class="comment">//复制栈顶数据并压入栈顶，此时压入为i</span></span><br><span class="line">  <span class="number">40</span>: lconst_1</span><br><span class="line">  <span class="number">41</span>: ladd</span><br><span class="line">  <span class="number">42</span>: lstore        <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>   <code>++i</code>的字节码表示为：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">37</span>: lload         <span class="number">9</span></span><br><span class="line"><span class="number">39</span>: lconst_1</span><br><span class="line"><span class="number">40</span>: ladd</span><br><span class="line"><span class="number">41</span>: dup2  <span class="comment">//复制栈顶数据并压入栈顶，此时压入为i+1</span></span><br><span class="line"><span class="number">42</span>: lstore        <span class="number">9</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>Boolean</code>在数组中占到了一个字节，在单独变量中等价于<code>int</code>占用了4个字节。</p>
</li>
<li><p><code>快速失败(fast-fail)</code>与<code>安全失败(safe-fail)</code>的概念</p>
<p><code>快速失败</code>：迭代器遍历集合时，在过程中对集合的内容进行了修改（增加、删除、修改），则会抛出<code>ConcurrentModificationException</code></p>
<p>因为遍历过程中会使用一个<code>modCount</code>变量，遍历期间如果内容发生了变化，<code>modCount</code>会发生改变，迭代器在执行<code>hasNext()/next()</code>时，都会检测该值是否发生变化，发生变化则终止遍历并抛出异常。</p>
<p><code>java.util</code>下的类都是<code>快速失败</code>的！</p>
<p><code>安全失败</code>：迭代器遍历的不是原有集合，而是原有集合的复制集合</p>
<p>因为遍历的是复制集合，所以遍历期间原有集合发生变化不会影响到遍历过程，就不会触发异常抛出。<strong>由于遍历的是复制集合，导致遍历时无法获取最新的修改。</strong></p>
<p><code>java.util.concurrent</code>下的类都是<code>安全失败</code>的！</p>
</li>
<li><p><code>Class.forName()</code>与<code>ClassLoader.class</code>的区别</p>
<p><code>Class.forName()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String name, /*要加载的Class名字*/</span><br><span class="line">										 boolean initialize,/*是否需要初始化-调用静态代码快及静态变量初始化*/</span><br><span class="line">                               ClassLoader loader/*指定ClassLoader进行加载*/)</span><br></pre></td></tr></table></figure>
<p>执行时默认会调用静态代码块<code>static{...}</code>，以及分配静态变量存储空间</p>
<p><code>ClassLoader.loadClass()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br></pre></td></tr></table></figure>
<p>执行时不会对类进行初始化，只是将类加载到了虚拟机中。</p>
</li>
<li><p>TODO</p>
</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leo-Wxy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://leo-wxy.github.io/2018/04/03/日常细节记录/">https://leo-wxy.github.io/2018/04/03/日常细节记录/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://leo-wxy.github.io">Wxy的个人博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/04/03/Gradle操作小记/"><i class="fa fa-chevron-left">  </i><span>Gradle操作小记</span></a></div><div class="next-post pull-right"><a href="/2018/04/01/Activity-Window-View的关联与理解/"><span>Activity,Window,View的关联与理解</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Leo-Wxy</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>