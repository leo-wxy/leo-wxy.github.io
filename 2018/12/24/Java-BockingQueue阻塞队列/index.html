

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Java-BockingQueue阻塞队列 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/solarized-light.min.css">
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
                Java-BockingQueue阻塞队列
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-12-24 15:16" pubdate>
        2018年12月24日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      62
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Java-BockingQueue阻塞队列</h1>
            
            <div class="markdown-body" id="post-body">
              <h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p><code>Queue队列</code>的特征是<code>FIFO——先进先出</code>。只有队尾可以进行插入操作，只有队头可以进行删除操作。</p>
<p><img src="/images/822721-20200318104019498-382557009.png" srcset="/img/loading.gif" alt="img"></p>
<p>Java中的<code>Queue</code>继承了<code>Collection</code>接口，并额外实现了以下方法</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>; 
  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;
  <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>
<h3 id="队列插入数据操作-add-offer"><a href="#队列插入数据操作-add-offer" class="headerlink" title="队列插入数据操作(add/offer)"></a>队列插入数据操作(<code>add/offer</code>)</h3><blockquote>
<p>将新数据插入队尾</p>
</blockquote>
<p><code>add</code>：如果队列满时，插入队尾数据，就会抛出<code>IllegalStateExecption</code></p>
<p><code>offer</code>：如果队列满时，插入队尾数据，不会抛出异常，会返回<code>false</code></p>
<h3 id="队列删除数据操作-remove-poll"><a href="#队列删除数据操作-remove-poll" class="headerlink" title="队列删除数据操作(remove/poll)"></a>队列删除数据操作(<code>remove/poll</code>)</h3><blockquote>
<p>获取队头元素并删除</p>
</blockquote>
<p><code>remove</code>：当队列为空时，删除元素时，会抛出<code>NoSuchElementException</code></p>
<p><code>poll</code>：当队列为空时，删除元素时，不会抛出异常，只会返回<code>null</code></p>
<h3 id="队列检查数据操作-element-peek"><a href="#队列检查数据操作-element-peek" class="headerlink" title="队列检查数据操作(element/peek)"></a>队列检查数据操作(<code>element/peek</code>)</h3><blockquote>
<p>获取队头元素但并不删除</p>
</blockquote>
<p><code>element</code>：当队列为空时，获取队头元素，会抛出<code>NoSuchElementException</code></p>
<p><code>peek</code>：当队列为空时，获取队头元素，不会抛出异常，只会返回<code>null</code></p>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td><code>add()</code></td>
<td><code>offer()</code> 返回 <code>false</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>remove()</code></td>
<td><code>poll()</code> 返回<code>null</code></td>
</tr>
<tr>
<td>获取数据(检查)</td>
<td><code>element()</code></td>
<td><code>peek()</code> 返回<code>null</code></td>
</tr>
</tbody>
</table>
<h2 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h2><p><strong>系统提供的用于多线程环境下存、取共享变量的一种容器。</strong></p>
<p><code>BlockingQueue阻塞队列</code>实现了<code>Queue接口</code>，相比于<code>Queue</code>提供了额外的功能：</p>
<ul>
<li>获取队头元素时，如果队列为空，执行线程会处于阻塞状态，直到队列非空——<code>对应删除和检查操作</code></li>
<li>添加队尾元素时，如果队列已满，执行线程会处于阻塞状态，直到队列不满——<code>对应插入操作</code></li>
</ul>
<p>当触发上述两种情况的出现时，按照不同的设置方式，提供了以下几种处理方案：</p>
<ul>
<li>抛出异常</li>
<li>返回特殊值(返回<code>null</code>或<code>false</code>)</li>
<li>阻塞当前线程直到可以执行</li>
<li>阻塞线程设置最大超时时间，若超过该时间，线程就会继续执行，放弃当次操作</li>
</ul>
<h3 id="阻塞队列插入数据操作-put-offer-time"><a href="#阻塞队列插入数据操作-put-offer-time" class="headerlink" title="阻塞队列插入数据操作(put/offer(time))"></a>阻塞队列插入数据操作(<code>put/offer(time)</code>)</h3><blockquote>
<p>对应阻塞队列在队列已满插入数据时的<code>阻塞</code>或者<code>超时处理</code></p>
</blockquote>
<p><code>put</code>：如果队列满时，插入队尾数据，会阻塞当前线程<code>直到队列非满</code></p>
<p><code>offer(time)</code>：如果队列满时，插入队尾数据，会阻塞当前线程<code>直到队列非满或者达到了超时时间</code>,达到超时时间则返回<code>false</code></p>
<h3 id="阻塞队列删除数据操作-take-poll-time"><a href="#阻塞队列删除数据操作-take-poll-time" class="headerlink" title="阻塞队列删除数据操作(take()/poll(time))"></a>阻塞队列删除数据操作(<code>take()/poll(time)</code>)</h3><blockquote>
<p>对应阻塞队列在队列为空时获取数据时的<code>阻塞</code>或<code>超时处理</code></p>
</blockquote>
<p><code>take()</code>：当队列为空时，删除元素时，会阻塞当前线程<code>直到队列非空</code></p>
<p><code>poll(time)</code>：当队列为空时，删除元素时，会阻塞当前线程<code>直到队列非空或者达到了超时时间</code>，达到超时时间返回<code>null</code></p>
<h3 id="阻塞队列检查数据操作"><a href="#阻塞队列检查数据操作" class="headerlink" title="阻塞队列检查数据操作"></a><del>阻塞队列检查数据操作</del></h3><table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td><code>add()</code></td>
<td><code>offer()</code> 返回 <code>false</code></td>
<td><code>put()</code></td>
<td><code>offer(time)</code>返回<code>false</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>remove()</code></td>
<td><code>poll()</code> 返回<code>null</code></td>
<td><code>take()</code></td>
<td><code>poll(time)</code>返回<code>null</code></td>
</tr>
<tr>
<td>获取数据(检查)</td>
<td><code>element()</code></td>
<td><code>peek()</code> 返回<code>null</code></td>
<td>/</td>
<td>/</td>
</tr>
</tbody>
</table>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>阻塞队列无法插入<code>null</code>，否则抛出空指针异常</li>
<li>可以访问阻塞队列中的任意元素，尽量避免使用<code>remove(object)</code>移除对象</li>
</ol>
<h2 id="BlockingQueue实现类"><a href="#BlockingQueue实现类" class="headerlink" title="BlockingQueue实现类"></a><code>BlockingQueue</code>实现类</h2><p>在<a href="/2019/09/13/Java-线程池/" title="Java-线程池">Java-线程池</a>中的<code>workQueue</code>设置的就是<code>BlockingQueue</code>接口的实现类，</p>
<p>例如</p>
<ul>
<li><code>ArrayBlockingQueue</code>：数组构成的有界阻塞队列</li>
<li><code>LinkedBlockingQueue</code>：链表构成的有界阻塞队列，如果不设置大小的话，近似<code>无界阻塞队列</code></li>
<li><code>SynchronousQueue</code>：不存储任何元素的阻塞队列</li>
<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列</li>
</ul>
<h2 id="BlockingQueue原理"><a href="#BlockingQueue原理" class="headerlink" title="BlockingQueue原理"></a><code>BlockingQueue</code>原理</h2><p><code>BlockingQueue</code>只是一个接口，真正的实现都是在<code>XXBloxckingQueue</code>中的，想要分析对应的原理就需要从实现类进行分析</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><code>ArrayBlockingQueue</code></h4><blockquote>
<p>由数组实现的有界阻塞队列，大小一旦确定就无法改变队列的长度。</p>
</blockquote>
<h5 id="关键成员变量"><a href="#关键成员变量" class="headerlink" title="关键成员变量"></a>关键成员变量</h5><pre><code class="hljs java"><span class="hljs-comment">/** The queued items 维护队列元素的数组*/</span>
<span class="hljs-keyword">final</span> Object[] items; 

<span class="hljs-comment">/** items index for next take, poll, peek or remove 移除数据的数组下标*/</span>
<span class="hljs-keyword">int</span> takeIndex;

<span class="hljs-comment">/** items index for next put, offer, or add 插入数据的数组下标*/</span>
<span class="hljs-keyword">int</span> putIndex;

<span class="hljs-comment">/** Number of elements in the queue 数组长度*/</span>
<span class="hljs-keyword">int</span> count;

<span class="hljs-comment">/** Main lock guarding all access 数据并发控制类*/</span>
<span class="hljs-keyword">final</span> ReentrantLock lock;

<span class="hljs-comment">/** Condition for waiting takes 控制take操作是否让线程等待*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;

<span class="hljs-comment">/** Condition for waiting puts 控制put操作是否让线程等待*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;</code></pre>
<p><code>ArrayBlockingQueue</code>阻塞功能的实现就是依赖了<code>ReentrantLock</code>以及<code>Condition</code>实现了<code>等待机制</code>。</p>
<p>具体可参考<a href="/2018/12/19/Java-ReenTrantLock/" title="Java-ReentrantLock">Java-ReentrantLock</a></p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;
        <span class="hljs-keyword">this</span>(capacity, <span class="hljs-keyword">false</span>);
    &#125;    

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();
        <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> Object[capacity];
        lock = <span class="hljs-keyword">new</span> ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    &#125;</code></pre>
<p><code>capacity</code>：设置阻塞队列的数组容量</p>
<p><code>fair</code>：设置线程并发是否公平(<code>默认配置非公平锁</code>)</p>
<blockquote>
<p>当前锁被一个线程持有时，其他线程会被挂起等待锁的释放，等待时加入等待队列。</p>
<p><code>公平锁</code>：当锁释放时，等待队列的前端线程会优先获取锁</p>
<p><code>非公平锁</code>：当锁释放时，等待队列中的所有线程都会去尝试获取锁</p>
</blockquote>
<p>在<code>ArrayBlockingQueue</code>初始化时，构造<code>ReentrantLock</code>锁以及两个<code>Condition</code>对象控制数据插入、删除时的阻塞。</p>
<h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p><code>offer()</code> 非阻塞添加数据</p>
<pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;
        Objects.requireNonNull(e);<span class="hljs-comment">//检查将要添加的数据是否为null</span>
        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
        lock.lock();<span class="hljs-comment">//上锁</span>
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span> (count == items.length)<span class="hljs-comment">//队列已满</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">else</span> &#123;
                enqueue(e);<span class="hljs-comment">//数据加入队列</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            &#125;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            lock.unlock();<span class="hljs-comment">//解锁</span>
        &#125;
    &#125;

<span class="hljs-comment">//数据入队</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E x)</span> </span>&#123;
        <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span>
        <span class="hljs-comment">// assert items[putIndex] == null;</span>
        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;
        items[putIndex] = x;<span class="hljs-comment">//数组赋值</span>
        <span class="hljs-comment">//如果此时放入的是最后一个下标的数据，重置下标为0，下一次从第一个开始放元素</span>
        <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;
        count++;
        notEmpty.signal();<span class="hljs-comment">//通知 数组非空 </span>
    &#125;</code></pre>
<p><code>offer()</code>添加数据时，将当前线程上锁。</p>
<ul>
<li>在当前队列已满时，直接返回<code>false</code></li>
<li>当前队列未满时，调用<code>enqueue()</code>添加数据，<code>putIndex</code>设置对应数据且<code>putIndex++</code>。 然后通知阻塞的消费线程<code>notEmpty</code></li>
</ul>
<p><code>poll()</code> 非阻塞取出数据</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    lock.lock();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">return</span> (count == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">null</span> : dequeue();<span class="hljs-comment">//当前队列非空 取出数据</span>
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span>
    <span class="hljs-comment">// assert items[takeIndex] != null;</span>
    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
    E x = (E) items[takeIndex];
    items[takeIndex] = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">//如果此时取出的是最后一个下标的数据，重置下标为0，下一次从第一个开始取出元素</span>
    <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="hljs-number">0</span>;
    count--;
    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-keyword">null</span>)
        itrs.elementDequeued();<span class="hljs-comment">//数据迭代减少，保证遍历线程安全</span>
    notFull.signal();<span class="hljs-comment">//通知 数组不满</span>
    <span class="hljs-keyword">return</span> x;
&#125;</code></pre>
<p><code>poll()</code>取出数据时，将当前线程上锁</p>
<ul>
<li>当前队列为空的时候，直接返回null</li>
<li>当前队列非空的时候，调用<code>dequeue()</code>将<code>takeIndex</code>元素出队，设置<code>takeIndex</code>处元素为<code>null</code>且<code>takeIndex--</code>。然后通知阻塞的生产线程<code>notFull</code></li>
</ul>
<p><code>offer(time)</code>不超时阻塞添加数据</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span>
    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;

    Objects.requireNonNull(e);
    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    lock.lockInterruptibly();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">while</span> (count == items.length) &#123;
            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            nanos = notFull.awaitNanos(nanos);
        &#125;
        enqueue(e);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre>
<p><code>offer(time)</code>添加数据时，将当前线程上锁</p>
<ul>
<li>在当前队列已满时，阻塞生产线程<code>notFull</code>，超过<code>time</code>后，队列还是满的话，直接返回<code>false</code></li>
<li>当前队列未满时，调用<code>enqueue()</code>添加数据，<code>putIndex</code>设置对应数据且<code>putIndex++</code>。 然后通知阻塞的消费者<code>notEmpty</code></li>
</ul>
<p><code>poll(time)</code>不超时阻塞取出数据</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    lock.lockInterruptibly();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
            nanos = notEmpty.awaitNanos(nanos);
        &#125;
        <span class="hljs-keyword">return</span> dequeue();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre>
<p><code>poll(time)</code>取出数据时，将当前线程上锁</p>
<ul>
<li>当前队列为空的时候，阻塞消费线程<code>notEmpty</code>，超过<code>time</code>后，队列还是空的话，直接返回<code>null</code></li>
<li>当前队列非空的时候，调用<code>dequeue()</code>将<code>takeIndex</code>元素出队，设置<code>takeIndex</code>处元素为<code>null</code>且<code>takeIndex--</code>。然后通知阻塞的生产者<code>notFull</code></li>
</ul>
<h6 id="put-阻塞添加数据"><a href="#put-阻塞添加数据" class="headerlink" title="put()阻塞添加数据"></a><code>put()</code>阻塞添加数据</h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    Objects.requireNonNull(e);
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    lock.lockInterruptibly();<span class="hljs-comment">//生产者线程上锁</span>
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">while</span> (count == items.length)
            notFull.await();<span class="hljs-comment">//等待消费者线程通知</span>
        enqueue(e);
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre>
<p><code>put()</code>添加数据时</p>
<ul>
<li>当前队列已满时，阻塞当前线程，等待<code>notFull</code>通知(<code>队列未满</code>)</li>
<li>当前队列未满时，调用<code>enqueue()</code>添加数据，<code>putIndex</code>设置对应数据且<code>putIndex++</code>。 然后通知阻塞的消费者<code>notEmpty</code></li>
</ul>
<h6 id="take-阻塞获取数据"><a href="#take-阻塞获取数据" class="headerlink" title="take()阻塞获取数据"></a><code>take()</code>阻塞获取数据</h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;
    lock.lockInterruptibly();<span class="hljs-comment">//消费者线程上锁</span>
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)
            notEmpty.await();<span class="hljs-comment">//等待生产者线程通知</span>
        <span class="hljs-keyword">return</span> dequeue();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        lock.unlock();
    &#125;
&#125;</code></pre>
<p><code>take()</code>获取数据时</p>
<ul>
<li>当前队列为空时，阻塞当前线程，等待<code>notEmpty</code>通知(<code>队列新增数据</code>)</li>
<li>当前队列非空的时候，调用<code>dequeue()</code>将<code>takeIndex</code>元素出队，设置<code>takeIndex</code>处元素为<code>null</code>且<code>takeIndex--</code>。然后通知阻塞的生产者<code>notFull</code></li>
</ul>
<p>其中<code>Condition</code>的<code>await/signal</code>类似于<code>Object</code>的<code>wait/notify</code>实现等待与通知的功能。</p>
<p>在分析<code>enqueue()</code>和<code>dequeue()</code>时，发现底层数组不会进行扩容，而是在到达边缘时，重置<code>index</code>为0，重复利用数组。</p>
<p><img src="/images/ArrayBlockingQueue循环数组.jpg" srcset="/img/loading.gif" alt="ArrayBlockingQueue循环数组"></p>
<p>从上述源码对<code>ArrayBlockingQueue</code>进行总结：</p>
<p><strong>底层数据结构是一个 数组，生产者和消费者由同一个锁(<code>ReetrantLock</code>)控制，生产和消费效率低。</strong></p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><blockquote>
<p>由链表实现的阻塞队列，默认最大长度为<code>Integer.MAX</code>。</p>
</blockquote>
<h5 id="关键成员变量-1"><a href="#关键成员变量-1" class="headerlink" title="关键成员变量"></a>关键成员变量</h5><pre><code class="hljs java"><span class="hljs-comment">/** The capacity bound, or Integer.MAX_VALUE if none 链表最大长度*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;

<span class="hljs-comment">/** Current number of elements 当前元素个数*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger();

<span class="hljs-comment">/**
 * Head of linked list.
 * Invariant: head.item == null
 * 链表头节点
 */</span>
<span class="hljs-keyword">transient</span> Node&lt;E&gt; head;

<span class="hljs-comment">/**
 * Tail of linked list.
 * Invariant: last.next == null
 * 链表尾节点
 */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;

<span class="hljs-comment">/** Lock held by take, poll, etc 控制消费并发*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();

<span class="hljs-comment">/** Wait queue for waiting takes 控制take线程等待 非空条件*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = takeLock.newCondition();

<span class="hljs-comment">/** Lock held by put, offer, etc 控制生产并发*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();

<span class="hljs-comment">/** Wait queue for waiting puts 控制put线程等待 非满条件*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = putLock.newCondition();</code></pre>
<p><code>LinkedBlockingQueue</code>采用了两把锁<code>putLock、takeLock</code>，分别进行控制，提高了并发性能。</p>
<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedBlockingQueue</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">this</span>(Integer.MAX_VALUE);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();
    <span class="hljs-keyword">this</span>.capacity = capacity;
    last = head = <span class="hljs-keyword">new</span> Node&lt;E&gt;(<span class="hljs-keyword">null</span>);
&#125;</code></pre>
<p><code>capacity</code>：设置单链表长度上限，若不设置该值，默认为<code>Integer.MAX</code></p>
<p>构造函数初始化了底层的链表结构。</p>
<h5 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h5><p><code>offer()</code>非阻塞添加数据</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;
    <span class="hljs-keyword">if</span> (count.get() == capacity) <span class="hljs-comment">//达到上限直接返回false</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;
    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);
    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;
    putLock.lock();<span class="hljs-comment">//线程上锁</span>
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">if</span> (count.get() &lt; capacity) &#123;
            enqueue(node);<span class="hljs-comment">//插入链表</span>
            c = count.getAndIncrement();
            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)
                notFull.signal();<span class="hljs-comment">//唤醒 等待的入队线程</span>
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        putLock.unlock();
    &#125;
    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)
        signalNotEmpty();<span class="hljs-comment">//唤醒等待的 出队线程</span>
    <span class="hljs-keyword">return</span> c &gt;= <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> </span>&#123;
    <span class="hljs-comment">// assert putLock.isHeldByCurrentThread();</span>
    <span class="hljs-comment">// assert last.next == null;</span>
    last = last.next = node;<span class="hljs-comment">//赋值操作</span>
&#125;</code></pre>
<p><code>offer</code>添加数据时，当队列已满时，直接返回<code>false</code>。未满时，插入新数据后，<code>count</code>自加后唤醒<code>notFull、notEmpty</code>。</p>
<p><code>poll()</code>非阻塞获取数据</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;
    <span class="hljs-keyword">if</span> (count.get() == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//队列为空返回null</span>
    E x = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;
    takeLock.lock();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">if</span> (count.get() &gt; <span class="hljs-number">0</span>) &#123;
            x = dequeue();<span class="hljs-comment">//出队</span>
            c = count.getAndDecrement();
            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)
                notEmpty.signal();<span class="hljs-comment">//通知非空线程</span>
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        takeLock.unlock();
    &#125;
    <span class="hljs-keyword">if</span> (c == capacity)
        signalNotFull();<span class="hljs-comment">//通知非满线程</span>
    <span class="hljs-keyword">return</span> x;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">// assert takeLock.isHeldByCurrentThread();</span>
    <span class="hljs-comment">// assert head.item == null;</span>
    Node&lt;E&gt; h = head;
    Node&lt;E&gt; first = h.next;
    h.next = h; <span class="hljs-comment">// help GC</span>
    head = first;
    E x = first.item;
    first.item = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">return</span> x;
&#125;</code></pre>
<p><code>poll</code>获取数据时，队列为空时，直接返回<code>null</code>。队列非空时，获取数据后，数据出队，<code>count</code>自减后，先后唤醒<code>notEmpty</code>、<code>notFull</code>。</p>
<h6 id="put-阻塞添加数据-1"><a href="#put-阻塞添加数据-1" class="headerlink" title="put()阻塞添加数据"></a><code>put()</code>阻塞添加数据</h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-comment">// Note: convention in all put/take/etc is to preset local var</span>
    <span class="hljs-comment">// holding count negative to indicate failure unless set.</span>
    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;
    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);
    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;
    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;
    putLock.lockInterruptibly();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;
            notFull.await();<span class="hljs-comment">//队列已满时，等待非满通知</span>
        &#125;
        enqueue(node);<span class="hljs-comment">//插入新数据</span>
        c = count.getAndIncrement();<span class="hljs-comment">//数据自增</span>
        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)
            notFull.signal();<span class="hljs-comment">//通知非满线程</span>
    &#125; <span class="hljs-keyword">finally</span> &#123;
        putLock.unlock();
    &#125;
    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)
        signalNotEmpty();<span class="hljs-comment">//通知非空线程</span>
&#125;</code></pre>
<p><code>put()</code>添加数据时，队列已满时，会进行阻塞等待直到队列非满。</p>
<h6 id="take-阻塞获取数据-1"><a href="#take-阻塞获取数据-1" class="headerlink" title="take()阻塞获取数据"></a><code>take()</code>阻塞获取数据</h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    E x;
    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;
    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;
    takeLock.lockInterruptibly();
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;
            notEmpty.await();<span class="hljs-comment">//队列为空时，等待非空通知</span>
        &#125;
        x = dequeue();<span class="hljs-comment">//出队</span>
        c = count.getAndDecrement();
        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)
            notEmpty.signal();<span class="hljs-comment">//通知非空线程</span>
    &#125; <span class="hljs-keyword">finally</span> &#123;
        takeLock.unlock();
    &#125;
    <span class="hljs-keyword">if</span> (c == capacity)
        signalNotFull();<span class="hljs-comment">//通知非满线程</span>
    <span class="hljs-keyword">return</span> x;
&#125;</code></pre>
<p><code>take()</code>获取数据时，队列为空时，会进行阻塞等到直到队列非空。</p>
<p><img src="/images/v2-8bc04760ad1133e7630717dbc38c1cc7_1440w.jpg" srcset="/img/loading.gif" alt="img"></p>
<p>从上述源码对<code>LinkedBlockingQueue</code>进行总结：</p>
<p><strong><code>LinkedBlockingQueue</code>底层数据结构为<code>单链表</code>，内部持有两个<code>Lock：putLock、takeLock</code>，相互之间不会干扰执行，提高了并发性能。</strong></p>
<h5 id="与ArrayBlockingQueue比较"><a href="#与ArrayBlockingQueue比较" class="headerlink" title="与ArrayBlockingQueue比较"></a>与<code>ArrayBlockingQueue</code>比较</h5><table>
<thead>
<tr>
<th></th>
<th>ArrayBlockingQueue</th>
<th>LinkedBlockingQueue</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造方法</td>
<td>必须指定构造大小<br>指定后无法修改</td>
<td>默认大小为<code>Integer.MAX</code><br>可以指定大小</td>
</tr>
<tr>
<td>底层数据结构</td>
<td>数组</td>
<td>单链表</td>
</tr>
<tr>
<td>锁</td>
<td>出队入队使用同一把锁<br>数据的删除和添加操作互斥</td>
<td>出队使用<code>takeLock</code>，入队使用<code>putLock</code><br>数据删除、添加操作不干扰，提升并发性能</td>
</tr>
</tbody>
</table>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><blockquote>
<p>容量为0，无法储存数据的阻塞队列。提供了公平与非公平锁的设置。</p>
</blockquote>
<h5 id="关键成员变量-2"><a href="#关键成员变量-2" class="headerlink" title="关键成员变量"></a>关键成员变量</h5><pre><code class="hljs java"><span class="hljs-comment">//针对不同操作定义的统一接口</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Transferer&lt;E&gt; transferer;

    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transferer</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;
       <span class="hljs-comment">//e为空则表示 需要获取数据；e不为空表示 需要添加数据</span>
        <span class="hljs-function"><span class="hljs-keyword">abstract</span> E <span class="hljs-title">transfer</span><span class="hljs-params">(E e, <span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos)</span></span>;
    &#125;</code></pre>
<h5 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynchronousQueue</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//默认非公平构造</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynchronousQueue</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;
    <span class="hljs-comment">//公平与非公平对应两种实现形式</span>
    transferer = fair ? <span class="hljs-keyword">new</span> TransferQueue&lt;E&gt;() : <span class="hljs-keyword">new</span> TransferStack&lt;E&gt;();
&#125;</code></pre>
<h5 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h5><p>数据操作<code>offer()/poll() put()/take()</code></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-keyword">return</span> transferer.transfer(e, <span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>) != <span class="hljs-keyword">null</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> transferer.transfer(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-keyword">if</span> (transferer.transfer(e, <span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">null</span>) &#123;
        Thread.interrupted();
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
    E e = transferer.transfer(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">return</span> e;
    Thread.interrupted();
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
&#125;</code></pre>
<p>上述的数据操作方法都涉及到了两部分内容：</p>
<ul>
<li><code>transferer</code>：数据调度</li>
<li><code>transfer</code>：数据执行</li>
</ul>
<h6 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h6><blockquote>
<p><code>SynchronousQueue</code>的<strong>公平</strong>实现，内部实现使用队列，可以保证先进先出的特性。</p>
</blockquote>
<p>基本实现方法：</p>
<p>当前队列为空的时候或者存在了与当前操作模式相同(<code>isData</code>一致)的节点。线程进行同步等待，尝试封装一个<code>QNode</code>节点，添加到队列中；然后等待与当前操作互补的操作发生（<code>写操作(isData = true)，等待一个读操作(isData = false)</code>）并且返回节点的元素。</p>
<p>如果队列中包含了与当前操作互补的等待节点，尝试通过<code>CAS</code>更新等待节点的item字段，然后让等待节点出队列。</p>
<p>如果队列中的节点的<code>waiter</code>等待线程被取消，节点也会被清理出队列。</p>
<p><img src="/images/TransferQueue.jpg" srcset="/img/loading.gif" alt="TransferQueue公平队列"></p>
<p><code>isData</code>：true 表示<code>put</code>操作，false表示<code>take</code>操作。</p>
<p><code>next</code>：下一个节点</p>
<p><code>waiter</code>：当前等待的线程</p>
<p><code>item</code>：元素信息</p>
<h6 id="TransferStack"><a href="#TransferStack" class="headerlink" title="TransferStack"></a>TransferStack</h6><blockquote>
<p><code>SynchronousQueue</code>非公平实现，内部实现使用<strong>栈</strong>，实现了<code>先进后出</code>的特性。</p>
</blockquote>
<p>基本实现方法：</p>
<p>如果栈为空或者栈中包含了相同模式的节点(<code>mode</code>一致)，尝试将节点推入栈中，然后一直等待，等到与之匹配的节点(<code>mode= Data 和 mode = Request</code> )出现，最后返回。</p>
<p>栈中若包含了与当前模式互补的节点，尝试将当前线程作为满足匹配的新节点入栈，与栈中等待的节点进行匹配。匹配完成之后，将这一对节点弹出，然后返回匹配节点的内容。</p>
<p>如果栈顶元素找到匹配节点，就会继续匹配，在匹配完成后弹出栈，接着进行匹配。</p>
<p><img src="/images/TransferStack.jpg" srcset="/img/loading.gif" alt="TranferStack"></p>
<p><code>next</code>：下一个元素</p>
<p><code>item</code>：元素信息</p>
<p><code>waiter</code>：当前等待的线程</p>
<p><code>match</code>：匹配的节点</p>
<p><code>mode</code>：<code>DATA(1)</code>-添加数据、<code>REQUEST(0)</code>-获取数据、<code>FULFILLING(2)</code>-互补模式</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li><code>SynchronousQueue</code>容量为0，无法进行数据存储</li>
<li>每次写入数据时，写线程都需要等待；直到另一个线程执行读操作，写线程会返回数据。<em>写入元素不能为null</em></li>
<li><code>peek()</code>返回<code>null</code>；<code>size()</code>返回<code>0</code>；无法进行迭代操作</li>
<li>提供了<code>公平</code>，<code>非公平</code>两种策略处理，分别是基于<code>Queue-TransferQueue</code>与<code>Stack-TransferStack</code>实现。</li>
</ul>
<h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><p>绝大多数都是利用了<strong>Lock锁的多条件(Condition)阻塞控制</strong>。</p>
<p>拿<code>ArrayBlockigQueue</code>进行简单描述就是：</p>
<ol>
<li><code>put</code>和<code>take</code>操作都需要先<strong>获取锁</strong>，无法获取的话就要一直自旋拿锁，直到获取锁为止</li>
<li>在拿到锁以后。还需要判断当前队列是否可用(<code>队列非满且非空</code>)，如果队列不可用就会被阻塞，并<strong>释放锁</strong></li>
<li>阻塞的线程被唤醒时，依然需要在拿到锁之后才可以继续执行，否则，自旋拿锁，拿到锁继续判断当前队列是否可用(<strong>使用while判断</strong>)</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h5 id="生产-消费模型"><a href="#生产-消费模型" class="headerlink" title="生产-消费模型"></a>生产-消费模型</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCDemo</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> queueSize = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(queueSize, <span class="hljs-keyword">true</span>);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        PCDemo blockQueue = <span class="hljs-keyword">new</span> PCDemo();
        Producter producter = blockQueue.new Producter();
        Customer customer = blockQueue.new Customer();

        producter.start();
        customer.start();
    &#125;

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    queue.take();
                    System.err.println(<span class="hljs-string">"消费哦，剩余空间为"</span> + queue.size());
                    Thread.sleep(<span class="hljs-number">100</span>);
                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
                <span class="hljs-keyword">try</span> &#123;
                    queue.put(<span class="hljs-number">1</span>);
                    System.err.println(<span class="hljs-string">"生产哦，剩余空间为"</span> + (queueSize - queue.size()));
                    Thread.sleep(<span class="hljs-number">100</span>);
                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><a href="/2019/09/13/Java-线程池/" title="Java-线程池">Java-线程池</a>
<h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><h3 id="Guarded-Suspension（保护性暂时挂起）"><a href="#Guarded-Suspension（保护性暂时挂起）" class="headerlink" title="Guarded Suspension（保护性暂时挂起）"></a>Guarded Suspension（保护性暂时挂起）</h3><p><strong>当服务进程准备好时，才提供服务。</strong></p>
<p><img src="/images/java-concurrent-guarded-suspension.png" srcset="/img/loading.gif" alt="img"></p>
<p>本质是一种<strong>等待唤醒机制的实现</strong>，也称为<strong>多线程的if</strong></p>
<p>基本实现代码</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;
  <span class="hljs-keyword">private</span> T obj;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReetrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition done = lock.newCondition();
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(Predicate&lt;T&gt; p)</span></span>&#123;
    lock.lock();
    <span class="hljs-keyword">try</span>&#123;
      <span class="hljs-keyword">while</span>(!p.test(obj))&#123;
        done.await(); <span class="hljs-comment">//等待事件执行</span>
      &#125;
    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
      e.printStacktrace();
    &#125;<span class="hljs-keyword">finally</span>&#123;
      lock.unlock();
    &#125;
    <span class="hljs-keyword">return</span> obj;
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChange</span><span class="hljs-params">(T obj)</span></span>&#123;
    lock.lock();
    <span class="hljs-keyword">try</span>&#123;
      <span class="hljs-keyword">this</span>.obj = obj;
      done.signAll();<span class="hljs-comment">//数据发生变化，进行通知</span>
    &#125;<span class="hljs-keyword">finally</span>&#123;
      lock.unlock();
    &#125;
  &#125;
&#125;</code></pre>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/dwlsxj/archive/2004/01/13/Thread.html" target="_blank" rel="noopener">SynchronousQueue-公平模式</a></p>
<p><a href="https://www.jianshu.com/p/a565b0b25c43" target="_blank" rel="noopener">SynchronousQueue</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/12/24/Android-简单实现Router功能/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android-简单实现Router功能</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/12/21/Android-线程相关/">
                        <span class="hidden-mobile">Android-线程相关</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
