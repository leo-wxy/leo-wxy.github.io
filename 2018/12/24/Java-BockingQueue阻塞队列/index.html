

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Java-BockingQueue阻塞队列 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java-BockingQueue阻塞队列">
              
                Java-BockingQueue阻塞队列
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-12-24 15:16" pubdate>
        2018年12月24日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      62
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java-BockingQueue阻塞队列</h1>
            
            <div class="markdown-body">
              <p><img src="/images/BlockingQueue 阻塞队列xmind.png" srcset="/img/loading.gif" alt="BlockingQueue阻塞队列"></p>
<h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p><code>Queue队列</code>的特征是<code>FIFO——先进先出</code>。只有队尾可以进行插入操作，只有队头可以进行删除操作。</p>
<p><img src="/images/822721-20200318104019498-382557009.png" srcset="/img/loading.gif" alt="img"></p>
<p>Java中的<code>Queue</code>继承了<code>Collection</code>接口，并额外实现了以下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;<br>  <span class="hljs-keyword">boolean</span> add(E e); <br>  <span class="hljs-keyword">boolean</span> offer(E e);<br>  E remove();<br>  E poll();<br>  E element();<br>  E peek();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="队列插入数据操作-add-offer"><a href="#队列插入数据操作-add-offer" class="headerlink" title="队列插入数据操作(add/offer)"></a>队列插入数据操作(<code>add/offer</code>)</h3><blockquote>
<p>将新数据插入队尾</p>
</blockquote>
<p><code>add</code>：如果队列满时，插入队尾数据，就会抛出<code>IllegalStateExecption</code></p>
<p><code>offer</code>：如果队列满时，插入队尾数据，不会抛出异常，会返回<code>false</code></p>
<h3 id="队列删除数据操作-remove-poll"><a href="#队列删除数据操作-remove-poll" class="headerlink" title="队列删除数据操作(remove/poll)"></a>队列删除数据操作(<code>remove/poll</code>)</h3><blockquote>
<p>获取队头元素并删除</p>
</blockquote>
<p><code>remove</code>：当队列为空时，删除元素时，会抛出<code>NoSuchElementException</code></p>
<p><code>poll</code>：当队列为空时，删除元素时，不会抛出异常，只会返回<code>null</code></p>
<h3 id="队列检查数据操作-element-peek"><a href="#队列检查数据操作-element-peek" class="headerlink" title="队列检查数据操作(element/peek)"></a>队列检查数据操作(<code>element/peek</code>)</h3><blockquote>
<p>获取队头元素但并不删除</p>
</blockquote>
<p><code>element</code>：当队列为空时，获取队头元素，会抛出<code>NoSuchElementException</code></p>
<p><code>peek</code>：当队列为空时，获取队头元素，不会抛出异常，只会返回<code>null</code></p>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td><code>add()</code></td>
<td><code>offer()</code> 返回 <code>false</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>remove()</code></td>
<td><code>poll()</code> 返回<code>null</code></td>
</tr>
<tr>
<td>获取数据(检查)</td>
<td><code>element()</code></td>
<td><code>peek()</code> 返回<code>null</code></td>
</tr>
</tbody>
</table>
<h2 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h2><p><strong>系统提供的用于多线程环境下存、取共享变量的一种容器。</strong></p>
<p><code>BlockingQueue阻塞队列</code>实现了<code>Queue接口</code>，相比于<code>Queue</code>提供了额外的功能：</p>
<ul>
<li>获取队头元素时，如果队列为空，执行线程会处于阻塞状态，直到队列非空——<code>对应删除和检查操作</code></li>
<li>添加队尾元素时，如果队列已满，执行线程会处于阻塞状态，直到队列不满——<code>对应插入操作</code></li>
</ul>
<p>当触发上述两种情况的出现时，按照不同的设置方式，提供了以下几种处理方案：</p>
<ul>
<li>抛出异常</li>
<li>返回特殊值(返回<code>null</code>或<code>false</code>)</li>
<li>阻塞当前线程直到可以执行</li>
<li>阻塞线程设置最大超时时间，若超过该时间，线程就会继续执行，放弃当次操作</li>
</ul>
<h3 id="阻塞队列插入数据操作-put-offer-time"><a href="#阻塞队列插入数据操作-put-offer-time" class="headerlink" title="阻塞队列插入数据操作(put/offer(time))"></a>阻塞队列插入数据操作(<code>put/offer(time)</code>)</h3><blockquote>
<p>对应阻塞队列在队列已满插入数据时的<code>阻塞</code>或者<code>超时处理</code></p>
</blockquote>
<p><code>put</code>：如果队列满时，插入队尾数据，会阻塞当前线程<code>直到队列非满</code></p>
<p><code>offer(time)</code>：如果队列满时，插入队尾数据，会阻塞当前线程<code>直到队列非满或者达到了超时时间</code>,达到超时时间则返回<code>false</code></p>
<h3 id="阻塞队列删除数据操作-take-poll-time"><a href="#阻塞队列删除数据操作-take-poll-time" class="headerlink" title="阻塞队列删除数据操作(take()/poll(time))"></a>阻塞队列删除数据操作(<code>take()/poll(time)</code>)</h3><blockquote>
<p>对应阻塞队列在队列为空时获取数据时的<code>阻塞</code>或<code>超时处理</code></p>
</blockquote>
<p><code>take()</code>：当队列为空时，删除元素时，会阻塞当前线程<code>直到队列非空</code></p>
<p><code>poll(time)</code>：当队列为空时，删除元素时，会阻塞当前线程<code>直到队列非空或者达到了超时时间</code>，达到超时时间返回<code>null</code></p>
<h3 id="阻塞队列检查数据操作"><a href="#阻塞队列检查数据操作" class="headerlink" title="阻塞队列检查数据操作"></a><del>阻塞队列检查数据操作</del></h3><table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td><code>add()</code></td>
<td><code>offer()</code> 返回 <code>false</code></td>
<td><code>put()</code></td>
<td><code>offer(time)</code>返回<code>false</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>remove()</code></td>
<td><code>poll()</code> 返回<code>null</code></td>
<td><code>take()</code></td>
<td><code>poll(time)</code>返回<code>null</code></td>
</tr>
<tr>
<td>获取数据(检查)</td>
<td><code>element()</code></td>
<td><code>peek()</code> 返回<code>null</code></td>
<td>/</td>
<td>/</td>
</tr>
</tbody>
</table>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>阻塞队列无法插入<code>null</code>，否则抛出空指针异常</li>
<li>可以访问阻塞队列中的任意元素，尽量避免使用<code>remove(object)</code>移除对象</li>
</ol>
<h2 id="BlockingQueue实现类"><a href="#BlockingQueue实现类" class="headerlink" title="BlockingQueue实现类"></a><code>BlockingQueue</code>实现类</h2><p>在{% post_link Java-线程池%}中的<code>workQueue</code>设置的就是<code>BlockingQueue</code>接口的实现类，</p>
<p>例如</p>
<ul>
<li><code>ArrayBlockingQueue</code>：数组构成的有界阻塞队列</li>
<li><code>LinkedBlockingQueue</code>：链表构成的有界阻塞队列，如果不设置大小的话，近似<code>无界阻塞队列</code></li>
<li><code>SynchronousQueue</code>：不存储任何元素的阻塞队列</li>
<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列</li>
</ul>
<h2 id="BlockingQueue原理"><a href="#BlockingQueue原理" class="headerlink" title="BlockingQueue原理"></a><code>BlockingQueue</code>原理</h2><p><code>BlockingQueue</code>只是一个接口，真正的实现都是在<code>XXBloxckingQueue</code>中的，想要分析对应的原理就需要从实现类进行分析</p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><code>ArrayBlockingQueue</code></h4><blockquote>
<p>由数组实现的有界阻塞队列，大小一旦确定就无法改变队列的长度。</p>
</blockquote>
<h5 id="关键成员变量"><a href="#关键成员变量" class="headerlink" title="关键成员变量"></a>关键成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">/** The queued items 维护队列元素的数组*/<br><span class="hljs-keyword">final</span> Object[] items; <br><br>/** items index <span class="hljs-keyword">for</span> next take, poll, peek or remove 移除数据的数组下标*/<br><span class="hljs-keyword">int</span> takeIndex;<br><br>/** items index <span class="hljs-keyword">for</span> next put, offer, or add 插入数据的数组下标*/<br><span class="hljs-keyword">int</span> putIndex;<br><br>/** Number of elements in the queue 数组长度*/<br><span class="hljs-keyword">int</span> count;<br><br>/** Main lock guarding all access 数据并发控制类*/<br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><br>/** Condition <span class="hljs-keyword">for</span> waiting takes 控制take操作是否让线程等待*/<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br>/** Condition <span class="hljs-keyword">for</span> waiting puts 控制put操作是否让线程等待*/<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br></code></pre></td></tr></table></figure>
<p><code>ArrayBlockingQueue</code>阻塞功能的实现就是依赖了<code>ReentrantLock</code>以及<code>Condition</code>实现了<code>等待机制</code>。</p>
<p>具体可参考</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ArrayBlockingQueue(<span class="hljs-keyword">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>(capacity, <span class="hljs-keyword">false</span>);<br>    &#125;    <br><br><span class="hljs-keyword">public</span> ArrayBlockingQueue(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair) &#123;<br>        <span class="hljs-keyword">if</span> (capacity &lt;= 0)<br>            throw new IllegalArgumentException();<br>        <span class="hljs-keyword">this</span>.items = new Object[capacity];<br>        lock = new ReentrantLock(fair);<br>        notEmpty = lock.newCondition();<br>        notFull =  lock.newCondition();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>capacity</code>：设置阻塞队列的数组容量</p>
<p><code>fair</code>：设置线程并发是否公平(<code>默认配置非公平锁</code>)</p>
<blockquote>
<p>当前锁被一个线程持有时，其他线程会被挂起等待锁的释放，等待时加入等待队列。</p>
<p><code>公平锁</code>：当锁释放时，等待队列的前端线程会优先获取锁</p>
<p><code>非公平锁</code>：当锁释放时，等待队列中的所有线程都会去尝试获取锁</p>
</blockquote>
<p>在<code>ArrayBlockingQueue</code>初始化时，构造<code>ReentrantLock</code>锁以及两个<code>Condition</code>对象控制数据插入、删除时的阻塞。</p>
<h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p><code>offer()</code> 非阻塞添加数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> offer(E e) &#123;<br>        Objects.requireNonNull(e);//检查将要添加的数据是否为<span class="hljs-keyword">null</span><br>        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>        lock.lock();//上锁<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (count == items.length)//队列已满<br>                return <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                enqueue(e);//数据加入队列<br>                return <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();//解锁<br>        &#125;<br>    &#125;<br><br>//数据入队<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> enqueue(E x) &#123;<br>        // <span class="hljs-keyword">assert</span> lock.getHoldCount() == 1;<br>        // <span class="hljs-keyword">assert</span> items[putIndex] == <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;<br>        items[putIndex] = x;//数组赋值<br>        //如果此时放入的是最后一个下标的数据，重置下标为0，下一次从第一个开始放元素<br>        <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = 0;<br>        count++;<br>        notEmpty.signal();//通知 数组非空 <br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>offer()</code>添加数据时，将当前线程上锁。</p>
<ul>
<li>在当前队列已满时，直接返回<code>false</code></li>
<li>当前队列未满时，调用<code>enqueue()</code>添加数据，<code>putIndex</code>设置对应数据且<code>putIndex++</code>。 然后通知阻塞的消费线程<code>notEmpty</code></li>
</ul>
<p><code>poll()</code> 非阻塞取出数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E poll() &#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        return (count == 0) ? <span class="hljs-keyword">null</span> : dequeue();//当前队列非空 取出数据<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> E dequeue() &#123;<br>    // <span class="hljs-keyword">assert</span> lock.getHoldCount() == 1;<br>    // <span class="hljs-keyword">assert</span> items[takeIndex] != <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;<br>    @SuppressWarnings("unchecked")<br>    E x = (E) items[takeIndex];<br>    items[takeIndex] = <span class="hljs-keyword">null</span>;<br>    //如果此时取出的是最后一个下标的数据，重置下标为0，下一次从第一个开始取出元素<br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = 0;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-keyword">null</span>)<br>        itrs.elementDequeued();//数据迭代减少，保证遍历线程安全<br>    notFull.signal();//通知 数组不满<br>    return x;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>poll()</code>取出数据时，将当前线程上锁</p>
<ul>
<li>当前队列为空的时候，直接返回null</li>
<li>当前队列非空的时候，调用<code>dequeue()</code>将<code>takeIndex</code>元素出队，设置<code>takeIndex</code>处元素为<code>null</code>且<code>takeIndex--</code>。然后通知阻塞的生产线程<code>notFull</code></li>
</ul>
<p><code>offer(time)</code>不超时阻塞添加数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> offer(E e, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)<br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    Objects.requireNonNull(e);<br>    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == items.length) &#123;<br>            <span class="hljs-keyword">if</span> (nanos &lt;= 0L)<br>                return <span class="hljs-keyword">false</span>;<br>            nanos = notFull.awaitNanos(nanos);<br>        &#125;<br>        enqueue(e);<br>        return <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>offer(time)</code>添加数据时，将当前线程上锁</p>
<ul>
<li>在当前队列已满时，阻塞生产线程<code>notFull</code>，超过<code>time</code>后，队列还是满的话，直接返回<code>false</code></li>
<li>当前队列未满时，调用<code>enqueue()</code>添加数据，<code>putIndex</code>设置对应数据且<code>putIndex++</code>。 然后通知阻塞的消费者<code>notEmpty</code></li>
</ul>
<p><code>poll(time)</code>不超时阻塞取出数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E poll(<span class="hljs-keyword">long</span> timeout, TimeUnit unit) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == 0) &#123;<br>            <span class="hljs-keyword">if</span> (nanos &lt;= 0L)<br>                return <span class="hljs-keyword">null</span>;<br>            nanos = notEmpty.awaitNanos(nanos);<br>        &#125;<br>        return dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>poll(time)</code>取出数据时，将当前线程上锁</p>
<ul>
<li>当前队列为空的时候，阻塞消费线程<code>notEmpty</code>，超过<code>time</code>后，队列还是空的话，直接返回<code>null</code></li>
<li>当前队列非空的时候，调用<code>dequeue()</code>将<code>takeIndex</code>元素出队，设置<code>takeIndex</code>处元素为<code>null</code>且<code>takeIndex--</code>。然后通知阻塞的生产者<code>notFull</code></li>
</ul>
<h6 id="put-阻塞添加数据"><a href="#put-阻塞添加数据" class="headerlink" title="put()阻塞添加数据"></a><code>put()</code>阻塞添加数据</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> put(E e) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Objects.requireNonNull(e);<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();//生产者线程上锁<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();//等待消费者线程通知<br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>put()</code>添加数据时</p>
<ul>
<li>当前队列已满时，阻塞当前线程，等待<code>notFull</code>通知(<code>队列未满</code>)</li>
<li>当前队列未满时，调用<code>enqueue()</code>添加数据，<code>putIndex</code>设置对应数据且<code>putIndex++</code>。 然后通知阻塞的消费者<code>notEmpty</code></li>
</ul>
<h6 id="take-阻塞获取数据"><a href="#take-阻塞获取数据" class="headerlink" title="take()阻塞获取数据"></a><code>take()</code>阻塞获取数据</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E take() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();//消费者线程上锁<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == 0)<br>            notEmpty.await();//等待生产者线程通知<br>        return dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>take()</code>获取数据时</p>
<ul>
<li>当前队列为空时，阻塞当前线程，等待<code>notEmpty</code>通知(<code>队列新增数据</code>)</li>
<li>当前队列非空的时候，调用<code>dequeue()</code>将<code>takeIndex</code>元素出队，设置<code>takeIndex</code>处元素为<code>null</code>且<code>takeIndex--</code>。然后通知阻塞的生产者<code>notFull</code></li>
</ul>
<p>其中<code>Condition</code>的<code>await/signal</code>类似于<code>Object</code>的<code>wait/notify</code>实现等待与通知的功能。</p>
<p>在分析<code>enqueue()</code>和<code>dequeue()</code>时，发现底层数组不会进行扩容，而是在到达边缘时，重置<code>index</code>为0，重复利用数组。</p>
<p><img src="/images/ArrayBlockingQueue循环数组.jpg" srcset="/img/loading.gif" alt="ArrayBlockingQueue循环数组"></p>
<p>从上述源码对<code>ArrayBlockingQueue</code>进行总结：</p>
<p><strong>底层数据结构是一个 数组，生产者和消费者由同一个锁(<code>ReetrantLock</code>)控制，生产和消费效率低。</strong></p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><blockquote>
<p>由链表实现的阻塞队列，默认最大长度为<code>Integer.MAX</code>。</p>
</blockquote>
<h5 id="关键成员变量-1"><a href="#关键成员变量-1" class="headerlink" title="关键成员变量"></a>关键成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">/** The capacity bound, or Integer.MAX_VALUE <span class="hljs-keyword">if</span> none 链表最大长度*/<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;<br><br>/** Current number of elements 当前元素个数*/<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger count = new AtomicInteger();<br><br>/**<br> * Head of linked list.<br> * Invariant: head.item == <span class="hljs-keyword">null</span><br> * 链表头节点<br> */<br><span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<br><br>/**<br> * Tail of linked list.<br> * Invariant: last.next == <span class="hljs-keyword">null</span><br> * 链表尾节点<br> */<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br>/** Lock held by take, poll, etc 控制消费并发*/<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = new ReentrantLock();<br><br>/** Wait queue <span class="hljs-keyword">for</span> waiting takes 控制take线程等待 非空条件*/<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = takeLock.newCondition();<br><br>/** Lock held by put, offer, etc 控制生产并发*/<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = new ReentrantLock();<br><br>/** Wait queue <span class="hljs-keyword">for</span> waiting puts 控制put线程等待 非满条件*/<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = putLock.newCondition();<br></code></pre></td></tr></table></figure>
<p><code>LinkedBlockingQueue</code>采用了两把锁<code>putLock、takeLock</code>，分别进行控制，提高了并发性能。</p>
<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> LinkedBlockingQueue() &#123;<br>    <span class="hljs-keyword">this</span>(Integer.MAX_VALUE);<br>&#125;<br><br><span class="hljs-keyword">public</span> LinkedBlockingQueue(<span class="hljs-keyword">int</span> capacity) &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= 0) throw new IllegalArgumentException();<br>    <span class="hljs-keyword">this</span>.capacity = capacity;<br>    last = head = new Node&lt;E&gt;(<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>capacity</code>：设置单链表长度上限，若不设置该值，默认为<code>Integer.MAX</code></p>
<p>构造函数初始化了底层的链表结构。</p>
<h5 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h5><p><code>offer()</code>非阻塞添加数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> offer(E e) &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) throw new NullPointerException();<br>    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;<br>    <span class="hljs-keyword">if</span> (count.get() == capacity) //达到上限直接返回<span class="hljs-keyword">false</span><br>        return <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> c = -1;<br>    Node&lt;E&gt; node = new Node&lt;E&gt;(e);<br>    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;<br>    putLock.lock();//线程上锁<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (count.get() &lt; capacity) &#123;<br>            enqueue(node);//插入链表<br>            c = count.getAndIncrement();<br>            <span class="hljs-keyword">if</span> (c + 1 &lt; capacity)<br>                notFull.signal();//唤醒 等待的入队线程<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        putLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == 0)<br>        signalNotEmpty();//唤醒等待的 出队线程<br>    return c &gt;= 0;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> enqueue(Node&lt;E&gt; node) &#123;<br>    // <span class="hljs-keyword">assert</span> putLock.isHeldByCurrentThread();<br>    // <span class="hljs-keyword">assert</span> last.next == <span class="hljs-keyword">null</span>;<br>    last = last.next = node;//赋值操作<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>offer</code>添加数据时，当队列已满时，直接返回<code>false</code>。未满时，插入新数据后，<code>count</code>自加后唤醒<code>notFull、notEmpty</code>。</p>
<p><code>poll()</code>非阻塞获取数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E poll() &#123;<br>    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;<br>    <span class="hljs-keyword">if</span> (count.get() == 0)<br>        return <span class="hljs-keyword">null</span>;//队列为空返回<span class="hljs-keyword">null</span><br>    E x = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> c = -1;<br>    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;<br>    takeLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (count.get() &gt; 0) &#123;<br>            x = dequeue();//出队<br>            c = count.getAndDecrement();<br>            <span class="hljs-keyword">if</span> (c &gt; 1)<br>                notEmpty.signal();//通知非空线程<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        takeLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == capacity)<br>        signalNotFull();//通知非满线程<br>    return x;<br>&#125;<br><br><span class="hljs-keyword">private</span> E dequeue() &#123;<br>    // <span class="hljs-keyword">assert</span> takeLock.isHeldByCurrentThread();<br>    // <span class="hljs-keyword">assert</span> head.item == <span class="hljs-keyword">null</span>;<br>    Node&lt;E&gt; h = head;<br>    Node&lt;E&gt; first = h.next;<br>    h.next = h; // help GC<br>    head = first;<br>    E x = first.item;<br>    first.item = <span class="hljs-keyword">null</span>;<br>    return x;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>poll</code>获取数据时，队列为空时，直接返回<code>null</code>。队列非空时，获取数据后，数据出队，<code>count</code>自减后，先后唤醒<code>notEmpty</code>、<code>notFull</code>。</p>
<h6 id="put-阻塞添加数据-1"><a href="#put-阻塞添加数据-1" class="headerlink" title="put()阻塞添加数据"></a><code>put()</code>阻塞添加数据</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> put(E e) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) throw new NullPointerException();<br>    // Note: convention in all put/take/etc is to preset local var<br>    // holding count negative to indicate failure unless set.<br>    <span class="hljs-keyword">int</span> c = -1;<br>    Node&lt;E&gt; node = new Node&lt;E&gt;(e);<br>    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;<br>    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;<br>    putLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;<br>            notFull.await();//队列已满时，等待非满通知<br>        &#125;<br>        enqueue(node);//插入新数据<br>        c = count.getAndIncrement();//数据自增<br>        <span class="hljs-keyword">if</span> (c + 1 &lt; capacity)<br>            notFull.signal();//通知非满线程<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        putLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == 0)<br>        signalNotEmpty();//通知非空线程<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>put()</code>添加数据时，队列已满时，会进行阻塞等待直到队列非满。</p>
<h6 id="take-阻塞获取数据-1"><a href="#take-阻塞获取数据-1" class="headerlink" title="take()阻塞获取数据"></a><code>take()</code>阻塞获取数据</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E take() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    E x;<br>    <span class="hljs-keyword">int</span> c = -1;<br>    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;<br>    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;<br>    takeLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count.get() == 0) &#123;<br>            notEmpty.await();//队列为空时，等待非空通知<br>        &#125;<br>        x = dequeue();//出队<br>        c = count.getAndDecrement();<br>        <span class="hljs-keyword">if</span> (c &gt; 1)<br>            notEmpty.signal();//通知非空线程<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        takeLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == capacity)<br>        signalNotFull();//通知非满线程<br>    return x;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>take()</code>获取数据时，队列为空时，会进行阻塞等到直到队列非空。</p>
<p><img src="/images/v2-8bc04760ad1133e7630717dbc38c1cc7_1440w.jpg" srcset="/img/loading.gif" alt="img"></p>
<p>从上述源码对<code>LinkedBlockingQueue</code>进行总结：</p>
<p><strong><code>LinkedBlockingQueue</code>底层数据结构为<code>单链表</code>，内部持有两个<code>Lock：putLock、takeLock</code>，相互之间不会干扰执行，提高了并发性能。</strong></p>
<h5 id="与ArrayBlockingQueue比较"><a href="#与ArrayBlockingQueue比较" class="headerlink" title="与ArrayBlockingQueue比较"></a>与<code>ArrayBlockingQueue</code>比较</h5><table>
<thead>
<tr>
<th></th>
<th>ArrayBlockingQueue</th>
<th>LinkedBlockingQueue</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造方法</td>
<td>必须指定构造大小<br>指定后无法修改</td>
<td>默认大小为<code>Integer.MAX</code><br>可以指定大小</td>
</tr>
<tr>
<td>底层数据结构</td>
<td>数组</td>
<td>单链表</td>
</tr>
<tr>
<td>锁</td>
<td>出队入队使用同一把锁<br>数据的删除和添加操作互斥</td>
<td>出队使用<code>takeLock</code>，入队使用<code>putLock</code><br>数据删除、添加操作不干扰，提升并发性能</td>
</tr>
</tbody>
</table>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><blockquote>
<p>容量为0，无法储存数据的阻塞队列。提供了公平与非公平锁的设置。</p>
</blockquote>
<h5 id="关键成员变量-2"><a href="#关键成员变量-2" class="headerlink" title="关键成员变量"></a>关键成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">//针对不同操作定义的统一接口<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Transferer&lt;E&gt; transferer;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> class Transferer&lt;E&gt; &#123;<br>       //e为空则表示 需要获取数据；e不为空表示 需要添加数据<br>        <span class="hljs-keyword">abstract</span> E transfer(E e, <span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SynchronousQueue() &#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">false</span>);//默认非公平构造<br>&#125;<br><br><span class="hljs-keyword">public</span> SynchronousQueue(<span class="hljs-keyword">boolean</span> fair) &#123;<br>    //公平与非公平对应两种实现形式<br>    transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h5><p>数据操作<code>offer()/poll() put()/take()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> offer(E e) &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) throw new NullPointerException();<br>    return transferer.transfer(e, <span class="hljs-keyword">true</span>, 0) != <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> E poll() &#123;<br>    return transferer.transfer(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, 0);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> put(E e) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) throw new NullPointerException();<br>    <span class="hljs-keyword">if</span> (transferer.transfer(e, <span class="hljs-keyword">false</span>, 0) == <span class="hljs-keyword">null</span>) &#123;<br>        Thread.interrupted();<br>        throw new InterruptedException();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> E take() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    E e = transferer.transfer(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, 0);<br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>)<br>        return e;<br>    Thread.interrupted();<br>    throw new InterruptedException();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述的数据操作方法都涉及到了两部分内容：</p>
<ul>
<li><code>transferer</code>：数据调度</li>
<li><code>transfer</code>：数据执行</li>
</ul>
<h6 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h6><blockquote>
<p><code>SynchronousQueue</code>的<strong>公平</strong>实现，内部实现使用队列，可以保证先进先出的特性。</p>
</blockquote>
<p>基本实现方法：</p>
<p>当前队列为空的时候或者存在了与即将添加的<code>QNode</code>操作模式一致(<code>isData一致</code>)的节点，线程进行同步等待，<code>QNode</code>添加到队列中。</p>
<p>继续等待与队列头部<code>QNode</code>操作互补(<code>写操作(isData = true)，等待一个读操作(isData = false)</code>)的<code>QNode</code>节点</p>
<p>新添加的<code>QNode</code>节点与队头<code>QNode</code>操作互补时，尝试通过<code>CAS</code>更新等待节点的item字段，然后让队头等待节点出列，并返回节点元素和更新队头节点。</p>
<p>如果队列中的节点的<code>waiter</code>等待线程被取消，节点也会被清理出队列。</p>
<p><img src="/images/TransferQueue.jpg" srcset="/img/loading.gif" alt="TransferQueue公平队列"></p>
<p><code>isData</code>：true 表示<code>put</code>操作，false表示<code>take</code>操作。</p>
<p><code>next</code>：下一个节点</p>
<p><code>waiter</code>：当前等待的线程</p>
<p><code>item</code>：元素信息</p>
<h6 id="TransferStack"><a href="#TransferStack" class="headerlink" title="TransferStack"></a>TransferStack</h6><blockquote>
<p><code>SynchronousQueue</code>非公平实现，内部实现使用<strong>栈</strong>，实现了<code>先进后出</code>的特性。</p>
</blockquote>
<p>基本实现方法：</p>
<p>当前栈为空或者存在了与即将添加的<code>SNode</code>模式相同的节点(<code>mode一致</code>)，线程进行同步等待，<code>SNode</code>添加到栈中</p>
<p>继续等待与栈顶<code>SNode</code>操作互补(<code>写操作(mode = DATA)，读操作(mode=REQUEST)</code>)的节点</p>
<p>出现与栈顶<code>SNode</code>操作互补的节点后，新增<code>SNode</code>节点的<code>mode</code>会变为<code>FULFILLING</code>，与栈顶节点匹配，匹配完成后，将俩节点都弹出并返回匹配节点的结果。</p>
<p>如果栈顶元素找到匹配节点，就会继续向下帮助匹配(<code>此时上一个匹配操作还没结束又进入一个新的请求</code>)</p>
<p><img src="/images/TransferStack.jpg" srcset="/img/loading.gif" alt="TranferStack"></p>
<p><code>next</code>：下一个元素</p>
<p><code>item</code>：元素信息</p>
<p><code>waiter</code>：当前等待的线程</p>
<p><code>match</code>：匹配的节点</p>
<p><code>mode</code>：<code>DATA(1)</code>-添加数据、<code>REQUEST(0)</code>-获取数据、<code>FULFILLING(2)</code>-互补模式</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li><code>SynchronousQueue</code>容量为0，无法进行数据存储</li>
<li>每次写入数据时，写线程都需要等待；直到另一个线程执行读操作，写线程会返回数据。<em>写入元素不能为null</em></li>
<li><code>peek()</code>返回<code>null</code>；<code>size()</code>返回<code>0</code>；无法进行迭代操作</li>
<li>提供了<code>公平</code>，<code>非公平</code>两种策略处理，分别是基于<code>Queue-TransferQueue</code>与<code>Stack-TransferStack</code>实现。</li>
</ul>
<h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><p>绝大多数都是利用了<strong>Lock锁的多条件(Condition)阻塞控制</strong>。</p>
<p>拿<code>ArrayBlockigQueue</code>进行简单描述就是：</p>
<ol>
<li><code>put</code>和<code>take</code>操作都需要先<strong>获取锁</strong>，无法获取的话就要一直自旋拿锁，直到获取锁为止</li>
<li>在拿到锁以后。还需要判断当前队列是否可用(<code>队列非满且非空</code>)，如果队列不可用就会被阻塞，并<strong>释放锁</strong></li>
<li>阻塞的线程被唤醒时，依然需要在拿到锁之后才可以继续执行，否则，自旋拿锁，拿到锁继续判断当前队列是否可用(<strong>使用while判断</strong>)</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h5 id="生产-消费模型"><a href="#生产-消费模型" class="headerlink" title="生产-消费模型"></a>生产-消费模型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class PCDemo &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> queueSize = 10;<br>    <span class="hljs-keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(queueSize, <span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br><br>        PCDemo blockQueue = new PCDemo();<br>        Producter producter = blockQueue.new Producter();<br>        Customer customer = blockQueue.new Customer();<br><br>        producter.start();<br>        customer.start();<br>    &#125;<br><br>    class Customer extends Thread &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.take();<br>                    System.err.println("消费哦，剩余空间为" + queue.size());<br>                    Thread.sleep(100);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    class Producter extends Thread &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.put(1);<br>                    System.err.println("生产哦，剩余空间为" + (queueSize - queue.size()));<br>                    Thread.sleep(100);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5>{% post_link Java-线程池%}
<h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><h3 id="Guarded-Suspension（保护性暂时挂起）"><a href="#Guarded-Suspension（保护性暂时挂起）" class="headerlink" title="Guarded Suspension（保护性暂时挂起）"></a>Guarded Suspension（保护性暂时挂起）</h3><p><strong>当服务进程准备好时，才提供服务。</strong></p>
<p><img src="/images/java-concurrent-guarded-suspension.png" srcset="/img/loading.gif" alt="img"></p>
<p>本质是一种<strong>等待唤醒机制的实现</strong>，也称为<strong>多线程的if</strong></p>
<p>基本实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class GuardedObject&lt;T&gt;&#123;<br>  <span class="hljs-keyword">private</span> T obj;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReetrantLock lock = new ReentrantLock();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition done = lock.newCondition();<br>  <br>  <span class="hljs-keyword">public</span> T get(Predicate&lt;T&gt; p)&#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-keyword">while</span>(!p.test(obj))&#123;<br>        done.await(); //等待事件执行<br>      &#125;<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>      e.printStacktrace();<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>      lock.unlock();<br>    &#125;<br>    return obj;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onChange(T obj)&#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-keyword">this</span>.obj = obj;<br>      done.signAll();//数据发生变化，进行通知<br>    &#125;<span class="hljs-keyword">finally</span>&#123;<br>      lock.unlock();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/dwlsxj/archive/2004/01/13/Thread.html" target="_blank" rel="noopener">SynchronousQueue-公平模式</a></p>
<p><a href="https://www.jianshu.com/p/a565b0b25c43" target="_blank" rel="noopener">SynchronousQueue</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/12/24/Android-简单实现Router功能/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android-简单实现Router功能</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/12/21/Android-线程相关/">
                        <span class="hidden-mobile">Android-线程相关</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
