

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <title>View的工作原理 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/atom-one-light.min.css">
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
                View的工作原理
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-12-14 16:47" pubdate>
        2018年12月14日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      191
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">View的工作原理</h1>
            
            <div class="markdown-body" id="post-body">
              <!--MeasureSpec是什么？有什么作用？，自定义View/ViewGroup需要注意什么？invalidate()和postInvalidate()的区别？,invalidate和postInvalidate的区别及使用 Requestlayout，onlayout，onDraw，DrawChild区别与联系  View刷新机制  View绘制流程  计算一个view的嵌套层级（递归）  onMeasure的具体过程，先measure子view还是自己  onDraw的具体过程，先draw子view还是自己  实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展 view的工作原理及measure、layout、draw流程。哪一个流程可以放在子线程中去执行？draw方法中需要注意的问题？Invalidate、postInvalidate、requestLayout应用场景 TextView.setText()调用什么方法去刷新 -->
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View工作原理.png" srcset="/img/loading.gif" class="full-image" alt="View工作原理" title="View工作原理"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<a id="more"></a>
<h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><p><strong>DecorView是整个Window界面的最顶层View。</strong> <em>可以使用Android Studio自带的Layout Inspector查看页面层级</em></p>
<h3 id="DecorView的布局结构"><a href="#DecorView的布局结构" class="headerlink" title="DecorView的布局结构"></a>DecorView的布局结构</h3><p>一般情况下<code>DecorView</code>会包含一个竖直方向的LinearLayout，该LinearLayout分为上下两个部分，上面是标题栏(<code>titlebar</code>)，下面是内容栏(<code>继承自FrameLayout 且id为content</code>)。因此我们设置Activity的布局方法叫做<code>setContentView()</code>，因为他们都被加进了<code>id为content的FrameLayout</code>中。</p>
<p>我们可以利用<code>ViewGroup content = findViewById(R.android.id.content)</code>获取conetnt。使用<code>content.getChildAt(0)</code>获取设置的Activity布局。</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/Activity.java</span>
    <span class="hljs-keyword">public</span> &lt;T extends View&gt; <span class="hljs-function">T <span class="hljs-title">findViewById</span><span class="hljs-params">(@IdRes <span class="hljs-keyword">int</span> id)</span> </span>&#123;
        <span class="hljs-comment">//从Window中去获取View</span>
        <span class="hljs-keyword">return</span> getWindow().findViewById(id);
    &#125;

<span class="hljs-comment">// ../android/view/Window.java</span>
    <span class="hljs-keyword">public</span> &lt;T extends View&gt; <span class="hljs-function">T <span class="hljs-title">findViewById</span><span class="hljs-params">(@IdRes <span class="hljs-keyword">int</span> id)</span> </span>&#123;
        <span class="hljs-comment">//从DecorView获取View</span>
        <span class="hljs-keyword">return</span> getDecorView().findViewById(id);
    &#125;</code></pre>
<p>所有的View都会从DecorView中开始检索，所以<strong>View层的事件都会先经过DecorView，再传递到我们定义的View上</strong>。</p>
<h3 id="setContentView-流程"><a href="#setContentView-流程" class="headerlink" title="setContentView()流程"></a>setContentView()流程</h3><blockquote>
<p>通过<code>setContentView()</code>将需要加载的布局放到<code>DecorView</code>中</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//Activity.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
    &#125;</code></pre>
<p><code>Activity.setContentView()</code>调用<code>PhoneWindow.setContentView()</code></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;
    <span class="hljs-comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span>
    <span class="hljs-comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span>
    <span class="hljs-comment">// before this happens.</span>
    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">//创建DecorView</span>
        installDecor();
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;
        mContentParent.removeAllViews();
    &#125;

    <span class="hljs-keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;
        <span class="hljs-keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                getContext());
        transitionTo(newScene);
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">//开始加载对应布局</span>
        mLayoutInflater.inflate(layoutResID, mContentParent);
    &#125;
    mContentParent.requestApplyInsets();
    <span class="hljs-keyword">final</span> Callback cb = getCallback();
    <span class="hljs-keyword">if</span> (cb != <span class="hljs-keyword">null</span> &amp;&amp; !isDestroyed()) &#123;
        cb.onContentChanged();
    &#125;
    mContentParentExplicitlySet = <span class="hljs-keyword">true</span>;
&#125;</code></pre>
<p><code>setContentView()</code>主要执行以下两步：</p>
<h4 id="installDecor-创建DecorView"><a href="#installDecor-创建DecorView" class="headerlink" title="installDecor()创建DecorView"></a><code>installDecor()</code>创建DecorView</h4><blockquote>
<p>基础<code>DecorView</code>主要包含两部分，标题<code>title_bar</code>和内容<code>content</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//PhoneWindow.java</span>
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installDecor</span><span class="hljs-params">()</span> </span>&#123;
        mForceDecorInstall = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (mDecor == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">//生成DecoeView</span>
            mDecor = generateDecor(-<span class="hljs-number">1</span>);
            ...
        &#125; <span class="hljs-keyword">else</span> &#123;
            mDecor.setWindow(<span class="hljs-keyword">this</span>);
        &#125;
        <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;
           <span class="hljs-comment">//根据DecorView生成子View</span>
            mContentParent = generateLayout(mDecor);
          ...
        &#125;
 &#125;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> DecorView <span class="hljs-title">generateDecor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> featureId)</span> </span>&#123;
        Context context;
        <span class="hljs-keyword">if</span> (mUseDecorContext) &#123;
            Context applicationContext = getContext().getApplicationContext();
            <span class="hljs-keyword">if</span> (applicationContext == <span class="hljs-keyword">null</span>) &#123;
                context = getContext();
            &#125; <span class="hljs-keyword">else</span> &#123;
                context = <span class="hljs-keyword">new</span> DecorContext(applicationContext, getContext());
                <span class="hljs-keyword">if</span> (mTheme != -<span class="hljs-number">1</span>) &#123;
                    context.setTheme(mTheme);
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            context = getContext();
        &#125;
      <span class="hljs-comment">// 生成DecorView对象</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecorView(context, featureId, <span class="hljs-keyword">this</span>, getAttributes());
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> ViewGroup <span class="hljs-title">generateLayout</span><span class="hljs-params">(DecorView decor)</span> </span>&#123;
      ...
        <span class="hljs-keyword">int</span> layoutResource;
        <span class="hljs-keyword">int</span> features = getLocalFeatures();
        <span class="hljs-keyword">if</span> ((features &amp; (<span class="hljs-number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="hljs-number">0</span>) &#123;
            layoutResource = R.layout.screen_swipe_dismiss;
            setCloseOnSwipeEnabled(<span class="hljs-keyword">true</span>);     
        &#125;...
         <span class="hljs-keyword">else</span>&#123;
           layoutResource = R.layout.screen_simple; <span class="hljs-comment">//默认布局</span>
         &#125;
         mDecor.startChanging();
         <span class="hljs-comment">//开始加载布局</span>
         mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);
         <span class="hljs-comment">//根据id找到 content</span>
         ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);<span class="hljs-comment">//com.android.internal.R.id.content</span>
         ...
         <span class="hljs-keyword">return</span> contentParent;
    &#125;

<span class="hljs-comment">//DecorView.java</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onResourcesLoaded</span><span class="hljs-params">(LayoutInflater inflater, <span class="hljs-keyword">int</span> layoutResource)</span> </span>&#123;
        <span class="hljs-keyword">final</span> View root = inflater.inflate(layoutResource, <span class="hljs-keyword">null</span>);
        <span class="hljs-keyword">if</span> (mDecorCaptionView != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (mDecorCaptionView.getParent() == <span class="hljs-keyword">null</span>) &#123;
                addView(mDecorCaptionView,
                        <span class="hljs-keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
            &#125;
            mDecorCaptionView.addView(root,
                    <span class="hljs-keyword">new</span> ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">//解析得到的View放到DecorView中</span>
            addView(root, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
        &#125;
        mContentRoot = (ViewGroup) root;
    &#125;</code></pre>
<p><code>installDecor()</code>主要复杂创建<code>DecorView</code>并执行<code>generateLayout()</code>生成<code>contentParent</code>将自定义的布局放入其中。</p>
<h4 id="LayoutInflater-inflate-加载布局"><a href="#LayoutInflater-inflate-加载布局" class="headerlink" title="LayoutInflater.inflate()加载布局"></a>LayoutInflater.inflate()加载布局</h4><blockquote>
<p><code>LayoutInflater</code>是一个抽象类，具体实现类为<code>PhoneLayoutInflater</code></p>
</blockquote>
<p>通过系统注册服务可以得到<code>LayoutInflater</code>的实现类<code>PhoneLayoutInflater</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//LayoutInflater.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LayoutInflater <span class="hljs-title">from</span><span class="hljs-params">(Context context)</span> </span>&#123;
    LayoutInflater LayoutInflater =
            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);<span class="hljs-comment">//获取系统配置的加载服务</span>
    <span class="hljs-keyword">if</span> (LayoutInflater == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">"LayoutInflater not found."</span>);
    &#125;
    <span class="hljs-keyword">return</span> LayoutInflater;
&#125;

<span class="hljs-comment">//系统设置 PhoneInflater 为加载类</span>
registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater<span class="hljs-class">.<span class="hljs-keyword">class</span>,
            <span class="hljs-title">new</span> <span class="hljs-title">CachedServiceFetcher</span>&lt;<span class="hljs-title">LayoutInflater</span>&gt;() </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> LayoutInflater <span class="hljs-title">createService</span><span class="hljs-params">(ContextImpl ctx)</span> </span>&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());
        &#125;&#125;);</code></pre>
<p>在<code>setContentView()</code>生成<code>DecorView</code>之后，就需要对设置的<code>layoutResId</code>进行加载，使其加入到<code>content</code>中</p>
<pre><code class="hljs java"><span class="hljs-comment">//LayoutInflater.java</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> resource, @Nullable ViewGroup root)</span> </span>&#123;
        <span class="hljs-keyword">return</span> inflate(resource, root, root != <span class="hljs-keyword">null</span>);
   &#125;   

   <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> resource, @Nullable ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span> </span>&#123;
        <span class="hljs-keyword">final</span> Resources res = getContext().getResources();
        ...
        <span class="hljs-comment">//构造xml解析器</span>
        <span class="hljs-keyword">final</span> XmlResourceParser parser = res.getLayout(resource);
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">return</span> inflate(parser, root, attachToRoot);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            parser.close();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span> </span>&#123;
        <span class="hljs-keyword">synchronized</span> (mConstructorArgs) &#123;
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="hljs-string">"inflate"</span>);

            <span class="hljs-keyword">final</span> Context inflaterContext = mContext;
            <span class="hljs-keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);
            Context lastContext = (Context) mConstructorArgs[<span class="hljs-number">0</span>];
            mConstructorArgs[<span class="hljs-number">0</span>] = inflaterContext;
            View result = root;

            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// Look for the root node.</span>
                <span class="hljs-keyword">int</span> type;
                <span class="hljs-comment">//非xml起始与结尾标记</span>
                <span class="hljs-keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;
                        type != XmlPullParser.END_DOCUMENT) &#123;
                &#125;
            
                <span class="hljs-keyword">if</span> (type != XmlPullParser.START_TAG) &#123;
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(parser.getPositionDescription()
                            + <span class="hljs-string">": No start tag found!"</span>);
                &#125;

                <span class="hljs-keyword">final</span> String name = parser.getName();
                <span class="hljs-comment">//处理&lt;merge&gt;标签</span>
                <span class="hljs-keyword">if</span> (TAG_MERGE.equals(name)) &#123;
                    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !attachToRoot) &#123;
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"&lt;merge /&gt; can be used only with a valid "</span>
                                + <span class="hljs-string">"ViewGroup root and attachToRoot=true"</span>);
                    &#125;
                    <span class="hljs-comment">//传入rootview 解析得到的布局直接加入rootView中</span>
                    rInflate(parser, root, inflaterContext, attrs, <span class="hljs-keyword">false</span>);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// Temp is the root view that was found in the xml</span>
                    <span class="hljs-comment">//根据Tag创建对应的View 例如&lt;TextView&gt;</span>
                    <span class="hljs-keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);

                    ViewGroup.LayoutParams params = <span class="hljs-keyword">null</span>;

                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;
                        <span class="hljs-comment">// Create layout params that match root, if supplied</span>
                        params = root.generateLayoutParams(attrs);
                        <span class="hljs-keyword">if</span> (!attachToRoot) &#123;
                            <span class="hljs-comment">// Set the layout params for temp if we are not</span>
                            <span class="hljs-comment">// attaching. (If we are, we use addView, below)</span>
                            temp.setLayoutParams(params);
                        &#125;
                    &#125;

                    <span class="hljs-comment">// Inflate all children under temp against its context.</span>
                    <span class="hljs-comment">//创建temp子View</span>
                    rInflateChildren(parser, temp, attrs, <span class="hljs-keyword">true</span>);

                    <span class="hljs-comment">// We are supposed to attach all the views we found (int temp)</span>
                    <span class="hljs-comment">// to root. Do that now.</span>
                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span> &amp;&amp; attachToRoot) &#123;
                        <span class="hljs-comment">//将temp添加到rootView中</span>
                        root.addView(temp, params);
                    &#125;

                    <span class="hljs-comment">// Decide whether to return the root that was passed in or the</span>
                    <span class="hljs-comment">// top view found in xml.</span>
                    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !attachToRoot) &#123;
                        <span class="hljs-comment">//attachToRoot：将View添加到RootView中，非就是直接返回解析的子View</span>
                        result = temp;
                    &#125;
                &#125;

            &#125; <span class="hljs-keyword">catch</span> (XmlPullParserException e) &#123;
                <span class="hljs-keyword">final</span> InflateException ie = <span class="hljs-keyword">new</span> InflateException(e.getMessage(), e);
                ie.setStackTrace(EMPTY_STACK_TRACE);
                <span class="hljs-keyword">throw</span> ie;
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                <span class="hljs-keyword">final</span> InflateException ie = <span class="hljs-keyword">new</span> InflateException(parser.getPositionDescription()
                        + <span class="hljs-string">": "</span> + e.getMessage(), e);
                ie.setStackTrace(EMPTY_STACK_TRACE);
                <span class="hljs-keyword">throw</span> ie;
            &#125; <span class="hljs-keyword">finally</span> &#123;
                <span class="hljs-comment">// Don't retain static reference on context.</span>
                mConstructorArgs[<span class="hljs-number">0</span>] = lastContext;
                mConstructorArgs[<span class="hljs-number">1</span>] = <span class="hljs-keyword">null</span>;

                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
            &#125;

            <span class="hljs-keyword">return</span> result;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rInflate</span><span class="hljs-params">(XmlPullParser parser, View parent, Context context,
            AttributeSet attrs, <span class="hljs-keyword">boolean</span> finishInflate)</span> <span class="hljs-keyword">throws</span> XmlPullParserException, IOException </span>&#123;

        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> depth = parser.getDepth();
        <span class="hljs-keyword">int</span> type;
        <span class="hljs-keyword">boolean</span> pendingRequestFocus = <span class="hljs-keyword">false</span>;

        <span class="hljs-keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||
                parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;

            <span class="hljs-keyword">if</span> (type != XmlPullParser.START_TAG) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;

            <span class="hljs-keyword">final</span> String name = parser.getName();

            <span class="hljs-keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;
                pendingRequestFocus = <span class="hljs-keyword">true</span>;
                consumeChildElements(parser);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_TAG.equals(name)) &#123;
                parseViewTag(parser, parent, attrs);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;<span class="hljs-comment">//&lt;include&gt;</span>
                <span class="hljs-keyword">if</span> (parser.getDepth() == <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"&lt;include /&gt; cannot be the root element"</span>);
                &#125;
                parseInclude(parser, context, parent, attrs);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_MERGE.equals(name)) &#123;<span class="hljs-comment">//&lt;merge&gt;</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"&lt;merge /&gt; must be the root element"</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">//创建View</span>
                <span class="hljs-keyword">final</span> View view = createViewFromTag(parent, name, context, attrs);
                <span class="hljs-keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;
                <span class="hljs-keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
                <span class="hljs-comment">//递归创建子View</span>
                rInflateChildren(parser, view, attrs, <span class="hljs-keyword">true</span>);
                <span class="hljs-comment">//创建的子View添加会parent</span>
                viewGroup.addView(view, params);
            &#125;
        &#125;

        <span class="hljs-keyword">if</span> (pendingRequestFocus) &#123;
            parent.restoreDefaultFocus();
        &#125;

        <span class="hljs-keyword">if</span> (finishInflate) &#123;
            parent.onFinishInflate();
        &#125;
    &#125;</code></pre>
<p><code>layoutInflater.inflate()</code>主要是调用<code>createViewFromTag()</code>从xml生成view的</p>
<h5 id="inflate-resource-root-attachToRoot"><a href="#inflate-resource-root-attachToRoot" class="headerlink" title="inflate(resource,root,attachToRoot)"></a>inflate(resource,root,attachToRoot)</h5><blockquote>
<p><code>source</code>：需要加载的layout id</p>
<p><code>root</code>：根布局</p>
<p>*<code>attachToRoot</code>：是否添加到<code>root</code>中</p>
</blockquote>
<p>根据源码分析到，<code>root</code>与<code>attachToRoot</code>会对<code>infalte()</code>结果产生影响以及实现代码会有差异</p>
<table>
<thead>
<tr>
<th><code>root</code>与<code>attachToRoot</code>参数</th>
<th>表现</th>
<th><code>inflate()</code>返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>root == nuill &amp;&amp; attachToRoot == false/true</code></td>
<td>直接显示<code>source</code>加载的结果，而且设置的<code>宽高属性</code>也会失效</td>
<td><code>source</code>加载后的<code>View实例</code></td>
</tr>
<tr>
<td><code>root != null &amp;&amp; attachToRoot == false</code></td>
<td>直接显示<code>source</code>加载的结果，且设置的<code>宽高属性</code>保持</td>
<td><code>source</code>加载后的<code>View实例</code></td>
</tr>
<tr>
<td><code>root!=null &amp;&amp; attachToRoot == true</code></td>
<td>直接显示<code>root</code>并且<code>source</code>已被<code>add</code>进去且设置的<code>宽高属性</code>保持</td>
<td><code>root</code></td>
</tr>
</tbody>
</table>
<h5 id="createViewFromTag"><a href="#createViewFromTag" class="headerlink" title="* createViewFromTag()"></a>* createViewFromTag()</h5><blockquote>
<p>主要负责将<code>&lt;tag&gt;</code>创建成<code>View</code>对象</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//LayoutInflater.java</span>
<span class="hljs-function">View <span class="hljs-title">createViewFromTag</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs,
            <span class="hljs-keyword">boolean</span> ignoreThemeAttr)</span> </span>&#123;
        <span class="hljs-comment">/**
        * view标签 取class 做为name
        */</span>
        <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">"view"</span>)) &#123;
            name = attrs.getAttributeValue(<span class="hljs-keyword">null</span>, <span class="hljs-string">"class"</span>);
        &#125;

        <span class="hljs-comment">// 设置View的Theme</span>
        <span class="hljs-keyword">if</span> (!ignoreThemeAttr) &#123;
            <span class="hljs-keyword">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> themeResId = ta.getResourceId(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (themeResId != <span class="hljs-number">0</span>) &#123;
                context = <span class="hljs-keyword">new</span> ContextThemeWrapper(context, themeResId);
            &#125;
            ta.recycle();
        &#125;
        <span class="hljs-comment">//处理 &lt;blink&gt;标签</span>
        <span class="hljs-keyword">if</span> (name.equals(TAG_1995)) &#123;
            <span class="hljs-comment">// Let's party like it's 1995!</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BlinkLayout(context, attrs);
        &#125;

        <span class="hljs-keyword">try</span> &#123;
            View view;
            <span class="hljs-comment">//通过Factory /Factory2  进行View的实例化</span>
            <span class="hljs-keyword">if</span> (mFactory2 != <span class="hljs-keyword">null</span>) &#123;
                view = mFactory2.onCreateView(parent, name, context, attrs);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mFactory != <span class="hljs-keyword">null</span>) &#123;
                view = mFactory.onCreateView(name, context, attrs);
            &#125; <span class="hljs-keyword">else</span> &#123;
                view = <span class="hljs-keyword">null</span>;
            &#125;
            <span class="hljs-comment">//通过 mPrivateFactory实例化View</span>
            <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span> &amp;&amp; mPrivateFactory != <span class="hljs-keyword">null</span>) &#123;
                view = mPrivateFactory.onCreateView(parent, name, context, attrs);
            &#125;
            <span class="hljs-comment">//未设置 Factory，走默认创建View的流程</span>
            <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-keyword">final</span> Object lastContext = mConstructorArgs[<span class="hljs-number">0</span>];
                mConstructorArgs[<span class="hljs-number">0</span>] = context;
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-comment">//&lt;tag&gt;中存在 . 可以判断为自定义View，走View自身的创建流程</span>
                    <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == name.indexOf(<span class="hljs-string">'.'</span>)) &#123;
                        view = onCreateView(parent, name, attrs);
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        view = createView(name, <span class="hljs-keyword">null</span>, attrs);
                    &#125;
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    mConstructorArgs[<span class="hljs-number">0</span>] = lastContext;
                &#125;
            &#125;

            <span class="hljs-keyword">return</span> view;
        &#125; 
        ,,,
    &#125;
&#125;</code></pre>
<p><code>createViewFromTag()</code>主要做了以下几步：</p>
<ol>
<li><p>如果为<code>&lt;view&gt;</code>标签，读取<code>class</code>属性做为类名</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"LinearLayout"</span>/&gt;</span> 等价于<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></code></pre>
</li>
</ol>
<ol start="2">
<li><p>应用<code>ContenxtThemeWrapper</code>为View设置主题<code>Theme</code></p>
</li>
<li><p>使用<code>Factory/Factory2/mPrivateFactory</code>实例化<code>View</code>，相当于<strong>拦截</strong></p>
<blockquote>
<p>实例化<code>View</code>的优先顺序为<code>Factory2 &gt; Factory &gt; mPrivateFactory &gt; PhoneLayoutInflater</code></p>
</blockquote>
</li>
<li><p>未设置<code>以上factory</code>，执行<code>View</code>的默认创建流程</p>
<blockquote>
<p>主要通过<code>PhoneLayoutInflater</code>执行</p>
</blockquote>
</li>
</ol>
<h3 id="Factory-Factory2-拦截View创建"><a href="#Factory-Factory2-拦截View创建" class="headerlink" title="Factory/Factory2-拦截View创建"></a>Factory/Factory2-拦截View创建</h3><blockquote>
<p>在上节有说到<code>Factory/Factory2</code>执行相当于拦截的功能，<code>hook</code>View创建的流程</p>
<p><code>mPrivateFactory</code>实现了<code>Factory2</code>接口，主要用于拦截<code>&lt;fragment&gt;</code>标签处理</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> Factory mFactory;
<span class="hljs-keyword">private</span> Factory2 mFactory2;
<span class="hljs-keyword">private</span> Factory2 mPrivateFactory;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, Context context, AttributeSet attrs)</span></span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Factory</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span></span>;
&#125;</code></pre>
<p><code>Factory2</code>相对于<code>Factory</code>在<code>onCreateView()</code>多传入了<code>parent</code></p>
<h4 id="Factroy2"><a href="#Factroy2" class="headerlink" title="Factroy2"></a>Factroy2</h4><p>设置<code>Factroy2</code>的方法</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFactory2</span><span class="hljs-params">(Factory2 factory)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (mFactorySet) &#123; <span class="hljs-comment">//只允许设置一次 Factory2</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"A factory has already been set on this LayoutInflater"</span>);
    &#125;
    <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"Given factory can not be null"</span>);
    &#125;
    mFactorySet = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span> (mFactory == <span class="hljs-keyword">null</span>) &#123;
        mFactory = mFactory2 = factory;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">//控制factory调用顺序</span>
        mFactory = mFactory2 = <span class="hljs-keyword">new</span> FactoryMerger(factory, factory, mFactory, mFactory2);
    &#125;
&#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMerger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory2</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Factory mF1, mF2;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Factory2 mF12, mF22;

    FactoryMerger(Factory f1, Factory2 f12, Factory f2, Factory2 f22) &#123;
        mF1 = f1;
        mF2 = f2;
        mF12 = f12;
        mF22 = f22;
    &#125;

  <span class="hljs-comment">//此处对应Factory</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;
        View v = mF1.onCreateView(name, context, attrs);
        <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> v;
        <span class="hljs-keyword">return</span> mF2.onCreateView(name, context, attrs);
    &#125;
   <span class="hljs-comment">//此处对应Factory2</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;
        View v = mF12 != <span class="hljs-keyword">null</span> ? mF12.onCreateView(parent, name, context, attrs)
                : mF1.onCreateView(name, context, attrs);
        <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> v;
        <span class="hljs-keyword">return</span> mF22 != <span class="hljs-keyword">null</span> ? mF22.onCreateView(parent, name, context, attrs)
                : mF2.onCreateView(name, context, attrs);
    &#125;
&#125;</code></pre>
<p>最终都是通过<code>FactoryMerger</code>执行的<code>onCreateView</code></p>
<h5 id="何处调用setFactory2"><a href="#何处调用setFactory2" class="headerlink" title="何处调用setFactory2()"></a>何处调用setFactory2()</h5><pre><code class="hljs java"><span class="hljs-comment">//AppCompatActivity.onCreate() -&gt; AppCompatDelegate.installViewFactory() -&gt;</span>
<span class="hljs-comment">//AppCompatDelegateImpl.installViewFactory()</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installViewFactory</span><span class="hljs-params">()</span> </span>&#123;
        LayoutInflater layoutInflater = LayoutInflater.from(<span class="hljs-keyword">this</span>.mContext);
        <span class="hljs-keyword">if</span> (layoutInflater.getFactory() == <span class="hljs-keyword">null</span>) &#123;
            LayoutInflaterCompat.setFactory2(layoutInflater, <span class="hljs-keyword">this</span>);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(layoutInflater.getFactory2() <span class="hljs-keyword">instanceof</span> AppCompatDelegateImpl)) &#123;
            Log.i(<span class="hljs-string">"AppCompatDelegate"</span>, <span class="hljs-string">"The Activity's LayoutInflater already has a Factory installed so we can not install AppCompat's"</span>);
        &#125;

    &#125;

<span class="hljs-comment">//设置Factory2执行到 onCreateView()</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.createView(parent, name, context, attrs);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">createView</span><span class="hljs-params">(View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mAppCompatViewInflater == <span class="hljs-keyword">null</span>) &#123;
            TypedArray a = <span class="hljs-keyword">this</span>.mContext.obtainStyledAttributes(styleable.AppCompatTheme);
            String viewInflaterClassName = a.getString(styleable.AppCompatTheme_viewInflaterClass);
            <span class="hljs-keyword">if</span> (viewInflaterClassName != <span class="hljs-keyword">null</span> &amp;&amp; !AppCompatViewInflater<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>().<span class="hljs-title">equals</span>(<span class="hljs-title">viewInflaterClassName</span>)) </span>&#123;
                <span class="hljs-keyword">try</span> &#123;
                    Class viewInflaterClass = Class.forName(viewInflaterClassName);
                    <span class="hljs-keyword">this</span>.mAppCompatViewInflater = (AppCompatViewInflater)viewInflaterClass.getDeclaredConstructor().newInstance();
                &#125; <span class="hljs-keyword">catch</span> (Throwable var8) &#123;
                    Log.i(<span class="hljs-string">"AppCompatDelegate"</span>, <span class="hljs-string">"Failed to instantiate custom view inflater "</span> + viewInflaterClassName + <span class="hljs-string">". Falling back to default."</span>, var8);
                    <span class="hljs-keyword">this</span>.mAppCompatViewInflater = <span class="hljs-keyword">new</span> AppCompatViewInflater();
                &#125;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">this</span>.mAppCompatViewInflater = <span class="hljs-keyword">new</span> AppCompatViewInflater();
            &#125;
        &#125;

        ...
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mAppCompatViewInflater.createView(...);
    &#125;</code></pre>
<p>通过<code>AppCompatViewInflater</code>去执行View的创建</p>
<pre><code class="hljs java"><span class="hljs-comment">//AppCompatViewInflater.java</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> View <span class="hljs-title">createView</span><span class="hljs-params">(View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs, <span class="hljs-keyword">boolean</span> inheritContext, <span class="hljs-keyword">boolean</span> readAndroidTheme, <span class="hljs-keyword">boolean</span> readAppTheme, <span class="hljs-keyword">boolean</span> wrapContext)</span> </span>&#123;
  ...
     <span class="hljs-keyword">switch</span> (name) &#123;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"TextView"</span>:
                view = createTextView(context, attrs);
                verifyNotNull(view, name);
                <span class="hljs-keyword">break</span>;
         ...
     &#125;
&#125;

    <span class="hljs-meta">@NonNull</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> AppCompatTextView <span class="hljs-title">createTextView</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AppCompatTextView(context, attrs);
    &#125;</code></pre>
<p>此处可以在使用到<code>AppCompatActivity</code>时，将原先的<code>&lt;TextView&gt;</code>转换为<code>AppCompatTextView</code></p>
<h4 id="mPrivateFactory"><a href="#mPrivateFactory" class="headerlink" title="mPrivateFactory"></a>mPrivateFactory</h4><blockquote>
<p>系统hide对象，无法被外界使用，主要处理<code>&lt;fragment&gt;</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrivateFactory</span><span class="hljs-params">(Factory2 factory)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (mPrivateFactory == <span class="hljs-keyword">null</span>) &#123;
        mPrivateFactory = factory;
    &#125; <span class="hljs-keyword">else</span> &#123;
        mPrivateFactory = <span class="hljs-keyword">new</span> FactoryMerger(factory, factory, mPrivateFactory, mPrivateFactory);
    &#125;
&#125;</code></pre>
<h5 id="何处调用setPrivateFactory"><a href="#何处调用setPrivateFactory" class="headerlink" title="何处调用setPrivateFactory()"></a>何处调用setPrivateFactory()</h5><pre><code class="hljs java"><span class="hljs-comment">//Activity.java</span>
<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;
  ...
    mWindow.getLayoutInflater().setPrivateFactory(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//this 表示当前Activity</span>
  ...
&#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!<span class="hljs-string">"fragment"</span>.equals(name)) &#123;
            <span class="hljs-keyword">return</span> onCreateView(name, context, attrs);
        &#125;
       <span class="hljs-comment">//&lt;fragment&gt;标签直接解析执行 onCreateView</span>
        <span class="hljs-keyword">return</span> mFragments.onCreateView(parent, name, context, attrs);
    &#125;</code></pre>
<h3 id="View默认创建流程"><a href="#View默认创建流程" class="headerlink" title="View默认创建流程"></a>View默认创建流程</h3><blockquote>
<p>未设置<code>Factory/Factory2</code>就会执行默认的View创建流程</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//LayoutInflater.java</span>
    <span class="hljs-function">View <span class="hljs-title">createViewFromTag</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs,
            <span class="hljs-keyword">boolean</span> ignoreThemeAttr)</span> </span>&#123;
      ...
        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-keyword">final</span> Object lastContext = mConstructorArgs[<span class="hljs-number">0</span>];
                mConstructorArgs[<span class="hljs-number">0</span>] = context;
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == name.indexOf(<span class="hljs-string">'.'</span>)) &#123;
                        view = onCreateView(parent, name, attrs);<span class="hljs-comment">//系统提供View</span>
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        view = createView(name, <span class="hljs-keyword">null</span>, attrs);<span class="hljs-comment">//自定义View</span>
                    &#125;
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    mConstructorArgs[<span class="hljs-number">0</span>] = lastContext;
                &#125;
            &#125;
      ...
    &#125;</code></pre>
<h4 id="系统提供View"><a href="#系统提供View" class="headerlink" title="系统提供View"></a>系统提供View</h4><blockquote>
<p>例如<code>&lt;TextView/&gt;、&lt;Button/&gt;</code>等</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneLayoutInflater</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LayoutInflater</span> </span>&#123;
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] sClassPrefixList = &#123;
        <span class="hljs-string">"android.widget."</span>,
        <span class="hljs-string">"android.webkit."</span>,
        <span class="hljs-string">"android.app."</span>
    &#125;;

     <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, AttributeSet attrs)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;
        <span class="hljs-keyword">for</span> (String prefix : sClassPrefixList) &#123;
            <span class="hljs-keyword">try</span> &#123;
                View view = createView(name, prefix, attrs);
                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-keyword">return</span> view;
                &#125;
            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
                <span class="hljs-comment">// In this case we want to let the base class take a crack</span>
                <span class="hljs-comment">// at it.</span>
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onCreateView(name, attrs);
    &#125;
  
&#125;

<span class="hljs-comment">//LayoutInflater.java</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, AttributeSet attrs)</span>
            <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;
        <span class="hljs-keyword">return</span> createView(name, <span class="hljs-string">"android.view."</span>, attrs);
    &#125;</code></pre>
<p>优先判断</p>
<ul>
<li><code>android.widget.*</code> 例如<code>android.widget.TextView</code></li>
<li><code>android.webkit.*</code> 例如<code>android.webkit.WebView</code></li>
<li><code>android.app.*</code> 例如<code>android.app.ActionBar</code></li>
</ul>
<p>是否有对应<code>nmae</code>的View实例存在</p>
<p>都不存在，就在<code>android.view.*</code>找寻对应View实例 例如<code>android.view.ViewStub</code></p>
<h4 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h4><blockquote>
<p>例如<code>android.support.v7.widget.RecyclerView</code>等</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View <span class="hljs-title">createView</span><span class="hljs-params">(String name, String prefix, AttributeSet attrs)</span>
            <span class="hljs-keyword">throws</span> ClassNotFoundException, InflateException </span>&#123;
       <span class="hljs-comment">//构建缓存，缓存已加载的View</span>
        Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);
        <span class="hljs-keyword">if</span> (constructor != <span class="hljs-keyword">null</span> &amp;&amp; !verifyClassLoader(constructor)) &#123;
            constructor = <span class="hljs-keyword">null</span>;
            sConstructorMap.remove(name);
        &#125;
        Class&lt;? extends View&gt; clazz = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">try</span> &#123;
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
            <span class="hljs-comment">//新建View构造器</span>
            <span class="hljs-keyword">if</span> (constructor == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">// 得到全限定名 例如android,widget.TextView</span>
                clazz = mContext.getClassLoader().loadClass(
                        prefix != <span class="hljs-keyword">null</span> ? (prefix + name) : name).asSubclass(View<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

                <span class="hljs-keyword">if</span> (mFilter != <span class="hljs-keyword">null</span> &amp;&amp; clazz != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-keyword">boolean</span> allowed = mFilter.onLoadClass(clazz);
                    <span class="hljs-keyword">if</span> (!allowed) &#123;
                        failNotAllowed(name, prefix, attrs);
                    &#125;
                &#125;
                constructor = clazz.getConstructor(mConstructorSignature);
                constructor.setAccessible(<span class="hljs-keyword">true</span>);
                sConstructorMap.put(name, constructor);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// If we have a filter, apply it to cached constructor</span>
                <span class="hljs-keyword">if</span> (mFilter != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-comment">// Have we seen this name before?</span>
                    Boolean allowedState = mFilterMap.get(name);
                    <span class="hljs-keyword">if</span> (allowedState == <span class="hljs-keyword">null</span>) &#123;
                        <span class="hljs-comment">// New class -- remember whether it is allowed</span>
                        clazz = mContext.getClassLoader().loadClass(
                                prefix != <span class="hljs-keyword">null</span> ? (prefix + name) : name).asSubclass(View<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

                        <span class="hljs-keyword">boolean</span> allowed = clazz != <span class="hljs-keyword">null</span> &amp;&amp; mFilter.onLoadClass(clazz);
                        mFilterMap.put(name, allowed);
                        <span class="hljs-keyword">if</span> (!allowed) &#123;
                            failNotAllowed(name, prefix, attrs);
                        &#125;
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allowedState.equals(Boolean.FALSE)) &#123;
                        failNotAllowed(name, prefix, attrs);
                    &#125;
                &#125;
            &#125;

            Object lastContext = mConstructorArgs[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (mConstructorArgs[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">// Fill in the context if not already within inflation.</span>
                mConstructorArgs[<span class="hljs-number">0</span>] = mContext;
            &#125;
            Object[] args = mConstructorArgs;
            args[<span class="hljs-number">1</span>] = attrs;
            <span class="hljs-comment">//根据得到的 constuctor 实例化View对象</span>
            <span class="hljs-keyword">final</span> View view = constructor.newInstance(args);
            <span class="hljs-comment">//针对ViewStub特殊处理</span>
            <span class="hljs-keyword">if</span> (view <span class="hljs-keyword">instanceof</span> ViewStub) &#123;
                <span class="hljs-comment">// Use the same context when inflating ViewStub later.</span>
                <span class="hljs-keyword">final</span> ViewStub viewStub = (ViewStub) view;
                viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="hljs-number">0</span>]));
            &#125;
            mConstructorArgs[<span class="hljs-number">0</span>] = lastContext;
            <span class="hljs-keyword">return</span> view;

        &#125; 
  ...
    &#125;</code></pre>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p><code>View默认创建</code>流程分为：</p>
<ul>
<li><code>&lt;tag&gt;</code>不包含<code>.</code>，用于处理<code>&lt;TextView&gt;、&lt;WebView&gt;</code>等标签，此时需要拼接<code>android.widget. 或 android.webkit. 或 android.app.</code>前缀(<strong>实现位于<code>PhoneLayoutInflater</code></strong>)，都没有找到对应的<code>View实例</code>时，就会在添加<code>android.view.</code>再去加载。</li>
<li><code>&lt;tag&gt;</code>包含<code>.</code>，此时的实例View分为以下几步：<ul>
<li>构建View的缓存，缓存的是<code>constructor</code>，根据<code>name</code>获取<code>constructor</code></li>
<li>缓存中不存在时，需要根据<code>prefix+name</code>获取View的<code>constructor</code>，并存入缓存中</li>
<li>根据<code>constructor</code>构造<code>View实例</code>——<code>constructor.newInstance()</code></li>
<li>如果需要处理<code>ViewStub</code>，为<code>ViewStub</code>指定加载类</li>
</ul>
</li>
</ul>
<p><img src="/images/LayoutInflater过程.jpg" srcset="/img/loading.gif" alt="执行流程"></p>
<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><blockquote>
<p><em>ViewRoot对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程均需通过ViewRoot完成。</em></p>
</blockquote>
<h3 id="ViewRootImpl创建时机"><a href="#ViewRootImpl创建时机" class="headerlink" title="ViewRootImpl创建时机"></a>ViewRootImpl创建时机</h3><p>当Activity创建时，最终是调用到<code>ActivityThread</code>的<code>handleLaunchActivity</code>来创建Activity。</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;
 ...
      <span class="hljs-comment">//创建一个Activity 会调用到onCreate()方法 从而完成DecroView的创建</span>
      Activity a = performLaunchActivity(r, customIntent);
        <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>) &#123;
            r.createdConfig = <span class="hljs-keyword">new</span> Configuration(mConfiguration);
            reportSizeConfigurations(r);
            Bundle oldState = r.state;
            
            handleResumeActivity(r.token, <span class="hljs-keyword">false</span>, r.isForward,
                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);
            ...
        &#125;
    ...
&#125;</code></pre>
<p>上述方法后续调用到了<code>handleResumeActivity()</code>,在这个方法中调用到了<code>WindowManager.addView()</code>将View传递至WindowManager</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span>
<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token,
            <span class="hljs-keyword">boolean</span> clearHide, <span class="hljs-keyword">boolean</span> isForward, <span class="hljs-keyword">boolean</span> reallyResume, <span class="hljs-keyword">int</span> seq, String reason)</span> </span>&#123;
         ActivityClientRecord r = mActivities.get(token);
        <span class="hljs-keyword">if</span> (!checkAndUpdateLifecycleSeq(seq, r, <span class="hljs-string">"resumeActivity"</span>)) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        unscheduleGcIdler();
        mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;

        <span class="hljs-comment">// 在这里会调用到生命周期中的onResume方法</span>
        r = performResumeActivity(token, clearHide, reason);
        ...
            <span class="hljs-keyword">if</span>(r!=<span class="hljs-keyword">null</span>)&#123;
                ...
                <span class="hljs-keyword">final</span> Activity a = r.activity;
                ...
                <span class="hljs-comment">//获得当前Activty的Window对象</span>
                r.window = r.activity.getWindow();
                <span class="hljs-comment">//获得当前Window的DecorView</span>
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                <span class="hljs-comment">//获得当前Activity的WindowManager对象</span>
                ViewManager wm = a.getWindowManager();
                WindowManager.LayoutParams l = r.window.getAttributes();
                a.mDecor = decor;
                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
                l.softInputMode |= forwardBit;
                <span class="hljs-keyword">if</span> (r.mPreserveWindow) &#123;
                    a.mWindowAdded = <span class="hljs-keyword">true</span>;
                    r.mPreserveWindow = <span class="hljs-keyword">false</span>;
                    ViewRootImpl impl = decor.getViewRootImpl();
                    <span class="hljs-keyword">if</span> (impl != <span class="hljs-keyword">null</span>) &#123;
                        impl.notifyChildRebuilt();
                    &#125;
                &#125;
                <span class="hljs-keyword">if</span> (a.mVisibleFromClient) &#123;
                    <span class="hljs-keyword">if</span> (!a.mWindowAdded) &#123;
                        a.mWindowAdded = <span class="hljs-keyword">true</span>;
                        <span class="hljs-comment">//将DecorView添加到PhoneWindow中</span>
                        wm.addView(decor, l);
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        a.onWindowAttributesChanged(l);
                    &#125;
                &#125;

            <span class="hljs-comment">// If the window has already been added, but during resume</span>
            <span class="hljs-comment">// we started another activity, then don't yet make the</span>
            <span class="hljs-comment">// window visible.</span>
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!willBeVisible) &#123;
                <span class="hljs-keyword">if</span> (localLOGV) Slog.v(
                    TAG, <span class="hljs-string">"Launch "</span> + r + <span class="hljs-string">" mStartedActivity set"</span>);
                r.hideForNow = <span class="hljs-keyword">true</span>;
            &#125;    
            &#125;
...
    &#125;</code></pre>
<p>后续调用到了<code>wm.addView()</code>。将对应的DecorView传递进去。</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/WindowManagerImpl.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowManagerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WindowManager</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Window mParentWindow;
    ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;
        applyDefaultToken(params);
        <span class="hljs-comment">//调用到了WindowManagerGlobal中的addView</span>
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    &#125;   
    ...
&#125;

<span class="hljs-comment">// ../android/view/WindowManagerGlobal.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow)</span> </span>&#123;
        ...

        ViewRootImpl root;
        View panelParentView = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">synchronized</span> (mLock) &#123;
            ...
            <span class="hljs-comment">//创建了ViewRootImpl实例</span>
            root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);<span class="hljs-comment">//初始化了ViewRootImpl对象</span>
            view.setLayoutParams(wparams);
            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
            <span class="hljs-comment">// do this last because it fires off messages to start doing things</span>
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">//调用setView 将传进来的DecorView添加到PhoneWindow中。 </span>
                root.setView(view, wparams, panelParentView);
            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;
                <span class="hljs-comment">// BadTokenException or InvalidDisplayException, clean up.</span>
                <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;
                    removeViewLocked(index, <span class="hljs-keyword">true</span>);
                &#125;
                <span class="hljs-keyword">throw</span> e;
            &#125;
        &#125;
    &#125;</code></pre>
<p>经过<code>ActivityThread.handleResumeActivity() -&gt; WindowManagerGlobal.addView()</code>创建了<code>ViewRootImpl</code>对象</p>
<h3 id="与DecorView的关系"><a href="#与DecorView的关系" class="headerlink" title="与DecorView的关系"></a>与DecorView的关系</h3><p>上述流程走完后，就把DecorView加载到了Window中。<strong>这个流程中将ViewRootImpl对象与DecorView进行了关联</strong>。</p>
<pre><code class="hljs java"><span class="hljs-comment">//view 表示 DecorView </span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;
     <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;
         <span class="hljs-comment">//传进来的DecorView作为全局变量使用</span>
          mView = view;
         ...
          <span class="hljs-comment">// Schedule the first layout -before- adding to the window</span>
                <span class="hljs-comment">// manager, to make sure we do the relayout before receiving</span>
                <span class="hljs-comment">// any other events from the system.</span>
          <span class="hljs-comment">//绘制整个布局</span>
          requestLayout();   
         ...
          <span class="hljs-comment">//设置ViewRootImpl为DecorView的parentView </span>
          view.assignParent(<span class="hljs-keyword">this</span>);
     &#125;   
 &#125;</code></pre>
<p>执行到<code>ViewRootImpl.setView()</code>设置<code>DecorView,assignParent(root)</code>。表示<strong>ViewRootImpl是DecorView的parent</strong>。</p>
<blockquote>
<p><code>Activity</code>、<code>Window(PhoneWindow)</code>、<code>View(DecorView)</code>、<code>ViewRootImpl</code>之间的关系？</p>
<p><code>PhoneWindow</code>是<code>Window</code>的唯一子类，在<code>Activity.attach()</code>构建的实例，是<strong>Activity与View交互的中间层</strong></p>
<p><code>DecorView</code>是<code>所有View</code>的最顶层，<code>ViewRootImpl</code>是<code>DecorView</code>的<code>parent</code>，<strong>掌管View的各种事件，例如<code>刷新、点击</code>事件等</strong></p>
</blockquote>
<h2 id="View的绘制流程触发"><a href="#View的绘制流程触发" class="headerlink" title="View的绘制流程触发"></a>View的绘制流程触发</h2><p>调用了<code>ViewRootImpl.setView(decorView)</code>将DecorView与ViewRootImpl进行了关联。View的绘制流程就是从ViewRoot开始的。</p>
<pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;
     <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;
         <span class="hljs-comment">//传进来的DecorView作为全局变量使用</span>
          mView = view;
         ...
          <span class="hljs-comment">// Schedule the first layout -before- adding to the window</span>
                <span class="hljs-comment">// manager, to make sure we do the relayout before receiving</span>
                <span class="hljs-comment">// any other events from the system.</span>
          <span class="hljs-comment">//绘制整个布局</span>
          requestLayout();   
         ...
          <span class="hljs-comment">//设置ViewRootImpl为DecorView的parentView </span>
          view.assignParent(<span class="hljs-keyword">this</span>);
     &#125;   
 &#125;

<span class="hljs-comment">//请求刷新整个布局</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;
            checkThread();
            mLayoutRequested = <span class="hljs-keyword">true</span>;
            scheduleTraversals();
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;
            mTraversalScheduled = <span class="hljs-keyword">true</span>;
            <span class="hljs-comment">//添加同步屏障</span>
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);
            <span class="hljs-keyword">if</span> (!mUnbufferedInputDispatch) &#123;
                scheduleConsumeBatchedInput();
            &#125;
            notifyRendererOfFramePending();
            pokeDrawLockIfNeeded();
        &#125;
    &#125;

    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraversalRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            doTraversal();
        &#125;
    &#125;
    <span class="hljs-keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="hljs-keyword">new</span> TraversalRunnable();

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doTraversal</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;
            mTraversalScheduled = <span class="hljs-keyword">false</span>;
            <span class="hljs-comment">//移除同步屏障</span>
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            <span class="hljs-keyword">if</span> (mProfile) &#123;
                Debug.startMethodTracing(<span class="hljs-string">"ViewAncestor"</span>);
            &#125;
            <span class="hljs-comment">//这里开始View的绘制流程</span>
            performTraversals();

            <span class="hljs-keyword">if</span> (mProfile) &#123;
                Debug.stopMethodTracing();
                mProfile = <span class="hljs-keyword">false</span>;
            &#125;
        &#125;
    &#125;</code></pre>
<p><code>ViewRootImpl.setView()</code>中最后调用到了<code>performTraversals()</code>在这个方法中开始View的绘制流程</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;
  ...
   <span class="hljs-keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);
   
   ...
   <span class="hljs-keyword">if</span> (!mStopped || mReportNextDraw) &#123;
      <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
	  <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
      ...
        <span class="hljs-keyword">if</span>(layoutRequested)&#123;
          <span class="hljs-comment">//开始Measure过程，定义View的宽高</span>
          performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
          ...
        &#125;
   &#125;
  
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);
    <span class="hljs-keyword">if</span>(didLayout)&#123;
        <span class="hljs-comment">//开始Layout过程，决定View的位置</span>
        performLayout(lp, mWidth, mHeight);
        ...
    &#125;
    
     <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;
            <span class="hljs-keyword">if</span> (mPendingTransitions != <span class="hljs-keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;
                    mPendingTransitions.get(i).startChangingAnimations();
                &#125;
                mPendingTransitions.clear();
            &#125;
            <span class="hljs-comment">//开始Draw过程，决定了View的显示，这个过程结束才可以看到内容</span>
            performDraw();
     &#125;
&#125;</code></pre>
<p>通过以上流程分析：<strong>View的绘制流程是从<code>ViewRootImpl</code>中开始的，先调用<code>performTraversals()</code>开始绘制，随后调用内部的<code>performMeasure()</code>开始Measure过程，调用<code>performLayout()</code>，开始Layout过程，最后调用<code>performDraw()</code>开始Draw，完成后就可以现在在屏幕上。</strong></p>
<p><img src="/images/View绘制流程.png" srcset="/img/loading.gif" alt="View绘制流程"></p>
<p>如上图所示，<code>performTraversals()</code>依次调用<code>performMeasure()，performLayout(),performDraw()</code>完成View的绘制。</p>
<h2 id="View工作流程"><a href="#View工作流程" class="headerlink" title="View工作流程"></a>View工作流程</h2><blockquote>
<p>主要是指<code>measure(测量)</code>,<code>layout(布局)</code>,<code>draw(绘制)</code>三大流程。</p>
</blockquote>
<h3 id="measure-测量"><a href="#measure-测量" class="headerlink" title="measure-测量"></a>measure-测量</h3><blockquote>
<p>起点位于<code>performMeasure()</code>。</p>
</blockquote>
<h4 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h4><blockquote>
<p>MeasureSpec代表一个32位int值，高2位代表SpecMode(测量模式)，低30位代表SpecSize(某种测量模式下的规格大小)。</p>
</blockquote>
<p>作用：父控件提供给子View的一个参数，作为设定自身大小参考，实际大小还是有子View自身决定。</p>
<p><img src="/images/MeasureSpec结构" srcset="/img/loading.gif" alt="MeasureSpec结构"></p>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MeasureSpec</span> </span>&#123;
       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MODE_SHIFT = <span class="hljs-number">30</span>;
       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MODE_MASK  = <span class="hljs-number">0x3</span> &lt;&lt; MODE_SHIFT;

       <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> */</span>
       <span class="hljs-meta">@IntDef</span>(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)
       <span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)
       <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MeasureSpecMode &#123;&#125;
    
     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNSPECIFIED = <span class="hljs-number">0</span> &lt;&lt; MODE_SHIFT;
     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> EXACTLY     = <span class="hljs-number">1</span> &lt;&lt; MODE_SHIFT;
     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> AT_MOST     = <span class="hljs-number">2</span> &lt;&lt; MODE_SHIFT;

     <span class="hljs-meta">@MeasureSpecMode</span>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measureSpec)</span> </span>&#123;
           <span class="hljs-comment">//noinspection ResourceType</span>
           <span class="hljs-keyword">return</span> (measureSpec &amp; MODE_MASK);
       &#125;
         
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measureSpec)</span> </span>&#123;
           <span class="hljs-keyword">return</span> (measureSpec &amp; ~MODE_MASK);
       &#125;</code></pre>
<p><code>SpecMode</code>分为三类：</p>
<ul>
<li><code>UNSPECIFIED</code>：<strong>未指定模式</strong>。父控件不对子控件家人和我束缚，子元素可以为任意大小，一般用于系统内部的测量。比如<code>ScrollView</code></li>
<li><code>EXACTLY</code>：<strong>精确模式</strong>。父控件为子View指定精确大小，希望子View完全按照自己给的尺寸处理大小。一般是设置了<code>明确的值</code>或是<code>MATCH_PARENT</code></li>
<li><code>AT_MOST</code>：<strong>最大模式</strong>。父控件为子View指定最大尺寸，希望子View不要超过这个尺寸。一般对应<code>WRAP_CONTENT</code></li>
</ul>
<h5 id="MeasureSpec与LayoutParams的关系"><a href="#MeasureSpec与LayoutParams的关系" class="headerlink" title="MeasureSpec与LayoutParams的关系"></a>MeasureSpec与LayoutParams的关系</h5><p>每一个View，都持有一个MeasureSpec，里面保存了View的尺寸。我们也可以使用<code>LayoutParams</code>指定View的尺寸。所以在View测量的时候，系统会将<code>LayoutParams</code>在父容器的约束下转换成<code>MeasureSpec</code>，然后根据转换后的值确定宽高。</p>
<p><strong>转换后的MeasureSpec是由LayoutParams和父容器的MeasureSpec一起决定的。</strong></p>
<table>
<thead>
<tr>
<th>下：childLayoutParams 右：parentSpecMode</th>
<th>EXACTLY</th>
<th>AT_MOST</th>
<th>UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>固定大小</td>
<td>Exactly<br>childSize</td>
<td>Exactly<br>childSize</td>
<td>Exactly<br>childSize</td>
</tr>
<tr>
<td>match_parent</td>
<td>Exactly<br>parentSize(父容器剩余空间)</td>
<td>AT_MOST<br>parentSize(最大父容器剩余空间)</td>
<td>UNSPECIFIED<br>0</td>
</tr>
<tr>
<td>wrap_content</td>
<td>AT_MOST<br>parentSize(最大父容器剩余空间)</td>
<td>AT_MOST<br>parentSize(最大父容器剩余空间)</td>
<td>UNSPECIFIED<br>0</td>
</tr>
</tbody>
</table>
<p>根据<code>ViewGroup.getChildMeasureSpec()</code>得出上表。</p>
<h6 id="DecorView转换MeasureSpec"><a href="#DecorView转换MeasureSpec" class="headerlink" title="DecorView转换MeasureSpec"></a>DecorView转换MeasureSpec</h6><blockquote>
<p>DecorView的转换由Window的尺寸和自身的LayoutParams决定。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewRootImpl.java</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;
    ...
       <span class="hljs-comment">//DecorView Measure过程</span>
       <span class="hljs-keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
       <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
       performMeasure(childWidthMeasureSpec,childHeightMeasureSpec)
    ...  
&#125;

<span class="hljs-comment">//在方法中生成了DecoeView的MeasureSpec 根据Window的尺寸和自身的LayoutParams</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRootMeasureSpec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> windowSize<span class="hljs-comment">/*Window尺寸*/</span>, <span class="hljs-keyword">int</span> rootDimension)</span> </span>&#123;
        <span class="hljs-keyword">int</span> measureSpec;
        <span class="hljs-keyword">switch</span> (rootDimension) &#123;
       
        <span class="hljs-keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:
            <span class="hljs-comment">//MeasureSpec中的specSize就是窗口尺寸,specMode为EXACTLY 精确模式</span>
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:
            <span class="hljs-comment">//MeasureSpec中的specSize为窗口尺寸,specMode为aT_MOST 最大模式，最大值为窗口尺寸</span>
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-comment">//MeasureSpec中的specSize为固定尺寸,specMode为EXACTLY 精确模式</span>
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">return</span> measureSpec;
    &#125;</code></pre>
<h4 id="View的measure过程"><a href="#View的measure过程" class="headerlink" title="View的measure过程"></a>View的measure过程</h4><p>主要是由<code>measure()</code>方法完成</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/View.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;
    <span class="hljs-comment">//这个类是final的，所以子类无法重写该方法</span>
    ...
    onMeasure(widthMeasureSpec,heightMeasureSpec);
    ...
    mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;<span class="hljs-comment">//不设置该标记会导致 View无法布局</span>
    ...
&#125;</code></pre>
<p>在<code>measure()</code>中调用<code>onMeasure()</code>去进行实际的测量</p>
<pre><code class="hljs java"><span class="hljs-comment">//../android/view/View.java</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;
        setMeasuredDimension(
            getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    &#125;

   <span class="hljs-comment">//设置View的宽高</span>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMeasuredDimension</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measuredWidth, <span class="hljs-keyword">int</span> measuredHeight)</span> </span>&#123;
        <span class="hljs-keyword">boolean</span> optical = isLayoutModeOptical(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;
            Insets insets = getOpticalInsets();
            <span class="hljs-keyword">int</span> opticalWidth  = insets.left + insets.right;
            <span class="hljs-keyword">int</span> opticalHeight = insets.top  + insets.bottom;

            measuredWidth  += optical ? opticalWidth  : -opticalWidth;
            measuredHeight += optical ? opticalHeight : -opticalHeight;
        &#125;
        setMeasuredDimensionRaw(measuredWidth, measuredHeight);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMeasuredDimensionRaw</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measuredWidth, <span class="hljs-keyword">int</span> measuredHeight)</span> </span>&#123;
        mMeasuredWidth = measuredWidth;
        mMeasuredHeight = measuredHeight;
        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
    &#125;

    <span class="hljs-comment">//返回View的MeasureSpec中的specSize</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDefaultSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> measureSpec)</span> </span>&#123;
        <span class="hljs-keyword">int</span> result = size;
        <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);
        <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);

        <span class="hljs-keyword">switch</span> (specMode) &#123;
        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:
            result = size;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<span class="hljs-comment">//wrap_content</span>
        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<span class="hljs-comment">//match_parent / XX </span>
        <span class="hljs-comment">//这段代码中可以分析得出 一个直接继承View的自定义View 定义为wrap_content和match_parent大小都是一致的.</span>
            result = specSize;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuggestedMinimumHeight</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (mBackground == <span class="hljs-keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());
    &#125;

<span class="hljs-comment">//如果View没有设置背景，返回minWidth值，默认为0。若设置了背景就取背景宽度和最小宽度中的最大值返回。</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuggestedMinimumWidth</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (mBackground == <span class="hljs-keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
    &#125;

    
<span class="hljs-comment">// ../android/graphics/drawable/Drawable.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumWidth</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> intrinsicWidth = getIntrinsicWidth();
    <span class="hljs-keyword">return</span> intrinsicWidth &gt; <span class="hljs-number">0</span> ? intrinsicWidth : <span class="hljs-number">0</span>;
&#125;</code></pre>
<p><img src="/images/View-Measure.png" srcset="/img/loading.gif" alt="View-Measure"></p>
<p>结合上述流程图，简单分析View的Measure过程</p>
<ul>
<li>系统在绘制开始时回去调用<code>View.measure()</code>，这个类是final的们无法被重写</li>
<li>后续调用<code>View.onMeasure()</code>,自定义View时可以按照自己的需求对这个方法进行重写</li>
<li><code>onMeasure()</code>中调用到<code>setMeasureDimension()</code>对View进行宽高的设置</li>
<li>需要使用<code>getDefaultSize()</code>去获取最终显示出的宽高</li>
<li>在<code>getDefaultSize()</code>中需要对传进来的<code>MeasureSpec</code>进行分析处理<ul>
<li>SpecMode若为<code>UNSPECIFIED</code>，则最终尺寸为传进来的<code>SpecSize</code></li>
<li>SpecMode为<code>AT_MOST</code>,<code>EXACTLY</code>，还需要额外判断View是否有背景<ul>
<li>有背景，最终尺寸就为View的最小尺寸和背景尺寸的最大值</li>
<li>没背景，最终尺寸就为View的最小尺寸</li>
</ul>
</li>
</ul>
</li>
<li>取到最终尺寸后，数据回溯到<code>onMeasure()</code>中，即完成测量(<code>Measure</code>)过程</li>
</ul>
<p>在上述分析中，自定义View中使用<code>wrap_content</code>时，specMode为<code>AT_MOST</code>，尺寸为父控件剩余大小，效果与使用<code>match_parent</code>一致。这也是自定义View中常碰到的问题 <em>为何自定义View是wrap_content无效？</em> 解决方法就是 自己重写<code>onMeasure()</code>对<code>wrap_content</code>特殊处理。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec,<span class="hljs-keyword">int</span> heightMeasureSpec)</span></span>&#123;
    <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec,heightMeasureSpec);
    <span class="hljs-keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
    <span class="hljs-keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
    <span class="hljs-keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
    <span class="hljs-keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
    
    <span class="hljs-keyword">if</span>(widthSpecMode = MeasureSpec.AT_MOST &amp;&amp; heightSpecMode = MeasureSpec.AT_MOST)&#123;
        setMeasureDimension(mWidth,mHeight);
    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(widthSpecMode = MeasureSpec.AT_MOST)&#123;
        setMeasureDimension(mWidth,heightSpecSize);
    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(heightSpecMode = MeasureSpec.AT_MOST)&#123;
        setMeasureDimension(widthSpecSize,mHeight);
    &#125;
    
&#125;</code></pre>
<h4 id="ViewGroup的measure过程"><a href="#ViewGroup的measure过程" class="headerlink" title="ViewGroup的measure过程"></a>ViewGroup的measure过程</h4><blockquote>
<p>除了完成自身的measure过程之外，还要去遍历调用所有子元素的measure方法，各个子元素再去递归执行这个过程。</p>
<p><strong>先Measure子View，再Measure自己</strong></p>
</blockquote>
<p>ViewGroup中没有定义<code>onMeasure()</code>，定义了一个<code>measureChildren()</code>。</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewGroup.java</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = mChildrenCount;
        <span class="hljs-keyword">final</span> View[] children = mChildren;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;
            <span class="hljs-keyword">final</span> View child = children[i];
            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;
                <span class="hljs-comment">//遍历对每一个子元素进行测量过程</span>
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
            &#125;
        &#125;
    &#125;</code></pre>
<p>循环调用<code>measureChild()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewGroup.java</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChild</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> parentWidthMeasureSpec,
            <span class="hljs-keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;
        <span class="hljs-comment">//获得子View的LayoutParams</span>
        <span class="hljs-keyword">final</span> LayoutParams lp = child.getLayoutParams();
        <span class="hljs-comment">//</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight, lp.width);
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    &#125;

 <span class="hljs-comment">//子View的MEasureSpec由父View的MEasureSpec以及自身的LayoutParams共同决定</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getChildMeasureSpec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> spec, <span class="hljs-keyword">int</span> padding, <span class="hljs-keyword">int</span> childDimension)</span> </span>&#123;
        <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(spec);
        <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(spec);

        <span class="hljs-comment">//padding代指父View已占用的空间，子View无法使用，所以子View的空间需要减去padding部分</span>
        <span class="hljs-keyword">int</span> size = Math.max(<span class="hljs-number">0</span>, specSize - padding);

        <span class="hljs-keyword">int</span> resultSize = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> resultMode = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">switch</span> (specMode) &#123;
        <span class="hljs-comment">// Parent has imposed an exact size on us</span>
        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:
            <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;
                <span class="hljs-comment">// Child wants to be our size. So be it.</span>
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;
                <span class="hljs-comment">// Child wants to determine its own size. It can't be</span>
                <span class="hljs-comment">// bigger than us.</span>
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            &#125;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-comment">// Parent has imposed a maximum size on us</span>
        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:
            <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// Child wants a specific size... so be it</span>
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;
                <span class="hljs-comment">// Child wants to be our size, but our size is not fixed.</span>
                <span class="hljs-comment">// Constrain child to not be bigger than us.</span>
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;
                <span class="hljs-comment">// Child wants to determine its own size. It can't be</span>
                <span class="hljs-comment">// bigger than us.</span>
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            &#125;
            <span class="hljs-keyword">break</span>;

        <span class="hljs-comment">// Parent asked to see how big we want to be</span>
        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:
            <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// Child wants a specific size... let him have it</span>
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;
                <span class="hljs-comment">// Child wants to be our size... find out how big it should</span>
                <span class="hljs-comment">// be</span>
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;
                <span class="hljs-comment">// Child wants to determine its own size.... find out how</span>
                <span class="hljs-comment">// big it should be</span>
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            &#125;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-comment">//noinspection ResourceType</span>
        <span class="hljs-keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    &#125;</code></pre>
<p>由于ViewGroup有不同布局的需要，很难统一，所以没有提供统一的<code>onMeasure()</code>方法，而是让子类自己去实现<code>onMeasure()</code>。</p>
<p><img src="/images/ViewGroup-Measure.png" srcset="/img/loading.gif" alt="ViewGroup-Measure"></p>
<p>根据上述流程图，简单总结一下：</p>
<ul>
<li>ViewGroup调用自身的<code>measureChildren()</code>，里面遍历自己的子View</li>
<li>遍历后调用<code>measureChild()</code>，准备给每一个子View计算它的<code>MeasureSpec</code></li>
<li>调用<code>getChildMeasureSpec()</code>计算子View的<code>MeasureSpec</code>，需要结合父布局的<code>MeasureSpec</code>以及子View的<code>LayoutParams</code>共同得出结果</li>
<li>调用子View的<code>measure()</code>，完成子View的测量过程。</li>
<li>合并子View的测量值，得到ViewGroup的测量值</li>
</ul>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol>
<li>在Activity启动时获取View的尺寸？<ul>
<li>在 Activity#onWindowFocusChanged 回调中获取宽高。<br><code>当Activity得到焦点或失去焦点的时候，这个方法都会被频繁调用</code></li>
<li>view.post(runnable)，在 runnable 中获取宽高。<br><code>利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。</code></li>
<li>ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。<br><code>监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露</code></li>
<li>调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高<br><code>手动对view进行measure来得到View的尺寸。</code></li>
</ul>
</li>
</ol>
<h3 id="layout-布局"><a href="#layout-布局" class="headerlink" title="layout-布局"></a>layout-布局</h3><blockquote>
<p>ViewGroup用来确定子元素的位置，当ViewGroup位置被确定后，在<code>onLayout()</code>中遍历所有子View，并调用其<code>layout()</code>。</p>
<p><strong>先layout自身后layout子元素。</strong></p>
</blockquote>
<h4 id="View的layout过程"><a href="#View的layout过程" class="headerlink" title="View的layout过程"></a>View的layout过程</h4><p>主要是由View的<code>layout()</code>方法实现</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/View.java   </span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;
        <span class="hljs-keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="hljs-number">0</span>) &#123;
            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        &#125;
        
        <span class="hljs-comment">//左上角顶点距父容器左边的距离</span>
        <span class="hljs-keyword">int</span> oldL = mLeft;
        <span class="hljs-comment">//左上角顶点距父容器上边的距离</span>
        <span class="hljs-keyword">int</span> oldT = mTop;
        <span class="hljs-comment">//右下角顶点距父容器上边的距离</span>
        <span class="hljs-keyword">int</span> oldB = mBottom;
        <span class="hljs-comment">//右下角顶点距父容器上边的距离</span>
        <span class="hljs-keyword">int</span> oldR = mRight;
        <span class="hljs-comment">//</span>
        <span class="hljs-keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?
                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

        <span class="hljs-keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;
            onLayout(changed, l, t, r, b);
            ...
        &#125;
        ...
    &#125;

<span class="hljs-comment">//由于子View下是没有子类了，所以该方法内不没有任何代码实现 一般自定义View是不需要重写该方法的</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;
    
    &#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setOpticalFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;
        Insets parentInsets = mParent <span class="hljs-keyword">instanceof</span> View ?
                ((View) mParent).getOpticalInsets() : Insets.NONE;
        Insets childInsets = getOpticalInsets();
        <span class="hljs-comment">//根据特效边框重新计算四个顶点的位置，然后调用setFrame重新计算</span>
        <span class="hljs-keyword">return</span> setFrame(
                left   + parentInsets.left - childInsets.left,
                top    + parentInsets.top  - childInsets.top,
                right  + parentInsets.left + childInsets.right,
                bottom + parentInsets.top  + childInsets.bottom);
    &#125;

<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;
             <span class="hljs-keyword">boolean</span> changed = <span class="hljs-keyword">false</span>;

        <span class="hljs-keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;
            changed = <span class="hljs-keyword">true</span>;

            <span class="hljs-comment">// Remember our drawn bit</span>
            <span class="hljs-keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;

            <span class="hljs-keyword">int</span> oldWidth = mRight - mLeft;
            <span class="hljs-keyword">int</span> oldHeight = mBottom - mTop;
            <span class="hljs-keyword">int</span> newWidth = right - left;
            <span class="hljs-keyword">int</span> newHeight = bottom - top;
            <span class="hljs-keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);

            <span class="hljs-comment">// Invalidate our old position</span>
            invalidate(sizeChanged);
            <span class="hljs-comment">//重新计算View的四个顶点距父布局左上边框的距离</span>
            mLeft = left;
            mTop = top;
            mRight = right;
            mBottom = bottom;
            mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);
            ...
        &#125;
&#125;


<span class="hljs-comment">//判断当前View是否存在阴影或者外发光等边框效果</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLayoutModeOptical</span><span class="hljs-params">(Object o)</span> </span>&#123;
        <span class="hljs-keyword">return</span> o <span class="hljs-keyword">instanceof</span> ViewGroup &amp;&amp; ((ViewGroup) o).isLayoutModeOptical();
    &#125;</code></pre>
<p><img src="/images/View-Layout.png" srcset="/img/loading.gif" alt="View-Layout"></p>
<p>按照流程图总结一下：</p>
<ul>
<li>View调用<code>layout()</code>开始布局过程(<code>确定最终宽高以及四个顶点的位置</code>)</li>
<li>根据是否有边缘效果(<code>例如发光，阴影</code>)<ul>
<li>有边缘效果，调用<code>setOpticalFrame()</code>去除边缘的影响，最终还是调用<code>setFrame()</code>设立自己的四个顶点</li>
<li>无边缘效果，调用<code>setFrame()</code>设立自己的四个顶点</li>
</ul>
</li>
<li>最后调用<code>onLayout()</code>最终确立宽高以及四点坐标。</li>
</ul>
<h4 id="ViewGroup的layout过程"><a href="#ViewGroup的layout过程" class="headerlink" title="ViewGroup的layout过程"></a>ViewGroup的layout过程</h4><p>当有子View存在的时候，需要遍历子View进行<code>layout</code>过程。即需要在<code>onLayout()</code>方法实现子View的<code>layout</code>。</p>
<pre><code class="hljs java"><span class="hljs-comment">//源码与上述相同 由于ViewGroup中所有子View的layout都需要实现，所以需要实现 onLayout() 方法</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> top,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> bottom)</span></span>&#123;
    <span class="hljs-comment">//遍历子View</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ; i &lt;getChildCount();i++)&#123;
        View child = getChildAt(i);
        
        <span class="hljs-comment">//在这里可以添加 顶点变化逻辑</span>
        <span class="hljs-keyword">int</span> childTop = Top;
        <span class="hljs-keyword">int</span> childLeft = Left;
        <span class="hljs-keyword">int</span> childBottom = Bottom;
        <span class="hljs-keyword">int</span> childRight = Right;
         
        ...
        setChildFrame(child,childLeft,childTop,childRight,childBottom);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChildFrame</span><span class="hljs-params">(child,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> b)</span></span>&#123;
    <span class="hljs-comment">//按照上一节流程走</span>
    child.layout(l,t,r,b);
&#125;</code></pre>
<p><img src="/images/ViewGroup-Layout.png" srcset="/img/loading.gif" alt="ViewGroup-Layout"></p>
<p>按照流程图简单总结一下：</p>
<ul>
<li>先调用ViewGroup的<code>layout()</code>，先对ViewGroup进行布局过程</li>
<li>在ViewGroup的<code>onLayout()</code>中实现子View的遍历布局过程</li>
<li>对遍历的子View按照ViewGroup的要求进行顶点坐标的计算，计算完成后调用子View的<code>layout()</code></li>
</ul>
<p>拓展：</p>
<ol>
<li><p>View的测量宽/高(<code>getMeasureWidth()/getMeasureHeight()</code>)与最终得到的宽/高(<code>getWidth()/getHeight()</code>)有什么区别？</p>
<pre><code class="hljs java"><span class="hljs-comment">//	获得View在测量过程中的宽</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMeasuredWidth</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;
    &#125;
<span class="hljs-comment">//	获得View在测量过程中的高</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMeasuredHeight</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> mMeasuredHeight &amp; MEASURED_SIZE_MASK;
    &#125;
<span class="hljs-comment">//	上节 measure 源码分析中就是调用了该方法 进行View的测量</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMeasuredDimensionRaw</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measuredWidth, <span class="hljs-keyword">int</span> measuredHeight)</span> </span>&#123;
        mMeasuredWidth = measuredWidth;
        mMeasuredHeight = measuredHeight;
        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
    &#125;
<span class="hljs-comment">//获得View最终宽</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> mRight - mLeft;
    &#125;
<span class="hljs-comment">//获得View最终高</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> mBottom - mTop;
    &#125;</code></pre>
<blockquote>
<p>两者的比较</p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th>何时赋值</th>
<th>赋值方法</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">View测量结束宽/高<br>getMeasureWidth()/getMeasureHeight()</td>
<td>View的<code>measure</code>过程</td>
<td><code>setMeasureDimension()</code></td>
<td>在<code>onLayout()</code>获取View的宽/高</td>
</tr>
<tr>
<td style="text-align:left">View最终宽/高<br>getWidth()/getHeight()</td>
<td>View的<code>layout</code>过程</td>
<td><code>layout()</code>对top,left,right,bottom进行操作</td>
<td><code>onLayout()</code>结束后获取最终宽/高</td>
</tr>
</tbody>
</table>
<p>   <strong>一般情况下，二者返回的数据是相同的，除非人为对View的<code>layout()</code>进行重写。</strong></p>
   <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> b)</span></span>&#123;
    <span class="hljs-keyword">super</span>.layout(j,t,r+<span class="hljs-number">100</span>,b+<span class="hljs-number">100</span>);
&#125;</code></pre>
<p>   上述代码就会导致View最终结果与测量时不同。</p>
<h3 id="draw-绘制"><a href="#draw-绘制" class="headerlink" title="draw-绘制"></a>draw-绘制</h3><blockquote>
<p>draw作用主要将View绘制在屏幕上面</p>
<p><strong>draw过程，先draw自身再draw子View</strong></p>
</blockquote>
<h4 id="View的draw过程"><a href="#View的draw过程" class="headerlink" title="View的draw过程"></a>View的draw过程</h4><p>View的draw过程，从<code>View.draw()</code>开始</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/View.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
    <span class="hljs-comment">//标记当前View是否需要绘制背景</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;
                (mAttachInfo == <span class="hljs-keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);
    
    <span class="hljs-keyword">int</span> saveCount;
        <span class="hljs-comment">//1. 绘制背景</span>
    <span class="hljs-keyword">if</span> (!dirtyOpaque) &#123;
            drawBackground(canvas);
        &#125;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> viewFlags = mViewFlags;
    <span class="hljs-comment">//是否有水平边缘</span>
    <span class="hljs-keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="hljs-number">0</span>;
    <span class="hljs-comment">//是否有竖直边缘</span>
    <span class="hljs-keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(!horizontalEdges &amp;&amp; !verticalEdges)&#123;
       <span class="hljs-comment">// 3.绘制View本身</span>
          <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);

       <span class="hljs-comment">// 4.绘制子View</span>
          dispatchDraw(canvas);
        
       <span class="hljs-comment">// 6.绘制装饰 例如滚动条</span>
          onDrawForeground(canvas);
        
    ...
       <span class="hljs-keyword">return</span>; 
    &#125;
    
    <span class="hljs-comment">//如果有竖直边缘或者水平边缘 例如divide</span>
    
    <span class="hljs-comment">// 2. 保存当前Canvas层</span>
        saveCount = canvas.getSaveCount();
        <span class="hljs-keyword">int</span> solidColor = getSolidColor();
        <span class="hljs-keyword">if</span> (solidColor == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
            <span class="hljs-keyword">if</span> (drawTop) &#123;
                canvas.saveLayer(left, top, right, top + length, <span class="hljs-keyword">null</span>, flags);
            &#125;
            <span class="hljs-keyword">if</span> (drawBottom) &#123;
                canvas.saveLayer(left, bottom - length, right, bottom, <span class="hljs-keyword">null</span>, flags);
            &#125;
            <span class="hljs-keyword">if</span> (drawLeft) &#123;
                canvas.saveLayer(left, top, left + length, bottom, <span class="hljs-keyword">null</span>, flags);
            &#125;
            <span class="hljs-keyword">if</span> (drawRight) &#123;
                canvas.saveLayer(right - length, top, right, bottom, <span class="hljs-keyword">null</span>, flags);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            scrollabilityCache.setFadeColor(solidColor);
        &#125;
    ...
        <span class="hljs-comment">// 3.绘制View本身</span>
          <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);

       <span class="hljs-comment">// 4.绘制子View</span>
          dispatchDraw(canvas);
    
    ...
        <span class="hljs-comment">// 5.绘制边缘效果 例如阴影</span>
        canvas.restoreToCount(saveCount);
    ...
        
       <span class="hljs-comment">// 6.绘制装饰 例如滚动条</span>
          onDrawForeground(canvas);
    ...
    
&#125;

<span class="hljs-comment">//绘制View本身的背景</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawBackground</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
        <span class="hljs-keyword">final</span> Drawable background = mBackground;
        <span class="hljs-keyword">if</span> (background == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-comment">//设置View的背景边界</span>
        setBackgroundBounds();
        ...
          
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrollX = mScrollX;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrollY = mScrollY;
        <span class="hljs-keyword">if</span> ((scrollX | scrollY) == <span class="hljs-number">0</span>) &#123;
            background.draw(canvas);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">//将画布偏移 然后在偏移后的画布上进行背景绘制</span>
            canvas.translate(scrollX, scrollY);
            background.draw(canvas);
            canvas.translate(-scrollX, -scrollY);
        &#125;
    &#125;

<span class="hljs-comment">//绘制View本身的内容</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
    <span class="hljs-comment">// 默认空实现 需要子类复写该方法以实现内容的绘制 ，自定义View中必须执行该方法</span>
    &#125;

<span class="hljs-comment">//绘制子View的内容</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
    <span class="hljs-comment">//由于View不存在子View，所以不需要实现</span>
    &#125;

<span class="hljs-comment">//绘制装饰 例如滚动条 前景图片</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDrawForeground</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
        onDrawScrollIndicators(canvas);
        onDrawScrollBars(canvas);

        <span class="hljs-keyword">final</span> Drawable foreground = mForegroundInfo != <span class="hljs-keyword">null</span> ? mForegroundInfo.mDrawable : <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">if</span> (foreground != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (mForegroundInfo.mBoundsChanged) &#123;
                mForegroundInfo.mBoundsChanged = <span class="hljs-keyword">false</span>;
                <span class="hljs-keyword">final</span> Rect selfBounds = mForegroundInfo.mSelfBounds;
                <span class="hljs-keyword">final</span> Rect overlayBounds = mForegroundInfo.mOverlayBounds;

                <span class="hljs-keyword">if</span> (mForegroundInfo.mInsidePadding) &#123;
                    selfBounds.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, getWidth(), getHeight());
                &#125; <span class="hljs-keyword">else</span> &#123;
                    selfBounds.set(getPaddingLeft(), getPaddingTop(),
                            getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());
                &#125;

                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ld = getLayoutDirection();
                Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),
                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);
                foreground.setBounds(overlayBounds);
            &#125;

            foreground.draw(canvas);
        &#125;
    &#125;</code></pre>
<p><img src="/images/View-Draw.png" srcset="/img/loading.gif" alt="View-Draw"></p>
<p>结合上述流程图分析Draw过程：</p>
<ul>
<li>先调用<code>View.draw()</code>方法开始Draw流程</li>
<li>如果需要<code>dirtyOpaque</code>，就绘制背景<code>drawBackground()</code></li>
<li>如果需要显示边缘效果，就进行保存画布<code>canvas.saveLayer()</code></li>
<li>如果需要<code>dirtyOpaque</code>，绘制自身的内容<code>onDraw()</code> – <strong>自定义View必须实现</strong></li>
<li>调用<code>dispatchDraw()</code>绘制子View</li>
<li>如果需要显示边缘效果，绘制后，还原画布<code>canvas.restore()</code></li>
<li>调用<code>drawForeground()</code>绘制装饰，例如滚动条或前景</li>
</ul>
<h4 id="ViewGroup的draw过程"><a href="#ViewGroup的draw过程" class="headerlink" title="ViewGroup的draw过程"></a>ViewGroup的draw过程</h4><p>ViewGroup的draw过程主要调整了上述源码中的<code>dispatchDraw()</code>，在其内部进行了子View的遍历以及绘制过程</p>
<pre><code class="hljs java"> <span class="hljs-comment">// ../android/view/ViewGroup.java</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
        <span class="hljs-keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childrenCount = mChildrenCount;
        <span class="hljs-keyword">final</span> View[] children = mChildren;
    ...
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;
            <span class="hljs-keyword">while</span> (transientIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;
                <span class="hljs-keyword">final</span> View transientChild = mTransientViews.get(transientIndex);
                <span class="hljs-keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||
                        transientChild.getAnimation() != <span class="hljs-keyword">null</span>) &#123;
                    more |= drawChild(canvas, transientChild, drawingTime);
                &#125;
                transientIndex++;
                <span class="hljs-keyword">if</span> (transientIndex &gt;= transientCount) &#123;
                    transientIndex = -<span class="hljs-number">1</span>;
                &#125;
            &#125;

            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;
                more |= drawChild(canvas, child, drawingTime);
            &#125;
        &#125;
    ...
&#125;

<span class="hljs-comment">//绘制子View</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">drawChild</span><span class="hljs-params">(Canvas canvas, View child, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;
      <span class="hljs-comment">//调用子View的draw方法</span>
      <span class="hljs-keyword">return</span> child.draw(canvas, <span class="hljs-keyword">this</span>, drawingTime);
&#125;</code></pre>
<p><img src="/images/ViewGroup-Draw.png" srcset="/img/loading.gif" alt="ViewGroup-Draw"></p>
<p>结合上述流程图分析ViewGroup的Draw过程：</p>
<ul>
<li>draw过程与上述<code>View的draw过程一致</code></li>
<li><code>dispatchDraw()</code>默认实现，内部包含了子View的遍历以及绘制</li>
</ul>
<p>拓展：</p>
<ol>
<li><p><code>View.setWillNotDraw()</code>有什么意义?</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWillNotDraw</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> willNotDraw)</span> </span>&#123;
    <span class="hljs-comment">//设置 不需绘制 标记位</span>
    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="hljs-number">0</span>, DRAW_MASK);
&#125;</code></pre>
<p>如果一个View不需要绘制任何内容，设置这个标记为<code>true</code>，系统就会进行相应优化。</p>
<p><strong><em>View默认不开启<code>willNotDraw</code>标记位，ViewGroup默认开启。</em></strong></p>
</li>
<li><p><code>ViewGroup</code>修改子View绘制顺序</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(Canvas canvas)</span></span>&#123;
  ...
    <span class="hljs-comment">//设置自定义绘制顺序</span>
   <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties
                ? <span class="hljs-keyword">null</span> : buildOrderedChildList();
        <span class="hljs-comment">//是否允许自定义绘制顺序</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = preorderedList == <span class="hljs-keyword">null</span>
                &amp;&amp; isChildrenDrawingOrderEnabled();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;
            <span class="hljs-keyword">while</span> (transientIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;
                <span class="hljs-keyword">final</span> View transientChild = mTransientViews.get(transientIndex);
                <span class="hljs-keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||
                        transientChild.getAnimation() != <span class="hljs-keyword">null</span>) &#123;
                    more |= drawChild(canvas, transientChild, drawingTime);
                &#125;
                transientIndex++;
                <span class="hljs-keyword">if</span> (transientIndex &gt;= transientCount) &#123;
                    transientIndex = -<span class="hljs-number">1</span>;
                &#125;
            &#125;

            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;
                more |= drawChild(canvas, child, drawingTime);
            &#125;
        &#125;
  ...
&#125;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isChildrenDrawingOrderEnabled</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> (mGroupFlags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == FLAG_USE_CHILD_DRAWING_ORDER;
    &#125;
<span class="hljs-comment">//设置是否允许自定义绘制顺序</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChildrenDrawingOrderEnabled</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> enabled)</span> </span>&#123;
        setBooleanFlag(FLAG_USE_CHILD_DRAWING_ORDER, enabled);
    &#125;

 <span class="hljs-comment">//初始子View的绘制顺序 按照z轴的值调整绘制顺序，z轴从大到小绘制</span>
    <span class="hljs-function">ArrayList&lt;View&gt; <span class="hljs-title">buildOrderedChildList</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childrenCount = mChildrenCount;
        <span class="hljs-keyword">if</span> (childrenCount &lt;= <span class="hljs-number">1</span> || !hasChildWithZ()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">if</span> (mPreSortedChildren == <span class="hljs-keyword">null</span>) &#123;
            mPreSortedChildren = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(childrenCount);
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// callers should clear, so clear shouldn't be necessary, but for safety...</span>
            mPreSortedChildren.clear();
            mPreSortedChildren.ensureCapacity(childrenCount);
        &#125;

        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = isChildrenDrawingOrderEnabled();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;
            <span class="hljs-comment">// add next child (in child order) to end of list</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            <span class="hljs-keyword">final</span> View nextChild = mChildren[childIndex];
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> currentZ = nextChild.getZ();

            <span class="hljs-comment">// insert ahead of any Views with greater Z</span>
            <span class="hljs-keyword">int</span> insertIndex = i;
            <span class="hljs-keyword">while</span> (insertIndex &gt; <span class="hljs-number">0</span> &amp;&amp; mPreSortedChildren.get(insertIndex - <span class="hljs-number">1</span>).getZ() &gt; currentZ) &#123;
                insertIndex--;
            &#125;
            mPreSortedChildren.add(insertIndex, nextChild);
        &#125;
        <span class="hljs-keyword">return</span> mPreSortedChildren;
    &#125;

    <span class="hljs-comment">//确定当前子View的绘制顺序</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndVerifyPreorderedIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> childrenCount, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">boolean</span> customOrder)</span> </span>&#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex;
        <span class="hljs-keyword">if</span> (customOrder) &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex1 = getChildDrawingOrder(childrenCount, i);
            <span class="hljs-keyword">if</span> (childIndex1 &gt;= childrenCount) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"getChildDrawingOrder() "</span>
                        + <span class="hljs-string">"returned invalid index "</span> + childIndex1
                        + <span class="hljs-string">" (child count is "</span> + childrenCount + <span class="hljs-string">")"</span>);
            &#125;
            childIndex = childIndex1;
        &#125; <span class="hljs-keyword">else</span> &#123;
            childIndex = i;
        &#125;
        <span class="hljs-keyword">return</span> childIndex;
    &#125;
<span class="hljs-comment">//需要重写该方法，调整绘制顺序</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getChildDrawingOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> childCount, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
        <span class="hljs-keyword">return</span> i;
    &#125;

<span class="hljs-comment">//调整当前子View顺序</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> View <span class="hljs-title">getAndVerifyPreorderedView</span><span class="hljs-params">(ArrayList&lt;View&gt; preorderedList, View[] children,
            <span class="hljs-keyword">int</span> childIndex)</span> </span>&#123;
        <span class="hljs-keyword">final</span> View child;
        <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-keyword">null</span>) &#123;
            child = preorderedList.get(childIndex);
            <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Invalid preorderedList contained null child at index "</span>
                        + childIndex);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            child = children[childIndex];
        &#125;
        <span class="hljs-keyword">return</span> child;
    &#125;</code></pre>
</li>
</ol>
<p>   根据上述源码，默认的绘制<strong>按照z轴从大到小的顺序</strong>进行绘制，如果需要修改绘制顺序的话，需要执行以下两步：</p>
<ol>
<li><code>setChildrenDrawingEnabled(true)</code>打开自定义设置开关</li>
<li><p>继承<code>ViewGroup</code>后，重写<code>getChildDrawingOrder()</code>方法，设置对应的绘制顺序</p>
<p>常用的<code>RecyclerView</code>、<code>ViewPager</code>都实现了该方法，其中<code>RecyclerView</code>通过设置<code>ChildDrawingOrderCallback</code>也可以实现这个功能。</p>
</li>
</ol>
<h2 id="自定义View-1"><a href="#自定义View-1" class="headerlink" title="自定义View"></a>自定义View</h2><blockquote>
<p>自定义View需要了解View的层次、View的事件分发机制以及View的工作流程。</p>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="1-继承View重写onDraw"><a href="#1-继承View重写onDraw" class="headerlink" title="1.继承View重写onDraw()"></a>1.继承View重写<code>onDraw()</code></h4><blockquote>
<p>主要用于实现一些不规则的效果，不方便通过布局的组合方法可以直接实现，往往需要静态或者动态的显示一些不规则图形(圆形啥的)。</p>
<p>特殊形状的这种就需要重写<code>onDraw()</code>实现。<strong>一般需要额外支持wrtap_content，并且也需要处理padding方法。</strong></p>
</blockquote>
<h4 id="2-继承ViewGroup派生特殊的Layout"><a href="#2-继承ViewGroup派生特殊的Layout" class="headerlink" title="2.继承ViewGroup派生特殊的Layout"></a>2.继承ViewGroup派生特殊的Layout</h4><blockquote>
<p>主要用于实现自定义的布局，除了常用的一些布局外。实现的是几种View的组合形式</p>
<p><strong>实现稍微复杂，需要合适的处理ViewGroup的<code>onMeasure()，onLayout()</code>以及子View的<code>onMeasure()，onLayout()</code></strong></p>
</blockquote>
<h4 id="3-继承特定的View-例如TextView"><a href="#3-继承特定的View-例如TextView" class="headerlink" title="3.继承特定的View(例如TextView)"></a>3.继承特定的View(例如TextView)</h4><blockquote>
<p>这种比较常见，一般用于拓展已有View的功能。</p>
<p><strong>实现比较简单，无需自己处理wrap_content以及padding</strong></p>
</blockquote>
<h4 id="4-继承特定的ViewGroup-例如LinearLayout"><a href="#4-继承特定的ViewGroup-例如LinearLayout" class="headerlink" title="4.继承特定的ViewGroup(例如LinearLayout)"></a>4.继承特定的ViewGroup(例如LinearLayout)</h4><blockquote>
<p>比较常见，当某种效果看起来很像几种View组合在一起的时候</p>
<p><strong>实现比较简单，无需自己处理测量以及布局过程</strong></p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-让View支持wrap-content"><a href="#1-让View支持wrap-content" class="headerlink" title="1.让View支持wrap_content"></a>1.让View支持wrap_content</h4><blockquote>
<p>直接继承View或ViewGroup的控件，不重写<code>onMeasure()</code>并对<code>AT_MOST</code>进行处理，就无法达到需要的显示效果。</p>
</blockquote>
<h4 id="2-需要的话，让View支持padding"><a href="#2-需要的话，让View支持padding" class="headerlink" title="2.需要的话，让View支持padding"></a>2.需要的话，让View支持padding</h4><blockquote>
<p>直接继承View的控件，需要在<code>draw</code>过程处理padding属性，不然padding属性无法起作用。</p>
<p>直接继承ViewGroup的控件，需要在<code>onMeasure()，onLayout()</code>处理自身的padding以及子View的margin</p>
</blockquote>
<h4 id="3-尽量不要在View中使用Handler"><a href="#3-尽量不要在View中使用Handler" class="headerlink" title="3.尽量不要在View中使用Handler"></a>3.尽量不要在View中使用Handler</h4><blockquote>
<p>View内部提供了<code>post</code>方法，可以替代Handler使用</p>
</blockquote>
<h4 id="4-View中如果有线程或动画，需要及时停止"><a href="#4-View中如果有线程或动画，需要及时停止" class="headerlink" title="4.View中如果有线程或动画，需要及时停止"></a>4.View中如果有线程或动画，需要及时停止</h4><blockquote>
<ol>
<li>不处理有可能造成内存泄漏，View不可见时也需要停止线程和动画</li>
<li>包含View的Activity启动时，View的<code>onAccachedToWindow()</code>会调用</li>
<li>包含View的Activity退出或当前View被移除时，调用<code>View.onDetachedFromWindow()</code>时关闭线程和动画</li>
</ol>
</blockquote>
<h4 id="5-View若有滑动冲突情况，需要处理"><a href="#5-View若有滑动冲突情况，需要处理" class="headerlink" title="5.View若有滑动冲突情况，需要处理"></a>5.View若有滑动冲突情况，需要处理</h4><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><a href="/2019/01/02/自定义View实践/" title="自定义View实践">自定义View实践</a>
<a href="/2019/01/02/自定义ViewGroup实践/" title="自定义ViewGroup实践">自定义ViewGroup实践</a>
<h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><h3 id="如何触发View的重新绘制？"><a href="#如何触发View的重新绘制？" class="headerlink" title="如何触发View的重新绘制？"></a>如何触发View的重新绘制？</h3><p>通过调用<code>invalidate()/postInvalidate()</code>或<code>requestLayout()</code>实现。</p>
<h4 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h4><blockquote>
<p>在需要刷新<code>View</code>的布局时会调用该函数。不应该在布局的过程中调用这个函数。</p>
<p>这个请求可能会在以下场景执行：当前布局结束、当前帧绘制完成，下次布局发生时</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//View.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mMeasureCache != <span class="hljs-keyword">null</span>) mMeasureCache.clear();

        <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// Only trigger request-during-layout logic if this is the view requesting it,</span>
            <span class="hljs-comment">// not the views in its parent hierarchy</span>
            ViewRootImpl viewRoot = getViewRootImpl();
            <span class="hljs-keyword">if</span> (viewRoot != <span class="hljs-keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;
                <span class="hljs-keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="hljs-keyword">this</span>)) &#123;
                  <span class="hljs-comment">//如果当前在layout过程中，且调用了 requestLayout，就需要直接返回</span>
                  <span class="hljs-comment">//等待下一次信号到来时执行</span>
                    <span class="hljs-keyword">return</span>;
                &#125;
            &#125;
            mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">this</span>;
        &#125;
        <span class="hljs-comment">//设置强制刷新标记</span>
        mPrivateFlags |= PFLAG_FORCE_LAYOUT;<span class="hljs-comment">//该标记可执行onMeasure()</span>
        mPrivateFlags |= PFLAG_INVALIDATED;<span class="hljs-comment">//</span>

        <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;
            <span class="hljs-comment">//向父布局继续请求刷新布局</span>
            mParent.requestLayout();
        &#125;
        <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">this</span>) &#123;
            mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">null</span>;
        &#125;
    &#125;</code></pre>
<h4 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h4><h3 id="Invalidate、postInvalidate、requestLayout源码及应用场景"><a href="#Invalidate、postInvalidate、requestLayout源码及应用场景" class="headerlink" title="Invalidate、postInvalidate、requestLayout源码及应用场景"></a>Invalidate、postInvalidate、requestLayout源码及应用场景</h3><h4 id="invalidate-1"><a href="#invalidate-1" class="headerlink" title="invalidate"></a>invalidate</h4><blockquote>
<p><code>invalidate()</code>必须在主线程调用，用于请求View的重绘，意味着只影响View的<code>draw</code>过程。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/View.java</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">()</span> </span>&#123;
        invalidate(<span class="hljs-keyword">true</span>);
    &#125;

 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> invalidateCache)</span> </span>&#123;
        invalidateInternal(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="hljs-keyword">true</span>);
    &#125;

 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidateInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">boolean</span> invalidateCache,
            <span class="hljs-keyword">boolean</span> fullInvalidate)</span> </span>&#123;
     <span class="hljs-comment">//View不可见或者在移动中 不进行重绘</span>
     <span class="hljs-keyword">if</span> (skipInvalidate()) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
     
     <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)
                || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)
                || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED
                || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;
            <span class="hljs-comment">//需要全部重绘</span>
            <span class="hljs-keyword">if</span> (fullInvalidate) &#123;
                mLastIsOpaque = isOpaque();
                <span class="hljs-comment">//修改绘制完成标记</span>
                mPrivateFlags &amp;= ~PFLAG_DRAWN;
            &#125;
            <span class="hljs-comment">//修改正在绘制标记</span>
            mPrivateFlags |= PFLAG_DIRTY;
            <span class="hljs-comment">//清除缓存</span>
            <span class="hljs-keyword">if</span> (invalidateCache) &#123;
                mPrivateFlags |= PFLAG_INVALIDATED;
                mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;
            &#125;

            <span class="hljs-comment">// Propagate the damage rectangle to the parent view.</span>
            <span class="hljs-keyword">final</span> AttachInfo ai = mAttachInfo;
            <span class="hljs-keyword">final</span> ViewParent p = mParent;
            <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; ai != <span class="hljs-keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;
                <span class="hljs-keyword">final</span> Rect damage = ai.mTmpInvalRect;
                damage.set(l, t, r, b);
                <span class="hljs-comment">//设置重绘区域 并把自身传递到父布局</span>
                p.invalidateChild(<span class="hljs-keyword">this</span>, damage);
            &#125;

            <span class="hljs-comment">// Damage the entire projection receiver, if necessary.</span>
            <span class="hljs-keyword">if</span> (mBackground != <span class="hljs-keyword">null</span> &amp;&amp; mBackground.isProjected()) &#123;
                <span class="hljs-keyword">final</span> View receiver = getProjectionReceiver();
                <span class="hljs-keyword">if</span> (receiver != <span class="hljs-keyword">null</span>) &#123;
                    receiver.damageInParent();
                &#125;
            &#125;
        &#125;     
     
 &#125;</code></pre>
<p>上述代码修改标记完成后，调用父类的<code>invalidateChild()</code>将需要重绘的区域(<code>脏区域</code>)传入。(<code>ViewGroup以及ViewRootImpl都继承自ViewParent类</code>)</p>
<blockquote>
<p>脏区域：<em>为了保证绘制的效率，控件树仅对需要绘制的区域进行重绘，需要重绘的区域成为<code>脏区域</code></em>。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//../android/view/VireGroup.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidateChild</span><span class="hljs-params">(View child, <span class="hljs-keyword">final</span> Rect dirty)</span> </span>&#123;
        <span class="hljs-keyword">final</span> AttachInfo attachInfo = mAttachInfo;
        <span class="hljs-comment">//需要在开启硬件加速的情况下 会调用新的重绘方案</span>
        <span class="hljs-keyword">if</span> (attachInfo != <span class="hljs-keyword">null</span> &amp;&amp; attachInfo.mHardwareAccelerated) &#123;
            <span class="hljs-comment">// HW accelerated fast path</span>
            onDescendantInvalidated(child, child);
            <span class="hljs-keyword">return</span>;
        &#125;

        ViewParent parent = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">if</span> (attachInfo != <span class="hljs-keyword">null</span>) &#123;
          ...
            <span class="hljs-comment">//开始遍历循环 从当前View不断向上调用父布局的绘制方法</span>
            <span class="hljs-keyword">do</span> &#123;
                View view = <span class="hljs-keyword">null</span>;
                <span class="hljs-comment">// 当前父布局还为ViewGroup</span>
                <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> View) &#123;
                    view = (View) parent;
                &#125;<span class="hljs-keyword">else</span> &#123;
                  <span class="hljs-comment">// 当前父布局到了ViewRootImpl</span>
                &#125;
                

                <span class="hljs-keyword">if</span> (drawAnimation) &#123;
                    <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;
                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> ViewRootImpl) &#123;
                        ((ViewRootImpl) parent).mIsAnimating = <span class="hljs-keyword">true</span>;
                    &#125;
                &#125;

                <span class="hljs-comment">// If the parent is dirty opaque or not dirty, mark it dirty with the opaque</span>
                <span class="hljs-comment">// flag coming from the child that initiated the invalidate</span>
                <span class="hljs-comment">// 父布局为实心 就需要设置 privateFlag标记</span>
                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-keyword">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class="hljs-number">0</span> &amp;&amp;
                            view.getSolidColor() == <span class="hljs-number">0</span>) &#123;
                        opaqueFlag = PFLAG_DIRTY;
                    &#125;
                    <span class="hljs-keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;
                        view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;
                    &#125;
                &#125;
                <span class="hljs-comment">//递归调用父布局的重绘方法</span>
                parent = parent.invalidateChildInParent(location, dirty);
                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-comment">// Account for transform on current parent</span>
                    Matrix m = view.getMatrix();
                    <span class="hljs-keyword">if</span> (!m.isIdentity()) &#123;
                        RectF boundingRect = attachInfo.mTmpTransformRect;
                        boundingRect.set(dirty);
                        m.mapRect(boundingRect);
                       <span class="hljs-comment">//将子View的脏区域 转换 父布局中的一块区域</span>
                        dirty.set((<span class="hljs-keyword">int</span>) Math.floor(boundingRect.left),
                                (<span class="hljs-keyword">int</span>) Math.floor(boundingRect.top),
                                (<span class="hljs-keyword">int</span>) Math.ceil(boundingRect.right),
                                (<span class="hljs-keyword">int</span>) Math.ceil(boundingRect.bottom));
                    &#125;
                &#125;
            &#125; <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span>);
        &#125;
    &#125;

    <span class="hljs-comment">//将子视图坐标位置转化为当前视图的显示位置 </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewParent <span class="hljs-title">invalidateChildInParent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] location, <span class="hljs-keyword">final</span> Rect dirty)</span> </span>&#123;
        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// either DRAWN, or DRAWING_CACHE_VALID</span>
            <span class="hljs-comment">//ViewGroup中没有动画在执行 或者 已完成</span>
            <span class="hljs-keyword">if</span> ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE))
                    != FLAG_OPTIMIZE_INVALIDATE) &#123;
                dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,
                        location[CHILD_TOP_INDEX] - mScrollY);
                <span class="hljs-keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == <span class="hljs-number">0</span>) &#123;
                    dirty.union(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mRight - mLeft, mBottom - mTop);
                &#125;

                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = mLeft;
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> top = mTop;

                <span class="hljs-keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;
                    <span class="hljs-keyword">if</span> (!dirty.intersect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mRight - left, mBottom - top)) &#123;
                        dirty.setEmpty();
                    &#125;
                &#125;

                location[CHILD_LEFT_INDEX] = left;
                location[CHILD_TOP_INDEX] = top;
            &#125; <span class="hljs-keyword">else</span> &#123;
                
                <span class="hljs-keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;
                    dirty.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mRight - mLeft, mBottom - mTop);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// in case the dirty rect extends outside the bounds of this container</span>
                    dirty.union(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mRight - mLeft, mBottom - mTop);
                &#125;
                location[CHILD_LEFT_INDEX] = mLeft;
                location[CHILD_TOP_INDEX] = mTop;

                mPrivateFlags &amp;= ~PFLAG_DRAWN;
            &#125;
            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;
            <span class="hljs-keyword">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;
                mPrivateFlags |= PFLAG_INVALIDATED;
            &#125;

            <span class="hljs-keyword">return</span> mParent;
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;</code></pre>
<p>当<code>parent</code>不为View时，说明已经到达了最顶层即<code>ViewRootImpl</code></p>
<blockquote>
<p>为什么最顶层会是<code>ViewRootImpl</code>?</p>
<pre><code class="hljs java">&gt; 在ViewRoot与DecorView关联时讲到最后 WindowManagerGlobal 调用了 ViewRootImpl.setView() 传递进去DecorView
&gt; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;
&gt;    <span class="hljs-comment">//设置当前ViewRootImpl为DecorView的parent</span>
&gt;    view.assignParent(<span class="hljs-keyword">this</span>);
&gt; &#125;
&gt; <span class="hljs-comment">//给当前View设置父布局</span>
&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assignParent</span><span class="hljs-params">(ViewParent parent)</span> </span>&#123;
&gt;         <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;
&gt;             mParent = parent;
&gt;         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent == <span class="hljs-keyword">null</span>) &#123;
&gt;             mParent = <span class="hljs-keyword">null</span>;
&gt;         &#125; <span class="hljs-keyword">else</span> &#123;
&gt;             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"view "</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">" being added, but"</span>
&gt;                     + <span class="hljs-string">" it already has a parent"</span>);
&gt;         &#125;
&gt;     &#125;
&gt;</code></pre>
</blockquote>
<blockquote>
<p>不断向上回溯的过程中，最终走到DecorView <code>getParent()</code>就为ViewRootImpl</p>
</blockquote>
<p>走到最后调用到了ViewRootImpl的<code>invalidateChild</code>方法，内部实现为<code>invalidateChildInParent()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewRootImpl.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidateChild</span><span class="hljs-params">(View child, Rect dirty)</span> </span>&#123;
        invalidateChildInParent(<span class="hljs-keyword">null</span>, dirty);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewParent <span class="hljs-title">invalidateChildInParent</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] location, Rect dirty)</span> </span>&#123;
        <span class="hljs-comment">//判断当前线程是否与View线程相同</span>
        checkThread();
        <span class="hljs-keyword">if</span> (DEBUG_DRAW) Log.v(mTag, <span class="hljs-string">"Invalidate child: "</span> + dirty);

        <span class="hljs-keyword">if</span> (dirty == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">//整个窗口重绘</span>
            invalidate();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;
            <span class="hljs-comment">//需要重绘区域为空 就不管了</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        <span class="hljs-comment">//设置 重绘区域偏移</span>
        <span class="hljs-keyword">if</span> (mCurScrollY != <span class="hljs-number">0</span> || mTranslator != <span class="hljs-keyword">null</span>) &#123;
            mTempRect.set(dirty);
            dirty = mTempRect;
            <span class="hljs-keyword">if</span> (mCurScrollY != <span class="hljs-number">0</span>) &#123;
                dirty.offset(<span class="hljs-number">0</span>, -mCurScrollY);
            &#125;
            <span class="hljs-keyword">if</span> (mTranslator != <span class="hljs-keyword">null</span>) &#123;
                mTranslator.translateRectInAppWindowToScreen(dirty);
            &#125;
            <span class="hljs-keyword">if</span> (mAttachInfo.mScalingRequired) &#123;
                dirty.inset(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);
            &#125;
        &#125;

        invalidateRectOnScreen(dirty);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    <span class="hljs-comment">//在屏幕上找到对应的重绘区域进行重绘</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidateRectOnScreen</span><span class="hljs-params">(Rect dirty)</span> </span>&#123;
        <span class="hljs-keyword">final</span> Rect localDirty = mDirty;
        <span class="hljs-keyword">if</span> (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;
            mAttachInfo.mSetIgnoreDirtyState = <span class="hljs-keyword">true</span>;
            mAttachInfo.mIgnoreDirtyState = <span class="hljs-keyword">true</span>;
        &#125;

        <span class="hljs-comment">// Add the new dirty rect to the current one</span>
        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);
        <span class="hljs-comment">// Intersect with the bounds of the window to skip</span>
        <span class="hljs-comment">// updates that lie outside of the visible region</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> appScale = mAttachInfo.mApplicationScale;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intersected = localDirty.intersect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
                (<span class="hljs-keyword">int</span>) (mWidth * appScale + <span class="hljs-number">0.5f</span>), (<span class="hljs-keyword">int</span>) (mHeight * appScale + <span class="hljs-number">0.5f</span>));
        <span class="hljs-keyword">if</span> (!intersected) &#123;
            localDirty.setEmpty();
        &#125;
        <span class="hljs-keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;
            <span class="hljs-comment">//真正执行绘制的地方</span>
            scheduleTraversals();
        &#125;
    &#125;</code></pre>
<p>最终调用到了<code>scheduleTraversals()</code>，在上面讲到<code>View的绘制流程</code>时，有提到最初就是从<code>performTraversals()</code>开始，这里的<code>scheduleTraversals()</code>就是去触发一次<code>performTraversals()</code>开始一次绘制流程。</p>
<blockquote>
<p>由于<code>scheduleTraversals</code>是在主线程执行的，所以调用<code>invalidate()</code>时由于请求还未处理该消息，当多次调用重绘请求时，重绘也不会发生多次，提升效率。</p>
<p>调用到<code>performTraversals()</code>按道理会重新走一遍绘制流程即<code>measure-&gt;layout-&gt;draw</code>，由于重绘时，设置<code>layoutRequested为false</code>就不会重新触发<code>measure及layout</code>流程。</p>
</blockquote>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View-Invalidate.png" srcset="/img/loading.gif" class="full-image" alt="View的重绘流程" title="View的重绘流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>根据上述流程图，简单总结：</p>
<ul>
<li>View调用<code>invalidate()</code>时，会调用父布局的<code>invalidateChild()</code>并传入自身View以及需要重绘区域</li>
<li>ViewGroup接收到传参时，会开启循环(<code>条件为直到没有父布局为止</code>)，调用自身的<code>invalidateChildInParent()-主要功能为将子布局区域转换成当前布局的区域</code>向父布局层层传递</li>
<li>当父布局不为ViewGroup时，意味着已经到了最顶层的DecorView(<code>因为它的parent为ViewRootImpl</code>)，所以最终会执行到<code>ViewRootImpl.invalidateChild()</code></li>
<li>ViewRootImpl执行<code>invalidateChild()</code>最终调用到的就是<code>performTraversals()</code>进行View的绘制流程(<code>draw</code>)，由于设置了<code>mLayoutRequested</code>限制了<code>measure,layout</code>的执行，所以只会发生<code>draw</code></li>
</ul>
<h4 id="postInvalidate"><a href="#postInvalidate" class="headerlink" title="postInvalidate"></a>postInvalidate</h4><blockquote>
<p><code>postInvalidate</code>就是可以在子线程重绘View。实际的实现还是调用<code>invalidate()</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/View.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postInvalidate</span><span class="hljs-params">()</span> </span>&#123;
        postInvalidateDelayed(<span class="hljs-number">0</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postInvalidate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;
        postInvalidateDelayed(<span class="hljs-number">0</span>, left, top, right, bottom);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postInvalidateDelayed</span><span class="hljs-params">(<span class="hljs-keyword">long</span> delayMilliseconds, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top,
            <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;

        <span class="hljs-comment">// We try only with the AttachInfo because there's no point in invalidating</span>
        <span class="hljs-comment">// if we are not attached to our window</span>
        <span class="hljs-keyword">final</span> AttachInfo attachInfo = mAttachInfo;
        <span class="hljs-keyword">if</span> (attachInfo != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">final</span> AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.obtain();
            info.target = <span class="hljs-keyword">this</span>;
            info.left = left;
            info.top = top;
            info.right = right;
            info.bottom = bottom;

            attachInfo.mViewRootImpl.dispatchInvalidateRectDelayed(info, delayMilliseconds);
        &#125;
    &#125;

<span class="hljs-comment">// ../android/view/ViewRootImpl.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchInvalidateDelayed</span><span class="hljs-params">(View view, <span class="hljs-keyword">long</span> delayMilliseconds)</span> </span>&#123;
    Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);
    mHandler.sendMessageDelayed(msg, delayMilliseconds);
&#125;

<span class="hljs-keyword">final</span> ViewRootHandler mHandler = <span class="hljs-keyword">new</span> ViewRootHandler();
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewRootHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;
  ..
     <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;
            <span class="hljs-keyword">switch</span> (msg.what) &#123;
            <span class="hljs-keyword">case</span> MSG_INVALIDATE:
                <span class="hljs-comment">//最终调用到了 invalidate </span>
                ((View) msg.obj).invalidate();
                <span class="hljs-keyword">break</span>;
                ...
            &#125;
       &#125;
  ...
&#125;</code></pre>
<h4 id="requestLayout-1"><a href="#requestLayout-1" class="headerlink" title="requestLayout"></a>requestLayout</h4><blockquote>
<p>强制重新布局，重新走一遍View的绘制流程。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/view/View.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mMeasureCache != <span class="hljs-keyword">null</span>) mMeasureCache.clear();

        <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// Only trigger request-during-layout logic if this is the view requesting it,</span>
            <span class="hljs-comment">// not the views in its parent hierarchy</span>
            ViewRootImpl viewRoot = getViewRootImpl();
            <span class="hljs-keyword">if</span> (viewRoot != <span class="hljs-keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;
                <span class="hljs-keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="hljs-keyword">this</span>)) &#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
            &#125;
            mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">this</span>;
        &#125;
        <span class="hljs-comment">//设置强制刷新标记</span>
        mPrivateFlags |= PFLAG_FORCE_LAYOUT;
        mPrivateFlags |= PFLAG_INVALIDATED;

        <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;
            <span class="hljs-comment">//向父布局继续请求刷新布局</span>
            mParent.requestLayout();
        &#125;
        <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">this</span>) &#123;
            mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">null</span>;
        &#125;
    &#125;</code></pre>
<p>不断向父布局请求重新布局，逐层传递直到ViewRootImpl层。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;
        checkThread();
        <span class="hljs-comment">//设置标记 重新布局</span>
        mLayoutRequested = <span class="hljs-keyword">true</span>;
        scheduleTraversals();
    &#125;
&#125;</code></pre>
<p>上文中提到<code>mLayoutRequested</code>就是防止<code>invalidate</code>重新走一遍绘制流程，这里设置为<code>true</code>，意味着需要走一遍<code>measure,layout</code>。</p>
<p>由于<code>measure</code>过程设置了<code>mPrivateTags PFLAG_LAYOUT_REQUIRED</code>所以会往下继续执行<code>layout</code>过程。</p>
<blockquote>
<p><code>requestLayout</code>是否会触发<code>draw</code>过程？</p>
<p>按照流程来说<code>layout</code>之后就是<code>draw</code>，所以可以从<code>layout</code>过程中查看相关代码</p>
<pre><code class="hljs java">&gt; 在上文中说到 View的layout过程 会调用到 layout 后续是 setFrame 确定顶点，最后onLayout执行
&gt; <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;
&gt;    <span class="hljs-comment">//意味着 如果布局的坐标发生了改变 就需要重新绘制</span>
&gt; 	 <span class="hljs-keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;
&gt;             changed = <span class="hljs-keyword">true</span>;
&gt; 
&gt;             <span class="hljs-comment">// Remember our drawn bit</span>
&gt;             <span class="hljs-keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;
&gt; 
&gt;             <span class="hljs-keyword">int</span> oldWidth = mRight - mLeft;
&gt;             <span class="hljs-keyword">int</span> oldHeight = mBottom - mTop;
&gt;             <span class="hljs-keyword">int</span> newWidth = right - left;
&gt;             <span class="hljs-keyword">int</span> newHeight = bottom - top;
&gt;             <span class="hljs-keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);
&gt; 
&gt;             <span class="hljs-comment">// Invalidate our old position</span>
&gt;             invalidate(sizeChanged);
&gt;             ...
&gt;        &#125;
&gt;    ...
&gt; &#125;
&gt;</code></pre>
</blockquote>
<blockquote>
<p>综上所述，如果layout的布局有变化还是会触发<code>draw</code>过程的</p>
</blockquote>
<h3 id="include、merge、ViewStub作用以及实现"><a href="#include、merge、ViewStub作用以及实现" class="headerlink" title="include、merge、ViewStub作用以及实现"></a>include、merge、ViewStub作用以及实现</h3><a href="/2019/01/03/include、merge-ViewStub相关/" title="include、merge及ViewStub相关">include、merge及ViewStub相关</a>
<h3 id="View的层级计算"><a href="#View的层级计算" class="headerlink" title="View的层级计算"></a>View的层级计算</h3><p>//TODO 提供代码</p>
<p>由于View是树形结构，代码的话可以利用<code>getParent()</code>实现 ，直到返回值为null，说明已经到了最高层。</p>
<h3 id="AsyncLayoutInflater异步加载"><a href="#AsyncLayoutInflater异步加载" class="headerlink" title="AsyncLayoutInflater异步加载"></a>AsyncLayoutInflater异步加载</h3><p><a href="https://www.jianshu.com/p/8548db25a475" target="_blank" rel="noopener">AsyncLayoutInfalter</a></p>
<h3 id="inflate-时，root与attachToRoot的结果源码"><a href="#inflate-时，root与attachToRoot的结果源码" class="headerlink" title="inflate()时，root与attachToRoot的结果源码"></a>inflate()时，<code>root</code>与<code>attachToRoot</code>的结果源码</h3><h3 id="MeasureSpec-UNSPECIFIED使用场景"><a href="#MeasureSpec-UNSPECIFIED使用场景" class="headerlink" title="MeasureSpec.UNSPECIFIED使用场景"></a><code>MeasureSpec.UNSPECIFIED</code>使用场景</h3>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/12/17/实现自定义图片加载框架/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">实现自定义图片加载框架</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/12/14/Java-反射/">
                        <span class="hidden-mobile">Java - 反射</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
