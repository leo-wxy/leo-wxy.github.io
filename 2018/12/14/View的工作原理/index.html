

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="
">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="View的工作原理">
<meta property="og:url" content="https://leo-wxy.github.io/2018/12/14/View的工作原理/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://leo-wxy.github.io/images/View工作原理xmind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View工作原理-PhoneWindow.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View工作原理-DecorView.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/setContentView流程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View工作原理-ViewRootImpl.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/三者关系.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View工作原理-LayoutInflater-PhoneLayoutInflater.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/LayoutInflater-inflate.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/LayoutInflater-Factory2.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/LayoutInflater-默认View创建流程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/LayoutInflater过程.jpg">
<meta property="og:image" content="https://leo-wxy.github.io/images/View绘制流程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/measure-MeasureSpec.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/MeasureSpec结构">
<meta property="og:image" content="https://leo-wxy.github.io/images/measure-View的measure过程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View-Measure.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/measure-ViewGroup的measure过程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/ViewGroup-Measure.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/layout-View的layout过程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View-Layout.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/layout-ViewGroup的layout过程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/ViewGroup-Layout.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/layout-getMeasureWidth(">
<meta property="og:image" content="https://leo-wxy.github.io/images/draw-View的draw过程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View-Draw.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/draw-ViewGroup的draw过程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/ViewGroup-Draw.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/draw-ViewGroup自定义绘制顺序.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/自定义View.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/自定义View-注意事项.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View工作原理-触发View的重新绘制.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View工作原理-requestLayout.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View工作原理-Invalidate.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/View重绘.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/TextView.setText.png">
<meta property="og:updated_time" content="2020-12-10T14:45:07.000Z">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="View的工作原理">
<meta name="twitter:image" content="https://leo-wxy.github.io/images/View工作原理xmind.png">
  
  <title>View的工作原理 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.12","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="View的工作原理">
              
                View的工作原理
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-12-14 16:47" pubdate>
        2018年12月14日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      79k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      246 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">View的工作原理</h1>
            
            <div class="markdown-body">
              <!--MeasureSpec是什么？有什么作用？，自定义View/ViewGroup需要注意什么？invalidate()和postInvalidate()的区别？,invalidate和postInvalidate的区别及使用 Requestlayout，onlayout，onDraw，DrawChild区别与联系  View刷新机制  View绘制流程  计算一个view的嵌套层级（递归）  onMeasure的具体过程，先measure子view还是自己  onDraw的具体过程，先draw子view还是自己  实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展 view的工作原理及measure、layout、draw流程。哪一个流程可以放在子线程中去执行？draw方法中需要注意的问题？Invalidate、postInvalidate、requestLayout应用场景 TextView.setText()调用什么方法去刷新 -->
<p><img src="/images/View工作原理xmind.png" srcset="/img/loading.gif" lazyload="" alt="View工作原理"></p>
<a id="more"></a>
<h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><p><img src="/images/View工作原理-PhoneWindow.png" srcset="/img/loading.gif" lazyload="" alt="View工作原理-PhoneWindow"></p>
<p><code>Window</code>是一个抽象类，提供了各种窗口操作方法。每个Activity都会持有一个<code>Window</code>。</p>
<p><code>PhoneWindow</code>是<code>Window</code>唯一实现类，在Activity被创建时<code>Activity.attach()</code>进行初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">//ActivityThread.java<br>//Activity开始启动<br><span class="hljs-keyword">public</span> Activity handleLaunchActivity(ActivityClientRecord r,<br>            PendingTransactionActions pendingActions, Intent customIntent) &#123;<br> ... <br>   <span class="hljs-keyword">final</span> Activity a = performLaunchActivity(r, customIntent);<br>&#125;<br><br>    <span class="hljs-keyword">private</span> Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;<br>      //创建Application对象<br>            Application app = r.packageInfo.makeApplication(<span class="hljs-keyword">false</span>, mInstrumentation);      <br>      //Activity初始化<br>       activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,<br>                        r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>                        r.embeddedID, r.lastNonConfigurationInstances, config,<br>                        r.referrer, r.voiceInteractor, window, r.configCallback);<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">//Activity.java<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> attach(Context context, ActivityThread aThread,<br>            Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,<br>            Application application, Intent intent, ActivityInfo info,<br>            CharSequence title, Activity parent, String id,<br>            NonConfigurationInstances lastNonConfigurationInstances,<br>            Configuration config, String referrer, IVoiceInteractor voiceInteractor,<br>            Window window, ActivityConfigCallback activityConfigCallback) &#123;<br>      ...<br>        //初始化PhoneWindow对象<br>        mWindow = new PhoneWindow(<span class="hljs-keyword">this</span>, window, activityConfigCallback);<br>        mWindow.setWindowControllerCallback(<span class="hljs-keyword">this</span>);<br>      //绑定Window对象<br>        mWindow.setCallback(<span class="hljs-keyword">this</span>);<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">//PhoneWindow.java<br><span class="hljs-keyword">public</span> class PhoneWindow extends Window implements MenuBuilder.Callback &#123;<br>    // This is the top-level view of the window, containing the window decor.<br>    <span class="hljs-keyword">private</span> DecorView mDecor;//对应DecorView  <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><p><img src="/images/View工作原理-DecorView.png" srcset="/img/loading.gif" lazyload="" alt="View工作原理-DecorView"></p>
<p><strong>DecorView是整个Window界面的最顶层View。</strong> <em>可以使用Android Studio自带的Layout Inspector查看页面层级</em></p>
<h3 id="DecorView的布局结构"><a href="#DecorView的布局结构" class="headerlink" title="DecorView的布局结构"></a>DecorView的布局结构</h3><p>一般情况下<code>DecorView</code>会包含一个竖直方向的LinearLayout，该LinearLayout分为上下两个部分，上面是标题栏(<code>titlebar</code>)，下面是内容栏(<code>继承自FrameLayout 且id为content</code>)。因此我们设置Activity的布局方法叫做<code>setContentView()</code>，因为他们都被加进了<code>id为content的FrameLayout</code>中。</p>
<p>我们可以利用<code>ViewGroup content = findViewById(R.android.id.content)</code>获取conetnt。使用<code>content.getChildAt(0)</code>获取设置的Activity布局。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/Activity.java<br>    <span class="hljs-keyword">public</span> &lt;T extends View&gt; T findViewById(@IdRes <span class="hljs-keyword">int</span> id) &#123;<br>        //从Window中去获取View<br>        return getWindow().findViewById(id);<br>    &#125;<br><br>// ../android/view/Window.java<br>    <span class="hljs-keyword">public</span> &lt;T extends View&gt; T findViewById(@IdRes <span class="hljs-keyword">int</span> id) &#123;<br>        //从DecorView获取View<br>        return getDecorView().findViewById(id);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>所有的View都会从DecorView中开始检索，所以<strong>View层的事件都会先经过DecorView，再传递到我们定义的View上</strong>。</p>
<h3 id="setContentView-过程"><a href="#setContentView-过程" class="headerlink" title="setContentView()过程"></a>setContentView()过程</h3><blockquote>
<p>通过<code>setContentView()</code>将需要加载的布局放到<code>DecorView</code>中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">//Activity.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setContentView(@LayoutRes <span class="hljs-keyword">int</span> layoutResID) &#123;<br>        getWindow().setContentView(layoutResID);<br>        initWindowDecorActionBar();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>Activity.setContentView()</code>调用<code>PhoneWindow.setContentView()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setContentView(<span class="hljs-keyword">int</span> layoutResID) &#123;<br>    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window<br>    // decor, when theme attributes and the like are crystalized. Do not check the feature<br>    // before <span class="hljs-keyword">this</span> happens.<br>    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;<br>        //创建DecorView<br>        installDecor();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;<br>        mContentParent.removeAllViews();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;<br>        <span class="hljs-keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,<br>                getContext());<br>        transitionTo(newScene);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      //开始加载对应布局<br>        mLayoutInflater.inflate(layoutResID, mContentParent);<br>    &#125;<br>    mContentParent.requestApplyInsets();<br>    <span class="hljs-keyword">final</span> Callback cb = getCallback();<br>    <span class="hljs-keyword">if</span> (cb != <span class="hljs-keyword">null</span> &amp;&amp; !isDestroyed()) &#123;<br>        cb.onContentChanged();<br>    &#125;<br>    mContentParentExplicitlySet = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>setContentView()</code>主要执行以下两步：</p>
<h4 id="installDecor-——创建DecorView"><a href="#installDecor-——创建DecorView" class="headerlink" title="installDecor()——创建DecorView"></a><code>installDecor()</code>——创建DecorView</h4><blockquote>
<p>基础<code>DecorView</code>主要包含两部分，标题<code>title_bar</code>和内容<code>content</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java">//PhoneWindow.java<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> installDecor() &#123;<br>        mForceDecorInstall = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (mDecor == <span class="hljs-keyword">null</span>) &#123;<br>            //生成DecoeView<br>            mDecor = generateDecor(-1);<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mDecor.setWindow(<span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;<br>           //根据DecorView生成子View<br>            mContentParent = generateLayout(mDecor);<br>          ...<br>        &#125;<br> &#125;<br><br>    <span class="hljs-keyword">protected</span> DecorView generateDecor(<span class="hljs-keyword">int</span> featureId) &#123;<br>        Context context;<br>        <span class="hljs-keyword">if</span> (mUseDecorContext) &#123;<br>            Context applicationContext = getContext().getApplicationContext();<br>            <span class="hljs-keyword">if</span> (applicationContext == <span class="hljs-keyword">null</span>) &#123;<br>                context = getContext();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                context = new DecorContext(applicationContext, getContext());<br>                <span class="hljs-keyword">if</span> (mTheme != -1) &#123;<br>                    context.setTheme(mTheme);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            context = getContext();<br>        &#125;<br>      // 生成DecorView对象<br>        return new DecorView(context, featureId, <span class="hljs-keyword">this</span>, getAttributes());<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> ViewGroup generateLayout(DecorView decor) &#123;<br>      ...<br>        <span class="hljs-keyword">int</span> layoutResource;<br>        <span class="hljs-keyword">int</span> features = getLocalFeatures();<br>        <span class="hljs-keyword">if</span> ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123;<br>            layoutResource = R.layout.screen_swipe_dismiss;<br>            setCloseOnSwipeEnabled(<span class="hljs-keyword">true</span>);     <br>        &#125;...<br>         <span class="hljs-keyword">else</span>&#123;<br>           layoutResource = R.layout.screen_simple; //默认布局<br>         &#125;<br>         mDecor.startChanging();<br>         //开始加载布局<br>         mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);<br>         //根据id找到 content<br>         ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//com.android.internal.R.id.content<br>         ...<br>         return contentParent;<br>    &#125;<br><br>//DecorView.java<br>    <span class="hljs-keyword">void</span> onResourcesLoaded(LayoutInflater inflater, <span class="hljs-keyword">int</span> layoutResource) &#123;<br>        <span class="hljs-keyword">final</span> View root = inflater.inflate(layoutResource, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (mDecorCaptionView != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mDecorCaptionView.getParent() == <span class="hljs-keyword">null</span>) &#123;<br>                addView(mDecorCaptionView,<br>                        new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));<br>            &#125;<br>            mDecorCaptionView.addView(root,<br>                    new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            //解析得到的View放到DecorView中<br>            addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));<br>        &#125;<br>        mContentRoot = (ViewGroup) root;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>installDecor()</code>主要负责创建<code>DecorView</code>并执行<code>generateLayout()</code>生成<code>contentParent</code>将自定义的布局放入其中。</p>
<h4 id="inflate-layoutResID-mContentParent-——加载布局"><a href="#inflate-layoutResID-mContentParent-——加载布局" class="headerlink" title="inflate(layoutResID, mContentParent)——加载布局"></a>inflate(layoutResID, mContentParent)——加载布局</h4><p><code>inflate()</code>主要将<code>layoutResID</code>加载成具体的View，并加入到<code>mContentParent</code>中，进行显示。</p>
<p><img src="/images/setContentView流程.png" srcset="/img/loading.gif" lazyload="" alt="执行流程"></p>
<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><p><img src="/images/View工作原理-ViewRootImpl.png" srcset="/img/loading.gif" lazyload="" alt="View工作原理-ViewRootImpl"></p>
<blockquote>
<p><em>ViewRoot对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程均需通过ViewRoot完成。</em></p>
</blockquote>
<h3 id="ViewRootImpl创建时机"><a href="#ViewRootImpl创建时机" class="headerlink" title="ViewRootImpl创建时机"></a>ViewRootImpl创建时机</h3><p>当Activity创建时，最终是调用到<code>ActivityThread</code>的<code>handleLaunchActivity</code>来创建Activity。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/ActivityThread.java<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;<br> ...<br>      //创建一个Activity 会调用到onCreate()方法 从而完成DecroView的创建<br>      Activity a = performLaunchActivity(r, customIntent);<br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>) &#123;<br>            r.createdConfig = new Configuration(mConfiguration);<br>            reportSizeConfigurations(r);<br>            Bundle oldState = r.state;<br>            <br>            handleResumeActivity(r.token, <span class="hljs-keyword">false</span>, r.isForward,<br>                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);<br>            ...<br>        &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述方法后续调用到了<code>handleResumeActivity()</code>,在这个方法中调用到了<code>WindowManager.addView()</code>将View传递至WindowManager</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/ActivityThread.java<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> handleResumeActivity(IBinder token,<br>            <span class="hljs-keyword">boolean</span> clearHide, <span class="hljs-keyword">boolean</span> isForward, <span class="hljs-keyword">boolean</span> reallyResume, <span class="hljs-keyword">int</span> seq, String reason) &#123;<br>         ActivityClientRecord r = mActivities.get(token);<br>        <span class="hljs-keyword">if</span> (!checkAndUpdateLifecycleSeq(seq, r, "resumeActivity")) &#123;<br>            return;<br>        &#125;<br>        unscheduleGcIdler();<br>        mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br><br>        // 在这里会调用到生命周期中的onResume方法<br>        r = performResumeActivity(token, clearHide, reason);<br>        ...<br>            <span class="hljs-keyword">if</span>(r!=<span class="hljs-keyword">null</span>)&#123;<br>                ...<br>                <span class="hljs-keyword">final</span> Activity a = r.activity;<br>                ...<br>                //获得当前Activty的Window对象<br>                r.window = r.activity.getWindow();<br>                //获得当前Window的DecorView<br>                View decor = r.window.getDecorView();<br>                decor.setVisibility(View.INVISIBLE);<br>                //获得当前Activity的WindowManager对象<br>                ViewManager wm = a.getWindowManager();<br>                WindowManager.LayoutParams l = r.window.getAttributes();<br>                a.mDecor = decor;<br>                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;<br>                l.softInputMode |= forwardBit;<br>                <span class="hljs-keyword">if</span> (r.mPreserveWindow) &#123;<br>                    a.mWindowAdded = <span class="hljs-keyword">true</span>;<br>                    r.mPreserveWindow = <span class="hljs-keyword">false</span>;<br>                    ViewRootImpl impl = decor.getViewRootImpl();<br>                    <span class="hljs-keyword">if</span> (impl != <span class="hljs-keyword">null</span>) &#123;<br>                        impl.notifyChildRebuilt();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (a.mVisibleFromClient) &#123;<br>                    <span class="hljs-keyword">if</span> (!a.mWindowAdded) &#123;<br>                        a.mWindowAdded = <span class="hljs-keyword">true</span>;<br>                        //将DecorView添加到PhoneWindow中<br>                        wm.addView(decor, l);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        a.onWindowAttributesChanged(l);<br>                    &#125;<br>                &#125;<br><br>            // If the window has already been added, but during resume<br>            // we started another activity, then don't yet make the<br>            // window visible.<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!willBeVisible) &#123;<br>                <span class="hljs-keyword">if</span> (localLOGV) Slog.v(<br>                    TAG, "Launch " + r + " mStartedActivity set");<br>                r.hideForNow = <span class="hljs-keyword">true</span>;<br>            &#125;    <br>            &#125;<br>        <span class="hljs-keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="hljs-keyword">null</span> &amp;&amp; !r.hideForNow) &#123;<br>...<br>            <span class="hljs-keyword">if</span> (r.activity.mVisibleFromClient) &#123;<br>              //显示DecorView<br>                r.activity.makeVisible();<br>            &#125;<br>        &#125;<br>...<br>    &#125;<br><br>//Activity.java<br>    <span class="hljs-keyword">void</span> makeVisible() &#123;<br>        <span class="hljs-keyword">if</span> (!mWindowAdded) &#123;<br>            ViewManager wm = getWindowManager();<br>            wm.addView(mDecor, getWindow().getAttributes());<br>            mWindowAdded = <span class="hljs-keyword">true</span>;<br>        &#125;<br>      //显示DecorView及其内容<br>        mDecor.setVisibility(View.VISIBLE);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>后续调用到了<code>wm.addView()</code>。将对应的DecorView传递进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/view/WindowManagerImpl.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class WindowManagerImpl implements WindowManager &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Window mParentWindow;<br>    ...<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;<br>        applyDefaultToken(params);<br>        //调用到了WindowManagerGlobal中的addView<br>        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);<br>    &#125;   <br>    ...<br>&#125;<br><br>// ../android/view/WindowManagerGlobal.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> addView(View view, ViewGroup.LayoutParams params,<br>            Display display, Window parentWindow) &#123;<br>        ...<br><br>        ViewRootImpl root;<br>        View panelParentView = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            ...<br>            //创建了ViewRootImpl实例<br>            root = new ViewRootImpl(view.getContext(), display);//初始化了ViewRootImpl对象<br>            view.setLayoutParams(wparams);<br>            mViews.add(view);<br>            mRoots.add(root);<br>            mParams.add(wparams);<br>            // <span class="hljs-keyword">do</span> <span class="hljs-keyword">this</span> last because it fires off messages to start doing things<br>            <span class="hljs-keyword">try</span> &#123;<br>                //调用setView 将传进来的DecorView添加到PhoneWindow中。 <br>                root.setView(view, wparams, panelParentView);<br>            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>                // BadTokenException or InvalidDisplayException, clean up.<br>                <span class="hljs-keyword">if</span> (index &gt;= 0) &#123;<br>                    removeViewLocked(index, <span class="hljs-keyword">true</span>);<br>                &#125;<br>                throw e;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>经过<code>ActivityThread.handleResumeActivity() -&gt; WindowManagerGlobal.addView()</code>创建了<code>ViewRootImpl</code>对象</p>
<h3 id="与DecorView的关系"><a href="#与DecorView的关系" class="headerlink" title="与DecorView的关系"></a>与DecorView的关系</h3><p>上述流程走完后，就把DecorView加载到了Window中。<strong>这个流程中将ViewRootImpl对象与DecorView进行了关联</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">//view 表示 DecorView <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;<br>     <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>         //传进来的DecorView作为全局变量使用<br>          mView = view;<br>         ...<br>          // Schedule the first layout -before- adding to the window<br>                // manager, to make sure we <span class="hljs-keyword">do</span> the relayout before receiving<br>                // any other events from the system.<br>          //绘制整个布局<br>          requestLayout();   <br>         ...<br>          //设置ViewRootImpl为DecorView的parentView <br>          view.assignParent(<span class="hljs-keyword">this</span>);<br>     &#125;   <br> &#125;<br></code></pre></td></tr></table></figure>
<p>执行到<code>ViewRootImpl.setView()</code>设置<code>DecorView,assignParent(root)</code>。表示<strong>ViewRootImpl是DecorView的parent</strong>。</p>
<p><img src="/images/三者关系.png" srcset="/img/loading.gif" lazyload="" alt="三者关系"></p>
<blockquote>
<p><code>Activity</code>、<code>Window(PhoneWindow)</code>、<code>View(DecorView)</code>、<code>ViewRootImpl</code>之间的关系？</p>
<p><code>PhoneWindow</code>是<code>Window</code>的唯一子类，在<code>Activity.attach()</code>构建的实例，是<strong>Activity与View交互的中间层</strong></p>
<p><code>DecorView</code>是<code>所有View</code>的最顶层，<code>ViewRootImpl</code>是<code>DecorView</code>的<code>parent</code>，负责<code>WindowManagerService</code>与<code>DecorView</code>的通信。<strong>掌管View的各种事件，例如<code>刷新、点击</code>事件等</strong></p>
</blockquote>
<h2 id="LayoutInflater"><a href="#LayoutInflater" class="headerlink" title="LayoutInflater"></a>LayoutInflater</h2><blockquote>
<p><code>LayoutInflater</code>是一个抽象类，具体实现类为<code>PhoneLayoutInflater</code>。主要用于进行<code>布局加载</code>。</p>
</blockquote>
<h3 id="PhoneLayoutInflater"><a href="#PhoneLayoutInflater" class="headerlink" title="PhoneLayoutInflater"></a>PhoneLayoutInflater</h3><p><img src="/images/View工作原理-LayoutInflater-PhoneLayoutInflater.png" srcset="/img/loading.gif" lazyload="" alt="View工作原理-LayoutInflater-PhoneLayoutInflater"></p>
<blockquote>
<p> 通过系统注册服务可以得到<code>LayoutInflater</code>的实现类<code>PhoneLayoutInflater</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">//LayoutInflater.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LayoutInflater from(Context context) &#123;<br>    LayoutInflater LayoutInflater =<br>            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//获取系统配置的加载服务<br>    <span class="hljs-keyword">if</span> (LayoutInflater == <span class="hljs-keyword">null</span>) &#123;<br>        throw new AssertionError("LayoutInflater not found.");<br>    &#125;<br>    return LayoutInflater;<br>&#125;<br><br>//ContextThemeWrapper.java<br>    @Override<br>    <span class="hljs-keyword">public</span> Object getSystemService(String name) &#123;<br>        <span class="hljs-keyword">if</span> (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;<br>          //单例获取 LayoutInflater<br>            <span class="hljs-keyword">if</span> (mInflater == <span class="hljs-keyword">null</span>) &#123;<br>                mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(<span class="hljs-keyword">this</span>);<br>            &#125;<br>            return mInflater;<br>        &#125;<br>        return getBaseContext().getSystemService(name);<br>    &#125;<br><br>//SystemServerRegistry.java<br>//系统设置 PhoneInflater 为加载类<br>registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,<br>            new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> LayoutInflater createService(ContextImpl ctx) &#123;<br>            return new PhoneLayoutInflater(ctx.getOuterContext());<br>        &#125;&#125;);<br></code></pre></td></tr></table></figure>
<p><code>PhoneLayoutInflater</code>设置的<code>context</code>为<code>ContextImpl.getOuterContext()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">//ContextImpl.java<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> setOuterContext(Context context) &#123;<br>        mOuterContext = context;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> Context getOuterContext() &#123;<br>        return mOuterContext;<br>    &#125;<br><br>//ActivityThread.java<br>    <span class="hljs-keyword">private</span> Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;<br>      ...<br>        appContext.setOuterContext(activity);//设置外部context为Activity<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><strong>一般从<code>Activity、View、Dialog，Fragment</code>获取的<code>layoutInflater.getContext()</code>为Activity</strong></p>
<blockquote>
<p>无论是哪种方式获取<code>LayoutInflater</code>，都是通过<code>ContextImpl.getSystemService()</code>获取的。</p>
</blockquote>
<h3 id="inflate-加载布局"><a href="#inflate-加载布局" class="headerlink" title="inflate()-加载布局"></a>inflate()-加载布局</h3><p><img src="/images/LayoutInflater-inflate.png" srcset="/img/loading.gif" lazyload="" alt="LayoutInflater-inflate"></p>
<blockquote>
<p><code>source</code>：需要加载的layout id</p>
<p><code>root</code>：根布局(<code>为null则表示创建的是最顶层的布局</code>)</p>
<p>*<code>attachToRoot</code>：是否添加到<code>root</code>中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs java">//LayoutInflater.java<br>   <span class="hljs-keyword">public</span> View inflate(@LayoutRes <span class="hljs-keyword">int</span> resource, @Nullable ViewGroup root) &#123;<br>        return inflate(resource, root, root != <span class="hljs-keyword">null</span>);<br>   &#125;   <br><br>   <span class="hljs-keyword">public</span> View inflate(@LayoutRes <span class="hljs-keyword">int</span> resource, @Nullable ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot) &#123;<br>        <span class="hljs-keyword">final</span> Resources res = getContext().getResources();<br>        ...<br>        //构造xml解析器<br>        <span class="hljs-keyword">final</span> XmlResourceParser parser = res.getLayout(resource);<br>        <span class="hljs-keyword">try</span> &#123;<br>            return inflate(parser, root, attachToRoot);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            parser.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> View inflate(XmlPullParser parser, @Nullable ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mConstructorArgs) &#123;<br>            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate");<br><br>            <span class="hljs-keyword">final</span> Context inflaterContext = mContext;<br>            <span class="hljs-keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);<br>            Context lastContext = (Context) mConstructorArgs[0];<br>            mConstructorArgs[0] = inflaterContext;<br>            View result = root;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                // Look <span class="hljs-keyword">for</span> the root node.<br>                <span class="hljs-keyword">int</span> type;<br>                //非xml起始与结尾标记<br>                <span class="hljs-keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;<br>                        type != XmlPullParser.END_DOCUMENT) &#123;<br>                &#125;<br>            <br>                <span class="hljs-keyword">if</span> (type != XmlPullParser.START_TAG) &#123;<br>                    throw new InflateException(parser.getPositionDescription()<br>                            + ": No start tag found!");<br>                &#125;<br><br>                <span class="hljs-keyword">final</span> String name = parser.getName();<br>                //处理&lt;merge&gt;标签<br>                <span class="hljs-keyword">if</span> (TAG_MERGE.equals(name)) &#123;<br>                    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !attachToRoot) &#123;<br>                        throw new InflateException("&lt;merge /&gt; can be used only with a valid "<br>                                + "ViewGroup root and attachToRoot=<span class="hljs-keyword">true</span>");<br>                    &#125;<br>                    //传入rootview 解析得到的布局直接加入rootView中<br>                    rInflate(parser, root, inflaterContext, attrs, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    // Temp is the root view that was found in the xml<br>                    //根据Tag创建对应的View 例如&lt;TextView&gt;<br>                    <span class="hljs-keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);<br><br>                    ViewGroup.LayoutParams params = <span class="hljs-keyword">null</span>;<br><br>                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                        // Create layout params that match root, <span class="hljs-keyword">if</span> supplied<br>                        params = root.generateLayoutParams(attrs);<br>                        <span class="hljs-keyword">if</span> (!attachToRoot) &#123;<br>                            // Set the layout params <span class="hljs-keyword">for</span> temp <span class="hljs-keyword">if</span> we are not<br>                            // attaching. (If we are, we use addView, below)<br>                            temp.setLayoutParams(params);<br>                        &#125;<br>                    &#125;<br><br>                    // Inflate all children under temp against its context.<br>                    //创建temp子View<br>                    rInflateChildren(parser, temp, attrs, <span class="hljs-keyword">true</span>);<br><br>                    // We are supposed to attach all the views we found (<span class="hljs-keyword">int</span> temp)<br>                    // to root. Do that now.<br>                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span> &amp;&amp; attachToRoot) &#123;<br>                        //将temp添加到rootView中<br>                        root.addView(temp, params);<br>                    &#125;<br><br>                    // Decide whether to return the root that was passed in or the<br>                    // top view found in xml.<br>                    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !attachToRoot) &#123;<br>                        //attachToRoot：将View添加到RootView中，非就是直接返回解析的子View<br>                        result = temp;<br>                    &#125;<br>                &#125;<br><br>            &#125; <span class="hljs-keyword">catch</span> (XmlPullParserException e) &#123;<br>                <span class="hljs-keyword">final</span> InflateException ie = new InflateException(e.getMessage(), e);<br>                ie.setStackTrace(EMPTY_STACK_TRACE);<br>                throw ie;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">final</span> InflateException ie = new InflateException(parser.getPositionDescription()<br>                        + ": " + e.getMessage(), e);<br>                ie.setStackTrace(EMPTY_STACK_TRACE);<br>                throw ie;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                // Don't retain <span class="hljs-keyword">static</span> reference on context.<br>                mConstructorArgs[0] = lastContext;<br>                mConstructorArgs[1] = <span class="hljs-keyword">null</span>;<br><br>                Trace.traceEnd(Trace.TRACE_TAG_VIEW);<br>            &#125;<br><br>            return result;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> rInflate(XmlPullParser parser, View parent, Context context,<br>            AttributeSet attrs, <span class="hljs-keyword">boolean</span> finishInflate) <span class="hljs-keyword">throws</span> XmlPullParserException, IOException &#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> depth = parser.getDepth();<br>        <span class="hljs-keyword">int</span> type;<br>        <span class="hljs-keyword">boolean</span> pendingRequestFocus = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||<br>                parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;<br><br>            <span class="hljs-keyword">if</span> (type != XmlPullParser.START_TAG) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">final</span> String name = parser.getName();<br><br>            <span class="hljs-keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;<br>                pendingRequestFocus = <span class="hljs-keyword">true</span>;<br>                consumeChildElements(parser);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_TAG.equals(name)) &#123;<br>                parseViewTag(parser, parent, attrs);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;//&lt;include&gt;<br>                <span class="hljs-keyword">if</span> (parser.getDepth() == 0) &#123;<br>                    throw new InflateException("&lt;include /&gt; cannot be the root element");<br>                &#125;<br>                parseInclude(parser, context, parent, attrs);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_MERGE.equals(name)) &#123;//&lt;merge&gt;<br>                throw new InflateException("&lt;merge /&gt; must be the root element");<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                //创建View<br>                <span class="hljs-keyword">final</span> View view = createViewFromTag(parent, name, context, attrs);<br>                <span class="hljs-keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;<br>                <span class="hljs-keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);<br>                //递归创建子View<br>                rInflateChildren(parser, view, attrs, <span class="hljs-keyword">true</span>);<br>                //创建的子View添加会parent<br>                viewGroup.addView(view, params);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pendingRequestFocus) &#123;<br>            parent.restoreDefaultFocus();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (finishInflate) &#123;<br>            parent.onFinishInflate();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>layoutInflater.inflate()</code>主要是调用<code>createViewFromTag()</code>从xml生成view的。</p>
<h4 id="createViewFromTag"><a href="#createViewFromTag" class="headerlink" title="* createViewFromTag()"></a>* createViewFromTag()</h4><blockquote>
<p>主要负责将<code>&lt;tag&gt;</code>创建成<code>View</code>对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java">//LayoutInflater.java<br>View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,<br>            <span class="hljs-keyword">boolean</span> ignoreThemeAttr) &#123;<br>        /**<br>        * view标签 取class 做为name<br>        */<br>        <span class="hljs-keyword">if</span> (name.equals("view")) &#123;<br>            name = attrs.getAttributeValue(<span class="hljs-keyword">null</span>, "class");<br>        &#125;<br><br>        // 设置View的Theme<br>        <span class="hljs-keyword">if</span> (!ignoreThemeAttr) &#123;<br>            <span class="hljs-keyword">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> themeResId = ta.getResourceId(0, 0);<br>            <span class="hljs-keyword">if</span> (themeResId != 0) &#123;<br>                context = new ContextThemeWrapper(context, themeResId);<br>            &#125;<br>            ta.recycle();<br>        &#125;<br>        //处理 &lt;blink&gt;标签<br>        <span class="hljs-keyword">if</span> (name.equals(TAG_1995)) &#123;<br>            // Let's party like it's 1995!<br>            return new BlinkLayout(context, attrs);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            View view;<br>            //通过Factory /Factory2  进行View的实例化<br>            <span class="hljs-keyword">if</span> (mFactory2 != <span class="hljs-keyword">null</span>) &#123;<br>                view = mFactory2.onCreateView(parent, name, context, attrs);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mFactory != <span class="hljs-keyword">null</span>) &#123;<br>                view = mFactory.onCreateView(name, context, attrs);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                view = <span class="hljs-keyword">null</span>;<br>            &#125;<br>            //通过 mPrivateFactory实例化View<br>            <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span> &amp;&amp; mPrivateFactory != <span class="hljs-keyword">null</span>) &#123;<br>                view = mPrivateFactory.onCreateView(parent, name, context, attrs);<br>            &#125;<br>            //未设置 Factory，走默认创建View的流程<br>            <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> Object lastContext = mConstructorArgs[0];<br>                mConstructorArgs[0] = context;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    //&lt;tag&gt;中存在 . 可以判断为自定义View，走View自身的创建流程<br>                    <span class="hljs-keyword">if</span> (-1 == name.indexOf('.')) &#123;<br>                        view = onCreateView(parent, name, attrs);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        view = createView(name, <span class="hljs-keyword">null</span>, attrs);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    mConstructorArgs[0] = lastContext;<br>                &#125;<br>            &#125;<br><br>            return view;<br>        &#125; <br>        ,,,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>createViewFromTag()</code>主要做了以下几步：</p>
<ol>
<li><p>如果为<code>&lt;view&gt;</code>标签，读取<code>class</code>属性做为类名</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;view class="LinearLayout"/&gt; 等价于&lt;LinearLayout&gt;&lt;/LinearLayout&gt;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>应用<code>ContenxtThemeWrapper</code>为View设置主题<code>Theme</code></p>
</li>
<li><p>使用<code>Factory/Factory2/mPrivateFactory</code>实例化<code>View</code>，相当于<strong>拦截</strong></p>
<blockquote>
<p>实例化<code>View</code>的优先顺序为<code>Factory2 &gt; Factory &gt; mPrivateFactory &gt; PhoneLayoutInflater</code></p>
</blockquote>
</li>
<li><p>未设置<code>以上factory</code>，执行<code>View</code>的默认创建流程</p>
<blockquote>
<p>主要通过<code>PhoneLayoutInflater</code>执行</p>
</blockquote>
</li>
</ol>
<h3 id="Factory-Factory2-拦截View创建"><a href="#Factory-Factory2-拦截View创建" class="headerlink" title="Factory/Factory2-拦截View创建"></a>Factory/Factory2-拦截View创建</h3><p><img src="/images/LayoutInflater-Factory2.png" srcset="/img/loading.gif" lazyload="" alt="LayoutInflater-Factory2"></p>
<blockquote>
<p>在上节有说到<code>Factory/Factory2</code>执行相当于拦截的功能，<code>hook</code>View创建的流程</p>
<p><code>mPrivateFactory</code>实现了<code>Factory2</code>接口，主要用于拦截<code>&lt;fragment&gt;</code>标签处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Factory mFactory;<br><span class="hljs-keyword">private</span> Factory2 mFactory2;<br><span class="hljs-keyword">private</span> Factory2 mPrivateFactory;<br><br><span class="hljs-keyword">public</span> interface Factory &#123;<br>    <span class="hljs-keyword">public</span> View onCreateView(String name, Context context, AttributeSet attrs);<br>&#125;<br><br><span class="hljs-keyword">public</span> interface Factory2 extends Factory &#123;<br>    <span class="hljs-keyword">public</span> View onCreateView(View parent, String name, Context context, AttributeSet attrs);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Factory2</code>相对于<code>Factory</code>在<code>onCreateView()</code>多传入了<code>parent</code></p>
<h4 id="Factroy2"><a href="#Factroy2" class="headerlink" title="Factroy2"></a>Factroy2</h4><p>设置<code>Factroy2</code>的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setFactory2(Factory2 factory) &#123;<br>    <span class="hljs-keyword">if</span> (mFactorySet) &#123; //只允许设置一次 Factory2<br>        throw new IllegalStateException("A factory has already been set on <span class="hljs-keyword">this</span> LayoutInflater");<br>    &#125;<br>    <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) &#123;//设置的factory不能为<span class="hljs-keyword">null</span><br>        throw new NullPointerException("Given factory can not be <span class="hljs-keyword">null</span>");<br>    &#125;<br>    mFactorySet = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (mFactory == <span class="hljs-keyword">null</span>) &#123;<br>        mFactory = mFactory2 = factory;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        //控制factory调用顺序<br>        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> class FactoryMerger implements Factory2 &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Factory mF1, mF2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Factory2 mF12, mF22;<br><br>    FactoryMerger(Factory f1, Factory2 f12, Factory f2, Factory2 f22) &#123;<br>        mF1 = f1;<br>        mF2 = f2;<br>        mF12 = f12;<br>        mF22 = f22;<br>    &#125;<br><br>  //此处对应Factory<br>    <span class="hljs-keyword">public</span> View onCreateView(String name, Context context, AttributeSet attrs) &#123;<br>        View v = mF1.onCreateView(name, context, attrs);<br>        <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) return v;<br>        return mF2.onCreateView(name, context, attrs);<br>    &#125;<br>   //此处对应Factory2<br>    <span class="hljs-keyword">public</span> View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;<br>        View v = mF12 != <span class="hljs-keyword">null</span> ? mF12.onCreateView(parent, name, context, attrs)<br>                : mF1.onCreateView(name, context, attrs);<br>        <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) return v;<br>        return mF22 != <span class="hljs-keyword">null</span> ? mF22.onCreateView(parent, name, context, attrs)<br>                : mF2.onCreateView(name, context, attrs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终都是通过<code>FactoryMerger</code>执行的<code>onCreateView</code></p>
<h5 id="何处调用setFactory2"><a href="#何处调用setFactory2" class="headerlink" title="何处调用setFactory2()"></a>何处调用setFactory2()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">//AppCompatActivity.onCreate() -&gt; AppCompatDelegate.installViewFactory() -&gt;<br>//AppCompatDelegateImpl.installViewFactory()<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> installViewFactory() &#123;<br>        LayoutInflater layoutInflater = LayoutInflater.from(<span class="hljs-keyword">this</span>.mContext);<br>        <span class="hljs-keyword">if</span> (layoutInflater.getFactory() == <span class="hljs-keyword">null</span>) &#123;<br>            LayoutInflaterCompat.setFactory2(layoutInflater, <span class="hljs-keyword">this</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(layoutInflater.getFactory2() <span class="hljs-keyword">instanceof</span> AppCompatDelegateImpl)) &#123;<br>            Log.i("AppCompatDelegate", "The Activity's LayoutInflater already has a Factory installed so we can not install AppCompat's");<br>        &#125;<br>    &#125;<br><br>//设置Factory2执行到 onCreateView()<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;<br>        return <span class="hljs-keyword">this</span>.createView(parent, name, context, attrs);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> View createView(View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mAppCompatViewInflater == <span class="hljs-keyword">null</span>) &#123;<br>            TypedArray a = <span class="hljs-keyword">this</span>.mContext.obtainStyledAttributes(styleable.AppCompatTheme);<br>            String viewInflaterClassName = a.getString(styleable.AppCompatTheme_viewInflaterClass);<br>            <span class="hljs-keyword">if</span> (viewInflaterClassName != <span class="hljs-keyword">null</span> &amp;&amp; !AppCompatViewInflater.class.getName().equals(viewInflaterClassName)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Class viewInflaterClass = Class.forName(viewInflaterClassName);<br>                    <span class="hljs-keyword">this</span>.mAppCompatViewInflater = (AppCompatViewInflater)viewInflaterClass.getDeclaredConstructor().newInstance();<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable var8) &#123;<br>                    Log.i("AppCompatDelegate", "Failed to instantiate custom view inflater " + viewInflaterClassName + ". Falling back to <span class="hljs-keyword">default</span>.", var8);<br>                    <span class="hljs-keyword">this</span>.mAppCompatViewInflater = new AppCompatViewInflater();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">this</span>.mAppCompatViewInflater = new AppCompatViewInflater();<br>            &#125;<br>        &#125;<br><br>        ...<br>        return <span class="hljs-keyword">this</span>.mAppCompatViewInflater.createView(...);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>AppCompatViewInflater</code>去执行View的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">//AppCompatViewInflater.java<br>    <span class="hljs-keyword">final</span> View createView(View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs, <span class="hljs-keyword">boolean</span> inheritContext, <span class="hljs-keyword">boolean</span> readAndroidTheme, <span class="hljs-keyword">boolean</span> readAppTheme, <span class="hljs-keyword">boolean</span> wrapContext) &#123;<br>  ...<br>     <span class="hljs-keyword">switch</span> (name) &#123;<br>            <span class="hljs-keyword">case</span> "TextView":<br>                view = createTextView(context, attrs);<br>                verifyNotNull(view, name);<br>                <span class="hljs-keyword">break</span>;<br>         ...<br>     &#125;<br>&#125;<br><br>    @NonNull<br>    <span class="hljs-keyword">protected</span> AppCompatTextView createTextView(Context context, AttributeSet attrs) &#123;<br>        return new AppCompatTextView(context, attrs);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>此处可以在使用到<code>AppCompatActivity</code>时，将原先的<code>&lt;TextView&gt;</code>转换为<code>AppCompatTextView</code></p>
<h4 id="mPrivateFactory"><a href="#mPrivateFactory" class="headerlink" title="mPrivateFactory"></a>mPrivateFactory</h4><blockquote>
<p>系统hide对象，无法被外界使用，主要处理<code>&lt;fragment&gt;</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setPrivateFactory(Factory2 factory) &#123;<br>    <span class="hljs-keyword">if</span> (mPrivateFactory == <span class="hljs-keyword">null</span>) &#123;<br>        mPrivateFactory = factory;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mPrivateFactory = new FactoryMerger(factory, factory, mPrivateFactory, mPrivateFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="何处调用setPrivateFactory"><a href="#何处调用setPrivateFactory" class="headerlink" title="何处调用setPrivateFactory()"></a>何处调用setPrivateFactory()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">//Activity.java<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> attach(Context context, ActivityThread aThread,<br>            Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,<br>            Application application, Intent intent, ActivityInfo info,<br>            CharSequence title, Activity parent, String id,<br>            NonConfigurationInstances lastNonConfigurationInstances,<br>            Configuration config, String referrer, IVoiceInteractor voiceInteractor,<br>            Window window, ActivityConfigCallback activityConfigCallback) &#123;<br>  ...<br>    mWindow.getLayoutInflater().setPrivateFactory(<span class="hljs-keyword">this</span>); //<span class="hljs-keyword">this</span> 表示当前Activity<br>  ...<br>&#125;<br><br>    <span class="hljs-keyword">public</span> View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;<br>        <span class="hljs-keyword">if</span> (!"fragment".equals(name)) &#123;<br>            return onCreateView(name, context, attrs);<br>        &#125;<br>       //&lt;fragment&gt;标签直接解析执行 onCreateView<br>        return mFragments.onCreateView(parent, name, context, attrs);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="拓展使用"><a href="#拓展使用" class="headerlink" title="拓展使用"></a>拓展使用</h4><p>系统通过<code>Factory</code>提供<code>hook</code>方法，方便拦截<code>LayoutInflater</code>创建View的过程。支持以下应用场景：</p>
<ul>
<li>支持对自定义标签名称的处理</li>
<li>全局替换系统控件为自定义View</li>
<li><strong>替换字体</strong></li>
<li><strong>全局换肤</strong></li>
<li><strong>获取控件加载耗时</strong></li>
</ul>
<p>针对以上场景，实现部分关键代码以供参考</p>
<h5 id="获取控件加载耗时"><a href="#获取控件加载耗时" class="headerlink" title="获取控件加载耗时"></a>获取控件加载耗时</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">//XXActivity.java<br>    @Override<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> onCreate(@Nullable Bundle savedInstanceState) &#123;<br>      //设置自定义Factory<br>        setFactory2();<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.act_xx);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> setFactory2()&#123;<br>        LayoutInflaterCompat.setFactory2(getLayoutInflater(), new LayoutInflater.Factory2() &#123;<br>            @Override<br>            <span class="hljs-keyword">public</span> View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;<br>                <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();//加载开始时间<br>                View view = getDelegate().createView(parent, name, context, attrs);//开始加载<br>                <span class="hljs-keyword">long</span> costTime = System.currentTimeMillis() - startTime;//加载结束时间<br>                Log.e("costTime",costTime+"");<br>                return view;<br>            &#125;<br><br>            @Override<br>            <span class="hljs-keyword">public</span> View onCreateView(String name, Context context, AttributeSet attrs) &#123;<br>                return <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>setFactory2()</code>不可以放到<code>super.onCreate()</code>之后，会触发<code>A factory has already been set on this LayoutInflater</code>异常，原因就在于<code>setFactory2()</code>最多支持设置一个。</p>
<h5 id="替换字体"><a href="#替换字体" class="headerlink" title="替换字体"></a>替换字体</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> setFontFactory2() &#123;<br>    LayoutInflaterCompat.setFactory2(getLayoutInflater(), new LayoutInflater.Factory2() &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;<br>            View view = getDelegate().createView(parent, name, context, attrs);<br>            <span class="hljs-keyword">if</span> (view <span class="hljs-keyword">instanceof</span> TextView ) &#123;<br>                ((TextView) view).setTypeface(XX);//设置对应字体<br>            &#125;<br>            return view;<br>        &#125;<br><br>        @Override<br>        <span class="hljs-keyword">public</span> View onCreateView(String name, Context context, AttributeSet attrs) &#123;<br>            return <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只要执行了<code>getDelegate().createView()</code>可以保证<code>原生控件-&gt;兼容控件</code>功能正常。</p>
<h3 id="View默认创建流程"><a href="#View默认创建流程" class="headerlink" title="View默认创建流程"></a>View默认创建流程</h3><p><img src="/images/LayoutInflater-默认View创建流程.png" srcset="/img/loading.gif" lazyload="" alt="LayoutInflater-默认View创建流程"></p>
<blockquote>
<p>未设置<code>Factory/Factory2</code>就会执行默认的View创建流程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">//LayoutInflater.java<br>    View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,<br>            <span class="hljs-keyword">boolean</span> ignoreThemeAttr) &#123;<br>      ...<br>        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> Object lastContext = mConstructorArgs[0];<br>                mConstructorArgs[0] = context;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (-1 == name.indexOf('.')) &#123;<br>                        view = onCreateView(parent, name, attrs);//系统提供View<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        view = createView(name, <span class="hljs-keyword">null</span>, attrs);//自定义View<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    mConstructorArgs[0] = lastContext;<br>                &#125;<br>            &#125;<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="系统提供View"><a href="#系统提供View" class="headerlink" title="系统提供View"></a>系统提供View</h4><blockquote>
<p>例如<code>&lt;TextView/&gt;、&lt;Button/&gt;</code>等</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class PhoneLayoutInflater extends LayoutInflater &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] sClassPrefixList = &#123;<br>        "android.widget.",<br>        "android.webkit.",<br>        "android.app."<br>    &#125;;<br><br>     @Override <span class="hljs-keyword">protected</span> View onCreateView(String name, AttributeSet attrs) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">for</span> (String prefix : sClassPrefixList) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                View view = createView(name, prefix, attrs);<br>                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;<br>                    return view;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                // In <span class="hljs-keyword">this</span> <span class="hljs-keyword">case</span> we want to let the base class take a crack<br>                // at it.<br>            &#125;<br>        &#125;<br><br>        return <span class="hljs-keyword">super</span>.onCreateView(name, attrs);<br>    &#125;<br>  <br>&#125;<br><br>//LayoutInflater.java<br>    <span class="hljs-keyword">protected</span> View onCreateView(String name, AttributeSet attrs)<br>            <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        return createView(name, "android.view.", attrs);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>优先判断</p>
<ul>
<li><code>android.widget.*</code> 例如<code>android.widget.TextView</code></li>
<li><code>android.webkit.*</code> 例如<code>android.webkit.WebView</code></li>
<li><code>android.app.*</code> 例如<code>android.app.ActionBar</code></li>
</ul>
<p>是否有对应<code>nmae</code>的View实例存在</p>
<p>都不存在，就在<code>android.view.*</code>找寻对应View实例 例如<code>android.view.ViewStub</code></p>
<h4 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h4><blockquote>
<p>例如<code>android.support.v7.widget.RecyclerView</code>等</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View createView(String name, String prefix, AttributeSet attrs)<br>            <span class="hljs-keyword">throws</span> ClassNotFoundException, InflateException &#123;<br>       //构建缓存，缓存已加载的View<br>        Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);<br>        <span class="hljs-keyword">if</span> (constructor != <span class="hljs-keyword">null</span> &amp;&amp; !verifyClassLoader(constructor)) &#123;<br>            constructor = <span class="hljs-keyword">null</span>;<br>            sConstructorMap.remove(name);<br>        &#125;<br>        Class&lt;? extends View&gt; clazz = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);<br>            //新建View构造器<br>            <span class="hljs-keyword">if</span> (constructor == <span class="hljs-keyword">null</span>) &#123;<br>                // 得到全限定名 例如android,widget.TextView<br>                clazz = mContext.getClassLoader().loadClass(<br>                        prefix != <span class="hljs-keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);<br><br>                <span class="hljs-keyword">if</span> (mFilter != <span class="hljs-keyword">null</span> &amp;&amp; clazz != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">boolean</span> allowed = mFilter.onLoadClass(clazz);<br>                    <span class="hljs-keyword">if</span> (!allowed) &#123;<br>                        failNotAllowed(name, prefix, attrs);<br>                    &#125;<br>                &#125;<br>                constructor = clazz.getConstructor(mConstructorSignature);<br>                constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>                sConstructorMap.put(name, constructor);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                // If we have a filter, apply it to cached constructor<br>                <span class="hljs-keyword">if</span> (mFilter != <span class="hljs-keyword">null</span>) &#123;<br>                    // Have we seen <span class="hljs-keyword">this</span> name before?<br>                    Boolean allowedState = mFilterMap.get(name);<br>                    <span class="hljs-keyword">if</span> (allowedState == <span class="hljs-keyword">null</span>) &#123;<br>                        // New class -- remember whether it is allowed<br>                        clazz = mContext.getClassLoader().loadClass(<br>                                prefix != <span class="hljs-keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);<br><br>                        <span class="hljs-keyword">boolean</span> allowed = clazz != <span class="hljs-keyword">null</span> &amp;&amp; mFilter.onLoadClass(clazz);<br>                        mFilterMap.put(name, allowed);<br>                        <span class="hljs-keyword">if</span> (!allowed) &#123;<br>                            failNotAllowed(name, prefix, attrs);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allowedState.equals(Boolean.FALSE)) &#123;<br>                        failNotAllowed(name, prefix, attrs);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            Object lastContext = mConstructorArgs[0];<br>            <span class="hljs-keyword">if</span> (mConstructorArgs[0] == <span class="hljs-keyword">null</span>) &#123;<br>                // Fill in the context <span class="hljs-keyword">if</span> not already within inflation.<br>                mConstructorArgs[0] = mContext;<br>            &#125;<br>            Object[] args = mConstructorArgs;<br>            args[1] = attrs;<br>            //根据得到的 constuctor 实例化View对象<br>            <span class="hljs-keyword">final</span> View view = constructor.newInstance(args);<br>            //针对ViewStub特殊处理<br>            <span class="hljs-keyword">if</span> (view <span class="hljs-keyword">instanceof</span> ViewStub) &#123;<br>                // Use the same context when inflating ViewStub later.<br>                <span class="hljs-keyword">final</span> ViewStub viewStub = (ViewStub) view;<br>                viewStub.setLayoutInflater(cloneInContext((Context) args[0]));<br>            &#125;<br>            mConstructorArgs[0] = lastContext;<br>            return view;<br><br>        &#125; <br>  ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p><code>View默认创建</code>流程分为：</p>
<ul>
<li><code>&lt;tag&gt;</code>不包含<code>.</code>，用于处理<code>&lt;TextView&gt;、&lt;WebView&gt;</code>等标签，此时需要拼接<code>android.widget. 或 android.webkit. 或 android.app.</code>前缀(<strong>实现位于<code>PhoneLayoutInflater</code></strong>)，都没有找到对应的<code>View实例</code>时，就会在添加<code>android.view.</code>再去加载。</li>
<li><code>&lt;tag&gt;</code>包含<code>.</code>，此时的实例View分为以下几步：<ul>
<li>构建View的缓存，缓存的是<code>constructor</code>，根据<code>name</code>获取<code>constructor</code></li>
<li>缓存中不存在时，需要根据<code>prefix+name</code>获取View的<code>constructor</code>，并存入缓存中</li>
<li>根据<code>constructor</code>构造<code>View实例</code>——<code>constructor.newInstance()</code></li>
<li>如果需要处理<code>ViewStub</code>，为<code>ViewStub</code>指定加载类</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/LayoutInflater过程.jpg" srcset="/img/loading.gif" lazyload="" alt="LayoutInflater过程"></p>
<h2 id="View的绘制流程触发"><a href="#View的绘制流程触发" class="headerlink" title="View的绘制流程触发"></a>View的绘制流程触发</h2><p>调用了<code>ViewRootImpl.setView(decorView)</code>将DecorView与ViewRootImpl进行了关联。View的绘制流程就是从ViewRoot开始的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;<br>     <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>         //传进来的DecorView作为全局变量使用<br>          mView = view;<br>         ...<br>          // Schedule the first layout -before- adding to the window<br>                // manager, to make sure we <span class="hljs-keyword">do</span> the relayout before receiving<br>                // any other events from the system.<br>          //绘制整个布局<br>          requestLayout();   <br>         ...<br>          //设置ViewRootImpl为DecorView的parentView <br>          view.assignParent(<span class="hljs-keyword">this</span>);<br>     &#125;   <br> &#125;<br><br>//请求刷新整个布局<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> requestLayout() &#123;<br>        <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;<br>            checkThread();<br>            mLayoutRequested = <span class="hljs-keyword">true</span>;<br>            scheduleTraversals();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> scheduleTraversals() &#123;<br>        <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;<br>            mTraversalScheduled = <span class="hljs-keyword">true</span>;<br>            //添加同步屏障<br>            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();<br>            mChoreographer.postCallback(<br>                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (!mUnbufferedInputDispatch) &#123;<br>                scheduleConsumeBatchedInput();<br>            &#125;<br>            notifyRendererOfFramePending();<br>            pokeDrawLockIfNeeded();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> class TraversalRunnable implements Runnable &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>            doTraversal();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">final</span> TraversalRunnable mTraversalRunnable = new TraversalRunnable();<br><br>    <span class="hljs-keyword">void</span> doTraversal() &#123;<br>        <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;<br>            mTraversalScheduled = <span class="hljs-keyword">false</span>;<br>            //移除同步屏障<br>            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);<br><br>            <span class="hljs-keyword">if</span> (mProfile) &#123;<br>                Debug.startMethodTracing("ViewAncestor");<br>            &#125;<br>            //这里开始View的绘制流程<br>            performTraversals();<br><br>            <span class="hljs-keyword">if</span> (mProfile) &#123;<br>                Debug.stopMethodTracing();<br>                mProfile = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>ViewRootImpl.setView()</code>中最后调用到了<code>performTraversals()</code>在这个方法中开始View的绘制流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performTraversals() &#123;<br>  ...<br>   <span class="hljs-keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>   <br>   ...<br>   <span class="hljs-keyword">if</span> (!mStopped || mReportNextDraw) &#123;<br>      <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);<br>2  <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);<br>      ...<br>        <span class="hljs-keyword">if</span>(layoutRequested)&#123;<br>          //开始Measure过程，定义View的宽高<br>          performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<br>          ...<br>        &#125;<br>   &#125;<br>  <br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>    <span class="hljs-keyword">if</span>(didLayout)&#123;<br>        //开始Layout过程，决定View的位置<br>        performLayout(lp, mWidth, mHeight);<br>        ...<br>    &#125;<br>    <br>     <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;<br>            <span class="hljs-keyword">if</span> (mPendingTransitions != <span class="hljs-keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;<br>                    mPendingTransitions.get(i).startChangingAnimations();<br>                &#125;<br>                mPendingTransitions.clear();<br>            &#125;<br>            //开始Draw过程，决定了View的显示，这个过程结束才可以看到内容<br>            performDraw();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过以上流程分析：<strong>View的绘制流程是从<code>ViewRootImpl</code>中开始的，先调用<code>performTraversals()</code>开始绘制，随后调用内部的<code>performMeasure()</code>开始Measure过程，调用<code>performLayout()</code>，开始Layout过程，最后调用<code>performDraw()</code>开始Draw，完成后就可以现在在屏幕上。</strong></p>
<p><img src="/images/View绘制流程.png" srcset="/img/loading.gif" lazyload="" alt="View绘制流程"></p>
<p>如上图所示，<code>performTraversals()</code>依次调用<code>performMeasure()，performLayout(),performDraw()</code>完成View的绘制。</p>
<h2 id="View工作流程"><a href="#View工作流程" class="headerlink" title="View工作流程"></a>View工作流程</h2><blockquote>
<p>主要是指<code>measure(测量)</code>,<code>layout(布局)</code>,<code>draw(绘制)</code>三大流程。</p>
</blockquote>
<h3 id="measure-测量"><a href="#measure-测量" class="headerlink" title="measure-测量"></a>measure-测量</h3><blockquote>
<p>起点位于<code>performMeasure()</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performMeasure(<span class="hljs-keyword">int</span> childWidthMeasureSpec, <span class="hljs-keyword">int</span> childHeightMeasureSpec) &#123;<br>       ...<br>        <span class="hljs-keyword">try</span> &#123;<br>            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            Trace.traceEnd(Trace.TRACE_TAG_VIEW);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h4><p><img src="/images/measure-MeasureSpec.png" srcset="/img/loading.gif" lazyload="" alt="measure-MeasureSpec"></p>
<blockquote>
<p>MeasureSpec代表一个32位int值，高2位代表SpecMode(测量模式)，低30位代表SpecSize(某种测量模式下的规格大小)。</p>
</blockquote>
<p>作用：父控件提供给子View的一个参数，作为设定自身大小参考，实际大小还是有子View自身决定。</p>
<p><img src="/images/MeasureSpec结构" srcset="/img/loading.gif" lazyload="" alt="MeasureSpec结构"></p>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> class MeasureSpec &#123;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MODE_SHIFT = 30;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;<br><br>       /** @hide */<br>       @IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)<br>       @Retention(RetentionPolicy.SOURCE)<br>       <span class="hljs-keyword">public</span> @interface MeasureSpecMode &#123;&#125;<br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> EXACTLY     = 1 &lt;&lt; MODE_SHIFT;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> AT_MOST     = 2 &lt;&lt; MODE_SHIFT;<br><br>     @MeasureSpecMode<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> getMode(<span class="hljs-keyword">int</span> measureSpec) &#123;<br>           //noinspection ResourceType<br>           return (measureSpec &amp; MODE_MASK);<br>       &#125;<br>         <br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> getSize(<span class="hljs-keyword">int</span> measureSpec) &#123;<br>           return (measureSpec &amp; ~MODE_MASK);<br>       &#125;<br></code></pre></td></tr></table></figure>
<p><code>SpecMode</code>分为三类：</p>
<ul>
<li><code>UNSPECIFIED</code>：<strong>未指定模式</strong>。父控件不对子控件添加束缚，子元素可以为任意大小，一般用于系统内部的测量。比如<code>ScrollView</code></li>
<li><code>EXACTLY</code>：<strong>精确模式</strong>。父控件为子View指定精确大小，希望子View完全按照自己给的尺寸处理大小。一般是设置了<code>明确的值</code>或是<code>MATCH_PARENT</code></li>
<li><code>AT_MOST</code>：<strong>最大模式</strong>。父控件为子View指定最大尺寸，希望子View不要超过这个尺寸。一般对应<code>WRAP_CONTENT</code></li>
</ul>
<h5 id="MeasureSpec与LayoutParams的关系"><a href="#MeasureSpec与LayoutParams的关系" class="headerlink" title="MeasureSpec与LayoutParams的关系"></a>MeasureSpec与LayoutParams的关系</h5><p>每一个View，都持有一个MeasureSpec，里面保存了View的尺寸。我们也可以使用<code>LayoutParams</code>指定View的尺寸。所以在View测量的时候，系统会将<code>LayoutParams</code>在父容器的约束下转换成<code>MeasureSpec</code>，然后根据转换后的值确定宽高。</p>
<p><strong>转换后的MeasureSpec是由LayoutParams和父容器的MeasureSpec一起决定的。</strong></p>
<table>
<thead>
<tr>
<th>下：childLayoutParams 右：parentSpecMode</th>
<th>EXACTLY</th>
<th>AT_MOST</th>
<th>UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>固定大小</td>
<td>Exactly<br>childSize</td>
<td>Exactly<br>childSize</td>
<td>Exactly<br>childSize</td>
</tr>
<tr>
<td>match_parent</td>
<td>Exactly<br>parentSize(父容器剩余空间)</td>
<td>AT_MOST<br>parentSize(最大父容器剩余空间)</td>
<td>UNSPECIFIED<br>0 或 parentSize(最大父容器剩余空间)</td>
</tr>
<tr>
<td>wrap_content</td>
<td>AT_MOST<br>parentSize(最大父容器剩余空间)</td>
<td>AT_MOST<br>parentSize(最大父容器剩余空间)</td>
<td>UNSPECIFIED<br>0 或 parentSize(最大父容器剩余空间)</td>
</tr>
</tbody>
</table>
<p>根据<code>ViewGroup.getChildMeasureSpec()</code>得出上表。</p>
<h6 id="DecorView转换MeasureSpec"><a href="#DecorView转换MeasureSpec" class="headerlink" title="DecorView转换MeasureSpec"></a>DecorView转换MeasureSpec</h6><blockquote>
<p>DecorView的转换由Window的尺寸和自身的LayoutParams决定。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/view/ViewRootImpl.java<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performTraversals() &#123;<br>    ...<br>       //DecorView Measure过程<br>       <span class="hljs-keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);<br>       <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);<br>       performMeasure(childWidthMeasureSpec,childHeightMeasureSpec)<br>    ...  <br>&#125;<br><br>//在方法中生成了DecoeView的MeasureSpec 根据Window的尺寸和自身的LayoutParams<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> getRootMeasureSpec(<span class="hljs-keyword">int</span> windowSize/*Window尺寸*/, <span class="hljs-keyword">int</span> rootDimension) &#123;<br>        <span class="hljs-keyword">int</span> measureSpec;<br>        <span class="hljs-keyword">switch</span> (rootDimension) &#123;<br>       <br>        <span class="hljs-keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:<br>            //MeasureSpec中的specSize就是窗口尺寸,specMode为EXACTLY 精确模式<br>            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:<br>            //MeasureSpec中的specSize为窗口尺寸,specMode为aT_MOST 最大模式，最大值为窗口尺寸<br>            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            //MeasureSpec中的specSize为固定尺寸,specMode为EXACTLY 精确模式<br>            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        return measureSpec;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="View的measure过程"><a href="#View的measure过程" class="headerlink" title="View的measure过程"></a>View的measure过程</h4><p><img src="/images/measure-View的measure过程.png" srcset="/img/loading.gif" lazyload="" alt="measure-View的measure过程"></p>
<p>主要是由<code>measure()</code>方法完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/view/View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> measure(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec) &#123;<br>      ...<br>        //需要执行onMeasure<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;<br>        // 布局发生变化<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> needsLayout = specChanged<br>                &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);      <br>      ...<br>        <span class="hljs-keyword">if</span> (forceLayout/*强制测量*/ || needsLayout/*需要测量*/) &#123;<br>          ...<br>          <span class="hljs-keyword">int</span> cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);<br>          //需要强制测量布局 或者。缓存无效<br>            <span class="hljs-keyword">if</span> (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;<br>                // measure ourselves, <span class="hljs-keyword">this</span> should set the measured dimension flag back<br>                onMeasure(widthMeasureSpec, heightMeasureSpec);<br>                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);<br>                // Casting a <span class="hljs-keyword">long</span> to <span class="hljs-keyword">int</span> drops the high 32 bits, no mask needed<br>                setMeasuredDimensionRaw((<span class="hljs-keyword">int</span>) (value &gt;&gt; 32), (<span class="hljs-keyword">int</span>) value);<br>              //需要在layout 再次执行 onMeasure<br>                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br>            &#125;<br>          ...<br>            //添加 PFLAG_LAYOUT_REQUIRED标记，表示需要执行 layout流程<br>             mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>measure()</code>中调用<code>onMeasure()</code>去进行实际的测量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java">//../android/view/View.java<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> onMeasure(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec) &#123;<br>        setMeasuredDimension(<br>            getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),<br>            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));<br>    &#125;<br><br>   //设置View的宽高<br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> setMeasuredDimension(<span class="hljs-keyword">int</span> measuredWidth, <span class="hljs-keyword">int</span> measuredHeight) &#123;<br>        <span class="hljs-keyword">boolean</span> optical = isLayoutModeOptical(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;<br>            Insets insets = getOpticalInsets();<br>            <span class="hljs-keyword">int</span> opticalWidth  = insets.left + insets.right;<br>            <span class="hljs-keyword">int</span> opticalHeight = insets.top  + insets.bottom;<br><br>            measuredWidth  += optical ? opticalWidth  : -opticalWidth;<br>            measuredHeight += optical ? opticalHeight : -opticalHeight;<br>        &#125;<br>        setMeasuredDimensionRaw(measuredWidth, measuredHeight);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> setMeasuredDimensionRaw(<span class="hljs-keyword">int</span> measuredWidth, <span class="hljs-keyword">int</span> measuredHeight) &#123;<br>        mMeasuredWidth = measuredWidth;<br>        mMeasuredHeight = measuredHeight;<br>        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;<br>    &#125;<br><br>    //返回View的MeasureSpec中的specSize<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> getDefaultSize(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> measureSpec) &#123;<br>        <span class="hljs-keyword">int</span> result = size;<br>        <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);<br>        <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);<br><br>        <span class="hljs-keyword">switch</span> (specMode) &#123;<br>        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>            result = size;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST://wrap_content<br>        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY://match_parent / XX <br>        //这段代码中可以分析得出 一个直接继承View的自定义View 定义为wrap_content和match_parent大小都是一致的.<br>            result = specSize;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        return result;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> getSuggestedMinimumHeight() &#123;<br>        return (mBackground == <span class="hljs-keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());<br>    &#125;<br><br>//如果View没有设置背景，返回minWidth值，默认为0。若设置了背景就取背景宽度和最小宽度中的最大值返回。<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> getSuggestedMinimumWidth() &#123;<br>        return (mBackground == <span class="hljs-keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());<br>    &#125;<br><br>    <br>// ../android/graphics/drawable/Drawable.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getMinimumWidth()&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> intrinsicWidth = getIntrinsicWidth();<br>    return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/View-Measure.png" srcset="/img/loading.gif" lazyload="" alt="View-Measure"></p>
<p>结合上述流程图，简单分析View的Measure过程</p>
<ul>
<li>系统在绘制开始时回去调用<code>View.measure()</code>，这个类是final的们无法被重写</li>
<li>后续调用<code>View.onMeasure()</code>,自定义View时可以按照自己的需求对这个方法进行重写</li>
<li><code>onMeasure()</code>中调用到<code>setMeasureDimension()</code>对View进行宽高的设置</li>
<li>需要使用<code>getDefaultSize()</code>去获取最终显示出的宽高</li>
<li>在<code>getDefaultSize()</code>中需要对传进来的<code>MeasureSpec</code>进行分析处理<ul>
<li>SpecMode若为<code>UNSPECIFIED</code>，则最终尺寸为传进来的<code>SpecSize</code></li>
<li>SpecMode为<code>AT_MOST</code>,<code>EXACTLY</code>，还需要额外判断View是否有背景<ul>
<li>有背景，最终尺寸就为View的最小尺寸和背景尺寸的最大值</li>
<li>没背景，最终尺寸就为View的最小尺寸</li>
</ul>
</li>
</ul>
</li>
<li>取到最终尺寸后，数据回溯到<code>onMeasure()</code>中，即完成测量(<code>Measure</code>)过程</li>
</ul>
<p>在上述分析中，自定义View中使用<code>wrap_content</code>时，specMode为<code>AT_MOST</code>，尺寸为父控件剩余大小，效果与使用<code>match_parent</code>一致。这也是自定义View中常碰到的问题 <em>为何自定义View是wrap_content无效？</em> 解决方法就是 自己重写<code>onMeasure()</code>对<code>wrap_content</code>特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onMeasure(<span class="hljs-keyword">int</span> widthMeasureSpec,<span class="hljs-keyword">int</span> heightMeasureSpec)&#123;<br>    <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec,heightMeasureSpec);<br>    <span class="hljs-keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);<br>    <span class="hljs-keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);<br>    <span class="hljs-keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);<br>    <span class="hljs-keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);<br>    <br>    <span class="hljs-keyword">if</span>(widthSpecMode = MeasureSpec.AT_MOST &amp;&amp; heightSpecMode = MeasureSpec.AT_MOST)&#123;<br>        setMeasureDimension(mWidth,mHeight);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(widthSpecMode = MeasureSpec.AT_MOST)&#123;<br>        setMeasureDimension(mWidth,heightSpecSize);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(heightSpecMode = MeasureSpec.AT_MOST)&#123;<br>        setMeasureDimension(widthSpecSize,mHeight);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="ViewGroup的measure过程"><a href="#ViewGroup的measure过程" class="headerlink" title="ViewGroup的measure过程"></a>ViewGroup的measure过程</h4><p><img src="/images/measure-ViewGroup的measure过程.png" srcset="/img/loading.gif" lazyload="" alt="measure-ViewGroup的measure过程"></p>
<blockquote>
<p>除了完成自身的measure过程之外，还要去遍历调用所有子元素的measure方法，各个子元素再去递归执行这个过程。</p>
<p><strong>先Measure子View，再Measure自己</strong></p>
</blockquote>
<p>ViewGroup中没有定义<code>onMeasure()</code>，定义了一个<code>measureChildren()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/view/ViewGroup.java<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> measureChildren(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = mChildrenCount;<br>        <span class="hljs-keyword">final</span> View[] children = mChildren;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">final</span> View child = children[i];<br>            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;<br>                //遍历对每一个子元素进行测量过程<br>                measureChild(child, widthMeasureSpec, heightMeasureSpec);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>循环调用<code>measureChild()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/view/ViewGroup.java<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> measureChild(View child, <span class="hljs-keyword">int</span> parentWidthMeasureSpec,<br>            <span class="hljs-keyword">int</span> parentHeightMeasureSpec) &#123;<br>        //获得子View的LayoutParams<br>        <span class="hljs-keyword">final</span> LayoutParams lp = child.getLayoutParams();<br>        //<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,<br>                mPaddingLeft + mPaddingRight, lp.width);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,<br>                mPaddingTop + mPaddingBottom, lp.height);<br><br>        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>    &#125;<br><br> //子View的MEasureSpec由父View的MEasureSpec以及自身的LayoutParams共同决定<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> getChildMeasureSpec(<span class="hljs-keyword">int</span> spec, <span class="hljs-keyword">int</span> padding, <span class="hljs-keyword">int</span> childDimension) &#123;<br>        <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(spec);<br>        <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(spec);<br><br>        //padding代指父View已占用的空间，子View无法使用，所以子View的空间需要减去padding部分<br>        <span class="hljs-keyword">int</span> size = Math.max(0, specSize - padding);<br><br>        <span class="hljs-keyword">int</span> resultSize = 0;<br>        <span class="hljs-keyword">int</span> resultMode = 0;<br><br>        <span class="hljs-keyword">switch</span> (specMode) &#123;<br>        // Parent has imposed an exact size on us<br>        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>            <span class="hljs-keyword">if</span> (childDimension &gt;= 0) &#123;<br>                resultSize = childDimension;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>                // Child wants to be our size. So be it.<br>                resultSize = size;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>                // Child wants to determine its own size. It can't be<br>                // bigger than us.<br>                resultSize = size;<br>                resultMode = MeasureSpec.AT_MOST;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br><br>        // Parent has imposed a maximum size on us<br>        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>            <span class="hljs-keyword">if</span> (childDimension &gt;= 0) &#123;<br>                // Child wants a specific size... so be it<br>                resultSize = childDimension;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>                // Child wants to be our size, but our size is not fixed.<br>                // Constrain child to not be bigger than us.<br>                resultSize = size;<br>                resultMode = MeasureSpec.AT_MOST;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>                // Child wants to determine its own size. It can't be<br>                // bigger than us.<br>                resultSize = size;<br>                resultMode = MeasureSpec.AT_MOST;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br><br>        // Parent asked to see how big we want to be<br>        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>            <span class="hljs-keyword">if</span> (childDimension &gt;= 0) &#123;<br>                // Child wants a specific size... let him have it<br>                resultSize = childDimension;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>                // Child wants to be our size... find out how big it should<br>                // be<br>                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;<br>                resultMode = MeasureSpec.UNSPECIFIED;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>                // Child wants to determine its own size.... find out how<br>                // big it should be<br>                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;<br>                resultMode = MeasureSpec.UNSPECIFIED;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        //noinspection ResourceType<br>        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>由于ViewGroup有不同布局的需要，很难统一，所以没有提供统一的<code>onMeasure()</code>方法，而是让子类自己去实现<code>onMeasure()</code>。</p>
<p><img src="/images/ViewGroup-Measure.png" srcset="/img/loading.gif" lazyload="" alt="ViewGroup-Measure"></p>
<p>根据上述流程图，简单总结一下：</p>
<ul>
<li>ViewGroup调用自身的<code>measureChildren()</code>，里面遍历自己的子View</li>
<li>遍历后调用<code>measureChild()</code>，准备给每一个子View计算它的<code>MeasureSpec</code></li>
<li>调用<code>getChildMeasureSpec()</code>计算子View的<code>MeasureSpec</code>，需要结合父布局的<code>MeasureSpec</code>以及子View的<code>LayoutParams</code>共同得出结果</li>
<li>调用子View的<code>measure()</code>，完成子View的测量过程。</li>
<li>合并子View的测量值，得到ViewGroup的测量值</li>
</ul>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol>
<li><p>在Activity启动时获取View的尺寸？</p>
<ul>
<li>在 Activity#onWindowFocusChanged 回调中获取宽高。<br><code>当Activity得到焦点或失去焦点的时候，这个方法都会被频繁调用</code></li>
<li>view.post(runnable)，在 runnable 中获取宽高。<br><code>利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。</code></li>
<li>ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。<br><code>监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露</code></li>
<li>调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高<br><code>手动对view进行measure来得到View的尺寸。</code></li>
</ul>
</li>
<li><p>不同ViewGroup实现的<code>getChildMeasureSpec()</code>可能导致不同结果</p>
<blockquote>
<p>每种ViewGroup的子类测量策略(<code>getChildMeasureSpec()</code>)不尽相同，就会导致显示结果不一致。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;FrameLayout<br>    android:layout_width="match_parent"<br>    android:layout_height="300dp"<br>    android:background="@color/colorAccent"&gt;<br>   <br>    &lt;Button<br>        android:layout_width="match_parent"<br>        android:layout_height="400dp" /&gt;<br>&lt;/FrameLayout&gt;<br>   <br>&lt;RelativeLayout<br>    android:layout_width="match_parent"<br>    android:layout_height="300dp"&gt;<br>   <br>    &lt;Button<br>        android:layout_width="match_parent"<br>        android:layout_height="400dp" /&gt;<br>&lt;/RelativeLayout&gt;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>   在<code>FrameLayout</code>和<code>RelativeLayout</code>中，<code>Button</code>显示效果不一致，</p>
<ul>
<li><code>FrameLayout</code>中<code>Button</code>高度为<code>400dp</code></li>
<li><p><code>RelativeLayout</code>中<code>Button</code>高度为<code>300dp</code></p>
<p><code>FrameLayout</code>遵循默认的<code>ViewGroup.getChildMeasureSpec()</code>，<code>RelativeLayout</code>重写<code>getChildMeasureSpec()</code>。</p>
</li>
</ul>
<h3 id="layout-布局"><a href="#layout-布局" class="headerlink" title="layout-布局"></a>layout-布局</h3><blockquote>
<p>ViewGroup用来确定子元素的位置，当ViewGroup位置被确定后，在<code>onLayout()</code>中遍历所有子View，并调用其<code>layout()</code>。</p>
<p><strong>先layout自身后layout子元素。</strong></p>
<p>起点位于<code>performLayout()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performLayout(WindowManager.LayoutParams lp, <span class="hljs-keyword">int</span> desiredWindowWidth,<br>        <span class="hljs-keyword">int</span> desiredWindowHeight) &#123;<br>   //正在执行layout流程<br>   mInLayout = <span class="hljs-keyword">true</span>;<br><br>   <span class="hljs-keyword">final</span> View host = mView;//对应DecorView<br>  //执行DecorView的layout过程<br>  host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());<br>   //在layout过程中 尚未执行requestLayout的view<br>   <span class="hljs-keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();<br>   <span class="hljs-keyword">if</span> (numViewsRequestingLayout &gt; 0) &#123;<br>      //寻找mPrivateFlags为PFLAG_FORCE_LAYOUT的View<br>       ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,<br>                    <span class="hljs-keyword">false</span>);<br>            <span class="hljs-keyword">if</span> (validLayoutRequesters != <span class="hljs-keyword">null</span>) &#123;<br>              //当前View重新measure<br>                 measureHierarchy(host, lp, mView.getContext().getResources(),<br>                        desiredWindowWidth, desiredWindowHeight);     <br>              //重新执行layout<br>                 host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());  <br>              ...<br>                //寻找尚未设置 PFLAG_FORCE_LAYOUT的View<br>                 validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="hljs-keyword">true</span>);                   <br>                 <span class="hljs-keyword">if</span> (validLayoutRequesters != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;<br>                    // 执行requestLayout在下一帧执行时<br>                    getRunQueue().post(new Runnable() &#123;<br>                        @Override<br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>                            <span class="hljs-keyword">int</span> numValidRequests = finalRequesters.size();<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; numValidRequests; ++i) &#123;<br>                                <span class="hljs-keyword">final</span> View view = finalRequesters.get(i);<br>                                Log.w("View", "requestLayout() improperly called by " + view +<br>                                        " during second layout pass: posting in next frame");<br>                                view.requestLayout();<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;                 <br>            &#125;<br>   &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>主要执行了三步：</p>
<ul>
<li>执行<code>DecorView</code>的<code>layout</code>过程</li>
<li>执行调用过<code>requestLayout()</code>的View(包含<code>PFLAG_FORCE_LAYOUT</code>标志)的<code>measure</code>和<code>layout</code></li>
<li>还没调用过<code>requestLayout()</code>的View加入到队列中，等待下一帧绘制时执行</li>
</ul>
<h4 id="View的layout过程"><a href="#View的layout过程" class="headerlink" title="View的layout过程"></a>View的layout过程</h4><p><img src="/images/layout-View的layout过程.png" srcset="/img/loading.gif" lazyload="" alt="layout-View的layout过程"></p>
<p>主要是由View的<code>layout()</code>方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/view/View.java   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> layout(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b) &#123;<br>        <span class="hljs-keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;<br>          //需要再次测量 可能缓存无效<br>            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);<br>            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br>        &#125;<br>        <br>        //左上角顶点距父容器左边的距离<br>        <span class="hljs-keyword">int</span> oldL = mLeft;<br>        //左上角顶点距父容器上边的距离<br>        <span class="hljs-keyword">int</span> oldT = mTop;<br>        //右下角顶点距父容器上边的距离<br>        <span class="hljs-keyword">int</span> oldB = mBottom;<br>        //右下角顶点距父容器上边的距离<br>        <span class="hljs-keyword">int</span> oldR = mRight;<br>        //判断本次布局流程是否发生了布局的变化<br>        <span class="hljs-keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?<br>                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);<br><br>        <span class="hljs-keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;<br>          //通知View进行布局过程<br>            onLayout(changed, l, t, r, b);<br>            ...<br>              //通知View布局发生变化<br>            listenersCopy.get(i).onLayoutChange(<span class="hljs-keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);              <br>        &#125;<br>        ...<br>    &#125;<br><br>//由于子View下是没有子类了，所以该方法内不没有任何代码实现 一般自定义View是不需要重写该方法的<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> onLayout(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom) &#123;<br>    <br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> setOpticalFrame(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom) &#123;<br>        Insets parentInsets = mParent <span class="hljs-keyword">instanceof</span> View ?<br>                ((View) mParent).getOpticalInsets() : Insets.NONE;<br>        Insets childInsets = getOpticalInsets();<br>        //根据特效边框重新计算四个顶点的位置，然后调用setFrame重新计算<br>        return setFrame(<br>                left   + parentInsets.left - childInsets.left,<br>                top    + parentInsets.top  - childInsets.top,<br>                right  + parentInsets.left + childInsets.right,<br>                bottom + parentInsets.top  + childInsets.bottom);<br>    &#125;<br><br>//保存本次布局信息<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> setFrame(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom) &#123;<br>             <span class="hljs-keyword">boolean</span> changed = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;<br>            changed = <span class="hljs-keyword">true</span>;<br><br>            // Remember our drawn bit<br>            <span class="hljs-keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;<br><br>            <span class="hljs-keyword">int</span> oldWidth = mRight - mLeft;<br>            <span class="hljs-keyword">int</span> oldHeight = mBottom - mTop;<br>            <span class="hljs-keyword">int</span> newWidth = right - left;<br>            <span class="hljs-keyword">int</span> newHeight = bottom - top;<br>            <span class="hljs-keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);<br><br>            // 布局发生变化 需要执行重绘流程<br>            invalidate(sizeChanged);<br>            //重新计算View的四个顶点距父布局左上边框的距离<br>            mLeft = left;<br>            mTop = top;<br>            mRight = right;<br>            mBottom = bottom;<br>            mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);<br>            ...<br>        &#125;<br>&#125;<br><br><br>//判断当前View是否存在阴影或者外发光等边框效果<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> isLayoutModeOptical(Object o) &#123;<br>        return o <span class="hljs-keyword">instanceof</span> ViewGroup &amp;&amp; ((ViewGroup) o).isLayoutModeOptical();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/View-Layout.png" srcset="/img/loading.gif" lazyload="" alt="View-Layout"></p>
<p>按照流程图总结一下：</p>
<ul>
<li>View调用<code>layout()</code>开始布局过程(<code>确定最终宽高以及四个顶点的位置</code>)</li>
<li>根据是否有边缘效果(<code>例如发光，阴影</code>)<ul>
<li>有边缘效果，调用<code>setOpticalFrame()</code>去除边缘的影响，最终还是调用<code>setFrame()</code>设立自己的四个顶点</li>
<li>无边缘效果，调用<code>setFrame()</code>设立自己的四个顶点</li>
</ul>
</li>
<li>最后调用<code>onLayout()</code>最终确立宽高以及四点坐标。</li>
</ul>
<h4 id="ViewGroup的layout过程"><a href="#ViewGroup的layout过程" class="headerlink" title="ViewGroup的layout过程"></a>ViewGroup的layout过程</h4><p><img src="/images/layout-ViewGroup的layout过程.png" srcset="/img/loading.gif" lazyload="" alt="layout-ViewGroup的layout过程"></p>
<p>当有子View存在的时候，需要遍历子View进行<code>layout</code>过程。即需要在<code>onLayout()</code>方法实现子View的<code>layout</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewGroup.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> layout(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b) &#123;<br>        <span class="hljs-keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="hljs-keyword">null</span> || !mTransition.isChangingLayout())) &#123;<br>            <span class="hljs-keyword">if</span> (mTransition != <span class="hljs-keyword">null</span>) &#123;<br>                mTransition.layoutChange(<span class="hljs-keyword">this</span>);<br>            &#125;<br>          //调用View.layout()<br>            <span class="hljs-keyword">super</span>.layout(l, t, r, b);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            // record the fact that we noop'd it; request layout when transition finishes<br>            mLayoutCalledWhileSuppressed = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> onLayout(<span class="hljs-keyword">boolean</span> changed,<br>            <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b);<br><br>//源码与上述相同 由于ViewGroup中所有子View的layout都需要实现，所以需要实现 onLayout() 方法<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> onLayout(<span class="hljs-keyword">boolean</span> changed,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> top,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> bottom)&#123;<br>    //遍历子View<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =0 ; i &lt;getChildCount();i++)&#123;<br>        View child = getChildAt(i);<br>        <br>        //在这里可以添加 顶点变化逻辑<br>        <span class="hljs-keyword">int</span> childTop = Top;<br>        <span class="hljs-keyword">int</span> childLeft = Left;<br>        <span class="hljs-keyword">int</span> childBottom = Bottom;<br>        <span class="hljs-keyword">int</span> childRight = Right;<br>         <br>        ...<br>        setChildFrame(child,childLeft,childTop,childRight,childBottom);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> setChildFrame(child,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> b)&#123;<br>    //按照上一节流程走<br>    child.layout(l,t,r,b);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/ViewGroup-Layout.png" srcset="/img/loading.gif" lazyload="" alt="ViewGroup-Layout"></p>
<p>按照流程图简单总结一下：</p>
<ul>
<li>先调用ViewGroup的<code>layout()</code>，先对ViewGroup进行布局过程</li>
<li>在ViewGroup的<code>onLayout()</code>中实现子View的遍历布局过程</li>
<li>对遍历的子View按照ViewGroup的要求进行顶点坐标的计算，计算完成后调用子View的<code>layout()</code></li>
</ul>
<p>拓展：</p>
<ol>
<li><p>View的测量宽/高(<code>getMeasureWidth()/getMeasureHeight()</code>)与最终得到的宽/高(<code>getWidth()/getHeight()</code>)有什么区别？</p>
<p><img src="/images/layout-getMeasureWidth(" srcset="/img/loading.gif" lazyload="" alt="layout-getMeasureWidth() 与 getWidth()区别"> 与 getWidth()区别.png)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">//	获得View在测量过程中的宽<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> getMeasuredWidth() &#123;<br>        return mMeasuredWidth &amp; MEASURED_SIZE_MASK;<br>    &#125;<br>//	获得View在测量过程中的高<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> getMeasuredHeight() &#123;<br>        return mMeasuredHeight &amp; MEASURED_SIZE_MASK;<br>    &#125;<br>//	上节 measure 源码分析中就是调用了该方法 进行View的测量<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> setMeasuredDimensionRaw(<span class="hljs-keyword">int</span> measuredWidth, <span class="hljs-keyword">int</span> measuredHeight) &#123;<br>        mMeasuredWidth = measuredWidth;<br>        mMeasuredHeight = measuredHeight;<br>        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;<br>    &#125;<br>//获得View最终宽<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> getWidth() &#123;<br>        return mRight - mLeft;<br>    &#125;<br>//获得View最终高<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> getHeight() &#123;<br>        return mBottom - mTop;<br> &#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>两者的比较</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th>何时赋值</th>
<th>赋值方法</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">View测量结束宽/高<br>getMeasureWidth()/getMeasureHeight()</td>
<td>View的<code>measure</code>过程</td>
<td><code>setMeasureDimension()</code></td>
<td>在<code>onLayout()</code>获取View的宽/高</td>
</tr>
<tr>
<td style="text-align:left">View最终宽/高<br>getWidth()/getHeight()</td>
<td>View的<code>layout</code>过程</td>
<td><code>layout()</code>对top,left,right,bottom进行操作</td>
<td><code>onLayout()</code>结束后获取最终宽/高</td>
</tr>
</tbody>
</table>
<p>   <strong>一般情况下，二者返回的数据是相同的，除非人为对View的<code>layout()</code>进行重写。</strong></p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> layout(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> b)&#123;<br>    <span class="hljs-keyword">super</span>.layout(j,t,r+100,b+100);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>   上述代码就会导致View最终结果与测量时不同。</p>
<h3 id="draw-绘制"><a href="#draw-绘制" class="headerlink" title="draw-绘制"></a>draw-绘制</h3><blockquote>
<p>draw作用主要将View绘制在屏幕上面</p>
<p><strong>draw过程，先draw自身再draw子View</strong></p>
<p>起点是<code>performDraw()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performDraw() &#123;<br>      ...<br>        <span class="hljs-keyword">boolean</span> canUseAsync = draw(fullRedrawNeeded);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> draw(<span class="hljs-keyword">boolean</span> fullRedrawNeeded) &#123;<br>        <span class="hljs-keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;<br>            <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;<br>              //硬件绘制<br>              ...<br>                mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="hljs-keyword">this</span>, callback);              <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              //软件绘制<br>              ...<br>              <span class="hljs-keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,<br>                        scalingRequired, dirty, surfaceInsets)) &#123;<br>                    return <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>          ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="View的draw过程"><a href="#View的draw过程" class="headerlink" title="View的draw过程"></a>View的draw过程</h4><p><img src="/images/draw-View的draw过程.png" srcset="/img/loading.gif" lazyload="" alt="draw-View的draw过程"></p>
<p>View的draw过程，从<code>View.draw()</code>开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/view/View.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> draw(Canvas canvas) &#123;<br>    //标记当前View是否背景透明<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;<br>                (mAttachInfo == <span class="hljs-keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);<br>    <br>    <span class="hljs-keyword">int</span> saveCount;<br>        //1. 绘制背景<br>    <span class="hljs-keyword">if</span> (!dirtyOpaque) &#123;<br>            drawBackground(canvas);<br>        &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> viewFlags = mViewFlags;<br>    //是否有水平边缘<br>    <span class="hljs-keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;<br>    //是否有竖直边缘<br>    <span class="hljs-keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;<br>    <span class="hljs-keyword">if</span>(!horizontalEdges &amp;&amp; !verticalEdges)&#123;<br>       // 3.绘制View本身<br>          <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);<br><br>       // 4.绘制子View<br>          dispatchDraw(canvas);<br>        <br>       // 6.绘制装饰 例如滚动条<br>          onDrawForeground(canvas);<br>        <br>    ...<br>       return; <br>    &#125;<br>    <br>    //如果有竖直边缘或者水平边缘 例如divide<br>    <br>    // 2. 保存当前Canvas层<br>        saveCount = canvas.getSaveCount();<br>        <span class="hljs-keyword">int</span> solidColor = getSolidColor();<br>        <span class="hljs-keyword">if</span> (solidColor == 0) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;<br>            <span class="hljs-keyword">if</span> (drawTop) &#123;<br>                canvas.saveLayer(left, top, right, top + length, <span class="hljs-keyword">null</span>, flags);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (drawBottom) &#123;<br>                canvas.saveLayer(left, bottom - length, right, bottom, <span class="hljs-keyword">null</span>, flags);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (drawLeft) &#123;<br>                canvas.saveLayer(left, top, left + length, bottom, <span class="hljs-keyword">null</span>, flags);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (drawRight) &#123;<br>                canvas.saveLayer(right - length, top, right, bottom, <span class="hljs-keyword">null</span>, flags);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            scrollabilityCache.setFadeColor(solidColor);<br>        &#125;<br>    ...<br>        // 3.绘制View本身<br>          <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);<br><br>       // 4.绘制子View<br>          dispatchDraw(canvas);<br>    <br>    ...<br>        // 5.绘制边缘效果 例如阴影<br>        canvas.restoreToCount(saveCount);<br>    ...<br>        <br>       // 6.绘制装饰 例如滚动条<br>          onDrawForeground(canvas);<br>    ...<br>    <br>&#125;<br><br>//绘制View本身的背景<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> drawBackground(Canvas canvas) &#123;<br>        <span class="hljs-keyword">final</span> Drawable background = mBackground;<br>        <span class="hljs-keyword">if</span> (background == <span class="hljs-keyword">null</span>) &#123;<br>            return;<br>        &#125;<br>        //设置View的背景边界<br>        setBackgroundBounds();<br>        ...<br>          <br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrollX = mScrollX;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrollY = mScrollY;<br>        <span class="hljs-keyword">if</span> ((scrollX | scrollY) == 0) &#123;<br>            background.draw(canvas);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            //将画布偏移 然后在偏移后的画布上进行背景绘制<br>            canvas.translate(scrollX, scrollY);<br>            background.draw(canvas);<br>            canvas.translate(-scrollX, -scrollY);<br>        &#125;<br>    &#125;<br><br>//绘制View本身的内容<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> onDraw(Canvas canvas) &#123;<br>    // 默认空实现 需要子类复写该方法以实现内容的绘制 ，自定义View中必须执行该方法<br>    &#125;<br><br>//绘制子View的内容<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> dispatchDraw(Canvas canvas) &#123;<br>    //由于View不存在子View，所以不需要实现<br>    &#125;<br><br>//绘制装饰 例如滚动条 前景图片<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onDrawForeground(Canvas canvas) &#123;<br>        onDrawScrollIndicators(canvas);<br>        onDrawScrollBars(canvas);<br><br>        <span class="hljs-keyword">final</span> Drawable foreground = mForegroundInfo != <span class="hljs-keyword">null</span> ? mForegroundInfo.mDrawable : <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (foreground != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mForegroundInfo.mBoundsChanged) &#123;<br>                mForegroundInfo.mBoundsChanged = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">final</span> Rect selfBounds = mForegroundInfo.mSelfBounds;<br>                <span class="hljs-keyword">final</span> Rect overlayBounds = mForegroundInfo.mOverlayBounds;<br><br>                <span class="hljs-keyword">if</span> (mForegroundInfo.mInsidePadding) &#123;<br>                    selfBounds.set(0, 0, getWidth(), getHeight());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    selfBounds.set(getPaddingLeft(), getPaddingTop(),<br>                            getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());<br>                &#125;<br><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ld = getLayoutDirection();<br>                Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),<br>                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);<br>                foreground.setBounds(overlayBounds);<br>            &#125;<br><br>            foreground.draw(canvas);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/View-Draw.png" srcset="/img/loading.gif" lazyload="" alt="View-Draw"></p>
<p>结合上述流程图分析Draw过程：</p>
<ul>
<li>先调用<code>View.draw()</code>方法开始Draw流程</li>
<li>如果需要<code>dirtyOpaque</code>，就绘制背景<code>drawBackground()</code></li>
<li>如果需要显示边缘效果，就进行保存画布<code>canvas.saveLayer()</code></li>
<li>如果需要<code>dirtyOpaque</code>，绘制自身的内容<code>onDraw()</code> – <strong>自定义View必须实现</strong></li>
<li>调用<code>dispatchDraw()</code>绘制子View</li>
<li>如果需要显示边缘效果，绘制后，还原画布<code>canvas.restore()</code></li>
<li>调用<code>drawForeground()</code>绘制装饰，例如滚动条或前景</li>
</ul>
<h4 id="ViewGroup的draw过程"><a href="#ViewGroup的draw过程" class="headerlink" title="ViewGroup的draw过程"></a>ViewGroup的draw过程</h4><p><img src="/images/draw-ViewGroup的draw过程.png" srcset="/img/loading.gif" lazyload="" alt="draw-ViewGroup的draw过程"></p>
<p>ViewGroup的draw过程主要调整了上述源码中的<code>dispatchDraw()</code>，在其内部进行了子View的遍历以及绘制过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> // ../android/view/ViewGroup.java<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> dispatchDraw(Canvas canvas) &#123;<br>        <span class="hljs-keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childrenCount = mChildrenCount;<br>        <span class="hljs-keyword">final</span> View[] children = mChildren;<br>    ...<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; childrenCount; i++) &#123;<br>            <span class="hljs-keyword">while</span> (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;<br>                <span class="hljs-keyword">final</span> View transientChild = mTransientViews.get(transientIndex);<br>                <span class="hljs-keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||<br>                        transientChild.getAnimation() != <span class="hljs-keyword">null</span>) &#123;<br>                    more |= drawChild(canvas, transientChild, drawingTime);<br>                &#125;<br>                transientIndex++;<br>                <span class="hljs-keyword">if</span> (transientIndex &gt;= transientCount) &#123;<br>                    transientIndex = -1;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<br>            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);<br>            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;<br>                more |= drawChild(canvas, child, drawingTime);<br>            &#125;<br>        &#125;<br>    ...<br>&#125;<br><br>//绘制子View<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> drawChild(Canvas canvas, View child, <span class="hljs-keyword">long</span> drawingTime) &#123;<br>      //调用子View的draw方法<br>      return child.draw(canvas, <span class="hljs-keyword">this</span>, drawingTime);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/ViewGroup-Draw.png" srcset="/img/loading.gif" lazyload="" alt="ViewGroup-Draw"></p>
<p>结合上述流程图分析ViewGroup的Draw过程：</p>
<ul>
<li>draw过程与上述<code>View的draw过程一致</code></li>
<li><code>dispatchDraw()</code>默认实现，内部包含了子View的遍历以及绘制</li>
</ul>
<p>拓展：</p>
<ol>
<li><p><code>View.setWillNotDraw()</code>有什么意义?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setWillNotDraw(<span class="hljs-keyword">boolean</span> willNotDraw) &#123;<br>    //设置 不需绘制 标记位<br>    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果一个View不需要绘制任何内容，设置这个标记为<code>true</code>，系统就会进行相应优化。</p>
<p><strong><em>View默认不开启<code>willNotDraw</code>标记位，ViewGroup默认开启。</em></strong></p>
</li>
<li><p><code>ViewGroup</code>修改子View绘制顺序</p>
<p><img src="/images/draw-ViewGroup自定义绘制顺序.png" srcset="/img/loading.gif" lazyload="" alt="draw-ViewGroup自定义绘制顺序"></p>
<figure class="highlight java"><figcaption><span>ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> dispatchDraw(Canvas canvas)&#123;<br>  ...<br>    //设置自定义绘制顺序<br>   <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties<br>                ? <span class="hljs-keyword">null</span> : buildOrderedChildList();<br>        //是否允许自定义绘制顺序<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = preorderedList == <span class="hljs-keyword">null</span><br>                &amp;&amp; isChildrenDrawingOrderEnabled();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; childrenCount; i++) &#123;<br>            <span class="hljs-keyword">while</span> (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;<br>                <span class="hljs-keyword">final</span> View transientChild = mTransientViews.get(transientIndex);<br>                <span class="hljs-keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||<br>                        transientChild.getAnimation() != <span class="hljs-keyword">null</span>) &#123;<br>                    more |= drawChild(canvas, transientChild, drawingTime);<br>                &#125;<br>                transientIndex++;<br>                <span class="hljs-keyword">if</span> (transientIndex &gt;= transientCount) &#123;<br>                    transientIndex = -1;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<br>            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);<br>            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;<br>                more |= drawChild(canvas, child, drawingTime);<br>            &#125;<br>        &#125;<br> ...<br>&#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isChildrenDrawingOrderEnabled() &#123;<br>        return (mGroupFlags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == FLAG_USE_CHILD_DRAWING_ORDER;<br>    &#125;<br>//设置是否允许自定义绘制顺序<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> setChildrenDrawingOrderEnabled(<span class="hljs-keyword">boolean</span> enabled) &#123;<br>        setBooleanFlag(FLAG_USE_CHILD_DRAWING_ORDER, enabled);<br>    &#125;<br><br> //初始子View的绘制顺序 按照z轴的值调整绘制顺序，z轴从大到小绘制<br>    ArrayList&lt;View&gt; buildOrderedChildList() &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childrenCount = mChildrenCount;<br>        <span class="hljs-keyword">if</span> (childrenCount &lt;= 1 || !hasChildWithZ()) return <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">if</span> (mPreSortedChildren == <span class="hljs-keyword">null</span>) &#123;<br>            mPreSortedChildren = new ArrayList&lt;&gt;(childrenCount);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            // callers should clear, so clear shouldn't be necessary, but <span class="hljs-keyword">for</span> safety...<br>            mPreSortedChildren.clear();<br>            mPreSortedChildren.ensureCapacity(childrenCount);<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = isChildrenDrawingOrderEnabled();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; childrenCount; i++) &#123;<br>            // add next child (in child order) to end of list<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<br>            <span class="hljs-keyword">final</span> View nextChild = mChildren[childIndex];<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> currentZ = nextChild.getZ();<br><br>            // insert ahead of any Views with greater Z<br>            <span class="hljs-keyword">int</span> insertIndex = i;<br>            <span class="hljs-keyword">while</span> (insertIndex &gt; 0 &amp;&amp; mPreSortedChildren.get(insertIndex - 1).getZ() &gt; currentZ) &#123;<br>                insertIndex--;<br>            &#125;<br>            mPreSortedChildren.add(insertIndex, nextChild);<br>        &#125;<br>        return mPreSortedChildren;<br>    &#125;<br><br>    //确定当前子View的绘制顺序<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> getAndVerifyPreorderedIndex(<span class="hljs-keyword">int</span> childrenCount, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">boolean</span> customOrder) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex;<br>        <span class="hljs-keyword">if</span> (customOrder) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex1 = getChildDrawingOrder(childrenCount, i);<br>            <span class="hljs-keyword">if</span> (childIndex1 &gt;= childrenCount) &#123;<br>                throw new IndexOutOfBoundsException("getChildDrawingOrder() "<br>                        + "returned invalid index " + childIndex1<br>                        + " (child count is " + childrenCount + ")");<br>            &#125;<br>            childIndex = childIndex1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            childIndex = i;<br>        &#125;<br>        return childIndex;<br>    &#125;<br>//需要重写该方法，调整绘制顺序<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> getChildDrawingOrder(<span class="hljs-keyword">int</span> childCount, <span class="hljs-keyword">int</span> i) &#123;<br>        return i;<br>    &#125;<br><br>//调整当前子View顺序<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> View getAndVerifyPreorderedView(ArrayList&lt;View&gt; preorderedList, View[] children,<br>            <span class="hljs-keyword">int</span> childIndex) &#123;<br>        <span class="hljs-keyword">final</span> View child;<br>        <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-keyword">null</span>) &#123;<br>            child = preorderedList.get(childIndex);<br>            <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;<br>                throw new RuntimeException("Invalid preorderedList contained <span class="hljs-keyword">null</span> child at index "<br>                        + childIndex);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            child = children[childIndex];<br>        &#125;<br>        return child;<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>   根据上述源码，默认的绘制<strong>按照z轴从大到小的顺序</strong>进行绘制，如果需要修改绘制顺序的话，需要执行以下两步：</p>
<ol>
<li><code>setChildrenDrawingEnabled(true)</code>打开自定义设置开关</li>
<li><p>继承<code>ViewGroup</code>后，重写<code>getChildDrawingOrder()</code>方法，设置对应的绘制顺序</p>
<p>常用的<code>RecyclerView</code>、<code>ViewPager</code>都实现了该方法，其中<code>RecyclerView</code>通过设置<code>ChildDrawingOrderCallback</code>也可以实现这个功能。</p>
</li>
</ol>
<p>如果在<code>addView()</code>的场景下，可通过<code>setElevation()</code>或<code>setTranslationZ()</code>或<code>setZ()</code>去修改Z轴的坐标值。</p>
<h2 id="自定义View-1"><a href="#自定义View-1" class="headerlink" title="自定义View"></a>自定义View</h2><p><img src="/images/自定义View.png" srcset="/img/loading.gif" lazyload="" alt="自定义View"></p>
<blockquote>
<p>自定义View需要了解View的层次、View的事件分发机制以及View的工作流程。</p>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="1-继承View重写onDraw"><a href="#1-继承View重写onDraw" class="headerlink" title="1.继承View重写onDraw()"></a>1.继承View重写<code>onDraw()</code></h4><blockquote>
<p>主要用于实现一些不规则的效果，不方便通过布局的组合方法可以直接实现，往往需要静态或者动态的显示一些不规则图形(圆形啥的)。</p>
<p>特殊形状的这种就需要重写<code>onDraw()</code>实现。<strong>一般需要额外支持wrtap_content，并且也需要处理padding方法。</strong></p>
</blockquote>
<h4 id="2-继承ViewGroup派生特殊的Layout"><a href="#2-继承ViewGroup派生特殊的Layout" class="headerlink" title="2.继承ViewGroup派生特殊的Layout"></a>2.继承ViewGroup派生特殊的Layout</h4><blockquote>
<p>主要用于实现自定义的布局，除了常用的一些布局外。实现的是几种View的组合形式</p>
<p><strong>实现稍微复杂，需要合适的处理ViewGroup的<code>onMeasure()，onLayout()</code>以及子View的<code>onMeasure()，onLayout()</code></strong></p>
</blockquote>
<h4 id="3-继承特定的View-例如TextView"><a href="#3-继承特定的View-例如TextView" class="headerlink" title="3.继承特定的View(例如TextView)"></a>3.继承特定的View(例如TextView)</h4><blockquote>
<p>这种比较常见，一般用于拓展已有View的功能。</p>
<p><strong>实现比较简单，无需自己处理wrap_content以及padding</strong></p>
</blockquote>
<h4 id="4-继承特定的ViewGroup-例如LinearLayout"><a href="#4-继承特定的ViewGroup-例如LinearLayout" class="headerlink" title="4.继承特定的ViewGroup(例如LinearLayout)"></a>4.继承特定的ViewGroup(例如LinearLayout)</h4><blockquote>
<p>比较常见，当某种效果看起来很像几种View组合在一起的时候</p>
<p><strong>实现比较简单，无需自己处理测量以及布局过程</strong></p>
</blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><img src="/images/自定义View-注意事项.png" srcset="/img/loading.gif" lazyload="" alt="自定义View-注意事项"></p>
<h4 id="1-让View支持wrap-content"><a href="#1-让View支持wrap-content" class="headerlink" title="1.让View支持wrap_content"></a>1.让View支持wrap_content</h4><blockquote>
<p>直接继承View或ViewGroup的控件，不重写<code>onMeasure()</code>并对<code>AT_MOST</code>进行处理，就无法达到需要的显示效果。</p>
</blockquote>
<h4 id="2-需要的话，让View支持padding"><a href="#2-需要的话，让View支持padding" class="headerlink" title="2.需要的话，让View支持padding"></a>2.需要的话，让View支持padding</h4><blockquote>
<p>直接继承View的控件，需要在<code>draw</code>过程处理padding属性，不然padding属性无法起作用。</p>
<p>直接继承ViewGroup的控件，需要在<code>onMeasure()，onLayout()</code>处理自身的padding以及子View的margin<code>measureChildWithMargin()</code></p>
</blockquote>
<h4 id="3-尽量不要在View中使用Handler"><a href="#3-尽量不要在View中使用Handler" class="headerlink" title="3.尽量不要在View中使用Handler"></a>3.尽量不要在View中使用Handler</h4><blockquote>
<p>View内部提供了<code>post</code>方法，可以替代Handler使用</p>
</blockquote>
<h4 id="4-View中如果有线程或动画，需要及时停止"><a href="#4-View中如果有线程或动画，需要及时停止" class="headerlink" title="4.View中如果有线程或动画，需要及时停止"></a>4.View中如果有线程或动画，需要及时停止</h4><blockquote>
<ol>
<li>不处理有可能造成内存泄漏，View不可见时也需要停止线程和动画</li>
<li>包含View的Activity启动时，View的<code>onAccachedToWindow()</code>会调用</li>
<li>包含View的Activity退出或当前View被移除时，调用<code>View.onDetachedFromWindow()</code>时关闭线程和动画</li>
</ol>
</blockquote>
<h4 id="5-View若有滑动冲突情况，需要处理"><a href="#5-View若有滑动冲突情况，需要处理" class="headerlink" title="5.View若有滑动冲突情况，需要处理"></a>5.View若有滑动冲突情况，需要处理</h4><blockquote>
<p>滑动冲突处理方法：</p>
<ul>
<li><p><code>外部拦截法</code>：点击事件都先经过<strong>父容器的拦截处理</strong>，如果父容器需要此事件就拦截，不需要就放行</p>
<p>重写父容器的<code>onInterceptTouchEvent()</code>，在方法内部拦截</p>
</li>
<li><p><code>内部拦截法</code>：父容器不拦截任何事件，所有事件交由子容器进行处理，如果子容器需要就消耗事件，不需要就返给父容器处理。</p>
<p>重写父容器的<code>onInterceptTouchEvent()</code>，以及子容器的<code>dispatchTouchEvent()</code>。关键在于调用<code>requestDisallowInterceptTouchEvent()</code>控制父布局是否进行拦截。</p>
</li>
</ul>
<p>一般推荐使用<code>外部拦截法</code>，符合事件分发流程。</p>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3>{% post_link 自定义View实践%}
{% post_link 自定义ViewGroup实践%}
<h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><h3 id="如何触发View的重新绘制？"><a href="#如何触发View的重新绘制？" class="headerlink" title="如何触发View的重新绘制？"></a>如何触发View的重新绘制？</h3><p>通过调用<code>invalidate()/postInvalidate()</code>或<code>requestLayout()</code>实现。</p>
<p><img src="/images/View工作原理-触发View的重新绘制.png" srcset="/img/loading.gif" lazyload="" alt="View工作原理-触发View的重新绘制"></p>
<h4 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h4><p><img src="/images/View工作原理-requestLayout.png" srcset="/img/loading.gif" lazyload="" alt="View工作原理-requestLayout"></p>
<blockquote>
<p>在需要刷新<code>View</code>的布局时会调用该函数。不应该在布局的过程中调用这个函数。</p>
<p>这个请求可能会在以下场景执行：当前布局结束、当前帧绘制完成，下次布局发生时</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> requestLayout() &#123;<br>        <span class="hljs-keyword">if</span> (mMeasureCache != <span class="hljs-keyword">null</span>) mMeasureCache.clear();<br><br>        <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">null</span>) &#123;<br>            // Only trigger request-during-layout logic <span class="hljs-keyword">if</span> <span class="hljs-keyword">this</span> is the view requesting it,<br>            // not the views in its parent hierarchy<br>            ViewRootImpl viewRoot = getViewRootImpl();<br>            <span class="hljs-keyword">if</span> (viewRoot != <span class="hljs-keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;<br>                <span class="hljs-keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="hljs-keyword">this</span>)) &#123;<br>                  //如果当前在layout过程中，且调用了 requestLayout，就需要直接返回<br>                  //等待下一次信号到来时执行<br>                    return;<br>                &#125;<br>            &#125;<br>            mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">this</span>;<br>        &#125;<br>        //设置强制刷新标记<br>        mPrivateFlags |= PFLAG_FORCE_LAYOUT;//该标记可执行onMeasure()<br>        mPrivateFlags |= PFLAG_INVALIDATED;//<br><br>        <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;<br>            //向父布局继续请求刷新布局<br>            mParent.requestLayout();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">this</span>) &#123;<br>            mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>mParent</code>对应父节点，一层层向上递归调用父节点<code>requestLayout()。</code>直到调用<code>ViewRootImpl.requestLayout()</code>结束.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> requestLayout() &#123;<br>        <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;<br>          //检查当前是否主线程<br>            checkThread();<br>          //需要执行measure、layout<br>            mLayoutRequested = <span class="hljs-keyword">true</span>;<br>            scheduleTraversals();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>调用到<code>scheduleTraversals()</code>就是开始了<code>View的绘制流程</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performTraversals() &#123;<br>  //是否执行measure、layout过程<br>   <span class="hljs-keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>  ...<br>    <span class="hljs-keyword">if</span> (!mStopped || mReportNextDraw) &#123;<br>         <span class="hljs-keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()<br>                  || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||<br>                   updatedConfiguration) &#123; <br>                  //执行测量流程<br>                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);<br>         &#125;<br>    &#125;<br>  ...<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);<br>     <span class="hljs-keyword">if</span> (didLayout) &#123;<br>       //执行布局流程<br>            performLayout(lp, mWidth, mHeight);<br>     &#125;<br>  ...<br>        <span class="hljs-keyword">boolean</span> cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;<br><br>        <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;<br>            <span class="hljs-keyword">if</span> (mPendingTransitions != <span class="hljs-keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;<br>                    mPendingTransitions.get(i).startChangingAnimations();<br>                &#125;<br>                mPendingTransitions.clear();<br>            &#125;<br>          //执行绘制流程<br>            performDraw();<br>        &#125;    <br> &#125;<br></code></pre></td></tr></table></figure>
<p>一开始调用的<code>performMeasure()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performMeasure(<span class="hljs-keyword">int</span> childWidthMeasureSpec, <span class="hljs-keyword">int</span> childHeightMeasureSpec) &#123;<br>       ...<br>        <span class="hljs-keyword">try</span> &#123;<br>            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            Trace.traceEnd(Trace.TRACE_TAG_VIEW);<br>        &#125;<br>    &#125;<br><br><br>//View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> measure(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec) &#123;<br>      ...<br>        //需要执行onMeasure<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;<br>      ...<br>        <span class="hljs-keyword">if</span> (forceLayout || needsLayout) &#123;<br>          ...<br>            onMeasure(widthMeasureSpec, heightMeasureSpec);<br>          ...<br>            //添加 PFLAG_LAYOUT_REQUIRED标记，表示需要执行 layout流程<br>             mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>继续向下调用<code>performLayout()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performLayout(WindowManager.LayoutParams lp, <span class="hljs-keyword">int</span> desiredWindowWidth,<br>            <span class="hljs-keyword">int</span> desiredWindowHeight) &#123;<br>       //正在执行layout流程<br>       mInLayout = <span class="hljs-keyword">true</span>;<br><br>       <span class="hljs-keyword">final</span> View host = mView;//对应DecorView<br>       //在layout过程中 尚未执行requestLayout的view<br>       <span class="hljs-keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();<br>       <span class="hljs-keyword">if</span> (numViewsRequestingLayout &gt; 0) &#123;<br>          //寻找mPrivateFlags为PFLAG_FORCE_LAYOUT的View<br>           ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,<br>                        <span class="hljs-keyword">false</span>);<br>                <span class="hljs-keyword">if</span> (validLayoutRequesters != <span class="hljs-keyword">null</span>) &#123;<br>                  //当前View重新measure<br>                     measureHierarchy(host, lp, mView.getContext().getResources(),<br>                            desiredWindowWidth, desiredWindowHeight);     <br>                  //重新执行layout<br>                     host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());  <br>                  ...<br>                    //寻找尚未设置 PFLAG_FORCE_LAYOUT的View<br>                     validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="hljs-keyword">true</span>);                   <br>                     <span class="hljs-keyword">if</span> (validLayoutRequesters != <span class="hljs-keyword">null</span>) &#123;<br>                        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;<br>                        // 执行requestLayout在下一帧执行时<br>                        getRunQueue().post(new Runnable() &#123;<br>                            @Override<br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>                                <span class="hljs-keyword">int</span> numValidRequests = finalRequesters.size();<br>                                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; numValidRequests; ++i) &#123;<br>                                    <span class="hljs-keyword">final</span> View view = finalRequesters.get(i);<br>                                    Log.w("View", "requestLayout() improperly called by " + view +<br>                                            " during second layout pass: posting in next frame");<br>                                    view.requestLayout();<br>                                &#125;<br>                            &#125;<br>                        &#125;);<br>                    &#125;                 <br>                &#125;<br>       &#125;<br>      <br>    &#125;<br></code></pre></td></tr></table></figure>
<p>主要执行了三步：</p>
<ul>
<li>执行<code>DecorView</code>的<code>layout</code>过程</li>
<li>执行调用过<code>requestLayout()</code>的View(包含<code>PFLAG_FORCE_LAYOUT</code>标志)的<code>measure</code>和<code>layout</code></li>
<li>还没调用过<code>requestLayout()</code>的View加入到队列中，等待下一帧绘制时执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> layout(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b) &#123;<br>      //判断当前位置是否发生变化<br>        <span class="hljs-keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?<br>                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);      <br>      //位置发生变化。或 需要layout<br>        <span class="hljs-keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;<br>          //回调onLayout()<br>            onLayout(changed, l, t, r, b);<br>          ...<br>         //移除 PFLAG_LAYOUT_REQUIRED标志 在measure过程添加   <br>          mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;<br>          ...<br>        &#125;<br>      ...<br>        //layout过程完成后 移除 PFLAG_FORCE_LAYOUT标志<br>        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;        <br>      <br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> setFrame(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom) &#123;<br>      //位置发生变化时，就需要执行 invalidate()重绘View<br>      <span class="hljs-keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;<br>         <span class="hljs-keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);<br>          //需要重绘视图<br>            invalidate(sizeChanged);<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>requestLayout()</code>主要执行了以下几步：</p>
<ul>
<li>添加<code>PFLAG_FORCE_LAYOUT</code>和<code>PFLAG_INVALIDATED</code>标记</li>
<li><code>measure</code>执行需要判断<code>PFLAG_FORCE_LAYOUT</code>标记是否存在</li>
<li><code>measure</code>执行后，添加<code>PFLAG_LAYOUT_REQUIRED</code>标记，可以去执行<code>onLayout()</code></li>
<li><code>layout</code>执行后，移除<code>PFLAG_LAYOUT_REQUIRED</code>和<code>PFLAG_FORCE_LAYOUT</code>标记</li>
<li>在<code>layout</code>过程中，如果位置发生了变化，会执行到<code>invalidate()</code>，可能会执行<code>draw</code>过程；如果未发生变化，就不会执行<code>draw</code>过程</li>
</ul>
</blockquote>
<h4 id="invalidate-postInvalidate"><a href="#invalidate-postInvalidate" class="headerlink" title="invalidate/postInvalidate"></a>invalidate/postInvalidate</h4><p><img src="/images/View工作原理-Invalidate.png" srcset="/img/loading.gif" lazyload="" alt="View工作原理-Invalidate"></p>
<blockquote>
<p><code>invalidate()</code>必须在主线程调用。<code>postInvalidate()</code>可以在子线程调用(通过handler发送消息到主线程调用)</p>
<p>主要用于请求View的重绘，只会影响到View的<code>draw</code>过程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> postInvalidate() &#123;<br>        postInvalidateDelayed(0);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> dispatchInvalidateDelayed(View view, <span class="hljs-keyword">long</span> delayMilliseconds) &#123;<br>        Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);<br>        mHandler.sendMessageDelayed(msg, delayMilliseconds);<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> handleMessage(Message msg) &#123;<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                <span class="hljs-keyword">case</span> MSG_INVALIDATE:<br>                    ((View) msg.obj).invalidate();//继续执行到invalidate()<br>                    <span class="hljs-keyword">break</span>;<br>                ...<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> invalidate() &#123;<br>        invalidate(<span class="hljs-keyword">true</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>最终执行到<code>invalidateInternal()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>    <span class="hljs-keyword">void</span> invalidateInternal(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">boolean</span> invalidateCache,<br>            <span class="hljs-keyword">boolean</span> fullInvalidate) &#123;<br>        ...<br>        //当前View不可见<br>        <span class="hljs-keyword">if</span> (skipInvalidate()) &#123;<br>            return;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)<br>                || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)<br>                || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED//当前没有执行invalidate<br>                || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;<br>          //需要全量重绘<br>            <span class="hljs-keyword">if</span> (fullInvalidate) &#123;<br>                mLastIsOpaque = isOpaque();<br>              //添加重绘标记<br>                mPrivateFlags &amp;= ~PFLAG_DRAWN;<br>            &#125;<br>           //添加当前View重绘标记<br>            mPrivateFlags |= PFLAG_DIRTY;<br>           //是否刷新缓存<br>            <span class="hljs-keyword">if</span> (invalidateCache) &#123;<br>                mPrivateFlags |= PFLAG_INVALIDATED;<br>                mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;<br>            &#125;<br><br>            // Propagate the damage rectangle to the parent view.<br>            <span class="hljs-keyword">final</span> AttachInfo ai = mAttachInfo;<br>            <span class="hljs-keyword">final</span> ViewParent p = mParent;<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; ai != <span class="hljs-keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;<br>                <span class="hljs-keyword">final</span> Rect damage = ai.mTmpInvalRect;<br>                damage.set(l, t, r, b);<br>              //设置重绘区域 并把自身传递到父布局<br>                p.invalidateChild(<span class="hljs-keyword">this</span>, damage);<br>            &#125;<br>          ...<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>上述代码修改标记完成后，调用父类的<code>invalidateChild()</code>将需要重绘的区域(<code>脏区域</code>)传入。(<code>ViewGroup以及ViewRootImpl都继承自ViewParent类</code>)</p>
<blockquote>
<p>脏区域：<em>为了保证绘制的效率，控件树仅对需要绘制的区域进行重绘，需要重绘的区域成为<code>脏区域</code></em>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewGroup.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> invalidateChild(View child, <span class="hljs-keyword">final</span> Rect dirty) &#123;<br>      //开启硬件加速<br>        <span class="hljs-keyword">if</span> (attachInfo != <span class="hljs-keyword">null</span> &amp;&amp; attachInfo.mHardwareAccelerated) &#123;<br>            // 更新DisplayList<br>            onDescendantInvalidated(child, child);<br>            return;<br>        &#125;      <br>         //当前View是否 不透明<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp;<br>                    child.getAnimation() == <span class="hljs-keyword">null</span> &amp;&amp; childMatrix.isIdentity(); <br>        //全不透明 标记为 PFLAG_DIRTY_OPAQUE<br>        //部分透明 标记为 PFLAG_DIRTY<br>        <span class="hljs-keyword">int</span> opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;<br>      ...<br>        <span class="hljs-keyword">do</span> &#123;<br>                View view = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> View) &#123;<br>                    view = (View) parent;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (drawAnimation) &#123;<br>                    <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;<br>                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> ViewRootImpl) &#123;<br>                        ((ViewRootImpl) parent).mIsAnimating = <span class="hljs-keyword">true</span>;<br>                    &#125;<br>                &#125;<br><br>                // If the parent is dirty opaque or not dirty, mark it dirty with the opaque<br>                // flag coming from the child that initiated the invalidate<br>                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp;<br>                            view.getSolidColor() == 0) &#123;<br>                        opaqueFlag = PFLAG_DIRTY;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;<br>                        view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;<br>                    &#125;<br>                &#125;<br>                //递归调用父布局的重绘方法<br>                parent = parent.invalidateChildInParent(location, dirty);<br>                //计算需要重绘区域<br>                dirty.set((<span class="hljs-keyword">int</span>) Math.floor(boundingRect.left),<br>                                (<span class="hljs-keyword">int</span>) Math.floor(boundingRect.top),<br>                                (<span class="hljs-keyword">int</span>) Math.ceil(boundingRect.right),<br>                                (<span class="hljs-keyword">int</span>) Math.ceil(boundingRect.bottom));                <br>          ...<br>            &#125; <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span>);<br>      <br>    &#125;<br><br>//ViewGroup.java<br>    <span class="hljs-keyword">public</span> ViewParent invalidateChildInParent(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] location, <span class="hljs-keyword">final</span> Rect dirty) &#123;<br>        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != 0) &#123;<br>          //将子View转换为当前View显示的位置<br>          ...<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>当<code>parent==null</code>时，表示已经到了最顶层<code>ViewRootImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">public</span> ViewParent invalidateChildInParent(<span class="hljs-keyword">int</span>[] location, Rect dirty) &#123;<br>      //检查当前是否主线程<br>        checkThread();<br>        <span class="hljs-keyword">if</span> (DEBUG_DRAW) Log.v(mTag, "Invalidate child: " + dirty);<br><br>        <span class="hljs-keyword">if</span> (dirty == <span class="hljs-keyword">null</span>) &#123;<br>            invalidate();<br>            return <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;<br>            return <span class="hljs-keyword">null</span>;<br>        &#125;<br>       ...<br>      //更新屏幕对应脏区域<br>        invalidateRectOnScreen(dirty);<br><br>        return <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> invalidateRectOnScreen(Rect dirty) &#123;<br>        <span class="hljs-keyword">final</span> Rect localDirty = mDirty;<br>        <span class="hljs-keyword">if</span> (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;<br>            mAttachInfo.mSetIgnoreDirtyState = <span class="hljs-keyword">true</span>;<br>            mAttachInfo.mIgnoreDirtyState = <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        // Add the new dirty rect to the current one<br>        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);<br>        // Intersect with the bounds of the window to skip<br>        // updates that lie outside of the visible region<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> appScale = mAttachInfo.mApplicationScale;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intersected = localDirty.intersect(0, 0,<br>                (<span class="hljs-keyword">int</span>) (mWidth * appScale + 0.5f), (<span class="hljs-keyword">int</span>) (mHeight * appScale + 0.5f));<br>        <span class="hljs-keyword">if</span> (!intersected) &#123;<br>            localDirty.setEmpty();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;<br>          //执行绘制流程<br>            scheduleTraversals();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>scheduleTraversals()</code>执行绘制流程，由于未设置<code>mLayoutRequested = true</code>，所以无法进入<code>performMeasure()</code>和<code>performLayout()</code>只能执行到<code>performDraw()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">//ViewRootImpl.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> performDraw() &#123;<br>      ...<br>        <span class="hljs-keyword">boolean</span> canUseAsync = draw(fullRedrawNeeded);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> draw(<span class="hljs-keyword">boolean</span> fullRedrawNeeded) &#123;<br>        <span class="hljs-keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;<br>            <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;<br>              //硬件绘制<br>              ...<br>                mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="hljs-keyword">this</span>, callback);              <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              //软件绘制<br>              ...<br>              <span class="hljs-keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,<br>                        scalingRequired, dirty, surfaceInsets)) &#123;<br>                    return <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>          ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>向下调用到<code>View.draw()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> draw(Canvas canvas) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;<br>                (mAttachInfo == <span class="hljs-keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);<br>        <span class="hljs-keyword">if</span> (!dirtyOpaque) &#123;<br>            drawBackground(canvas);//绘制背景<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);//绘制自身<br>        dispatchDraw(canvas); //绘制子View <br>        onDrawForeground(canvas);//绘制前景<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>关键在于是否持有<code>PFLAG_DIRTY_OPAQUE</code>标志，这个标志主要是在<code>invalidate()</code>打上的。</p>
<blockquote>
<p><code>invalidate()</code>通过设置<code>PFLAG_INVALIDATED</code>和<code>PFLAG_DRAWING_CACHE_VALID</code>标记，然后执行<code>invalidateChild()</code>通过层层向上调用<code>parent.invalidateChildInParent()</code>把需要重新绘制的区域传递上去，直到达到<code>ViewRootImpl</code>为止。最后调用到<code>invalidateRectOnScreen()</code>传入最终需要重新绘制的区域，开始执行绘制流程。</p>
<p><strong>invalidate()会打上<code>PFLAG_DIRTY_OPAQUE</code>标记，只有这个标记才会执行<code>onDraw()</code>。</strong></p>
</blockquote>
<h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><p><code>rquestLayout()</code>和<code>invalidate()</code>都可以触发整个绘制流程，但是触发<code>measure</code>、<code>layout</code>、<code>draw</code>各条件都不同</p>
<ul>
<li><code>measure</code>过程触发：<code>mPrivateFlags</code>包含<code>PFLAG_FORCE_LAYOUT</code></li>
<li><code>layout</code>过程触发：<code>mPrivateFlags</code>包含<code>PFLAG_LAYOUT_REQUIRED(measure执行后添加)</code>或者<code>位置发生变化</code></li>
<li><code>draw</code>过程触发：<code>mPrivateFlags</code>包含<code>PFLAG_DIRTY_OPAQUE</code></li>
</ul>
<p><code>requestLayout()</code>主要用来设置<code>PFLAG_FORCE_LAYOUT</code>标志以及设置<code>mLayoutRequested=true</code>，会执行到<code>measure、layout</code>过程，如果位置发生变化则可能执行<code>draw</code>过程。</p>
<p><code>invalidate()</code>主要用来设置<code>PFLAG_DIRTY_OPAQUE</code>标志，可以在执行<code>performTraversal()</code>时，调用到<code>performDraw()</code>后到<code>draw()</code>时，可以进行绘制过程。</p>
<p><img src="/images/View重绘.png" srcset="/img/loading.gif" lazyload="" alt="区别"></p>
<h4 id="同时调用"><a href="#同时调用" class="headerlink" title="同时调用"></a>同时调用</h4><blockquote>
<p>在某些情况下，需要<code>requestLayout</code>和<code>invalidate</code>配合使用，得到最终的结果。</p>
</blockquote>
<p>拿<code>TextView</code>举例：</p>
<p><img src="/images/TextView.setText.png" srcset="/img/loading.gif" lazyload="" alt="TextView.setText()"></p>
<p>当<code>TextView</code>执行<code>setText()</code>后，TextView可能布局发生改变，也可能需要进行重绘。需要区分不同情况实现对应功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java">//TextView.java<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> setText(CharSequence text, //文本<br>                         BufferType type, //缓存类型 NORMAL 默认样式 SPANNABLE 自定义样式 EDITABLE 可以追加字符<br>                         <span class="hljs-keyword">boolean</span> notifyBefore, //是否通知之前<br>                         <span class="hljs-keyword">int</span> oldlen //旧文本长度<br>) &#123;<br>      ...<br>        <span class="hljs-keyword">if</span> (mLayout != <span class="hljs-keyword">null</span>) &#123;<br>            checkForRelayout();<br>        &#125;<br>      ...<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> checkForRelayout() &#123;<br>      //TextView的宽度以及高度固定不变<br>        <span class="hljs-keyword">if</span> ((mLayoutParams.width != LayoutParams.WRAP_CONTENT//宽度固定<br>                || (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth))<br>                &amp;&amp; (mHint == <span class="hljs-keyword">null</span> || mHintLayout != <span class="hljs-keyword">null</span>)<br>                &amp;&amp; (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; 0)) &#123;<br>            // Static width, so <span class="hljs-keyword">try</span> making a new text layout.<br><br>            <span class="hljs-keyword">int</span> oldht = mLayout.getHeight();<br>            <span class="hljs-keyword">int</span> want = mLayout.getWidth();<br>            <span class="hljs-keyword">int</span> hintWant = mHintLayout == <span class="hljs-keyword">null</span> ? 0 : mHintLayout.getWidth();<br><br>            /*<br>             * No need to bring the text into view, since the size is not<br>             * changing (unless we <span class="hljs-keyword">do</span> the requestLayout(), in which <span class="hljs-keyword">case</span> it<br>             * will happen at measure).<br>             */<br>            makeNewLayout(want, hintWant, UNKNOWN_BORING, UNKNOWN_BORING,<br>                          mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight(),<br>                          <span class="hljs-keyword">false</span>);<br><br>          //非跑马灯格式<br>            <span class="hljs-keyword">if</span> (mEllipsize != TextUtils.TruncateAt.MARQUEE) &#123;<br>                // In a fixed-height view, so use our new text layout.<br>                <span class="hljs-keyword">if</span> (mLayoutParams.height != LayoutParams.WRAP_CONTENT <br>                        &amp;&amp; mLayoutParams.height != LayoutParams.MATCH_PARENT) &#123;//高度为&gt;0的值<br>                    autoSizeText();<br>                    invalidate();<br>                    return;<br>                &#125;<br><br>                // 除非主动设置高度，否则高度与行数相关，不会为0<br>                <span class="hljs-keyword">if</span> (mLayout.getHeight() == oldht<br>                        &amp;&amp; (mHintLayout == <span class="hljs-keyword">null</span> || mHintLayout.getHeight() == oldht)) &#123;//高度没有发生变化<br>                    autoSizeText();<br>                    invalidate();<br>                    return;<br>                &#125;<br>            &#125;<br><br>            // We lose: the height has changed and we have a dynamic height.<br>            // Request a new view layout using our new text layout.<br>            requestLayout();<br>            invalidate();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            // Dynamic width, so we have no choice but to request a new<br>            // view layout with a new text layout.<br>            nullLayouts();<br>            requestLayout();<br>            invalidate();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>根据上述源码分析：</p>
<blockquote>
<p><code>TextView.setText()</code>根据不同的情况会执行不同的重绘方法：</p>
<ul>
<li><code>width!=wrap_content</code><ul>
<li>非跑马灯格式(<code>mEllipsize!=MARQUEE</code>) &amp;&amp; (<code>height &gt; 0</code> || <code>height == oldht/*高度没有变化*/</code>)：执行<code>invalidate()</code></li>
<li>others：执行<code>requestLayout()</code>和<code>invalidate()</code></li>
</ul>
</li>
<li><code>width=wrap_content</code>：需要执行<code>requestLayout()</code>和<code>invalidate()</code></li>
</ul>
</blockquote>
<h4 id="拓展-2"><a href="#拓展-2" class="headerlink" title="拓展"></a>拓展</h4><h5 id="forceLayout"><a href="#forceLayout" class="headerlink" title="forceLayout()"></a>forceLayout()</h5><blockquote>
<p>标记当前View需要重新执行<code>测量-布局-绘制</code>流程。一般父ViewGroup调用<code>requestLayout()</code>，子View不会触发整套流程。</p>
<p>调用后，子View也可以执行整套流程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">//View.java   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> forceLayout() &#123;<br>        <span class="hljs-keyword">if</span> (mMeasureCache != <span class="hljs-keyword">null</span>) mMeasureCache.clear();<br><br>        mPrivateFlags |= PFLAG_FORCE_LAYOUT;//标记 执行measure<br>        mPrivateFlags |= PFLAG_INVALIDATED;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>forceLayout</code>若要生效，需要<code>直系父View</code>调用<code>requestLayout</code>。</p>
<h3 id="include、merge、ViewStub作用以及实现"><a href="#include、merge、ViewStub作用以及实现" class="headerlink" title="include、merge、ViewStub作用以及实现"></a>include、merge、ViewStub作用以及实现</h3>{% post_link include、merge-ViewStub相关%}
<h3 id="View的层级计算"><a href="#View的层级计算" class="headerlink" title="View的层级计算"></a>View的层级计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">//实际形成一个二叉树 递归计算深度    <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxViewDeep(View view) &#123;<br>        <span class="hljs-keyword">if</span> (!(view <span class="hljs-keyword">instanceof</span> ViewGroup)) &#123;<br>            return 0;<br>        &#125;<br><br>        ViewGroup vp = (ViewGroup) view;<br>        <span class="hljs-keyword">if</span> (vp.getChildCount() == 0) &#123;<br>            return 0;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> max = 0;<br>        <span class="hljs-keyword">int</span> count = vp.getChildCount();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; count; i++) &#123;<br>            <span class="hljs-keyword">int</span> deep = maxViewDeep(vp.getChildAt(i)) + 1;<br>            <span class="hljs-keyword">if</span> (deep &gt; max) &#123;<br>                max = deep;<br>            &#125;<br>        &#125;<br>        return max;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="AsyncLayoutInflater异步加载"><a href="#AsyncLayoutInflater异步加载" class="headerlink" title="AsyncLayoutInflater异步加载"></a>AsyncLayoutInflater异步加载</h3><a href="/2020/11/02/Android-布局优化-AsyncLayoutInflater简析/" title="AsyncLayoutInflater">AsyncLayoutInflater</a>
<h3 id="inflate-时，root与attachToRoot的结果源码"><a href="#inflate-时，root与attachToRoot的结果源码" class="headerlink" title="inflate()时，root与attachToRoot的结果源码"></a>inflate()时，<code>root</code>与<code>attachToRoot</code>的结果源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">//LayoutInflater.java<br>    <span class="hljs-keyword">public</span> View inflate(XmlPullParser parser, @Nullable ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot) &#123;<br>            View result = root;<br>      <br>                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                        // Create layout params that match root, <span class="hljs-keyword">if</span> supplied<br>                        params = root.generateLayoutParams(attrs);<br>                        <span class="hljs-keyword">if</span> (!attachToRoot) &#123;<br>                            // Set the layout params <span class="hljs-keyword">for</span> temp <span class="hljs-keyword">if</span> we are not<br>                            // attaching. (If we are, we use addView, below)<br>                            temp.setLayoutParams(params);<br>                        &#125;<br>                    &#125;      <br>                    // We are supposed to attach all the views we found (<span class="hljs-keyword">int</span> temp)<br>                    // to root. Do that now.<br>                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span> &amp;&amp; attachToRoot) &#123;<br>                        //将temp添加到rootView中<br>                        root.addView(temp, params);<br>                    &#125;<br><br>                    // Decide whether to return the root that was passed in or the<br>                    // top view found in xml.<br>                    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !attachToRoot) &#123;<br>                        //attachToRoot：将View添加到RootView中，非就是直接返回解析的子View<br>                        result = temp;<br>                    &#125;      <br>      return result;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>根据源码分析到，<code>root</code>与<code>attachToRoot</code>会对<code>infalte()</code>结果产生影响以及实现代码会有差异</p>
<table>
<thead>
<tr>
<th><code>root</code>与<code>attachToRoot</code>参数</th>
<th>表现</th>
<th><code>inflate()</code>返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>root == nuill &amp;&amp; attachToRoot == false/true</code></td>
<td>直接显示<code>source</code>加载的结果，而且设置的<code>宽高属性</code>也会失效</td>
<td><code>source</code>加载后的<code>View实例</code></td>
</tr>
<tr>
<td><code>root != null &amp;&amp; attachToRoot == false</code></td>
<td>直接显示<code>source</code>加载的结果，且设置的<code>宽高属性</code>保持</td>
<td><code>source</code>加载后的<code>View实例</code></td>
</tr>
<tr>
<td><code>root != null &amp;&amp; attachToRoot == true</code></td>
<td>直接显示<code>root</code>并且<code>source</code>已被<code>add</code>进去且设置的<code>宽高属性</code>保持</td>
<td><code>root</code></td>
</tr>
</tbody>
</table>
<p><strong><code>root</code>不为null，无论<code>attachToRoot</code>，都会保持需要加载布局的宽高属性。<code>root</code>为null，无论<code>attachToRoot</code>，都不会持有原有的宽高属性。</strong></p>
<h3 id="MeasureSpec-UNSPECIFIED使用场景"><a href="#MeasureSpec-UNSPECIFIED使用场景" class="headerlink" title="MeasureSpec.UNSPECIFIED使用场景"></a><code>MeasureSpec.UNSPECIFIED</code>使用场景</h3><blockquote>
<p><code>UNSPECIFIED</code>就是未指定的意思，在这个模式下 父控件不会干涉子控件的尺寸。</p>
<p><strong>一般用于支持滚动的布局中，例如<code>ScrollView</code>、<code>RecyclerView</code>中。</strong></p>
<p>在可滚动的<code>ViewGroup</code>中，不应该限制子View的尺寸。有可能子View会超出父布局的尺寸，在<code>AT_MOST/EXACTLY</code>都会对子View的尺寸进行限制。</p>
</blockquote>
<p>拿<code>ScrollView</code>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">//ScrollView.java<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> measureChild(View child, <span class="hljs-keyword">int</span> parentWidthMeasureSpec,<br>            <span class="hljs-keyword">int</span> parentHeightMeasureSpec) &#123;<br>        ViewGroup.LayoutParams lp = child.getLayoutParams();<br><br>        <span class="hljs-keyword">int</span> childWidthMeasureSpec;<br>        <span class="hljs-keyword">int</span> childHeightMeasureSpec;<br><br>        childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft<br>                + mPaddingRight, lp.width);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> verticalPadding = mPaddingTop + mPaddingBottom;<br>      //强制设置子View的测量模式为`UNSPECIFIED`<br>        childHeightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(<br>                Math.max(0, MeasureSpec.getSize(parentHeightMeasureSpec) - verticalPadding),<br>                MeasureSpec.UNSPECIFIED);<br><br>        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>    &#125;<br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/12/17/实现自定义图片加载框架/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">实现自定义图片加载框架</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/12/14/Java-反射/">
                        <span class="hidden-mobile">Java - 反射</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>
  




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
