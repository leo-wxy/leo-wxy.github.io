<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>RecyclerView简析 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css">


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">



<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                RecyclerView简析
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2018-12-20 11:49">
                    2018年12月20日 中午
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    6.4k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    96
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView机制.png" srcset="/img/loading.gif" class="full-image" alt="RecyclerView机制" title="RecyclerView机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="RecyclerView定义"><a href="#RecyclerView定义" class="headerlink" title="RecyclerView定义"></a>RecyclerView定义</h2><blockquote>
<p>RecyclerView是一个新的组件，用来代替ListView组件的。</p>
</blockquote>
<p>相比于ListView来说，RecyclerView的最大一个特性就是<strong>灵活性</strong>，主要体现在以下几个方面：</p>
<ul>
<li><code>多样式</code>：可以对数据展示进行定制，可以显示成列表，表格或者是瀑布流，你还可以自定义成任何显示样式。</li>
<li><code>局部刷新</code>：可以刷新指定的Item或者区域</li>
<li><code>刷新动画</code>：支持对Item的添加和移除添加动画</li>
<li><code>添加装饰</code>：支持自定义Item之间的分割线效果</li>
</ul>
<p>相比ListView还有其他的优点：</p>
<ul>
<li>默认实现View的复用，不需要判断<code>if(convertView == null)</code>的实现，回收机制更加完善。</li>
<li>容易实现拖拽，侧滑删除等效果。(利用<code>ItemTouchHelper</code>)</li>
</ul>
<p>RecyclerView是一个插件式的实现，对各个功能进行解耦，从而扩展性比较好。</p>
<h2 id="RecyclerView用法"><a href="#RecyclerView用法" class="headerlink" title="RecyclerView用法"></a>RecyclerView用法</h2><p>RecyclerView的标准实现流程如下：</p>
<ul>
<li><p>创建Adapter：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">DemoAdapter</span>.<span class="hljs-title">VH</span>&gt; </span>&#123;
...
&#125;</code></pre></div>
<p>创建一个继承<code>RecyclerView.Adapter</code>的Adapter类</p>
</li>
<li><p>创建ViewHolder：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span> </span>&#123;
    <span class="hljs-keyword">final</span> TextView title;
  
    VH(<span class="hljs-meta">@NonNull</span> View itemView) &#123;
        <span class="hljs-keyword">super</span>(itemView);
        title = itemView.findViewById(R.id.title);
    &#125;
&#125;</code></pre></div>
<p>创建一个继承<code>RecyclerView.ViewHolder</code>的静态内部类，记为<code>VH</code>。内部实现类似<code>ListView的ViewHolder</code>。</p>
</li>
<li><p>完善以下方法：</p>
<ul>
<li><p><code>VH onCreateViewHolder(ViewGroup parent,int viewType)</code>：绑定对应的layout id并创建<code>VH</code>返回</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> DemoAdapter.<span class="hljs-function">VH <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(@NonNull ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;
    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_demo, parent, <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VH(view);
&#125;</code></pre></div>
</li>
<li><p><code>void onBindViewHolder(VH holder,int position)</code>：为<code>VH</code>设置事件以及数据</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(@NonNull VH holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;
    holder.title.setText(mData.get(position));
    holder.itemView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;
            <span class="hljs-comment">//设置item点击事件</span>
        &#125;
    &#125;);
&#125;</code></pre></div>
</li>
<li><p><code>int getItemCount()</code>：返回item个数</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;
     <span class="hljs-keyword">return</span> mData.size();
 &#125;</code></pre></div>
</li>
</ul>
</li>
</ul>
<p>Adapter创建完成后，需要把Adapter设置到RecyclerView上。一般来说需要为RecyclerView进行四大设置：</p>
<ul>
<li><strong>设置Adapter(必须设置)</strong>：给RecyclerView绑定数据源 </li>
<li><strong>设置LayoutManager(必须设置)</strong>：给RecyclerView设置显示样式</li>
<li><strong>设置Item Decoration(可以设置)</strong>：给RecyclerView设置Item间的分割线</li>
<li><strong>设置Item Animator(可以设置)</strong>：给RecyclerView设置Item的添加和删除动画</li>
</ul>
<p>设置实例：</p>
<div class="hljs"><pre><code class="hljs java">List&lt;String&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

RecyclerView rv_demo = (RecyclerView)findViewById(R.id.rv_demo);
rv_demo.setAdapter(<span class="hljs-keyword">new</span> DemoAdapter(data));
rv_demo.setLayoutManager(<span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>));<span class="hljs-comment">//默认竖向显示</span></code></pre></div>
<p>更新数据：</p>
<div class="hljs"><pre><code class="hljs java">rv_demo.notifyDataSetChanged();<span class="hljs-comment">//更新整个视图</span>
<span class="hljs-comment">//更新局部视图</span>
rv_demo.notifyitemInserted();
rv_demo.notifyItemRemoved();
rv_demo.notifyitemChanged();</code></pre></div>
<h2 id="RecyclerView源码解析"><a href="#RecyclerView源码解析" class="headerlink" title="RecyclerView源码解析"></a>RecyclerView源码解析</h2><blockquote>
<p>RecyclerView的四大组成部分：<strong>Adapter、LayoutManager、ItemAnimator，ItemDecoration</strong>。</p>
</blockquote>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><blockquote>
<p>主要为了给RecyclerView提供数据，将Data与View进行绑定。创建ViewHolder以及数据变化时通知到RecyclerView。通知RecyclerView使用的是<em>观察者模式</em>。</p>
</blockquote>
<p>在<code>setAdapter()</code>时，就会给Adapter注册一个观察者，去通知RecyclerView数据变化</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAdapter</span><span class="hljs-params">(Adapter adapter)</span> </span>&#123;
    <span class="hljs-comment">// bail out if layout is frozen</span>
    setLayoutFrozen(<span class="hljs-keyword">false</span>);
    setAdapterInternal(adapter, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
    requestLayout();
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAdapterInternal</span><span class="hljs-params">(Adapter adapter, <span class="hljs-keyword">boolean</span> compatibleWithPrevious,
        <span class="hljs-keyword">boolean</span> removeAndRecycleViews)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (adapter != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">//注册观察者</span>
        adapter.registerAdapterDataObserver(mObserver);
        adapter.onAttachedToRecyclerView(<span class="hljs-keyword">this</span>);
    &#125;
    ...
&#125;</code></pre></div>
<p><br></p>
<h3 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h3><blockquote>
<p>负责RecyclerView的布局，其中包含了Item View的获取与回收。后面会分析它的缓存机制。</p>
</blockquote>
<p>还是按照绘制流程来看，LayoutManager在RecyclerView中是如何使用的？</p>
<blockquote>
<p>Measure流程</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java">LayoutManager mLayout;   
<span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthSpec, <span class="hljs-keyword">int</span> heightSpec)</span> </span>&#123;
      <span class="hljs-keyword">if</span> (mLayout.mAutoMeasure) &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> skipMeasure = widthMode == MeasureSpec.EXACTLY
                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;
            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);
       ... 
      &#125;
      ...
    &#125;</code></pre></div>
<p>在<code>RecyclerView.onMeasure()</code>中调用到了<code>LayoutManager.onMeasure()</code>，然后其中执行到了<code>RecyclerView.defaultOnMeasure()</code></p>
<div class="hljs"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">defaultOnMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthSpec, <span class="hljs-keyword">int</span> heightSpec)</span> </span>&#123;
        <span class="hljs-comment">// calling LayoutManager here is not pretty but that API is already public and it is better</span>
        <span class="hljs-comment">// than creating another method since this is internal.</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = LayoutManager.chooseSize(widthSpec,
                getPaddingLeft() + getPaddingRight(),
                getMinimumWidth());
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = LayoutManager.chooseSize(heightSpec,
                getPaddingTop() + getPaddingBottom(),
                getMinimumHeight());

        setMeasuredDimension(width, height);
    &#125;

<span class="hljs-comment">// LayoutManager.java</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">chooseSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> spec, <span class="hljs-keyword">int</span> desired, <span class="hljs-keyword">int</span> min)</span> </span>&#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mode = View.MeasureSpec.getMode(spec);
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = View.MeasureSpec.getSize(spec);
            <span class="hljs-keyword">switch</span> (mode) &#123;
                <span class="hljs-keyword">case</span> View.MeasureSpec.EXACTLY:
                    <span class="hljs-keyword">return</span> size;
                <span class="hljs-keyword">case</span> View.MeasureSpec.AT_MOST:
                    <span class="hljs-keyword">return</span> Math.min(size, Math.max(desired, min));
                <span class="hljs-keyword">case</span> View.MeasureSpec.UNSPECIFIED:
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">return</span> Math.max(desired, min);
            &#125;
        &#125;</code></pre></div>
<p>最终RecyclerView的<code>Measure流程</code>依赖<code>LayoutManager.chooseSize()</code>来确定最后的RecyclerView宽高。</p>
<blockquote>
<p>Layout流程</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;
    Trace.beginSection(TRACE_ON_LAYOUT_TAG);
    dispatchLayout();
    Trace.endSection();
    mFirstLayoutComplete = <span class="hljs-keyword">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchLayout</span><span class="hljs-params">()</span> </span>&#123;
   ...
    mState.mIsMeasuring = <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">//第一次开始布局</span>
    <span class="hljs-keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;
        <span class="hljs-comment">//存储ziView状态并确定是否要执行动画</span>
        dispatchLayoutStep1();
        mLayout.setExactMeasureSpecsFrom(<span class="hljs-keyword">this</span>);
        dispatchLayoutStep2();
      <span class="hljs-comment">//发生了数据变化(notifyDataSetChanges)或者布局变化</span>
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()
            || mLayout.getHeight() != getHeight()) &#123;
        <span class="hljs-comment">// First 2 steps are done in onMeasure but looks like we have to run again due to</span>
        <span class="hljs-comment">// changed size.</span>
        mLayout.setExactMeasureSpecsFrom(<span class="hljs-keyword">this</span>);
        <span class="hljs-comment">//Item布局过程</span>
        dispatchLayoutStep2();
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// always make sure we sync them (to ensure mode is exact)</span>
        mLayout.setExactMeasureSpecsFrom(<span class="hljs-keyword">this</span>);
    &#125;
    <span class="hljs-comment">//执行Item 动画</span>
    dispatchLayoutStep3();
&#125;</code></pre></div>
<p>观察上述源码发现，涉及布局过程的只有<code>dispatchLayoutStep2()</code>，从这个方法继续向下看</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchLayoutStep2</span><span class="hljs-params">()</span> </span>&#123;
    ...
    <span class="hljs-comment">// Step 2: Run layout</span>
    mState.mInPreLayout = <span class="hljs-keyword">false</span>;
    mLayout.onLayoutChildren(mRecycler, mState);
    ...
&#125;</code></pre></div>
<p>这里涉及到了<code>LayoutManager.onLayoutChildren()</code>，由于默认是空实现，我们就拿<code>LinearLayoutManager</code>这个子类继续分析</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// LinearLayoutManager.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayoutChildren</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;
     ...
        <span class="hljs-keyword">int</span> startOffset;
        <span class="hljs-keyword">int</span> endOffset;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> firstLayoutDirection;
        <span class="hljs-keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;
            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL
                    : LayoutState.ITEM_DIRECTION_HEAD;
        &#125; <span class="hljs-keyword">else</span> &#123;
            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD
                    : LayoutState.ITEM_DIRECTION_TAIL;
        &#125;

        onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);
        detachAndScrapAttachedViews(recycler);
        mLayoutState.mInfinite = resolveIsInfinite();
        mLayoutState.mIsPreLayout = state.isPreLayout();
        <span class="hljs-comment">//是否从底部布局</span>
        <span class="hljs-keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;  
           <span class="hljs-comment">// 向上布局</span>
            updateLayoutStateToFillStart(mAnchorInfo);
            mLayoutState.mExtra = extraForStart;
            <span class="hljs-comment">//填充item</span>
            fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);
            startOffset = mLayoutState.mOffset;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> firstElement = mLayoutState.mCurrentPosition;
            <span class="hljs-keyword">if</span> (mLayoutState.mAvailable &gt; <span class="hljs-number">0</span>) &#123;
                extraForEnd += mLayoutState.mAvailable;
            &#125;
            <span class="hljs-comment">//向下布局</span>
            updateLayoutStateToFillEnd(mAnchorInfo);
            mLayoutState.mExtra = extraForEnd;
            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
            fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);
            endOffset = mLayoutState.mOffset;

            <span class="hljs-keyword">if</span> (mLayoutState.mAvailable &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// end could not consume all. add more items towards start</span>
                extraForStart = mLayoutState.mAvailable;
                updateLayoutStateToFillStart(firstElement, startOffset);
                mLayoutState.mExtra = extraForStart;
                fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);
                startOffset = mLayoutState.mOffset;
            &#125;
        &#125;<span class="hljs-keyword">else</span>&#123;
          ...
          
        &#125;
      ...
    &#125;</code></pre></div>
<p>确定布局方向后，就需要填充子View，利用<code>fill()</code>实现。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fill</span><span class="hljs-params">(RecyclerView.Recycler recycler, LayoutState layoutState,
        RecyclerView.State state, <span class="hljs-keyword">boolean</span> stopOnFocusable)</span> </span>&#123;
   <span class="hljs-comment">//存储当前可用空间</span>
   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = layoutState.mAvailable;
   ...
    <span class="hljs-comment">//计算可用布局宽高</span>
    <span class="hljs-keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;
    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;
   <span class="hljs-comment">//迭代填充Item</span>
    <span class="hljs-keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="hljs-number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;
        layoutChunkResult.resetInternal();
        <span class="hljs-comment">//布局item</span>
        layoutChunk(recycler, state, layoutState, layoutChunkResult);
        <span class="hljs-keyword">if</span> (layoutChunkResult.mFinished) &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
      layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;
       <span class="hljs-comment">//子View的回收工作</span>
    &#125;
  ...
&#125;</code></pre></div>
<p>在<code>fill()</code>中循环调用<code>layoutChunk()</code>进行布局。每次布局完成后需要计算剩余空间，之后判断是否需要继续布局Item。</p>
<p>向下看Item的布局方法<code>layoutChunk()</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layoutChunk</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state,
		LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;
	<span class="hljs-comment">// 获取item view</span>
	View view = layoutState.next(recycler);
	<span class="hljs-comment">// 获取布局参数</span>
	LayoutParams params = (LayoutParams) view.getLayoutParams();
	<span class="hljs-keyword">if</span> (layoutState.mScrapList == <span class="hljs-keyword">null</span>) &#123;
		<span class="hljs-keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection== LayoutState.LAYOUT_START)) &#123;
			<span class="hljs-comment">// 增加item view</span>
			addView(view);
		&#125; <span class="hljs-keyword">else</span> &#123;
			addView(view, <span class="hljs-number">0</span>);
		&#125;
	&#125; 
	<span class="hljs-comment">// 测量item</span>
	measureChildWithMargins(view, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
	<span class="hljs-comment">// 计算item使用的空间</span>
	result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);
	<span class="hljs-keyword">int</span> left, top, right, bottom;
	<span class="hljs-comment">// 竖直方向布局，计算Item坐标</span>
	<span class="hljs-keyword">if</span> (mOrientation == VERTICAL) &#123;
    <span class="hljs-comment">//设置了从右向左的布局方式</span>
		<span class="hljs-keyword">if</span> (isLayoutRTL()) &#123;
			right = getWidth() - getPaddingRight();
			left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);
		&#125; <span class="hljs-keyword">else</span> &#123;
			left = getPaddingLeft();
			right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);
		&#125;
		<span class="hljs-keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;
			bottom = layoutState.mOffset;
			top = layoutState.mOffset - result.mConsumed;
		&#125; <span class="hljs-keyword">else</span> &#123;
			top = layoutState.mOffset;
			bottom = layoutState.mOffset + result.mConsumed;
		&#125;   
	&#125; 
  <span class="hljs-comment">//水平方向布局，计算Item坐标</span>
  <span class="hljs-keyword">else</span> &#123;
     top = getPaddingTop();
     bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);

     <span class="hljs-keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;
          right = layoutState.mOffset;
          left = layoutState.mOffset - result.mConsumed;
     &#125; <span class="hljs-keyword">else</span> &#123;
          left = layoutState.mOffset;
          right = layoutState.mOffset + result.mConsumed;
     &#125;	   
	&#125;
  	<span class="hljs-comment">// item布局</span>
	layoutDecoratedWithMargins(view, left, top, right, bottom);
  ...
&#125;

<span class="hljs-comment">//测量子View的布局</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChildWithMargins</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> widthUsed, <span class="hljs-keyword">int</span> heightUsed)</span> </span>&#123;
            <span class="hljs-keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();

            <span class="hljs-keyword">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
            widthUsed += insets.left + insets.right;
            heightUsed += insets.top + insets.bottom;

            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),
                    getPaddingLeft() + getPaddingRight()
                            + lp.leftMargin + lp.rightMargin + widthUsed, lp.width,
                    canScrollHorizontally());
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),
                    getPaddingTop() + getPaddingBottom()
                            + lp.topMargin + lp.bottomMargin + heightUsed, lp.height,
                    canScrollVertically());
            <span class="hljs-keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;
               <span class="hljs-comment">//子View测量</span>
                child.measure(widthSpec, heightSpec);
            &#125;
        &#125;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layoutDecoratedWithMargins</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right,
                <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;
            <span class="hljs-keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();
            <span class="hljs-keyword">final</span> Rect insets = lp.mDecorInsets;
            <span class="hljs-comment">//子view布局</span>
            child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,
                    right - insets.right - lp.rightMargin,
                    bottom - insets.bottom - lp.bottomMargin);
        &#125;</code></pre></div>
<p>在<code>layoutChunk()</code>中完成了子View的<code>measure以及layout</code>过程。</p>
<blockquote>
<p>Draw过程</p>
</blockquote>
<p>Draw过程就是下文描述到的<code>ItemDecoration</code>，主要完成的就是绘制分割线的过程。</p>
<p><br></p>
<h3 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h3><blockquote>
<p>RecyclerView能够通过<code>RecyclerView.setItemAnimator(ItemAnimator animator)</code>设置添加、删除、移动、改变的动画效果。提供了默认的动画效果<code>DefaultItemAnimator</code>。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java">class CustomItemAnimator : RecyclerView.ItemAnimator()&#123;

  override fun isRunning(): Boolean &#123;
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    &#125;
    
    override fun animatePersistence(
        viewHolder: RecyclerView.ViewHolder,
        preLayoutInfo: ItemHolderInfo,
        postLayoutInfo: ItemHolderInfo
    ): Boolean &#123;
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    &#125;

    override fun runPendingAnimations() &#123;
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    &#125;

    override fun endAnimation(item: RecyclerView.ViewHolder) &#123;
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    &#125;

    override fun animateDisappearance(
        viewHolder: RecyclerView.ViewHolder,
        preLayoutInfo: ItemHolderInfo,
        postLayoutInfo: ItemHolderInfo?
    ): Boolean &#123;
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    &#125;

    override fun animateChange(
        oldHolder: RecyclerView.ViewHolder,
        newHolder: RecyclerView.ViewHolder,
        preLayoutInfo: ItemHolderInfo,
        postLayoutInfo: ItemHolderInfo
    ): Boolean &#123;
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    &#125;

    override fun animateAppearance(
        viewHolder: RecyclerView.ViewHolder,
        preLayoutInfo: ItemHolderInfo?,
        postLayoutInfo: ItemHolderInfo
    ): Boolean &#123;
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    &#125;

    override fun endAnimations() &#123;
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    &#125;

&#125;</code></pre></div>
<ul>
<li><code>animateAppearance()</code>：当ViewHolder出现在屏幕上时被调用(<em>可能是add或move</em>)</li>
<li><code>animateDisappearance()</code>：当ViewHolder消失在屏幕上时被调用(<em>可能是remove或move</em>)</li>
<li><code>animatePersistence()</code>：在没调用<code>notifyItemChanged()</code>和<code>notifyDataSetChanged()</code>的情况下发生布局改变时被调用</li>
<li><code>animateChange()</code>：在调用<code>notifyItemChanged()</code>或<code>notifyDataSetChanged()</code>的情况下发生布局改变时被调用</li>
<li><code>runPendingAnimations()</code>：RecyclerView的执行方式是每帧执行一次，如果在帧之间添加了多个Item，就会保存Pending动画，等到下一帧一起执行。<strong>前面定义的<code>animateXXX()</code>返回true。</strong></li>
<li><code>isRunning()</code>：是否有动画要执行或正在执行</li>
<li><code>dispatchAnimationsFinished()</code>：当全部动画执行完毕时调用</li>
</ul>
<blockquote>
<p>对于<code>ItemAnimator</code>，最常见的是<em>闪屏问题</em> ——当Item中存在图片和文字时，刷新RecyclerView时会出现闪烁问题。</p>
<p>出现原因是由于调用<code>notifyDataSetChanged()</code>，会调用到<code>DefaultAnimator.animateChangeImpl()</code>执行change动画，导致透明度发生0-1的变化，发生闪烁。</p>
<p>解决方法：在<code>setAdapter()</code>之前调用<code>((SimpleItemAnimator)rv.getItemAnimator()).setSupportsChangeAnimations(false)</code>禁用change动画。</p>
</blockquote>
<p><br></p>
<h3 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h3><blockquote>
<p>RecyclerView通过<code>addItemDecoration()</code>添加Item之间的分割线。</p>
</blockquote>
<p>如果我们要自己实现一个分割线效果，需要自己创建一个类并继承<code>RecyclerView.ItemDecoration</code>，重写一下两个方法：</p>
<ul>
<li><code>onDraw()</code>：绘制分割线</li>
<li><code>getItemOffsets()</code>：设置分割线的宽高</li>
</ul>
<div class="hljs"><pre><code class="hljs java">class CustomDecoration : RecyclerView.ItemDecoration() &#123;
    override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State) &#123;
        //调用在Item绘制完毕前，绘制分割线
    &#125;

    override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) &#123;
        //定义分割线的宽/高，在不同的显示模式下
    &#125;

    override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) &#123;
       //调用在Item绘制完毕后，绘制分割线
    &#125;
&#125;</code></pre></div>
<p>接下来分析RecyclerView是如何调用到分割线？</p>
<p>回顾View的绘制流程是<em>measure-&gt;layout-&gt;draw</em>，我们开始分析分割线的调用流程。</p>
<p>由于RecyclerView继承自<code>ViewGroup</code>，分割线是作为Item之间的间隔使用，那就要从<code>measureChild()</code>开始查看</p>
<div class="hljs"><pre><code class="hljs java">       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChild</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> widthUsed, <span class="hljs-keyword">int</span> heightUsed)</span> </span>&#123;
           <span class="hljs-keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();
           <span class="hljs-comment">//获取设置的分割线</span>
           <span class="hljs-keyword">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
           widthUsed += insets.left + insets.right;
           heightUsed += insets.top + insets.bottom;
           <span class="hljs-comment">//都需要在原基础上 加上分割线的宽/高</span>
           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),
                   getPaddingLeft() + getPaddingRight() + widthUsed, lp.width,
                   canScrollHorizontally());
           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),
                   getPaddingTop() + getPaddingBottom() + heightUsed, lp.height,
                   canScrollVertically()); 
           <span class="hljs-keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;
               child.measure(widthSpec, heightSpec);
           &#125;
       &#125;

<span class="hljs-function">Rect <span class="hljs-title">getItemDecorInsetsForChild</span><span class="hljs-params">(View child)</span> </span>&#123;
       ...
           <span class="hljs-comment">//调用到设置的 getItemOffsets()</span>
           mItemDecorations.get(i).getItemOffsets(mTempRect, child, <span class="hljs-keyword">this</span>, mState);
       ...
   &#125;</code></pre></div>
<p>在<code>measureChild()</code>找到了引用分割线并设置宽高的地方，接下啦需要找到引用绘制(<code>onDraw</code>)的地方</p>
<div class="hljs"><pre><code class="hljs java">    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas c)</span> </span>&#123;
        <span class="hljs-comment">//调用到父类的 onDraw 即 View.onDraw</span>
        <span class="hljs-keyword">super</span>.onDraw(c);

        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mItemDecorations.size();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;
            mItemDecorations.get(i).onDraw(c, <span class="hljs-keyword">this</span>, mState);
        &#125;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas c)</span> </span>&#123;
        <span class="hljs-comment">//调用到父类的 draw() 即  View.draw()</span>
        <span class="hljs-keyword">super</span>.draw(c);

        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mItemDecorations.size();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;
            mItemDecorations.get(i).onDrawOver(c, <span class="hljs-keyword">this</span>, mState);
        &#125;
      ...
    &#125;

<span class="hljs-comment">// View.java</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;
  ...
    <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);
  ...
 &#125;</code></pre></div>
<p>上面找到了两个引用了<code>ItemDecoration</code>的绘制方法。这里回顾一下<code>ViewGroup</code>的Draw流程，先调用自身的<code>draw()</code>，然后<code>drawBackground()</code>，向下到<code>onDraw()</code>，绘制子View<code>disaptchDraw()</code>。</p>
<p>根据Draw流程分析，先调用到<code>RecyclerView.draw()</code>，发现调用到了<code>super.draw()</code>即指向了<code>View.draw()</code>这时View调用到自身的<code>onDraw()</code>，而RecyclerView重写了该方法，就调用到了<code>ItemDecoration.onDraw()</code>，然后走向<code>dispatchDraw()</code>绘制子View。绘制完毕后，最后调用到了<code>ItemDecoration.onDrawOver()</code>。</p>
<p>综上所述：<strong><code>onDraw()</code>调用在子View绘制前，<code>onDrawOver()</code>在绘制之后执行</strong>。</p>
<p><br></p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><blockquote>
<p>RecyclerView是以<code>RecyclerView.ViewHolder</code>作为单位进行回收。Recycler是RecyclerView回收机制的实现类。</p>
</blockquote>
<p>Recycler实现的是<strong>四级缓存</strong>：</p>
<ul>
<li><code>mAttachedScrap</code>：缓存已在屏幕上的ViewHolder。   <em>一级缓存</em></li>
<li><code>mCacheViews</code>：缓存屏幕外的ViewHolder，默认为2个。  <em>一级缓存</em></li>
<li><code>mViewCacheExtension</code>：需要用户定制，默认不实现。  <em>二级缓存</em></li>
<li><code>mRecyclerPool</code>：缓存池，<code>mCacheViews</code>集合中装满时，会放到这里。技术上可以实现所有<code>RecyclerViewPool</code>共用。默认为5个。 <em>三级缓存</em></li>
<li><code>createViewHolder</code>：创建ViewHolder。<em>‌四级缓存</em></li>
</ul>
<p>缓存机制主要分为两段流程：<strong>复用机制和回收机制。</strong></p>
<h4 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h4><blockquote>
<p> 从<code>Recycler</code>获取一个<code>ViewHolder</code></p>
</blockquote>
<p><code>LayoutManager</code>通过调用<code>Recycler.getViewForPosition(pos)</code>获取<code>pos</code>位置上的<code>view</code>。</p>
<div class="hljs"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getViewForPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;
        <span class="hljs-keyword">return</span> getViewForPosition(position, <span class="hljs-keyword">false</span>);
    &#125;

    <span class="hljs-function">View <span class="hljs-title">getViewForPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">boolean</span> dryRun)</span> </span>&#123;
        <span class="hljs-keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;
    &#125;
    <span class="hljs-comment">//复用机制的主要方实现</span>
<span class="hljs-function">ViewHolder <span class="hljs-title">tryGetViewHolderForPositionByDeadline</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position,
            <span class="hljs-keyword">boolean</span> dryRun, <span class="hljs-keyword">long</span> deadlineNs)</span> </span>&#123;
        <span class="hljs-comment">//判断位置是否正常</span>
        <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || position &gt;= mState.getItemCount()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Invalid item position "</span> + position
                    + <span class="hljs-string">"("</span> + position + <span class="hljs-string">"). Item count:"</span> + mState.getItemCount());
        &#125;
        <span class="hljs-keyword">boolean</span> fromScrapOrHiddenOrCache = <span class="hljs-keyword">false</span>;
        ViewHolder holder = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 是否设置动画</span>
        <span class="hljs-keyword">if</span> (mState.isPreLayout()) &#123;
            holder = getChangedScrapViewForPosition(position);
            fromScrapOrHiddenOrCache = holder != <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">//从 mAttcherScrap 或者 mCachedViews 获取holder</span>
            holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);①
            <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">//判定ViewHolder是否有效</span>
                <span class="hljs-keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;②
                    <span class="hljs-comment">// recycle holder (and unscrap if relevant) since it can't be used</span>
                    <span class="hljs-keyword">if</span> (!dryRun) &#123;
                        <span class="hljs-comment">//设置回收标记</span>
                        holder.addFlags(ViewHolder.FLAG_INVALID);
                        <span class="hljs-keyword">if</span> (holder.isScrap()) &#123;
                            removeDetachedView(holder.itemView, <span class="hljs-keyword">false</span>);
                            holder.unScrap();
                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.wasReturnedFromScrap()) &#123;
                            holder.clearReturnedFromScrapFlag();
                        &#125;
                        recycleViewHolderInternal(holder);
                    &#125;
                    holder = <span class="hljs-keyword">null</span>;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    fromScrapOrHiddenOrCache = <span class="hljs-keyword">true</span>;
                &#125;
            &#125;
        &#125;
        
        <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);
            <span class="hljs-keyword">if</span> (offsetPosition &lt; <span class="hljs-number">0</span> || offsetPosition &gt;= mAdapter.getItemCount()) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Inconsistency detected. Invalid item "</span>
                        + <span class="hljs-string">"position "</span> + position + <span class="hljs-string">"(offset:"</span> + offsetPosition + <span class="hljs-string">")."</span>
                        + <span class="hljs-string">"state:"</span> + mState.getItemCount());
            &#125;
            <span class="hljs-comment">//获取item设置的type</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);
            <span class="hljs-comment">// stable id 就是标识一个viewholder的唯一性</span>
            <span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;
                holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),③
                        type, dryRun);
                <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-comment">// update position</span>
                    holder.mPosition = offsetPosition;
                    fromScrapOrHiddenOrCache = <span class="hljs-keyword">true</span>;
                &#125;
            &#125;
            <span class="hljs-comment">//从用户自己设置的 mViewCacheExtension 去寻找对应ViewHolder·</span>
            <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">// We are NOT sending the offsetPosition because LayoutManager does not</span>
                <span class="hljs-comment">// know it.</span>
                <span class="hljs-keyword">final</span> View view = mViewCacheExtension
                        .getViewForPositionAndType(<span class="hljs-keyword">this</span>, position, type);
                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-comment">//包装成一个ViewHolder</span>
                    holder = getChildViewHolder(view);
                    <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"getViewForPositionAndType returned"</span>
                                + <span class="hljs-string">" a view which does not have a ViewHolder"</span>);
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.shouldIgnore()) &#123;
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"getViewForPositionAndType returned"</span>
                                + <span class="hljs-string">" a view that is ignored. You must call stopIgnoring before"</span>
                                + <span class="hljs-string">" returning this view."</span>);
                    &#125;
                &#125;
            &#125;
            <span class="hljs-comment">//从 RecyclerViewPool去寻找对应的ViewHolder</span>
            <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// fallback to pool</span>
                <span class="hljs-keyword">if</span> (DEBUG) &#123;
                    Log.d(TAG, <span class="hljs-string">"tryGetViewHolderForPositionByDeadline("</span>
                            + position + <span class="hljs-string">") fetching from shared pool"</span>);
                &#125;
                holder = getRecycledViewPool().getRecycledView(type);④
                <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;
                    holder.resetInternal();⑤
                    <span class="hljs-keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;
                        invalidateDisplayListInt(holder);
                    &#125;
                &#125;
            &#125;
            <span class="hljs-comment">//从以上三级缓存中都没有找到对应的ViewHolder就只能自己创建了</span>
            <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-keyword">long</span> start = getNanoTime();
                <span class="hljs-keyword">if</span> (deadlineNs != FOREVER_NS
                        &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;
                    <span class="hljs-comment">// abort - we have a deadline we can't meet</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                &#125;
                <span class="hljs-comment">//创建对应的ViewHolder</span>
                holder = mAdapter.createViewHolder(RecyclerView.<span class="hljs-keyword">this</span>, type);
                <span class="hljs-keyword">if</span> (ALLOW_THREAD_GAP_WORK) &#123;
                    <span class="hljs-comment">// only bother finding nested RV if prefetching</span>
                    RecyclerView innerView = findNestedRecyclerView(holder.itemView);
                    <span class="hljs-keyword">if</span> (innerView != <span class="hljs-keyword">null</span>) &#123;
                        holder.mNestedRecyclerView = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(innerView);
                    &#125;
                &#125;

                <span class="hljs-keyword">long</span> end = getNanoTime();
                mRecyclerPool.factorInCreateTime(type, end - start);
                <span class="hljs-keyword">if</span> (DEBUG) &#123;
                    Log.d(TAG, <span class="hljs-string">"tryGetViewHolderForPositionByDeadline created new ViewHolder"</span>);
                &#125;
            &#125;
        &#125;

        <span class="hljs-comment">// This is very ugly but the only place we can grab this information</span>
        <span class="hljs-comment">// before the View is rebound and returned to the LayoutManager for post layout ops.</span>
        <span class="hljs-comment">// We don't need this in pre-layout since the VH is not updated by the LM.</span>
        <span class="hljs-keyword">if</span> (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder
                .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) &#123;
            holder.setFlags(<span class="hljs-number">0</span>, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
            <span class="hljs-keyword">if</span> (mState.mRunSimpleAnimations) &#123;
                <span class="hljs-keyword">int</span> changeFlags = ItemAnimator
                        .buildAdapterChangeFlagsForAnimations(holder);
                changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;
                <span class="hljs-keyword">final</span> ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState,
                        holder, changeFlags, holder.getUnmodifiedPayloads());
                recordAnimationInfoIfBouncedHiddenView(holder, info);
            &#125;
        &#125;

        <span class="hljs-keyword">boolean</span> bound = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;
            <span class="hljs-comment">// do not update unless we absolutely have to.</span>
            holder.mPreLayoutPosition = position;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;
            <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; holder.isRemoved()) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Removed holder should be bound and it should"</span>
                        + <span class="hljs-string">" come here only in pre-layout. Holder: "</span> + holder);
            &#125;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);
            bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
        &#125;
        <span class="hljs-comment">//设置对应ViewHolder的 layoutparams</span>
        <span class="hljs-keyword">final</span> ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();
        <span class="hljs-keyword">final</span> LayoutParams rvLayoutParams;
        <span class="hljs-keyword">if</span> (lp == <span class="hljs-keyword">null</span>) &#123;
            rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();
            holder.itemView.setLayoutParams(rvLayoutParams);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!checkLayoutParams(lp)) &#123;
            rvLayoutParams = (LayoutParams) generateLayoutParams(lp);
            holder.itemView.setLayoutParams(rvLayoutParams);
        &#125; <span class="hljs-keyword">else</span> &#123;
            rvLayoutParams = (LayoutParams) lp;
        &#125;
        rvLayoutParams.mViewHolder = holder;
        rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound;
        <span class="hljs-keyword">return</span> holder;
    &#125;</code></pre></div>
<p>①<code>getScrapOrHiddenOrCachedHolderForPosition()</code>：从<code>mAttchedScrap</code>或者<code>mCachedViews</code>去获取ViewHolder</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function">ViewHolder <span class="hljs-title">getScrapOrHiddenOrCachedHolderForPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">boolean</span> dryRun)</span> </span>&#123;  
  <span class="hljs-comment">//先从 mAttachedScrap 获取对应的ViewHolder</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; scrapCount; i++) &#123;
               <span class="hljs-keyword">final</span> ViewHolder holder = mAttachedScrap.get(i);
               <span class="hljs-keyword">if</span> (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position
                       &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) &#123;
                   holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
                   <span class="hljs-keyword">return</span> holder;
               &#125;
           &#125;
   <span class="hljs-comment">//从隐藏的View中去寻找ViewHolder</span>
   <span class="hljs-keyword">if</span> (!dryRun) &#123;
               View view = mChildHelper.findHiddenNonRemovedView(position);
               <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;
                   <span class="hljs-comment">// This View is good to be used. We just need to unhide, detach and move to the</span>
                   <span class="hljs-comment">// scrap list.</span>
                   <span class="hljs-keyword">final</span> ViewHolder vh = getChildViewHolderInt(view);
                   mChildHelper.unhide(view);
                   <span class="hljs-keyword">int</span> layoutIndex = mChildHelper.indexOfChild(view);
                   <span class="hljs-keyword">if</span> (layoutIndex == RecyclerView.NO_POSITION) &#123;
                       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"layout index should not be -1 after "</span>
                               + <span class="hljs-string">"unhiding a view:"</span> + vh);
                   &#125;
                   mChildHelper.detachViewFromParent(layoutIndex);
                   scrapView(view);
                   vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP
                           | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
                   <span class="hljs-keyword">return</span> vh;
               &#125;
           &#125;
    <span class="hljs-comment">//从mCachedViews去获取对应的ViewHolder</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cacheSize = mCachedViews.size();
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cacheSize; i++) &#123;
               <span class="hljs-keyword">final</span> ViewHolder holder = mCachedViews.get(i);
               <span class="hljs-comment">// invalid view holders may be in cache if adapter has stable ids as they can be</span>
               <span class="hljs-comment">// retrieved via getScrapOrCachedViewForId</span>
               <span class="hljs-keyword">if</span> (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) &#123;
                   <span class="hljs-keyword">if</span> (!dryRun) &#123;
                       mCachedViews.remove(i);
                   &#125;
                   <span class="hljs-keyword">if</span> (DEBUG) &#123;
                       Log.d(TAG, <span class="hljs-string">"getScrapOrHiddenOrCachedHolderForPosition("</span> + position
                               + <span class="hljs-string">") found match in cache: "</span> + holder);
                   &#125;
                   <span class="hljs-keyword">return</span> holder;
               &#125;
           &#125;
&#125;</code></pre></div>
<p>根据<code>position</code>从<code>mAttachedScrap -&gt; hideView -&gt; mCachedViews</code>的顺序向下获取。</p>
<p><strong>mCachedViews里面存放的都是已存在的ViewHolder，新位置的是没法获取的。</strong></p>
<p>②<code>validateViewHolderForOffsetPosition(holder)</code>：校验获取的ViewHolder是否有效</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">validateViewHolderForOffsetPosition</span><span class="hljs-params">(ViewHolder holder)</span> </span>&#123;
    <span class="hljs-comment">// if it is a removed holder, nothing to verify since we cannot ask adapter anymore</span>
    <span class="hljs-comment">// if it is not removed, verify the type and id.</span>
    <span class="hljs-keyword">if</span> (holder.isRemoved()) &#123;
        <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; !mState.isPreLayout()) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"should not receive a removed view unless it"</span>
                    + <span class="hljs-string">" is pre layout"</span>);
        &#125;
        <span class="hljs-keyword">return</span> mState.isPreLayout();
    &#125;
    <span class="hljs-keyword">if</span> (holder.mPosition &lt; <span class="hljs-number">0</span> || holder.mPosition &gt;= mAdapter.getItemCount()) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Inconsistency detected. Invalid view holder "</span>
                + <span class="hljs-string">"adapter position"</span> + holder);
    &#125;
    <span class="hljs-keyword">if</span> (!mState.isPreLayout()) &#123;
        <span class="hljs-comment">// don't check type if it is pre-layout.</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> type = mAdapter.getItemViewType(holder.mPosition);
        <span class="hljs-keyword">if</span> (type != holder.getItemViewType()) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;
        <span class="hljs-keyword">return</span> holder.getItemId() == mAdapter.getItemId(holder.mPosition);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre></div>
<p>判断获取的ViewHolder存在和位置是否正确。</p>
<p>③<code>getScrapOrCachedViewForId()</code>：根据<code>position</code>获取对应的<code>itemId</code>然后获取ViewHolder</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function">ViewHolder <span class="hljs-title">getScrapOrCachedViewForId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">boolean</span> dryRun)</span> </span>&#123;
            <span class="hljs-comment">// Look in our attached views first</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mAttachedScrap.size();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
                <span class="hljs-keyword">final</span> ViewHolder holder = mAttachedScrap.get(i);
                <span class="hljs-keyword">if</span> (holder.getItemId() == id &amp;&amp; !holder.wasReturnedFromScrap()) &#123;
                    <span class="hljs-keyword">if</span> (type == holder.getItemViewType()) &#123;
                        holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
                        <span class="hljs-keyword">if</span> (holder.isRemoved()) &#123;
                            <span class="hljs-keyword">if</span> (!mState.isPreLayout()) &#123;
                                holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE
                                        | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED);
                            &#125;
                        &#125;
                        <span class="hljs-keyword">return</span> holder;
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dryRun) &#123;
                        mAttachedScrap.remove(i);
                        removeDetachedView(holder.itemView, <span class="hljs-keyword">false</span>);
                        quickRecycleScrapView(holder.itemView);
                    &#125;
                &#125;
            &#125;</code></pre></div>
<p>利用转化的<code>itemId</code>从<code>mAttachedScrap</code>获取对应的ViewHolder</p>
<p>④<code>getRecycledViewPool().getRecycledView()</code>：从<code>mRecyclerViewPool</code>去获取对应的ViewHolder</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ViewHolder <span class="hljs-title">getRecycledView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> viewType)</span> </span>&#123;
    <span class="hljs-keyword">final</span> ScrapData scrapData = mScrap.get(viewType);
    <span class="hljs-keyword">if</span> (scrapData != <span class="hljs-keyword">null</span> &amp;&amp; !scrapData.mScrapHeap.isEmpty()) &#123;
        <span class="hljs-keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;
        <span class="hljs-keyword">return</span> scrapHeap.remove(scrapHeap.size() - <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre></div>
<p>存储时会根据不同的<code>itemType</code>进行存储，然后取对应ViewHolder时，就不像前面获取ViewHodler需要通过<code>position或itemId</code>完整的匹配，只要找到对应<code>ViewType</code>并有值，直接取出最后一个ViewHolder缓存进行复用即可。</p>
<p>⑤<code>holder.resetInternal()</code>：对从<code>mRecyclerViewPool</code>取出的ViewHolder重新进行设置，变成一个全新的ViewHolder</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resetInternal</span><span class="hljs-params">()</span> </span>&#123;
    mFlags = <span class="hljs-number">0</span>;
    mPosition = NO_POSITION;
    mOldPosition = NO_POSITION;
    mItemId = NO_ID;
    mPreLayoutPosition = NO_POSITION;
    mIsRecyclableCount = <span class="hljs-number">0</span>;
    mShadowedHolder = <span class="hljs-keyword">null</span>;
    mShadowingHolder = <span class="hljs-keyword">null</span>;
    clearPayload();
    mWasImportantForAccessibilityBeforeHidden = View.IMPORTANT_FOR_ACCESSIBILITY_AUTO;
    mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET;
    clearNestedRecyclerViewIfNotNested(<span class="hljs-keyword">this</span>);
&#125;</code></pre></div>
<p>由于取出的ViewHolder进行了重新设置，所以后续就需要调用<code>bindViewHolder()</code>重新进行数据绑定</p>
<p>观察上述源码可知，复用机制简单分为以下几步：</p>
<ul>
<li>从<code>mAttachedScrap</code>或<code>mCachedViews</code>(<em>一级缓存</em>)去获取可复用的ViewHolder</li>
<li>如果没有找到可复用的ViewHolder，就会从<code>mViewacheExtension</code>(<em>二级缓存</em>)去获取可复用的ViewHolder。<code>如果用户没有定义就跳过这一级。</code></li>
<li>用户未定义货没有找到可复用的ViewHolder，就会从<code>mRecyclerPool</code>(<em>三级缓存</em>)去获取可复用的ViewHolder。<strong>这时需要调用<code>onBindViewHolder()</code></strong></li>
<li>从上面三步中都没有获取到，就只能自己调用<code>createViewHolder</code>(<em>四级缓存</em>)去重新创建一个ViewHolder以供使用，然后在调用<code>bindViewHolder()</code>绑定数据。最后调整<code>ViewHolder。itemView</code>的布局参数。</li>
<li>返回最终得到的ViewHolder。</li>
</ul>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView复用机制.png" srcset="/img/loading.gif" class="full-image" alt="RecyclerView复用机制" title="RecyclerView复用机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h4><blockquote>
<p>由<code>Recycler</code>进行View的回收</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycleView</span><span class="hljs-params">(View view)</span> </span>&#123;
    <span class="hljs-comment">//传入对应的View 然后通过View获取ViewHolder</span>
    ViewHolder holder = getChildViewHolderInt(view);
    <span class="hljs-comment">//标记该View要移除</span>
    <span class="hljs-keyword">if</span> (holder.isTmpDetached()) &#123;
        removeDetachedView(view, <span class="hljs-keyword">false</span>);
    &#125;
    <span class="hljs-comment">//该ViewHolder来自缓存可见的数组</span>
    <span class="hljs-keyword">if</span> (holder.isScrap()) &#123;
        <span class="hljs-comment">//清除缓存</span>
        holder.unScrap();
    &#125; <span class="hljs-comment">//holder来自缓存的不可见ViewHolder</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.wasReturnedFromScrap()) &#123;
        <span class="hljs-comment">//清除缓存</span>
        holder.clearReturnedFromScrapFlag();
    &#125;
    <span class="hljs-comment">//开始回收流程</span>
    recycleViewHolderInternal(holder);
&#125;</code></pre></div>
<p>回收流程的真正执行逻辑是在<code>recyclerViewHolderInternal()</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recycleViewHolderInternal</span><span class="hljs-params">(ViewHolder holder)</span> </span>&#123;
    ...
    <span class="hljs-comment">//noinspection unchecked</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> transientStatePreventsRecycling = holder
            .doesTransientStatePreventRecycling();
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> forceRecycle = mAdapter != <span class="hljs-keyword">null</span>
            &amp;&amp; transientStatePreventsRecycling
            &amp;&amp; mAdapter.onFailedToRecycleView(holder);
    <span class="hljs-keyword">boolean</span> cached = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">boolean</span> recycled = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; mCachedViews.contains(holder)) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"cached view received recycle internal? "</span>
                + holder);
    &#125;
    <span class="hljs-keyword">if</span> (forceRecycle || holder.isRecyclable()) &#123;
        <span class="hljs-comment">//要求缓存数量&gt;0，并且ViewHolder的标志是有效的额，且非REMOVED或UPDATE，进行缓存</span>
        <span class="hljs-keyword">if</span> (mViewCacheMax &gt; <span class="hljs-number">0</span> <span class="hljs-comment">/*大小默认为2*/</span>
                &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
                        | ViewHolder.FLAG_REMOVED
                        | ViewHolder.FLAG_UPDATE
                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;
            <span class="hljs-comment">// Retire oldest cached view</span>
            <span class="hljs-keyword">int</span> cachedViewSize = mCachedViews.size();
            <span class="hljs-comment">//mCacheViews已经满了，就把最前面缓存的ViewHolder放到RecyclerViewPool中</span>
            <span class="hljs-keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">//移除 mCachedViews的第一条缓存数据</span>
                recycleCachedViewAt(<span class="hljs-number">0</span>);①
                cachedViewSize--;
            &#125;

            <span class="hljs-keyword">int</span> targetCacheIndex = cachedViewSize;
            <span class="hljs-keyword">if</span> (ALLOW_THREAD_GAP_WORK
                    &amp;&amp; cachedViewSize &gt; <span class="hljs-number">0</span>
                    &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123;
                <span class="hljs-comment">// when adding the view, skip past most recently prefetched views</span>
                <span class="hljs-keyword">int</span> cacheIndex = cachedViewSize - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (cacheIndex &gt;= <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-keyword">int</span> cachedPos = mCachedViews.get(cacheIndex).mPosition;
                    <span class="hljs-comment">//缓存的时候不能覆盖最近经常使用的缓存 利用LFU算法 -- 最少使用策略</span>
                    <span class="hljs-keyword">if</span> (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123;
                        <span class="hljs-keyword">break</span>;
                    &#125;
                    cacheIndex--;
                &#125;
                targetCacheIndex = cacheIndex + <span class="hljs-number">1</span>;
            &#125;
            <span class="hljs-comment">//将最新的ViewHolder缓存数据插入到mCacheViews中复用</span>
            mCachedViews.add(targetCacheIndex, holder);
            cached = <span class="hljs-keyword">true</span>;
        &#125;
        <span class="hljs-comment">//如果没有触发缓存的话 就放进RecyclerViewPool中</span>
        <span class="hljs-keyword">if</span> (!cached) &#123;
            addViewHolderToRecycledViewPool(holder, <span class="hljs-keyword">true</span>);
            recycled = <span class="hljs-keyword">true</span>;
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> A view can fail to be recycled when it is scrolled off while an animation</span>
        <span class="hljs-comment">// runs. In this case, the item is eventually recycled by</span>
        <span class="hljs-comment">// ItemAnimatorRestoreListener#onAnimationFinished.</span>

        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> consider cancelling an animation when an item is removed scrollBy,</span>
        <span class="hljs-comment">// to return it to the pool faster</span>
        <span class="hljs-keyword">if</span> (DEBUG) &#123;
            Log.d(TAG, <span class="hljs-string">"trying to recycle a non-recycleable holder. Hopefully, it will "</span>
                    + <span class="hljs-string">"re-visit here. We are still removing it from animation lists"</span>);
        &#125;
    &#125;
    <span class="hljs-comment">// even if the holder is not removed, we still call this method so that it is removed</span>
    <span class="hljs-comment">// from view holder lists.</span>
    mViewInfoStore.removeViewHolder(holder);
    <span class="hljs-keyword">if</span> (!cached &amp;&amp; !recycled &amp;&amp; transientStatePreventsRecycling) &#123;
        holder.mOwnerRecyclerView = <span class="hljs-keyword">null</span>;
    &#125;
&#125;</code></pre></div>
<p>①<code>recycleCachedViewAt(0)</code>：移除<code>mCachedViews</code>中的第一条数据并放入到<code>mRecyclerViewPool</code>中</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recycleCachedViewAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cachedViewIndex)</span> </span>&#123;
    ViewHolder viewHolder = mCachedViews.get(cachedViewIndex);
    addViewHolderToRecycledViewPool(viewHolder, <span class="hljs-keyword">true</span>);
    mCachedViews.remove(cachedViewIndex);
&#125;</code></pre></div>
<p><code>mRecyclerPool</code>是根据<code>itemType</code>进行缓存的，最大上限为5。</p>
<p>观察上述源码可知，回收机制步骤如下：<strong>回收机制是发生在 RecyclerView滚动时进行的。</strong></p>
<ul>
<li>在RecyclerView滑动时，会调用到<code>LayoutManager.scrollVerticalBy()</code>去处理，在<code>LayoutManager.fill()</code>中会去完成<code>复用以及回收ViewHolder</code>的功能，最终调用到<code>recyclerView()</code>开始回收工作</li>
<li>回收时，先判断<code>mCachedViews</code>是否已满，未满直接放入。如果<code>mCachedViews</code>已满，则取出第一个缓存的ViewHolder放入<code>RecyclerViewPool</code>中，然后放入新的ViewHolder进行缓存</li>
<li>如果因为<code>ViewHolder</code>设置了<code>REMOVED或UPDATED</code>标志，无法加入<code>mCacheViews</code>中，就直接放入到<code>mRecyclerPool</code>中。</li>
</ul>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView回收机制.png" srcset="/img/loading.gif" class="full-image" alt="RecyclerView回收机制" title="RecyclerView回收机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>1.RecyclerView的操作场景主要有三种：</p>
<ul>
<li><p><em>有无到有</em>：RecyclerView中没有任何数据，然后调用<code>setAdapter()</code>添加数据源后。RecyclerView添加了数据并显示。</p>
<blockquote>
<p><code>Recycler</code>在这时只是调用到<code>createViewHolder()</code>不会发生缓存事件。</p>
</blockquote>
</li>
<li><p><em>在原有数据的情况下刷新</em>：做了下拉刷新操作，只对屏幕上可见的数据源进行替换。</p>
<blockquote>
<p>这时ViewHolder会被标记<code>FLAG_TMP_DETACHED</code>，然后这时的Viewolder就会被保存到<code>mAttachedScrap</code>中等待复用。</p>
</blockquote>
</li>
<li><p><em>RecyclerView发生滑动</em>：RecyclerView发生了上下或者左右滑动操作。</p>
</li>
</ul>
<p>2.RecyclerView滑动场景下的回收复用涉及到的结构有以下两个：<code>mCachedViews</code>和<code>mRecyclerPool</code></p>
<p>  <code>mCachedViews</code>的优先级高于<code>mRecyclerPool</code>，回收时最新的ViewHolder先放入到<code>mCachedViews</code>中，没位置了就移除最旧的那个给新的腾地方，最旧的就放到<code>mRecyclerPool</code>中。</p>
<p>  复用时也是一样，先从<code>mCachedViews</code>去获取对应的ViewHolder，需要匹配<code>position</code>，就是需要位置对应才能进行复用。找不到就去<code>mRecyclerPool</code>中找，在<code>mRecyclerPool</code>中的ViewHolder都跟新的一样，需要重新绑定数据(<em>bindViewHolder()</em>)。还没有就要自己创建了(<em>createViewHolder()</em>)。</p>
<p>3.<code>mCachedViews</code>上限是2</p>
<h2 id="RecyclerView优化"><a href="#RecyclerView优化" class="headerlink" title="RecyclerView优化"></a>RecyclerView优化</h2><ul>
<li><p><strong>数据处理与视图绑定分离</strong></p>
<blockquote>
<p><code>bindViewHolder()</code>是在主线程中进行的，如果里面发生了耗时操作，会影响滑动的流畅性。</p>
<p><strong><code>onBindViewHolder()</code>中应该只进行数据的<code>set</code>操作，不需要做其他判断。</strong></p>
</blockquote>
</li>
<li><p><strong>数据优化</strong></p>
<blockquote>
<ol>
<li>分页加载远端数据，对拉取的数据进行缓存，提高二次加载的速度</li>
<li>对于新增或删除数据通过<code>DiffUtil</code>，来进行局部数据刷新，而不是每次都去进行全量刷新。</li>
</ol>
</blockquote>
</li>
<li><p><strong>布局优化</strong></p>
<blockquote>
<ol>
<li><code>减少过度绘制</code>：减少布局层级，可以考虑使用自定义View来减少层级，或者设置更合理的布局。</li>
<li><code>减少xml文件</code>：<code>inflate</code>时间：去解析xml都需要经过耗时的IO操作，可以利用代码直接生成对应的布局，利用<code>new View()</code>生成。</li>
<li><code>减少View对象的创建</code>：需要尽可能简化ItemView，对多ViewType能够共用的部分尽量设计成自定义View，减少View的构造和嵌套。</li>
</ol>
</blockquote>
</li>
<li><p><strong>其他优化</strong></p>
<blockquote>
<ol>
<li><p>设置高度固定：如果Item高度固定的话，可以使用<code>RecyclerView.setHasFixedSize(true)</code>，避免调用<code>requestLayout()</code></p>
</li>
<li><p>共用<code>RecycledViewPool</code>：具有相关的Adapter，就可以调用<code>RecyclerView.setRecycledViewPool(pool)</code>共用同一个。</p>
</li>
<li><p>加大RecyclerView的缓存：空间换时间</p>
<div class="hljs"><pre><code class="hljs java">&gt;    recyclerView.setItemViewCacheSize(<span class="hljs-number">20</span>);
&gt;    recyclerView.setDrawingCacheEnabled(<span class="hljs-keyword">true</span>);
&gt;    recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);
&gt;</code></pre></div>
</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li><p>增加RecyclerView预留的额外空间：显示范围之外，增加额外的缓存空间。<em>默认为2。</em></p>
<div class="hljs"><pre><code class="hljs java">&gt;    <span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>) &#123;
&gt;        <span class="hljs-meta">@Override</span>
&gt;        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getExtraLayoutSpace</span><span class="hljs-params">(RecyclerView.State state)</span> </span>&#123;
&gt;            <span class="hljs-keyword">return</span> size;
&gt;        &#125;
&gt;    &#125;;
&gt;</code></pre></div>
</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li><p>减少ItemView监听器的创建</p>
<blockquote>
<p>不要对每个Item都去创建一个监听器，而是根据<code>android:id</code>设置不同的操作，共用一个监听器。</p>
</blockquote>
</li>
<li><p>优化滑动操作：设置<code>RecyclerView.addOnScrollListener()</code>在滑动过程中停止加载</p>
</li>
<li><p>关闭默认动画效果：设置<code>((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false)</code></p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="RecyclerView拓展"><a href="#RecyclerView拓展" class="headerlink" title="RecyclerView拓展"></a>RecyclerView拓展</h2><p>是否需要将ListView替换成RecyclerView?</p>
<blockquote>
<p>从性能上看，RecyclerView并没有带来明显的提升。如果需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView。只是单纯用于展示数据的话，ListView实现更加简单。</p>
</blockquote>
<h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://www.cnblogs.com/dasusu/p/7746946.html" target="_blank" rel="noopener">基于场景解析RecyclerView的回收复用机制原理</a></p>
<p><a href="https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA?" target="_blank" rel="noopener">RecyclerView必知必会</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2018/12/20/数据结构-红黑树/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构-红黑树</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2018/12/20/Android性能优化/">
                        <span class="hidden-mobile">Android性能优化</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
