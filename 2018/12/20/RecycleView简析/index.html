

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
    <meta name="description" content="RecyclerView定义 RecyclerView是一个新的组件，用来代替ListView组件的。  相比于ListView来说，RecyclerView的最大一个特性就是灵活性，主要体现在以下几个方面：  多样式：可以对数据展示进行定制，可以显示成列表，表格或者是瀑布流，你还可以自定义成任何显示样式。 局部刷新：可以刷新指定的Item或者区域 刷新动画：支持对Item的添加和移除添加动画">
<meta property="og:type" content="article">
<meta property="og:title" content="RecyclerView简析">
<meta property="og:url" content="https://leo-wxy.github.io/2018/12/20/RecycleView%E7%AE%80%E6%9E%90/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="RecyclerView定义 RecyclerView是一个新的组件，用来代替ListView组件的。  相比于ListView来说，RecyclerView的最大一个特性就是灵活性，主要体现在以下几个方面：  多样式：可以对数据展示进行定制，可以显示成列表，表格或者是瀑布流，你还可以自定义成任何显示样式。 局部刷新：可以刷新指定的Item或者区域 刷新动画：支持对Item的添加和移除添加动画">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leo-wxy.github.io/images/RecyclerView%E6%9C%BA%E5%88%B6.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/RecyclerView%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/RecyclerView%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png">
<meta property="article:published_time" content="2018-12-20T03:49:27.000Z">
<meta property="article:modified_time" content="2019-03-02T04:09:57.000Z">
<meta property="article:author" content="Leo-Wxy">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://leo-wxy.github.io/images/RecyclerView%E6%9C%BA%E5%88%B6.png">
  
  
  
  <title>RecyclerView简析 - Wxy的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":false};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">RecyclerView简析</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-12-20 11:49" pubdate>
          2018年12月20日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          5.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          18 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">RecyclerView简析</h1>
            
            
              <div class="markdown-body">
                
                <span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView机制.png" srcset="/img/loading.gif" lazyload class="full-image" alt="RecyclerView机制" title="RecyclerView机制" /><meta itemprop="width" content="auto"/><meta itemprop="height" content="auto"/></span>
<h2 id="RecyclerView定义"><a href="#RecyclerView定义" class="headerlink" title="RecyclerView定义"></a>RecyclerView定义</h2><blockquote>
<p>RecyclerView是一个新的组件，用来代替ListView组件的。</p>
</blockquote>
<p>相比于ListView来说，RecyclerView的最大一个特性就是<strong>灵活性</strong>，主要体现在以下几个方面：</p>
<ul>
<li><code>多样式</code>：可以对数据展示进行定制，可以显示成列表，表格或者是瀑布流，你还可以自定义成任何显示样式。</li>
<li><code>局部刷新</code>：可以刷新指定的Item或者区域</li>
<li><code>刷新动画</code>：支持对Item的添加和移除添加动画</li>
<li><code>添加装饰</code>：支持自定义Item之间的分割线效果</li>
</ul>
<p>相比ListView还有其他的优点：</p>
<ul>
<li>默认实现View的复用，不需要判断<code>if(convertView == null)</code>的实现，回收机制更加完善。</li>
<li>容易实现拖拽，侧滑删除等效果。(利用<code>ItemTouchHelper</code>)</li>
</ul>
<p>RecyclerView是一个插件式的实现，对各个功能进行解耦，从而扩展性比较好。</p>
<h2 id="RecyclerView用法"><a href="#RecyclerView用法" class="headerlink" title="RecyclerView用法"></a>RecyclerView用法</h2><p>RecyclerView的标准实现流程如下：</p>
<ul>
<li><p>创建Adapter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecyclerView</span>.Adapter&lt;DemoAdapter.VH&gt; &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建一个继承<code>RecyclerView.Adapter</code>的Adapter类</p>
</li>
<li><p>创建ViewHolder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecyclerView</span>.ViewHolder &#123;<br>    <span class="hljs-keyword">final</span> TextView title;<br>  <br>    VH(<span class="hljs-meta">@NonNull</span> View itemView) &#123;<br>        <span class="hljs-built_in">super</span>(itemView);<br>        title = itemView.findViewById(R.id.title);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建一个继承<code>RecyclerView.ViewHolder</code>的静态内部类，记为<code>VH</code>。内部实现类似<code>ListView的ViewHolder</code>。</p>
</li>
<li><p>完善以下方法：</p>
<ul>
<li><p><code>VH onCreateViewHolder(ViewGroup parent,int viewType)</code>：绑定对应的layout id并创建<code>VH</code>返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> DemoAdapter.VH <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup parent, <span class="hljs-type">int</span> viewType)</span> &#123;<br>    <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> LayoutInflater.from(parent.getContext()).inflate(R.layout.item_demo, parent, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VH</span>(view);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void onBindViewHolder(VH holder,int position)</code>：为<code>VH</code>设置事件以及数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBindViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> VH holder, <span class="hljs-type">int</span> position)</span> &#123;<br>    holder.title.setText(mData.get(position));<br>    holder.itemView.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>            <span class="hljs-comment">//设置item点击事件</span><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>int getItemCount()</code>：返回item个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getItemCount</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> mData.size();<br> &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>Adapter创建完成后，需要把Adapter设置到RecyclerView上。一般来说需要为RecyclerView进行四大设置：</p>
<ul>
<li><strong>设置Adapter(必须设置)</strong>：给RecyclerView绑定数据源 </li>
<li><strong>设置LayoutManager(必须设置)</strong>：给RecyclerView设置显示样式</li>
<li><strong>设置Item Decoration(可以设置)</strong>：给RecyclerView设置Item间的分割线</li>
<li><strong>设置Item Animator(可以设置)</strong>：给RecyclerView设置Item的添加和删除动画</li>
</ul>
<p>设置实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-type">RecyclerView</span> <span class="hljs-variable">rv_demo</span> <span class="hljs-operator">=</span> (RecyclerView)findViewById(R.id.rv_demo);<br>rv_demo.setAdapter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoAdapter</span>(data));<br>rv_demo.setLayoutManager(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearLayoutManager</span>(<span class="hljs-built_in">this</span>));<span class="hljs-comment">//默认竖向显示</span><br></code></pre></td></tr></table></figure>

<p>更新数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">rv_demo.notifyDataSetChanged();<span class="hljs-comment">//更新整个视图</span><br><span class="hljs-comment">//更新局部视图</span><br>rv_demo.notifyitemInserted();<br>rv_demo.notifyItemRemoved();<br>rv_demo.notifyitemChanged();<br></code></pre></td></tr></table></figure>

<h2 id="RecyclerView源码解析"><a href="#RecyclerView源码解析" class="headerlink" title="RecyclerView源码解析"></a>RecyclerView源码解析</h2><blockquote>
<p>RecyclerView的四大组成部分：<strong>Adapter、LayoutManager、ItemAnimator，ItemDecoration</strong>。</p>
</blockquote>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><blockquote>
<p>主要为了给RecyclerView提供数据，将Data与View进行绑定。创建ViewHolder以及数据变化时通知到RecyclerView。通知RecyclerView使用的是<em>观察者模式</em>。</p>
</blockquote>
<p>在<code>setAdapter()</code>时，就会给Adapter注册一个观察者，去通知RecyclerView数据变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAdapter</span><span class="hljs-params">(Adapter adapter)</span> &#123;<br>    <span class="hljs-comment">// bail out if layout is frozen</span><br>    setLayoutFrozen(<span class="hljs-literal">false</span>);<br>    setAdapterInternal(adapter, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>    requestLayout();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAdapterInternal</span><span class="hljs-params">(Adapter adapter, <span class="hljs-type">boolean</span> compatibleWithPrevious,</span><br><span class="hljs-params">        <span class="hljs-type">boolean</span> removeAndRecycleViews)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (adapter != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//注册观察者</span><br>        adapter.registerAdapterDataObserver(mObserver);<br>        adapter.onAttachedToRecyclerView(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<h3 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h3><blockquote>
<p>负责RecyclerView的布局，其中包含了Item View的获取与回收。后面会分析它的缓存机制。</p>
</blockquote>
<p>还是按照绘制流程来看，LayoutManager在RecyclerView中是如何使用的？</p>
<blockquote>
<p>Measure流程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">LayoutManager mLayout;   <br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthSpec, <span class="hljs-type">int</span> heightSpec)</span> &#123;<br>      <span class="hljs-keyword">if</span> (mLayout.mAutoMeasure) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">widthMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(widthSpec);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">heightMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(heightSpec);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">skipMeasure</span> <span class="hljs-operator">=</span> widthMode == MeasureSpec.EXACTLY<br>                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;<br>            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);<br>       ... <br>      &#125;<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>在<code>RecyclerView.onMeasure()</code>中调用到了<code>LayoutManager.onMeasure()</code>，然后其中执行到了<code>RecyclerView.defaultOnMeasure()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultOnMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthSpec, <span class="hljs-type">int</span> heightSpec)</span> &#123;<br>        <span class="hljs-comment">// calling LayoutManager here is not pretty but that API is already public and it is better</span><br>        <span class="hljs-comment">// than creating another method since this is internal.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> LayoutManager.chooseSize(widthSpec,<br>                getPaddingLeft() + getPaddingRight(),<br>                getMinimumWidth());<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> LayoutManager.chooseSize(heightSpec,<br>                getPaddingTop() + getPaddingBottom(),<br>                getMinimumHeight());<br><br>        setMeasuredDimension(width, height);<br>    &#125;<br><br><span class="hljs-comment">// LayoutManager.java</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chooseSize</span><span class="hljs-params">(<span class="hljs-type">int</span> spec, <span class="hljs-type">int</span> desired, <span class="hljs-type">int</span> min)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mode</span> <span class="hljs-operator">=</span> View.MeasureSpec.getMode(spec);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> View.MeasureSpec.getSize(spec);<br>            <span class="hljs-keyword">switch</span> (mode) &#123;<br>                <span class="hljs-keyword">case</span> View.MeasureSpec.EXACTLY:<br>                    <span class="hljs-keyword">return</span> size;<br>                <span class="hljs-keyword">case</span> View.MeasureSpec.AT_MOST:<br>                    <span class="hljs-keyword">return</span> Math.min(size, Math.max(desired, min));<br>                <span class="hljs-keyword">case</span> View.MeasureSpec.UNSPECIFIED:<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">return</span> Math.max(desired, min);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>最终RecyclerView的<code>Measure流程</code>依赖<code>LayoutManager.chooseSize()</code>来确定最后的RecyclerView宽高。</p>
<blockquote>
<p>Layout流程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLayout</span><span class="hljs-params">(<span class="hljs-type">boolean</span> changed, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> b)</span> &#123;<br>    Trace.beginSection(TRACE_ON_LAYOUT_TAG);<br>    dispatchLayout();<br>    Trace.endSection();<br>    mFirstLayoutComplete = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchLayout</span><span class="hljs-params">()</span> &#123;<br>   ...<br>    mState.mIsMeasuring = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//第一次开始布局</span><br>    <span class="hljs-keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;<br>        <span class="hljs-comment">//存储ziView状态并确定是否要执行动画</span><br>        dispatchLayoutStep1();<br>        mLayout.setExactMeasureSpecsFrom(<span class="hljs-built_in">this</span>);<br>        dispatchLayoutStep2();<br>      <span class="hljs-comment">//发生了数据变化(notifyDataSetChanges)或者布局变化</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()<br>            || mLayout.getHeight() != getHeight()) &#123;<br>        <span class="hljs-comment">// First 2 steps are done in onMeasure but looks like we have to run again due to</span><br>        <span class="hljs-comment">// changed size.</span><br>        mLayout.setExactMeasureSpecsFrom(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//Item布局过程</span><br>        dispatchLayoutStep2();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// always make sure we sync them (to ensure mode is exact)</span><br>        mLayout.setExactMeasureSpecsFrom(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//执行Item 动画</span><br>    dispatchLayoutStep3();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>观察上述源码发现，涉及布局过程的只有<code>dispatchLayoutStep2()</code>，从这个方法继续向下看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchLayoutStep2</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    <span class="hljs-comment">// Step 2: Run layout</span><br>    mState.mInPreLayout = <span class="hljs-literal">false</span>;<br>    mLayout.onLayoutChildren(mRecycler, mState);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里涉及到了<code>LayoutManager.onLayoutChildren()</code>，由于默认是空实现，我们就拿<code>LinearLayoutManager</code>这个子类继续分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LinearLayoutManager.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLayoutChildren</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;<br>     ...<br>        <span class="hljs-type">int</span> startOffset;<br>        <span class="hljs-type">int</span> endOffset;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> firstLayoutDirection;<br>        <span class="hljs-keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;<br>            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL<br>                    : LayoutState.ITEM_DIRECTION_HEAD;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD<br>                    : LayoutState.ITEM_DIRECTION_TAIL;<br>        &#125;<br><br>        onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);<br>        detachAndScrapAttachedViews(recycler);<br>        mLayoutState.mInfinite = resolveIsInfinite();<br>        mLayoutState.mIsPreLayout = state.isPreLayout();<br>        <span class="hljs-comment">//是否从底部布局</span><br>        <span class="hljs-keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;  <br>           <span class="hljs-comment">// 向上布局</span><br>            updateLayoutStateToFillStart(mAnchorInfo);<br>            mLayoutState.mExtra = extraForStart;<br>            <span class="hljs-comment">//填充item</span><br>            fill(recycler, mLayoutState, state, <span class="hljs-literal">false</span>);<br>            startOffset = mLayoutState.mOffset;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">firstElement</span> <span class="hljs-operator">=</span> mLayoutState.mCurrentPosition;<br>            <span class="hljs-keyword">if</span> (mLayoutState.mAvailable &gt; <span class="hljs-number">0</span>) &#123;<br>                extraForEnd += mLayoutState.mAvailable;<br>            &#125;<br>            <span class="hljs-comment">//向下布局</span><br>            updateLayoutStateToFillEnd(mAnchorInfo);<br>            mLayoutState.mExtra = extraForEnd;<br>            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;<br>            fill(recycler, mLayoutState, state, <span class="hljs-literal">false</span>);<br>            endOffset = mLayoutState.mOffset;<br><br>            <span class="hljs-keyword">if</span> (mLayoutState.mAvailable &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// end could not consume all. add more items towards start</span><br>                extraForStart = mLayoutState.mAvailable;<br>                updateLayoutStateToFillStart(firstElement, startOffset);<br>                mLayoutState.mExtra = extraForStart;<br>                fill(recycler, mLayoutState, state, <span class="hljs-literal">false</span>);<br>                startOffset = mLayoutState.mOffset;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          ...<br>          <br>        &#125;<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>确定布局方向后，就需要填充子View，利用<code>fill()</code>实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span><br><span class="hljs-params">        RecyclerView.State state, <span class="hljs-type">boolean</span> stopOnFocusable)</span> &#123;<br>   <span class="hljs-comment">//存储当前可用空间</span><br>   <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> layoutState.mAvailable;<br>   ...<br>    <span class="hljs-comment">//计算可用布局宽高</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">remainingSpace</span> <span class="hljs-operator">=</span> layoutState.mAvailable + layoutState.mExtra;<br>    <span class="hljs-type">LayoutChunkResult</span> <span class="hljs-variable">layoutChunkResult</span> <span class="hljs-operator">=</span> mLayoutChunkResult;<br>   <span class="hljs-comment">//迭代填充Item</span><br>    <span class="hljs-keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="hljs-number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;<br>        layoutChunkResult.resetInternal();<br>        <span class="hljs-comment">//布局item</span><br>        layoutChunk(recycler, state, layoutState, layoutChunkResult);<br>        <span class="hljs-keyword">if</span> (layoutChunkResult.mFinished) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;<br>       <span class="hljs-comment">//子View的回收工作</span><br>    &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>fill()</code>中循环调用<code>layoutChunk()</code>进行布局。每次布局完成后需要计算剩余空间，之后判断是否需要继续布局Item。</p>
<p>向下看Item的布局方法<code>layoutChunk()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">layoutChunk</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span><br><span class="hljs-params">		LayoutState layoutState, LayoutChunkResult result)</span> &#123;<br>	<span class="hljs-comment">// 获取item view</span><br>	<span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> layoutState.next(recycler);<br>	<span class="hljs-comment">// 获取布局参数</span><br>	<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> (LayoutParams) view.getLayoutParams();<br>	<span class="hljs-keyword">if</span> (layoutState.mScrapList == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection== LayoutState.LAYOUT_START)) &#123;<br>			<span class="hljs-comment">// 增加item view</span><br>			addView(view);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			addView(view, <span class="hljs-number">0</span>);<br>		&#125;<br>	&#125; <br>	<span class="hljs-comment">// 测量item</span><br>	measureChildWithMargins(view, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">// 计算item使用的空间</span><br>	result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);<br>	<span class="hljs-type">int</span> left, top, right, bottom;<br>	<span class="hljs-comment">// 竖直方向布局，计算Item坐标</span><br>	<span class="hljs-keyword">if</span> (mOrientation == VERTICAL) &#123;<br>    <span class="hljs-comment">//设置了从右向左的布局方式</span><br>		<span class="hljs-keyword">if</span> (isLayoutRTL()) &#123;<br>			right = getWidth() - getPaddingRight();<br>			left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			left = getPaddingLeft();<br>			right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);<br>		&#125;<br>		<span class="hljs-keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;<br>			bottom = layoutState.mOffset;<br>			top = layoutState.mOffset - result.mConsumed;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			top = layoutState.mOffset;<br>			bottom = layoutState.mOffset + result.mConsumed;<br>		&#125;   <br>	&#125; <br>  <span class="hljs-comment">//水平方向布局，计算Item坐标</span><br>  <span class="hljs-keyword">else</span> &#123;<br>     top = getPaddingTop();<br>     bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);<br><br>     <span class="hljs-keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;<br>          right = layoutState.mOffset;<br>          left = layoutState.mOffset - result.mConsumed;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>          left = layoutState.mOffset;<br>          right = layoutState.mOffset + result.mConsumed;<br>     &#125;	   <br>	&#125;<br>  	<span class="hljs-comment">// item布局</span><br>	layoutDecoratedWithMargins(view, left, top, right, bottom);<br>  ...<br>&#125;<br><br><span class="hljs-comment">//测量子View的布局</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChildWithMargins</span><span class="hljs-params">(View child, <span class="hljs-type">int</span> widthUsed, <span class="hljs-type">int</span> heightUsed)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (LayoutParams) child.getLayoutParams();<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Rect</span> <span class="hljs-variable">insets</span> <span class="hljs-operator">=</span> mRecyclerView.getItemDecorInsetsForChild(child);<br>            widthUsed += insets.left + insets.right;<br>            heightUsed += insets.top + insets.bottom;<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">widthSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(getWidth(), getWidthMode(),<br>                    getPaddingLeft() + getPaddingRight()<br>                            + lp.leftMargin + lp.rightMargin + widthUsed, lp.width,<br>                    canScrollHorizontally());<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">heightSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(getHeight(), getHeightMode(),<br>                    getPaddingTop() + getPaddingBottom()<br>                            + lp.topMargin + lp.bottomMargin + heightUsed, lp.height,<br>                    canScrollVertically());<br>            <span class="hljs-keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;<br>               <span class="hljs-comment">//子View测量</span><br>                child.measure(widthSpec, heightSpec);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">layoutDecoratedWithMargins</span><span class="hljs-params">(View child, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right,</span><br><span class="hljs-params">                <span class="hljs-type">int</span> bottom)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (LayoutParams) child.getLayoutParams();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Rect</span> <span class="hljs-variable">insets</span> <span class="hljs-operator">=</span> lp.mDecorInsets;<br>            <span class="hljs-comment">//子view布局</span><br>            child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,<br>                    right - insets.right - lp.rightMargin,<br>                    bottom - insets.bottom - lp.bottomMargin);<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>在<code>layoutChunk()</code>中完成了子View的<code>measure以及layout</code>过程。</p>
<blockquote>
<p>Draw过程</p>
</blockquote>
<p>Draw过程就是下文描述到的<code>ItemDecoration</code>，主要完成的就是绘制分割线的过程。</p>
<br>

<h3 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h3><blockquote>
<p>RecyclerView能够通过<code>RecyclerView.setItemAnimator(ItemAnimator animator)</code>设置添加、删除、移动、改变的动画效果。提供了默认的动画效果<code>DefaultItemAnimator</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomItemAnimator</span> : RecyclerView.ItemAnimator()&#123;<br><br>  override fun <span class="hljs-title function_">isRunning</span><span class="hljs-params">()</span>: Boolean &#123;<br>        TODO(<span class="hljs-string">&quot;not implemented&quot;</span>) <span class="hljs-comment">//To change body of created functions use File | Settings | File Templates.</span><br>    &#125;<br>    <br>    override fun <span class="hljs-title function_">animatePersistence</span><span class="hljs-params">(</span><br><span class="hljs-params">        viewHolder: RecyclerView.ViewHolder,</span><br><span class="hljs-params">        preLayoutInfo: ItemHolderInfo,</span><br><span class="hljs-params">        postLayoutInfo: ItemHolderInfo</span><br><span class="hljs-params">    )</span>: Boolean &#123;<br>        TODO(<span class="hljs-string">&quot;not implemented&quot;</span>) <span class="hljs-comment">//To change body of created functions use File | Settings | File Templates.</span><br>    &#125;<br><br>    override fun <span class="hljs-title function_">runPendingAnimations</span><span class="hljs-params">()</span> &#123;<br>        TODO(<span class="hljs-string">&quot;not implemented&quot;</span>) <span class="hljs-comment">//To change body of created functions use File | Settings | File Templates.</span><br>    &#125;<br><br>    override fun <span class="hljs-title function_">endAnimation</span><span class="hljs-params">(item: RecyclerView.ViewHolder)</span> &#123;<br>        TODO(<span class="hljs-string">&quot;not implemented&quot;</span>) <span class="hljs-comment">//To change body of created functions use File | Settings | File Templates.</span><br>    &#125;<br><br>    override fun <span class="hljs-title function_">animateDisappearance</span><span class="hljs-params">(</span><br><span class="hljs-params">        viewHolder: RecyclerView.ViewHolder,</span><br><span class="hljs-params">        preLayoutInfo: ItemHolderInfo,</span><br><span class="hljs-params">        postLayoutInfo: ItemHolderInfo?</span><br><span class="hljs-params">    )</span>: Boolean &#123;<br>        TODO(<span class="hljs-string">&quot;not implemented&quot;</span>) <span class="hljs-comment">//To change body of created functions use File | Settings | File Templates.</span><br>    &#125;<br><br>    override fun <span class="hljs-title function_">animateChange</span><span class="hljs-params">(</span><br><span class="hljs-params">        oldHolder: RecyclerView.ViewHolder,</span><br><span class="hljs-params">        newHolder: RecyclerView.ViewHolder,</span><br><span class="hljs-params">        preLayoutInfo: ItemHolderInfo,</span><br><span class="hljs-params">        postLayoutInfo: ItemHolderInfo</span><br><span class="hljs-params">    )</span>: Boolean &#123;<br>        TODO(<span class="hljs-string">&quot;not implemented&quot;</span>) <span class="hljs-comment">//To change body of created functions use File | Settings | File Templates.</span><br>    &#125;<br><br>    override fun <span class="hljs-title function_">animateAppearance</span><span class="hljs-params">(</span><br><span class="hljs-params">        viewHolder: RecyclerView.ViewHolder,</span><br><span class="hljs-params">        preLayoutInfo: ItemHolderInfo?,</span><br><span class="hljs-params">        postLayoutInfo: ItemHolderInfo</span><br><span class="hljs-params">    )</span>: Boolean &#123;<br>        TODO(<span class="hljs-string">&quot;not implemented&quot;</span>) <span class="hljs-comment">//To change body of created functions use File | Settings | File Templates.</span><br>    &#125;<br><br>    override fun <span class="hljs-title function_">endAnimations</span><span class="hljs-params">()</span> &#123;<br>        TODO(<span class="hljs-string">&quot;not implemented&quot;</span>) <span class="hljs-comment">//To change body of created functions use File | Settings | File Templates.</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>animateAppearance()</code>：当ViewHolder出现在屏幕上时被调用(<em>可能是add或move</em>)</li>
<li><code>animateDisappearance()</code>：当ViewHolder消失在屏幕上时被调用(<em>可能是remove或move</em>)</li>
<li><code>animatePersistence()</code>：在没调用<code>notifyItemChanged()</code>和<code>notifyDataSetChanged()</code>的情况下发生布局改变时被调用</li>
<li><code>animateChange()</code>：在调用<code>notifyItemChanged()</code>或<code>notifyDataSetChanged()</code>的情况下发生布局改变时被调用</li>
<li><code>runPendingAnimations()</code>：RecyclerView的执行方式是每帧执行一次，如果在帧之间添加了多个Item，就会保存Pending动画，等到下一帧一起执行。<strong>前面定义的<code>animateXXX()</code>返回true。</strong></li>
<li><code>isRunning()</code>：是否有动画要执行或正在执行</li>
<li><code>dispatchAnimationsFinished()</code>：当全部动画执行完毕时调用</li>
</ul>
<blockquote>
<p>对于<code>ItemAnimator</code>，最常见的是<em>闪屏问题</em> ——当Item中存在图片和文字时，刷新RecyclerView时会出现闪烁问题。</p>
<p>出现原因是由于调用<code>notifyDataSetChanged()</code>，会调用到<code>DefaultAnimator.animateChangeImpl()</code>执行change动画，导致透明度发生0-1的变化，发生闪烁。</p>
<p>解决方法：在<code>setAdapter()</code>之前调用<code>((SimpleItemAnimator)rv.getItemAnimator()).setSupportsChangeAnimations(false)</code>禁用change动画。</p>
</blockquote>
<br>

<h3 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h3><blockquote>
<p>RecyclerView通过<code>addItemDecoration()</code>添加Item之间的分割线。</p>
</blockquote>
<p>如果我们要自己实现一个分割线效果，需要自己创建一个类并继承<code>RecyclerView.ItemDecoration</code>，重写一下两个方法：</p>
<ul>
<li><code>onDraw()</code>：绘制分割线</li>
<li><code>getItemOffsets()</code>：设置分割线的宽高</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDecoration</span> : RecyclerView.ItemDecoration() &#123;<br>    override fun <span class="hljs-title function_">onDraw</span><span class="hljs-params">(c: Canvas, parent: RecyclerView, state: RecyclerView.State)</span> &#123;<br>        <span class="hljs-comment">//调用在Item绘制完毕前，绘制分割线</span><br>    &#125;<br><br>    override fun <span class="hljs-title function_">getItemOffsets</span><span class="hljs-params">(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State)</span> &#123;<br>        <span class="hljs-comment">//定义分割线的宽/高，在不同的显示模式下</span><br>    &#125;<br><br>    override fun <span class="hljs-title function_">onDrawOver</span><span class="hljs-params">(c: Canvas, parent: RecyclerView, state: RecyclerView.State)</span> &#123;<br>       <span class="hljs-comment">//调用在Item绘制完毕后，绘制分割线</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来分析RecyclerView是如何调用到分割线？</p>
<p>回顾View的绘制流程是<em>measure-&gt;layout-&gt;draw</em>，我们开始分析分割线的调用流程。</p>
<p>由于RecyclerView继承自<code>ViewGroup</code>，分割线是作为Item之间的间隔使用，那就要从<code>measureChild()</code>开始查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChild</span><span class="hljs-params">(View child, <span class="hljs-type">int</span> widthUsed, <span class="hljs-type">int</span> heightUsed)</span> &#123;<br>           <span class="hljs-keyword">final</span> <span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (LayoutParams) child.getLayoutParams();<br>           <span class="hljs-comment">//获取设置的分割线</span><br>           <span class="hljs-keyword">final</span> <span class="hljs-type">Rect</span> <span class="hljs-variable">insets</span> <span class="hljs-operator">=</span> mRecyclerView.getItemDecorInsetsForChild(child);<br>           widthUsed += insets.left + insets.right;<br>           heightUsed += insets.top + insets.bottom;<br>           <span class="hljs-comment">//都需要在原基础上 加上分割线的宽/高</span><br>           <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">widthSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(getWidth(), getWidthMode(),<br>                   getPaddingLeft() + getPaddingRight() + widthUsed, lp.width,<br>                   canScrollHorizontally());<br>           <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">heightSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(getHeight(), getHeightMode(),<br>                   getPaddingTop() + getPaddingBottom() + heightUsed, lp.height,<br>                   canScrollVertically()); <br>           <span class="hljs-keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;<br>               child.measure(widthSpec, heightSpec);<br>           &#125;<br>       &#125;<br><br>Rect <span class="hljs-title function_">getItemDecorInsetsForChild</span><span class="hljs-params">(View child)</span> &#123;<br>       ...<br>           <span class="hljs-comment">//调用到设置的 getItemOffsets()</span><br>           mItemDecorations.get(i).getItemOffsets(mTempRect, child, <span class="hljs-built_in">this</span>, mState);<br>       ...<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>在<code>measureChild()</code>找到了引用分割线并设置宽高的地方，接下啦需要找到引用绘制(<code>onDraw</code>)的地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas c)</span> &#123;<br>        <span class="hljs-comment">//调用到父类的 onDraw 即 View.onDraw</span><br>        <span class="hljs-built_in">super</span>.onDraw(c);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> mItemDecorations.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            mItemDecorations.get(i).onDraw(c, <span class="hljs-built_in">this</span>, mState);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Canvas c)</span> &#123;<br>        <span class="hljs-comment">//调用到父类的 draw() 即  View.draw()</span><br>        <span class="hljs-built_in">super</span>.draw(c);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> mItemDecorations.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            mItemDecorations.get(i).onDrawOver(c, <span class="hljs-built_in">this</span>, mState);<br>        &#125;<br>      ...<br>    &#125;<br><br><span class="hljs-comment">// View.java</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);<br>  ...<br> &#125;<br></code></pre></td></tr></table></figure>

<p>上面找到了两个引用了<code>ItemDecoration</code>的绘制方法。这里回顾一下<code>ViewGroup</code>的Draw流程，先调用自身的<code>draw()</code>，然后<code>drawBackground()</code>，向下到<code>onDraw()</code>，绘制子View<code>disaptchDraw()</code>。</p>
<p>根据Draw流程分析，先调用到<code>RecyclerView.draw()</code>，发现调用到了<code>super.draw()</code>即指向了<code>View.draw()</code>这时View调用到自身的<code>onDraw()</code>，而RecyclerView重写了该方法，就调用到了<code>ItemDecoration.onDraw()</code>，然后走向<code>dispatchDraw()</code>绘制子View。绘制完毕后，最后调用到了<code>ItemDecoration.onDrawOver()</code>。</p>
<p>综上所述：<strong><code>onDraw()</code>调用在子View绘制前，<code>onDrawOver()</code>在绘制之后执行</strong>。</p>
<br>

<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><blockquote>
<p>RecyclerView是以<code>RecyclerView.ViewHolder</code>作为单位进行回收。Recycler是RecyclerView回收机制的实现类。</p>
</blockquote>
<p>Recycler实现的是<strong>四级缓存</strong>：</p>
<ul>
<li><code>mAttachedScrap</code>：缓存已在屏幕上的ViewHolder。   <em>一级缓存</em></li>
<li><code>mCacheViews</code>：缓存屏幕外的ViewHolder，默认为2个。  <em>一级缓存</em></li>
<li><code>mViewCacheExtension</code>：需要用户定制，默认不实现。  <em>二级缓存</em></li>
<li><code>mRecyclerPool</code>：缓存池，<code>mCacheViews</code>集合中装满时，会放到这里。技术上可以实现所有<code>RecyclerViewPool</code>共用。默认为5个。 <em>三级缓存</em></li>
<li><code>createViewHolder</code>：创建ViewHolder。<em>‌四级缓存</em></li>
</ul>
<p>缓存机制主要分为两段流程：<strong>复用机制和回收机制。</strong></p>
<h4 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h4><blockquote>
<p> 从<code>Recycler</code>获取一个<code>ViewHolder</code></p>
</blockquote>
<p><code>LayoutManager</code>通过调用<code>Recycler.getViewForPosition(pos)</code>获取<code>pos</code>位置上的<code>view</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">getViewForPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-keyword">return</span> getViewForPosition(position, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    View <span class="hljs-title function_">getViewForPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> position, <span class="hljs-type">boolean</span> dryRun)</span> &#123;<br>        <span class="hljs-keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;<br>    &#125;<br>    <span class="hljs-comment">//复用机制的主要方实现</span><br>ViewHolder <span class="hljs-title function_">tryGetViewHolderForPositionByDeadline</span><span class="hljs-params">(<span class="hljs-type">int</span> position,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> dryRun, <span class="hljs-type">long</span> deadlineNs)</span> &#123;<br>        <span class="hljs-comment">//判断位置是否正常</span><br>        <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || position &gt;= mState.getItemCount()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Invalid item position &quot;</span> + position<br>                    + <span class="hljs-string">&quot;(&quot;</span> + position + <span class="hljs-string">&quot;). Item count:&quot;</span> + mState.getItemCount());<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">fromScrapOrHiddenOrCache</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 是否设置动画</span><br>        <span class="hljs-keyword">if</span> (mState.isPreLayout()) &#123;<br>            holder = getChangedScrapViewForPosition(position);<br>            fromScrapOrHiddenOrCache = holder != <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//从 mAttcherScrap 或者 mCachedViews 获取holder</span><br>            holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);①<br>            <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//判定ViewHolder是否有效</span><br>                <span class="hljs-keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;②<br>                    <span class="hljs-comment">// recycle holder (and unscrap if relevant) since it can&#x27;t be used</span><br>                    <span class="hljs-keyword">if</span> (!dryRun) &#123;<br>                        <span class="hljs-comment">//设置回收标记</span><br>                        holder.addFlags(ViewHolder.FLAG_INVALID);<br>                        <span class="hljs-keyword">if</span> (holder.isScrap()) &#123;<br>                            removeDetachedView(holder.itemView, <span class="hljs-literal">false</span>);<br>                            holder.unScrap();<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.wasReturnedFromScrap()) &#123;<br>                            holder.clearReturnedFromScrapFlag();<br>                        &#125;<br>                        recycleViewHolderInternal(holder);<br>                    &#125;<br>                    holder = <span class="hljs-literal">null</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    fromScrapOrHiddenOrCache = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offsetPosition</span> <span class="hljs-operator">=</span> mAdapterHelper.findPositionOffset(position);<br>            <span class="hljs-keyword">if</span> (offsetPosition &lt; <span class="hljs-number">0</span> || offsetPosition &gt;= mAdapter.getItemCount()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Inconsistency detected. Invalid item &quot;</span><br>                        + <span class="hljs-string">&quot;position &quot;</span> + position + <span class="hljs-string">&quot;(offset:&quot;</span> + offsetPosition + <span class="hljs-string">&quot;).&quot;</span><br>                        + <span class="hljs-string">&quot;state:&quot;</span> + mState.getItemCount());<br>            &#125;<br>            <span class="hljs-comment">//获取item设置的type</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> mAdapter.getItemViewType(offsetPosition);<br>            <span class="hljs-comment">// stable id 就是标识一个viewholder的唯一性</span><br>            <span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;<br>                holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),③<br>                        type, dryRun);<br>                <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// update position</span><br>                    holder.mPosition = offsetPosition;<br>                    fromScrapOrHiddenOrCache = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//从用户自己设置的 mViewCacheExtension 去寻找对应ViewHolder·</span><br>            <span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span> &amp;&amp; mViewCacheExtension != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// We are NOT sending the offsetPosition because LayoutManager does not</span><br>                <span class="hljs-comment">// know it.</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> mViewCacheExtension<br>                        .getViewForPositionAndType(<span class="hljs-built_in">this</span>, position, type);<br>                <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//包装成一个ViewHolder</span><br>                    holder = getChildViewHolder(view);<br>                    <span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;getViewForPositionAndType returned&quot;</span><br>                                + <span class="hljs-string">&quot; a view which does not have a ViewHolder&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.shouldIgnore()) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;getViewForPositionAndType returned&quot;</span><br>                                + <span class="hljs-string">&quot; a view that is ignored. You must call stopIgnoring before&quot;</span><br>                                + <span class="hljs-string">&quot; returning this view.&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//从 RecyclerViewPool去寻找对应的ViewHolder</span><br>            <span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// fallback to pool</span><br>                <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                    Log.d(TAG, <span class="hljs-string">&quot;tryGetViewHolderForPositionByDeadline(&quot;</span><br>                            + position + <span class="hljs-string">&quot;) fetching from shared pool&quot;</span>);<br>                &#125;<br>                holder = getRecycledViewPool().getRecycledView(type);④<br>                <span class="hljs-keyword">if</span> (holder != <span class="hljs-literal">null</span>) &#123;<br>                    holder.resetInternal();⑤<br>                    <span class="hljs-keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;<br>                        invalidateDisplayListInt(holder);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//从以上三级缓存中都没有找到对应的ViewHolder就只能自己创建了</span><br>            <span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> getNanoTime();<br>                <span class="hljs-keyword">if</span> (deadlineNs != FOREVER_NS<br>                        &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;<br>                    <span class="hljs-comment">// abort - we have a deadline we can&#x27;t meet</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">//创建对应的ViewHolder</span><br>                holder = mAdapter.createViewHolder(RecyclerView.<span class="hljs-built_in">this</span>, type);<br>                <span class="hljs-keyword">if</span> (ALLOW_THREAD_GAP_WORK) &#123;<br>                    <span class="hljs-comment">// only bother finding nested RV if prefetching</span><br>                    <span class="hljs-type">RecyclerView</span> <span class="hljs-variable">innerView</span> <span class="hljs-operator">=</span> findNestedRecyclerView(holder.itemView);<br>                    <span class="hljs-keyword">if</span> (innerView != <span class="hljs-literal">null</span>) &#123;<br>                        holder.mNestedRecyclerView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(innerView);<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> getNanoTime();<br>                mRecyclerPool.factorInCreateTime(type, end - start);<br>                <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                    Log.d(TAG, <span class="hljs-string">&quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// This is very ugly but the only place we can grab this information</span><br>        <span class="hljs-comment">// before the View is rebound and returned to the LayoutManager for post layout ops.</span><br>        <span class="hljs-comment">// We don&#x27;t need this in pre-layout since the VH is not updated by the LM.</span><br>        <span class="hljs-keyword">if</span> (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder<br>                .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) &#123;<br>            holder.setFlags(<span class="hljs-number">0</span>, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);<br>            <span class="hljs-keyword">if</span> (mState.mRunSimpleAnimations) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">changeFlags</span> <span class="hljs-operator">=</span> ItemAnimator<br>                        .buildAdapterChangeFlagsForAnimations(holder);<br>                changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ItemHolderInfo</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> mItemAnimator.recordPreLayoutInformation(mState,<br>                        holder, changeFlags, holder.getUnmodifiedPayloads());<br>                recordAnimationInfoIfBouncedHiddenView(holder, info);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">bound</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;<br>            <span class="hljs-comment">// do not update unless we absolutely have to.</span><br>            holder.mPreLayoutPosition = position;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; holder.isRemoved()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Removed holder should be bound and it should&quot;</span><br>                        + <span class="hljs-string">&quot; come here only in pre-layout. Holder: &quot;</span> + holder);<br>            &#125;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offsetPosition</span> <span class="hljs-operator">=</span> mAdapterHelper.findPositionOffset(position);<br>            bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);<br>        &#125;<br>        <span class="hljs-comment">//设置对应ViewHolder的 layoutparams</span><br>        <span class="hljs-keyword">final</span> ViewGroup.<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> holder.itemView.getLayoutParams();<br>        <span class="hljs-keyword">final</span> LayoutParams rvLayoutParams;<br>        <span class="hljs-keyword">if</span> (lp == <span class="hljs-literal">null</span>) &#123;<br>            rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();<br>            holder.itemView.setLayoutParams(rvLayoutParams);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!checkLayoutParams(lp)) &#123;<br>            rvLayoutParams = (LayoutParams) generateLayoutParams(lp);<br>            holder.itemView.setLayoutParams(rvLayoutParams);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rvLayoutParams = (LayoutParams) lp;<br>        &#125;<br>        rvLayoutParams.mViewHolder = holder;<br>        rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound;<br>        <span class="hljs-keyword">return</span> holder;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>①<code>getScrapOrHiddenOrCachedHolderForPosition()</code>：从<code>mAttchedScrap</code>或者<code>mCachedViews</code>去获取ViewHolder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewHolder <span class="hljs-title function_">getScrapOrHiddenOrCachedHolderForPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> position, <span class="hljs-type">boolean</span> dryRun)</span> &#123;  <br>  <span class="hljs-comment">//先从 mAttachedScrap 获取对应的ViewHolder</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scrapCount; i++) &#123;<br>               <span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> mAttachedScrap.get(i);<br>               <span class="hljs-keyword">if</span> (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position<br>                       &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) &#123;<br>                   holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);<br>                   <span class="hljs-keyword">return</span> holder;<br>               &#125;<br>           &#125;<br>   <span class="hljs-comment">//从隐藏的View中去寻找ViewHolder</span><br>   <span class="hljs-keyword">if</span> (!dryRun) &#123;<br>               <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> mChildHelper.findHiddenNonRemovedView(position);<br>               <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>                   <span class="hljs-comment">// This View is good to be used. We just need to unhide, detach and move to the</span><br>                   <span class="hljs-comment">// scrap list.</span><br>                   <span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">vh</span> <span class="hljs-operator">=</span> getChildViewHolderInt(view);<br>                   mChildHelper.unhide(view);<br>                   <span class="hljs-type">int</span> <span class="hljs-variable">layoutIndex</span> <span class="hljs-operator">=</span> mChildHelper.indexOfChild(view);<br>                   <span class="hljs-keyword">if</span> (layoutIndex == RecyclerView.NO_POSITION) &#123;<br>                       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;layout index should not be -1 after &quot;</span><br>                               + <span class="hljs-string">&quot;unhiding a view:&quot;</span> + vh);<br>                   &#125;<br>                   mChildHelper.detachViewFromParent(layoutIndex);<br>                   scrapView(view);<br>                   vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP<br>                           | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);<br>                   <span class="hljs-keyword">return</span> vh;<br>               &#125;<br>           &#125;<br>    <span class="hljs-comment">//从mCachedViews去获取对应的ViewHolder</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">cacheSize</span> <span class="hljs-operator">=</span> mCachedViews.size();<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cacheSize; i++) &#123;<br>               <span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> mCachedViews.get(i);<br>               <span class="hljs-comment">// invalid view holders may be in cache if adapter has stable ids as they can be</span><br>               <span class="hljs-comment">// retrieved via getScrapOrCachedViewForId</span><br>               <span class="hljs-keyword">if</span> (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) &#123;<br>                   <span class="hljs-keyword">if</span> (!dryRun) &#123;<br>                       mCachedViews.remove(i);<br>                   &#125;<br>                   <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                       Log.d(TAG, <span class="hljs-string">&quot;getScrapOrHiddenOrCachedHolderForPosition(&quot;</span> + position<br>                               + <span class="hljs-string">&quot;) found match in cache: &quot;</span> + holder);<br>                   &#125;<br>                   <span class="hljs-keyword">return</span> holder;<br>               &#125;<br>           &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据<code>position</code>从<code>mAttachedScrap -&gt; hideView -&gt; mCachedViews</code>的顺序向下获取。</p>
<p><strong>mCachedViews里面存放的都是已存在的ViewHolder，新位置的是没法获取的。</strong></p>
<p>②<code>validateViewHolderForOffsetPosition(holder)</code>：校验获取的ViewHolder是否有效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">validateViewHolderForOffsetPosition</span><span class="hljs-params">(ViewHolder holder)</span> &#123;<br>    <span class="hljs-comment">// if it is a removed holder, nothing to verify since we cannot ask adapter anymore</span><br>    <span class="hljs-comment">// if it is not removed, verify the type and id.</span><br>    <span class="hljs-keyword">if</span> (holder.isRemoved()) &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; !mState.isPreLayout()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;should not receive a removed view unless it&quot;</span><br>                    + <span class="hljs-string">&quot; is pre layout&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> mState.isPreLayout();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (holder.mPosition &lt; <span class="hljs-number">0</span> || holder.mPosition &gt;= mAdapter.getItemCount()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Inconsistency detected. Invalid view holder &quot;</span><br>                + <span class="hljs-string">&quot;adapter position&quot;</span> + holder);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!mState.isPreLayout()) &#123;<br>        <span class="hljs-comment">// don&#x27;t check type if it is pre-layout.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> mAdapter.getItemViewType(holder.mPosition);<br>        <span class="hljs-keyword">if</span> (type != holder.getItemViewType()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;<br>        <span class="hljs-keyword">return</span> holder.getItemId() == mAdapter.getItemId(holder.mPosition);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>判断获取的ViewHolder存在和位置是否正确。</p>
<p>③<code>getScrapOrCachedViewForId()</code>：根据<code>position</code>获取对应的<code>itemId</code>然后获取ViewHolder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewHolder <span class="hljs-title function_">getScrapOrCachedViewForId</span><span class="hljs-params">(<span class="hljs-type">long</span> id, <span class="hljs-type">int</span> type, <span class="hljs-type">boolean</span> dryRun)</span> &#123;<br>            <span class="hljs-comment">// Look in our attached views first</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> mAttachedScrap.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> mAttachedScrap.get(i);<br>                <span class="hljs-keyword">if</span> (holder.getItemId() == id &amp;&amp; !holder.wasReturnedFromScrap()) &#123;<br>                    <span class="hljs-keyword">if</span> (type == holder.getItemViewType()) &#123;<br>                        holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);<br>                        <span class="hljs-keyword">if</span> (holder.isRemoved()) &#123;<br>                            <span class="hljs-keyword">if</span> (!mState.isPreLayout()) &#123;<br>                                holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE<br>                                        | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED);<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">return</span> holder;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dryRun) &#123;<br>                        mAttachedScrap.remove(i);<br>                        removeDetachedView(holder.itemView, <span class="hljs-literal">false</span>);<br>                        quickRecycleScrapView(holder.itemView);<br>                    &#125;<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure>

<p>利用转化的<code>itemId</code>从<code>mAttachedScrap</code>获取对应的ViewHolder</p>
<p>④<code>getRecycledViewPool().getRecycledView()</code>：从<code>mRecyclerViewPool</code>去获取对应的ViewHolder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ViewHolder <span class="hljs-title function_">getRecycledView</span><span class="hljs-params">(<span class="hljs-type">int</span> viewType)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ScrapData</span> <span class="hljs-variable">scrapData</span> <span class="hljs-operator">=</span> mScrap.get(viewType);<br>    <span class="hljs-keyword">if</span> (scrapData != <span class="hljs-literal">null</span> &amp;&amp; !scrapData.mScrapHeap.isEmpty()) &#123;<br>        <span class="hljs-keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;<br>        <span class="hljs-keyword">return</span> scrapHeap.remove(scrapHeap.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>存储时会根据不同的<code>itemType</code>进行存储，然后取对应ViewHolder时，就不像前面获取ViewHodler需要通过<code>position或itemId</code>完整的匹配，只要找到对应<code>ViewType</code>并有值，直接取出最后一个ViewHolder缓存进行复用即可。</p>
<p>⑤<code>holder.resetInternal()</code>：对从<code>mRecyclerViewPool</code>取出的ViewHolder重新进行设置，变成一个全新的ViewHolder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">resetInternal</span><span class="hljs-params">()</span> &#123;<br>    mFlags = <span class="hljs-number">0</span>;<br>    mPosition = NO_POSITION;<br>    mOldPosition = NO_POSITION;<br>    mItemId = NO_ID;<br>    mPreLayoutPosition = NO_POSITION;<br>    mIsRecyclableCount = <span class="hljs-number">0</span>;<br>    mShadowedHolder = <span class="hljs-literal">null</span>;<br>    mShadowingHolder = <span class="hljs-literal">null</span>;<br>    clearPayload();<br>    mWasImportantForAccessibilityBeforeHidden = View.IMPORTANT_FOR_ACCESSIBILITY_AUTO;<br>    mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET;<br>    clearNestedRecyclerViewIfNotNested(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于取出的ViewHolder进行了重新设置，所以后续就需要调用<code>bindViewHolder()</code>重新进行数据绑定</p>
<p>观察上述源码可知，复用机制简单分为以下几步：</p>
<ul>
<li>从<code>mAttachedScrap</code>或<code>mCachedViews</code>(<em>一级缓存</em>)去获取可复用的ViewHolder</li>
<li>如果没有找到可复用的ViewHolder，就会从<code>mViewacheExtension</code>(<em>二级缓存</em>)去获取可复用的ViewHolder。<code>如果用户没有定义就跳过这一级。</code></li>
<li>用户未定义货没有找到可复用的ViewHolder，就会从<code>mRecyclerPool</code>(<em>三级缓存</em>)去获取可复用的ViewHolder。<strong>这时需要调用<code>onBindViewHolder()</code></strong></li>
<li>从上面三步中都没有获取到，就只能自己调用<code>createViewHolder</code>(<em>四级缓存</em>)去重新创建一个ViewHolder以供使用，然后在调用<code>bindViewHolder()</code>绑定数据。最后调整<code>ViewHolder。itemView</code>的布局参数。</li>
<li>返回最终得到的ViewHolder。</li>
</ul>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView复用机制.png" srcset="/img/loading.gif" lazyload class="full-image" alt="RecyclerView复用机制" title="RecyclerView复用机制" /><meta itemprop="width" content="auto"/><meta itemprop="height" content="auto"/></span>



<h4 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h4><blockquote>
<p>由<code>Recycler</code>进行View的回收</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recycleView</span><span class="hljs-params">(View view)</span> &#123;<br>    <span class="hljs-comment">//传入对应的View 然后通过View获取ViewHolder</span><br>    <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> getChildViewHolderInt(view);<br>    <span class="hljs-comment">//标记该View要移除</span><br>    <span class="hljs-keyword">if</span> (holder.isTmpDetached()) &#123;<br>        removeDetachedView(view, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//该ViewHolder来自缓存可见的数组</span><br>    <span class="hljs-keyword">if</span> (holder.isScrap()) &#123;<br>        <span class="hljs-comment">//清除缓存</span><br>        holder.unScrap();<br>    &#125; <span class="hljs-comment">//holder来自缓存的不可见ViewHolder</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.wasReturnedFromScrap()) &#123;<br>        <span class="hljs-comment">//清除缓存</span><br>        holder.clearReturnedFromScrapFlag();<br>    &#125;<br>    <span class="hljs-comment">//开始回收流程</span><br>    recycleViewHolderInternal(holder);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>回收流程的真正执行逻辑是在<code>recyclerViewHolderInternal()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">recycleViewHolderInternal</span><span class="hljs-params">(ViewHolder holder)</span> &#123;<br>    ...<br>    <span class="hljs-comment">//noinspection unchecked</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">transientStatePreventsRecycling</span> <span class="hljs-operator">=</span> holder<br>            .doesTransientStatePreventRecycling();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">forceRecycle</span> <span class="hljs-operator">=</span> mAdapter != <span class="hljs-literal">null</span><br>            &amp;&amp; transientStatePreventsRecycling<br>            &amp;&amp; mAdapter.onFailedToRecycleView(holder);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">cached</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">recycled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; mCachedViews.contains(holder)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;cached view received recycle internal? &quot;</span><br>                + holder);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (forceRecycle || holder.isRecyclable()) &#123;<br>        <span class="hljs-comment">//要求缓存数量&gt;0，并且ViewHolder的标志是有效的额，且非REMOVED或UPDATE，进行缓存</span><br>        <span class="hljs-keyword">if</span> (mViewCacheMax &gt; <span class="hljs-number">0</span> <span class="hljs-comment">/*大小默认为2*/</span><br>                &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID<br>                        | ViewHolder.FLAG_REMOVED<br>                        | ViewHolder.FLAG_UPDATE<br>                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;<br>            <span class="hljs-comment">// Retire oldest cached view</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">cachedViewSize</span> <span class="hljs-operator">=</span> mCachedViews.size();<br>            <span class="hljs-comment">//mCacheViews已经满了，就把最前面缓存的ViewHolder放到RecyclerViewPool中</span><br>            <span class="hljs-keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//移除 mCachedViews的第一条缓存数据</span><br>                recycleCachedViewAt(<span class="hljs-number">0</span>);①<br>                cachedViewSize--;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">targetCacheIndex</span> <span class="hljs-operator">=</span> cachedViewSize;<br>            <span class="hljs-keyword">if</span> (ALLOW_THREAD_GAP_WORK<br>                    &amp;&amp; cachedViewSize &gt; <span class="hljs-number">0</span><br>                    &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123;<br>                <span class="hljs-comment">// when adding the view, skip past most recently prefetched views</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">cacheIndex</span> <span class="hljs-operator">=</span> cachedViewSize - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (cacheIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cachedPos</span> <span class="hljs-operator">=</span> mCachedViews.get(cacheIndex).mPosition;<br>                    <span class="hljs-comment">//缓存的时候不能覆盖最近经常使用的缓存 利用LFU算法 -- 最少使用策略</span><br>                    <span class="hljs-keyword">if</span> (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    cacheIndex--;<br>                &#125;<br>                targetCacheIndex = cacheIndex + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//将最新的ViewHolder缓存数据插入到mCacheViews中复用</span><br>            mCachedViews.add(targetCacheIndex, holder);<br>            cached = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果没有触发缓存的话 就放进RecyclerViewPool中</span><br>        <span class="hljs-keyword">if</span> (!cached) &#123;<br>            addViewHolderToRecycledViewPool(holder, <span class="hljs-literal">true</span>);<br>            recycled = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> A view can fail to be recycled when it is scrolled off while an animation</span><br>        <span class="hljs-comment">// runs. In this case, the item is eventually recycled by</span><br>        <span class="hljs-comment">// ItemAnimatorRestoreListener#onAnimationFinished.</span><br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> consider cancelling an animation when an item is removed scrollBy,</span><br>        <span class="hljs-comment">// to return it to the pool faster</span><br>        <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;trying to recycle a non-recycleable holder. Hopefully, it will &quot;</span><br>                    + <span class="hljs-string">&quot;re-visit here. We are still removing it from animation lists&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// even if the holder is not removed, we still call this method so that it is removed</span><br>    <span class="hljs-comment">// from view holder lists.</span><br>    mViewInfoStore.removeViewHolder(holder);<br>    <span class="hljs-keyword">if</span> (!cached &amp;&amp; !recycled &amp;&amp; transientStatePreventsRecycling) &#123;<br>        holder.mOwnerRecyclerView = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>①<code>recycleCachedViewAt(0)</code>：移除<code>mCachedViews</code>中的第一条数据并放入到<code>mRecyclerViewPool</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">recycleCachedViewAt</span><span class="hljs-params">(<span class="hljs-type">int</span> cachedViewIndex)</span> &#123;<br>    <span class="hljs-type">ViewHolder</span> <span class="hljs-variable">viewHolder</span> <span class="hljs-operator">=</span> mCachedViews.get(cachedViewIndex);<br>    addViewHolderToRecycledViewPool(viewHolder, <span class="hljs-literal">true</span>);<br>    mCachedViews.remove(cachedViewIndex);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>mRecyclerPool</code>是根据<code>itemType</code>进行缓存的，最大上限为5。</p>
<p>观察上述源码可知，回收机制步骤如下：<strong>回收机制是发生在 RecyclerView滚动时进行的。</strong></p>
<ul>
<li>在RecyclerView滑动时，会调用到<code>LayoutManager.scrollVerticalBy()</code>去处理，在<code>LayoutManager.fill()</code>中会去完成<code>复用以及回收ViewHolder</code>的功能，最终调用到<code>recyclerView()</code>开始回收工作</li>
<li>回收时，先判断<code>mCachedViews</code>是否已满，未满直接放入。如果<code>mCachedViews</code>已满，则取出第一个缓存的ViewHolder放入<code>RecyclerViewPool</code>中，然后放入新的ViewHolder进行缓存</li>
<li>如果因为<code>ViewHolder</code>设置了<code>REMOVED或UPDATED</code>标志，无法加入<code>mCacheViews</code>中，就直接放入到<code>mRecyclerPool</code>中。</li>
</ul>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView回收机制.png" srcset="/img/loading.gif" lazyload class="full-image" alt="RecyclerView回收机制" title="RecyclerView回收机制" /><meta itemprop="width" content="auto"/><meta itemprop="height" content="auto"/></span>

<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>1.RecyclerView的操作场景主要有三种：</p>
<ul>
<li><p><em>有无到有</em>：RecyclerView中没有任何数据，然后调用<code>setAdapter()</code>添加数据源后。RecyclerView添加了数据并显示。</p>
<blockquote>
<p><code>Recycler</code>在这时只是调用到<code>createViewHolder()</code>不会发生缓存事件。</p>
</blockquote>
</li>
<li><p><em>在原有数据的情况下刷新</em>：做了下拉刷新操作，只对屏幕上可见的数据源进行替换。</p>
<blockquote>
<p>这时ViewHolder会被标记<code>FLAG_TMP_DETACHED</code>，然后这时的Viewolder就会被保存到<code>mAttachedScrap</code>中等待复用。</p>
</blockquote>
</li>
<li><p><em>RecyclerView发生滑动</em>：RecyclerView发生了上下或者左右滑动操作。</p>
</li>
</ul>
<p>2.RecyclerView滑动场景下的回收复用涉及到的结构有以下两个：<code>mCachedViews</code>和<code>mRecyclerPool</code></p>
<p>  <code>mCachedViews</code>的优先级高于<code>mRecyclerPool</code>，回收时最新的ViewHolder先放入到<code>mCachedViews</code>中，没位置了就移除最旧的那个给新的腾地方，最旧的就放到<code>mRecyclerPool</code>中。</p>
<p>  复用时也是一样，先从<code>mCachedViews</code>去获取对应的ViewHolder，需要匹配<code>position</code>，就是需要位置对应才能进行复用。找不到就去<code>mRecyclerPool</code>中找，在<code>mRecyclerPool</code>中的ViewHolder都跟新的一样，需要重新绑定数据(<em>bindViewHolder()</em>)。还没有就要自己创建了(<em>createViewHolder()</em>)。</p>
<p>3.<code>mCachedViews</code>上限是2</p>
<h2 id="RecyclerView优化"><a href="#RecyclerView优化" class="headerlink" title="RecyclerView优化"></a>RecyclerView优化</h2><ul>
<li><p><strong>数据处理与视图绑定分离</strong></p>
<blockquote>
<p><code>bindViewHolder()</code>是在主线程中进行的，如果里面发生了耗时操作，会影响滑动的流畅性。</p>
<p><strong><code>onBindViewHolder()</code>中应该只进行数据的<code>set</code>操作，不需要做其他判断。</strong></p>
</blockquote>
</li>
<li><p><strong>数据优化</strong></p>
<blockquote>
<ol>
<li>分页加载远端数据，对拉取的数据进行缓存，提高二次加载的速度</li>
<li>对于新增或删除数据通过<code>DiffUtil</code>，来进行局部数据刷新，而不是每次都去进行全量刷新。</li>
</ol>
</blockquote>
</li>
<li><p><strong>布局优化</strong></p>
<blockquote>
<ol>
<li><code>减少过度绘制</code>：减少布局层级，可以考虑使用自定义View来减少层级，或者设置更合理的布局。</li>
<li><code>减少xml文件</code>：<code>inflate</code>时间：去解析xml都需要经过耗时的IO操作，可以利用代码直接生成对应的布局，利用<code>new View()</code>生成。</li>
<li><code>减少View对象的创建</code>：需要尽可能简化ItemView，对多ViewType能够共用的部分尽量设计成自定义View，减少View的构造和嵌套。</li>
</ol>
</blockquote>
</li>
<li><p><strong>其他优化</strong></p>
<blockquote>
<ol>
<li><p>设置高度固定：如果Item高度固定的话，可以使用<code>RecyclerView.setHasFixedSize(true)</code>，避免调用<code>requestLayout()</code></p>
</li>
<li><p>共用<code>RecycledViewPool</code>：具有相关的Adapter，就可以调用<code>RecyclerView.setRecycledViewPool(pool)</code>共用同一个。</p>
</li>
<li><p>加大RecyclerView的缓存：空间换时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">recyclerView.setItemViewCacheSize(<span class="hljs-number">20</span>);<br>recyclerView.setDrawingCacheEnabled(<span class="hljs-literal">true</span>);<br>recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);<br></code></pre></td></tr></table></figure>
</li>
<li><p>增加RecyclerView预留的额外空间：显示范围之外，增加额外的缓存空间。<em>默认为2。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearLayoutManager</span>(<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getExtraLayoutSpace</span><span class="hljs-params">(RecyclerView.State state)</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


</li>
<li><p>减少ItemView监听器的创建</p>
<blockquote>
<p>不要对每个Item都去创建一个监听器，而是根据<code>android:id</code>设置不同的操作，共用一个监听器。</p>
</blockquote>
</li>
<li><p>优化滑动操作：设置<code>RecyclerView.addOnScrollListener()</code>在滑动过程中停止加载</p>
</li>
<li><p>关闭默认动画效果：设置<code>((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false)</code></p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="RecyclerView拓展"><a href="#RecyclerView拓展" class="headerlink" title="RecyclerView拓展"></a>RecyclerView拓展</h2><p>是否需要将ListView替换成RecyclerView?</p>
<blockquote>
<p>从性能上看，RecyclerView并没有带来明显的提升。如果需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView。只是单纯用于展示数据的话，ListView实现更加简单。</p>
</blockquote>
<h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dasusu/p/7746946.html">基于场景解析RecyclerView的回收复用机制原理</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA">RecyclerView必知必会</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/" class="print-no-link">#Android</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>RecyclerView简析</div>
      <div>https://leo-wxy.github.io/2018/12/20/RecycleView简析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Leo-Wxy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2018年12月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/" title="数据结构-红黑树">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构-红黑树</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/12/20/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%80%BB%E8%A7%88/" title="Android性能优化">
                        <span class="hidden-mobile">Android性能优化</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
