

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>RecyclerView简析 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="RecyclerView简析">
              
                RecyclerView简析
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-12-20 11:49" pubdate>
        2018年12月20日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      96
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">RecyclerView简析</h1>
            
            <div class="markdown-body">
              <span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView机制.png" srcset="/img/loading.gif" class="full-image" alt="RecyclerView机制" title="RecyclerView机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="RecyclerView定义"><a href="#RecyclerView定义" class="headerlink" title="RecyclerView定义"></a>RecyclerView定义</h2><blockquote>
<p>RecyclerView是一个新的组件，用来代替ListView组件的。</p>
</blockquote>
<p>相比于ListView来说，RecyclerView的最大一个特性就是<strong>灵活性</strong>，主要体现在以下几个方面：</p>
<ul>
<li><code>多样式</code>：可以对数据展示进行定制，可以显示成列表，表格或者是瀑布流，你还可以自定义成任何显示样式。</li>
<li><code>局部刷新</code>：可以刷新指定的Item或者区域</li>
<li><code>刷新动画</code>：支持对Item的添加和移除添加动画</li>
<li><code>添加装饰</code>：支持自定义Item之间的分割线效果</li>
</ul>
<p>相比ListView还有其他的优点：</p>
<ul>
<li>默认实现View的复用，不需要判断<code>if(convertView == null)</code>的实现，回收机制更加完善。</li>
<li>容易实现拖拽，侧滑删除等效果。(利用<code>ItemTouchHelper</code>)</li>
</ul>
<p>RecyclerView是一个插件式的实现，对各个功能进行解耦，从而扩展性比较好。</p>
<h2 id="RecyclerView用法"><a href="#RecyclerView用法" class="headerlink" title="RecyclerView用法"></a>RecyclerView用法</h2><p>RecyclerView的标准实现流程如下：</p>
<ul>
<li><p>创建Adapter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class DemoAdapter extends RecyclerView.Adapter&lt;DemoAdapter.VH&gt; &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建一个继承<code>RecyclerView.Adapter</code>的Adapter类</p>
</li>
<li><p>创建ViewHolder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> class VH extends RecyclerView.ViewHolder &#123;<br>    <span class="hljs-keyword">final</span> TextView title;<br>  <br>    VH(@NonNull View itemView) &#123;<br>        <span class="hljs-keyword">super</span>(itemView);<br>        title = itemView.findViewById(R.id.title);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建一个继承<code>RecyclerView.ViewHolder</code>的静态内部类，记为<code>VH</code>。内部实现类似<code>ListView的ViewHolder</code>。</p>
</li>
<li><p>完善以下方法：</p>
<ul>
<li><p><code>VH onCreateViewHolder(ViewGroup parent,int viewType)</code>：绑定对应的layout id并创建<code>VH</code>返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> DemoAdapter.VH onCreateViewHolder(@NonNull ViewGroup parent, <span class="hljs-keyword">int</span> viewType) &#123;<br>    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_demo, parent, <span class="hljs-keyword">false</span>);<br>    return new VH(view);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>void onBindViewHolder(VH holder,int position)</code>：为<code>VH</code>设置事件以及数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onBindViewHolder(@NonNull VH holder, <span class="hljs-keyword">int</span> position) &#123;<br>    holder.title.setText(mData.get(position));<br>    holder.itemView.setOnClickListener(new View.OnClickListener() &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onClick(View v) &#123;<br>            //设置item点击事件<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>int getItemCount()</code>：返回item个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> getItemCount() &#123;<br>     return mData.size();<br> &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>Adapter创建完成后，需要把Adapter设置到RecyclerView上。一般来说需要为RecyclerView进行四大设置：</p>
<ul>
<li><strong>设置Adapter(必须设置)</strong>：给RecyclerView绑定数据源 </li>
<li><strong>设置LayoutManager(必须设置)</strong>：给RecyclerView设置显示样式</li>
<li><strong>设置Item Decoration(可以设置)</strong>：给RecyclerView设置Item间的分割线</li>
<li><strong>设置Item Animator(可以设置)</strong>：给RecyclerView设置Item的添加和删除动画</li>
</ul>
<p>设置实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; data = new ArrayList&lt;&gt;();<br><br>RecyclerView rv_demo = (RecyclerView)findViewById(R.id.rv_demo);<br>rv_demo.setAdapter(new DemoAdapter(data));<br>rv_demo.setLayoutManager(new LinearLayoutManager(<span class="hljs-keyword">this</span>));//默认竖向显示<br></code></pre></td></tr></table></figure>
<p>更新数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">rv_demo.notifyDataSetChanged();//更新整个视图<br>//更新局部视图<br>rv_demo.notifyitemInserted();<br>rv_demo.notifyItemRemoved();<br>rv_demo.notifyitemChanged();<br></code></pre></td></tr></table></figure>
<h2 id="RecyclerView源码解析"><a href="#RecyclerView源码解析" class="headerlink" title="RecyclerView源码解析"></a>RecyclerView源码解析</h2><blockquote>
<p>RecyclerView的四大组成部分：<strong>Adapter、LayoutManager、ItemAnimator，ItemDecoration</strong>。</p>
</blockquote>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><blockquote>
<p>主要为了给RecyclerView提供数据，将Data与View进行绑定。创建ViewHolder以及数据变化时通知到RecyclerView。通知RecyclerView使用的是<em>观察者模式</em>。</p>
</blockquote>
<p>在<code>setAdapter()</code>时，就会给Adapter注册一个观察者，去通知RecyclerView数据变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setAdapter(Adapter adapter) &#123;<br>    // bail out <span class="hljs-keyword">if</span> layout is frozen<br>    setLayoutFrozen(<span class="hljs-keyword">false</span>);<br>    setAdapterInternal(adapter, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>    requestLayout();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> setAdapterInternal(Adapter adapter, <span class="hljs-keyword">boolean</span> compatibleWithPrevious,<br>        <span class="hljs-keyword">boolean</span> removeAndRecycleViews) &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (adapter != <span class="hljs-keyword">null</span>) &#123;<br>        //注册观察者<br>        adapter.registerAdapterDataObserver(mObserver);<br>        adapter.onAttachedToRecyclerView(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h3><blockquote>
<p>负责RecyclerView的布局，其中包含了Item View的获取与回收。后面会分析它的缓存机制。</p>
</blockquote>
<p>还是按照绘制流程来看，LayoutManager在RecyclerView中是如何使用的？</p>
<blockquote>
<p>Measure流程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">LayoutManager mLayout;   <br>@Override<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> onMeasure(<span class="hljs-keyword">int</span> widthSpec, <span class="hljs-keyword">int</span> heightSpec) &#123;<br>      <span class="hljs-keyword">if</span> (mLayout.mAutoMeasure) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> skipMeasure = widthMode == MeasureSpec.EXACTLY<br>                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;<br>            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);<br>       ... <br>      &#125;<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>RecyclerView.onMeasure()</code>中调用到了<code>LayoutManager.onMeasure()</code>，然后其中执行到了<code>RecyclerView.defaultOnMeasure()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">void</span> defaultOnMeasure(<span class="hljs-keyword">int</span> widthSpec, <span class="hljs-keyword">int</span> heightSpec) &#123;<br>        // calling LayoutManager here is not pretty but that API is already <span class="hljs-keyword">public</span> and it is better<br>        // than creating another method since <span class="hljs-keyword">this</span> is internal.<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = LayoutManager.chooseSize(widthSpec,<br>                getPaddingLeft() + getPaddingRight(),<br>                getMinimumWidth());<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = LayoutManager.chooseSize(heightSpec,<br>                getPaddingTop() + getPaddingBottom(),<br>                getMinimumHeight());<br><br>        setMeasuredDimension(width, height);<br>    &#125;<br><br>// LayoutManager.java<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> chooseSize(<span class="hljs-keyword">int</span> spec, <span class="hljs-keyword">int</span> desired, <span class="hljs-keyword">int</span> min) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mode = View.MeasureSpec.getMode(spec);<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = View.MeasureSpec.getSize(spec);<br>            <span class="hljs-keyword">switch</span> (mode) &#123;<br>                <span class="hljs-keyword">case</span> View.MeasureSpec.EXACTLY:<br>                    return size;<br>                <span class="hljs-keyword">case</span> View.MeasureSpec.AT_MOST:<br>                    return Math.min(size, Math.max(desired, min));<br>                <span class="hljs-keyword">case</span> View.MeasureSpec.UNSPECIFIED:<br>                <span class="hljs-keyword">default</span>:<br>                    return Math.max(desired, min);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>最终RecyclerView的<code>Measure流程</code>依赖<code>LayoutManager.chooseSize()</code>来确定最后的RecyclerView宽高。</p>
<blockquote>
<p>Layout流程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">@Override<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> onLayout(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b) &#123;<br>    Trace.beginSection(TRACE_ON_LAYOUT_TAG);<br>    dispatchLayout();<br>    Trace.endSection();<br>    mFirstLayoutComplete = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> dispatchLayout() &#123;<br>   ...<br>    mState.mIsMeasuring = <span class="hljs-keyword">false</span>;<br>    //第一次开始布局<br>    <span class="hljs-keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;<br>        //存储ziView状态并确定是否要执行动画<br>        dispatchLayoutStep1();<br>        mLayout.setExactMeasureSpecsFrom(<span class="hljs-keyword">this</span>);<br>        dispatchLayoutStep2();<br>      //发生了数据变化(notifyDataSetChanges)或者布局变化<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()<br>            || mLayout.getHeight() != getHeight()) &#123;<br>        // First 2 steps are done in onMeasure but looks like we have to run again due to<br>        // changed size.<br>        mLayout.setExactMeasureSpecsFrom(<span class="hljs-keyword">this</span>);<br>        //Item布局过程<br>        dispatchLayoutStep2();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // always make sure we sync them (to ensure mode is exact)<br>        mLayout.setExactMeasureSpecsFrom(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    //执行Item 动画<br>    dispatchLayoutStep3();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>观察上述源码发现，涉及布局过程的只有<code>dispatchLayoutStep2()</code>，从这个方法继续向下看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> dispatchLayoutStep2() &#123;<br>    ...<br>    // Step 2: Run layout<br>    mState.mInPreLayout = <span class="hljs-keyword">false</span>;<br>    mLayout.onLayoutChildren(mRecycler, mState);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里涉及到了<code>LayoutManager.onLayoutChildren()</code>，由于默认是空实现，我们就拿<code>LinearLayoutManager</code>这个子类继续分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java">// LinearLayoutManager.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;<br>     ...<br>        <span class="hljs-keyword">int</span> startOffset;<br>        <span class="hljs-keyword">int</span> endOffset;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> firstLayoutDirection;<br>        <span class="hljs-keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;<br>            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL<br>                    : LayoutState.ITEM_DIRECTION_HEAD;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD<br>                    : LayoutState.ITEM_DIRECTION_TAIL;<br>        &#125;<br><br>        onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);<br>        detachAndScrapAttachedViews(recycler);<br>        mLayoutState.mInfinite = resolveIsInfinite();<br>        mLayoutState.mIsPreLayout = state.isPreLayout();<br>        //是否从底部布局<br>        <span class="hljs-keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;  <br>           // 向上布局<br>            updateLayoutStateToFillStart(mAnchorInfo);<br>            mLayoutState.mExtra = extraForStart;<br>            //填充item<br>            fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);<br>            startOffset = mLayoutState.mOffset;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> firstElement = mLayoutState.mCurrentPosition;<br>            <span class="hljs-keyword">if</span> (mLayoutState.mAvailable &gt; 0) &#123;<br>                extraForEnd += mLayoutState.mAvailable;<br>            &#125;<br>            //向下布局<br>            updateLayoutStateToFillEnd(mAnchorInfo);<br>            mLayoutState.mExtra = extraForEnd;<br>            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;<br>            fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);<br>            endOffset = mLayoutState.mOffset;<br><br>            <span class="hljs-keyword">if</span> (mLayoutState.mAvailable &gt; 0) &#123;<br>                // end could not consume all. add more items towards start<br>                extraForStart = mLayoutState.mAvailable;<br>                updateLayoutStateToFillStart(firstElement, startOffset);<br>                mLayoutState.mExtra = extraForStart;<br>                fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);<br>                startOffset = mLayoutState.mOffset;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          ...<br>          <br>        &#125;<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>确定布局方向后，就需要填充子View，利用<code>fill()</code>实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> fill(RecyclerView.Recycler recycler, LayoutState layoutState,<br>        RecyclerView.State state, <span class="hljs-keyword">boolean</span> stopOnFocusable) &#123;<br>   //存储当前可用空间<br>   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = layoutState.mAvailable;<br>   ...<br>    //计算可用布局宽高<br>    <span class="hljs-keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;<br>    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;<br>   //迭代填充Item<br>    <span class="hljs-keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123;<br>        layoutChunkResult.resetInternal();<br>        //布局item<br>        layoutChunk(recycler, state, layoutState, layoutChunkResult);<br>        <span class="hljs-keyword">if</span> (layoutChunkResult.mFinished) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;<br>       //子View的回收工作<br>    &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>fill()</code>中循环调用<code>layoutChunk()</code>进行布局。每次布局完成后需要计算剩余空间，之后判断是否需要继续布局Item。</p>
<p>向下看Item的布局方法<code>layoutChunk()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,<br>22LayoutState layoutState, LayoutChunkResult result) &#123;<br>2// 获取item view<br>2View view = layoutState.next(recycler);<br>2// 获取布局参数<br>2LayoutParams params = (LayoutParams) view.getLayoutParams();<br>2<span class="hljs-keyword">if</span> (layoutState.mScrapList == <span class="hljs-keyword">null</span>) &#123;<br>22<span class="hljs-keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection== LayoutState.LAYOUT_START)) &#123;<br>222// 增加item view<br>222addView(view);<br>22&#125; <span class="hljs-keyword">else</span> &#123;<br>222addView(view, 0);<br>22&#125;<br>2&#125; <br>2// 测量item<br>2measureChildWithMargins(view, 0, 0);<br>2// 计算item使用的空间<br>2result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);<br>2<span class="hljs-keyword">int</span> left, top, right, bottom;<br>2// 竖直方向布局，计算Item坐标<br>2<span class="hljs-keyword">if</span> (mOrientation == VERTICAL) &#123;<br>    //设置了从右向左的布局方式<br>22<span class="hljs-keyword">if</span> (isLayoutRTL()) &#123;<br>222right = getWidth() - getPaddingRight();<br>222left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);<br>22&#125; <span class="hljs-keyword">else</span> &#123;<br>222left = getPaddingLeft();<br>222right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);<br>22&#125;<br>22<span class="hljs-keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;<br>222bottom = layoutState.mOffset;<br>222top = layoutState.mOffset - result.mConsumed;<br>22&#125; <span class="hljs-keyword">else</span> &#123;<br>222top = layoutState.mOffset;<br>222bottom = layoutState.mOffset + result.mConsumed;<br>22&#125;   <br>2&#125; <br>  //水平方向布局，计算Item坐标<br>  <span class="hljs-keyword">else</span> &#123;<br>     top = getPaddingTop();<br>     bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);<br><br>     <span class="hljs-keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;<br>          right = layoutState.mOffset;<br>          left = layoutState.mOffset - result.mConsumed;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>          left = layoutState.mOffset;<br>          right = layoutState.mOffset + result.mConsumed;<br>     &#125;	   <br>2&#125;<br>  	// item布局<br>2layoutDecoratedWithMargins(view, left, top, right, bottom);<br>  ...<br>&#125;<br><br>//测量子View的布局<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> measureChildWithMargins(View child, <span class="hljs-keyword">int</span> widthUsed, <span class="hljs-keyword">int</span> heightUsed) &#123;<br>            <span class="hljs-keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();<br><br>            <span class="hljs-keyword">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);<br>            widthUsed += insets.left + insets.right;<br>            heightUsed += insets.top + insets.bottom;<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),<br>                    getPaddingLeft() + getPaddingRight()<br>                            + lp.leftMargin + lp.rightMargin + widthUsed, lp.width,<br>                    canScrollHorizontally());<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),<br>                    getPaddingTop() + getPaddingBottom()<br>                            + lp.topMargin + lp.bottomMargin + heightUsed, lp.height,<br>                    canScrollVertically());<br>            <span class="hljs-keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;<br>               //子View测量<br>                child.measure(widthSpec, heightSpec);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> layoutDecoratedWithMargins(View child, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right,<br>                <span class="hljs-keyword">int</span> bottom) &#123;<br>            <span class="hljs-keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();<br>            <span class="hljs-keyword">final</span> Rect insets = lp.mDecorInsets;<br>            //子view布局<br>            child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,<br>                    right - insets.right - lp.rightMargin,<br>                    bottom - insets.bottom - lp.bottomMargin);<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>layoutChunk()</code>中完成了子View的<code>measure以及layout</code>过程。</p>
<blockquote>
<p>Draw过程</p>
</blockquote>
<p>Draw过程就是下文描述到的<code>ItemDecoration</code>，主要完成的就是绘制分割线的过程。</p>
<p><br></p>
<h3 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h3><blockquote>
<p>RecyclerView能够通过<code>RecyclerView.setItemAnimator(ItemAnimator animator)</code>设置添加、删除、移动、改变的动画效果。提供了默认的动画效果<code>DefaultItemAnimator</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java">class CustomItemAnimator : RecyclerView.ItemAnimator()&#123;<br><br>  override fun isRunning(): Boolean &#123;<br>        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.<br>    &#125;<br>    <br>    override fun animatePersistence(<br>        viewHolder: RecyclerView.ViewHolder,<br>        preLayoutInfo: ItemHolderInfo,<br>        postLayoutInfo: ItemHolderInfo<br>    ): Boolean &#123;<br>        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.<br>    &#125;<br><br>    override fun runPendingAnimations() &#123;<br>        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.<br>    &#125;<br><br>    override fun endAnimation(item: RecyclerView.ViewHolder) &#123;<br>        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.<br>    &#125;<br><br>    override fun animateDisappearance(<br>        viewHolder: RecyclerView.ViewHolder,<br>        preLayoutInfo: ItemHolderInfo,<br>        postLayoutInfo: ItemHolderInfo?<br>    ): Boolean &#123;<br>        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.<br>    &#125;<br><br>    override fun animateChange(<br>        oldHolder: RecyclerView.ViewHolder,<br>        newHolder: RecyclerView.ViewHolder,<br>        preLayoutInfo: ItemHolderInfo,<br>        postLayoutInfo: ItemHolderInfo<br>    ): Boolean &#123;<br>        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.<br>    &#125;<br><br>    override fun animateAppearance(<br>        viewHolder: RecyclerView.ViewHolder,<br>        preLayoutInfo: ItemHolderInfo?,<br>        postLayoutInfo: ItemHolderInfo<br>    ): Boolean &#123;<br>        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.<br>    &#125;<br><br>    override fun endAnimations() &#123;<br>        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>animateAppearance()</code>：当ViewHolder出现在屏幕上时被调用(<em>可能是add或move</em>)</li>
<li><code>animateDisappearance()</code>：当ViewHolder消失在屏幕上时被调用(<em>可能是remove或move</em>)</li>
<li><code>animatePersistence()</code>：在没调用<code>notifyItemChanged()</code>和<code>notifyDataSetChanged()</code>的情况下发生布局改变时被调用</li>
<li><code>animateChange()</code>：在调用<code>notifyItemChanged()</code>或<code>notifyDataSetChanged()</code>的情况下发生布局改变时被调用</li>
<li><code>runPendingAnimations()</code>：RecyclerView的执行方式是每帧执行一次，如果在帧之间添加了多个Item，就会保存Pending动画，等到下一帧一起执行。<strong>前面定义的<code>animateXXX()</code>返回true。</strong></li>
<li><code>isRunning()</code>：是否有动画要执行或正在执行</li>
<li><code>dispatchAnimationsFinished()</code>：当全部动画执行完毕时调用</li>
</ul>
<blockquote>
<p>对于<code>ItemAnimator</code>，最常见的是<em>闪屏问题</em> ——当Item中存在图片和文字时，刷新RecyclerView时会出现闪烁问题。</p>
<p>出现原因是由于调用<code>notifyDataSetChanged()</code>，会调用到<code>DefaultAnimator.animateChangeImpl()</code>执行change动画，导致透明度发生0-1的变化，发生闪烁。</p>
<p>解决方法：在<code>setAdapter()</code>之前调用<code>((SimpleItemAnimator)rv.getItemAnimator()).setSupportsChangeAnimations(false)</code>禁用change动画。</p>
</blockquote>
<p><br></p>
<h3 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h3><blockquote>
<p>RecyclerView通过<code>addItemDecoration()</code>添加Item之间的分割线。</p>
</blockquote>
<p>如果我们要自己实现一个分割线效果，需要自己创建一个类并继承<code>RecyclerView.ItemDecoration</code>，重写一下两个方法：</p>
<ul>
<li><code>onDraw()</code>：绘制分割线</li>
<li><code>getItemOffsets()</code>：设置分割线的宽高</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">class CustomDecoration : RecyclerView.ItemDecoration() &#123;<br>    override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State) &#123;<br>        //调用在Item绘制完毕前，绘制分割线<br>    &#125;<br><br>    override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) &#123;<br>        //定义分割线的宽/高，在不同的显示模式下<br>    &#125;<br><br>    override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) &#123;<br>       //调用在Item绘制完毕后，绘制分割线<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来分析RecyclerView是如何调用到分割线？</p>
<p>回顾View的绘制流程是<em>measure-&gt;layout-&gt;draw</em>，我们开始分析分割线的调用流程。</p>
<p>由于RecyclerView继承自<code>ViewGroup</code>，分割线是作为Item之间的间隔使用，那就要从<code>measureChild()</code>开始查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> measureChild(View child, <span class="hljs-keyword">int</span> widthUsed, <span class="hljs-keyword">int</span> heightUsed) &#123;<br>           <span class="hljs-keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();<br>           //获取设置的分割线<br>           <span class="hljs-keyword">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);<br>           widthUsed += insets.left + insets.right;<br>           heightUsed += insets.top + insets.bottom;<br>           //都需要在原基础上 加上分割线的宽/高<br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),<br>                   getPaddingLeft() + getPaddingRight() + widthUsed, lp.width,<br>                   canScrollHorizontally());<br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),<br>                   getPaddingTop() + getPaddingBottom() + heightUsed, lp.height,<br>                   canScrollVertically()); <br>           <span class="hljs-keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;<br>               child.measure(widthSpec, heightSpec);<br>           &#125;<br>       &#125;<br><br>Rect getItemDecorInsetsForChild(View child) &#123;<br>       ...<br>           //调用到设置的 getItemOffsets()<br>           mItemDecorations.get(i).getItemOffsets(mTempRect, child, <span class="hljs-keyword">this</span>, mState);<br>       ...<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>measureChild()</code>找到了引用分割线并设置宽高的地方，接下啦需要找到引用绘制(<code>onDraw</code>)的地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onDraw(Canvas c) &#123;<br>        //调用到父类的 onDraw 即 View.onDraw<br>        <span class="hljs-keyword">super</span>.onDraw(c);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mItemDecorations.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; count; i++) &#123;<br>            mItemDecorations.get(i).onDraw(c, <span class="hljs-keyword">this</span>, mState);<br>        &#125;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> draw(Canvas c) &#123;<br>        //调用到父类的 draw() 即  View.draw()<br>        <span class="hljs-keyword">super</span>.draw(c);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mItemDecorations.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; count; i++) &#123;<br>            mItemDecorations.get(i).onDrawOver(c, <span class="hljs-keyword">this</span>, mState);<br>        &#125;<br>      ...<br>    &#125;<br><br>// View.java<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> draw(Canvas canvas) &#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);<br>  ...<br> &#125;<br></code></pre></td></tr></table></figure>
<p>上面找到了两个引用了<code>ItemDecoration</code>的绘制方法。这里回顾一下<code>ViewGroup</code>的Draw流程，先调用自身的<code>draw()</code>，然后<code>drawBackground()</code>，向下到<code>onDraw()</code>，绘制子View<code>disaptchDraw()</code>。</p>
<p>根据Draw流程分析，先调用到<code>RecyclerView.draw()</code>，发现调用到了<code>super.draw()</code>即指向了<code>View.draw()</code>这时View调用到自身的<code>onDraw()</code>，而RecyclerView重写了该方法，就调用到了<code>ItemDecoration.onDraw()</code>，然后走向<code>dispatchDraw()</code>绘制子View。绘制完毕后，最后调用到了<code>ItemDecoration.onDrawOver()</code>。</p>
<p>综上所述：<strong><code>onDraw()</code>调用在子View绘制前，<code>onDrawOver()</code>在绘制之后执行</strong>。</p>
<p><br></p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><blockquote>
<p>RecyclerView是以<code>RecyclerView.ViewHolder</code>作为单位进行回收。Recycler是RecyclerView回收机制的实现类。</p>
</blockquote>
<p>Recycler实现的是<strong>四级缓存</strong>：</p>
<ul>
<li><code>mAttachedScrap</code>：缓存已在屏幕上的ViewHolder。   <em>一级缓存</em></li>
<li><code>mCacheViews</code>：缓存屏幕外的ViewHolder，默认为2个。  <em>一级缓存</em></li>
<li><code>mViewCacheExtension</code>：需要用户定制，默认不实现。  <em>二级缓存</em></li>
<li><code>mRecyclerPool</code>：缓存池，<code>mCacheViews</code>集合中装满时，会放到这里。技术上可以实现所有<code>RecyclerViewPool</code>共用。默认为5个。 <em>三级缓存</em></li>
<li><code>createViewHolder</code>：创建ViewHolder。<em>‌四级缓存</em></li>
</ul>
<p>缓存机制主要分为两段流程：<strong>复用机制和回收机制。</strong></p>
<h4 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h4><blockquote>
<p> 从<code>Recycler</code>获取一个<code>ViewHolder</code></p>
</blockquote>
<p><code>LayoutManager</code>通过调用<code>Recycler.getViewForPosition(pos)</code>获取<code>pos</code>位置上的<code>view</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> View getViewForPosition(<span class="hljs-keyword">int</span> position) &#123;<br>        return getViewForPosition(position, <span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    View getViewForPosition(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">boolean</span> dryRun) &#123;<br>        return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;<br>    &#125;<br>    //复用机制的主要方实现<br>ViewHolder tryGetViewHolderForPositionByDeadline(<span class="hljs-keyword">int</span> position,<br>            <span class="hljs-keyword">boolean</span> dryRun, <span class="hljs-keyword">long</span> deadlineNs) &#123;<br>        //判断位置是否正常<br>        <span class="hljs-keyword">if</span> (position &lt; 0 || position &gt;= mState.getItemCount()) &#123;<br>            throw new IndexOutOfBoundsException("Invalid item position " + position<br>                    + "(" + position + "). Item count:" + mState.getItemCount());<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> fromScrapOrHiddenOrCache = <span class="hljs-keyword">false</span>;<br>        ViewHolder holder = <span class="hljs-keyword">null</span>;<br>        // 是否设置动画<br>        <span class="hljs-keyword">if</span> (mState.isPreLayout()) &#123;<br>            holder = getChangedScrapViewForPosition(position);<br>            fromScrapOrHiddenOrCache = holder != <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;<br>            //从 mAttcherScrap 或者 mCachedViews 获取holder<br>            holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);①<br>            <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;<br>                //判定ViewHolder是否有效<br>                <span class="hljs-keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;②<br>                    // recycle holder (and unscrap <span class="hljs-keyword">if</span> relevant) since it can't be used<br>                    <span class="hljs-keyword">if</span> (!dryRun) &#123;<br>                        //设置回收标记<br>                        holder.addFlags(ViewHolder.FLAG_INVALID);<br>                        <span class="hljs-keyword">if</span> (holder.isScrap()) &#123;<br>                            removeDetachedView(holder.itemView, <span class="hljs-keyword">false</span>);<br>                            holder.unScrap();<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.wasReturnedFromScrap()) &#123;<br>                            holder.clearReturnedFromScrapFlag();<br>                        &#125;<br>                        recycleViewHolderInternal(holder);<br>                    &#125;<br>                    holder = <span class="hljs-keyword">null</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    fromScrapOrHiddenOrCache = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);<br>            <span class="hljs-keyword">if</span> (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) &#123;<br>                throw new IndexOutOfBoundsException("Inconsistency detected. Invalid item "<br>                        + "position " + position + "(offset:" + offsetPosition + ")."<br>                        + "state:" + mState.getItemCount());<br>            &#125;<br>            //获取item设置的type<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);<br>            // stable id 就是标识一个viewholder的唯一性<br>            <span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;<br>                holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),③<br>                        type, dryRun);<br>                <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;<br>                    // update position<br>                    holder.mPosition = offsetPosition;<br>                    fromScrapOrHiddenOrCache = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>            //从用户自己设置的 mViewCacheExtension 去寻找对应ViewHolder·<br>            <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="hljs-keyword">null</span>) &#123;<br>                // We are NOT sending the offsetPosition because LayoutManager does not<br>                // know it.<br>                <span class="hljs-keyword">final</span> View view = mViewCacheExtension<br>                        .getViewForPositionAndType(<span class="hljs-keyword">this</span>, position, type);<br>                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;<br>                    //包装成一个ViewHolder<br>                    holder = getChildViewHolder(view);<br>                    <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;<br>                        throw new IllegalArgumentException("getViewForPositionAndType returned"<br>                                + " a view which does not have a ViewHolder");<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.shouldIgnore()) &#123;<br>                        throw new IllegalArgumentException("getViewForPositionAndType returned"<br>                                + " a view that is ignored. You must call stopIgnoring before"<br>                                + " returning <span class="hljs-keyword">this</span> view.");<br>                    &#125;<br>                &#125;<br>            &#125;<br>            //从 RecyclerViewPool去寻找对应的ViewHolder<br>            <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123; // fallback to pool<br>                <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                    Log.d(TAG, "tryGetViewHolderForPositionByDeadline("<br>                            + position + ") fetching from shared pool");<br>                &#125;<br>                holder = getRecycledViewPool().getRecycledView(type);④<br>                <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;<br>                    holder.resetInternal();⑤<br>                    <span class="hljs-keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;<br>                        invalidateDisplayListInt(holder);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            //从以上三级缓存中都没有找到对应的ViewHolder就只能自己创建了<br>            <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">long</span> start = getNanoTime();<br>                <span class="hljs-keyword">if</span> (deadlineNs != FOREVER_NS<br>                        &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;<br>                    // abort - we have a deadline we can't meet<br>                    return <span class="hljs-keyword">null</span>;<br>                &#125;<br>                //创建对应的ViewHolder<br>                holder = mAdapter.createViewHolder(RecyclerView.<span class="hljs-keyword">this</span>, type);<br>                <span class="hljs-keyword">if</span> (ALLOW_THREAD_GAP_WORK) &#123;<br>                    // only bother finding nested RV <span class="hljs-keyword">if</span> prefetching<br>                    RecyclerView innerView = findNestedRecyclerView(holder.itemView);<br>                    <span class="hljs-keyword">if</span> (innerView != <span class="hljs-keyword">null</span>) &#123;<br>                        holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView);<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">long</span> end = getNanoTime();<br>                mRecyclerPool.factorInCreateTime(type, end - start);<br>                <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                    Log.d(TAG, "tryGetViewHolderForPositionByDeadline created new ViewHolder");<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        // This is very ugly but the only place we can grab <span class="hljs-keyword">this</span> information<br>        // before the View is rebound and returned to the LayoutManager <span class="hljs-keyword">for</span> post layout ops.<br>        // We don't need <span class="hljs-keyword">this</span> in pre-layout since the VH is not updated by the LM.<br>        <span class="hljs-keyword">if</span> (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder<br>                .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) &#123;<br>            holder.setFlags(0, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);<br>            <span class="hljs-keyword">if</span> (mState.mRunSimpleAnimations) &#123;<br>                <span class="hljs-keyword">int</span> changeFlags = ItemAnimator<br>                        .buildAdapterChangeFlagsForAnimations(holder);<br>                changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;<br>                <span class="hljs-keyword">final</span> ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState,<br>                        holder, changeFlags, holder.getUnmodifiedPayloads());<br>                recordAnimationInfoIfBouncedHiddenView(holder, info);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span> bound = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;<br>            // <span class="hljs-keyword">do</span> not update unless we absolutely have to.<br>            holder.mPreLayoutPosition = position;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; holder.isRemoved()) &#123;<br>                throw new IllegalStateException("Removed holder should be bound and it should"<br>                        + " come here only in pre-layout. Holder: " + holder);<br>            &#125;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);<br>            bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);<br>        &#125;<br>        //设置对应ViewHolder的 layoutparams<br>        <span class="hljs-keyword">final</span> ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();<br>        <span class="hljs-keyword">final</span> LayoutParams rvLayoutParams;<br>        <span class="hljs-keyword">if</span> (lp == <span class="hljs-keyword">null</span>) &#123;<br>            rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();<br>            holder.itemView.setLayoutParams(rvLayoutParams);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!checkLayoutParams(lp)) &#123;<br>            rvLayoutParams = (LayoutParams) generateLayoutParams(lp);<br>            holder.itemView.setLayoutParams(rvLayoutParams);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rvLayoutParams = (LayoutParams) lp;<br>        &#125;<br>        rvLayoutParams.mViewHolder = holder;<br>        rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound;<br>        return holder;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>①<code>getScrapOrHiddenOrCachedHolderForPosition()</code>：从<code>mAttchedScrap</code>或者<code>mCachedViews</code>去获取ViewHolder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewHolder getScrapOrHiddenOrCachedHolderForPosition(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">boolean</span> dryRun) &#123;  <br>  //先从 mAttachedScrap 获取对应的ViewHolder<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; scrapCount; i++) &#123;<br>               <span class="hljs-keyword">final</span> ViewHolder holder = mAttachedScrap.get(i);<br>               <span class="hljs-keyword">if</span> (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position<br>                       &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) &#123;<br>                   holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);<br>                   return holder;<br>               &#125;<br>           &#125;<br>   //从隐藏的View中去寻找ViewHolder<br>   <span class="hljs-keyword">if</span> (!dryRun) &#123;<br>               View view = mChildHelper.findHiddenNonRemovedView(position);<br>               <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;<br>                   // This View is good to be used. We just need to unhide, detach and move to the<br>                   // scrap list.<br>                   <span class="hljs-keyword">final</span> ViewHolder vh = getChildViewHolderInt(view);<br>                   mChildHelper.unhide(view);<br>                   <span class="hljs-keyword">int</span> layoutIndex = mChildHelper.indexOfChild(view);<br>                   <span class="hljs-keyword">if</span> (layoutIndex == RecyclerView.NO_POSITION) &#123;<br>                       throw new IllegalStateException("layout index should not be -1 after "<br>                               + "unhiding a view:" + vh);<br>                   &#125;<br>                   mChildHelper.detachViewFromParent(layoutIndex);<br>                   scrapView(view);<br>                   vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP<br>                           | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);<br>                   return vh;<br>               &#125;<br>           &#125;<br>    //从mCachedViews去获取对应的ViewHolder<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cacheSize = mCachedViews.size();<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; cacheSize; i++) &#123;<br>               <span class="hljs-keyword">final</span> ViewHolder holder = mCachedViews.get(i);<br>               // invalid view holders may be in cache <span class="hljs-keyword">if</span> adapter has stable ids as they can be<br>               // retrieved via getScrapOrCachedViewForId<br>               <span class="hljs-keyword">if</span> (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) &#123;<br>                   <span class="hljs-keyword">if</span> (!dryRun) &#123;<br>                       mCachedViews.remove(i);<br>                   &#125;<br>                   <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>                       Log.d(TAG, "getScrapOrHiddenOrCachedHolderForPosition(" + position<br>                               + ") found match in cache: " + holder);<br>                   &#125;<br>                   return holder;<br>               &#125;<br>           &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据<code>position</code>从<code>mAttachedScrap -&gt; hideView -&gt; mCachedViews</code>的顺序向下获取。</p>
<p><strong>mCachedViews里面存放的都是已存在的ViewHolder，新位置的是没法获取的。</strong></p>
<p>②<code>validateViewHolderForOffsetPosition(holder)</code>：校验获取的ViewHolder是否有效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> validateViewHolderForOffsetPosition(ViewHolder holder) &#123;<br>    // <span class="hljs-keyword">if</span> it is a removed holder, nothing to verify since we cannot ask adapter anymore<br>    // <span class="hljs-keyword">if</span> it is not removed, verify the type and id.<br>    <span class="hljs-keyword">if</span> (holder.isRemoved()) &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; !mState.isPreLayout()) &#123;<br>            throw new IllegalStateException("should not receive a removed view unless it"<br>                    + " is pre layout");<br>        &#125;<br>        return mState.isPreLayout();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (holder.mPosition &lt; 0 || holder.mPosition &gt;= mAdapter.getItemCount()) &#123;<br>        throw new IndexOutOfBoundsException("Inconsistency detected. Invalid view holder "<br>                + "adapter position" + holder);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!mState.isPreLayout()) &#123;<br>        // don't check type <span class="hljs-keyword">if</span> it is pre-layout.<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> type = mAdapter.getItemViewType(holder.mPosition);<br>        <span class="hljs-keyword">if</span> (type != holder.getItemViewType()) &#123;<br>            return <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;<br>        return holder.getItemId() == mAdapter.getItemId(holder.mPosition);<br>    &#125;<br>    return <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>判断获取的ViewHolder存在和位置是否正确。</p>
<p>③<code>getScrapOrCachedViewForId()</code>：根据<code>position</code>获取对应的<code>itemId</code>然后获取ViewHolder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewHolder getScrapOrCachedViewForId(<span class="hljs-keyword">long</span> id, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">boolean</span> dryRun) &#123;<br>            // Look in our attached views first<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mAttachedScrap.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = count - 1; i &gt;= 0; i--) &#123;<br>                <span class="hljs-keyword">final</span> ViewHolder holder = mAttachedScrap.get(i);<br>                <span class="hljs-keyword">if</span> (holder.getItemId() == id &amp;&amp; !holder.wasReturnedFromScrap()) &#123;<br>                    <span class="hljs-keyword">if</span> (type == holder.getItemViewType()) &#123;<br>                        holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);<br>                        <span class="hljs-keyword">if</span> (holder.isRemoved()) &#123;<br>                            <span class="hljs-keyword">if</span> (!mState.isPreLayout()) &#123;<br>                                holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE<br>                                        | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED);<br>                            &#125;<br>                        &#125;<br>                        return holder;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dryRun) &#123;<br>                        mAttachedScrap.remove(i);<br>                        removeDetachedView(holder.itemView, <span class="hljs-keyword">false</span>);<br>                        quickRecycleScrapView(holder.itemView);<br>                    &#125;<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure>
<p>利用转化的<code>itemId</code>从<code>mAttachedScrap</code>获取对应的ViewHolder</p>
<p>④<code>getRecycledViewPool().getRecycledView()</code>：从<code>mRecyclerViewPool</code>去获取对应的ViewHolder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ViewHolder getRecycledView(<span class="hljs-keyword">int</span> viewType) &#123;<br>    <span class="hljs-keyword">final</span> ScrapData scrapData = mScrap.get(viewType);<br>    <span class="hljs-keyword">if</span> (scrapData != <span class="hljs-keyword">null</span> &amp;&amp; !scrapData.mScrapHeap.isEmpty()) &#123;<br>        <span class="hljs-keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;<br>        return scrapHeap.remove(scrapHeap.size() - 1);<br>    &#125;<br>    return <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>存储时会根据不同的<code>itemType</code>进行存储，然后取对应ViewHolder时，就不像前面获取ViewHodler需要通过<code>position或itemId</code>完整的匹配，只要找到对应<code>ViewType</code>并有值，直接取出最后一个ViewHolder缓存进行复用即可。</p>
<p>⑤<code>holder.resetInternal()</code>：对从<code>mRecyclerViewPool</code>取出的ViewHolder重新进行设置，变成一个全新的ViewHolder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> resetInternal() &#123;<br>    mFlags = 0;<br>    mPosition = NO_POSITION;<br>    mOldPosition = NO_POSITION;<br>    mItemId = NO_ID;<br>    mPreLayoutPosition = NO_POSITION;<br>    mIsRecyclableCount = 0;<br>    mShadowedHolder = <span class="hljs-keyword">null</span>;<br>    mShadowingHolder = <span class="hljs-keyword">null</span>;<br>    clearPayload();<br>    mWasImportantForAccessibilityBeforeHidden = View.IMPORTANT_FOR_ACCESSIBILITY_AUTO;<br>    mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET;<br>    clearNestedRecyclerViewIfNotNested(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于取出的ViewHolder进行了重新设置，所以后续就需要调用<code>bindViewHolder()</code>重新进行数据绑定</p>
<p>观察上述源码可知，复用机制简单分为以下几步：</p>
<ul>
<li>从<code>mAttachedScrap</code>或<code>mCachedViews</code>(<em>一级缓存</em>)去获取可复用的ViewHolder</li>
<li>如果没有找到可复用的ViewHolder，就会从<code>mViewacheExtension</code>(<em>二级缓存</em>)去获取可复用的ViewHolder。<code>如果用户没有定义就跳过这一级。</code></li>
<li>用户未定义货没有找到可复用的ViewHolder，就会从<code>mRecyclerPool</code>(<em>三级缓存</em>)去获取可复用的ViewHolder。<strong>这时需要调用<code>onBindViewHolder()</code></strong></li>
<li>从上面三步中都没有获取到，就只能自己调用<code>createViewHolder</code>(<em>四级缓存</em>)去重新创建一个ViewHolder以供使用，然后在调用<code>bindViewHolder()</code>绑定数据。最后调整<code>ViewHolder。itemView</code>的布局参数。</li>
<li>返回最终得到的ViewHolder。</li>
</ul>
{% fullimage /images/RecyclerView复用机制.png,RecyclerView复用机制,RecyclerView复用机制%}
<h4 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h4><blockquote>
<p>由<code>Recycler</code>进行View的回收</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> recycleView(View view) &#123;<br>    //传入对应的View 然后通过View获取ViewHolder<br>    ViewHolder holder = getChildViewHolderInt(view);<br>    //标记该View要移除<br>    <span class="hljs-keyword">if</span> (holder.isTmpDetached()) &#123;<br>        removeDetachedView(view, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    //该ViewHolder来自缓存可见的数组<br>    <span class="hljs-keyword">if</span> (holder.isScrap()) &#123;<br>        //清除缓存<br>        holder.unScrap();<br>    &#125; //holder来自缓存的不可见ViewHolder<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.wasReturnedFromScrap()) &#123;<br>        //清除缓存<br>        holder.clearReturnedFromScrapFlag();<br>    &#125;<br>    //开始回收流程<br>    recycleViewHolderInternal(holder);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>回收流程的真正执行逻辑是在<code>recyclerViewHolderInternal()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> recycleViewHolderInternal(ViewHolder holder) &#123;<br>    ...<br>    //noinspection unchecked<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> transientStatePreventsRecycling = holder<br>            .doesTransientStatePreventRecycling();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> forceRecycle = mAdapter != <span class="hljs-keyword">null</span><br>            &amp;&amp; transientStatePreventsRecycling<br>            &amp;&amp; mAdapter.onFailedToRecycleView(holder);<br>    <span class="hljs-keyword">boolean</span> cached = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> recycled = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; mCachedViews.contains(holder)) &#123;<br>        throw new IllegalArgumentException("cached view received recycle internal? "<br>                + holder);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (forceRecycle || holder.isRecyclable()) &#123;<br>        //要求缓存数量&gt;0，并且ViewHolder的标志是有效的额，且非REMOVED或UPDATE，进行缓存<br>        <span class="hljs-keyword">if</span> (mViewCacheMax &gt; 0 /*大小默认为2*/<br>                &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID<br>                        | ViewHolder.FLAG_REMOVED<br>                        | ViewHolder.FLAG_UPDATE<br>                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;<br>            // Retire oldest cached view<br>            <span class="hljs-keyword">int</span> cachedViewSize = mCachedViews.size();<br>            //mCacheViews已经满了，就把最前面缓存的ViewHolder放到RecyclerViewPool中<br>            <span class="hljs-keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123;<br>                //移除 mCachedViews的第一条缓存数据<br>                recycleCachedViewAt(0);①<br>                cachedViewSize--;<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> targetCacheIndex = cachedViewSize;<br>            <span class="hljs-keyword">if</span> (ALLOW_THREAD_GAP_WORK<br>                    &amp;&amp; cachedViewSize &gt; 0<br>                    &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123;<br>                // when adding the view, skip past most recently prefetched views<br>                <span class="hljs-keyword">int</span> cacheIndex = cachedViewSize - 1;<br>                <span class="hljs-keyword">while</span> (cacheIndex &gt;= 0) &#123;<br>                    <span class="hljs-keyword">int</span> cachedPos = mCachedViews.get(cacheIndex).mPosition;<br>                    //缓存的时候不能覆盖最近经常使用的缓存 利用LFU算法 -- 最少使用策略<br>                    <span class="hljs-keyword">if</span> (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    cacheIndex--;<br>                &#125;<br>                targetCacheIndex = cacheIndex + 1;<br>            &#125;<br>            //将最新的ViewHolder缓存数据插入到mCacheViews中复用<br>            mCachedViews.add(targetCacheIndex, holder);<br>            cached = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        //如果没有触发缓存的话 就放进RecyclerViewPool中<br>        <span class="hljs-keyword">if</span> (!cached) &#123;<br>            addViewHolderToRecycledViewPool(holder, <span class="hljs-keyword">true</span>);<br>            recycled = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // NOTE: A view can fail to be recycled when it is scrolled off <span class="hljs-keyword">while</span> an animation<br>        // runs. In <span class="hljs-keyword">this</span> <span class="hljs-keyword">case</span>, the item is eventually recycled by<br>        // ItemAnimatorRestoreListener#onAnimationFinished.<br><br>        // TODO: consider cancelling an animation when an item is removed scrollBy,<br>        // to return it to the pool faster<br>        <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>            Log.d(TAG, "trying to recycle a non-recycleable holder. Hopefully, it will "<br>                    + "re-visit here. We are still removing it from animation lists");<br>        &#125;<br>    &#125;<br>    // even <span class="hljs-keyword">if</span> the holder is not removed, we still call <span class="hljs-keyword">this</span> method so that it is removed<br>    // from view holder lists.<br>    mViewInfoStore.removeViewHolder(holder);<br>    <span class="hljs-keyword">if</span> (!cached &amp;&amp; !recycled &amp;&amp; transientStatePreventsRecycling) &#123;<br>        holder.mOwnerRecyclerView = <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>①<code>recycleCachedViewAt(0)</code>：移除<code>mCachedViews</code>中的第一条数据并放入到<code>mRecyclerViewPool</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> recycleCachedViewAt(<span class="hljs-keyword">int</span> cachedViewIndex) &#123;<br>    ViewHolder viewHolder = mCachedViews.get(cachedViewIndex);<br>    addViewHolderToRecycledViewPool(viewHolder, <span class="hljs-keyword">true</span>);<br>    mCachedViews.remove(cachedViewIndex);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>mRecyclerPool</code>是根据<code>itemType</code>进行缓存的，最大上限为5。</p>
<p>观察上述源码可知，回收机制步骤如下：<strong>回收机制是发生在 RecyclerView滚动时进行的。</strong></p>
<ul>
<li>在RecyclerView滑动时，会调用到<code>LayoutManager.scrollVerticalBy()</code>去处理，在<code>LayoutManager.fill()</code>中会去完成<code>复用以及回收ViewHolder</code>的功能，最终调用到<code>recyclerView()</code>开始回收工作</li>
<li>回收时，先判断<code>mCachedViews</code>是否已满，未满直接放入。如果<code>mCachedViews</code>已满，则取出第一个缓存的ViewHolder放入<code>RecyclerViewPool</code>中，然后放入新的ViewHolder进行缓存</li>
<li>如果因为<code>ViewHolder</code>设置了<code>REMOVED或UPDATED</code>标志，无法加入<code>mCacheViews</code>中，就直接放入到<code>mRecyclerPool</code>中。</li>
</ul>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView回收机制.png" srcset="/img/loading.gif" class="full-image" alt="RecyclerView回收机制" title="RecyclerView回收机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>1.RecyclerView的操作场景主要有三种：</p>
<ul>
<li><p><em>有无到有</em>：RecyclerView中没有任何数据，然后调用<code>setAdapter()</code>添加数据源后。RecyclerView添加了数据并显示。</p>
<blockquote>
<p><code>Recycler</code>在这时只是调用到<code>createViewHolder()</code>不会发生缓存事件。</p>
</blockquote>
</li>
<li><p><em>在原有数据的情况下刷新</em>：做了下拉刷新操作，只对屏幕上可见的数据源进行替换。</p>
<blockquote>
<p>这时ViewHolder会被标记<code>FLAG_TMP_DETACHED</code>，然后这时的Viewolder就会被保存到<code>mAttachedScrap</code>中等待复用。</p>
</blockquote>
</li>
<li><p><em>RecyclerView发生滑动</em>：RecyclerView发生了上下或者左右滑动操作。</p>
</li>
</ul>
<p>2.RecyclerView滑动场景下的回收复用涉及到的结构有以下两个：<code>mCachedViews</code>和<code>mRecyclerPool</code></p>
<p>  <code>mCachedViews</code>的优先级高于<code>mRecyclerPool</code>，回收时最新的ViewHolder先放入到<code>mCachedViews</code>中，没位置了就移除最旧的那个给新的腾地方，最旧的就放到<code>mRecyclerPool</code>中。</p>
<p>  复用时也是一样，先从<code>mCachedViews</code>去获取对应的ViewHolder，需要匹配<code>position</code>，就是需要位置对应才能进行复用。找不到就去<code>mRecyclerPool</code>中找，在<code>mRecyclerPool</code>中的ViewHolder都跟新的一样，需要重新绑定数据(<em>bindViewHolder()</em>)。还没有就要自己创建了(<em>createViewHolder()</em>)。</p>
<p>3.<code>mCachedViews</code>上限是2</p>
<h2 id="RecyclerView优化"><a href="#RecyclerView优化" class="headerlink" title="RecyclerView优化"></a>RecyclerView优化</h2><ul>
<li><p><strong>数据处理与视图绑定分离</strong></p>
<blockquote>
<p><code>bindViewHolder()</code>是在主线程中进行的，如果里面发生了耗时操作，会影响滑动的流畅性。</p>
<p><strong><code>onBindViewHolder()</code>中应该只进行数据的<code>set</code>操作，不需要做其他判断。</strong></p>
</blockquote>
</li>
<li><p><strong>数据优化</strong></p>
<blockquote>
<ol>
<li>分页加载远端数据，对拉取的数据进行缓存，提高二次加载的速度</li>
<li>对于新增或删除数据通过<code>DiffUtil</code>，来进行局部数据刷新，而不是每次都去进行全量刷新。</li>
</ol>
</blockquote>
</li>
<li><p><strong>布局优化</strong></p>
<blockquote>
<ol>
<li><code>减少过度绘制</code>：减少布局层级，可以考虑使用自定义View来减少层级，或者设置更合理的布局。</li>
<li><code>减少xml文件</code>：<code>inflate</code>时间：去解析xml都需要经过耗时的IO操作，可以利用代码直接生成对应的布局，利用<code>new View()</code>生成。</li>
<li><code>减少View对象的创建</code>：需要尽可能简化ItemView，对多ViewType能够共用的部分尽量设计成自定义View，减少View的构造和嵌套。</li>
</ol>
</blockquote>
</li>
<li><p><strong>其他优化</strong></p>
<blockquote>
<ol>
<li><p>设置高度固定：如果Item高度固定的话，可以使用<code>RecyclerView.setHasFixedSize(true)</code>，避免调用<code>requestLayout()</code></p>
</li>
<li><p>共用<code>RecycledViewPool</code>：具有相关的Adapter，就可以调用<code>RecyclerView.setRecycledViewPool(pool)</code>共用同一个。</p>
</li>
<li><p>加大RecyclerView的缓存：空间换时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;    recyclerView.setItemViewCacheSize(20);<br>&gt;    recyclerView.setDrawingCacheEnabled(<span class="hljs-keyword">true</span>);<br>&gt;    recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);<br>&gt;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li><p>增加RecyclerView预留的额外空间：显示范围之外，增加额外的缓存空间。<em>默认为2。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;    new LinearLayoutManager(<span class="hljs-keyword">this</span>) &#123;<br>&gt;        @Override<br>&gt;        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> getExtraLayoutSpace(RecyclerView.State state) &#123;<br>&gt;            return size;<br>&gt;        &#125;<br>&gt;    &#125;;<br>&gt;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li><p>减少ItemView监听器的创建</p>
<blockquote>
<p>不要对每个Item都去创建一个监听器，而是根据<code>android:id</code>设置不同的操作，共用一个监听器。</p>
</blockquote>
</li>
<li><p>优化滑动操作：设置<code>RecyclerView.addOnScrollListener()</code>在滑动过程中停止加载</p>
</li>
<li><p>关闭默认动画效果：设置<code>((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false)</code></p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="RecyclerView拓展"><a href="#RecyclerView拓展" class="headerlink" title="RecyclerView拓展"></a>RecyclerView拓展</h2><p>是否需要将ListView替换成RecyclerView?</p>
<blockquote>
<p>从性能上看，RecyclerView并没有带来明显的提升。如果需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView。只是单纯用于展示数据的话，ListView实现更加简单。</p>
</blockquote>
<h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://www.cnblogs.com/dasusu/p/7746946.html" target="_blank" rel="noopener">基于场景解析RecyclerView的回收复用机制原理</a></p>
<p><a href="https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA?" target="_blank" rel="noopener">RecyclerView必知必会</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/12/20/数据结构-红黑树/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构-红黑树</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/12/20/Android性能优化-总览/">
                        <span class="hidden-mobile">Android性能优化</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
