<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="HashMap定义HashMap是基于Map接口实现的一种键-值对&amp;lt;key,value&amp;gt;的存储结构。内部允许null值，同时非有序，非同步(线程不安全)。它存储和查找数据时，是根据key的hashcode计算出具体的存储位置。内部最多允许一条记录的key为null。 HashMap的底层实现是数组+链表+红黑树(Java 8新增的)。  数组是HashMap的主体  所以H">
<meta name="keywords" content="数据结构,Java源码">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构--HashMap实现原理及解析">
<meta property="og:url" content="http://yoursite.com/2018/05/09/HashMap实现原理及解析/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="HashMap定义HashMap是基于Map接口实现的一种键-值对&amp;lt;key,value&amp;gt;的存储结构。内部允许null值，同时非有序，非同步(线程不安全)。它存储和查找数据时，是根据key的hashcode计算出具体的存储位置。内部最多允许一条记录的key为null。 HashMap的底层实现是数组+链表+红黑树(Java 8新增的)。  数组是HashMap的主体  所以H">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/HashMap结构.png">
<meta property="og:image" content="http://yoursite.com/images/HashMap-put流程.png">
<meta property="og:image" content="http://yoursite.com/images/扩容前后对比.png">
<meta property="og:image" content="http://yoursite.com/images/HashMap扩容过程.png">
<meta property="og:image" content="http://yoursite.com/images/HashMap-get流程.png">
<meta property="og:updated_time" content="2019-03-14T02:49:07.143Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构--HashMap实现原理及解析">
<meta name="twitter:description" content="HashMap定义HashMap是基于Map接口实现的一种键-值对&amp;lt;key,value&amp;gt;的存储结构。内部允许null值，同时非有序，非同步(线程不安全)。它存储和查找数据时，是根据key的hashcode计算出具体的存储位置。内部最多允许一条记录的key为null。 HashMap的底层实现是数组+链表+红黑树(Java 8新增的)。  数组是HashMap的主体  所以H">
<meta name="twitter:image" content="http://yoursite.com/images/HashMap结构.png">






  <link rel="canonical" href="http://yoursite.com/2018/05/09/HashMap实现原理及解析/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>数据结构--HashMap实现原理及解析 | Wxy的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wxy的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">技术路上点滴</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/09/HashMap实现原理及解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leo-Wxy">
      <meta itemprop="description" content="如果我没有见过光明，那我本可以忍受黑暗">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wxy的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构--HashMap实现原理及解析

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-09 13:03:31" itemprop="dateCreated datePublished" datetime="2018-05-09T13:03:31+08:00">2018-05-09</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!--主要是对HashMap，ArrayMap，ConcurrentHashmap-->
<!-- HashMap和HashTable的区别 , HashMap和ConcurrentHashMap的区别，HashMap的底层源码,HashMap的原理,ConcurrentHashMap，ArrayMap,SparseArray,hashmap线程不安全，请问为什么线程不安全？答，并发时会成环。什么时候成环？比如我有两个数据要装入hashmap。hashset和hashmap的区别，写代码使用hashmap实现一个简单的hashset。-->
<!-- https://juejin.im/post/59e86f9351882521ad0f4147, https://juejin.im/post/5a7592f4f265da4e8d42ded2 -->
<!-- hashmap实现的数据结构，数组、桶等。hashmap的哈希冲突解决方法：拉链法等。拉链法的优缺点。hashmap的参数及影响性能的关键参数：加载因子和初始容量。Resize操作的过程。hashmap容量为2次幂的原因。hashtable线程安全、synchronized加锁。hashtable和hashmap异同。为什么hashtable被弃用？-->
<!--关于HashMap扩容，1.8之前，如果不发生Hash冲突不会触发扩容，1.8之后，只要HashMap中的元素个数大于阈值，就发生扩容。（欢迎纠正）expectedSize / 0.75F + 1.0F  equals 和 hashcode 关系,HashMap遍历原理-->
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HashMap结构.png" class="full-image" alt="HashMap基础结构" title="HashMap基础结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="HashMap定义"><a href="#HashMap定义" class="headerlink" title="HashMap定义"></a>HashMap定义</h2><p><code>HashMap</code>是基于<code>Map</code>接口实现的一种<code>键-值对&lt;key,value&gt;</code>的存储结构。内部允许<code>null</code>值，同时非有序，非同步(<em>线程不安全</em>)。它存储和查找数据时，是根据<code>key</code>的<code>hashcode</code>计算出具体的存储位置。内部最多允许一条记录的<code>key</code>为<code>null</code>。</p>
<p><code>HashMap</code>的底层实现是<strong>数组+链表+红黑树(Java 8新增的)</strong>。</p>
<ul>
<li><p>数组是HashMap的主体  <em>所以HashMap的容量指的就是 数组的长度。HashMap的size指的就为存储键值对数量。</em></p>
</li>
<li><p>链表主要为了解决<code>Hash冲突</code>而存在的</p>
<blockquote>
<p>常用解决Hash冲突的方法有四种：</p>
<ul>
<li><code>开放地址法--线性探测</code> ：一般是在散列函数的基础上采取另一种算法，从而找到下一个空的数组位置，再将新数据填充进去。从而有效利用原数组空间。<strong>若整个空间都找不到空余的地址，则产生溢出。</strong></li>
<li><code>链地址法（拉链法）</code>：基本思路是<code>全部具有同样哈希地址的而不同的Key的数据元素连接到同一个链表中</code>。加入在某个位置发生<code>Hash冲突</code>，就将新数据以链表的形式接在已有数据的后面。<strong>HashMap1.7 是头插法，冲突的数据放在链表前端；HashMap在1.8之后是尾插法，冲突的数据放在链表尾端。</strong><ul>
<li>优点：无堆积现象存在，平均查找长度较短；节点空间是动态申请的，适用于无法缺点表长的情况；装填因子较大时，拉链法中增加的指针空间可忽略不计；删除节点的操作易于实现。</li>
<li>缺点：指针需要额外的空间。</li>
</ul>
</li>
<li><code>再哈希法</code>：同时构造多个不同的hash函数，直到不出现冲突为止。</li>
<li><code>建立公共溢出区</code>：将哈希表分为两部分：基本表和溢出表。所有冲突的数据都放到溢出表中。</li>
</ul>
</blockquote>
</li>
<li><p>当链表长度大于阈值(<em>一般为8</em>)时，会转换成红黑树，减少搜索时间(<em>最坏时间复杂度为 $ O(nlogn) $</em>)</p>
</li>
</ul>
<h2 id="HashMap中的重要参数分析"><a href="#HashMap中的重要参数分析" class="headerlink" title="HashMap中的重要参数分析"></a>HashMap中的重要参数分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 初始容量 左移4位得到16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 最大容量</span></span><br></pre></td></tr></table></figure>
<p><code>capacity 容量</code>：必须是2的幂 并且小于 <code>MAXIMUM_CAPACITY</code>$2^{30}$。默认容量为16，如果不设置初始容量的话。</p>
<blockquote>
<p>为什么要转换为 $2^n$？</p>
<ul>
<li><code>可以提高取余的效率</code>。为了防止链表过长，要保证键值对在数组中尽可能均匀分布。确定元素位置的方法是通过<code>hash%length(table长度)</code>计算得出的。但是单纯的取余方式消耗相对较大，由于通过位运算<code>hash &amp; (length-1)</code>得到的结果是一样的。<strong>一个数对$ 2^n $取余，就是要去这个数二进制的最低n位。</strong></li>
<li><code>有利于提高计算元素存放位置的效率</code>。可以有效降低<code>Hash冲突</code>几率。</li>
</ul>
</blockquote>
<p><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 实际负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//默认负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold;<span class="comment">//扩容阈值 = 容量 * 负载因子</span></span><br></pre></td></tr></table></figure>
<p><code>loadFactor</code>：HashMap在其容量增加前可达到的最大负载。</p>
<blockquote>
<p><strong>LoadFactor取值范围为0~∞，当为0时会抛出IllegalArgumentException异常。</strong></p>
<p>主要分两种情况分析：</p>
<ul>
<li><code>loadFactory偏大</code>：则<code>HashMap</code>装载程度就会越高。意味着可以容纳更多的元素，空间利用率就会变高。但元素多了，发生<code>Hash冲突</code>的几率就会越大，从而链表会拉长，查询效率就会变低。</li>
<li><code>loadFactory偏小</code>：则<code>HashMap</code>装载程度就会变低，容纳的元素就会变少，空间利用率就会变低。但是发生<code>Hash冲突</code>的几率变低，并且链表长度也会较短，提高查询效率。由于会发生频繁的扩容操作，对性能也会有影响。</li>
</ul>
<p>合理的设置<code>loadFactory</code>：</p>
<ul>
<li>关心内存的话，采用<code>时间换空间策略</code>，适当的加大加载因子，牺牲查询速度，来换取更大的使用空间。</li>
<li>关心时间的话，采用<code>空间换时间策略</code>，适当的减小加载因子，从而提高查询性能，但需要考虑到频繁扩容带来的性能消耗。</li>
</ul>
</blockquote>
<p><code>threshold</code>：扩容阈值。当哈希表的大小 &gt;= 扩容阈值时，就会进行扩容操作。例如<code>capacity设置16，loadFactory设置0.75，则阈值为12。当存储元素个数&gt;12时，触发扩容。</code></p>
<blockquote>
<p>计算方式为<code>capacity * loadFactor</code>。</p>
<p><code>扩容</code>：对哈希表进行<code>resize</code>操作，扩大到原先的两倍表格大小。</p>
</blockquote>
<p><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">//桶的树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; <span class="comment">//桶的链表还原阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">//最小树形化容量阈值</span></span><br></pre></td></tr></table></figure>
<p><code>TREEIFY_THRESHOLD</code>：当链表长度大于该值时，链表就会转换成红黑树。</p>
<p><code>UNTREEIFY_THRESHOLD</code>：当红黑树节点小于该值时，红黑树会转换回聊表。发生在<code>resize()</code>扩容时。</p>
<p><code>MIN_TREEIFY_CAPACITY</code>：当哈希表中的容量大于该值时，才允许链表转换红黑树。</p>
<p><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;  <span class="comment">// 存储数据的Node类型 数组，长度 = 2的幂；数组的每个元素 = 1个单链表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;<span class="comment">// HashMap的大小，即 HashMap中存储的键值对的数量</span></span><br></pre></td></tr></table></figure>
<h2 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h2><h3 id="HashMap初始化"><a href="#HashMap初始化" class="headerlink" title="HashMap初始化"></a>HashMap初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  ...  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * capacity = initialCapacity , loadFactory = loadFactor</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始容量不得 &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +initialCapacity);</span><br><span class="line">        <span class="comment">//初始容量最大就是 MAXIMUM_CAPACITY    </span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//负载因子必须 &gt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//设置 扩容阈值</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * capacity = initialCapacity , loadFactory = 0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * capacity = 16 , loadFactory = 0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * capacity = 16 , loadFactory = 0.75</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        <span class="comment">//将传入的子Map中的数据逐个添加到 HashMap中</span></span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>在初始化<code>HashMap</code>中，只是进行了初始变量的赋值，还未进行<code>table</code>的设置</li>
<li><strong>真正初始化哈希表(table)是在第一次调用<code>put()</code>时。这个就是<code>lazy-load 懒加载</code>，直到被首次使用时，才会进行初始化。</strong></li>
</ol>
</blockquote>
<h3 id="HashMap插入数据-put"><a href="#HashMap插入数据-put" class="headerlink" title="HashMap插入数据 - put()"></a>HashMap插入数据 - put()</h3><blockquote>
<p>向<code>HashMap</code>中插入数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用示例</span></span><br><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"Android"</span>,<span class="string">"Best"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>put()</code> 源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>put()</code>中，实现分为了两步：</p>
<ul>
<li><p><code>hash()</code>：将<code>key</code>转化成<code>hash值</code>。通过<code>扰动函数</code>生成对应<code>hash值</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当<code>key==null</code>时，<code>hash值</code>为0 ，所以可以允许<code>key</code>设置为null，不过后续都会覆盖原值。</p>
<p>当<code>key!=null</code>时，先获取原key的<code>hashcode()</code>，然后对其进行扰动处理： 按位异或(^) 再自身右移16位。</p>
<blockquote>
<p>所有处理的根本目的：<strong>为了提高 存储键值对 的数组下标位置的随机性&amp;分布均匀性，尽量避免出现Hash冲突。</strong></p>
</blockquote>
</li>
<li><p><code>putVal()</code>：添加<code>key-value</code>的实际方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//记录当前的hash表</span></span><br><span class="line">  Node&lt;K,V&gt;[] tab; </span><br><span class="line">  <span class="comment">//记录当前的链表节点</span></span><br><span class="line">  Node&lt;K,V&gt; p; </span><br><span class="line">  <span class="comment">//n 记录hash表长度 i 记录当前操作的index</span></span><br><span class="line">  <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="comment">//tab 为空则创建</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 初始化hash表，并把初始化后的hash表长度值赋值给n</span></span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//通过hash &amp; (length -1 ) 确定最后的元素存储位置</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//计算得出位置没有元素存在，则新建节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当前位置已存在节点，可能是修改或者发生了Hash冲突</span></span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">//得到的Hash值相同 且 定义的key也相同 可以判定为修改操作</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//将结果赋值给 e</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 当前节点是树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//往红黑树结构中 插入新节点或者更新对应节点 如果是新增节点返回值为 null</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 当前节点为链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//遍历链表到尾端也没有找到对应key值相同节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//向尾端插入新节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果链表长度大于 阈值，就会转换成红黑树结构</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果链表中存在key相同且hash值相同的节点，则更新对应值</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发现对应的key，直接用新的value替换旧value，并返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//默认空实现，但是 LinkedHashMap有 实现该方法</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//当前存储的键值对大于 阈值 则进行扩容操作。</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="comment">//证明该操作为新增操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HashMap-put流程.png" class="full-image" alt="HashMap-put流程" title="HashMap-put流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>总结流程：</p>
<ol>
<li>先判断<code>Node&lt;K,V&gt;[] table</code>是否为空或者null，是则执行<code>resize()</code>进行扩容</li>
<li>根据插入的键值<code>key</code>的<code>hash值</code>，通过<code>(length-1) &amp; hash值</code>得到需要的存储位置<code>index</code>，如果该位置上没有数据，则直接新建节点插入该位置。</li>
<li>如果存储位置已有元素存在，就需要判断<code>index</code>上的元素的<code>hash值和key</code>是否和当前要操作的一致，一致则判定为<code>修改操作</code>，覆盖原元素的value即可</li>
<li>当前存储位置既有元素，并且<code>key</code>也不一致，则判定该位置发生了<code>hash冲突</code>。接下来去判断当前头节点是否为树节点(<em>红黑树</em>)，如果是就以红黑树的方式插入或修改节点。</li>
<li>如果头节点不是树节点，则为默认的链表节点，将新增节点直接插入至链表的尾端，然后继续判断当前链表的长度是否大于<code>TREEIFY_THRESHOLD-1</code>，大于则转化为<code>红黑树</code>。遍历过程中发现<code>key</code>已经存在，则直接覆盖<code>value</code>。</li>
<li>插入成功后，在判断当前存储的键值对数量是否大于 <code>threshold阈值</code>，大于则触发扩容<code>resize()</code>操作。</li>
</ol>
</li>
</ul>
<h3 id="HashMap扩容-resize"><a href="#HashMap扩容-resize" class="headerlink" title="HashMap扩容 - resize()"></a>HashMap扩容 - resize()</h3><h4 id="为什么需要扩容"><a href="#为什么需要扩容" class="headerlink" title="为什么需要扩容"></a>为什么需要扩容</h4><blockquote>
<p>当需要存储的数据量大于HashMap的初始容量时，就会造成部分数据出现在链表或红黑树上，性能比直接通过数组下表查询数据差很多，就需要扩容来减少此类数据，提供查询性能。</p>
</blockquote>
<h4 id="如何触发扩容"><a href="#如何触发扩容" class="headerlink" title="如何触发扩容"></a>如何触发扩容</h4><blockquote>
<ol>
<li><code>初始化哈希表</code>。上文分析<code>put()</code>时看到，如果哈希表为null或空，就会触发扩容进行哈希表初始化。</li>
<li><code>当前数组容量过小，需要进行扩容</code>。HashMap存储的键值对大于<code>threshold</code>时，会触发扩容。</li>
</ol>
</blockquote>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">//扩容操作前的数组</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">//扩容前的数组长度</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//扩容前的扩容阈值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">//新容量及新阈值初始</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//触发扩容的条件为  原数组容量过小</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//扩容前的数组长度已经达到最大值，则无法继续扩容</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//扩容后数组长度依然满足条件 则进行扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">//调整扩容阈值为原先2倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//触发扩容条件为 初始化哈希表</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123;               </span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算新的扩容阈值上限</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"uncheck ed"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        <span class="comment">//替换当前在用的数组</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将扩容前的数据迁移到新表中</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//数据是直接在数组上，直接进行赋值</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//数据在红黑树上，需要用红黑树的迁移方法</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; </span><br><span class="line">                        <span class="comment">//数据在链表上 进行链表结构的扩容</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//原索引</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//原索引 + oldcap</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//原索引值放到新数组中</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//原索引 + oldcap 放到新数组中</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构的扩容操作</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//bit 指向了 oldcap</span></span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//小于树还原阈值，就需要重新变回链表样式</span></span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>根据源码发现，扩容机制会在原基础上扩大两倍的容量进行存储。<em>扩容后就会把原先在链表以及红黑树上的数据，重新分配到新的数组上去。</em></p>
<p>由于我们使用的2次幂的扩展(<em>每次扩容为原大小的2倍</em>)，所以元素在扩容后数组的位置要不在原位置（<code>index</code>），要不就在原位置加上扩容前的数组长度(<code>index + olcCap</code>)。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/扩容前后对比.png" class="full-image" alt="扩容前后对比" title="扩容前后对比"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>简单的描述下，在链表上的数据如何进行扩容处理：</p>
<ul>
<li>遍历旧表，如果元素的next为空(<code>node.nect == null</code>)，直接取余后放入新数组</li>
<li>元素后面接了一个链表，那么需要新建两条链表，<code>hi链和lo链</code></li>
<li>开始遍历链表，计算每个元素的<code>hash值 &amp; oldcap</code>的值，如果为0则插入<code>lo链末端</code>，不为0则插入<code>hi链末端</code></li>
<li>遍历完成后，将两条链的头节点放入新数组中。<code>iohead</code>放入原来的位置，<code>hihead</code>放入原位置加上<code>oldcap</code>处。</li>
</ul>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HashMap扩容过程.png" class="full-image" alt="HashMap扩容过程" title="HashMap扩容过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p> 扩容后的元素移动方式就是<strong>要不在原位置，要不就是原位置加上旧容量值的位置。</strong> </p>
</blockquote>
<h3 id="HashMap获取数据-get"><a href="#HashMap获取数据-get" class="headerlink" title="HashMap获取数据 - get()"></a>HashMap获取数据 - get()</h3><blockquote>
<p>从HashMap获取数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.get(<span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>get()</code>源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据计算出的Hash值 去获取对应结果</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录当前的hash表</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">//first 记录对应hash位置的第一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; first, e; </span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//判断当前元素的存储位置是否有元素存在</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//头结点的hash值和要获取key的hash值相同 且 key相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//返回头结点</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//数组中不存在相等节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当前位置结构是 红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//当前位置结构是 链表</span></span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 遍历单链表，逐一比较链表节点，链表节点的hash值与key的hash值相等，并且key也相等</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">//返回对应节点</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过上述方式都没找到 就返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HashMap-get流程.png" class="full-image" alt="HashMap-get流程" title="HashMap-get流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>总结流程：</p>
<ul>
<li>先调用<code>key.hashcode ^ (h&gt;&gt;&gt;16)</code>计算出<code>key</code>的<code>hash值</code></li>
<li>根据计算出的<code>hash值</code>，通过<code>(length-1) &amp; hash值</code>计算出存储位置<code>table[i]</code>，判断位置上是否有元素存在</li>
<li>存储位置上没有元素存在，则直接返回null。</li>
<li>存储位置上存在元素，首先比较头节点(<code>头节点在数组上</code>)，如果头节点的<code>key hash值</code>和要获取<code>key hash值</code>相同并且<code>first.key == key</code>，则返回该位置的头节点。</li>
<li>头节点元素不是要找的元素，就需要判定头节点的结构</li>
<li>头节点结构为 红黑树 (<code>first instanceof TreeNode</code>)，按照红黑树的方式遍历查找节点，有就返回，没有返回null</li>
<li>头节点结构为 链表(<code>first instanceof Node</code>)，遍历单链表，逐一进行比较，当链表节点的<code>key hash值</code>和要获取<code>key hash值</code>相同并且<code>first.key == key</code>，则返回该节点；遍历结束都没找到，就返回null。</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="HashMap和HashTable以及HashSet的区别"><a href="#HashMap和HashTable以及HashSet的区别" class="headerlink" title="HashMap和HashTable以及HashSet的区别"></a>HashMap和HashTable以及HashSet的区别</h3><blockquote>
<p>HashMap</p>
<ul>
<li><p>基于<code>AbstractMap</code>类，实现<code>Map、Cloneable(被克隆)、Serializable(序列化)</code>接口</p>
</li>
<li><p>HashMap的<code>key,value</code>都可以为<code>null</code>，<code>HashMap</code>遇到<code>key == null</code>时，数据会放在<code>table[0]</code>上</p>
</li>
<li>HashMap初始容量为16，负载因子默认0.75,并且容器长度一定是2次幂。扩容时，也已2倍大小进行扩容。</li>
<li>HashMap是先将<code>key</code>经过<code>key.hashcode() ^ (h&gt;&gt;&gt;16)</code>计算出<code>hash值</code>，在拿<code>hash值</code>经过<code>hash &amp; (length -1 )</code>得到最终存储位置</li>
<li>HashMap不是线程安全，如果想线程安全，可以通过<code>Collections.synchronizedMap()</code>包裹HashMap，实质上是对HashMap的所有操作加了锁(<em>用synchronized进行修饰</em>)。导致运行效率下降，推荐使用<code>ConcurrentHashMap</code>。</li>
</ul>
</blockquote>
<p><br></p>
<blockquote>
<p>HashTable</p>
<ul>
<li><p>基于<code>Map</code>接口和<code>Dictionry</code>类</p>
</li>
<li><p>HashTable的<code>key,value</code>不允许为<code>null</code>，如果<code>key ==null</code>，抛出空指针异常</p>
</li>
<li>HashTable初始容量为11，负载因子默认0.75，扩容时是以原容量的两倍加1进行扩容，即<code>newCap = (oldCap &lt;&lt; 1)+1</code></li>
<li>HashTable用的是除留余数法计算存储位置的.<code>int index = (hash &amp; 0x7FFFFFFF) % tab.length</code></li>
<li>HashTable是线程安全的，每个操作方法都用<code>synchronized</code>进行修饰保证同步，运行效率低，建议使用<code>ConcurrentHashMap</code>替换。</li>
</ul>
</blockquote>
<p><br></p>
<blockquote>
<p>HashSet</p>
<ul>
<li>实现了Set接口</li>
<li>由于HashSet底层由HashMap实现，所以扩容机制与HashMap相同</li>
<li>HashSet只能存储对象，无法存储键值对。利用<code>add(E e)</code>插入对象，实质使用的是<code>HashMap.put(e,new Object())</code>进行操作。</li>
<li>HashSet和HashMap一样是线程不安全的。</li>
</ul>
</blockquote>
<h3 id="HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？"><a href="#HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？" class="headerlink" title="HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？"></a>HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？</h3><p>HashMap不是线程安全的，如果多个线程同时对 HashMap 进行数据更改的话，会导致数据不一致或者数据污染甚至数据丢失。</p>
<p>当出现线程不安全的操作时，HashMap尽可能抛出<code>ConcurrentModificationException</code>异常。</p>
<ul>
<li>当我们在对HashMap进行遍历时，如果在遍历期间我们对HashMap进行<code>put()、remove()</code>操作，会导致<code>modCount</code>发生变化(<code>exceptedModCount != modCount</code>)，然后抛出<code>ConcurrentModificationException</code>异常，这就是<strong><code>fail-fast快速失败</code></strong>机制。</li>
<li>由于存在扩容机制，多线程操作HashMap时，调用<code>resize()</code>进行扩容可能会导致死循环的发生。</li>
</ul>
<p>如果想要线程安全，还是推荐使用<code>ConcurrentHashMap</code>。</p>
<h3 id="使用HashMap时，使用什么对象作为key比较好？"><a href="#使用HashMap时，使用什么对象作为key比较好？" class="headerlink" title="使用HashMap时，使用什么对象作为key比较好？"></a>使用HashMap时，使用什么对象作为key比较好？</h3><p><strong>最好选择不可变对象作为key，因为为了计算<code>hashcode()</code>，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode，就会导致无法正确的找到对象。</strong></p>
<p><code>String和Interger</code>等包装类就很适合作为key，而且<code>String</code>最常用。因为<code>String</code>是不可变的且<code>final</code>修饰(<em>保证key的不可更改性</em>)，并且已经重写了<code>equals()和hashcode()</code>方法(<em>不容易出现hash值的计算错误</em>)。</p>
<p>不可变性还有其他的优点例如<code>线程安全</code>。</p>
<h3 id="如何使用自定义对象作为key？"><a href="#如何使用自定义对象作为key？" class="headerlink" title="如何使用自定义对象作为key？"></a>如何使用自定义对象作为key？</h3><p>HashMap的<code>key</code>可以是任何类型的对象，只要它遵守了<code>equals()和hashCode()</code>的定义规则，并且当对象插入到Map之后将不再会改变了。如果这个自定义对象是不可变的，那么它已经满足了作为键的条件。</p>
<blockquote>
<p><code>hashcode()</code>和<code>equals()</code>都是用来对比两个对象是否相等一致。</p>
<p>由于重写的<code>equals()</code>内部逻辑一般比较全面和复杂，效率就会比较低。利用<code>hashCode()</code>进行对比，只要生成一个对应的<code>hash值</code>就可以了，然后比较两者的<code>hash值</code>是否相同，不同肯定不相等。比较效率较高。</p>
<p>但是如果<code>hash值</code>相同的话，可能会有两个情况：</p>
<ol>
<li>他们真的是相同对象</li>
<li>由于hash的计算过程导致可能生成相同的<code>hash值</code>。</li>
</ol>
<p>这个时候就需要用到<code>equals()</code>去进行比较。</p>
<p>在改写<code>equals()</code>时，需要满足以下3点：</p>
<ul>
<li>自反性：a.equals(a) 必须为 true</li>
<li>对称性：<code>a.equals(b)</code>为true，则<code>b.equals(a)</code>必须成立</li>
<li>传递性：<code>a.equals(b)</code>为true，并且<code>b.equals(c)</code>也为true，那么<code>a.equals(c)</code>也为true。</li>
</ul>
<p><strong>每当需要对比的时候，首先用<code>hashCode()</code>进行比较，如果<code>hashCode()</code>不一样肯定不相等，就不需要调用<code>equals()</code>继续比较。如果<code>hashCode()</code>相同，再调用<code>equals()</code>继续比较，大大提高了效率也保证了数据的准确。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> userId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            User user = (User) o;</span><br><span class="line">            <span class="keyword">return</span> userId == user.userId &amp;&amp;</span><br><span class="line">                    Objects.equals(name, user.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设定userid为hashcode</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> userId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMap3</span><span class="params">(Map&lt;String,String&gt; map)</span></span>&#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : set) &#123;</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMap4</span><span class="params">(Map&lt;String,String&gt; map)</span></span>&#123;</span><br><span class="line">    Set&lt;String&gt; set = map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String entry : set) &#123;</span><br><span class="line">    String value = map.get(entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5c8910286fb9a049ad77e9a3" target="_blank" rel="noopener">深入接触HashMap线程安全性问题</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

  
    <div>


    
<div style="text-align:center;color: #ccc;font-size:14px;">
------ 本文结束<i class="fa fa-heart"></i>感谢您的阅读 ------</div>

<div>    
 
 
    <ul class="post-copyright">
      <li class="post-copyright-author">
          <strong>本文作者：</strong> Leo-Wxy
      </li>
      <li class="post-copyright-link">
        <strong>本文链接：</strong>
        <a href="/2018/05/09/HashMap实现原理及解析/" title="数据结构--HashMap实现原理及解析">2018/05/09/HashMap实现原理及解析/</a>
      </li>
      <li class="post-copyright-license">
        <strong>版权声明： </strong>
        本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！
      </li>
    </ul>
  
</div>

</div>
  

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
            <a href="/tags/Java源码/" rel="tag"># Java源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/04/JVM相关及其拓展-四/" rel="next" title="JVM相关及其拓展(四) -- 垃圾收集器与内存分配策略">
                <i class="fa fa-chevron-left"></i> JVM相关及其拓展(四) -- 垃圾收集器与内存分配策略
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/09/JVM相关及其拓展-五/" rel="prev" title="JVM相关及其拓展(五) -- Java内存模型">
                JVM相关及其拓展(五) -- Java内存模型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Leo-Wxy">
            
              <p class="site-author-name" itemprop="name">Leo-Wxy</p>
              <p class="site-description motion-element" itemprop="description">如果我没有见过光明，那我本可以忍受黑暗</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">115</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/leo-wxy" title="GitHub &rarr; https://github.com/leo-wxy" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/xy.wang.android@gmail.com" title="G-Mail &rarr; xy.wang.android@gmail.com"><i class="fa fa-fw fa-globe"></i>G-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap定义"><span class="nav-text">HashMap定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap中的重要参数分析"><span class="nav-text">HashMap中的重要参数分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap源码解析"><span class="nav-text">HashMap源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap初始化"><span class="nav-text">HashMap初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap插入数据-put"><span class="nav-text">HashMap插入数据 - put()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap扩容-resize"><span class="nav-text">HashMap扩容 - resize()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么需要扩容"><span class="nav-text">为什么需要扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何触发扩容"><span class="nav-text">如何触发扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码解析"><span class="nav-text">源码解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap获取数据-get"><span class="nav-text">HashMap获取数据 - get()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓展"><span class="nav-text">拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap和HashTable以及HashSet的区别"><span class="nav-text">HashMap和HashTable以及HashSet的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？"><span class="nav-text">HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用HashMap时，使用什么对象作为key比较好？"><span class="nav-text">使用HashMap时，使用什么对象作为key比较好？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用自定义对象作为key？"><span class="nav-text">如何使用自定义对象作为key？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap遍历"><span class="nav-text">HashMap遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内容引用"><span class="nav-text">内容引用</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo-Wxy</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.7.0</div>




        







        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  


  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow: auto hidden;
}
</style>

    
  


  

  

  

  

  

  

  

  

</body>
</html>
