<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Android-线程池 ThreadPool 专题详解 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/dracula.min.css">


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">



<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                Android-线程池 ThreadPool 专题详解
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2018-05-31 12:35">
                    2018年5月31日 下午
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    5k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    64
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h2 id="线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？"><a href="#线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？" class="headerlink" title="线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？"></a>线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？</h2><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/线程池_ThreadPool.png" srcset="/img/loading.gif" class="full-image" alt="线程池脑图" title="线程池脑图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li><strong>线程</strong>：进程中负责执行的执行单元，一个进程中至少有一个线程,<strong>操作系统能够进行调度的最小单位</strong></li>
<li><strong>进程</strong>：一个执行中的程序的实例</li>
<li><strong>多线程</strong>：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU确定，因此多线程具有不确定性</li>
<li><strong>线程池</strong>： 基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象回归池中，避免反复创建线程对象所带来的性能开销，节省系统资源。</li>
</ul>
<h3 id="1-线程池的概念"><a href="#1-线程池的概念" class="headerlink" title="1. 线程池的概念"></a>1. 线程池的概念</h3><p>在执行一个异步任务或并发任务时，往往会通过<code>new Thread()</code>方法去开启一个子线程去执行任务，等到子线程操作完成后在利用<code>Handler</code>切换至主线程。但是利用这种方法我们无法对自己创建的子线程进行有效的管理，然后由于过多的创建子进程，他们之间相互竞争会导致资源的过度占用。线程池的出现就是为了来对子进程进行管理。</p>
<h3 id="2-线程池的实现原理"><a href="#2-线程池的实现原理" class="headerlink" title="2. 线程池的实现原理"></a>2. 线程池的实现原理</h3><p><code>Executors</code>提供了基础的四类线程池方法，最终都是通过<code>ThreadPoolExecutor</code>类完成。对于这个类的描述<code>他维护了一个线程池，对于提交Executor中的任务，不是创建新的线程而是使用池内的线程来执行任务。可以显著减少对于任务执行的开销。</code></p>
<ol>
<li><p>ThreadPoolExecutor构造函数介绍</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,
                              <span class="hljs-keyword">int</span> maximumPoolSize,
                              <span class="hljs-keyword">long</span> keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)</span></span></code></pre></div>
<p>参数介绍：</p>
<ul>
<li><p><strong><code>corePoolSize 核心线程数</code></strong> 表示线程池中的基本线程数量即核心线程数量。一般情况下核心线程会一直存活在线程池中，即便他们处于闲置状态。只有在<code>ThreadPoolExecutor的allowCoreThreadTimeOut设置为true</code>的时候，会有一个超时策略（超过设置好的超时时间，闲置的核心线程会被终止）。<strong>当创建的线程数小于corePoolSize时，不管有没有空闲线程都会创建新的线程</strong>。</p>
</li>
<li><p><strong><code>maximumPoolSize 最大线程数</code></strong>  表示线程池中允许的最大创建线程数，当活动的线程数达到数值后，后续新任务会被阻塞。<strong>使用有界队列时，未达到该值则会创建新的线程，使用无界队列时该值无效。</strong></p>
</li>
<li><p><strong><code>keepAliveTime 非核心线程闲置时的超时时长</code></strong> 表示空闲非核心线程的最大存活时间，一旦超过即被销毁。<strong>当<code>ThreadPoolExecutor的allowCoreThreadTimeOut设置为true</code>的时候，该参数也可作用于核心线程</strong></p>
</li>
<li><p><strong><code>unit 存活时间的时间单位</code></strong> 用于指定keepAliveTime参数的时间单位，为一个枚举类型。包含下列参数：<code>NANOSECONDS（纳秒）</code>,<code>MICROSECONDS（微秒）</code>,<code>MILLSECONDS（毫秒）</code>,<code>SECONDS（）秒</code>,<code>MINUTES（分）</code>,<code>HOURS（时）</code>,<code>DAYS（天）</code></p>
</li>
<li><p><strong><code>workQueue 线程池中的任务队列</code></strong> 该队列是<code>java.util.BlockingQueue&lt;E&gt;</code>的一个实例，是一种阻塞队列用来存放等待执行的任务。通过<code>execute()</code>方法将提交的Runnable对象存储进去。根据具体实现类的不同可以分为以下三种队列策略：</p>
<ul>
<li><code>容量为0即直接提交策略--SynchronousQueue</code>：等待队列容量为0 ，所有需要阻塞的任务必须等待池内的某个线程有空闲才可以继续执行，否则阻塞。<code>CachedThreadPool</code>使用该队列策略。</li>
<li><code>容量无限即无界队列策略--LinkedBlockingQueue</code>：等待队列的长度无穷大，在这种策略下不会出现多余corePoolSize的线程被创建，所以maximumPoolSize以及handler无效，因为不存在队列满的情况。不过也有缺点：<strong>线程的执行速度会比提交速度慢，会导致无界队列快速增长，直到系统资源耗尽。</strong><code>fixedThreadPool</code>采用了这种队列策略。</li>
<li><code>容量有限即有界队列策略--指定了容量的任何BlockingQueue</code>：等待队列的长度为限制长度，指定了容量后可以<strong>防止过多的资源被消耗</strong>。 </li>
</ul>
</li>
<li><p><strong><code>threadFactory 线程工厂</code></strong>：是一个接口可以为线程池提供新线程的创建。由同一个threadFactory创建的线程同属于一个ThreadGroup，优先级都为Thread.NORM_PRIORITY，以及为非进程守护状态。默认都是采用<code>Executors.defaultThreadFactory()</code>返回值。</p>
</li>
<li><p><strong><code>handler 拒绝策略</code></strong>：当<strong>使用有界队列时且队列任务被填满后并且线程数也达到了最大值，就会触发拒绝策略</strong>。如果任务被拒绝执行，则会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法，默认调用<code>AbortPolicy</code>拒绝策略，也可以由用户自定义。JDK中定义了4种拒绝策略：</p>
<ul>
<li><p><code>AbortPolicy</code><strong>处理程序遭到拒绝则直接抛出<code>RejectedExecutionException</code>异常然后丢弃该任务。</strong></p>
<p>实现源码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;
       <span class="hljs-comment">/**
        * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.
        */</span>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;
           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">"Task "</span> + r.toString() +
                                                <span class="hljs-string">" rejected from "</span> +
                                                e.toString());
       &#125;
   &#125;</code></pre></div>
<p>样例演示：</p>
<div class="hljs"><pre><code class="hljs java"> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;

        TestRunnable(<span class="hljs-keyword">int</span> id) &#123;
            <span class="hljs-keyword">this</span>.id = id;
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
            System.err.println(Thread.currentThread().getName()+<span class="hljs-string">" 当前线程id="</span>+ <span class="hljs-keyword">this</span>.id);
            <span class="hljs-keyword">try</span> &#123;
                Thread.sleep(<span class="hljs-number">1000</span>);
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abortPolicyDemo</span><span class="hljs-params">()</span> </span>&#123;
        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(
                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());

        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));
        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">2</span>));
        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">3</span>));
        threadPoolExecutor.shutdown();
    &#125;

运行结果：添加进程时直接抛出异常但是没有影响后续的进行
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span>
Exception in thread <span class="hljs-string">"main"</span> java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@<span class="hljs-number">4</span>b1210ee rejected from java.util.concurrent.ThreadPoolExecutor@<span class="hljs-number">4</span>d7e1886[Running, pool size = <span class="hljs-number">1</span>, active threads = <span class="hljs-number">1</span>, queued tasks = <span class="hljs-number">1</span>, completed tasks = <span class="hljs-number">0</span>]
    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="hljs-number">2047</span>)
    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="hljs-number">823</span>)
    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="hljs-number">1369</span>)
    at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:<span class="hljs-number">112</span>)
    at threadpool.ThreadPoolDemo.abortPolicyDemo(ThreadPoolDemo.java:<span class="hljs-number">140</span>)
    at threadpool.ThreadPoolDemo.main(ThreadPoolDemo.java:<span class="hljs-number">13</span>)
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span></code></pre></div>
</li>
<li><p><code>CallerRunsPolicy</code><strong>在调用<code>execute</code>方法的调用者所在线程来执行被拒绝的任务，提供简单的反馈控制机制，可以减缓新任务的提交速度。</strong></p>
<p>实现源码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;
        <span class="hljs-comment">/**
         * Creates a &#123;<span class="hljs-doctag">@code</span> CallerRunsPolicy&#125;.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CallerRunsPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;
            <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;
                r.run();
            &#125;
        &#125;
    &#125;</code></pre></div>
<p>样例演示：</p>
<div class="hljs"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callerRunsPolicyDemo</span><span class="hljs-params">()</span></span>&#123;
        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(
                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());

        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));
        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">2</span>));
        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">3</span>));
        threadPoolExecutor.shutdown();
    &#125;

运行结果：task2执行在了主线程，由于被拒绝执行所以在调用者线程执行了任务
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span>
main 当前线程id=<span class="hljs-number">3</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span></code></pre></div>
</li>
<li><p><code>DiscardPolicy</code><strong>被拒绝即无法执行的任务被直接删除</strong></p>
<p>实现源码：   </p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;
              <span class="hljs-comment">/**
               * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardPolicy&#125;.
               */</span>
              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;
              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;
              &#125;
          &#125;</code></pre></div>
<p>样例演示：</p>
<div class="hljs"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discardPolicyDemo</span><span class="hljs-params">()</span></span>&#123;
        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(
                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy());

        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));
        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">2</span>));
        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">3</span>));
        threadPoolExecutor.shutdown();
    &#125;

运行结果：由于被拒绝执行在该策略下被直接抛弃
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span></code></pre></div>
</li>
<li><p><code>DiscardOldestPolicy</code><strong>判断线程池是否被关闭，没有则丢弃最老的一个请求，再尝试提交当前任务。</strong></p>
<p>实现源码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;
             <span class="hljs-comment">/**
              * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.
              */</span>
             <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardOldestPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;
             <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;
                 <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;
                     e.getQueue().poll();
                     e.execute(r);
                 &#125;
             &#125;
         &#125;</code></pre></div>
<p>样例演示：</p>
<div class="hljs"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discardOldestPolicyDemo</span><span class="hljs-params">()</span></span>&#123;
        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(
                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());

        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));
        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">2</span>));
        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">3</span>));
        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">4</span>));
        threadPoolExecutor.shutdown();
    &#125;

运行结果：???
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">4</span></code></pre></div>
</li>
<li><p><code>CustomRejectPolicy 自定义拒绝策略</code><strong>可以用来记录运行日志或者记录无法处理的任务</strong></p>
<p>样例演示：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**
* 自定义拒绝策略，实现RejectedExecutionHandler接口即可
*/</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomRejectedPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span></span>&#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;
            <span class="hljs-keyword">if</span> (!executor.isShutdown())&#123;
                    System.err.println(<span class="hljs-string">"自定义异常日志记录:  "</span>+  r.toString());
            &#125;
        &#125;
    &#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customPolicyDemo</span><span class="hljs-params">()</span></span>&#123;
        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(
                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> CustomRejectedPolicy());

    <span class="hljs-comment">//使用execute是因为使用submit时会被封装成RunnableFuture对象</span>
        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));
        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">2</span>));
        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">3</span>));
        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">4</span>));

        threadPoolExecutor.shutdown();
    &#125;

运行结果：由于<span class="hljs-number">4</span>号被拒绝，记录日志
自定义异常日志记录:  java.util.concurrent.FutureTask@<span class="hljs-number">4</span>b1210ee
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">3</span></code></pre></div>
</li>
<li><p>额外参数扩展 <code>allowCoreThreadTimeOut 允许核心线程过期</code>默认值为false（线程池已不被使用，但是其中还有活着的线程，则该线程池无法被回收，会造成内存泄露）。所以用户可以显式调用<code>shutDown()</code>或者该值设置为true，则会被回收。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ThreadPoolExecutor的使用</p>
<p>向线程池提交一个任务的方式有两种：</p>
<ul>
<li><p><code>execute</code>：这种方法提交任务，是没有返回值的即无法判断在线程池中是否完成该任务</p>
<div class="hljs"><pre><code class="hljs java">threadPoolExecutor.execute(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));</code></pre></div>
</li>
<li><p><code>submit</code>：使用<code>submit</code>方法提交任务时，会返回一个future，可以通过这个future来判断任务是否执行成功也可以根据<code>future的get()</code>方法获取返回值。<strong>若子线程任务没完成，<code>get()</code>方法会阻塞直到任务完成，若使用<code>get(long timeout,TimeUnit unit)</code>则会阻塞一段时间后返回，可能尚未完成任务。</strong></p>
<div class="hljs"><pre><code class="hljs java">Future&lt;Integer&gt; future = fixedThreadPool.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;
     
               <span class="hljs-meta">@Override</span>
               <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                   System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" , index = "</span> + index);
                   <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
               &#125;
           &#125;);
     
           <span class="hljs-keyword">try</span> &#123;
               System.err.println(<span class="hljs-string">"Future return :"</span> + future.get().toString());
           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
               e.printStackTrace();
           &#125;</code></pre></div>
</li>
</ul>
</li>
<li><p>线程池的关闭</p>
<p>线程池关闭方法有两种：</p>
<ul>
<li><p><code>shutdown()</code>：将线程池的状态置为SHUTDOWN状态，然后中断没有正在执行的线程。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;
        mainLock.lock();
        <span class="hljs-keyword">try</span> &#123;
            checkShutdownAccess();
            advanceRunState(SHUTDOWN);
            interruptIdleWorkers();
            onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span>
        &#125; <span class="hljs-keyword">finally</span> &#123;
            mainLock.unlock();
        &#125;
        tryTerminate();
    &#125;</code></pre></div>
</li>
<li><p><code>shutdownNow()</code>：将线程池的状态设为STOP状态，中断所有任务包括执行中的线程，并返回等待执行的任务列表。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;
        List&lt;Runnable&gt; tasks;
        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;
        mainLock.lock();
        <span class="hljs-keyword">try</span> &#123;
            checkShutdownAccess();
            advanceRunState(STOP);
            interruptWorkers();
            tasks = drainQueue();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            mainLock.unlock();
        &#125;
        tryTerminate();
        <span class="hljs-keyword">return</span> tasks;
    &#125;</code></pre></div>
<p>中断线程需要采用<code>interrput</code>方法，<strong>无法响应中断的任务可能永远无法终止。</strong></p>
<p>当需要立即中断所有线程并且不在乎任务是否执行完成时，可以使用<code>shutdownNow</code>方法。</p>
</li>
</ul>
</li>
<li><p>线程池的拓展</p>
<p><code>ThreadPoolExecutor</code>默认提供三个空方法，可以通过重写这三个方法来监控线程池。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//任务执行前 记录任务开始前时间</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> </span>&#123; &#125;
<span class="hljs-comment">//任务执行后 记录任务结束时间</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> </span>&#123; &#125;
<span class="hljs-comment">//线程池关闭 记录线程池关闭事件以及执行过的线程数量</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">terminated</span><span class="hljs-params">()</span> </span>&#123; &#125;</code></pre></div>
<p>样例演示：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span></span>&#123;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;
            <span class="hljs-keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> </span>&#123;
            <span class="hljs-keyword">super</span>.beforeExecute(t, r);
            System.err.println(<span class="hljs-string">"beforeExecute"</span>+r.toString());
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> </span>&#123;
            <span class="hljs-keyword">super</span>.afterExecute(r, t);
            System.err.println(<span class="hljs-string">"afterExecute"</span>+r.toString());
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">terminated</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">super</span>.terminated();
            System.err.println(<span class="hljs-string">"线程关闭"</span>);
        &#125;
    &#125;</code></pre></div>
</li>
</ol>
<h3 id="3-为什么要使用线程池"><a href="#3-为什么要使用线程池" class="headerlink" title="3. 为什么要使用线程池"></a>3. 为什么要使用线程池</h3><ul>
<li><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li><strong>提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就可以立即执行</li>
<li><strong>提高线程的可管理性。</strong>线程是稀缺资源，大量创建会导致系统资源过度消耗且会降低系统的稳定性，线程池可以有效控制线程数，并进行统一的分配、调优和监控。</li>
</ul>
<h3 id="4-线程池的分类以及各自的特性"><a href="#4-线程池的分类以及各自的特性" class="headerlink" title="4. 线程池的分类以及各自的特性"></a>4. 线程池的分类以及各自的特性</h3><p>利用<code>Executors</code>类提供了四种不同的线程池，他们都是直接或者间接配置<code>ThreadPoolExecutor</code>来实现功能。下面分别介绍着四个线程池</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><code>newFixedThreadPool</code></h4><blockquote>
<p>创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就不会发生变化，如果某个线程因为异常而结束，则会补充一个新进程。</p>
<p>由于只设置核心线程大小，所以可以<strong>更快的响应外界请求</strong></p>
<p>线程池的大小设置，可以使用<code>Runtime.getRuntime().availableProcessors()</code></p>
</blockquote>
<ul>
<li><p>实现源码</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**
* 设置了核心线程，并且没有超时机制，使用LinkedBlockingQueue则任务队列大小是无上限的
*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,
                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,
                                      <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());
    &#125;</code></pre></div>
</li>
<li><p>样例演示</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fixedThreadPoolDemo</span><span class="hljs-params">()</span></span>&#123;
        ExecutorService fixedThreadPool= Executors.newFixedThreadPool(<span class="hljs-number">3</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">6</span> ; i++) &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index=i;
            fixedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                    System.err.println(Thread.currentThread().getName()+<span class="hljs-string">" , index = "</span>+index);
                &#125;
            &#125;);

            <span class="hljs-keyword">try</span>&#123;
                Thread.sleep(<span class="hljs-number">1000</span>);
            &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

运行结果：整个过程都在pool-<span class="hljs-number">1</span>的线程池中运行,然后复用线程
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">0</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> , index = <span class="hljs-number">1</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> , index = <span class="hljs-number">2</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">3</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> , index = <span class="hljs-number">4</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> , index = <span class="hljs-number">5</span></code></pre></div>
</li>
<li><p>适用场景</p>
<p>用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。</p>
</li>
</ul>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><code>newCachedThreadPool</code></h4><blockquote>
<p>可根据需要创建新线程的线程池，但是在一起构造的线程可用时将重用他们。对于很多短期异步任务的程序而言，这类线程池可以提高性能。</p>
<p>如果现有线程没有可用的，则会创建一个新的线程并添加到池中，终止并从缓存中移除那些超过60s没有使用的线程。<strong>因此，长时间保持空闲的newCachedThreadPool线程池是不存在任何线程的，所以这时候几乎不占用系统资源。</strong></p>
</blockquote>
<ul>
<li><p>实现源码</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**
* 核心线程数为0 线程最大为Int的最大值所以可以认定为线程池最大线程无限大，设置了超时时间为60s。任务队列采用了阻塞队列(必须池内有空闲线程才可以执行)
*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,
                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,
                                      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());
    &#125;</code></pre></div>
</li>
<li><p>样例演示</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cachedThreadPoolDemo</span><span class="hljs-params">()</span></span>&#123;
        ExecutorService cachedThreadPool= Executors.newCachedThreadPool();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">6</span> ; i++) &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index=i;
            cachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                    System.err.println(Thread.currentThread().getName()+<span class="hljs-string">" , index = "</span>+index);
                &#125;
            &#125;);

            <span class="hljs-keyword">try</span>&#123;
                Thread.sleep(<span class="hljs-number">1000</span>);
            &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

运行结果：整个过程都在同一个线程pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>中执行，后面线程复用前面的线程
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">0</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">1</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">2</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">3</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">4</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">5</span></code></pre></div>
</li>
<li><p>适用场景</p>
<p>并发执行大量短期的小任务，或者负载较轻的服务器</p>
</li>
</ul>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><code>newScheduledThreadPool</code></h4><blockquote>
<p>创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<ul>
<li><p>实现源码</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);
&#125;
<span class="hljs-comment">/**
* 核心线程数固定，非核心线程数为无限大，当非核心数处于闲置状态的时候会被立即回收
*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;
    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,
          <span class="hljs-keyword">new</span> DelayedWorkQueue());
&#125;</code></pre></div>
</li>
<li><p>样例演示</p>
<div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleThreadPoolDemo</span><span class="hljs-params">()</span> </span>&#123;
        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);
     <span class="hljs-comment">//延迟一定时间后执行Runnable任务</span>
        scheduledThreadPool.schedule(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" delay 2s"</span>);
            &#125;
        &#125;, <span class="hljs-number">2</span>, TimeUnit.SECONDS);
     <span class="hljs-comment">//延迟一定时间后执行Callable任务</span>
        scheduledThreadPool.schedule(<span class="hljs-keyword">new</span> Callable&lt;Object&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
            &#125;
        &#125;, <span class="hljs-number">2</span>, TimeUnit.SECONDS);
     <span class="hljs-comment">//延迟一定时间（initialDelay）后,以(period)时间间隔执行任务</span>
        scheduledThreadPool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" every 3s"</span>);
            &#125;
        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);
     <span class="hljs-comment">//延迟一定时间（initialDelay）后,以(delay即上一个任务执行结束到下一个任务开始的间隔)执行</span>
        scheduledThreadPool.scheduleWithFixedDelay(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" delay 3s"</span>);
            &#125;
        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);
    &#125;

运行结果：
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> every <span class="hljs-number">3</span>s
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> delay <span class="hljs-number">3</span>s
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> delay <span class="hljs-number">3</span>s <span class="hljs-number">1</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> every <span class="hljs-number">3</span>s</code></pre></div>
</li>
<li><p>适用场景</p>
<p>用于需要多个后台线程执行周期任务，同时需要限制线程数量</p>
</li>
</ul>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><code>newSingleThreadExecutor</code></h4><blockquote>
<p>创建一个单线程池，该线程池中只有一个线程在工作，其他任务都会依次在任务中排列中等候依次执行，任务是串行执行的。此线程池保证所有的任务的执行顺序按照任务提交顺序执行(FIFO-先进先出)。</p>
</blockquote>
<ul>
<li><p>实现源码</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**
* 只有一个核心线程，对任务队列没有大小限制，将所有外界任务统一到一个线程执行所有我们不需要处理线程同步的问题。
*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService
            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,
                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,
                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));
    &#125;</code></pre></div>
</li>
<li><p>样例演示</p>
<div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">singleThreadPoolDemo</span><span class="hljs-params">()</span></span>&#123;
        ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;
            singleThreadExecutor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                    System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" , index = "</span> + index);
                &#125;
            &#125;);

            <span class="hljs-keyword">try</span> &#123;
                Thread.sleep(<span class="hljs-number">1000</span>);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

运行结果：所有的任务都是在pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>中依次运行
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">0</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">1</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">2</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">3</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">4</span>
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">5</span></code></pre></div>
</li>
<li><p>适用场景</p>
<p>用于串行执行任务的场景，每个任务需要顺序执行</p>
</li>
</ul>
<h3 id="5-线程池的执行流程"><a href="#5-线程池的执行流程" class="headerlink" title="5. 线程池的执行流程"></a>5. 线程池的执行流程</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/threadpool_process.png" srcset="/img/loading.gif" class="full-image" alt="线程池执行流程图" title="线程池执行流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<ol>
<li>判断corePoolSize(核心线程数)是否已到达，没到达则可以创建一个新线程执行任务</li>
<li>判断工作队列是否已满，没满则添加入队列等待执行</li>
<li>判断maximum(最大线程数)是否已到达，没到达则创建一个新线程执行任务。已满则执行拒绝策略。</li>
</ol>
<h3 id="6-线程池的使用注意"><a href="#6-线程池的使用注意" class="headerlink" title="6. 线程池的使用注意"></a>6. 线程池的使用注意</h3><ol>
<li><p>线程池不要用<code>Executors</code>的方式去创建，应该利用<code>ThreadPoolExecutor</code>的方式，这样可以帮助更好理解实现方式以及避免资源消耗过度的问题。</p>
<p><strong><code>fixThreadPool以及singleThreadPool</code>,由于设置的等待队列长度为Integer.MAX_VALUE，导致大量请求堆积，消耗大量资源。</strong></p>
<p><strong><code>cachedThreadPool以及scheduledThreadPool</code>,由于运行允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的请求，消耗大量资源。</strong></p>
</li>
<li><p>针对具体情况去配置线程池参数，不同的任务类别应采用不同规模的线程池，任务类别分为3种：</p>
<ul>
<li><p><strong><code>CPU密集型任务(需要进行大量计算，处理)</code></strong>：线程池中线程个数尽量少，不应大于CPU核心数，避免出现每个线程都需要长时间使用但是线程过多去抢占资源。</p>
</li>
<li><p><strong><code>IO密集型任务(主要时间都在IO，CPU空闲时间比较多)</code></strong>：线程池可以配置尽量多的线程，由于CPU大部分时间空闲，可以提高CPU的利用率。</p>
</li>
<li><p><strong><code>混合型任务</code></strong>：如果可以拆分，则拆分成一个CPU密集型以及IO密集型任务，只要执行任务效率相差不大。若相差太大则没必要拆分。</p>
</li>
</ul>
</li>
</ol>
<h3 id="7-补充知识"><a href="#7-补充知识" class="headerlink" title="7.补充知识"></a>7.补充知识</h3><ol>
<li><p><code>submit()</code>和<code>execute()</code>区别</p>
<p><code>submit()</code>返回一个<code>future</code>，根据<code>future</code>可以判断任务是否完成–实现<code>Callable</code>接口</p>
<p><code>execute()</code>无返回值。只是执行了任务，不知道结果如何 – 实现<code>Runnable</code>接口</p>
</li>
</ol>
<h3 id="8-内容引用"><a href="#8-内容引用" class="headerlink" title="8. 内容引用"></a>8. 内容引用</h3><p><a href="https://juejin.im/post/5bdbbc3d6fb9a0224a5e486f#heading-14" target="_blank" rel="noopener">线程池</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTU0MzI4MQ==&amp;mid=2247486818&amp;idx=1&amp;sn=5d5f87cceadb062c3502cd7a1e2d3e0a&amp;chksm=eb4761fcdc30e8ea3de28eca8c16ce305336852534dbd23edb348b5c1e02334dee025ea8f7bf&amp;mpshare=1&amp;scene=23&amp;srcid=12117GQN5ZAnFwJRhSpKAcO1%23rd" target="_blank" rel="noopener">参考链接</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2018/05/31/Android-Study-Plan-XVIII/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android-Study-Plan-XVIII -- 基础网络原理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2018/05/14/Handler机制即源码解析/">
                        <span class="hidden-mobile">Handler机制源码解析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
