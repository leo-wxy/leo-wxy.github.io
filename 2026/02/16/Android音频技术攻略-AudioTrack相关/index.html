

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、AudioTrack相关1.1 AudioTrack是什么（认知聚合）1.1.1 基础定义 AudioTrack 是 Android 侧 PCM 播放的核心接口，播放器把解码后的数据持续写入它。 它把应用层数据交给系统音频服务，再由系统完成混音、路由与设备输出。 对播放器来说，AudioTrack 是发声链路的最后一跳，不是可选能力。  1.1.2 在音频栈中的位置flowchart LR">
<meta property="og:type" content="article">
<meta property="og:title" content="Android音频技术攻略-AudioTrack相关">
<meta property="og:url" content="https://leo-wxy.github.io/2026/02/16/Android%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF%E6%94%BB%E7%95%A5-AudioTrack%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="一、AudioTrack相关1.1 AudioTrack是什么（认知聚合）1.1.1 基础定义 AudioTrack 是 Android 侧 PCM 播放的核心接口，播放器把解码后的数据持续写入它。 它把应用层数据交给系统音频服务，再由系统完成混音、路由与设备输出。 对播放器来说，AudioTrack 是发声链路的最后一跳，不是可选能力。  1.1.2 在音频栈中的位置flowchart LR">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2026-02-16T12:44:46.000Z">
<meta property="article:modified_time" content="2026-02-17T13:15:32.332Z">
<meta property="article:author" content="Leo-Wxy">
<meta property="article:tag" content="音视频">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Android音频技术攻略-AudioTrack相关 - Wxy的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":false};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Android音频技术攻略-AudioTrack相关</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2026-02-16 20:44" pubdate>
          2026年2月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          6.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          22 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Android音频技术攻略-AudioTrack相关</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="一、AudioTrack相关"><a href="#一、AudioTrack相关" class="headerlink" title="一、AudioTrack相关"></a>一、AudioTrack相关</h2><h3 id="1-1-AudioTrack是什么（认知聚合）"><a href="#1-1-AudioTrack是什么（认知聚合）" class="headerlink" title="1.1 AudioTrack是什么（认知聚合）"></a>1.1 AudioTrack是什么（认知聚合）</h3><h4 id="1-1-1-基础定义"><a href="#1-1-1-基础定义" class="headerlink" title="1.1.1 基础定义"></a>1.1.1 基础定义</h4><ul>
<li><code>AudioTrack</code> 是 Android 侧 PCM 播放的核心接口，播放器把解码后的数据持续写入它。</li>
<li>它把应用层数据交给系统音频服务，再由系统完成混音、路由与设备输出。</li>
<li>对播放器来说，<code>AudioTrack</code> 是发声链路的最后一跳，不是可选能力。</li>
</ul>
<h4 id="1-1-2-在音频栈中的位置"><a href="#1-1-2-在音频栈中的位置" class="headerlink" title="1.1.2 在音频栈中的位置"></a>1.1.2 在音频栈中的位置</h4><pre><code class=" mermaid">flowchart LR
  A[Player/业务层] --&gt; B[AudioTrack]
  B --&gt; C[AudioFlinger]
  C --&gt; D[Audio HAL]
  D --&gt; E[Speaker/Bluetooth/Headset]
</code></pre>

<ul>
<li>应用层直接可控的是 <code>AudioTrack</code> 写入与状态；系统层负责策略、混音和硬件交互。</li>
</ul>
<h4 id="1-1-3-在播放器中的核心职责"><a href="#1-1-3-在播放器中的核心职责" class="headerlink" title="1.1.3 在播放器中的核心职责"></a>1.1.3 在播放器中的核心职责</h4><ul>
<li>承接解码后的 PCM 数据并按节拍写入。</li>
<li>维持缓冲稳定，尽量避免缓冲不足导致卡顿和破音。</li>
<li>输出可观测状态（播放状态、写入结果、进度信息）用于同步与排障。</li>
</ul>
<h4 id="1-1-4-本文参考边界"><a href="#1-1-4-本文参考边界" class="headerlink" title="1.1.4 本文参考边界"></a>1.1.4 本文参考边界</h4><ul>
<li><code>Project.md</code> 仅用于定位项目中的 AudioTrack 使用点。</li>
<li>正文主线聚焦通用分析方法，不以项目源码走读为主。</li>
</ul>
<h3 id="1-2-AudioTrack创建参数"><a href="#1-2-AudioTrack创建参数" class="headerlink" title="1.2 AudioTrack创建参数"></a>1.2 AudioTrack创建参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// https://cs.android.com/android/platform/superproject/+/android-latest-release:frameworks/base/media/java/android/media/AudioTrack.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AudioTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> streamType, <span class="hljs-type">int</span> sampleRateInHz, <span class="hljs-type">int</span> channelConfig, <span class="hljs-type">int</span> audioFormat,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> bufferSizeInBytes, <span class="hljs-type">int</span> mode)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AudioTrack</span><span class="hljs-params">(<span class="hljs-type">int</span> streamType, <span class="hljs-type">int</span> sampleRateInHz, <span class="hljs-type">int</span> channelConfig, <span class="hljs-type">int</span> audioFormat,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> bufferSizeInBytes, <span class="hljs-type">int</span> mode, <span class="hljs-type">int</span> sessionId)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AudioTrack</span><span class="hljs-params">(AudioAttributes attributes, AudioFormat format, <span class="hljs-type">int</span> bufferSizeInBytes,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> mode, <span class="hljs-type">int</span> sessionId)</span><br><br><span class="hljs-type">AudioTrack</span> <span class="hljs-variable">track</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AudioTrack</span>.Builder()<br>        .setAudioAttributes(attributes)<br>        .setAudioFormat(format)<br>        .setBufferSizeInBytes(bufferSizeInBytes)<br>        .setTransferMode(AudioTrack.MODE_STREAM)<br>        .setSessionId(AudioManager.AUDIO_SESSION_ID_GENERATE)<br>        .build();<br><br><br><br></code></pre></td></tr></table></figure>

<h4 id="1-2-0-三要素与构造参数映射"><a href="#1-2-0-三要素与构造参数映射" class="headerlink" title="1.2.0 三要素与构造参数映射"></a>1.2.0 三要素与构造参数映射</h4><table>
<thead>
<tr>
<th>PCM 核心参数</th>
<th>AudioTrack 对应参数</th>
<th>常见值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>采样率</td>
<td><code>sampleRateInHz</code></td>
<td><code>44100</code> &#x2F; <code>48000</code> &#x2F; <code>96000</code></td>
<td>每秒采样次数</td>
</tr>
<tr>
<td>位深</td>
<td><code>audioFormat</code></td>
<td><code>ENCODING_PCM_16BIT</code> &#x2F; <code>ENCODING_PCM_FLOAT</code></td>
<td>每个采样点的数据精度</td>
</tr>
<tr>
<td>声道数&#x2F;布局</td>
<td><code>channelConfig</code> &#x2F; <code>channelMask</code></td>
<td><code>CHANNEL_OUT_MONO</code> &#x2F; <code>CHANNEL_OUT_STEREO</code> &#x2F; <code>CHANNEL_OUT_5POINT1</code></td>
<td>决定通道数量和空间布局</td>
</tr>
</tbody></table>
<ul>
<li>这三个参数需要成组匹配；只改其中一个，常见结果是重采样、下混或异常静音。</li>
</ul>
<h4 id="1-2-1-sampleRateInHz"><a href="#1-2-1-sampleRateInHz" class="headerlink" title="1.2.1 sampleRateInHz"></a>1.2.1 <code>sampleRateInHz</code></h4><ul>
<li><code>sampleRateInHz</code> 常见取值如下，优先与源音频和设备主采样率对齐。</li>
</ul>
<table>
<thead>
<tr>
<th>常见值(Hz)</th>
<th>典型来源&#x2F;场景</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td><code>8000</code></td>
<td>窄带语音</td>
<td>仅语音链路使用，不建议音乐播放</td>
</tr>
<tr>
<td><code>16000</code></td>
<td>宽带语音</td>
<td>语音通话&#x2F;语音消息常见</td>
</tr>
<tr>
<td><code>44100</code></td>
<td>音乐内容（CD 系）</td>
<td>音乐场景常见，兼容性高</td>
</tr>
<tr>
<td><code>48000</code></td>
<td>视频&#x2F;直播&#x2F;系统主采样率</td>
<td>Android 设备主流推荐值</td>
</tr>
<tr>
<td><code>96000</code></td>
<td>Hi-Res 场景</td>
<td>仅在设备和链路都支持时启用</td>
</tr>
</tbody></table>
<ul>
<li>与设备工作采样率不一致时，系统可能触发重采样并引入额外开销。</li>
</ul>
<h4 id="1-2-2-channelConfig-channelMask"><a href="#1-2-2-channelConfig-channelMask" class="headerlink" title="1.2.2 channelConfig &#x2F; channelMask"></a>1.2.2 <code>channelConfig</code> &#x2F; <code>channelMask</code></h4><ul>
<li>定义声道布局，旧构造常用 <code>channelConfig</code>，Builder 常用 <code>channelMask</code>。</li>
<li><code>nChannel</code> 表示声道数量，<code>channelMask</code> 表示声道布局掩码，两者不是同一个概念。</li>
</ul>
<table>
<thead>
<tr>
<th>概念</th>
<th>典型值</th>
<th>表达内容</th>
<th>常见误区</th>
</tr>
</thead>
<tbody><tr>
<td>声道数（<code>nChannel</code>）</td>
<td><code>1</code> &#x2F; <code>2</code> &#x2F; <code>6</code></td>
<td>有多少路音频通道</td>
<td>只看数量，不看布局位置</td>
</tr>
<tr>
<td>声道布局（<code>channelMask</code>）</td>
<td><code>CHANNEL_OUT_STEREO</code> &#x2F; <code>CHANNEL_OUT_5POINT1</code></td>
<td>每个通道对应的物理位置</td>
<td>仅按声道数创建，忽略布局映射</td>
</tr>
</tbody></table>
<ul>
<li>同样是 <code>2</code> 声道，语义也可能不同（立体声或双单声道）；跨模块传递时要明确布局与映射关系。</li>
</ul>
<table>
<thead>
<tr>
<th>常见取值</th>
<th>声道数</th>
<th>典型场景</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>CHANNEL_OUT_MONO</code></td>
<td><code>1</code></td>
<td>语音、低带宽输出</td>
<td>资源占用低</td>
</tr>
<tr>
<td><code>CHANNEL_OUT_STEREO</code></td>
<td><code>2</code></td>
<td>音乐、视频默认输出</td>
<td>最常用，优先选项</td>
</tr>
<tr>
<td><code>CHANNEL_OUT_5POINT1</code></td>
<td><code>6</code></td>
<td>外接设备&#x2F;家庭影院</td>
<td>需设备真实支持</td>
</tr>
<tr>
<td><code>CHANNEL_OUT_7POINT1_SURROUND</code></td>
<td><code>8</code></td>
<td>高声道设备输出</td>
<td>兼容性要求高</td>
</tr>
</tbody></table>
<ul>
<li>与输入 PCM 声道不匹配时，可能出现声道错位、下混异常或静音。</li>
</ul>
<h4 id="1-2-3-audioFormat"><a href="#1-2-3-audioFormat" class="headerlink" title="1.2.3 audioFormat"></a>1.2.3 <code>audioFormat</code></h4><ul>
<li><code>audioFormat</code>（或 <code>AudioFormat.setEncoding(...)</code>）描述写入 AudioTrack 的数据编码类型。</li>
<li>在 PCM 场景下，它主要体现位深和数值类型；在直通场景下，它也可表示压缩编码类型。</li>
</ul>
<table>
<thead>
<tr>
<th>常见取值</th>
<th>每采样字节</th>
<th>典型场景</th>
<th>兼容性</th>
</tr>
</thead>
<tbody><tr>
<td><code>ENCODING_PCM_8BIT</code></td>
<td><code>1</code></td>
<td>历史兼容场景</td>
<td>现代播放器较少使用</td>
</tr>
<tr>
<td><code>ENCODING_PCM_16BIT</code>(默认)</td>
<td><code>2</code></td>
<td>音乐&#x2F;视频主流场景</td>
<td>兼容性最高，推荐默认</td>
</tr>
<tr>
<td><code>ENCODING_PCM_FLOAT</code></td>
<td><code>4</code></td>
<td>高动态处理链路</td>
<td>精度高但带宽和算力成本更高</td>
</tr>
<tr>
<td><code>ENCODING_PCM_24BIT_PACKED</code></td>
<td><code>3</code></td>
<td>高保真输出</td>
<td>机型支持差异较大</td>
</tr>
<tr>
<td><code>ENCODING_PCM_32BIT</code></td>
<td><code>4</code></td>
<td>专业处理链路</td>
<td>需确认端到端支持</td>
</tr>
</tbody></table>
<ul>
<li>非 PCM 编码通常用于直通&#x2F;离载播放，是否可用由设备能力决定。</li>
</ul>
<table>
<thead>
<tr>
<th>编码类别</th>
<th>常见取值</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PCM 编码</td>
<td><code>ENCODING_PCM_16BIT</code> &#x2F; <code>ENCODING_PCM_FLOAT</code></td>
<td>应用写入原始 PCM 数据</td>
<td>常规播放器最常见</td>
</tr>
<tr>
<td>压缩编码</td>
<td><code>ENCODING_AC3</code> &#x2F; <code>ENCODING_E_AC3</code> &#x2F; <code>ENCODING_DTS</code> &#x2F; <code>ENCODING_IEC61937</code></td>
<td>向设备直通压缩比特流</td>
<td>依赖 HDMI&#x2F;外设与系统支持</td>
</tr>
</tbody></table>
<ul>
<li>选择格式时同时看三件事：设备支持、上游解码输出、CPU&#x2F;带宽成本。</li>
</ul>
<h5 id="PCM-FLOAT-异常回退-case"><a href="#PCM-FLOAT-异常回退-case" class="headerlink" title="PCM_FLOAT 异常回退 case"></a>PCM_FLOAT 异常回退 case</h5><ul>
<li>如果 <code>ENCODING_PCM_FLOAT</code> 播放出现杂音或无声，建议优先回退到 <code>ENCODING_PCM_16BIT</code> 保证可播。</li>
</ul>
<table>
<thead>
<tr>
<th>异常现象</th>
<th>快速检查点</th>
<th>处理动作</th>
</tr>
</thead>
<tbody><tr>
<td>有杂音&#x2F;爆音</td>
<td>样本值是否超出 <code>[-1.0, 1.0]</code></td>
<td>先做夹紧（clamp），再观察</td>
</tr>
<tr>
<td>完全无声</td>
<td>数据是否含 <code>NaN/Inf</code>、声道是否交错布局</td>
<td>修正数据后重试</td>
</tr>
<tr>
<td>初始化或写入异常</td>
<td><code>STATE_UNINITIALIZED</code> &#x2F; <code>write</code> 连续异常返回</td>
<td>直接降级到 <code>PCM_16BIT</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>降级流程</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>stop -&gt; flush -&gt; release</code></td>
<td>彻底清理旧的 float 播放实例</td>
</tr>
<tr>
<td><code>recreate AudioTrack (PCM_16BIT)</code></td>
<td>使用同一组采样率和声道重新创建</td>
</tr>
<tr>
<td><code>float -&gt; short</code> 转换</td>
<td>样本先 clamp 到 <code>[-1.0, 1.0]</code>，再乘 <code>32767</code></td>
</tr>
</tbody></table>
<ul>
<li>实践建议：将该回退做成自动策略，并按机型记录黑名单，后续默认走 <code>PCM_16BIT</code>。</li>
</ul>
<h4 id="1-2-4-bufferSizeInBytes"><a href="#1-2-4-bufferSizeInBytes" class="headerlink" title="1.2.4 bufferSizeInBytes"></a>1.2.4 <code>bufferSizeInBytes</code></h4><ul>
<li>这个参数没有固定枚举值，通常按 <code>getMinBufferSize(...)</code> 的倍数调优。</li>
<li>缓冲大小可先用 PCM 数据量公式估算：<code>bytes = sampleRateInHz x (bitDepth / 8) x channels x durationSec</code>。</li>
<li>示例：<code>48kHz/16bit/立体声</code> 每秒约 <code>192000 bytes</code>，则 <code>40ms</code> 约 <code>7680 bytes</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>取值策略</th>
<th>经验值</th>
<th>适用场景</th>
<th>风险</th>
</tr>
</thead>
<tbody><tr>
<td>最小值</td>
<td><code>minBuffer</code></td>
<td>延迟优先实验</td>
<td>最易出现缓冲不足与卡顿</td>
</tr>
<tr>
<td>稳定优先</td>
<td><code>2 x minBuffer</code></td>
<td>大多数音乐播放</td>
<td>常用平衡点</td>
</tr>
<tr>
<td>抖动兜底</td>
<td><code>4 x minBuffer</code></td>
<td>低端机&#x2F;复杂解码链路</td>
<td>时延上升明显</td>
</tr>
<tr>
<td>强兜底</td>
<td><code>&gt;4 x minBuffer</code></td>
<td>极端卡顿规避</td>
<td>交互延迟偏大</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>目标缓冲时长</th>
<th>示例值（<code>48kHz/立体声/16bit</code>）</th>
<th>体验特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>20ms</code></td>
<td><code>3840 bytes</code></td>
<td>低延迟，风险高</td>
</tr>
<tr>
<td><code>40ms</code></td>
<td><code>7680 bytes</code></td>
<td>常见平衡</td>
</tr>
<tr>
<td><code>80ms</code></td>
<td><code>15360 bytes</code></td>
<td>稳定性更好</td>
</tr>
<tr>
<td><code>120ms</code></td>
<td><code>23040 bytes</code></td>
<td>更稳但拖尾明显</td>
</tr>
</tbody></table>
<ul>
<li>延迟应按分层模型看，不只盯 <code>bufferSizeInBytes</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>延迟分层</th>
<th>典型范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>App Buffer</td>
<td><code>20~50ms</code></td>
<td>上层缓存与写入节拍</td>
</tr>
<tr>
<td>AudioTrack Buffer</td>
<td>与 <code>bufferSizeInBytes</code> 相关</td>
<td>可通过 <code>minBuffer</code> 倍数调优</td>
</tr>
<tr>
<td>AudioFlinger</td>
<td><code>~20ms</code></td>
<td>系统混音与调度</td>
</tr>
<tr>
<td>Audio HAL&#x2F;设备</td>
<td><code>10~50ms</code></td>
<td>硬件与驱动链路</td>
</tr>
</tbody></table>
<ul>
<li>经验上总延迟常在 <code>80~200ms</code> 区间，<code>2 x minBuffer</code> 往往是体验与稳定性的平衡点。</li>
<li><code>bufferSizeInBytes</code> 必须大于等于 <code>minBuffer</code>，生产环境建议从 <code>2 x minBuffer</code> 起步。</li>
</ul>
<h4 id="1-2-5-AudioAttributes"><a href="#1-2-5-AudioAttributes" class="headerlink" title="1.2.5 AudioAttributes"></a>1.2.5 <code>AudioAttributes</code></h4><ul>
<li>构造 <code>AudioAttributes</code> 时重点是 <code>usage</code> 和 <code>contentType</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>常见取值</th>
<th>典型场景</th>
<th>影响</th>
</tr>
</thead>
<tbody><tr>
<td><code>usage</code></td>
<td><code>USAGE_MEDIA</code></td>
<td>音乐、播客、视频</td>
<td>媒体播放默认选择</td>
</tr>
<tr>
<td><code>usage</code></td>
<td><code>USAGE_GAME</code></td>
<td>游戏音效&#x2F;背景音</td>
<td>更贴近游戏策略</td>
</tr>
<tr>
<td><code>usage</code></td>
<td><code>USAGE_VOICE_COMMUNICATION</code></td>
<td>通话&#x2F;实时语音</td>
<td>走语音通信策略</td>
</tr>
<tr>
<td><code>usage</code></td>
<td><code>USAGE_ALARM</code></td>
<td>闹钟提醒</td>
<td>受系统提醒策略影响</td>
</tr>
<tr>
<td><code>contentType</code></td>
<td><code>CONTENT_TYPE_MUSIC</code></td>
<td>音乐内容</td>
<td>音色策略更偏音乐</td>
</tr>
<tr>
<td><code>contentType</code></td>
<td><code>CONTENT_TYPE_SPEECH</code></td>
<td>人声内容</td>
<td>语音内容标识更明确</td>
</tr>
<tr>
<td><code>contentType</code></td>
<td><code>CONTENT_TYPE_MOVIE</code></td>
<td>影视内容</td>
<td>适配视频类内容策略</td>
</tr>
<tr>
<td><code>contentType</code></td>
<td><code>CONTENT_TYPE_SONIFICATION</code></td>
<td>提示音</td>
<td>系统提示类声音</td>
</tr>
</tbody></table>
<ul>
<li><code>flags</code> 是对播放行为的附加提示，默认 <code>0</code> 即可；只有明确场景再设置。</li>
</ul>
<table>
<thead>
<tr>
<th><code>flags</code> 常见值</th>
<th>含义</th>
<th>典型场景</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td><code>FLAG_HW_AV_SYNC</code></td>
<td>请求硬件级音画同步</td>
<td>视频播放、隧道播放</td>
<td>需设备&#x2F;解码链路支持</td>
</tr>
<tr>
<td><code>FLAG_SCO</code></td>
<td>倾向走蓝牙 SCO 语音链路</td>
<td>通话&#x2F;对讲类语音</td>
<td>音质与带宽受限</td>
</tr>
<tr>
<td><code>FLAG_AUDIBILITY_ENFORCED</code></td>
<td>强制可听策略</td>
<td>系统级提示音</td>
<td>多数三方应用不建议使用</td>
</tr>
<tr>
<td><code>FLAG_BEACON</code></td>
<td>声音 beacon 提示策略</td>
<td>特定辅助提示场景</td>
<td>使用场景较少</td>
</tr>
</tbody></table>
<ul>
<li>音乐播放器默认组合可优先使用：<code>USAGE_MEDIA + CONTENT_TYPE_MUSIC</code>。</li>
<li>普通音乐播放一般不需要额外 <code>flags</code>，保持默认值更稳妥。</li>
</ul>
<h4 id="1-2-6-streamType（旧接口参数）"><a href="#1-2-6-streamType（旧接口参数）" class="headerlink" title="1.2.6 streamType（旧接口参数）"></a>1.2.6 <code>streamType</code>（旧接口参数）</h4><ul>
<li>你说得对，旧版构造函数里确实有 <code>streamType</code>，用于描述声音类型和音量组。</li>
</ul>
<table>
<thead>
<tr>
<th>常见取值</th>
<th>典型场景</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>STREAM_MUSIC</code></td>
<td>音乐、视频、播客</td>
<td>最常用，播放器默认选项</td>
</tr>
<tr>
<td><code>STREAM_RING</code></td>
<td>来电铃声</td>
<td>走铃声音量组</td>
</tr>
<tr>
<td><code>STREAM_ALARM</code></td>
<td>闹钟提醒</td>
<td>走闹钟音量组</td>
</tr>
<tr>
<td><code>STREAM_NOTIFICATION</code></td>
<td>通知提示</td>
<td>走通知音量组</td>
</tr>
<tr>
<td><code>STREAM_VOICE_CALL</code></td>
<td>通话语音</td>
<td>走通话链路策略</td>
</tr>
<tr>
<td><code>STREAM_SYSTEM</code></td>
<td>系统提示音</td>
<td>系统级提示场景</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>版本建议</th>
<th>推荐做法</th>
</tr>
</thead>
<tbody><tr>
<td>旧代码&#x2F;兼容场景</td>
<td>可继续使用 <code>streamType</code></td>
</tr>
<tr>
<td>Android 5.0+ 新实现</td>
<td>优先使用 <code>AudioAttributes</code>（<code>usage + contentType</code>）</td>
</tr>
</tbody></table>
<ul>
<li>可把 <code>streamType</code> 视为旧模型，<code>AudioAttributes</code> 视为新模型；新项目优先后者。</li>
</ul>
<h4 id="1-2-7-mode（MODE-STREAM-MODE-STATIC）"><a href="#1-2-7-mode（MODE-STREAM-MODE-STATIC）" class="headerlink" title="1.2.7 mode（MODE_STREAM &#x2F; MODE_STATIC）"></a>1.2.7 <code>mode</code>（<code>MODE_STREAM</code> &#x2F; <code>MODE_STATIC</code>）</h4><table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>典型场景</th>
<th>约束</th>
</tr>
</thead>
<tbody><tr>
<td><code>MODE_STREAM</code></td>
<td>流式写入，边解码边播放</td>
<td>音乐、播客、直播、长音频</td>
<td>需持续写入和调度线程</td>
</tr>
<tr>
<td><code>MODE_STATIC</code></td>
<td>一次装载后播放</td>
<td>短音效、提示音</td>
<td>不适合长音频，内存占用集中</td>
</tr>
</tbody></table>
<ul>
<li>播放器主链路默认使用 <code>MODE_STREAM</code>，除非是短音效才考虑 <code>MODE_STATIC</code>。</li>
</ul>
<h4 id="1-2-8-sessionId（Builder-构造参数）"><a href="#1-2-8-sessionId（Builder-构造参数）" class="headerlink" title="1.2.8 sessionId（Builder&#x2F;构造参数）"></a>1.2.8 <code>sessionId</code>（Builder&#x2F;构造参数）</h4><ul>
<li><code>sessionId</code> 用于标识音频会话，常用于把 <code>AudioEffect</code>（如均衡器、低音增强、可视化）绑定到指定播放链路。</li>
</ul>
<table>
<thead>
<tr>
<th>常见取值</th>
<th>含义</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>AudioManager.AUDIO_SESSION_ID_GENERATE</code></td>
<td>让系统分配新的会话 ID</td>
<td>普通音乐播放默认选择</td>
</tr>
<tr>
<td><code>已有 sessionId</code>（<code>&gt;0</code>）</td>
<td>复用已有会话</td>
<td>多实例共享同一组音效或统一控制</td>
</tr>
</tbody></table>
<ul>
<li>不需要共享音效链路时，优先使用 <code>AUDIO_SESSION_ID_GENERATE</code>，避免手动管理会话冲突。</li>
</ul>
<table>
<thead>
<tr>
<th>多个 AudioTrack 使用同一 <code>sessionId</code> 的影响</th>
<th>现象</th>
</tr>
</thead>
<tbody><tr>
<td>音效共享</td>
<td>调整一个 Track 的 EQ&#x2F;低音，另一个也会被影响</td>
</tr>
<tr>
<td>参数互相覆盖</td>
<td>多处同时改音效参数，听感会忽强忽弱</td>
</tr>
<tr>
<td>生命周期互相牵连</td>
<td>一方重建或释放后，另一方可能出现效果失效</td>
</tr>
</tbody></table>
<ul>
<li>结论：除非你明确要共享同一套音效，否则每个 AudioTrack 用独立 <code>sessionId</code> 更稳。</li>
</ul>
<h5 id="线上问题实例"><a href="#线上问题实例" class="headerlink" title="线上问题实例"></a>线上问题实例</h5><p>线上有用户反馈歌曲在播放过程中，上一首歌正常播放结束到下一首歌后出现了播放无声问题。初步排查问题就是两个AudioTrack对象使用了同一个 sessionid，导致淡入淡出效果触发时，针对AudioTrack设置音量时系统处理异常，导致播放无声。</p>
<p>根本解决方案：<strong>每次创建AudioTrack时都要生成新的sessionId</strong>。</p>
<h4 id="1-2-9-常见音频格式与参数搭配"><a href="#1-2-9-常见音频格式与参数搭配" class="headerlink" title="1.2.9 常见音频格式与参数搭配"></a>1.2.9 常见音频格式与参数搭配</h4><ul>
<li>这里的 <code>sampleRateInHz</code> 和 <code>channelConfig</code> 指的是<strong>解码后写入 AudioTrack 的 PCM 参数</strong>，不是封装格式本身。</li>
</ul>
<table>
<thead>
<tr>
<th>常见源格式</th>
<th>常见采样率</th>
<th>常见声道</th>
<th><code>channelConfig</code> 常用值</th>
<th>实践建议</th>
</tr>
</thead>
<tbody><tr>
<td>MP3</td>
<td><code>44100</code> &#x2F; <code>48000</code></td>
<td><code>2</code></td>
<td><code>CHANNEL_OUT_STEREO</code></td>
<td>音乐播放默认可按源参数直出</td>
</tr>
<tr>
<td>AAC-LC</td>
<td><code>44100</code> &#x2F; <code>48000</code></td>
<td><code>2</code></td>
<td><code>CHANNEL_OUT_STEREO</code></td>
<td>与 MP3 类似，优先立体声</td>
</tr>
<tr>
<td>HE-AAC</td>
<td><code>44100</code> &#x2F; <code>48000</code></td>
<td><code>2</code></td>
<td><code>CHANNEL_OUT_STEREO</code></td>
<td>低码率常见，注意重采样成本</td>
</tr>
<tr>
<td>FLAC</td>
<td><code>44100</code> &#x2F; <code>48000</code> &#x2F; <code>96000</code></td>
<td><code>2</code></td>
<td><code>CHANNEL_OUT_STEREO</code></td>
<td>高采样率需先确认设备支持</td>
</tr>
<tr>
<td>WAV(PCM)</td>
<td><code>8000~96000</code></td>
<td><code>1</code> &#x2F; <code>2</code></td>
<td><code>CHANNEL_OUT_MONO</code> &#x2F; <code>CHANNEL_OUT_STEREO</code></td>
<td>按文件头参数直接配置最稳</td>
</tr>
<tr>
<td>Opus</td>
<td><code>48000</code>(常见)</td>
<td><code>1</code> &#x2F; <code>2</code></td>
<td><code>CHANNEL_OUT_MONO</code> &#x2F; <code>CHANNEL_OUT_STEREO</code></td>
<td>实时语音常见单声道</td>
</tr>
<tr>
<td>AMR-NB</td>
<td><code>8000</code></td>
<td><code>1</code></td>
<td><code>CHANNEL_OUT_MONO</code></td>
<td>语音场景专用，不建议音乐</td>
</tr>
<tr>
<td>AMR-WB</td>
<td><code>16000</code></td>
<td><code>1</code></td>
<td><code>CHANNEL_OUT_MONO</code></td>
<td>宽带语音常见配置</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>播放类型</th>
<th>推荐 <code>sampleRateInHz</code></th>
<th>推荐 <code>channelConfig</code></th>
</tr>
</thead>
<tbody><tr>
<td>音乐&#x2F;视频通用播放</td>
<td><code>44100</code> 或 <code>48000</code></td>
<td><code>CHANNEL_OUT_STEREO</code></td>
</tr>
<tr>
<td>实时语音&#x2F;通话</td>
<td><code>16000</code> 或 <code>48000</code></td>
<td><code>CHANNEL_OUT_MONO</code></td>
</tr>
<tr>
<td>低带宽语音兼容</td>
<td><code>8000</code></td>
<td><code>CHANNEL_OUT_MONO</code></td>
</tr>
</tbody></table>
<ul>
<li>如果源是多声道但设备&#x2F;链路不稳定，优先下混到立体声，先保证可播和稳定性。</li>
</ul>
<h2 id="二、AudioTrack播放模式与生命周期"><a href="#二、AudioTrack播放模式与生命周期" class="headerlink" title="二、AudioTrack播放模式与生命周期"></a>二、AudioTrack播放模式与生命周期</h2><h3 id="2-1-播放模式选择"><a href="#2-1-播放模式选择" class="headerlink" title="2.1 播放模式选择"></a>2.1 播放模式选择</h3><table>
<thead>
<tr>
<th>模式</th>
<th>数据供给方式</th>
<th>典型场景</th>
<th>优势</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td><code>MODE_STREAM</code></td>
<td>边解码边 <code>write(...)</code></td>
<td>音乐、播客、直播、长音频</td>
<td>灵活、可持续播放</td>
<td>依赖写线程节拍和缓冲策略</td>
</tr>
<tr>
<td><code>MODE_STATIC</code></td>
<td>一次写入后播放</td>
<td>短音效、提示音</td>
<td>控制简单，触发快</td>
<td>不适合长音频，内存占用集中</td>
</tr>
</tbody></table>
<ul>
<li>播放器主链路建议默认 <code>MODE_STREAM</code>，只有短音频才优先 <code>MODE_STATIC</code>。</li>
</ul>
<h3 id="2-2-生命周期状态拆解"><a href="#2-2-生命周期状态拆解" class="headerlink" title="2.2 生命周期状态拆解"></a>2.2 生命周期状态拆解</h3><table>
<thead>
<tr>
<th>维度</th>
<th>典型状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始化状态</td>
<td><code>STATE_UNINITIALIZED</code> &#x2F; <code>STATE_INITIALIZED</code></td>
<td>反映对象是否可用</td>
</tr>
<tr>
<td>播放状态</td>
<td><code>PLAYSTATE_STOPPED</code> &#x2F; <code>PLAYSTATE_PAUSED</code> &#x2F; <code>PLAYSTATE_PLAYING</code></td>
<td>反映当前播放行为</td>
</tr>
<tr>
<td>资源状态</td>
<td><code>release</code> 后不可再用</td>
<td>释放后必须重建实例</td>
</tr>
</tbody></table>
<ul>
<li>生命周期上要区分“对象可用性”和“播放状态”，两者是不同维度。</li>
</ul>
<h3 id="2-3-核心控制-API-行为"><a href="#2-3-核心控制-API-行为" class="headerlink" title="2.3 核心控制 API 行为"></a>2.3 核心控制 API 行为</h3><table>
<thead>
<tr>
<th>API</th>
<th>对播放的影响</th>
<th>对缓冲的影响</th>
<th>常见使用时机</th>
</tr>
</thead>
<tbody><tr>
<td><code>play()</code></td>
<td>开始&#x2F;恢复播放</td>
<td>不清空缓冲</td>
<td>首播、暂停后恢复</td>
</tr>
<tr>
<td><code>pause()</code></td>
<td>暂停播放</td>
<td>保留缓冲数据</td>
<td>临时中断、可快速恢复</td>
</tr>
<tr>
<td><code>stop()</code></td>
<td>停止播放</td>
<td>已写入数据不再继续消费</td>
<td>切歌、主动停止</td>
</tr>
<tr>
<td><code>flush()</code></td>
<td>不直接触发播放</td>
<td>清空待播缓冲</td>
<td>切源、跳播、丢弃旧数据</td>
</tr>
<tr>
<td><code>release()</code></td>
<td>销毁实例</td>
<td>底层资源完全释放</td>
<td>退出播放、彻底重建</td>
</tr>
</tbody></table>
<ul>
<li><code>pause</code> 和 <code>stop</code> 的核心差异是“是否保留当前播放上下文”；<code>flush</code> 负责清理待播数据。</li>
</ul>
<h3 id="2-4-执行-API-与播放状态流程图"><a href="#2-4-执行-API-与播放状态流程图" class="headerlink" title="2.4 执行 API 与播放状态流程图"></a>2.4 执行 API 与播放状态流程图</h3><pre><code class=" mermaid">stateDiagram-v2
  [*] --&gt; STATE_UNINITIALIZED: new AudioTrack
  STATE_UNINITIALIZED --&gt; STATE_INITIALIZED: init success

  STATE_INITIALIZED --&gt; PLAYSTATE_STOPPED: ready
  PLAYSTATE_STOPPED --&gt; PLAYSTATE_PLAYING: play()
  PLAYSTATE_PLAYING --&gt; PLAYSTATE_PAUSED: pause()
  PLAYSTATE_PAUSED --&gt; PLAYSTATE_PLAYING: play()

  PLAYSTATE_PLAYING --&gt; PLAYSTATE_STOPPED: stop()
  PLAYSTATE_PAUSED --&gt; PLAYSTATE_STOPPED: stop()

  PLAYSTATE_STOPPED --&gt; PLAYSTATE_STOPPED: flush()
  PLAYSTATE_PAUSED --&gt; PLAYSTATE_PAUSED: flush()

  PLAYSTATE_STOPPED --&gt; RELEASED: release()
  PLAYSTATE_PAUSED --&gt; RELEASED: release()
  PLAYSTATE_PLAYING --&gt; RELEASED: stop() + release()
</code></pre>

<ul>
<li><code>flush()</code> 主要用于清空待播缓冲，常配合 <code>pause/stop</code> 使用。</li>
<li>对 <code>MODE_STREAM</code> 长音频来说，<code>play -&gt; write loop -&gt; pause/stop -&gt; release</code> 是主流程。</li>
</ul>
<h3 id="2-5-生命周期管理建议"><a href="#2-5-生命周期管理建议" class="headerlink" title="2.5 生命周期管理建议"></a>2.5 生命周期管理建议</h3><ul>
<li>业务状态和 AudioTrack 状态要同源更新，避免 UI 显示播放中但底层已停。</li>
<li>路由切换（蓝牙&#x2F;耳机）后，先确认参数是否变化，再决定 <code>flush</code> 还是重建。</li>
<li>任何 <code>release()</code> 之后都不要复用旧实例，统一走重建流程更安全。</li>
</ul>
<h3 id="2-6-API-合法性与推荐调用矩阵"><a href="#2-6-API-合法性与推荐调用矩阵" class="headerlink" title="2.6 API 合法性与推荐调用矩阵"></a>2.6 API 合法性与推荐调用矩阵</h3><table>
<thead>
<tr>
<th>当前状态</th>
<th><code>play()</code></th>
<th><code>write(...)</code></th>
<th><code>pause()</code></th>
<th><code>stop()</code></th>
<th><code>flush()</code></th>
<th><code>release()</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>STATE_UNINITIALIZED</code></td>
<td>不可用</td>
<td>不可用</td>
<td>不可用</td>
<td>不可用</td>
<td>不可用</td>
<td>可调用但无实际意义</td>
</tr>
<tr>
<td><code>STATE_INITIALIZED + PLAYSTATE_STOPPED</code></td>
<td>推荐</td>
<td>可调用（<code>MODE_STREAM</code> 可预填缓冲）</td>
<td>不建议</td>
<td>可调用（通常无必要）</td>
<td>可调用</td>
<td>推荐</td>
</tr>
<tr>
<td><code>PLAYSTATE_PLAYING</code></td>
<td>可重复调用（幂等）</td>
<td>推荐</td>
<td>推荐</td>
<td>推荐</td>
<td>不建议直接调用</td>
<td>建议先 <code>stop()</code> 再调用</td>
</tr>
<tr>
<td><code>PLAYSTATE_PAUSED</code></td>
<td>推荐（恢复播放）</td>
<td>可调用（继续填充缓冲）</td>
<td>可重复调用（幂等）</td>
<td>推荐</td>
<td>推荐</td>
<td>推荐</td>
</tr>
<tr>
<td><code>RELEASED</code></td>
<td>不可用</td>
<td>不可用</td>
<td>不可用</td>
<td>不可用</td>
<td>不可用</td>
<td>已释放</td>
</tr>
</tbody></table>
<ul>
<li>这张表强调的是“工程推荐顺序”，不是所有机型上的绝对 API 限制。</li>
</ul>
<h3 id="2-7-pause-stop-flush-场景决策表"><a href="#2-7-pause-stop-flush-场景决策表" class="headerlink" title="2.7 pause &#x2F; stop &#x2F; flush 场景决策表"></a>2.7 <code>pause</code> &#x2F; <code>stop</code> &#x2F; <code>flush</code> 场景决策表</h3><table>
<thead>
<tr>
<th>业务场景</th>
<th>推荐操作</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>短暂中断（来电、音频焦点短丢失）</td>
<td><code>pause()</code></td>
<td>保留当前上下文，恢复快</td>
</tr>
<tr>
<td>用户手动暂停</td>
<td><code>pause()</code></td>
<td>保留缓冲，继续播放时更平滑</td>
</tr>
<tr>
<td>切歌（旧数据必须丢弃）</td>
<td><code>stop() + flush()</code></td>
<td>立即终止旧流并清理待播缓存</td>
</tr>
<tr>
<td>Seek 到新位置</td>
<td><code>pause()/stop() + flush()</code> 后再 <code>play()</code></td>
<td>避免旧位置残留数据混入新位置</td>
</tr>
<tr>
<td>退出播放页或销毁播放器</td>
<td><code>stop() + release()</code></td>
<td>彻底释放底层资源</td>
</tr>
</tbody></table>
<ul>
<li>判断口诀：只想“暂时停”用 <code>pause</code>，要“切断旧流”用 <code>stop</code>，要“丢掉旧缓冲”加 <code>flush</code>。</li>
</ul>
<h2 id="三、AudioTrack-write机制与实战"><a href="#三、AudioTrack-write机制与实战" class="headerlink" title="三、AudioTrack write机制与实战"></a>三、AudioTrack write机制与实战</h2><h3 id="3-1-write-常见接口"><a href="#3-1-write-常见接口" class="headerlink" title="3.1 write(...) 常见接口"></a>3.1 <code>write(...)</code> 常见接口</h3><table>
<thead>
<tr>
<th>接口形态</th>
<th>数据类型</th>
<th>长度单位</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>write(byte[] ...)</code></td>
<td><code>byte</code></td>
<td>字节</td>
<td>16bit PCM 常见写法</td>
</tr>
<tr>
<td><code>write(short[] ...)</code></td>
<td><code>short</code></td>
<td>采样点（short）</td>
<td>已按 short 组织的 PCM 数据</td>
</tr>
<tr>
<td><code>write(float[] ...)</code></td>
<td><code>float</code></td>
<td>采样点（float）</td>
<td>浮点链路（<code>ENCODING_PCM_FLOAT</code>）</td>
</tr>
<tr>
<td><code>write(ByteBuffer, size, mode)</code></td>
<td><code>ByteBuffer</code></td>
<td>字节</td>
<td>NDK&#x2F;JNI 桥接与零拷贝场景</td>
</tr>
</tbody></table>
<ul>
<li>原则：<code>write</code> 数据格式要和 <code>AudioTrack</code> 的 <code>encoding + channel + sampleRate</code> 完整匹配。</li>
</ul>
<h3 id="3-2-阻塞与非阻塞写入"><a href="#3-2-阻塞与非阻塞写入" class="headerlink" title="3.2 阻塞与非阻塞写入"></a>3.2 阻塞与非阻塞写入</h3><table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
<th>优点</th>
<th>风险</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td><code>WRITE_BLOCKING</code></td>
<td>未写满前会等待</td>
<td>逻辑简单，节拍稳定</td>
<td>线程可能被长时间阻塞</td>
<td>常规音乐播放优先</td>
</tr>
<tr>
<td><code>WRITE_NON_BLOCKING</code></td>
<td>立即返回，可能短写</td>
<td>延迟可控，调度灵活</td>
<td>需要重试和补写策略</td>
<td>实时性要求高时使用</td>
</tr>
</tbody></table>
<ul>
<li>面试可直接回答：<code>BLOCKING</code> 偏稳定，<code>NON_BLOCKING</code> 偏低延迟与高控制。</li>
</ul>
<h3 id="3-3-write-返回值含义"><a href="#3-3-write-返回值含义" class="headerlink" title="3.3 write 返回值含义"></a>3.3 <code>write</code> 返回值含义</h3><table>
<thead>
<tr>
<th>返回值类型</th>
<th>含义</th>
<th>处理建议</th>
</tr>
</thead>
<tbody><tr>
<td><code>&gt; 0</code></td>
<td>本次成功写入（单位随接口而定）</td>
<td>累加 offset 继续写</td>
</tr>
<tr>
<td><code>= 0</code></td>
<td>本次未写入（常见于非阻塞）</td>
<td>短暂等待后重试</td>
</tr>
<tr>
<td><code>&lt; 0</code></td>
<td>错误码（如 <code>ERROR_BAD_VALUE</code> &#x2F; <code>ERROR_INVALID_OPERATION</code> &#x2F; <code>ERROR_DEAD_OBJECT</code>）</td>
<td>打日志并按错误类型恢复</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>典型错误码</th>
<th>常见原因</th>
<th>恢复动作</th>
</tr>
</thead>
<tbody><tr>
<td><code>ERROR_BAD_VALUE</code></td>
<td>参数越界、长度非法</td>
<td>校验 offset&#x2F;size 与数据单位</td>
</tr>
<tr>
<td><code>ERROR_INVALID_OPERATION</code></td>
<td>状态不合法或参数不匹配</td>
<td>检查 <code>STATE_INITIALIZED</code> 与格式配置</td>
</tr>
<tr>
<td><code>ERROR_DEAD_OBJECT</code></td>
<td>底层对象失效（路由&#x2F;设备变化后常见）</td>
<td><code>stop -&gt; flush -&gt; release -&gt; recreate</code></td>
</tr>
</tbody></table>
<h3 id="3-4-MODE-STREAM-写入主循环"><a href="#3-4-MODE-STREAM-写入主循环" class="headerlink" title="3.4 MODE_STREAM 写入主循环"></a>3.4 <code>MODE_STREAM</code> 写入主循环</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">while (playing) &#123;<br>  read pcm chunk<br>  result = audioTrack.write(data, offset, remain, writeMode)<br>  if (result &gt; 0) offset += result<br>  else if (result == 0) sleep/retry<br>  else handle error and maybe recreate<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>关键点只有两个：处理短写、处理错误返回。</li>
</ul>
<h3 id="3-5-写入链路的工程建议"><a href="#3-5-写入链路的工程建议" class="headerlink" title="3.5 写入链路的工程建议"></a>3.5 写入链路的工程建议</h3><ul>
<li>统一记录 <code>requested/written/costMs/playState</code>，便于后续问题定位。</li>
<li><code>WRITE_NON_BLOCKING</code> 必须有补写循环，否则容易出现数据断续。</li>
<li>发生 <code>ERROR_DEAD_OBJECT</code> 时优先重建，不要在旧实例上无限重试。</li>
<li><code>pause/stop/flush/release</code> 与 <code>write</code> 线程要串行化，避免并发状态竞争。</li>
</ul>
<h3 id="3-6-知识点补充：write-参数与返回值单位"><a href="#3-6-知识点补充：write-参数与返回值单位" class="headerlink" title="3.6 知识点补充：write 参数与返回值单位"></a>3.6 知识点补充：<code>write</code> 参数与返回值单位</h3><ul>
<li><code>write</code> 的 <code>offset/size</code> 与返回值单位，取决于你用的是哪种重载，不是所有接口都按字节计算。</li>
</ul>
<table>
<thead>
<tr>
<th><code>write</code> 形态</th>
<th><code>offset/size</code> 单位</th>
<th>返回值单位</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>write(byte[] ...)</code></td>
<td>字节</td>
<td>字节</td>
<td>16bit 链路最常见</td>
</tr>
<tr>
<td><code>write(short[] ...)</code></td>
<td><code>short</code> 采样点</td>
<td><code>short</code> 采样点</td>
<td>注意与字节长度换算</td>
</tr>
<tr>
<td><code>write(float[] ...)</code></td>
<td><code>float</code> 采样点</td>
<td><code>float</code> 采样点</td>
<td>常用于 <code>PCM_FLOAT</code></td>
</tr>
<tr>
<td><code>write(ByteBuffer, size, ...)</code></td>
<td>字节（<code>sizeInBytes</code>）</td>
<td>字节</td>
<td>NDK&#x2F;JNI 桥接常用</td>
</tr>
</tbody></table>
<ul>
<li>工程上最容易出错的是把 <code>float[]</code> 的长度当字节传，或把返回值按错误单位累计 offset。</li>
</ul>
<h3 id="3-7-知识点补充：write-调用自身阻塞"><a href="#3-7-知识点补充：write-调用自身阻塞" class="headerlink" title="3.7 知识点补充：write 调用自身阻塞"></a>3.7 知识点补充：<code>write</code> 调用自身阻塞</h3><ul>
<li>这是一个常见但容易误判的场景：数据已经拿到了，但 <code>write</code> 本身阻塞很久，导致渲染线程卡住。</li>
</ul>
<table>
<thead>
<tr>
<th>现象</th>
<th>可能根因</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BufferFill</code> 很快但总耗时高</td>
<td><code>WRITE_BLOCKING</code> 等待设备缓冲可写</td>
<td>下游消费速度跟不上上游写入节奏</td>
</tr>
<tr>
<td><code>write</code> 偶发长阻塞</td>
<td>路由切换&#x2F;设备状态波动</td>
<td>蓝牙切换、设备重配时常见</td>
</tr>
<tr>
<td>持续高阻塞</td>
<td>缓冲配置不合理或线程竞争</td>
<td>buffer 过小、系统调度抢占都会放大阻塞</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>建议观测指标</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td><code>fillCostMs</code>（拿数据耗时）</td>
<td>区分是不是上游供数慢</td>
</tr>
<tr>
<td><code>writeCostMs</code>（写入耗时）</td>
<td>定位是否是 <code>write</code> 阻塞本身</td>
</tr>
<tr>
<td><code>requested/written</code></td>
<td>判断是否伴随短写</td>
</tr>
<tr>
<td><code>playState + route</code></td>
<td>关联设备切换和状态变化</td>
</tr>
</tbody></table>
<ul>
<li>排查结论要先分层：先看 <code>fillCostMs</code>，再看 <code>writeCostMs</code>，避免把“下游写阻塞”误判成“上游没数据”。</li>
</ul>
<table>
<thead>
<tr>
<th>当前内核的简单检测方案</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>计时</td>
<td>在 <code>write</code> 前后记录耗时，得到 <code>frameRenderTime</code></td>
</tr>
<tr>
<td>对照基准</td>
<td>计算该批 PCM 理论播放时长 <code>pcmTime</code></td>
</tr>
<tr>
<td>判定条件</td>
<td><code>pcmTime &gt; 100ms</code> 且 <code>frameRenderTime &gt; 2 x pcmTime</code> 且 <code>frameRenderTime &gt; pcmTime + 200ms</code></td>
</tr>
<tr>
<td>上报</td>
<td>触发 <code>AMsgAudioRenderLagTime(3001)</code>，携带 <code>renderTime/pcmTime</code></td>
</tr>
</tbody></table>
<ul>
<li>这个方案的目标不是精确定位根因，而是先快速识别“当前卡顿更像写入阻塞”。</li>
</ul>
<h2 id="四、常用AudioTrack-API速查"><a href="#四、常用AudioTrack-API速查" class="headerlink" title="四、常用AudioTrack API速查"></a>四、常用AudioTrack API速查</h2><h3 id="4-1-音量相关-API（volume）"><a href="#4-1-音量相关-API（volume）" class="headerlink" title="4.1 音量相关 API（volume）"></a>4.1 音量相关 API（volume）</h3><table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
<th>返回&#x2F;参数</th>
<th>实战注意点</th>
</tr>
</thead>
<tbody><tr>
<td><code>setVolume(float volume)</code></td>
<td>设置当前 AudioTrack 的轨道音量增益</td>
<td><code>volume</code> 通常 <code>0.0~1.0</code></td>
<td>只影响当前 track，不等于系统媒体音量</td>
</tr>
<tr>
<td><code>getMaxVolume()</code></td>
<td>获取 AudioTrack 允许的最大音量值</td>
<td><code>float</code></td>
<td>主要用于边界校验，业务里较少直接依赖</td>
</tr>
<tr>
<td><code>getMinVolume()</code></td>
<td>获取 AudioTrack 允许的最小音量值</td>
<td><code>float</code></td>
<td>同上，常用于兜底范围判断</td>
</tr>
</tbody></table>
<ul>
<li><code>AudioTrack</code> 本身没有稳定的 <code>getVolume()</code> 来返回“当前最终听感音量”。</li>
<li>播放内核通常在业务层缓存当前设置值（例如 <code>mVolume</code>），作为“播放器音量状态”。</li>
<li>系统音量（媒体音量）应通过上层 <code>AudioManager</code> 获取并同步，不建议用 track 音量替代系统音量概念。</li>
</ul>
<table>
<thead>
<tr>
<th>获取 volume 目标</th>
<th>推荐方案</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>播放器当前音量</td>
<td>每次 <code>setVolume(v)</code> 时同步缓存 <code>v</code>（如 <code>mVolume</code>），读取时直接返回缓存值</td>
<td>最稳定，和业务状态一致</td>
</tr>
<tr>
<td>系统媒体音量</td>
<td>使用 <code>AudioManager.getStreamVolume(STREAM_MUSIC)</code></td>
<td>反映系统音量键调整结果</td>
</tr>
<tr>
<td>设备层音量变化通知</td>
<td>监听 <code>AMsgAudioTrackVolumeChanged</code>（或设备层回调）</td>
<td>用于 UI 同步与埋点观测</td>
</tr>
</tbody></table>
<ul>
<li>推荐做法：业务层维护 <code>playerVolume</code>，系统层维护 <code>systemVolume</code>，两者分开记录和展示。</li>
</ul>
<h3 id="4-2-延迟相关-API（getLatency）"><a href="#4-2-延迟相关-API（getLatency）" class="headerlink" title="4.2 延迟相关 API（getLatency）"></a>4.2 延迟相关 API（<code>getLatency</code>）</h3><table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
<th>返回</th>
<th>实战注意点</th>
</tr>
</thead>
<tbody><tr>
<td><code>getLatency()</code></td>
<td>查询当前输出链路的设备侧延迟估计</td>
<td><code>int</code>（ms）</td>
<td>机型差异明显，部分系统版本可能不可用或返回 <code>0</code></td>
</tr>
</tbody></table>
<ul>
<li><code>getLatency()</code> 更适合做趋势观测和偏移估计，不建议当作绝对精确值。</li>
<li>延迟分析建议配合分层模型一起看：<code>App Buffer + AudioTrack Buffer + AudioFlinger + HAL</code>。</li>
<li>当 <code>getLatency()</code> 不可用时，可退化为基于 buffer 和采样参数的估算方案。</li>
</ul>
<h3 id="4-3-getState-vs-getPlayState"><a href="#4-3-getState-vs-getPlayState" class="headerlink" title="4.3 getState vs getPlayState"></a>4.3 <code>getState</code> vs <code>getPlayState</code></h3><table>
<thead>
<tr>
<th>API</th>
<th>状态维度</th>
<th>常见值</th>
<th>典型用途</th>
<th>常见误区</th>
</tr>
</thead>
<tbody><tr>
<td><code>getState()</code></td>
<td>对象初始化状态</td>
<td><code>STATE_UNINITIALIZED</code> &#x2F; <code>STATE_INITIALIZED</code></td>
<td>判断 AudioTrack 实例是否可用</td>
<td>把它当成“正在播放”状态</td>
</tr>
<tr>
<td><code>getPlayState()</code></td>
<td>播放行为状态</td>
<td><code>PLAYSTATE_STOPPED</code> &#x2F; <code>PLAYSTATE_PAUSED</code> &#x2F; <code>PLAYSTATE_PLAYING</code></td>
<td>判断当前是否在播、暂停或停止</td>
<td>忽略对象本身是否已初始化</td>
</tr>
</tbody></table>
<ul>
<li>快速记法：<code>getState</code> 看“对象活没活”，<code>getPlayState</code> 看“播放动没动”。</li>
<li>排查时建议先看 <code>getState</code>，确认实例可用后再看 <code>getPlayState</code>。</li>
</ul>
<h3 id="4-4-使用建议（简版）"><a href="#4-4-使用建议（简版）" class="headerlink" title="4.4 使用建议（简版）"></a>4.4 使用建议（简版）</h3><ul>
<li>音量排查先分层：播放器音量、系统音量、设备路由音量分别看。</li>
<li>延迟排查先看“是否持续波动”，再看“是否超阈值”，避免单点值误判。</li>
<li>统一记录 <code>volume/route/latency/writeCostMs</code>，便于复盘问题。</li>
</ul>
<h2 id="五、常见问题处理"><a href="#五、常见问题处理" class="headerlink" title="五、常见问题处理"></a>五、常见问题处理</h2><h3 id="5-1-Underrun"><a href="#5-1-Underrun" class="headerlink" title="5.1 Underrun"></a>5.1 Underrun</h3><ul>
<li><code>Underrun</code> 本质是“设备要播放数据时，上游没及时喂够 PCM”，结果就是断续、卡顿、轻微爆音。</li>
</ul>
<table>
<thead>
<tr>
<th>判定信号</th>
<th>说明</th>
<th>处理优先级</th>
</tr>
</thead>
<tbody><tr>
<td><code>write</code> 短写（<code>written &lt; requested</code>）</td>
<td>最直接信号，常见于缓冲紧张或调度抖动</td>
<td>高</td>
</tr>
<tr>
<td><code>WRITE_NON_BLOCKING</code> 连续返回 <code>0</code></td>
<td>当前时刻没写进去，后续若不补写会快速放大风险</td>
<td>高</td>
</tr>
<tr>
<td><code>writeCostMs</code> 持续异常升高</td>
<td>下游消费速度跟不上，容易演变为断续</td>
<td>中</td>
</tr>
<tr>
<td>听感出现周期性“哒哒&#x2F;停顿”</td>
<td>用户感知层面的最终表现</td>
<td>高</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>常见触发原因</th>
<th>典型场景</th>
<th>快速动作</th>
</tr>
</thead>
<tbody><tr>
<td>上游供数慢</td>
<td>解码耗时突增、CPU 抢占</td>
<td>先确认 <code>fillCostMs</code> 是否异常</td>
</tr>
<tr>
<td>写线程被阻塞</td>
<td>锁竞争、系统调度抖动</td>
<td>检查 <code>writeCostMs</code> 与线程优先级</td>
</tr>
<tr>
<td>设备缓冲配置激进</td>
<td>过度追求低延迟，buffer 过小</td>
<td>从 <code>2 x minBuffer</code> 起回调</td>
</tr>
<tr>
<td>路由切换或设备重配</td>
<td>蓝牙&#x2F;耳机切换瞬间</td>
<td>必要时 <code>stop -&gt; flush -&gt; release -&gt; recreate</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>恢复策略</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>立即补写（短写补齐）</td>
<td>先止损，避免继续丢帧</td>
</tr>
<tr>
<td>临时增大 <code>bufferSizeInBytes</code></td>
<td>提升抗抖动能力</td>
</tr>
<tr>
<td>异常持续时重建 AudioTrack</td>
<td>清理失效状态，恢复稳定输出</td>
</tr>
<tr>
<td>降级编码链路（如 <code>PCM_FLOAT -&gt; PCM_16BIT</code>）</td>
<td>兼容优先，先保可播</td>
</tr>
</tbody></table>
<ul>
<li>排查顺序建议：先看 <code>requested/written</code>，再看 <code>fillCostMs/writeCostMs</code>，最后看路由与重建时序。</li>
</ul>
<h3 id="5-2-write-阻塞过高"><a href="#5-2-write-阻塞过高" class="headerlink" title="5.2 write 阻塞过高"></a>5.2 <code>write</code> 阻塞过高</h3><ul>
<li>这类问题的关键特征是：PCM 已经拿到，但 <code>write</code> 本身耗时偏高，最终把渲染线程拖慢。</li>
</ul>
<table>
<thead>
<tr>
<th>指标组合</th>
<th>结论倾向</th>
<th>下一步</th>
</tr>
</thead>
<tbody><tr>
<td><code>fillCostMs</code> 正常，<code>writeCostMs</code> 明显升高</td>
<td>下游写入阻塞</td>
<td>先查设备路由与缓冲策略</td>
</tr>
<tr>
<td><code>fillCostMs</code> 和 <code>writeCostMs</code> 都高</td>
<td>上游和下游都在抖动</td>
<td>先稳上游供数，再处理写入</td>
</tr>
<tr>
<td><code>requested</code> 正常，<code>written</code> 经常不足</td>
<td>写入压力过大，可能伴随 underrun</td>
<td>启用补写并观察阻塞是否持续</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>当前内核的判定参考</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>pcmTime &gt; 100ms</code></td>
<td>过滤过小片段的抖动噪声</td>
</tr>
<tr>
<td><code>frameRenderTime &gt; 2 x pcmTime</code> 且 <code>&gt; pcmTime + 200ms</code></td>
<td>判定“渲染明显落后”</td>
</tr>
<tr>
<td>上报 <code>AMsgAudioRenderLagTime(3001)</code></td>
<td>用于统一监控 write&#x2F;渲染滞后</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>常见根因</th>
<th>典型场景</th>
<th>处理动作</th>
</tr>
</thead>
<tbody><tr>
<td>路由切换瞬态阻塞</td>
<td>蓝牙切换、耳机插拔</td>
<td>观察是否短暂恢复，不恢复则重建</td>
</tr>
<tr>
<td>buffer 过小</td>
<td>低延迟配置过激进</td>
<td>从 <code>2 x minBuffer</code> 回调，必要时到 <code>4 x</code></td>
</tr>
<tr>
<td>线程竞争</td>
<td>锁粒度过大、CPU 抢占</td>
<td>收敛渲染线程临界区，避免重操作</td>
</tr>
<tr>
<td>设备状态异常</td>
<td>长时间阻塞或返回异常码</td>
<td><code>stop -&gt; flush -&gt; release -&gt; recreate</code></td>
</tr>
</tbody></table>
<ul>
<li>排查顺序建议：先确认是 <code>write</code> 慢，再判断是“瞬态阻塞”还是“持续阻塞”，最后决定调参还是重建。</li>
</ul>
<h3 id="5-3-无声但进度在走"><a href="#5-3-无声但进度在走" class="headerlink" title="5.3 无声但进度在走"></a>5.3 无声但进度在走</h3><ul>
<li>这类问题通常不是“播放器没跑起来”，而是“数据写入后没有正确到达目标输出设备”。</li>
</ul>
<table>
<thead>
<tr>
<th>现象</th>
<th>结论倾向</th>
<th>第一检查点</th>
</tr>
</thead>
<tbody><tr>
<td>进度持续增长，完全无声</td>
<td>路由或设备状态异常</td>
<td>当前输出设备是否切到蓝牙&#x2F;听筒</td>
</tr>
<tr>
<td>进度增长，偶发有声</td>
<td>参数&#x2F;会话状态不稳定</td>
<td>最近是否发生格式切换或重建</td>
</tr>
<tr>
<td>进度增长，音量条变化但听不到</td>
<td>音量层级不一致</td>
<td><code>playerVolume</code> 与 <code>systemVolume</code> 是否都正常</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>排查顺序</th>
<th>重点问题</th>
<th>通过标准</th>
</tr>
</thead>
<tbody><tr>
<td>1. 路由检查</td>
<td>是否写到预期设备</td>
<td>路由与用户当前设备一致</td>
</tr>
<tr>
<td>2. 播放状态检查</td>
<td><code>getPlayState</code> 是否真实处于播放中</td>
<td><code>PLAYSTATE_PLAYING</code> 且状态稳定</td>
</tr>
<tr>
<td>3. 参数匹配检查</td>
<td><code>sampleRate/channel/encoding</code> 是否一致</td>
<td>输入 PCM 与 AudioTrack 参数一致</td>
</tr>
<tr>
<td>4. 写入检查</td>
<td><code>write</code> 是否持续成功写入</td>
<td>返回值稳定 <code>&gt; 0</code>，无连续异常码</td>
</tr>
<tr>
<td>5. 会话与音效检查</td>
<td><code>sessionId</code>&#x2F;音效链路是否互相影响</td>
<td>不共享冲突会话或异常音效</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>常见根因</th>
<th>典型表现</th>
<th>处理动作</th>
</tr>
</thead>
<tbody><tr>
<td>路由切到非预期设备</td>
<td>看似在播但用户当前设备无声</td>
<td>触发路由同步，必要时重建 AudioTrack</td>
</tr>
<tr>
<td>参数不匹配</td>
<td>全程无声或伴随杂音后静音</td>
<td>统一参数并重建实例</td>
</tr>
<tr>
<td><code>ERROR_DEAD_OBJECT</code> 后未恢复</td>
<td>进度继续但底层对象已失效</td>
<td><code>stop -&gt; flush -&gt; release -&gt; recreate</code></td>
</tr>
<tr>
<td><code>sessionId</code> 复用冲突</td>
<td>某一路调整后另一条被静音或异常</td>
<td>拆分独立 <code>sessionId</code></td>
</tr>
<tr>
<td>音量层误判</td>
<td>设置了播放器音量但系统音量为 0</td>
<td>同步检查 <code>setVolume</code> 与系统媒体音量</td>
</tr>
</tbody></table>
<ul>
<li>快速恢复建议：先做 <code>stop -&gt; flush</code>，若仍无声直接 <code>release -&gt; recreate</code>，并在重建后重新下发 <code>volume/route/session</code> 相关状态。</li>
</ul>
<h3 id="5-4-爆音-卡顿-路由切换异常"><a href="#5-4-爆音-卡顿-路由切换异常" class="headerlink" title="5.4 爆音&#x2F;卡顿&#x2F;路由切换异常"></a>5.4 爆音&#x2F;卡顿&#x2F;路由切换异常</h3><ul>
<li>这三类问题常常是同一条链路上的不同表现：参数切换不平滑、缓冲节拍不稳定、路由恢复时序错误。</li>
</ul>
<table>
<thead>
<tr>
<th>现象</th>
<th>高频触发时机</th>
<th>结论倾向</th>
</tr>
</thead>
<tbody><tr>
<td>爆音&#x2F;破音</td>
<td>切歌、seek、格式切换瞬间</td>
<td>边界处理不完整（旧数据残留或格式突变）</td>
</tr>
<tr>
<td>周期性卡顿</td>
<td>高负载、后台切前台、蓝牙播放</td>
<td>缓冲或线程调度不稳</td>
</tr>
<tr>
<td>路由切换后异常</td>
<td>耳机插拔、蓝牙断连&#x2F;重连</td>
<td>旧设备未停干净或新设备未完整恢复</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>根因分类</th>
<th>典型问题</th>
<th>处理动作</th>
</tr>
</thead>
<tbody><tr>
<td>格式边界问题</td>
<td><code>sampleRate/channel/encoding</code> 变化但未重建</td>
<td>参数变化即重建 AudioTrack</td>
</tr>
<tr>
<td>缓冲策略激进</td>
<td><code>bufferSize</code> 过小，抖动放大</td>
<td>从 <code>2 x minBuffer</code> 回调，必要时 <code>4 x</code></td>
</tr>
<tr>
<td>写线程竞争</td>
<td>锁竞争、重操作占用渲染线程</td>
<td>缩小临界区，避免在渲染线程做重活</td>
</tr>
<tr>
<td>路由恢复时序错误</td>
<td>仍向旧设备写入或状态恢复不全</td>
<td><code>stop -&gt; flush -&gt; release -&gt; recreate</code> 后再恢复状态</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐 API 组合</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>切歌&#x2F;seek</td>
<td><code>pause/stop -&gt; flush -&gt; play</code></td>
<td>丢弃旧缓冲，避免残留杂音</td>
</tr>
<tr>
<td>参数变化</td>
<td><code>stop -&gt; release -&gt; recreate -&gt; play</code></td>
<td>保证参数与设备能力一致</td>
</tr>
<tr>
<td>路由切换</td>
<td><code>stop -&gt; flush/release -&gt; route ready -&gt; play</code></td>
<td>避免写入目标错位</td>
</tr>
<tr>
<td>持续异常</td>
<td><code>recreate + 参数降级</code>（如 <code>PCM_FLOAT -&gt; PCM_16BIT</code>）</td>
<td>先保稳定可播</td>
</tr>
</tbody></table>
<ul>
<li>排查顺序建议：先确认是否“参数变化未重建”，再看 <code>buffer</code> 与 <code>write</code> 指标，最后核对路由切换时序。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" class="print-no-link">#音视频</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Android音频技术攻略-AudioTrack相关</div>
      <div>https://leo-wxy.github.io/2026/02/16/Android音频技术攻略-AudioTrack相关/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Leo-Wxy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2026年2月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2026/02/16/Android%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF%E6%94%BB%E7%95%A5-FFmpeg%E7%9B%B8%E5%85%B3/" title="Android音频技术攻略-FFmpeg相关">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android音频技术攻略-FFmpeg相关</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2026/02/16/Android-Binder%E5%88%86%E6%9E%90/" title="Android-Binder分析">
                        <span class="hidden-mobile">Android-Binder分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
