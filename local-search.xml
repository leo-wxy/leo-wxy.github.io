<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android布局优化-AsyncLayoutInflater简析</title>
    <link href="/2020/11/02/Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96-AsyncLayoutInflater%E7%AE%80%E6%9E%90/"/>
    <url>/2020/11/02/Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96-AsyncLayoutInflater%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/AsyncLayoutInflater.png" srcset="/img/loading.gif" alt="AsyncLayoutInflater"></p><p>布局加载过程中存在两个耗时点：</p><ol><li>布局文件读取慢，涉及IO操作</li><li>根据<code>&lt;tag&gt;</code>创建View慢(<code>createViewFromTag()</code>)，使用反射的方式创建View。<em>布局嵌套层数越多，控件个数越多，反射的次数就会越多</em>。</li></ol><p>当XML文件过大、嵌套过深时，就会导致页面发生卡顿甚至ANR。</p><p>解决方案有两种：</p><ol><li><strong>直接解决</strong>：不使用IO操作以及反射</li><li><strong>侧面缓解</strong>：把耗时操作放到子线程，等待加载完毕返回主线程展示即可。下面提到的<code>AsyncLayoutInflater</code>就是使用这个方案。</li></ol><h2 id="AsyncLayoutInflater"><a href="#AsyncLayoutInflater" class="headerlink" title="AsyncLayoutInflater"></a>AsyncLayoutInflater</h2><p>采用<strong>异步加载</strong>的方式去加载布局，可以节省主线程时间，并且在异步加载完毕后回到主线程。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><pre><code class="hljs java"><span class="hljs-keyword">new</span> AsyncLayoutInflater(<span class="hljs-keyword">this</span>).inflate(R.layout.XX, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> AsyncLayoutInflater.OnInflateFinishedListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInflateFinished</span><span class="hljs-params">(@NonNull View view, <span class="hljs-keyword">int</span> i, @Nullable ViewGroup viewGroup)</span> </span>&#123;        setContentView(view);    &#125;&#125;);</code></pre><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncLayoutInflater</span> </span>&#123;    LayoutInflater mInflater;<span class="hljs-comment">//布局加载器</span>    Handler mHandler;<span class="hljs-comment">//处理加载完成消息</span>    InflateThread mInflateThread;<span class="hljs-comment">//执行加载任务</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncLayoutInflater</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;        mInflater = <span class="hljs-keyword">new</span> BasicInflater(context);        mHandler = <span class="hljs-keyword">new</span> Handler(mHandlerCallback);        mInflateThread = InflateThread.getInstance();    &#125;&#125;</code></pre><h4 id="BasicInflater"><a href="#BasicInflater" class="headerlink" title="BasicInflater"></a>BasicInflater</h4><p>自定义加载器。实现类似<code>PhoneLayoutInflater(默认布局加载器)</code></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicInflater</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LayoutInflater</span> </span>&#123;  <span class="hljs-comment">//优先在这三个包下加载</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] sClassPrefixList = &#123;        <span class="hljs-string">"android.widget."</span>,        <span class="hljs-string">"android.webkit."</span>,        <span class="hljs-string">"android.app."</span>    &#125;;    BasicInflater(Context context) &#123;        <span class="hljs-keyword">super</span>(context);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> LayoutInflater <span class="hljs-title">cloneInContext</span><span class="hljs-params">(Context newContext)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicInflater(newContext);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, AttributeSet attrs)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;        <span class="hljs-keyword">for</span> (String prefix : sClassPrefixList) &#123;            <span class="hljs-keyword">try</span> &#123;              <span class="hljs-comment">//加载View</span>                View view = createView(name, prefix, attrs);                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">return</span> view;                &#125;            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                <span class="hljs-comment">// In this case we want to let the base class take a crack</span>                <span class="hljs-comment">// at it.</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onCreateView(name, attrs);    &#125;&#125;</code></pre><h4 id="InflateThread"><a href="#InflateThread" class="headerlink" title="InflateThread"></a>InflateThread</h4><p>创建子线程，将<code>布局加载</code>请求加入<code>阻塞队列</code>中，按照插入顺序执行<code>LayoutInflater.inflate()</code>加载过程</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InflateThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InflateThread sInstance;    <span class="hljs-keyword">static</span> &#123;        sInstance = <span class="hljs-keyword">new</span> InflateThread();        sInstance.start();    &#125;  <span class="hljs-comment">//阻塞队列 最多支持10个加载请求</span>    <span class="hljs-keyword">private</span> ArrayBlockingQueue&lt;InflateRequest&gt; mQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">10</span>);  <span class="hljs-comment">//对象池，缓存InflateThread对象</span>    <span class="hljs-keyword">private</span> SynchronizedPool&lt;InflateRequest&gt; mRequestPool = <span class="hljs-keyword">new</span> SynchronizedPool&lt;&gt;(<span class="hljs-number">10</span>);      <span class="hljs-comment">//对象池获取缓存对象</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> InflateRequest <span class="hljs-title">obtainRequest</span><span class="hljs-params">()</span> </span>&#123;        InflateRequest obj = mRequestPool.acquire();        <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;            obj = <span class="hljs-keyword">new</span> InflateRequest();        &#125;        <span class="hljs-keyword">return</span> obj;    &#125;  <span class="hljs-comment">//对象池回收对象，便于下次复用</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseRequest</span><span class="hljs-params">(InflateRequest obj)</span> </span>&#123;        obj.callback = <span class="hljs-keyword">null</span>;        obj.inflater = <span class="hljs-keyword">null</span>;        obj.parent = <span class="hljs-keyword">null</span>;        obj.resid = <span class="hljs-number">0</span>;        obj.view = <span class="hljs-keyword">null</span>;        mRequestPool.release(obj);    &#125;        <span class="hljs-comment">//将inflate请求添加到 阻塞队列中</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(InflateRequest request)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            mQueue.put(request);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                    <span class="hljs-string">"Failed to enqueue async inflate request"</span>, e);        &#125;    &#125;  <span class="hljs-comment">//需要执行的任务</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runInner</span><span class="hljs-params">()</span> </span>&#123;        InflateRequest request;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-comment">//阻塞队列获取 任务，没任务则阻塞</span>            request = mQueue.take();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;            <span class="hljs-comment">// Odd, just continue</span>            Log.w(TAG, ex);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-comment">//调用BasicInflater去加载布局</span>            request.view = request.inflater.mInflater.inflate(                    request.resid, request.parent, <span class="hljs-keyword">false</span>);        &#125; <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;            <span class="hljs-comment">// Probably a Looper failure, retry on the UI thread</span>            Log.w(TAG, <span class="hljs-string">"Failed to inflate resource in the background! Retrying on the UI"</span>                    + <span class="hljs-string">" thread"</span>, ex);        &#125;      <span class="hljs-comment">//构建消息发送到Handler</span>        Message.obtain(request.inflater.mHandler, <span class="hljs-number">0</span>, request)                .sendToTarget();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            runInner();        &#125;    &#125;      &#125;</code></pre><p><code>InflateThread</code>不管最后<code>inflate()</code>执行成功或失败，都会把结果发回到Handler进行处理。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> Handler.Callback mHandlerCallback = <span class="hljs-keyword">new</span> Handler.Callback() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;      <span class="hljs-comment">//获取加载结果</span>        InflateRequest request = (InflateRequest) msg.obj;        <span class="hljs-keyword">if</span> (request.view == <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-comment">//异步加载失败，在主线程进行加载过程</span>            request.view = mInflater.inflate(                    request.resid, request.parent, <span class="hljs-keyword">false</span>);        &#125;      <span class="hljs-comment">//加载完成回调</span>        request.callback.onInflateFinished(                request.view, request.resid, request.parent);      <span class="hljs-comment">//回收加载请求</span>        mInflateThread.releaseRequest(request);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;;</code></pre><p><code>Handler</code>收到消息后，根据<code>InflateRequest.view</code>是否为空，判断接下执行步骤：</p><p>如果为空，回到主线程进行布局加载任务，加载完成后回调<code>onInflateFinished()</code></p><p>不为空，直接回调<code>onInflateFinished()</code></p><h3 id="inflate"><a href="#inflate" class="headerlink" title="inflate()"></a>inflate()</h3><p>发起异步加载布局请求</p><pre><code class="hljs java"><span class="hljs-meta">@UiThread</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inflate</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> resid, @Nullable ViewGroup parent,        @NonNull OnInflateFinishedListener callback)</span> </span>&#123;    <span class="hljs-keyword">if</span> (callback == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"callback argument may not be null!"</span>);    &#125;  <span class="hljs-comment">//构建InflateRequest对象</span>    InflateRequest request = mInflateThread.obtainRequest();    request.inflater = <span class="hljs-keyword">this</span>;    request.resid = resid;    request.parent = parent;    request.callback = callback;  <span class="hljs-comment">//插入加载请求到阻塞队列</span>    mInflateThread.enqueue(request);&#125;</code></pre><h4 id="InflateRequest"><a href="#InflateRequest" class="headerlink" title="InflateRequest"></a>InflateRequest</h4><p>主线程和子线程之间传递的数据模型，主要封装了<code>异步加载</code>需要的参数</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InflateRequest</span> </span>&#123;    AsyncLayoutInflater inflater;<span class="hljs-comment">//加载器</span>    ViewGroup parent;<span class="hljs-comment">//父布局</span>    <span class="hljs-keyword">int</span> resid;<span class="hljs-comment">//布局id</span>    View view;<span class="hljs-comment">//加载完成的View</span>    OnInflateFinishedListener callback;<span class="hljs-comment">//加载完成回调</span>    InflateRequest() &#123;    &#125;&#125;</code></pre><h4 id="OnInflateFinishedListener"><a href="#OnInflateFinishedListener" class="headerlink" title="OnInflateFinishedListener"></a>OnInflateFinishedListener</h4><p>布局加载完成后回调</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnInflateFinishedListener</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onInflateFinished</span><span class="hljs-params">(@NonNull View view, //加载完成的View                           @LayoutRes <span class="hljs-keyword">int</span> resid,            @Nullable ViewGroup parent)</span></span>;&#125;</code></pre><blockquote><p>使用<code>AsyncLayoutInflater</code>加载布局后，将需要加载的<code>layoutId</code>以及<code>OnInflateFinishedListener</code>构造成<code>InflateRequest</code>，插入到<code>InflateThread</code>的阻塞队列中，等待执行。任务执行完毕后，返回执行结果(<code>成功返回加载后的View，失败返回null</code>)。</p><p>通过<code>Handler</code>发送结果回到主线程，返回结果为<code>null</code>，则在主线程再次执行<code>布局加载</code>，得到结果后直接回调<code>onInflateFinished()</code>。</p></blockquote><h2 id="局限及改进"><a href="#局限及改进" class="headerlink" title="局限及改进"></a>局限及改进</h2><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><ol><li><code>AsyncLayoutInflater</code>构造的<code>View</code>，无法直接使用<code>handler</code>或者调用<code>looper.myLooper</code>，因为没有进行初始化</li><li><code>AsyncLayoutInflater</code>构造的<code>View</code>，不会自动加到<code>parent</code>中，需要手动加入</li><li><code>AsyncLayoutInflater</code>不支持设置<code>Factory/Factory2</code>，未设置<code>mPrivateFactory</code>所以不支持包含<code>&lt;fragment&gt;</code>的布局</li><li>最多支持10个布局加载，超出的布局需要等待。</li></ol><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><blockquote><p><code>AsyncLayoutInflater</code>是<code>final</code>的，无法被继承。需要<code>copy</code>一份代码进行修改。</p></blockquote><p>针对<code>4</code>可以内部替换成线程池，将加载布局请求放入线程池管理</p><p>针对<code>3</code>可以修改<code>BasicInflater</code>实现，内部支持<code>factory</code>设置</p><pre><code class="hljs java">BasicInflater(Context context) &#123;    <span class="hljs-keyword">super</span>(context);    <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> AppCompatActivity) &#123;        <span class="hljs-comment">// 加上这些可以保证AppCompatActivity的情况下，super.onCreate之前</span>        <span class="hljs-comment">// 使用AsyncLayoutInflater加载的布局也拥有默认的效果</span>        AppCompatDelegate appCompatDelegate = ((AppCompatActivity) context).getDelegate();        <span class="hljs-keyword">if</span> (appCompatDelegate <span class="hljs-keyword">instanceof</span> LayoutInflater.Factory2) &#123;            LayoutInflaterCompat.setFactory2(<span class="hljs-keyword">this</span>, (LayoutInflater.Factory2) appCompatDelegate);        &#125;    &#125;&#125;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/8548db25a475" target="_blank" rel="noopener">AsyncLayoutInfalter</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android匿名共享内存-Ashmem</title>
    <link href="/2020/10/31/Android%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-Ashmem/"/>
    <url>/2020/10/31/Android%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-Ashmem/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android硬件加速</title>
    <link href="/2020/10/27/Android%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
    <url>/2020/10/27/Android%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/Android硬件加速.png" srcset="/img/loading.gif" alt="Android硬件加速xmind"></p><h2 id="软硬件绘制的分歧点"><a href="#软硬件绘制的分歧点" class="headerlink" title="软硬件绘制的分歧点"></a>软硬件绘制的分歧点</h2><p>绘制过程入口位于<code>ViewRootImpl.performDraw()</code>中</p><pre><code class="hljs java"><span class="hljs-comment">//viewRootImpl.java</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performDraw</span><span class="hljs-params">()</span> </span>&#123;      ...        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//调用draw()执行实际的绘制工作</span>            <span class="hljs-keyword">boolean</span> canUseAsync = draw(fullRedrawNeeded);            <span class="hljs-keyword">if</span> (usingAsyncReport &amp;&amp; !canUseAsync) &#123;                mAttachInfo.mThreadedRenderer.setFrameCompleteCallback(<span class="hljs-keyword">null</span>);                usingAsyncReport = <span class="hljs-keyword">false</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            mIsDrawing = <span class="hljs-keyword">false</span>;            Trace.traceEnd(Trace.TRACE_TAG_VIEW);        &#125;    &#125;</code></pre><p><code>ViewRootImpl.draw()</code>实际执行的绘制工作</p><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;  ...    <span class="hljs-keyword">final</span> Rect dirty = mDirty;<span class="hljs-comment">//需要重新绘制的区域</span>  ...    <span class="hljs-keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;            <span class="hljs-comment">//是否支持硬件加速</span>            <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;              ...                mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="hljs-keyword">this</span>, callback);<span class="hljs-comment">//硬件绘制</span>            &#125; <span class="hljs-keyword">else</span> &#123;              ...                <span class="hljs-comment">//软件绘制</span>                <span class="hljs-keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,                        scalingRequired, dirty, surfaceInsets)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;      ...    &#125;  ...  &#125;</code></pre><h2 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h2><p><img src="/images/Android绘制-软件绘制.png" srcset="/img/loading.gif" alt="Android绘制-软件绘制"></p><h3 id="ViewRootImpl软件绘制相关"><a href="#ViewRootImpl软件绘制相关" class="headerlink" title="ViewRootImpl软件绘制相关"></a>ViewRootImpl软件绘制相关</h3><blockquote><p>未开启<code>硬件加速</code>时，执行到<code>drawSoftware()</code></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">drawSoftware</span><span class="hljs-params">(Surface surface, AttachInfo attachInfo, <span class="hljs-keyword">int</span> xoff, <span class="hljs-keyword">int</span> yoff,        <span class="hljs-keyword">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> </span>&#123;    <span class="hljs-comment">// Draw with software renderer.</span>    <span class="hljs-keyword">final</span> Canvas canvas;     canvas = mSurface.lockCanvas(dirty);<span class="hljs-comment">//获取用于绘制的Canvas</span>   ...   mView.draw(canvas);<span class="hljs-comment">//将mView的内容绘制到Canvas</span>   ...   <span class="hljs-comment">//将Canvas的内容显示到屏幕上,向SurfaceFlinger服务Queue一个Graphic Buffer</span>   surface.unlockCanvasAndPost(canvas);&#125;</code></pre><p>此处的<code>mView</code>对应的就是<code>DecorView</code></p><pre><code class="hljs java"><span class="hljs-comment">//DecorView.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;        <span class="hljs-keyword">super</span>.draw(canvas);        <span class="hljs-keyword">if</span> (mMenuBackground != <span class="hljs-keyword">null</span>) &#123;            mMenuBackground.draw(canvas);        &#125;    &#125;</code></pre><p>执行到<code>super.draw()</code>，<code>DecorView</code>继承自<code>FrameLayout</code>，等价于执行到<code>ViewGroup.draw()</code>。</p><pre><code class="hljs java"><span class="hljs-comment">//View.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;      ...        <span class="hljs-keyword">if</span> (!dirtyOpaque) &#123;          <span class="hljs-comment">//绘制背景</span>            drawBackground(canvas);        &#125;        <span class="hljs-comment">//绘制自身</span>        <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);        <span class="hljs-comment">//绘制子View 只有ViewGroup会实现该方法</span>        dispatchDraw(canvas);        <span class="hljs-comment">//绘制前景</span>        onDrawForeground(canvas);      ...    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//ViewGroup.java</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;      ...        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties                ? <span class="hljs-keyword">null</span> : buildOrderedChildList();<span class="hljs-comment">//绘制顺序按照Z值从大到小排列</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = preorderedList == <span class="hljs-keyword">null</span>                &amp;&amp; isChildrenDrawingOrderEnabled();<span class="hljs-comment">//允许自定义绘制顺序</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;            <span class="hljs-keyword">while</span> (transientIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;                <span class="hljs-keyword">final</span> View transientChild = mTransientViews.get(transientIndex);                <span class="hljs-keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||                        transientChild.getAnimation() != <span class="hljs-keyword">null</span>) &#123;                    more |= drawChild(canvas, transientChild, drawingTime);                &#125;                transientIndex++;                <span class="hljs-keyword">if</span> (transientIndex &gt;= transientCount) &#123;                    transientIndex = -<span class="hljs-number">1</span>;                &#125;            &#125;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<span class="hljs-comment">//根据自定义顺序获取当前绘制的View的绘制顺序</span>            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;                more |= drawChild(canvas, child, drawingTime);            &#125;        &#125;    &#125;    <span class="hljs-comment">//绘制子View</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">drawChild</span><span class="hljs-params">(Canvas canvas, View child, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;        <span class="hljs-keyword">return</span> child.draw(canvas, <span class="hljs-keyword">this</span>, drawingTime);    &#125;</code></pre><p><code>DecorView</code>是最顶层的View，自<code>drawSoftware()</code>开始绘制。</p><h3 id="View软件绘制相关"><a href="#View软件绘制相关" class="headerlink" title="View软件绘制相关"></a>View软件绘制相关</h3><p>上一节后面执行到了<code>child.draw()</code>，<code>child</code>为<code>View</code></p><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();        <span class="hljs-comment">//是否支持硬件绘制 显然当前情况不支持</span>        <span class="hljs-keyword">boolean</span> drawingWithRenderNode = mAttachInfo != <span class="hljs-keyword">null</span>                &amp;&amp; mAttachInfo.mHardwareAccelerated                &amp;&amp; hardwareAcceleratedCanvas;           ...           <span class="hljs-comment">//后续绘制缓存会分析</span>          <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123;             <span class="hljs-keyword">if</span> (layerType != LAYER_TYPE_NONE) &#123;                 <span class="hljs-comment">// If not drawing with RenderNode, treat HW layers as SW</span>                 layerType = LAYER_TYPE_SOFTWARE;                 buildDrawingCache(<span class="hljs-keyword">true</span>);            &#125;            cache = getDrawingCache(<span class="hljs-keyword">true</span>);         &#125;         <span class="hljs-comment">//缓存可用 且 非硬件绘制条件下</span>         <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> drawingWithDrawingCache = cache != <span class="hljs-keyword">null</span> &amp;&amp; !drawingWithRenderNode;         ...         <span class="hljs-keyword">if</span> (!drawingWithDrawingCache) &#123;            <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;                ((DisplayListCanvas) canvas).drawRenderNode(renderNode);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// ViewGroup 不需要绘制背景直接 绘制子View</span>                <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;                    dispatchDraw(canvas);                &#125; <span class="hljs-keyword">else</span> &#123;                    draw(canvas);                &#125;            &#125;        &#125;       ...&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//View.java</span>        <span class="hljs-keyword">if</span> ((changed &amp; DRAW_MASK) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> ((mViewFlags &amp; WILL_NOT_DRAW) != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (mBackground != <span class="hljs-keyword">null</span>                        || mDefaultFocusHighlight != <span class="hljs-keyword">null</span>                        || (mForegroundInfo != <span class="hljs-keyword">null</span> &amp;&amp; mForegroundInfo.mDrawable != <span class="hljs-keyword">null</span>)) &#123;                    mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;                &#125; <span class="hljs-keyword">else</span> &#123;                    mPrivateFlags |= PFLAG_SKIP_DRAW;                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;            &#125;            requestLayout();            invalidate(<span class="hljs-keyword">true</span>);        &#125;</code></pre><h3 id="软件绘制流程"><a href="#软件绘制流程" class="headerlink" title="软件绘制流程"></a>软件绘制流程</h3><p><img src="/images/软件绘制流程.jpg" srcset="/img/loading.gif" alt="软件绘制流程"></p><h2 id="硬件绘制"><a href="#硬件绘制" class="headerlink" title="硬件绘制"></a>硬件绘制</h2><blockquote><p>默认开启<code>硬件加速</code>，可以通过配置<code>android:hardwareAccelerated=&quot;false&quot;</code>关闭硬件加速</p><p><code>把View中绘制的计算工作交给GPU来处理，就是把drawXX()相关的方法进行转换。</code></p></blockquote><p><code>硬件绘制</code>主要包含两步：</p><ul><li><p><code>构建阶段</code></p><blockquote><p>遍历所有View，将需要绘制的操作缓存下来，构建<code>DisplayList</code>。交给<code>RenderThread</code>使用GPU进行硬件加速渲染。</p></blockquote></li><li><p><code>绘制阶段</code></p><blockquote><p>构建好的<code>DisplayList</code>交给<code>RenderThread</code>使用GPU进行硬件加速渲染，绘制的内容保存在<code>Graphic Buffer</code>并交由<code>SurfaceFlinger</code>显示。</p></blockquote></li></ul><h3 id="控制硬件加速"><a href="#控制硬件加速" class="headerlink" title="控制硬件加速"></a>控制硬件加速</h3><p><img src="/images/硬件绘制-控制硬件加速.png" srcset="/img/loading.gif" alt="硬件绘制-控制硬件加速"></p><blockquote><p>硬件绘制需要在<code>开启硬件加速</code>的条件下才可以执行</p></blockquote><p>可以在以下级别控制<code>硬件加速</code>：</p><ul><li><p><strong>应用</strong></p><p>在<code>AndroidManifest.xml</code>配置如下属性</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">...</span>&gt;</span></code></pre></li></ul><ul><li><p><strong>Activity</strong></p><p>在<code>AndroidManifest.xml</code>配置如下属性</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"true"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">...</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"false"</span> /&gt;</span> //控制某个Activity关闭硬件加速  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span></code></pre></li></ul><ul><li><p><strong>窗口Window</strong></p><p>配置如下代码</p><pre><code class="hljs java">getWindow().setFlags(    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);</code></pre></li></ul><ul><li><p><strong>视图View</strong></p><p>为单个视图停用硬件加速</p><pre><code class="hljs java">myView.setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="hljs-keyword">null</span>);</code></pre></li></ul><h3 id="DisplayList"><a href="#DisplayList" class="headerlink" title="DisplayList"></a>DisplayList</h3><p><img src="/images/硬件绘制-DisplayList.png" srcset="/img/loading.gif" alt="硬件绘制-DisplayList"></p><blockquote><p>本质上是一个<strong>缓冲区</strong>，里面<code>记录即将执行的绘制命令序列</code>。</p></blockquote><p><code>DisplayList</code>的存在有两个好处：</p><ol><li><p>在绘制下一帧时，若View没有发生变化，就不必执行相关绘制API，直接复用上次的<code>DisplayList</code>。</p></li><li><p>在绘制下一帧时，若View发生变化，但只是一些简单属性发生变化，就不需重建<code>DisplayList</code>，直接修改<code>DisplayList</code>相关属性即可。</p><p>针对以下属性，都不需重建<code>DisplayList</code></p><ul><li><code>alpha</code>：更改层的不透明度</li><li><code>x</code>、<code>y</code>、<code>translationX</code>、<code>translationY</code>：更改层的位置</li><li><code>scaleX</code>、<code>scaleY</code>：更改层的大小</li><li><code>rotation</code>、<code>rotationX</code>、<code>rotationY</code>：更改层在 3D 空间里的方向</li><li><code>pivotX</code>、<code>pivotY</code>：更改层的转换原点</li></ul></li></ol><p>以上在使用<code>DisplayList</code>的过程都不需要执行<code>onDraw()</code>。</p><p><img src="/images/DisplayList结构.png" srcset="/img/loading.gif" alt="img"></p><h3 id="RenderNode"><a href="#RenderNode" class="headerlink" title="RenderNode"></a>RenderNode</h3><blockquote><p>在Android 5.0后引入，是对<code>DisplayList</code>以及<code>View显示属性</code>的封装。</p></blockquote><p><strong>通常一个<code>RenderNode</code>对应一个<code>View</code>，包含了View自身及其子View的所有DisplayList。</strong></p><p>其中还有一个<code>RootRenderNode</code>，里面包含着<code>View层次结构中所有View的DisplayList信息</code>。</p><h3 id="ViewRootImpl硬件绘制相关"><a href="#ViewRootImpl硬件绘制相关" class="headerlink" title="ViewRootImpl硬件绘制相关"></a>ViewRootImpl硬件绘制相关</h3><blockquote><p>只有当前View支持<code>硬件加速</code>时，才可以进入<code>硬件绘制</code></p><p><code>if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled())</code></p></blockquote><p><img src="/images/硬件绘制-构建DisplayList.png" srcset="/img/loading.gif" alt="硬件绘制-构建DisplayList"></p><h4 id="ThreadedRenderer-draw"><a href="#ThreadedRenderer-draw" class="headerlink" title="ThreadedRenderer.draw()"></a>ThreadedRenderer.draw()</h4><blockquote><p><code>ThreadedRenderer</code>在UI线程创建，主要执行了两步：</p><ul><li>构建View的DrawOp树，就是<code>DisplayList</code>。<code>DrawOp 表示 Drawing Operations</code></li><li>与渲染线程(<code>RenderThread</code>)进行通信</li></ul></blockquote><pre><code class="hljs java"><span class="hljs-comment">//ThreadedRenderer.java</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks,          FrameDrawingCallback frameDrawingCallback)</span> </span>&#123;      attachInfo.mIgnoreDirtyState = <span class="hljs-keyword">true</span>;      <span class="hljs-keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;      choreographer.mFrameInfo.markDrawStart();      <span class="hljs-comment">//构建View的DrawOp树</span>      updateRootDisplayList(view, callbacks);      ...      <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] frameInfo = choreographer.mFrameInfo.mFrameInfo;      <span class="hljs-keyword">if</span> (frameDrawingCallback != <span class="hljs-keyword">null</span>) &#123;          nSetFrameCallback(mNativeProxy, frameDrawingCallback);      &#125;      <span class="hljs-comment">//通知RenderThread线程绘制</span>      <span class="hljs-keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);      ...  &#125;</code></pre><h4 id="updateRootDisplayList"><a href="#updateRootDisplayList" class="headerlink" title="updateRootDisplayList()"></a>updateRootDisplayList()</h4><blockquote><p>构建<code>DrawOp</code>树，构建<code>RootDisplayList</code></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateRootDisplayList</span><span class="hljs-params">(View view, DrawCallbacks callbacks)</span> </span>&#123;   <span class="hljs-comment">//更新View的displayList</span>    updateViewTreeDisplayList(view);    <span class="hljs-keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;       <span class="hljs-comment">//获取DisplayCanvas</span>        DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> saveCount = canvas.save();            canvas.translate(mInsetLeft, mInsetTop);            callbacks.onPreDraw(canvas);            canvas.insertReorderBarrier();           <span class="hljs-comment">//displayListCanvas缓存View对应的drawOp节点</span>            canvas.drawRenderNode(view.updateDisplayListIfDirty());            canvas.insertInorderBarrier();            callbacks.onPostDraw(canvas);            canvas.restoreToCount(saveCount);            mRootNodeNeedsUpdate = <span class="hljs-keyword">false</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-comment">//RootRenderNode填充所有节点</span>            mRootNode.end(canvas);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewTreeDisplayList</span><span class="hljs-params">(View view)</span> </span>&#123;    view.mPrivateFlags |= View.PFLAG_DRAWN;    view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)<span class="hljs-comment">//invalidate()对应标记</span>            == View.PFLAG_INVALIDATED;<span class="hljs-comment">//初始DecorView默认为 true</span>    view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;    view.updateDisplayListIfDirty();<span class="hljs-comment">//更新节点</span>    view.mRecreateDisplayList = <span class="hljs-keyword">false</span>;&#125;</code></pre><h4 id="DecorView-updateDisplayListIfDirty"><a href="#DecorView-updateDisplayListIfDirty" class="headerlink" title="DecorView.updateDisplayListIfDirty()"></a>DecorView.updateDisplayListIfDirty()</h4><blockquote><p><code>updateRootDisplayList()</code>中对应的View就是<code>DecorView</code>，是所有View的顶层。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><span class="hljs-meta">@NonNull</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RenderNode <span class="hljs-title">updateDisplayListIfDirty</span><span class="hljs-params">()</span> </span>&#123;      ...        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="hljs-number">0</span>                || !renderNode.isValid()                || (mRecreateDisplayList)) &#123;          ...          <span class="hljs-keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);          <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;<span class="hljs-comment">//是否强制软件绘制</span>                    buildDrawingCache(<span class="hljs-keyword">true</span>);                    Bitmap cache = getDrawingCache(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//获取绘制缓存</span>                    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//缓存有效，复用缓存</span>                        canvas.drawBitmap(cache, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mLayerPaint);                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// Fast path for layouts with no backgrounds</span>                    <span class="hljs-comment">//ViewGroup不需要绘制，直接调用dispatchDraw</span>                    <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;                        dispatchDraw(canvas);                        drawAutofilledHighlight(canvas);                         ...                    &#125; <span class="hljs-keyword">else</span> &#123;                      <span class="hljs-comment">//ViewGroup(需要绘制) / View 直接调用draw</span>                        draw(canvas);                    &#125;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;               <span class="hljs-comment">//缓存构建完成，放入渲染节点</span>                renderNode.end(canvas);                setDisplayListProperties(renderNode);            &#125;                  &#125;          &#125;</code></pre><p><code>DecorView</code>执行<code>updateDisplayListIfDirty()</code>，调用到<code>draw(Canvas)</code>，然后向下递归调用到<code>child.draw()</code></p><p><code>updateRootDisplayList()</code>主要执行以下几步：</p><ul><li>更新<code>DecorView</code>操作缓存(DisplayList)——<code>updateViewTreeDisplayList(decorView)</code></li><li>利用<code>DisplayCanvas</code>构建并缓存所有的<code>DrawOp(View的绘制操作)</code>——<code>mRootNode.start()</code></li><li>将<code>DisplayListCanvas</code>缓存的<code>DrawOp</code>填充到<code>RenderNode(View)</code>——<code>View.updateDisplayListIfDirty()</code></li><li>将<code>DecorView</code>的缓存<code>DrawOp</code>填充到<code>RootRenderNode</code>中——<code>mRootNode.end()</code></li></ul><p><img src="/images/硬件绘制-updateDisplayListIfDirty.png" srcset="/img/loading.gif" alt="硬件绘制-updateDisplayListIfDirty()"></p><h3 id="View硬件绘制相关"><a href="#View硬件绘制相关" class="headerlink" title="View硬件绘制相关"></a>View硬件绘制相关</h3><p>上一节中，通过<code>DecorView</code>递归调用<code>子View.updateDisplayListIfDirty()</code>不断填充<code>DisplayList</code>到对应View的<code>RenderNode</code></p><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">View</span><span class="hljs-params">(Context context)</span> </span>&#123;  ...     <span class="hljs-comment">//初始化渲染节点</span>     mRenderNode = RenderNode.create(getClass().getName(), <span class="hljs-keyword">new</span> ViewAnimationHostBridge(<span class="hljs-keyword">this</span>));  ...&#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;       <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();        <span class="hljs-keyword">boolean</span> drawingWithRenderNode = mAttachInfo != <span class="hljs-keyword">null</span>                &amp;&amp; mAttachInfo.mHardwareAccelerated                &amp;&amp; hardwareAcceleratedCanvas;        ...        <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;           <span class="hljs-comment">//继续执行到updateDisplayListIfDirty</span>            renderNode = updateDisplayListIfDirty();            <span class="hljs-keyword">if</span> (!renderNode.isValid()) &#123;                renderNode = <span class="hljs-keyword">null</span>;                drawingWithRenderNode = <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> RenderNode <span class="hljs-title">updateDisplayListIfDirty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> RenderNode renderNode = mRenderNode;        <span class="hljs-keyword">if</span> (!canHaveDisplayList()) &#123;            <span class="hljs-comment">// can't populate RenderNode, don't try</span>            <span class="hljs-keyword">return</span> renderNode;        &#125;        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="hljs-number">0</span> <span class="hljs-comment">//绘制缓存无效</span>                || !renderNode.isValid() <span class="hljs-comment">//渲染节点没有DisplayList</span>                || (mRecreateDisplayList)) &#123; <span class="hljs-comment">//需要刷新DisplayList</span>            <span class="hljs-comment">// Don't need to recreate the display list, just need to tell our</span>            <span class="hljs-comment">// children to restore/recreate theirs</span>            <span class="hljs-keyword">if</span> (renderNode.isValid() <span class="hljs-comment">//只要draw过一次后，一直返回true</span>                    &amp;&amp; !mRecreateDisplayList) &#123;<span class="hljs-comment">//调用一些只需要displayList属性修改的方法</span>                <span class="hljs-comment">//不需要重建 DisplayList</span>                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;                dispatchGetDisplayList();                <span class="hljs-keyword">return</span> renderNode; <span class="hljs-comment">// no work needed</span>            &#125;            <span class="hljs-comment">// If we got here, we're recreating it. Mark it as such to ensure that</span>            <span class="hljs-comment">// we copy in child display lists into ours in drawChild()</span>            mRecreateDisplayList = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">int</span> width = mRight - mLeft;            <span class="hljs-keyword">int</span> height = mBottom - mTop;            <span class="hljs-keyword">int</span> layerType = getLayerType();           <span class="hljs-comment">//获取DisplayListCanvas</span>            <span class="hljs-keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;<span class="hljs-comment">//软件绘制，绘制缓存存在直接复用</span>                    buildDrawingCache(<span class="hljs-keyword">true</span>);                    Bitmap cache = getDrawingCache(<span class="hljs-keyword">true</span>);                    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;                        canvas.drawBitmap(cache, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mLayerPaint);                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    computeScroll();                    canvas.translate(-mScrollX, -mScrollY);                    <span class="hljs-comment">//添加 缓存有效标记</span>                    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;                    <span class="hljs-comment">//ViewGroup不需要绘制，直接调用dispatchDraw</span>                    <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;                        dispatchDraw(canvas);                        drawAutofilledHighlight(canvas);                         ...                    &#125; <span class="hljs-keyword">else</span> &#123;                      <span class="hljs-comment">//ViewGroup(需要绘制) / View 直接调用draw</span>                        draw(canvas);                    &#125;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;               <span class="hljs-comment">//RenderNode 收集DisplayList</span>                renderNode.end(canvas);                setDisplayListProperties(renderNode);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;        &#125;        <span class="hljs-keyword">return</span> renderNode;    &#125;    <span class="hljs-comment">//是否会有DisplayList = 是否开启硬件加速</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canHaveDisplayList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> !(mAttachInfo == <span class="hljs-keyword">null</span> || mAttachInfo.mThreadedRenderer == <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-comment">//只有flag标记为 PFLAG_INVALIDATED ，调用需要 重建DisplayList</span>    mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="hljs-number">0</span>;</code></pre><p>根据上述源码可判断<code>View需要重新构建DisplayList(执行draw())</code>有以下条件：</p><ol><li><p><code>(mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0</code>当前View绘制缓存无效</p><p><strong>mPrivateFlags没有<code>PFLAG_DRAWING_CACHE_VALID</code>标记</strong></p></li><li><p><code>renderNode.isValid()==false</code> View对应的<code>DisplayList</code>尚未构建或者被销毁</p><p><strong>只要View绘制过一次，就会一直返回true。除非<code>detached</code></strong></p></li><li><p><code>mRecreateDisplayList==true</code> View需要重新构建<code>DisplayList</code></p><p><strong>mPrivateFlags持有<code>PFLAG_INVALIDATED</code>标记</strong></p></li></ol><p>能满足以上条件的就是调用<code>View.invalidate()</code></p><pre><code class="hljs java"><span class="hljs-comment">//View.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">()</span> </span>&#123;        invalidate(<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> invalidateCache)</span> </span>&#123;        invalidateInternal(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidateInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">boolean</span> invalidateCache,            <span class="hljs-keyword">boolean</span> fullInvalidate)</span> </span>&#123;      ...            <span class="hljs-keyword">if</span> (invalidateCache) &#123;                mPrivateFlags |= PFLAG_INVALIDATED; <span class="hljs-comment">//添加PFLAG_INVALIDATED标志</span>                mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;<span class="hljs-comment">//移除PFLAG_DRAWING_CACHE_VALID标志</span>            &#125;          &#125;</code></pre><h4 id="dispatchGetDisplayList"><a href="#dispatchGetDisplayList" class="headerlink" title="dispatchGetDisplayList()"></a>dispatchGetDisplayList()</h4><p>只会在不重建<code>DisplayList</code>情况下调用</p><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><span class="hljs-comment">// 只会在ViewGroup下实现，更新子View的DisplayList</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchGetDisplayList</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//ViewGroup.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchGetDisplayList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mChildrenCount;        <span class="hljs-keyword">final</span> View[] children = mChildren;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;            <span class="hljs-keyword">final</span> View child = children[i];           <span class="hljs-comment">//View可见 || 设置动画</span>            <span class="hljs-keyword">if</span> (((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>)) &#123;                recreateChildDisplayList(child);<span class="hljs-comment">//调用子</span>            &#125;        &#125;        ...    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recreateChildDisplayList</span><span class="hljs-params">(View child)</span> </span>&#123;        child.mRecreateDisplayList = (child.mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="hljs-number">0</span>;<span class="hljs-comment">//没有PFLAG_INVALIDATED 返回true</span>        child.mPrivateFlags &amp;= ~PFLAG_INVALIDATED; <span class="hljs-comment">//移除 PFLAG_INVALIDATED标志</span>        child.updateDisplayListIfDirty();        child.mRecreateDisplayList = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//执行完后 重置状态</span>    &#125;</code></pre><h3 id="RenderThread渲染UI"><a href="#RenderThread渲染UI" class="headerlink" title="RenderThread渲染UI"></a>RenderThread渲染UI</h3><p>构建完<code>RootRenderNode</code>的<code>DisplayList——DrawOp树</code>之后，就需要准备渲染。<em>利用GPU将DisplayList绘制到屏幕上</em>。</p><p><img src="/images/CPU GPU通信模型" srcset="/img/loading.gif" alt="img"></p><p>根据图示渲染过程主要分为5阶段：</p><ol><li>UI线程创建OpenGL渲染需要的命令及数据——<code>构建DrawOp树</code></li><li>CPU将数据共享给GPU，使用<code>匿名共享内存</code></li><li>通知GPU渲染</li><li>swapBuffers，并通知<code>SurfaceFlinger</code>开始合成图层</li><li>SurfaceFlinger开始合成图层</li></ol><h3 id="硬件绘制流程"><a href="#硬件绘制流程" class="headerlink" title="硬件绘制流程"></a>硬件绘制流程</h3><p><img src="/images/硬件绘制流程.jpg" srcset="/img/loading.gif" alt="硬件绘制流程"></p><p>如上图所示：</p><blockquote><p>硬件绘制的流程，主要包含两个步骤：<strong>录制 、 回放</strong>。</p><p><code>录制</code>：需要View的<code>draw()</code>参与，需要记录View的绘制步骤，并编译为<strong>绘制指令</strong>(<code>drawOp</code>)</p><p><code>回放</code>：还原绘制内容，只需要还原<strong>绘制指令</strong>，而且这个绘制指令是可以修改的，修改的过程是不需要重新触发<code>draw()</code>。</p></blockquote><h2 id="软件绘制VS硬件绘制"><a href="#软件绘制VS硬件绘制" class="headerlink" title="软件绘制VS硬件绘制"></a>软件绘制VS硬件绘制</h2><table><thead><tr><th>渲染场景</th><th>软件绘制</th><th>硬件绘制</th><th>效果分析</th></tr></thead><tbody><tr><td>页面初始化</td><td>绘制所有View</td><td>创建所有<code>DisplayList</code></td><td>GPU负责复杂的计算任务</td></tr><tr><td>调用背景透明TextView.setText()</td><td>重绘脏区所有View</td><td>TextView及每一级父View重建<code>DisplayList</code></td><td>重叠的兄弟节点不需要进行重绘，GPU会自行处理</td></tr><tr><td>TextView逐帧播放动画</td><td>每帧动画都要重绘脏区View</td><td>第一帧需要重建<code>DisplayList</code><br>后续只要更新对应的<code>DisplayList</code>即可</td><td>刷新每帧性能提升</td></tr><tr><td>修改TextView透明度</td><td>重绘脏区所有View</td><td>直接调用<code>RenderNode.setAlpha()</code>即可</td><td>只触发<code>DecorView.updateDisplayListIfDirty</code>，不再往下遍历</td></tr></tbody></table><h2 id="绘制缓存"><a href="#绘制缓存" class="headerlink" title="绘制缓存"></a>绘制缓存</h2><p><img src="/images/Android绘制-绘制缓存.png" srcset="/img/loading.gif" alt="绘制缓存"></p><blockquote><p>绘图缓存是指一个<code>Bitmap(软件绘制)</code>和<code>(硬件绘制)</code>，保存的是控件及其子控件的一个快照。</p><p>可以通过<code>View.setLayerType()</code>设置使用何种类型的缓存。</p><p><code>LAYER_TYPE_NONE</code>：视图正常渲染，不受屏幕外缓冲区支持。<strong>默认值</strong></p><p><code>LAYER_TYPE_SOFTWARE</code>：标识这个View有一个<code>Software Layer</code>，在一定条件下，会变成<code>bitmap</code>对象。</p><p><code>LAYER_TYPE_HARDWARE</code>：标识这个VIew有一个<code>Hardware Layer</code>，通过GPU来实现。依赖<code>硬件加速</code>实现，如果未开启<code>硬件加速</code>，按照<code>Software Layer</code>实现。</p></blockquote><h3 id="软件绘制缓存"><a href="#软件绘制缓存" class="headerlink" title="软件绘制缓存"></a>软件绘制缓存</h3><pre><code class="hljs java"><span class="hljs-comment">//View.java</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;     ...        Bitmap cache = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> layerType = getLayerType(); <span class="hljs-comment">// layerType默认为LAYER_TYPE_NONE</span>        <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123;<span class="hljs-comment">//软件绘制条件</span>             <span class="hljs-keyword">if</span> (layerType != LAYER_TYPE_NONE) &#123;<span class="hljs-comment">//必须设置 `LAYER_TYPE_SOFTWARE` 或 LAYER_TYPE_HARDWARE 缓存生效</span>                 <span class="hljs-comment">// If not drawing with RenderNode, treat HW layers as SW</span>                 layerType = LAYER_TYPE_SOFTWARE;<span class="hljs-comment">//设置 软件layer</span>                 buildDrawingCache(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//构建缓存</span>            &#125;            cache = getDrawingCache(<span class="hljs-keyword">true</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildDrawingCache</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoScale)</span> </span>&#123;       buildDrawingCacheImpl(autoScale);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildDrawingCacheImpl</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoScale)</span> </span>&#123;     ...       quality = Bitmap.Config.ARGB_8888;<span class="hljs-comment">//默认缓存bitmap图像类型</span>       bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(),                        width, height, quality);       bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);       <span class="hljs-keyword">if</span> (autoScale) &#123;          mDrawingCache = bitmap;       &#125; <span class="hljs-keyword">else</span> &#123;          mUnscaledDrawingCache = bitmap;       &#125;      ...    &#125;</code></pre><p>要启用<code>软件绘制缓存</code>，必须调用<code>View.setLayerType()</code>设置<code>LAYER_TYPE_HARDDWARE、LAYER_TYPE_SOFTWARE</code>。通过<code>buildDrawingCache()</code>生成<code>绘制缓存</code>，对应会生成两个缓存对象：</p><ul><li><code>mDrawingCache</code>：根据兼容模式进行放大或缩小</li><li><code>mUnscaledDrawingCache</code>：反映了控件的真实尺寸，多用作控件截图。</li></ul><p>后续通过<code>getDrawingCache()</code>获取缓存内容。</p><pre><code class="hljs java"><span class="hljs-comment">//View.java</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123; <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> drawingWithDrawingCache = cache != <span class="hljs-keyword">null</span> &amp;&amp; !drawingWithRenderNode; <span class="hljs-comment">//是否使用缓存</span> ... <span class="hljs-keyword">if</span>(!drawingWithDrawingCache) &#123;<span class="hljs-comment">//未使用缓存</span>    <span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;<span class="hljs-comment">//硬件绘制</span>        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;        ((DisplayListCanvas) canvas).drawRenderNode(renderNode);    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//软件绘制</span>        <span class="hljs-comment">// 需要回调到`onDraw()`</span>        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;            dispatchDraw(canvas);        &#125; <span class="hljs-keyword">else</span> &#123;            draw(canvas);        &#125;    &#125; &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cache!=<span class="hljs-keyword">null</span>)&#123;   canvas.drawBitmap(cache...)<span class="hljs-comment">//将缓存绘制于画布上</span> &#125;&#125;</code></pre><h3 id="硬件绘制缓存"><a href="#硬件绘制缓存" class="headerlink" title="硬件绘制缓存"></a>硬件绘制缓存</h3><p><code>DisplayList</code>可以理解为缓存，开启<code>硬件加速</code>时，只要每次回放<code>DisplayList</code>即可。</p><h3 id="绘制缓存的开启原则"><a href="#绘制缓存的开启原则" class="headerlink" title="绘制缓存的开启原则"></a>绘制缓存的开启原则</h3><ul><li>不要为<code>十分轻量级的控件</code>启用绘制缓存。可能缓存绘制的开销 &gt; 控件重绘开销</li><li>为<code>很少发生内容改变的控件</code>启用绘制缓存。避免<code>invalidate()</code>时产生额外的缓存绘制操作</li><li>当父控件需要频繁改变子控件的位置或变换时对<code>子控件</code>启用绘制缓存，避免频繁重绘子控件。通过<code>ViewGroup.setChildrenDrawingWithCache()</code>启用子控件绘制缓存。</li></ul><h2 id="属性动画更新相关"><a href="#属性动画更新相关" class="headerlink" title="属性动画更新相关"></a>属性动画更新相关</h2><p><img src="/images/Android绘制-属性动画更新相关.png" srcset="/img/loading.gif" alt="Android绘制-属性动画更新相关"></p><p>在<a href="/2020/10/12/Android动画-属性动画/" title="Android动画-属性动画">Android动画-属性动画</a>中讲到最后通过反射调用<code>View.setXX()</code>去执行动画。</p><pre><code class="hljs java"><span class="hljs-comment">//view.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScaleX</span><span class="hljs-params">(<span class="hljs-keyword">float</span> scaleX)</span> </span>&#123;        <span class="hljs-keyword">if</span> (scaleX != getScaleX()) &#123;            scaleX = sanitizeFloatPropertyValue(scaleX, <span class="hljs-string">"scaleX"</span>);            invalidateViewProperty(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);            mRenderNode.setScaleX(scaleX);<span class="hljs-comment">//更新对应View的displayList</span>            invalidateViewProperty(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);            invalidateParentIfNeededAndWasQuickRejected();            notifySubtreeAccessibilityStateChangedIfNeeded();        &#125;    &#125;</code></pre><p>关键在于<code>invalidateViewProperty()</code>调用界面刷新</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidateViewProperty</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> invalidateParent, <span class="hljs-keyword">boolean</span> forceRedraw)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!isHardwareAccelerated()            || !mRenderNode.isValid()            || (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//软件绘制</span>        <span class="hljs-keyword">if</span> (invalidateParent) &#123;            invalidateParentCaches();        &#125;        <span class="hljs-keyword">if</span> (forceRedraw) &#123;            mPrivateFlags |= PFLAG_DRAWN; <span class="hljs-comment">// force another invalidation with the new orientation</span>        &#125;        invalidate(<span class="hljs-keyword">false</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        damageInParent();<span class="hljs-comment">//硬件绘制</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">damageInParent</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo != <span class="hljs-keyword">null</span>) &#123;        mParent.onDescendantInvalidated(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);<span class="hljs-comment">//一层层向上层调用</span>    &#125;&#125;</code></pre><p><code>mParent</code>一般指向<code>ViewGroup</code></p><pre><code class="hljs java"><span class="hljs-comment">//ViewGroup.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDescendantInvalidated</span><span class="hljs-params">(@NonNull View child, @NonNull View target)</span> </span>&#123;      ...        <span class="hljs-keyword">if</span> ((target.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// We lazily use PFLAG_DIRTY, since computing opaque isn't worth the potential</span>            <span class="hljs-comment">// optimization in provides in a DisplayList world.</span>            mPrivateFlags = (mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DIRTY;            <span class="hljs-comment">// simplified invalidateChildInParent behavior: clear cache validity to be safe...</span>            <span class="hljs-comment">//标记缓存无效</span>            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;        &#125;      ...        <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-comment">//继续向顶层View请求</span>            mParent.onDescendantInvalidated(<span class="hljs-keyword">this</span>, target);        &#125;    &#125;</code></pre><p>在<code>onDescendantInvalidated()</code>主要移除了<code>PFLAG_DRAWING_CACHE_VALID</code>标志</p><p>最顶层的View是<code>DecorView</code>，而<code>ViewRootImpl</code>就是<code>DecorView的parent</code></p><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDescendantInvalidated</span><span class="hljs-params">(@NonNull View child, @NonNull View descendant)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((descendant.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != <span class="hljs-number">0</span>) &#123;            mIsAnimating = <span class="hljs-keyword">true</span>;        &#125;        invalidate();    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">()</span> </span>&#123;        mDirty.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mWidth, mHeight);        <span class="hljs-keyword">if</span> (!mWillDrawSoon) &#123;            scheduleTraversals();<span class="hljs-comment">//开始执行绘制流程</span>        &#125;    &#125;</code></pre><p>总结：属性动画最后反射调用<code>View.setXX()</code>更新View属性时，调用到<code>invalidateViewProperty()</code>，主要实现的功能就是<code>移除PFLAG_DRAWING_CACHE_VALID</code>标志。在执行绘制过程中，在回到<code>View.updateDisplayListIfDirty()</code>时</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RenderNode <span class="hljs-title">updateDisplayListIfDirty</span><span class="hljs-params">()</span> </span>&#123;  ...     <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="hljs-number">0</span> <span class="hljs-comment">//满足该条件</span>               || !renderNode.isValid()               || (mRecreateDisplayList)) &#123;           <span class="hljs-comment">// Don't need to recreate the display list, just need to tell our</span>           <span class="hljs-comment">// children to restore/recreate theirs</span>           <span class="hljs-keyword">if</span> (renderNode.isValid()                   &amp;&amp; !mRecreateDisplayList) &#123;<span class="hljs-comment">//未设置 PFLAG_INVALIDATED标志</span>               mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;               mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;               dispatchGetDisplayList();<span class="hljs-comment">//只要刷新DisplayList</span>               <span class="hljs-keyword">return</span> renderNode; <span class="hljs-comment">// no work needed</span>           &#125;       ...&#125;</code></pre><p><strong>在开启硬件加速的条件下，属性动画更新过程中不会回调<code>onDraw()</code></strong></p><h2 id="关键节点"><a href="#关键节点" class="headerlink" title="关键节点"></a>关键节点</h2><h3 id="DisplayList初始化"><a href="#DisplayList初始化" class="headerlink" title="DisplayList初始化"></a><code>DisplayList</code>初始化</h3><p><code>DisplayListCanvas.start()</code> -&gt; <code>DisplayListCanvas.obtain()</code>-&gt;<code>nCreateDisplayListCanvas</code></p><pre><code class="hljs c++"><span class="hljs-comment">//android_view_DisplayListCanvas.cpp</span><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="hljs-params">(jlong renderNodePtr,        jint width, jint height)</span> </span>&#123;    RenderNode* renderNode = <span class="hljs-keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));&#125;<span class="hljs-comment">//Canvas.cpp</span><span class="hljs-function">Canvas* <span class="hljs-title">Canvas::create_recording_canvas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, uirenderer::RenderNode* renderNode)</span> </span>&#123;    <span class="hljs-keyword">if</span> (uirenderer::Properties::isSkiaEnabled()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> uirenderer::RecordingCanvas(width, height);&#125;<span class="hljs-comment">//Properrties.cpp</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Properties::isSkiaEnabled</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">auto</span> renderType = getRenderPipelineType();<span class="hljs-comment">//分为三种类型 SkiaGL SkiaVulkan OpenGL(默认)</span>    <span class="hljs-keyword">return</span> RenderPipelineType::SkiaGL == renderType || RenderPipelineType::SkiaVulkan == renderType;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">//RecordingCanvas.cpp</span>RecordingCanvas::RecordingCanvas(<span class="hljs-keyword">size_t</span> width, <span class="hljs-keyword">size_t</span> height)        : mState(*<span class="hljs-keyword">this</span>), mResourceCache(ResourceCache::getInstance()) &#123;    resetRecording(width, height);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RecordingCanvas::resetRecording</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, RenderNode* node)</span> </span>&#123;    LOG_ALWAYS_FATAL_IF(mDisplayList, <span class="hljs-string">"prepareDirty called a second time during a recording!"</span>);    mDisplayList = <span class="hljs-keyword">new</span> DisplayList();<span class="hljs-comment">//初始化DisplayList</span>    mState.initializeRecordingSaveStack(width, height);    mDeferredBarrierType = DeferredBarrierType::InOrder;&#125;</code></pre><h3 id="插入DrawOp到DisplayList"><a href="#插入DrawOp到DisplayList" class="headerlink" title="插入DrawOp到DisplayList"></a>插入DrawOp到DisplayList</h3><p><code>DisplayListCanvas</code>内部也包含了各种<code>drawXX()</code>，例如<code>drawLines()、drawText()</code>等。在调用这些方法后，会把对应的绘制操作转换为<code>drawOp</code></p><pre><code class="hljs c++"><span class="hljs-comment">//DisplayListCanvas.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisplayListCanvas</span> <span class="hljs-title">extends</span> <span class="hljs-title">RecordingCanvas</span> &#123;</span> ...   <span class="hljs-comment">//所有绘制方法由RecordCanvas实现</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawCircle</span><span class="hljs-params">(CanvasProperty&lt;Float&gt; cx, CanvasProperty&lt;Float&gt; cy,            CanvasProperty&lt;Float&gt; radius, CanvasProperty&lt;Paint&gt; paint)</span> </span>&#123;        nDrawCircle(mNativeCanvasWrapper, cx.getNativeContainer(), cy.getNativeContainer(),                radius.getNativeContainer(), paint.getNativeContainer());    &#125;&#125;<span class="hljs-comment">//RecordingCanvas.java</span>    @<span class="hljs-function">Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-keyword">float</span> startX, <span class="hljs-keyword">float</span> startY, <span class="hljs-keyword">float</span> stopX, <span class="hljs-keyword">float</span> stopY,            @NonNull Paint paint)</span> </span>&#123;        nDrawLine(mNativeCanvasWrapper, startX, startY, stopX, stopY, paint.getNativeInstance());    &#125;</code></pre><p><code>drawCircle()和drawRoundRect()</code>由<code>DisplayListCanvas</code>实现。其他的绘制方法交由<code>RecordingCanvas</code>实现。</p><pre><code class="hljs c++"><span class="hljs-comment">//android_view_DisplayListCanvas.cpp</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">android_view_DisplayListCanvas_drawCircleProps</span><span class="hljs-params">(jlong canvasPtr,        jlong xPropPtr, jlong yPropPtr, jlong radiusPropPtr, jlong paintPropPtr)</span> </span>&#123;    Canvas* canvas = <span class="hljs-keyword">reinterpret_cast</span>&lt;Canvas*&gt;(canvasPtr);    CanvasPropertyPrimitive* xProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(xPropPtr);    CanvasPropertyPrimitive* yProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(yPropPtr);    CanvasPropertyPrimitive* radiusProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPrimitive*&gt;(radiusPropPtr);    CanvasPropertyPaint* paintProp = <span class="hljs-keyword">reinterpret_cast</span>&lt;CanvasPropertyPaint*&gt;(paintPropPtr);    canvas-&gt;drawCircle(xProp, yProp, radiusProp, paintProp);&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">//RecordingCanvas.h</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-keyword">float</span> startX, <span class="hljs-keyword">float</span> startY, <span class="hljs-keyword">float</span> stopX, <span class="hljs-keyword">float</span> stopY,                          <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span> <span class="hljs-keyword">override</span> </span>&#123;        <span class="hljs-keyword">float</span> points[<span class="hljs-number">4</span>] = &#123;startX, startY, stopX, stopY&#125;;        drawLines(points, <span class="hljs-number">4</span>, paint);    &#125;<span class="hljs-comment">//RecordingCanvas.cpp</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RecordingCanvas::drawLines</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>* points, <span class="hljs-keyword">int</span> floatCount, <span class="hljs-keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;    <span class="hljs-keyword">if</span> (CC_UNLIKELY(floatCount &lt; <span class="hljs-number">4</span> || paint.nothingToDraw())) <span class="hljs-keyword">return</span>;    floatCount &amp;= ~<span class="hljs-number">0x3</span>;  <span class="hljs-comment">// round down to nearest four</span>     addOp(alloc().create_trivial&lt;LinesOp&gt;(            calcBoundsOfPoints(points, floatCount), *mState.currentSnapshot()-&gt;transform,            getRecordedClip(), refPaint(&amp;paint), refBuffer&lt;<span class="hljs-keyword">float</span>&gt;(points, floatCount), floatCount));&#125;</code></pre><p>通过<code>addOp()</code>将<code>DrawLine</code>的绘制操作缓存到<code>displayList</code>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><a href="/2018/12/14/View的工作原理/" title="View的绘制过程">View的绘制过程</a><p><a href="https://developer.android.com/guide/topics/graphics/hardware-accel?hl=zh-cn" target="_blank" rel="noopener">Android官方文档-硬件加速</a></p><p><a href="https://blog.csdn.net/Luoshengyang/article/details/45943255" target="_blank" rel="noopener">DisplayList构建过程分析</a></p><p><a href="https://tech.meituan.com/2017/01/19/hardware-accelerate.html" target="_blank" rel="noopener">Android硬件加速原理与实现简介</a></p><p><a href="https://www.jianshu.com/p/dd800800145b" target="_blank" rel="noopener">RenderThread与OpenGL GPU渲染</a></p><p><a href="https://www.androidperformance.com/2019/07/27/Android-Hardware-Layer/" target="_blank" rel="noopener">Android 中的 Hardware Layer 详解</a></p><!-- https://www.jianshu.com/p/abfaea892611 ， https://blog.csdn.net/jinzhuojun/article/details/54234354 https://www.jianshu.com/p/40f660e17a73 -->]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android事件分发</title>
    <link href="/2020/10/21/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <url>/2020/10/21/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>View的事件分发本质就是<strong><a href="#1-MotionEvent">MotionEvent</a>事件的分发过程</strong>。当一个MotionEvent产生后，系统需要把该事件传递给一个具体的View.</p></blockquote><h3 id="点击事件传递规则"><a href="#点击事件传递规则" class="headerlink" title="点击事件传递规则"></a>点击事件传递规则</h3><p>点击事件的传递顺序为：<strong>Activity(Window) –&gt; ViewGroup –&gt; View</strong></p><p>事件分发过程中有3个重要的方法:</p><ul><li><p><code>dispathTouchEvent(MotionEvent event)</code></p><p>用来进行事件的分发。</p></li><li><p><code>onInterceptTouchEvent(MotionEvent event)</code></p><p>用来进行事件的拦截，在<code>dispatchOnTouchEvent()</code>内部中调用，返回结果表明是否拦截事件，<em>View中是没有该方法的</em></p></li><li><p><code>onTouchEvent(MotionEvent event)</code></p><p>用来处理点击事件，在<code>dispatchOnTouchEvent()</code>内部中调用，返回结果表明是否消耗当前事件</p></li></ul><blockquote><p>在Android系统中，可以处理事件传递的类有以下三种：</p><ul><li><strong>Activity</strong>：包含<code>dispatchTouchEvent</code>，<code>onTouchEvent</code>方法</li><li><strong>ViewGroup</strong>：包含<code>dispatchTouchEvent</code>，<code>onInterceptTouchEvent</code>，<code>onTouchEvent</code></li><li><strong>View</strong>：包含<code>dispatchTouchEvent</code>，<code>onTouchEvent</code>方法</li></ul></blockquote><p>可以用如下伪代码体现：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span></span>&#123;    <span class="hljs-keyword">boolean</span> consume = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span>(onInterceptTouchEvent(ev))&#123;        <span class="hljs-comment">//被拦截调用自身的onTouchEvent()处理点击事件</span>        consume = onTouchEvent(event);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">//没有拦截继续放行，执行子View的dispatchTouchEvent()</span>        consume = child.dispatchTouchEvent(event);    &#125;    <span class="hljs-keyword">return</span> consume;&#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/TouchEvent-Transmit.png" srcset="/img/loading.gif" class="full-image" alt="事件分发" title="事件分发"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><code>super</code>：调用父类方法</li><li><code>true</code>：消费事件，即事件不会往下传递</li><li><code>false</code>：不消费事件，事件继续往下传递(<code>onInterceptTouchEvent()</code>)/交由父布局处理事件(<code>onTouchEvent</code>，<code>dispatchTouchEvent</code>)</li></ul><p>简单的总结一下流程：<strong>Activity.dispatchTouchEvent() -&gt; ViewGroup.dispatchTouchEvent() -&gt; ViewGroup.onInterceptTouchEvent() -&gt; View.dispatchTouchEvent() -&gt;  View.onTouch() -&gt; View.onTouchEvent() -&gt; View.onClick()</strong></p><h3 id="事件分发的源码解析"><a href="#事件分发的源码解析" class="headerlink" title="事件分发的源码解析"></a>事件分发的源码解析</h3><h4 id="Activity的事件分发机制"><a href="#Activity的事件分发机制" class="headerlink" title="Activity的事件分发机制"></a>Activity的事件分发机制</h4><p>当一个点击事件发生时，事件最先传递到的就是<code>Activity.dispatchTouchEvent(MotionEvent ev)</code>中进行事件分发。<em>具体工作是由Activity的Window来完成的。</em></p><pre><code class="hljs java"><span class="hljs-comment">// ..android/app/Activity.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;            onUserInteraction();        &#125;        <span class="hljs-comment">//若dispatchTouchEvent返回true，事件到此结束，返回false，继续向下传递</span>        <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> onTouchEvent(ev);    &#125;<span class="hljs-comment">//当activity在栈顶时，点击，触摸或者点击通知栏都会触发 </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUserInteraction</span><span class="hljs-params">()</span> </span>&#123;    &#125;<span class="hljs-comment">// ../com/android/internal/policy/PhoneWindow.java</span><span class="hljs-comment">/*** getWindow().superDispatchTouchEvent(ev)* getWindow()指向的是Window对象的一个实例，在Android中Window的唯一实现就是PhoneWindow*/</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;        <span class="hljs-comment">//mDecor 是DecorView的一个实例，DecoeView就是顶层View中的实例对象</span>        <span class="hljs-keyword">return</span> mDecor.superDispatchTouchEvent(event);    &#125;<span class="hljs-comment">//../com/android/internal/policy/DecorView.java</span><span class="hljs-comment">/***  mDecor.superDispatchTouchEvent(event)*  mDecor 是DecorView的一个实例对象，DecorView是PhoneView的一个内部类，并且继承自FrameLayout*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;        <span class="hljs-comment">//调用父类的方法即FrameLayout.dispatchTouchEvent = ViewGroup.dispatchTouchEvent()，由父类去处理事件分发</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);    &#125;</code></pre><p><code>onUserInteraction()</code>用户点击屏幕时最先被触发。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Activity-Dispatch.png" srcset="/img/loading.gif" class="full-image" alt="Activity事件分发" title="Activity事件分发"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>总结一下：按照上述流程图，当一个点击事件进来时，Activity上的事件流程如下：</p><ul><li>调用<code>Activity.dispatchTouchEvent()</code>，然后调用<code>onUserInteraction()</code></li><li>调用<code>getWindow()即PhoneWindow.superDispatchTouchEvent()</code></li><li>调用<code>mDecor即DecorView.superDispatchTouchEvent()</code></li><li>调用DecorView父类即<strong><code>ViewGroup.dispatchTouchEvent()</code></strong> 在这里实现了事件从Activity传递至ViewGroup</li></ul><h4 id="ViewGroup事件分发机制"><a href="#ViewGroup事件分发机制" class="headerlink" title="ViewGroup事件分发机制"></a>ViewGroup事件分发机制</h4><p>上述Activity事件分发，后面会走到<code>ViewGroup.dispatchTouchEvent()</code></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span></span>&#123;    ...        <span class="hljs-comment">//---- ViewGroup会在ACTION_DOWN时重置GroupFlags以免影响后续对ACTION_DOWN事件的处理----</span>     <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;                cancelAndClearTouchTargets(ev);                resetTouchState();      &#125;<span class="hljs-comment">//--------</span>    <span class="hljs-comment">//----判断当前事件是否需要拦截----   </span>      <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intercepted;      <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN  <span class="hljs-comment">//必须是ACTION_DOWN事件，若为其他UP或MOVE事件不触发拦截机制</span>                    || mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//mFirstTouchTarget 若当前事件被拦截，则该值为null 反之不会空</span>                <span class="hljs-comment">//FLAG_DISALLOW_INTERCEPT：禁止ViewGroup拦截除了DOWN以外的事件</span>                <span class="hljs-comment">//可由View调用requestDisallowInterceptTouchEvent设置标记</span>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;                <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;                    intercepted = onInterceptTouchEvent(ev);                    ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    intercepted = <span class="hljs-keyword">false</span>;                &#125;       &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// There are no touch targets and this action is not an initial down</span>                <span class="hljs-comment">// so this view group continues to intercept touches.</span>                intercepted = <span class="hljs-keyword">true</span>;       &#125;<span class="hljs-comment">//--------    </span>    ...<span class="hljs-comment">//----ViewGroup不拦截分发事件，事件向下分发交由子View进行处理----        </span>                           <span class="hljs-keyword">final</span> View[] children = mChildren;                        <span class="hljs-comment">//遍历当前ViewGroup下的所有子View 遍历为倒序，意味着从外到内遍历</span>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(                                    childrenCount, i, customOrder);                            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(                                    preorderedList, children, childIndex);                            <span class="hljs-comment">// If there is a view that has accessibility focus we want it</span>                            <span class="hljs-comment">// to get the event first and if not handled we will perform a</span>                            <span class="hljs-comment">// normal dispatch. We may do a double iteration but this is</span>                            <span class="hljs-comment">// safer given the timeframe.</span>                            <span class="hljs-keyword">if</span> (childWithAccessibilityFocus != <span class="hljs-keyword">null</span>) &#123;                                <span class="hljs-keyword">if</span> (childWithAccessibilityFocus != child) &#123;                                    <span class="hljs-keyword">continue</span>;                                &#125;                                childWithAccessibilityFocus = <span class="hljs-keyword">null</span>;                                i = childrenCount - <span class="hljs-number">1</span>;                            &#125;<span class="hljs-comment">//如果View不可见或触摸点的坐标不在子View范围内，跳过本次循环</span>                            <span class="hljs-keyword">if</span> (!canViewReceivePointerEvents(child)                                    || !isTransformedTouchPointInView(x, y, child, <span class="hljs-keyword">null</span>)) &#123;                                ev.setTargetAccessibilityFocus(<span class="hljs-keyword">false</span>);                                <span class="hljs-keyword">continue</span>;                            &#125;                            newTouchTarget = getTouchTarget(child);                            <span class="hljs-keyword">if</span> (newTouchTarget != <span class="hljs-keyword">null</span>) &#123;                                <span class="hljs-comment">// Child is already receiving touch within its bounds.</span>                                <span class="hljs-comment">// Give it the new pointer in addition to the ones it is handling.</span>                                newTouchTarget.pointerIdBits |= idBitsToAssign;                                <span class="hljs-keyword">break</span>;                            &#125;                            resetCancelNextUpFlag(child);<span class="hljs-comment">//事件传递下来后，调用dispatchTransformedTouchEvent，事件就会传递到View中                     </span>                            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-keyword">false</span>, child, idBitsToAssign)) &#123;                                <span class="hljs-comment">// Child wants to receive touch within its bounds.</span>                                mLastTouchDownTime = ev.getDownTime();                                <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-keyword">null</span>) &#123;                                    <span class="hljs-comment">// childIndex points into presorted list, find original index</span>                                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; childrenCount; j++) &#123;                                        <span class="hljs-keyword">if</span> (children[childIndex] == mChildren[j]) &#123;                                            mLastTouchDownIndex = j;                                            <span class="hljs-keyword">break</span>;                                        &#125;                                    &#125;                                &#125; <span class="hljs-keyword">else</span> &#123;                                    mLastTouchDownIndex = childIndex;                                &#125;                                mLastTouchDownX = ev.getX();                                mLastTouchDownY = ev.getY();<span class="hljs-comment">//返回true的话                                </span>                                newTouchTarget = addTouchTarget(child, idBitsToAssign);                                alreadyDispatchedToNewTouchTarget = <span class="hljs-keyword">true</span>;                                <span class="hljs-keyword">break</span>;                            &#125;                            <span class="hljs-comment">// The accessibility focus didn't handle the event, so clear</span>                            <span class="hljs-comment">// the flag and do a normal dispatch to all children.</span>                            ev.setTargetAccessibilityFocus(<span class="hljs-keyword">false</span>);                        &#125;        ...<span class="hljs-comment">//如果 mfirstTouchTarget为空，ViewGroup默认拦截同一时间序列中的所有事件        </span>        <span class="hljs-keyword">if</span> (mFirstTouchTarget == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// No touch targets so treat this as an ordinary view.</span>            <span class="hljs-comment">//child默认为空，直接调用父类的 dispatchTouchEvent()</span>                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-keyword">null</span>,                        TouchTarget.ALL_POINTER_IDS);            &#125; <span class="hljs-keyword">else</span> &#123;        ...        &#125;    ...    &#125;<span class="hljs-comment">//是否拦截事件分发</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;        <span class="hljs-comment">//触发条件需要有 鼠标输入触发 正常操作都是触摸方式 所以可以看做默认false</span>        <span class="hljs-keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;<span class="hljs-comment">//事件向下分发 子View或者子ViewGroup</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTransformedTouchEvent</span><span class="hljs-params">(MotionEvent event, <span class="hljs-keyword">boolean</span> cancel,            View child, <span class="hljs-keyword">int</span> desiredPointerIdBits)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> handled;        <span class="hljs-comment">// Canceling motions is a special case.  We don't need to perform any transformations</span>        <span class="hljs-comment">// or filtering.  The important part is the action, not the contents.</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldAction = event.getAction();        <span class="hljs-keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;            event.setAction(MotionEvent.ACTION_CANCEL);            <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//如果没有子View，向上回溯调用父类的dispatchTouchEvent</span>                handled = <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//包含子View，调用子类的dispatchTouchEvent</span>                handled = child.dispatchTouchEvent(event);            &#125;            event.setAction(oldAction);            <span class="hljs-keyword">return</span> handled;        &#125;    ...&#125;<span class="hljs-comment">//mFirstTouchTarget其实是一种单链表结构</span><span class="hljs-function"><span class="hljs-keyword">private</span> TouchTarget <span class="hljs-title">addTouchTarget</span><span class="hljs-params">(@NonNull View child, <span class="hljs-keyword">int</span> pointerIdBits)</span> </span>&#123;        <span class="hljs-keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);        target.next = mFirstTouchTarget;        mFirstTouchTarget = target;        <span class="hljs-keyword">return</span> target;&#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ViewGroup-Dispatch.png" srcset="/img/loading.gif" class="full-image" alt="ViewGroup事件分发" title="ViewGroup事件分发"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据上述流程图，总结一下：</p><ul><li>点击事件从上层传递到ViewGroup，先调用<code>ViewGroup.dispatchTouchEvent()</code></li><li>判断<code>ViewGroup.onInterceptTouchEvent()</code>是否拦截点击事件<ul><li>默认不拦截，则将事件继续向子View传递，然后调用<code>View.dispatchTouchEvent()</code></li><li>被拦截返回<code>true</code>，调用<code>super.dispatchTouchEvent()</code>返给父布局处理，并且ViewGroup自身也处理事件，比如<code>onTouch(),onClick(),onTouchEvent()</code>等事件</li></ul></li></ul><blockquote><p>通常情况下ViewGroup的<code>onInterceptTouchEvent()</code>返回false，不会拦截用户操作。</p><p>不过要注意的是 拦截的是 一个用户的操作序列：<em>从用户手指按下到手指抬起为止。</em></p><ul><li>拦截了Down事件，后续的事件都会交由<code>ViewGroup.onTouchEvent()</code>处理</li><li>拦截了其他事件，会给之前序列头部的<code>ACTION_DOWN</code>事件发送一个<code>ACTION_CANCEL</code>类型事件，通知子View无法执行后续事件，回归初始状态。(<strong>例如点击ListView中的一个Item的Button，再滑动ListView，Button就会恢复初始状态。</strong>)</li></ul></blockquote><h4 id="View事件分发机制"><a href="#View事件分发机制" class="headerlink" title="View事件分发机制"></a>View事件分发机制</h4><p>上述ViewGroup事件分发后，就会调用到<code>View.dispatchTouchEvent()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/View.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123; ...    <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;         <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;            <span class="hljs-keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;                result = <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-comment">//noinspection SimplifiableIfStatement</span>            ListenerInfo li = mListenerInfo;            <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span>                 &amp;&amp; li.mOnTouchListener != <span class="hljs-keyword">null</span> <span class="hljs-comment">//View设置了onTouch事件</span>                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED <span class="hljs-comment">//View是可操作状态的 isEnable=true</span>                &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, event)<span class="hljs-comment">//View的onTouch返回为true</span>               )&#123;                result = <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-comment">//如果result为true即上述条件通过 这个if条件就不会向下执行意味着onTouchEvent()不会被调用</span>            <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;                result = <span class="hljs-keyword">true</span>;            &#125;        &#125;    ...        <span class="hljs-keyword">return</span> result;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> action = event.getAction();     <span class="hljs-comment">//只要设置了点击事件 clickable = true</span>     <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;     <span class="hljs-comment">//当View点击事件被禁止时，直接消耗点击事件</span>     <span class="hljs-keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;            <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="hljs-number">0</span>) &#123;                setPressed(<span class="hljs-keyword">false</span>);            &#125;            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;            <span class="hljs-comment">// A disabled view that is clickable still consumes the touch</span>            <span class="hljs-comment">// events, it just doesn't respond to them.</span>            <span class="hljs-keyword">return</span> clickable;        &#125;     ...      <span class="hljs-comment">//监听点击事件，并且需要配置Click事件才可以触发</span>      <span class="hljs-keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;          <span class="hljs-keyword">switch</span> (action) &#123;                  <span class="hljs-comment">//当手指从屏幕离开时，触发对应的点击事件</span>              <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:                  <span class="hljs-comment">//没有配置点击事件的话 直接返回</span>                  <span class="hljs-keyword">if</span> (!clickable) &#123;                        removeTapCallback();                        removeLongPressCallback();                        mInContextButtonPress = <span class="hljs-keyword">false</span>;                        mHasPerformedLongPress = <span class="hljs-keyword">false</span>;                        mIgnoreNextUpEvent = <span class="hljs-keyword">false</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                  <span class="hljs-keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="hljs-number">0</span>;                    <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="hljs-number">0</span> || prepressed) &#123;                        <span class="hljs-comment">// take focus if we don't have it already and we should in</span>                        <span class="hljs-comment">// touch mode.</span>                        <span class="hljs-keyword">boolean</span> focusTaken = <span class="hljs-keyword">false</span>;                        <span class="hljs-keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;                            focusTaken = requestFocus();                        &#125;                        ...                        <span class="hljs-keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;                            <span class="hljs-comment">// This is a tap, so remove the longpress check</span>                            removeLongPressCallback();                            <span class="hljs-comment">// Only perform take click actions if we were in the pressed state</span>                            <span class="hljs-keyword">if</span> (!focusTaken) &#123;                                <span class="hljs-comment">// Use a Runnable and post this rather than calling</span>                                <span class="hljs-comment">// performClick directly. This lets other visual state</span>                                <span class="hljs-comment">// of the view update before click actions start.</span>                                <span class="hljs-keyword">if</span> (mPerformClick == <span class="hljs-keyword">null</span>) &#123;                                    mPerformClick = <span class="hljs-keyword">new</span> PerformClick();                                &#125;                                <span class="hljs-keyword">if</span> (!post(mPerformClick)) &#123;                                    performClick();                                &#125;                            &#125;                        &#125;                        ...                    &#125;                  <span class="hljs-keyword">break</span>;          ...          &#125;      &#125; &#125;<span class="hljs-comment">//实际点击事件的触发位置</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">performClick</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> result;        <span class="hljs-keyword">final</span> ListenerInfo li = mListenerInfo;        <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="hljs-keyword">null</span>) &#123;            playSoundEffect(SoundEffectConstants.CLICK);            <span class="hljs-comment">//调用对应的点击事件</span>            li.mOnClickListener.onClick(<span class="hljs-keyword">this</span>);            result = <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            result = <span class="hljs-keyword">false</span>;        &#125;        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);        notifyEnterOrExitForAutoFillIfNeeded(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> result;    &#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View-Dispatch.png" srcset="/img/loading.gif" class="full-image" alt="View事件分发" title="View事件分发"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据上述流程图，总结一下：</p><ul><li>点击事件从ViewGroup传递到View，调用<code>View.dispatchTouchEvent()</code></li><li>判断当前View是否设置<code>OnTouchListener</code>，并且设置了<code>onTouch()</code>返回值，默认返回false<ul><li>返回<code>true</code>，代表事件被<code>onTouch()</code>消费，不会继续往下传递</li><li>返回<code>false</code>，事件继续向下传递，调用<code>View.onTouchEvent()</code>，后续若设置点击事件，则继续调用<code>performClick()</code>，最后执行<code>onClick()</code>事件</li></ul></li></ul><p>拓展：</p><blockquote><ol><li>如果有一个控件是<code>DISABLED</code>，注册的<code>onTouch()</code>事件不会被执行。若要监听点击事件，只能实现它的<code>onTouchEvent()</code></li><li>点击事件优先级： <code>onTouch()</code> &gt; <code>onTouchEvent()</code> &gt; <code>performClick()</code> &gt; <code>onClick()</code> </li></ol></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>点击事件传递从<code>dispatchTouchEvent()</code>开始，在不修改默认返回值时，事件会按照嵌套层次由外向内传递，到达最内层View时，由最内层View<code>onTouchEvent()</code>处理</li><li>事件在传递过程中，返回参数设为<code>true</code>，事件会被提前消费，不向下继续传递</li><li>View的点击事件触发顺序为  <code>onTouch()</code> &gt; <code>onTouchEvent()</code> &gt; <code>performClick()</code> &gt; <code>onClick()</code> </li></ol><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol><li><em>Touch事件的后续(例如<code>ACTION_MOVE</code>,<code>ACTION_UP</code>)层级传递</em><ul><li>若<code>dispatchTouchEvent()</code>返回true，那么能收到<code>ACTION_DOWN</code>的函数也可以收到后续事件</li><li>若<code>onTouchEvent()</code>返回true，那么其他事件不再往下传递，而是直接传给自己的<code>onTouchEvent()</code>并结束本次事件传递</li></ul></li></ol><p>## </p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android动画-属性动画</title>
    <link href="/2020/10/12/Android%E5%8A%A8%E7%94%BB-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"/>
    <url>/2020/10/12/Android%E5%8A%A8%E7%94%BB-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对作用对象进行了扩展，可以对任何对象做动画，甚至可以没有对象。</p></blockquote><p><img src="/images/属性动画简析xmind.png" srcset="/img/loading.gif" alt="属性动画简析xmind"></p><h2 id="1-与View动画进行比较"><a href="#1-与View动画进行比较" class="headerlink" title="1.与View动画进行比较"></a>1.与View动画进行比较</h2><ul><li>View动画的作用对象<code>只能是View</code>，属性动画可以作用于<code>所有Java对象</code></li><li>View动画并没有改变View的属性，只是改变了View的视觉效果，并不具有交互性(<em>例如：无法响应动画后的点击事件。</em>)；属性动画是真正的对View的属性进行了修改，可以方便后续的交互操作。</li><li>View动画的效果比较单一，只能实现一些<code>平移，缩放，旋转等简单动画效果</code>，复杂的效果可能就需要<code>自定义View动画</code>去实现；属性动画拓展性强，可以基本实现所有的动画效果。</li></ul><h2 id="2-使用属性动画"><a href="#2-使用属性动画" class="headerlink" title="2.使用属性动画"></a>2.使用属性动画</h2><blockquote><p>使用XML方式</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">set</span>  <span class="hljs-attr">android:ordering</span>=<span class="hljs-string">[</span>"<span class="hljs-attr">together</span>" | "<span class="hljs-attr">sequentially</span>"]&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">objectAnimator</span>        <span class="hljs-attr">android:propertyName</span>=<span class="hljs-string">"string"</span>        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"int"</span>        <span class="hljs-attr">android:valueFrom</span>=<span class="hljs-string">"float | int | color"</span>        <span class="hljs-attr">android:valueTo</span>=<span class="hljs-string">"float | int | color"</span>        <span class="hljs-attr">android:startOffset</span>=<span class="hljs-string">"int"</span>        <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">"int"</span>        <span class="hljs-attr">android:repeatMode</span>=<span class="hljs-string">[</span>"<span class="hljs-attr">repeat</span>" | "<span class="hljs-attr">reverse</span>"]        <span class="hljs-attr">android:valueType</span>=<span class="hljs-string">[</span>"<span class="hljs-attr">intType</span>" | "<span class="hljs-attr">floatType</span>"]/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">animator</span>        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"int"</span>        <span class="hljs-attr">android:valueFrom</span>=<span class="hljs-string">"float | int | color"</span>        <span class="hljs-attr">android:valueTo</span>=<span class="hljs-string">"float | int | color"</span>        <span class="hljs-attr">android:startOffset</span>=<span class="hljs-string">"int"</span>        <span class="hljs-attr">android:repeatCount</span>=<span class="hljs-string">"int"</span>        <span class="hljs-attr">android:repeatMode</span>=<span class="hljs-string">[</span>"<span class="hljs-attr">repeat</span>" | "<span class="hljs-attr">reverse</span>"]        <span class="hljs-attr">android:valueType</span>=<span class="hljs-string">[</span>"<span class="hljs-attr">intType</span>" | "<span class="hljs-attr">floatType</span>"]/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre><p><code>&lt;set&gt;</code>：表示动画集合，对应<code>AnimatorSet</code></p><p><code>android:ordering</code>：表示子动画的播放顺序</p><ul><li><code>together</code>：子动画同时播放</li><li><code>sequentially</code>：子动画按照定义顺序先后播放</li></ul><h3 id="使用ObjectAnimator实现"><a href="#使用ObjectAnimator实现" class="headerlink" title="使用ObjectAnimator实现"></a>使用<code>ObjectAnimator</code>实现</h3><blockquote><p>XML方式</p></blockquote><p><code>&lt;objectAnimator&gt;</code>：对象动画，对应<code>ObjectAnimator</code></p><ul><li><p><code>android:propertyName</code>：属性动画作用的属性名称</p><p>| 属性         | 作用                   | 数值类型 |<br>| ———— | ———————- | ——– |<br>| alpha        | 控制View的透明度       | float    |<br>| translationX | 控制View的水平方向位移 | float    |<br>| translationY | 控制View的竖直方向位移 | float    |<br>| rotation     | 控制View的Z轴旋转度数  | float    |<br>| rotationX    | 控制View的X轴旋转度数  | float    |<br>| rotationY    | 控制View的Y轴旋转度数  | float    |<br>| scaleX       | 控制View的X轴缩放倍数  | float    |<br>| scaleY       | 控制View的Y轴缩放倍数  | float    |</p></li><li><p><code>android:duration</code>： 动画持续时长。</p></li><li><p><code>android:startOffset</code>：设置动画执行之前的等待时长。</p></li><li><p><code>android:repeatCount</code>：动画重复执行的次数。</p><ul><li>默认为<strong>0</strong>，表示只播放一次。</li><li>设置为<strong>-1或infinite</strong>，表示无限重复。</li></ul></li><li><p><code>android:repeatMode</code>：动画重复执行的模式。可选值：</p><ul><li><strong>restart</strong>：表示连续重复，为默认值。</li><li><strong>reverse</strong> ：表示逆向重复。</li></ul></li><li><p><code>android:valueFrom</code>：动画初始值。</p></li><li><p><code>android:valueTo</code>：动画结束值。</p></li><li><p><code>android:valueType</code>：动画值类型。可选值：</p><ul><li>intType：表示属性的类型为 整形</li><li>floatType：表示属性的类型为浮点型 <em>默认值</em></li><li>不设置：如果表示颜色，无需设置</li></ul></li></ul><blockquote><p>Java创建</p></blockquote><pre><code class="hljs java">ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(view,propertyName<span class="hljs-comment">/*对应属性操作，可以为任意值*/</span>,<span class="hljs-keyword">float</span>... values<span class="hljs-comment">/*动画的初始值以及结束值，不定长度*/</span>);mObjectAnimator.setDuration(duration);mObjectAnimator.setStartDelay(delay);mObjectAnimator.setRepeatCount(repeatCount);mObjectAnimator.setRepeatMode(repeatMode);mObjectAnimator.start();</code></pre><h5 id="应用代码"><a href="#应用代码" class="headerlink" title="应用代码"></a>应用代码</h5><blockquote><p>XML方式</p></blockquote><pre><code class="hljs xml">// objectAnim.xml<span class="hljs-tag">&lt;<span class="hljs-name">objectAnimator</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>      <span class="hljs-attr">android:valueFrom</span>=<span class="hljs-string">"1"</span>   // 初始值    <span class="hljs-attr">android:valueTo</span>=<span class="hljs-string">"0"</span>  // 结束值    <span class="hljs-attr">android:valueType</span>=<span class="hljs-string">"floatType"</span>  // 变化值类型 ：<span class="hljs-attr">floatType</span> &amp; <span class="hljs-attr">intType</span>    <span class="hljs-attr">android:propertyName</span>=<span class="hljs-string">"alpha"</span> // 对象变化的属性名称/&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">// 载入XML动画</span>Animator animator = AnimatorInflater.loadAnimator(context, R.animator.objectAnim);  <span class="hljs-comment">// 设置执行动画对象</span>animator.setTarget(view);  animator.start();</code></pre><blockquote><p>Java方式</p></blockquote><pre><code class="hljs java">ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(view,<span class="hljs-string">"alpha"</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);mObjectAnimator.setDuration(<span class="hljs-number">1000</span>);mObjectAnimator.setStartDelay(<span class="hljs-number">100</span>);mObjectAnimator.setRepeatCount(<span class="hljs-number">0</span>);mObjectAnimator.setRepeatMode(ValueAnimator.RESTART);mObjectAnimator.start();</code></pre><h3 id="使用ValueAnimator实现"><a href="#使用ValueAnimator实现" class="headerlink" title="使用ValueAnimator实现"></a>使用<code>ValueAnimator</code>实现</h3><p><code>&lt;animator&gt;</code>：对应<code>ValueAnimator</code></p><p>相比于<code>&lt;objectAnimator&gt;</code>少了一个<code>android:propertyName</code>，其他含义相同。</p><blockquote><p>Java创建</p></blockquote><pre><code class="hljs java">ValueAnimator anim = ValueAnimator.ofInt(<span class="hljs-keyword">int</span>... values);<span class="hljs-comment">//ValueAnimator anim = ValueAnimator.ofFloat(float... values);</span><span class="hljs-comment">//ValueAnimator anim = ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values);</span>anim.setDuration(duration);anim.setStartDelay(delay);anim.setRepeatCount(repeatCount);anim.setRepeatMode(repeatMode);anim.start();</code></pre><h5 id="应用代码-1"><a href="#应用代码-1" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs java">ValueAnimator anim = ValueAnimator.ofInt(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);        <span class="hljs-comment">// 设置动画运行的时长</span>        anim.setDuration(<span class="hljs-number">500</span>);               <span class="hljs-comment">// 设置动画延迟播放时间</span>        anim.setStartDelay(<span class="hljs-number">500</span>);        <span class="hljs-comment">// 设置动画重复播放次数 = 重放次数+1    </span>        anim.setRepeatCount(<span class="hljs-number">0</span>);         anim.setRepeatMode(ValueAnimator.RESTART);        anim.addUpdateLinstener(<span class="hljs-keyword">new</span> ValueAnimator.AnimatorUpdateListener()&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span></span>&#123;    <span class="hljs-keyword">int</span> currentValue = (Integer)animation.getAnimatedValue；            <span class="hljs-comment">//在其中对View进行相关属性设置 利用currentValue</span>              ...            view.requestLayout();  &#125;&#125;)        anim.start();</code></pre><h3 id="使用动画集合AnimatiorSet实现"><a href="#使用动画集合AnimatiorSet实现" class="headerlink" title="使用动画集合AnimatiorSet实现"></a>使用动画集合<code>AnimatiorSet</code>实现</h3><blockquote><p>利用集合类<code>AnimatorSet</code>，内部可以随意组合继承<code>Animator类</code>的子类，而且可以定制顺序。</p></blockquote><h5 id="应用代码-2"><a href="#应用代码-2" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs java"><span class="hljs-comment">// 平移动画</span>ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, <span class="hljs-string">"translationX"</span>, curTranslationX, <span class="hljs-number">300</span>,curTranslationX);  <span class="hljs-comment">// 旋转动画</span>ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, <span class="hljs-string">"rotation"</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">360f</span>);  <span class="hljs-comment">// 透明度动画</span>ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, <span class="hljs-string">"alpha"</span>, <span class="hljs-number">1f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>);  AnimatorSet animSet = <span class="hljs-keyword">new</span> AnimatorSet();  <span class="hljs-comment">// 设置动画执行顺序</span>animSet.play(translation).with(rotate).before(alpha);  animSet.setDuration(<span class="hljs-number">5000</span>);  animSet.start();</code></pre><h3 id="使用ViewPropertyAnimator实现"><a href="#使用ViewPropertyAnimator实现" class="headerlink" title="使用ViewPropertyAnimator实现"></a>使用<code>ViewPropertyAnimator</code>实现</h3><blockquote><p>专门针对VIew操作的属性动画，可以直接由view进行调用，相当于一个简单的实现方式。</p></blockquote><h5 id="应用代码-3"><a href="#应用代码-3" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs java"><span class="hljs-comment">//设置View 透明度以及平移</span>view.animate().alpha(<span class="hljs-number">0</span>).translationX(<span class="hljs-number">100</span>).setDuration(<span class="hljs-number">500</span>).start();</code></pre><h3 id="注意内存泄露"><a href="#注意内存泄露" class="headerlink" title="注意内存泄露"></a>注意内存泄露</h3><blockquote><p>在使用属性动画中的无限循环动画(<code>setRepeatCount(ValueAnimator.INFINITE)</code>)时，需要在合适的场合(<code>Activity关闭、View的detach</code>)取消动画</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>.onDestroy();    <span class="hljs-keyword">if</span>(animator.isRunning())&#123;      animator.cancel();    &#125;&#125;</code></pre><h2 id="3-理解插值器和估值器"><a href="#3-理解插值器和估值器" class="headerlink" title="3.理解插值器和估值器"></a>3.理解插值器和估值器</h2><h3 id="1-插值器-Interpolator"><a href="#1-插值器-Interpolator" class="headerlink" title="1.插值器(Interpolator)"></a>1.插值器(<code>Interpolator</code>)</h3><blockquote><p>根据时间流逝的百分比计算出当前属性值改变的百分比。确定了动画效果变化的模式，如匀速变化、加速变化等。</p></blockquote><p>系统内部预置了一些常用的插值器：</p><ul><li><code>LinearInterpolator</code> : 线性插值器 - 匀速运动</li><li><code>AccelerateDecelerateInterpolator</code>：加速减速插值器 - 两头慢中间快</li><li><code>DecelerateInterpolator</code>：减速插值器 - 越来越慢</li></ul><p>可以应用的对象：</p><ul><li>View动画： 上文有提到，对应设置属性为<code>android:interpolator</code></li><li>属性动画：实现<em>非匀速运动</em>的方法</li></ul><p>自定义插值器：</p><blockquote><p>可以高度定制化自己需要的运行轨迹。</p></blockquote><p>实现：需要实现<code>Interpolator/TimeInterpolator</code>接口并复写<code>getInterpolation()</code>方法。</p><blockquote><ol><li>补间动画 实现 <code>Interpolator</code>接口；属性动画实现<code>TimeInterpolator</code>接口</li><li><code>TimeInterpolator</code>接口是属性动画中新增的，用于兼容<code>Interpolator</code>接口，这使得所有过去的<code>Interpolator</code>实现类都可以直接在属性动画使用。</li></ol></blockquote><p>接口说明：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TimeInterpolator</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">getInterpolation</span><span class="hljs-params">(<span class="hljs-keyword">float</span> input)</span></span>;  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interpolator</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">TimeInterpolator</span></span>&#123;  &#125;input 变化范围为<span class="hljs-number">0</span>~<span class="hljs-number">1</span> 返回值<span class="hljs-keyword">float</span>型的  用于估值器计算的</code></pre><p>实现示例：<em>自定义插值器的关键在于<code>input</code>根据动画的进度(0%~100%)通过逻辑计算，得到当前属性值改变的百分比。</em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecelerateAccelerateInterpolator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TimeInterpolator</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getInterpolation</span><span class="hljs-params">(<span class="hljs-keyword">float</span> input)</span> </span>&#123;        <span class="hljs-keyword">float</span> result;        <span class="hljs-keyword">if</span> (input &lt;= <span class="hljs-number">0.5</span>) &#123;            result = (<span class="hljs-keyword">float</span>) (Math.sin(Math.PI * input)) / <span class="hljs-number">2</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            result = (<span class="hljs-keyword">float</span>) (<span class="hljs-number">2</span> - Math.sin(Math.PI * input)) / <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;</code></pre><h3 id="2-估值器-Evaluator"><a href="#2-估值器-Evaluator" class="headerlink" title="2.估值器(Evaluator)"></a>2.估值器(<code>Evaluator</code>)</h3><blockquote><p>根据当前属性改变的百分比来计算改变后的属性值</p></blockquote><p>系统提供了一些估值器：</p><ul><li><code>IntEvaluator</code>：整形估值器</li><li><code>FloatEvaluator</code>：浮点型估值器</li><li><code>ArgbEvaluator</code>：Color属性估值器</li></ul><p>可以应用的对象：</p><p><strong>属性动画专属</strong></p><p>使用方法：</p><pre><code class="hljs java">ValueAnimator anim = ValueAnimator.ofInt(<span class="hljs-keyword">int</span>... values);  <span class="hljs-comment">//使用的是 IntEvaluator</span>ValueAnimator anim = ValueAnimator.ofFloat(<span class="hljs-keyword">float</span>... values); <span class="hljs-comment">//使用的是 FloatEvaluator</span>ValueAnimator anim = ValueAnimator.ofArgb(<span class="hljs-keyword">int</span>... values);<span class="hljs-comment">// 使用的是 ArgbEvaluator</span><span class="hljs-comment">//需要自定义 估值器</span>ValueAnimator anim = ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values);</code></pre><p>自定义估值器：</p><blockquote><p>除了<code>int,float,color</code>类型之外的类型做动画，需要用到自定义估值器</p></blockquote><p>接口说明：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TypeEvaluator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">/**    * <span class="hljs-doctag">@param</span> fraction   估值小数 插值器的返回值    * <span class="hljs-doctag">@param</span> startValue 起始值    * <span class="hljs-doctag">@param</span> endValue   结束值    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction, T startValue, T endValue)</span></span>;&#125;</code></pre><p>实现实例：</p><p>先定义自定义对象</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;    <span class="hljs-comment">// 设置两个变量用于记录坐标的位置</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> x;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> y;    <span class="hljs-comment">// 构造方法用于设置坐标</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;    <span class="hljs-comment">// get方法用于获取坐标</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> y;    &#125;&#125;</code></pre><p>定义估值器</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointEvaluator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TypeEvaluator</span>&lt;<span class="hljs-title">Point</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Point <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction, Point startValue, Point endValue)</span> </span>&#123;        <span class="hljs-keyword">float</span> x = startValue.getX() + fraction * (endValue.getX() - startValue.getX());        <span class="hljs-keyword">float</span> y = startValue.getY() + fraction * (endValue.getY() - startValue.getY());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Point(x, y);    &#125;&#125;</code></pre><p>使用估值器</p><pre><code class="hljs java">Point startPoint = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<span class="hljs-comment">// 初始点为圆心(100, 100)</span>Point endPoint = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<span class="hljs-comment">// 结束点为(300, 300)</span>ValueAnimator anim = ValueAnimator.ofObject(<span class="hljs-keyword">new</span> PointEvaluator(), startPoint, endPoint);anim.setDuration(<span class="hljs-number">5000</span>);anim.start();</code></pre><h2 id="4-属性动画监听器"><a href="#4-属性动画监听器" class="headerlink" title="4.属性动画监听器"></a>4.属性动画监听器</h2><blockquote><p>可以监听属性动画的播放过程，包括<code>起始，结束，取消，重复</code>。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnimatorListener</span> </span>&#123;  <span class="hljs-comment">//动画开始</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(Animation animation)</span></span>;  <span class="hljs-comment">//动画结束</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationEnd</span><span class="hljs-params">(Animation animation)</span></span>;  <span class="hljs-comment">//动画取消</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationCancel</span><span class="hljs-params">(Animation animation)</span></span>;  <span class="hljs-comment">//动画重复</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationRepeat</span><span class="hljs-params">(Animation animation)</span></span>;&#125;调用方式animator.addListener(<span class="hljs-keyword">new</span> AnimatorListener()&#123; ...&#125;)；</code></pre><p>拓展：</p><p><code>AnimatorListenerAdapter</code>：<code>AnimatorListener</code>的适配器类，主要为了解决<strong>实现接口繁琐</strong>的问题。在大多数情况下，我们可能只要监听动画的开始和结束事件。如果直接继承<code>AnimatorListener</code>接口，就需要实现额外的方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimatorListenerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animator</span>.<span class="hljs-title">AnimatorListener</span>,        <span class="hljs-title">Animator</span>.<span class="hljs-title">AnimatorPauseListener</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationCancel</span><span class="hljs-params">(Animator animation)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationEnd</span><span class="hljs-params">(Animator animation)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationRepeat</span><span class="hljs-params">(Animator animation)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(Animator animation)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationPause</span><span class="hljs-params">(Animator animation)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationResume</span><span class="hljs-params">(Animator animation)</span> </span>&#123;    &#125;&#125;使用方式animator.addListener(<span class="hljs-keyword">new</span> AnimatorListenerAdapter()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(Animator animation)</span> </span>&#123;      <span class="hljs-comment">//只实现开始监听</span>    &#125;&#125;)</code></pre><h4 id="AnimatorUpdateListener：监听整个动画过程，每播放一帧，就会回调一次。"><a href="#AnimatorUpdateListener：监听整个动画过程，每播放一帧，就会回调一次。" class="headerlink" title="AnimatorUpdateListener：监听整个动画过程，每播放一帧，就会回调一次。"></a><code>AnimatorUpdateListener</code>：监听整个动画过程，每播放一帧，就会回调一次。</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AnimatorUpdateListener</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span>；&#125;</span></code></pre><p>利用这个特性，我们可以去对得到的数据进行处理。</p><p>上文中，自定义估值器，我们设置了一个<code>Point</code>对象，它的动画过程就是<code>Point</code>对象内部<code>x,y</code>变化的过程，我们就可以利用这个接口实时的去获取内部<code>x,y</code>进行操作。利用<code>ValueAnimator.getAnimatedValue()</code>就可以获取到对应的对象。</p><h2 id="5-对任意属性做动画"><a href="#5-对任意属性做动画" class="headerlink" title="5.对任意属性做动画"></a>5.对任意属性做动画</h2><p>上文中我们提到<code>android:propertyName</code>里面填的就是 属性动画可以支持的属性，假如我们要对View的宽度做动画，应该如何实现？</p><p><strong>属性动画的原理：属性动画要求动画作用的对象必须提供该属性的<code>get()和set()</code>方法，属性动画根据外界传递的该属性的初始值和结束值，以动画的效果多次去调用<code>set()</code>，每次传入的值不一样，随着时间推移，会越来越接近结束值。</strong></p><p>根据上述原理，我们可以得出一个结果。要想动画生效，必须支持两个条件：</p><ul><li><code>Object</code>必须提供<code>set()</code>，如果动画没有传递初始值，那么还要提供<code>get()</code>，因为系统要去获取初始值，计算最终值。（<em>不满足则直接Crash</em>）</li><li><code>Object</code>设置的<code>set()</code>必须可以让View产生变化，比如UI上会发生变化。(<em>不满足则不会发生变化</em>)</li></ul><p>针对上述条件，可以有3种解决方法：</p><ol><li><h4 id="给你的对象加上get-set-，如果你有权限的话"><a href="#给你的对象加上get-set-，如果你有权限的话" class="headerlink" title="给你的对象加上get(),set()，如果你有权限的话"></a>给你的对象加上<code>get(),set()</code>，如果你有权限的话</h4><blockquote><p>继承原始类，直接给继承类加上<code>get(),set()</code>，从而实现给对象加上该属性的<code>get(),set()</code></p></blockquote></li><li><h4 id="用一个类来包装原始对象，间接提供get-set"><a href="#用一个类来包装原始对象，间接提供get-set" class="headerlink" title="用一个类来包装原始对象，间接提供get(),set()"></a>用一个类来包装原始对象，间接提供<code>get(),set()</code></h4><blockquote><p>本质上是采用了设计模式中的装饰模式，即通过包装拓展对象的功能。</p></blockquote><p>示例：一开始就提到了对View的宽度进行动画效果，用这种方案就是找一个类来进行包装。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;  ImageView imageView;  ViewWrapper wrapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        imageView = (ImageView) findViewById(R.id.imageView);                <span class="hljs-comment">// 创建包装类,并传入动画作用的对象</span>        wrapper = <span class="hljs-keyword">new</span> ViewWrapper(imageView);                imageView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                ObjectAnimator.ofInt(wrapper, <span class="hljs-string">"width"</span><span class="hljs-comment">/*对应我们设置的getWidth()和setWidth()*/</span>, <span class="hljs-number">500</span>).setDuration(<span class="hljs-number">3000</span>).start();            &#125;        &#125;);    &#125;      <span class="hljs-comment">// 提供ViewWrapper类,用于包装View对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewWrapper</span> </span>&#123;        <span class="hljs-keyword">private</span> View mTarget;        <span class="hljs-comment">// 构造方法:传入需要包装的对象</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewWrapper</span><span class="hljs-params">(View target)</span> </span>&#123;            mTarget = target;        &#125;        <span class="hljs-comment">// 为宽度设置get（） &amp; set（）</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> mTarget.getLayoutParams().width;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width)</span> </span>&#123;            mTarget.getLayoutParams().width = width;            <span class="hljs-comment">//对View重新布局</span>            mTarget.requestLayout();        &#125;    &#125;&#125;</code></pre></li><li><h4 id="采用ValueAnimator，监听动画过程，利用返回值动态调整View属性"><a href="#采用ValueAnimator，监听动画过程，利用返回值动态调整View属性" class="headerlink" title="采用ValueAnimator，监听动画过程，利用返回值动态调整View属性"></a>采用<code>ValueAnimator</code>，监听动画过程，利用返回值动态调整View属性</h4><blockquote><p><code>ValueAnimator</code>本身不作用于任何对象，直接使用它不会有任何效果。做到的就是对一个View的属性进行变化。在动画过程中修改属性值，就类似于对对象做了动画。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span></span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>&#123;    setContentView(R.layout.main);    view.post(<span class="hljs-keyword">new</span> Runnable()&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;        performAnimator(view,view.getWidth,<span class="hljs-number">500</span>);      &#125;    &#125;)  &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performAnimatior</span><span class="hljs-params">(<span class="hljs-keyword">final</span> View target,<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start,<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end)</span></span>&#123;    ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);    valueAnimator.addUpdateListener(<span class="hljs-keyword">new</span> AnimatorUpdateListener()&#123;       <span class="hljs-keyword">private</span> IntEvaluator mEvaluator = <span class="hljs-keyword">new</span> IntEvaluator();       <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animator)</span></span>&#123;        <span class="hljs-keyword">int</span> currentValue = (Integer)animator.getAnimatedValue();        <span class="hljs-keyword">float</span> fraction = animator.getAnimatedFraction();        target.getLayoutParams().width = mEvaluator.evaluate(fraction,start,end);        target.requestLayout();      &#125;    &#125;);    valueAnimator.setDuration(<span class="hljs-number">5000</span>).start();  &#125;&#125;</code></pre></li></ol><h2 id="6-属性动画工作原理"><a href="#6-属性动画工作原理" class="headerlink" title="6.属性动画工作原理"></a>6.属性动画工作原理</h2><p><img src="/images/属性动画执行流程.png" srcset="/img/loading.gif" alt="属性动画执行流程"></p><blockquote><p>属性动画要求动画作用的对象必须提供该属性的<code>set()</code>方法，属性动画就会根据你传递的该属性的初始值和最终值，以动画的效果多次去调用<code>set()</code>。每次传递给<code>set()</code>的值都不一样，确切的来说是随着时间的推移，传递的值越来越接近最终值。如果动画不提供初始值，那就需要定义<code>get()</code>，以供系统去获取初始值。</p></blockquote><p>接下来就从入口处开始分析。</p><p><code>ObjectAnimator.ofFloat(view,&quot;alpha&quot;,0f,1f).start()</code>意味着动画开始。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/animation/ObjectAnimator.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">//如果动画已经执行，则停止动画</span>  AnimationHandler.getInstace().autoCancelBasedOn(<span class="hljs-keyword">this</span>);  <span class="hljs-keyword">super</span>.start()&#125;</code></pre><p><code>super.start()</code>就调用到父类<code>ValueAnimator.start()</code></p><h3 id="ValueAnimator-start"><a href="#ValueAnimator-start" class="headerlink" title="ValueAnimator.start()"></a>ValueAnimator.start()</h3><blockquote><p>属性动画执行</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// ../android/animation/ValueAnimator.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;  start(<span class="hljs-keyword">false</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> playBackwards)</span> </span>&#123;        <span class="hljs-keyword">if</span> (Looper.myLooper() == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AndroidRuntimeException(<span class="hljs-string">"Animators may only be run on Looper threads"</span>);        &#125;        mReversing = playBackwards;        mSelfPulse = !mSuppressSelfPulseRequested;        <span class="hljs-comment">// Special case: reversing from seek-to-0 should act as if not seeked at all.</span>        <span class="hljs-keyword">if</span> (playBackwards &amp;&amp; mSeekFraction != -<span class="hljs-number">1</span> &amp;&amp; mSeekFraction != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (mRepeatCount == INFINITE) &#123;                <span class="hljs-comment">// Calculate the fraction of the current iteration.</span>                <span class="hljs-keyword">float</span> fraction = (<span class="hljs-keyword">float</span>) (mSeekFraction - Math.floor(mSeekFraction));                mSeekFraction = <span class="hljs-number">1</span> - fraction;            &#125; <span class="hljs-keyword">else</span> &#123;                mSeekFraction = <span class="hljs-number">1</span> + mRepeatCount - mSeekFraction;            &#125;        &#125;        mStarted = <span class="hljs-keyword">true</span>;        mPaused = <span class="hljs-keyword">false</span>;        mRunning = <span class="hljs-keyword">false</span>;        mAnimationEndRequested = <span class="hljs-keyword">false</span>;        mLastFrameTime = -<span class="hljs-number">1</span>;        mFirstFrameTime = -<span class="hljs-number">1</span>;        mStartTime = -<span class="hljs-number">1</span>;        addAnimationCallback(<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span> (mStartDelay == <span class="hljs-number">0</span> || mSeekFraction &gt;= <span class="hljs-number">0</span> || mReversing) &#123;            startAnimation();<span class="hljs-comment">//开始动画并回调`onAnimationStart`</span>            <span class="hljs-keyword">if</span> (mSeekFraction == -<span class="hljs-number">1</span>) &#123;                setCurrentPlayTime(<span class="hljs-number">0</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                setCurrentFraction(mSeekFraction);            &#125;        &#125;    &#125;</code></pre><h4 id="startAnimation"><a href="#startAnimation" class="headerlink" title="startAnimation()"></a>startAnimation()</h4><blockquote><p>初始化一些变量以及回调<code>onAnimationStart()</code></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startAnimation</span><span class="hljs-params">()</span> </span>&#123;    ...    mAnimationEndRequested = <span class="hljs-keyword">false</span>;    initAnimation();    mRunning = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span> (mSeekFraction &gt;= <span class="hljs-number">0</span>) &#123;        mOverallFraction = mSeekFraction;    &#125; <span class="hljs-keyword">else</span> &#123;        mOverallFraction = <span class="hljs-number">0f</span>;    &#125;    <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-keyword">null</span>) &#123;        notifyStartListeners();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyStartListeners</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-keyword">null</span> &amp;&amp; !mStartListenersCalled) &#123;        ArrayList&lt;AnimatorListener&gt; tmpListeners =                (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();        <span class="hljs-keyword">int</span> numListeners = tmpListeners.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;            tmpListeners.get(i).onAnimationStart(<span class="hljs-keyword">this</span>, mReversing);<span class="hljs-comment">//回调onAnimationStart</span>        &#125;    &#125;    mStartListenersCalled = <span class="hljs-keyword">true</span>;&#125;</code></pre><h3 id="addAnimationCallback-0"><a href="#addAnimationCallback-0" class="headerlink" title="addAnimationCallback(0)"></a>addAnimationCallback(0)</h3><blockquote><p>真正执行动画的部分代码</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAnimationCallback</span><span class="hljs-params">(<span class="hljs-keyword">long</span> delay)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!mSelfPulse) &#123;        <span class="hljs-keyword">return</span>;    &#125;    getAnimationHandler().addAnimationFrameCallback(<span class="hljs-keyword">this</span>, delay);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> AnimationHandler <span class="hljs-title">getAnimationHandler</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> AnimationHandler.getInstance();&#125;</code></pre><h4 id="addAnimationFrameCallback"><a href="#addAnimationFrameCallback" class="headerlink" title="addAnimationFrameCallback()"></a>addAnimationFrameCallback()</h4><pre><code class="hljs java"><span class="hljs-comment">//AnimationHandler.java</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Choreographer.FrameCallback mFrameCallback = <span class="hljs-keyword">new</span> Choreographer.FrameCallback() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTimeNanos)</span> </span>&#123;            doAnimationFrame(getProvider().getFrameTime());            <span class="hljs-keyword">if</span> (mAnimationCallbacks.size() &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//回调为0时候</span>                getProvider().postFrameCallback(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//注册下一次的刷新事件监听</span>            &#125;        &#125;    &#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAnimationFrameCallback</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AnimationFrameCallback callback, <span class="hljs-keyword">long</span> delay)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mAnimationCallbacks.size() == <span class="hljs-number">0</span>) &#123;            getProvider().postFrameCallback(mFrameCallback);        &#125;        <span class="hljs-keyword">if</span> (!mAnimationCallbacks.contains(callback)) &#123;            mAnimationCallbacks.add(callback);        &#125;        <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span>) &#123;            mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> AnimationFrameCallbackProvider <span class="hljs-title">getProvider</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (mProvider == <span class="hljs-keyword">null</span>) &#123;            mProvider = <span class="hljs-keyword">new</span> MyFrameCallbackProvider();        &#125;        <span class="hljs-keyword">return</span> mProvider;    &#125;</code></pre><p>注册<code>mFrameCallback</code>到<code>Choreographer</code>的待执行队列里，并向底层注册一个屏幕刷新信号事件<code>onVsync()</code></p><p>此时的<code>mAnimationCallbacks</code>持有的是<code>ValueAnimator</code>集合</p><h4 id="postFrameCallback"><a href="#postFrameCallback" class="headerlink" title="postFrameCallback()"></a>postFrameCallback()</h4><blockquote><p>注册监听</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//AnimationHandler.java</span>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFrameCallbackProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AnimationFrameCallbackProvider</span> </span>&#123;        <span class="hljs-keyword">final</span> Choreographer mChoreographer = Choreographer.getInstance();        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postFrameCallback</span><span class="hljs-params">(Choreographer.FrameCallback callback)</span> </span>&#123;            mChoreographer.postFrameCallback(callback);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCommitCallback</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;            mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, <span class="hljs-keyword">null</span>);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getFrameTime</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> mChoreographer.getFrameTime();        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getFrameDelay</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> Choreographer.getFrameDelay();        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFrameDelay</span><span class="hljs-params">(<span class="hljs-keyword">long</span> delay)</span> </span>&#123;            Choreographer.setFrameDelay(delay);        &#125;    &#125;</code></pre><p><code>AnimationHandler</code>通过<code>Choreographer</code>向底层注册监听下一个<code>屏幕刷新信号</code>，接收到信号时<code>mFrameCallback</code>执行，调用<code>doAnimationFrame()</code>。如果还有动画未执行完毕，继续注册监听下一个<code>屏幕刷新信号</code>。</p><h3 id="Choreographer-postFrameCallback"><a href="#Choreographer-postFrameCallback" class="headerlink" title="Choreographer.postFrameCallback()"></a>Choreographer.postFrameCallback()</h3><blockquote><p>动画的核心类</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//Choreographer.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postFrameCallback</span><span class="hljs-params">(FrameCallback callback)</span> </span>&#123;        postFrameCallbackDelayed(callback, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postFrameCallbackDelayed</span><span class="hljs-params">(FrameCallback callback, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;        <span class="hljs-keyword">if</span> (callback == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"callback must not be null"</span>);        &#125;        postCallbackDelayedInternal(CALLBACK_ANIMATION,                callback, FRAME_CALLBACK_TOKEN, delayMillis);    &#125;</code></pre><p>其中<code>postCallbackDelayedInternal()</code>内部相关的代码可以参考<a href="/2020/05/30/View的刷新机制/" title="Android屏幕的刷新机制">Android屏幕的刷新机制</a></p><h3 id="AnimationHandler-doAnimationFrame"><a href="#AnimationHandler-doAnimationFrame" class="headerlink" title="AnimationHandler.doAnimationFrame()"></a>AnimationHandler.doAnimationFrame()</h3><blockquote><p>每次在<code>Vsync</code>信号来临时会执行到<code>doFrame()</code>对应执行到<code>doAnimationFrame()</code></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAnimationFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTime)</span> </span>&#123;    <span class="hljs-keyword">long</span> currentTime = SystemClock.uptimeMillis();    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = mAnimationCallbacks.size();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;        <span class="hljs-keyword">final</span> AnimationFrameCallback callback = mAnimationCallbacks.get(i);        <span class="hljs-keyword">if</span> (callback == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span> (isCallbackDue(callback, currentTime)) &#123;            callback.doAnimationFrame(frameTime);            <span class="hljs-keyword">if</span> (mCommitCallbacks.contains(callback)) &#123;                getProvider().postCommitCallback(<span class="hljs-keyword">new</span> Runnable() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                        commitAnimationFrame(callback, getProvider().getFrameTime());                    &#125;                &#125;);            &#125;        &#125;    &#125;    cleanUpList();&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCommitCallback</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;        mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, <span class="hljs-keyword">null</span>);    &#125;</code></pre><h4 id="cleanUpList"><a href="#cleanUpList" class="headerlink" title="cleanUpList()"></a>cleanUpList()</h4><blockquote><p>清理已经执行完毕的动画</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanUpList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (mListDirty) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mAnimationCallbacks.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span> (mAnimationCallbacks.get(i) == <span class="hljs-keyword">null</span>) &#123;                mAnimationCallbacks.remove(i);            &#125;        &#125;        mListDirty = <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h4 id="ValueAnimator-commitAnimationFrame"><a href="#ValueAnimator-commitAnimationFrame" class="headerlink" title="ValueAnimator.commitAnimationFrame()"></a>ValueAnimator.commitAnimationFrame()</h4><blockquote><p><code>callback</code>有效时，执行对应callback的<code>commitAnimationFrame()</code>，此时<code>callback</code>为<code>ValueAnimator</code></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitAnimationFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTime)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!mStartTimeCommitted) &#123;        mStartTimeCommitted = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">long</span> adjustment = frameTime - mLastFrameTime;        <span class="hljs-keyword">if</span> (adjustment &gt; <span class="hljs-number">0</span>) &#123;            mStartTime += adjustment;            <span class="hljs-keyword">if</span> (DEBUG) &#123;                Log.d(TAG, <span class="hljs-string">"Adjusted start time by "</span> + adjustment + <span class="hljs-string">" ms: "</span> + toString());            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>为了修正动画的第一帧时间</strong></p><p><code>Choreographer</code>内部持有多个队列，分别是<code>CALLBACK_INPUT(输入事件)</code>、<code>CALLBACK_ANIMATION(动画事件)</code>、<code>CALLBACK_TRAVERSAL(绘制事件)</code>，<code>CALLBACK_COMMIT(完成后的提交操作)</code>。此时<code>commitAnimationFrame()</code>执行在<code>CALLBACK_COMMIT</code>队列中，位于最后。</p><p>当有事件来后，先执行的是<code>动画事件</code>，如果页面太复杂，导致绘制时间过长，就可能导致下一个<code>Vsync</code>信号到来时，动画执行时会丢失前面几帧，利用<code>commitAnimationFrame</code>就可以及时修正第一帧的时间，使动画完整执行。</p><h3 id="ValueAnimator-doAnimationFrame"><a href="#ValueAnimator-doAnimationFrame" class="headerlink" title="ValueAnimator.doAnimationFrame()"></a>ValueAnimator.doAnimationFrame()</h3><blockquote><p><code>callback</code>有效时，执行对应callback的<code>doAnimationFrame()</code>，此时<code>callback</code>为<code>ValueAnimator</code></p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//ValueAnimator.java </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doAnimationFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTime)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mStartTime &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// First frame. If there is start delay, start delay count down will happen *after* this</span>            <span class="hljs-comment">// frame.</span>            mStartTime = mReversing <span class="hljs-comment">//动画是否反复</span>                    ? frameTime                    : frameTime + (<span class="hljs-keyword">long</span>) (mStartDelay * resolveDurationScale());        &#125;        <span class="hljs-comment">// Handle pause/resume</span>        <span class="hljs-keyword">if</span> (mPaused) &#123;            mPauseTime = frameTime;            removeAnimationCallback();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mResumed) &#123;            mResumed = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (mPauseTime &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// Offset by the duration that the animation was paused</span>                mStartTime += (frameTime - mPauseTime);            &#125;        &#125;        <span class="hljs-comment">//动画尚未执行时</span>        <span class="hljs-keyword">if</span> (!mRunning) &#123;            <span class="hljs-comment">// If not running, that means the animation is in the start delay phase of a forward</span>            <span class="hljs-comment">// running animation. In the case of reversing, we want to run start delay in the end.</span>            <span class="hljs-keyword">if</span> (mStartTime &gt; frameTime &amp;&amp; mSeekFraction == -<span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// This is when no seek fraction is set during start delay. If developers change the</span>                <span class="hljs-comment">// seek fraction during the delay, animation will start from the seeked position</span>                <span class="hljs-comment">// right away.</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// If mRunning is not set by now, that means non-zero start delay,</span>                <span class="hljs-comment">// no seeking, not reversing. At this point, start delay has passed.</span>                mRunning = <span class="hljs-keyword">true</span>;                startAnimation();<span class="hljs-comment">//开始动画</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> (mLastFrameTime &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (mSeekFraction &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">long</span> seekTime = (<span class="hljs-keyword">long</span>) (getScaledDuration() * mSeekFraction);                mStartTime = frameTime - seekTime;                mSeekFraction = -<span class="hljs-number">1</span>;            &#125;            mStartTimeCommitted = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// allow start time to be compensated for jank</span>        &#125;        mLastFrameTime = frameTime;        <span class="hljs-comment">// The frame time might be before the start time during the first frame of</span>        <span class="hljs-comment">// an animation.  The "current time" must always be on or after the start</span>        <span class="hljs-comment">// time to avoid animating frames at negative time intervals.  In practice, this</span>        <span class="hljs-comment">// is very rare and only happens when seeking backwards.</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> currentTime = Math.max(frameTime, mStartTime);<span class="hljs-comment">//判断当前动画执行的时间</span>        <span class="hljs-keyword">boolean</span> finished = animateBasedOnTime(currentTime);<span class="hljs-comment">//动画是否执行完毕</span>        <span class="hljs-keyword">if</span> (finished) &#123;            endAnimation();        &#125;        <span class="hljs-keyword">return</span> finished;    &#125;</code></pre><h4 id="endAnimation"><a href="#endAnimation" class="headerlink" title="endAnimation()"></a>endAnimation()</h4><blockquote><p>动画执行完毕后的清理工作，并且回调<code>onAnimationEnd</code>监听</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endAnimation</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (mAnimationEndRequested) &#123;            <span class="hljs-keyword">return</span>;        &#125;        removeAnimationCallback();        mAnimationEndRequested = <span class="hljs-keyword">true</span>;        mPaused = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">boolean</span> notify = (mStarted || mRunning) &amp;&amp; mListeners != <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (notify &amp;&amp; !mRunning) &#123;            <span class="hljs-comment">// If it's not yet running, then start listeners weren't called. Call them now.</span>            notifyStartListeners();        &#125;        mRunning = <span class="hljs-keyword">false</span>;        mStarted = <span class="hljs-keyword">false</span>;        mStartListenersCalled = <span class="hljs-keyword">false</span>;        mLastFrameTime = -<span class="hljs-number">1</span>;        mFirstFrameTime = -<span class="hljs-number">1</span>;        mStartTime = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (notify &amp;&amp; mListeners != <span class="hljs-keyword">null</span>) &#123;            ArrayList&lt;AnimatorListener&gt; tmpListeners =                    (ArrayList&lt;AnimatorListener&gt;) mListeners.clone();            <span class="hljs-keyword">int</span> numListeners = tmpListeners.size();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;                tmpListeners.get(i).onAnimationEnd(<span class="hljs-keyword">this</span>, mReversing);<span class="hljs-comment">//回调 onAnimationEnd</span>            &#125;        &#125;        <span class="hljs-comment">// mReversing needs to be reset *after* notifying the listeners for the end callbacks.</span>        mReversing = <span class="hljs-keyword">false</span>;    &#125;<span class="hljs-comment">//AnimationHelper.java</span><span class="hljs-comment">//移除动画执行监听</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeCallback</span><span class="hljs-params">(AnimationFrameCallback callback)</span> </span>&#123;        mCommitCallbacks.remove(callback);        mDelayedCallbackStartTime.remove(callback);        <span class="hljs-keyword">int</span> id = mAnimationCallbacks.indexOf(callback);        <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span>) &#123;            mAnimationCallbacks.set(id, <span class="hljs-keyword">null</span>);            mListDirty = <span class="hljs-keyword">true</span>;        &#125;    &#125;</code></pre><h4 id="ValueAnimator-animateBasedOnTime"><a href="#ValueAnimator-animateBasedOnTime" class="headerlink" title="ValueAnimator.animateBasedOnTime()"></a>ValueAnimator.animateBasedOnTime()</h4><blockquote><p>根据当前时间计算并实现当前帧的动画</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">animateBasedOnTime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> currentTime)</span> </span>&#123;    <span class="hljs-keyword">boolean</span> done = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (mRunning) &#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> scaledDuration = getScaledDuration();        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> fraction = scaledDuration &gt; <span class="hljs-number">0</span> ?                (<span class="hljs-keyword">float</span>)(currentTime - mStartTime) / scaledDuration : <span class="hljs-number">1f</span>;         <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> lastFraction = mOverallFraction;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> newIteration = (<span class="hljs-keyword">int</span>) fraction &gt; (<span class="hljs-keyword">int</span>) lastFraction;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> lastIterationFinished = (fraction &gt;= mRepeatCount + <span class="hljs-number">1</span>) &amp;&amp;                (mRepeatCount != INFINITE);        <span class="hljs-keyword">if</span> (scaledDuration == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 0 duration animator, ignore the repeat count and skip to the end</span>            done = <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newIteration &amp;&amp; !lastIterationFinished) &#123;            <span class="hljs-comment">// Time to repeat</span>            <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">int</span> numListeners = mListeners.size();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;                    mListeners.get(i).onAnimationRepeat(<span class="hljs-keyword">this</span>);                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastIterationFinished) &#123;            done = <span class="hljs-keyword">true</span>;        &#125;        mOverallFraction = clampFraction(fraction);        <span class="hljs-keyword">float</span> currentIterationFraction = getCurrentIterationFraction(                mOverallFraction, mReversing);        animateValue(currentIterationFraction);    &#125;    <span class="hljs-keyword">return</span> done;&#125;</code></pre><h5 id="clampFraction"><a href="#clampFraction" class="headerlink" title="clampFraction()"></a>clampFraction()</h5><blockquote><p>根据当前时间以及动画第一帧时间还有动画持续的时长来计算当前的动画进度。</p><p>确保动画进度的取值在<code>0-1</code>之间。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> <span class="hljs-title">clampFraction</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;    <span class="hljs-keyword">if</span> (fraction &lt; <span class="hljs-number">0</span>) &#123;        fraction = <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mRepeatCount != INFINITE) &#123;        fraction = Math.min(fraction, mRepeatCount + <span class="hljs-number">1</span>);<span class="hljs-comment">//得到重复执行后的累加进度</span>    &#125;    <span class="hljs-keyword">return</span> fraction;&#125;<span class="hljs-comment">//保证返回值位于 0-1之间</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getCurrentIterationFraction</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction, <span class="hljs-keyword">boolean</span> inReverse)</span> </span>&#123;    fraction = clampFraction(fraction);    <span class="hljs-keyword">int</span> iteration = getCurrentIteration(fraction);    <span class="hljs-keyword">float</span> currentFraction = fraction - iteration;    <span class="hljs-keyword">return</span> shouldPlayBackward(iteration, inReverse) ? <span class="hljs-number">1f</span> - currentFraction : currentFraction;&#125;</code></pre><h3 id="ValueAnimator-animateValue"><a href="#ValueAnimator-animateValue" class="headerlink" title="ValueAnimator.animateValue()"></a>ValueAnimator.animateValue()</h3><blockquote><p>前面计算得到当前动画进度后，需要应用该值到View上</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">animateValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;    fraction = mInterpolator.getInterpolation(fraction);    mCurrentFraction = fraction;    <span class="hljs-keyword">int</span> numValues = mValues.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numValues; ++i) &#123;        mValues[i].calculateValue(fraction);    &#125;    <span class="hljs-keyword">if</span> (mUpdateListeners != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">int</span> numListeners = mUpdateListeners.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;            mUpdateListeners.get(i).onAnimationUpdate(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//通知动画的监听回调</span>        &#125;    &#125;&#125;</code></pre><h4 id="getInterpolation"><a href="#getInterpolation" class="headerlink" title="getInterpolation()"></a>getInterpolation()</h4><blockquote><p>根据设置的插值器获取应当达到的进度</p></blockquote><h3 id="PropertyValuesHolder-calculateValue"><a href="#PropertyValuesHolder-calculateValue" class="headerlink" title="PropertyValuesHolder.calculateValue()"></a>PropertyValuesHolder.calculateValue()</h3><blockquote><p>根据进度计算最终需要用到的数值</p></blockquote><pre><code class="hljs java">Keyframes mKeyframes = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//关键帧   </span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calculateValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;    Object value = mKeyframes.getValue(fraction);    mAnimatedValue = mConverter == <span class="hljs-keyword">null</span> ? value : mConverter.convert(value);&#125;</code></pre><p>在执行<code>ObjectAnimator.start()</code>之前，需要先执行<code>ObjectAnimator.ofFloat(float... values)</code></p><pre><code class="hljs java"><span class="hljs-comment">//ValueAnimator.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFloatValues</span><span class="hljs-params">(<span class="hljs-keyword">float</span>... values)</span> </span>&#123;        <span class="hljs-keyword">if</span> (values == <span class="hljs-keyword">null</span> || values.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (mValues == <span class="hljs-keyword">null</span> || mValues.length == <span class="hljs-number">0</span>) &#123;            setValues(PropertyValuesHolder.ofFloat(<span class="hljs-string">""</span>, values));        &#125; <span class="hljs-keyword">else</span> &#123;            PropertyValuesHolder valuesHolder = mValues[<span class="hljs-number">0</span>];            valuesHolder.setFloatValues(values);        &#125;        <span class="hljs-comment">// New property/values/target should cause re-initialization prior to starting</span>        mInitialized = <span class="hljs-keyword">false</span>;    &#125;<span class="hljs-comment">//PropertyValuesHolder.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFloatValues</span><span class="hljs-params">(<span class="hljs-keyword">float</span>... values)</span> </span>&#123;        mValueType = <span class="hljs-keyword">float</span><span class="hljs-class">.<span class="hljs-keyword">class</span></span>;        mKeyframes = KeyframeSet.ofFloat(values);    &#125;</code></pre><p>所以<code>mKeyFrames.getValue(XX)</code>中的<code>mKeyFrames</code>为<code>KeyframeSet.ofFloat()</code></p><h4 id="KeyframeSet-ofFloat"><a href="#KeyframeSet-ofFloat" class="headerlink" title="KeyframeSet.ofFloat()"></a>KeyframeSet.ofFloat()</h4><blockquote><p><code>KeyframeSet</code>关键帧集合，根据传入的节点，生成<code>FloatkeyframeSet</code></p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//KeyframeSet.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> KeyframeSet <span class="hljs-title">ofFloat</span><span class="hljs-params">(<span class="hljs-keyword">float</span>... values)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> badValue = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> numKeyframes = values.length;        FloatKeyframe keyframes[] = <span class="hljs-keyword">new</span> FloatKeyframe[Math.max(numKeyframes,<span class="hljs-number">2</span>)];<span class="hljs-comment">//关键帧集合</span>        <span class="hljs-keyword">if</span> (numKeyframes == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//只有一个关键帧，生成两个一致的帧</span>            keyframes[<span class="hljs-number">0</span>] = (FloatKeyframe) Keyframe.ofFloat(<span class="hljs-number">0f</span>);            keyframes[<span class="hljs-number">1</span>] = (FloatKeyframe) Keyframe.ofFloat(<span class="hljs-number">1f</span>, values[<span class="hljs-number">0</span>]);            <span class="hljs-keyword">if</span> (Float.isNaN(values[<span class="hljs-number">0</span>])) &#123;                badValue = <span class="hljs-keyword">true</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//超过一个关键帧，按照传入数量，生成对应数量的帧集合</span>            keyframes[<span class="hljs-number">0</span>] = (FloatKeyframe) Keyframe.ofFloat(<span class="hljs-number">0f</span>, values[<span class="hljs-number">0</span>]);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; numKeyframes; ++i) &#123;                keyframes[i] =                        (FloatKeyframe) Keyframe.ofFloat((<span class="hljs-keyword">float</span>) i / (numKeyframes - <span class="hljs-number">1</span>), values[i]);                <span class="hljs-keyword">if</span> (Float.isNaN(values[i])) &#123;                    badValue = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (badValue) &#123;            Log.w(<span class="hljs-string">"Animator"</span>, <span class="hljs-string">"Bad value (NaN) in float animator"</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FloatKeyframeSet(keyframes);    &#125;</code></pre><h4 id="FloatKeyframeSet-getValue"><a href="#FloatKeyframeSet-getValue" class="headerlink" title="FloatKeyframeSet.getValue()"></a>FloatKeyframeSet.getValue()</h4><blockquote><p>根据当前进度，返回关键帧数值</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//FloatKeyframeSet.java</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FloatKeyframeSet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">KeyframeSet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Keyframes</span>.<span class="hljs-title">FloatKeyframes</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FloatKeyframeSet</span><span class="hljs-params">(FloatKeyframe... keyframes)</span> </span>&#123;        <span class="hljs-keyword">super</span>(keyframes);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;        <span class="hljs-keyword">return</span> getFloatValue(fraction);    &#125;   <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getFloatValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;        <span class="hljs-keyword">if</span> (fraction &lt;= <span class="hljs-number">0f</span>) &#123;<span class="hljs-comment">//初始点</span>            <span class="hljs-keyword">final</span> FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//第一帧</span>            <span class="hljs-keyword">final</span> FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(<span class="hljs-number">1</span>);<span class="hljs-comment">//第二帧</span>            ...            <span class="hljs-keyword">return</span> mEvaluator == <span class="hljs-keyword">null</span> ?                    prevValue + intervalFraction * (nextValue - prevValue) :                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).                            floatValue();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fraction &gt;= <span class="hljs-number">1f</span>) &#123;<span class="hljs-comment">//终点</span>            <span class="hljs-keyword">final</span> FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - <span class="hljs-number">2</span>);<span class="hljs-comment">//倒数第二帧</span>            <span class="hljs-keyword">final</span> FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - <span class="hljs-number">1</span>);<span class="hljs-comment">//倒数第一帧</span>            ...            <span class="hljs-keyword">return</span> mEvaluator == <span class="hljs-keyword">null</span> ?                    prevValue + intervalFraction * (nextValue - prevValue) :                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).                            floatValue();        &#125;        FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; mNumKeyframes; ++i) &#123;<span class="hljs-comment">//其中位置</span>            FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(i);            <span class="hljs-keyword">if</span> (fraction &lt; nextKeyframe.getFraction()) &#123;                ...                <span class="hljs-keyword">return</span> mEvaluator == <span class="hljs-keyword">null</span> ?                        prevValue + intervalFraction * (nextValue - prevValue) :                        ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).                            floatValue();            &#125;            prevKeyframe = nextKeyframe;        &#125;        <span class="hljs-comment">// shouldn't get here</span>        <span class="hljs-keyword">return</span> ((Number)mKeyframes.get(mNumKeyframes - <span class="hljs-number">1</span>).getValue()).floatValue();    &#125;    ...&#125;</code></pre><p><code>getFloatValue()</code>根据以下情况返回不同结果：</p><ul><li><code>起点</code>：取出第一和第二帧，得到对应进度</li><li><code>终点</code>：取出倒数第二和第一帧，得到对应进度</li><li><code>中间点</code>：遍历找到输入进度<code>fraction</code>位于第一帧和第几关键帧之间，然后计算关键帧转换得到的进度</li></ul><h3 id="ObjectAnimator-animateValue"><a href="#ObjectAnimator-animateValue" class="headerlink" title="ObjectAnimator.animateValue()"></a>ObjectAnimator.animateValue()</h3><blockquote><p><code>ValueAnimator</code>子类<code>ObjectAnimator</code>重写了该方法</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">animateValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction)</span> </span>&#123;    <span class="hljs-keyword">final</span> Object target = getTarget();    <span class="hljs-keyword">if</span> (mTarget != <span class="hljs-keyword">null</span> &amp;&amp; target == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// We lost the target reference, cancel and clean up. Note: we allow null target if the</span>        <span class="hljs-comment">/// target has never been set.</span>        cancel();        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">super</span>.animateValue(fraction);    <span class="hljs-keyword">int</span> numValues = mValues.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numValues; ++i) &#123;        mValues[i].setAnimatedValue(target);    &#125;&#125;</code></pre><p><code>super.animaterValue()</code>指的就是前面的<code>ValueAnimator.animateValue()</code>，在计算得到进度之后，<code>ObjectAnimator</code>是对对象生效的，接下来</p><p>需要将值赋予<code>target</code></p><h4 id="PropetryValuesHolder-setAnimatedValue"><a href="#PropetryValuesHolder-setAnimatedValue" class="headerlink" title="PropetryValuesHolder.setAnimatedValue()"></a>PropetryValuesHolder.setAnimatedValue()</h4><blockquote><p>针对<code>target</code>进行赋值操作</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAnimatedValue</span><span class="hljs-params">(Object target)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mProperty != <span class="hljs-keyword">null</span>) &#123;        mProperty.set(target, getAnimatedValue());    &#125;    <span class="hljs-keyword">if</span> (mSetter != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">try</span> &#123;            mTmpValueArray[<span class="hljs-number">0</span>] = getAnimatedValue();            mSetter.invoke(target, mTmpValueArray);        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;            Log.e(<span class="hljs-string">"PropertyValuesHolder"</span>, e.toString());        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;            Log.e(<span class="hljs-string">"PropertyValuesHolder"</span>, e.toString());        &#125;    &#125;&#125;</code></pre><p>拿<code>ObjectAnimator.ofFloat(view,View.SCALE_X,0f,1f)</code>为例，分析<code>setAnimatedValue()</code>执行结果</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupSetter</span><span class="hljs-params">(Class targetClass)</span> </span>&#123;    Class&lt;?&gt; propertyType = mConverter == <span class="hljs-keyword">null</span> ? mValueType : mConverter.getTargetType();    mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, <span class="hljs-string">"set"</span>, propertyType);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> Method <span class="hljs-title">setupSetterOrGetter</span><span class="hljs-params">(Class targetClass,        HashMap&lt;Class, HashMap&lt;String, Method&gt;&gt; propertyMapMap,        String prefix, Class valueType)</span> </span>&#123;  ...    setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);  ...&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> Method <span class="hljs-title">getPropertyFunction</span><span class="hljs-params">(Class targetClass, String prefix, Class valueType)</span> </span>&#123;    Method returnVal = <span class="hljs-keyword">null</span>;    String methodName = getMethodName(prefix, mPropertyName); <span class="hljs-comment">//方法名setScaleX() </span>    ... <span class="hljs-comment">//反射获取方法</span>   &#125;</code></pre><blockquote><p><code>PropertyValuesHolder</code>负责<strong>保存动画过程中所需要操作的属性和值</strong>。<code>ObjectAnimator.ofFloat(Object target,String propertyName.float... values)</code>内部的参数会被封装成<code>PropertyValuesHolder</code>实例。</p></blockquote><p><img src="/images/属性动画执行过程.jpg" srcset="/img/loading.gif" alt="属性动画执行过程"></p><h2 id="7-View-setXX"><a href="#7-View-setXX" class="headerlink" title="7.View.setXX()"></a>7.View.setXX()</h2><ul><li><code>alpha</code>：更改View的不透明度</li><li><code>x</code>、<code>y</code>、<code>translationX</code>、<code>translationY</code>：更改View的位置</li><li><code>scaleX</code>、<code>scaleY</code>：更改View的缩放</li><li><code>rotation</code>、<code>rotationX</code>、<code>rotationY</code>：更改View在3D空间的方向</li><li><code>pivotX</code>、<code>pivotY</code>：更改View的转换原点</li></ul><h2 id="8-参考链接"><a href="#8-参考链接" class="headerlink" title="8.参考链接"></a>8.参考链接</h2><p><a href="http://gityuan.com/2015/09/06/android-anaimator-4/" target="_blank" rel="noopener">源码解读Android属性动画</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android性能优化-网络优化详解</title>
    <link href="/2020/10/09/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/10/09/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<!--DNS优化 连接优化 弱网优化-->]]></content>
    
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-AQS-Condition原理及解析</title>
    <link href="/2020/10/08/Java-AQS-Condition%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/10/08/Java-AQS-Condition%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-CountDownLatch原理及解析</title>
    <link href="/2020/10/08/Java-CountDownLatch%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/10/08/Java-CountDownLatch%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebRTC-Mediasoup编译记录</title>
    <link href="/2020/09/24/WebRTC-Mediasoup%E7%BC%96%E8%AF%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/09/24/WebRTC-Mediasoup%E7%BC%96%E8%AF%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="下载相关文件"><a href="#下载相关文件" class="headerlink" title="下载相关文件"></a>下载相关文件</h3><ul><li><a href="https://github.com/versatica/libmediasoupclient" target="_blank" rel="noopener">libmediasoupclient</a></li><li><a href="https://webrtc.googlesource.com/src" target="_blank" rel="noopener">webrtc</a></li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://github.com/mail2chromium/Compile_WebRTC_Library_For_Android" target="_blank" rel="noopener">compile_webrtc</a></p><p><a href="https://mediasoup.org/documentation/v3/libmediasoupclient/installation/" target="_blank" rel="noopener">mediasoup doc</a></p><h3 id="编译webrtc"><a href="#编译webrtc" class="headerlink" title="编译webrtc"></a>编译webrtc</h3><pre><code class="hljs shell">//编译工具下载git clone https://chromium.googlesource.com/chromium/tools/depot_tools.gitexport PATh="$PATH:$&#123;HOME&#125;/depot_tools" //配置环境变量//下载webrtc源码mkdir webrtc_androidcd webrtc_androidgit clone https://webrtc.googlesource.com/srcfetch --nohooks webrtc_androidgclient sync//编译webrtc源码cd src./build/install-build-deps.shgn gen out/Debug --args='target_os="android" target_cpu="arm"'// gn gen out/Release --args='is_debug=false is_component_build=false rtc_include_tests=false target_os="android" target_cpu="arm"'autoninja -C out/Debug//autoninja -C out/Release</code></pre><p>对应文件输出目录：</p><p>./out/Debug/lib_java/sdk/android/libwebrtc.jar </p><p>./out/Debug/libjingle_peerconnection_so.so</p><p>上面这俩是Android需要用到的sdk</p><p>./out/Debug/lib.unstripped/libjingle_peerconnection_so.so</p><p>./out/Debug/obj/libwebrtc.a //静态链接</p><h3 id="编译libmediasoupclient"><a href="#编译libmediasoupclient" class="headerlink" title="编译libmediasoupclient"></a>编译libmediasoupclient</h3><h4 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h4><p>git clone <a href="https://github.com/versatica/libmediasoupclient" target="_blank" rel="noopener">https://github.com/versatica/libmediasoupclient</a></p><p>cd libmediasoupclient/</p><h4 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h4><pre><code class="hljs shell">cmake . -Bbuild \-DLIBWEBRTC_INCLUDE_PATH:PATH=PATH_TO_LIBWEBRTC_SOURCES \     # src源代码目录-DLIBWEBRTC_BINARY_PATH:PATH=PATH_TO_LIBWEBRTC_BINARY         # 编译出libwebrtc.a目录</code></pre><p>示例配置</p><p>cmake . -Bbuild   -DLIBWEBRTC_INCLUDE_PATH:PATH=/home/zaze/Desktop/webrtc_android/src   -DLIBWEBRTC_BINARY_PATH:PATH=/home/zaze/Desktop/webrtc_android/src/out/Debug/obj</p><p>运行命令后，再执行</p><pre><code class="hljs shell">make -C build/</code></pre><p>在<code>./build/</code>目录下会生成<code>libmediasoupclient.a</code>文件取出备用</p><h3 id="获取libmediasoupclient-sdk"><a href="#获取libmediasoupclient-sdk" class="headerlink" title="获取libmediasoupclient sdk"></a>获取libmediasoupclient sdk</h3><p>基于<a href="https://github.com/haiyangwu/mediasoup-client-android" target="_blank" rel="noopener">mediasoup-client-android</a>进行编译，注意以下关键点：</p><ul><li>clone后的项目里面的<code>mediasoup-client/deps/webrtc/lib</code>里面的<code>libwebrtc.a</code>文件都是有误的，需要从<code>https://github.com/haiyangwu/webrtc-android-build</code>获取对应版本的文件，下载完成后替换原有的<code>libs</code>目录</li></ul><p>TODO:后续替换为最新版的<code>libmediasoupclient</code>和<code>webrtc</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>WebRTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin-泛型</title>
    <link href="/2020/09/21/Kotlin-%E6%B3%9B%E5%9E%8B/"/>
    <url>/2020/09/21/Kotlin-%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac软件清单</title>
    <link href="/2020/09/17/Mac%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/"/>
    <url>/2020/09/17/Mac%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h3 id="电池管理软件"><a href="#电池管理软件" class="headerlink" title="电池管理软件"></a>电池管理软件</h3><p><a href="https://github.com/zackelia/bclm" target="_blank" rel="noopener">bclm-Github</a></p><p>AIDente</p>]]></content>
    
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-流量统计</title>
    <link href="/2020/09/15/Android-%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/"/>
    <url>/2020/09/15/Android-%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="流量统计"><a href="#流量统计" class="headerlink" title="流量统计"></a>流量统计</h2><p>Android目前提供了两种流量计算方案</p><ul><li><code>TrafficStats</code></li><li><code>NetworkStatsManager</code></li></ul><p>这两种方案有着各自的优缺点与限制，下面简单的记录一下</p><p><img src="/images/流量统计.png" srcset="/img/loading.gif" alt="流量统计"></p><h3 id="TrafficStats"><a href="#TrafficStats" class="headerlink" title="TrafficStats"></a>TrafficStats</h3><blockquote><p>Android API8后提供的该类，可以获取<strong>设备重启以来的流量信息</strong>。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrafficStats</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getMobileRxBytes</span><span class="hljs-params">()</span> <span class="hljs-comment">//移动网络接受的总流量</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getMobileTxBytes</span><span class="hljs-params">()</span> <span class="hljs-comment">//移动网络发送的总流量</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTotalTxBytes</span><span class="hljs-params">()</span> <span class="hljs-comment">//发送的总数据流量</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTotalRxBytes</span><span class="hljs-params">()</span> <span class="hljs-comment">//接收的总数据流量</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getUidRxBytes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> uid)</span> <span class="hljs-comment">//指定uid接收的流量</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getUidTxBytes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> uid)</span> <span class="hljs-comment">//指定uid发送的流量</span>&#125;</span></code></pre><p>以上为<code>TrafficStats</code>提供的基本方法</p><p>根据上述方法可以大致得到当前设备使用的流量数据，<code>getMobileXX()</code>获取移动网络数据，<code>getTotalXX()</code>获取总流量数据，所以<code>getTotalXX()-getMobileXX()</code>大致可以得到Wifi的使用数据。还可以通过指定<code>getUidXX()</code>获取指定应用的流量数据。</p><p>优点：</p><ul><li>调用方法简单，无需特别权限</li></ul><p>缺点：</p><ul><li><p>无法获取某个时间段内的流量消耗</p><p>统计的是设备启动以来的流量数据，无法判断是从哪个时间段开始的流量统计</p></li><li><p>无法获取指定应用的wifi类型流量数据</p><p>虽然可以通过监听网络变化去获取对应数据，实际可操作性不高</p></li></ul><h4 id="简单原理介绍"><a href="#简单原理介绍" class="headerlink" title="简单原理介绍"></a>简单原理介绍</h4><p>上述方法内部实现都是通过<code>getStatsService()</code>进行调用</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> INetworkStatsService <span class="hljs-title">getStatsService</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (sStatsService == <span class="hljs-keyword">null</span>) &#123;        sStatsService = INetworkStatsService.Stub.asInterface(                ServiceManager.getService(Context.NETWORK_STATS_SERVICE));    &#125;    <span class="hljs-keyword">return</span> sStatsService;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTotalTxPackets</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> getStatsService().getTotalStats(TYPE_TX_PACKETS);    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;        <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();    &#125;&#125;</code></pre><p>通过AIDL调用到<code>NetWorkStatsService</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkStatsService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">INetworkStatsService</span>.<span class="hljs-title">Stub</span> </span>&#123; ...<span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTotalStats</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;        <span class="hljs-keyword">long</span> nativeTotalStats = nativeGetTotalStat(type, checkBpfStatsEnable());        <span class="hljs-keyword">if</span> (nativeTotalStats == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> nativeTotalStats;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// Refer to comment in getIfaceStats</span>            <span class="hljs-keyword">return</span> nativeTotalStats + getTetherStats(IFACE_ALL, type);        &#125;    &#125;&#125;   <span class="hljs-comment">//判断是否启用 bpf流量监控</span>   mUseBpfTrafficStats = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"/sys/fs/bpf/traffic_uid_stats_map"</span>).exists();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkBpfStatsEnable</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mUseBpfTrafficStats;    &#125;</code></pre><p><code>bpf流量监控</code>是在Android 9之后提供的，需要在Android P上的设备才可以使用。老的监控方式逐渐被废弃。</p><p>通过JNI调用<code>com_android_server_net_NetworkStatsService.cpp</code></p><pre><code class="hljs c++"><span class="hljs-comment">//流量记录文件路径</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* QTAGUID_IFACE_STATS = <span class="hljs-string">"/proc/net/xt_qtaguid/iface_stat_fmt"</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* QTAGUID_UID_STATS = <span class="hljs-string">"/proc/net/xt_qtaguid/stats"</span>;<span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">getTotalStat</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jint type, jboolean useBpfStats)</span> </span>&#123;    Stats stats = &#123;&#125;;    <span class="hljs-keyword">if</span> (useBpfStats) &#123;        <span class="hljs-keyword">if</span> (bpfGetIfaceStats(<span class="hljs-literal">NULL</span>, &amp;stats) == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> getStatsType(&amp;stats, (StatsType) type);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> UNKNOWN;        &#125;    &#125;    <span class="hljs-keyword">if</span> (parseIfaceStats(<span class="hljs-literal">NULL</span>, &amp;stats) == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> getStatsType(&amp;stats, (StatsType) type);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> UNKNOWN;    &#125;&#125;</code></pre><p>在Android 9之前，通过读取<code>/proc/net/xt_qtaguid/stats</code>文件内容进行解析获取对应流量数据。</p><p>Android9 之后，通过读取<code>/sys/fs/bpf/traffic_uid_stats_map</code>获取数据</p><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrafficStatsHelper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAllRxBytes</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> TrafficStats.getTotalRxBytes();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAllTxBytes</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> TrafficStats.getTotalTxBytes();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAllRxBytesMobile</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> TrafficStats.getMobileRxBytes();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAllTxBytesMobile</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> TrafficStats.getMobileTxBytes();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAllRxBytesWifi</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> TrafficStats.getTotalRxBytes() - TrafficStats.getMobileRxBytes();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getAllTxBytesWifi</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> TrafficStats.getTotalTxBytes() - TrafficStats.getMobileTxBytes();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getPackageRxBytes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> uid)</span> </span>&#123;        <span class="hljs-keyword">return</span> TrafficStats.getUidRxBytes(uid);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getPackageTxBytes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> uid)</span> </span>&#123;        <span class="hljs-keyword">return</span> TrafficStats.getUidTxBytes(uid);    &#125;&#125;调用实例：TrafficStats.getUidRxBytes(Process.myUid()) <span class="hljs-comment">//当前不支持外部获取对应应用的流量信息，如果有需求需要使用NetWorkStatsManager</span></code></pre><h3 id="NetworkStatsManager"><a href="#NetworkStatsManager" class="headerlink" title="NetworkStatsManager"></a>NetworkStatsManager</h3><blockquote><p>Android 6.0之后新增加的类，可以获取历史的流量信息，并且支持查询时间段的流量数据</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Bucket <span class="hljs-title">querySummaryForDevice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> networkType, String subscriberId,            <span class="hljs-keyword">long</span> startTime, <span class="hljs-keyword">long</span> endTime)</span>  <span class="hljs-comment">//获取当前设备指定网络类型以及时间间隔内的所有流量信息</span><span class="hljs-keyword">public</span> NetworkStats <span class="hljs-title">queryDetailsForUid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> networkType, String subscriberId,            <span class="hljs-keyword">long</span> startTime, <span class="hljs-keyword">long</span> endTime, <span class="hljs-keyword">int</span> uid)</span> <span class="hljs-comment">//获取某id下的所有流量信息</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> class Bucket </span>&#123; ...        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getRxBytes</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//接收的流量</span>            <span class="hljs-keyword">return</span> mRxBytes;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTxBytes</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//发送的流量</span>            <span class="hljs-keyword">return</span> mTxBytes;        &#125;&#125;</code></pre><p>以上为<code>NetworkStatsManager</code>的主要调用方法</p><p>根据上述提供的方法，可以得到设备一直的流量数据，并且支持按照<code>networkType</code>区分和<code>startTime~endTime</code>获取指定时间段的流量数据。</p><p>优点：</p><ul><li>可以获取指定类型以及时间段的流量数据</li></ul><p>缺点：</p><ul><li>需要申请特殊权限以及做权限适配</li><li>使用较复杂</li></ul><h4 id="简单原理介绍-1"><a href="#简单原理介绍-1" class="headerlink" title="简单原理介绍"></a>简单原理介绍</h4><p>INetworkStatsSession.aidl -&gt; getDeviceSummaryForNetwork</p><p>NetworkStatsService.java</p><p>NetworkStatsCollection.java -&gt; getHistory()</p><h4 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h4><pre><code class="hljs java">AndroidManifest.xml 配置权限      &lt;uses-permission android:name=<span class="hljs-string">"android.permission.READ_PHONE_STATE"</span>/&gt;    &lt;uses-permission        android:name=<span class="hljs-string">"android.permission.PACKAGE_USAGE_STATS"</span>        tools:ignore=<span class="hljs-string">"ProtectedPermissions"</span>/&gt;          申请权限    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestPermissions</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//检测有无 查看应用使用情况权限</span>        <span class="hljs-keyword">if</span> (!hasPermissionToReadNetworkHistory()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//检测有无获取 READ_PHOBE_STATE 权限</span>        <span class="hljs-keyword">if</span> (!hasPermissionToReadPhoneStats()) &#123;            <span class="hljs-comment">//申请对应权限</span>            requestPhoneStateStats();        &#125;    &#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermissionToReadNetworkHistory</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">final</span> AppOpsManager appOps = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);        <span class="hljs-keyword">int</span> mode = appOps.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS,                android.os.Process.myUid(), getPackageName());        <span class="hljs-keyword">if</span> (mode == AppOpsManager.MODE_ALLOWED) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        appOps.startWatchingMode(AppOpsManager.OPSTR_GET_USAGE_STATS,                getApplicationContext().getPackageName(),                <span class="hljs-keyword">new</span> AppOpsManager.OnOpChangedListener() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-meta">@TargetApi</span>(Build.VERSION_CODES.M)                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpChanged</span><span class="hljs-params">(String op, String packageName)</span> </span>&#123;                        <span class="hljs-keyword">int</span> mode = appOps.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS,                                android.os.Process.myUid(), getPackageName());                        <span class="hljs-keyword">if</span> (mode != AppOpsManager.MODE_ALLOWED) &#123;                            <span class="hljs-keyword">return</span>;                        &#125;                        appOps.stopWatchingMode(<span class="hljs-keyword">this</span>);                        Intent intent = <span class="hljs-keyword">new</span> Intent(StatsActivity.<span class="hljs-keyword">this</span>, StatsActivity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                        <span class="hljs-keyword">if</span> (getIntent().getExtras() != <span class="hljs-keyword">null</span>) &#123;                            intent.putExtras(getIntent().getExtras());                        &#125;                        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);                        getApplicationContext().startActivity(intent);                    &#125;                &#125;);        requestReadNetworkHistoryAccess();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestReadNetworkHistoryAccess</span><span class="hljs-params">()</span> </span>&#123;        Intent intent = <span class="hljs-keyword">new</span> Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);        startActivity(intent);    &#125;<span class="hljs-comment">//上述权限申请完毕后，调用对应方法获取流量数据</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getPackageBytesWithNetTypeAndFlow</span><span class="hljs-params">(Context context, <span class="hljs-keyword">boolean</span> isRx<span class="hljs-comment">/*Rx、Tx*/</span>,                                                  <span class="hljs-keyword">int</span> networkType<span class="hljs-comment">/*TYPE_MOBILE，TYPE_WIFI*/</span>)</span> </span>&#123;        NetworkStats networkStats = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            networkStats = networkStatsManager.queryDetailsForUid(networkType, getSubscriberId(context, networkType),                    <span class="hljs-number">0</span>, System.currentTimeMillis(), packageUid);        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">long</span> bytes = <span class="hljs-number">0L</span>;        NetworkStats.Bucket bucket = <span class="hljs-keyword">new</span> NetworkStats.Bucket();        <span class="hljs-keyword">while</span> (networkStats.hasNextBucket()) &#123;            networkStats.getNextBucket(bucket);            bytes += isRx ? bucket.getRxBytes() : bucket.getTxBytes();        &#125;        networkStats.close();        <span class="hljs-keyword">return</span> bytes;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getSubscriberId</span><span class="hljs-params">(Context context, <span class="hljs-keyword">int</span> networkType)</span> </span>&#123;        <span class="hljs-keyword">if</span> (ConnectivityManager.TYPE_MOBILE == networkType) &#123;            TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);            <span class="hljs-keyword">return</span> tm.getSubscriberId();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/061f8889a888" target="_blank" rel="noopener">TrafficStats流程分析</a></p><p><a href="https://source.android.google.cn/devices/tech/datausage/ebpf-traffic-monitor" target="_blank" rel="noopener">ePBF流量监控</a></p><p><a href="https://github.com/RobertZagorski/NetworkStats.git" target="_blank" rel="noopener">NetStads Demo</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-AbstractQueuedSynchronizer简介</title>
    <link href="/2020/09/13/Java-AbstractQueuedSynchronizer%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/09/13/Java-AbstractQueuedSynchronizer%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/AQS原理xmind.png" srcset="/img/loading.gif" alt="AQS原理"></p><h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><p>AQS全称为<code>AbstractQueuedSynchronizer</code>，意为<code>抽象队列同步器</code>。</p><ul><li><code>Abstract</code>：抽象类，只实现主要逻辑，其他交由子类实现</li><li><code>Queued</code>：<code>FIFO</code>队列存储数据</li><li><code>Synchronizer</code>：同步</li></ul><p>在<code>Lock</code>中，是非常重要的核心组件。<code>AQS</code>是用来构建锁和同步器的框架，使用<code>AQS</code>可以简单且高效构建同步器。我们常见的<code>ReentrantLock、CountdownLatch</code>都是基于<code>AQS</code>构建的。</p><p><code>AQS</code>主要做了三件事情：</p><ol><li>同步状态的管理</li><li>线程的阻塞和唤醒</li><li>同步队列的维护</li></ol><h2 id="AQS同步方式"><a href="#AQS同步方式" class="headerlink" title="AQS同步方式"></a>AQS同步方式</h2><p>从使用层面来讲，AQS同步方式分为以下两种：</p><h3 id="独占模式-Exclusive"><a href="#独占模式-Exclusive" class="headerlink" title="独占模式(Exclusive)"></a>独占模式(Exclusive)</h3><p>资源是独占的，一次只能有一个线程获取。</p><p>例如<code>ReentrantLock</code></p><h3 id="共享模式-Share"><a href="#共享模式-Share" class="headerlink" title="共享模式(Share)"></a>共享模式(Share)</h3><p>资源是共享的，可以被多个线程同时获取并访问，还可以指定允许访问的资源个数。</p><p>例如<code>CountdownLatch</code>、<code>Semaphore</code></p><h3 id="混合模式-mixed"><a href="#混合模式-mixed" class="headerlink" title="混合模式(mixed)"></a>混合模式(mixed)</h3><p>将两种模式混合在一起进行使用，可以在特定条件下进行<code>独占</code>或<code>共享</code>资源。</p><p>例如<code>ReentrantReadWhiteLock</code></p><h2 id="AQS的数据结构"><a href="#AQS的数据结构" class="headerlink" title="AQS的数据结构"></a>AQS的数据结构</h2><p>AQS依赖内部的一个<code>FIFO双端队列</code>实现同步状态(<code>state</code>)的管理，并且使用了<code>head</code>和<code>tail</code>分别表示队列的首尾节点。</p><p><img src="/images/AQS-等待队列.png" srcset="/img/loading.gif" alt="AQS-等待队列"></p><p>队列中储存的是<code>Node</code>节点，其中包含了<strong>当前线程以及等待状态信息</strong>。</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><blockquote><p>表示资源当前状态。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state; <span class="hljs-comment">//资源标识</span></code></pre><p>同时定义了了几个关于<code>state</code>的方法，提供给子类覆盖实现自身逻辑。</p><p>例如：</p><p><code>ReentrantLock</code>：表示的资源为<code>独占锁</code>，<code>state=0</code>表示没持有锁，<code>state=1</code>表示锁被占用，<code>state&gt;1</code>表示了锁重入次数。</p><p><code>CountdownLatch</code>：表示的资源为<code>计数</code>，<code>state=0</code>表示计数器归零，可以被其他线程访问资源，<code>state&gt;0</code>表示所有线程访问资源时都需要阻塞。</p><pre><code class="hljs java">getState()<span class="hljs-comment">//获取同步状态</span>  setState(<span class="hljs-keyword">int</span> newState)<span class="hljs-comment">//设置同步状态</span>  compareAndSetState(<span class="hljs-keyword">int</span> expect,<span class="hljs-keyword">int</span> update)<span class="hljs-comment">//基于CAS，原子设置当前状态</span></code></pre><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><blockquote><p>AQS内部等待队列的节点</p></blockquote><pre><code class="hljs java">    <span class="hljs-comment">/*          * &lt;pre&gt;     *      +------+  prev +-----+       +-----+     * head |      | &lt;---- |     | &lt;---- |     |  tail     *      +------+       +-----+       +-----+     * &lt;/pre&gt;     */</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-comment">//标记当前节点(线程)位于共享模式下等待</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();   <span class="hljs-comment">//标记当前节点(线程)位于独占模式下等待</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//表示当前线程状态是取消的</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;   <span class="hljs-comment">//表示当前线程正在等待锁，需要被唤醒</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;   <span class="hljs-comment">//表示当前线程等待某一条件</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;   <span class="hljs-comment">//表示当前线程有资源可用，需要继续唤醒后续节点(CountdownLatch下使用)</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;   <span class="hljs-comment">//节点中线程的状态，默认为0</span>   <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;   <span class="hljs-comment">//当前节点的前一个节点</span>   <span class="hljs-keyword">volatile</span> Node prev;   <span class="hljs-comment">//当前节点的后一个节点</span>   <span class="hljs-keyword">volatile</span> Node next;   <span class="hljs-comment">//当前节点封装的线程信息</span>   <span class="hljs-keyword">volatile</span> Thread thread;   <span class="hljs-comment">//等待队列中的下一个等待节点</span>   Node nextWaiter;      <span class="hljs-comment">//判断是否为共享模式</span>   <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> nextWaiter == SHARED;        &#125;     Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span>            <span class="hljs-keyword">this</span>.nextWaiter = mode;            <span class="hljs-keyword">this</span>.thread = thread;        &#125;  &#125;</code></pre><p><img src="/images/AQS-Node.png" srcset="/img/loading.gif" alt="AQS-Node"></p><p><code>prev</code>：当前节点的上一个节点</p><p><code>next</code>：当前节点的下一个节点</p><p><code>thread</code>：当前节点持有的线程</p><p><code>waitStatus</code>：当前节点的状态</p><p><code>nextWaiter</code>：下一个处于<code>CONDITION</code>状态的节点</p><p><code>Node</code>是一个变体<code>CLH</code>的节点，<code>CLH</code>应用了自旋锁，节点保存了当前阻塞线程的信息。如果他的前驱节点释放了，就需要通过修改<code>waitStatus</code>字段出队前驱节点，让当前节点尝试获取锁。若有新的等待线程要入队，就会加入到队列的尾部。</p><p>其中<code>waitStatus</code>有以下几种状态：</p><table><thead><tr><th>waitStatus</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>SIGNAL</td><td>-1</td><td>表示当前节点的后续节点被阻塞或即将被阻塞，当前节点释放或取消后需要唤醒后续节点。<em>一般是后续节点来设置前驱节点的。</em></td></tr><tr><td>CANCELLED</td><td>1</td><td>表示当前节点超时或被中断，需要移出等待队列</td></tr><tr><td>CONDITION</td><td>-2</td><td>表示当前节点在<code>Condition</code>队列中，阻塞等待某个条件唤醒</td></tr><tr><td>PROPAGATE</td><td>-3</td><td>适用于共享模式(连续的操作节点依次进入临界区)，用于将唤醒后续线程传递下去，<strong>为了完善和增强锁的唤醒机制。</strong></td></tr><tr><td>INIT</td><td>0</td><td>节点初始创建处于该状态</td></tr></tbody></table><p><a href="https://blog.csdn.net/HalfImmortal/article/details/107432756" target="_blank" rel="noopener">CLH队列</a></p><blockquote><p>通过<code>Node</code>可以实现两个队列</p><ul><li>通过<code>prev</code>、<code>next</code>实现双向队列</li><li>通过<code>nextWaiter</code>实现<code>Condition</code>的单向等待队列</li></ul></blockquote><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><blockquote><p>用于实现<code>Condition</code>功能的内部类，直接作用于线程，对线程进行调度</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1173984872572414699L</span>;    <span class="hljs-comment">/** First node of condition queue. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;    <span class="hljs-comment">/** Last node of condition queue. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;  ...&#125;</code></pre><p>由<code>Node</code>组成的单向队列。</p><!--后续原理描述会分析内部实现。 --><h2 id="AQS原理解析"><a href="#AQS原理解析" class="headerlink" title="AQS原理解析"></a>AQS原理解析</h2><h3 id="子类实现方法"><a href="#子类实现方法" class="headerlink" title="子类实现方法"></a>子类实现方法</h3><p><code>AQS</code>的设计是基于<strong>模板方法模式(定义基本功能后，将一些实现延迟到子类)</strong>的，所以其中一些方法必须交由子类去实现。</p><h4 id="isHeldExclusively-是否独占资源"><a href="#isHeldExclusively-是否独占资源" class="headerlink" title="isHeldExclusively()-是否独占资源"></a>isHeldExclusively()-是否独占资源</h4><p>该线程是否正在独占资源。<em>只有需要用到<code>Condition</code>才需要去实现该方法</em></p><h4 id="tryAcquire-获取独占资源"><a href="#tryAcquire-获取独占资源" class="headerlink" title="tryAcquire()-获取独占资源"></a>tryAcquire()-获取独占资源</h4><p><strong>独占方式</strong>获取资源，成功获取返回<code>true</code>，失败返回<code>false</code></p><h4 id="tryRelease-释放独占资源"><a href="#tryRelease-释放独占资源" class="headerlink" title="tryRelease()-释放独占资源"></a>tryRelease()-释放独占资源</h4><p><strong>独占方式</strong>释放资源，成功释放返回<code>true</code>，失败返回<code>false</code></p><h4 id="tryAcquireShared-获取共享资源"><a href="#tryAcquireShared-获取共享资源" class="headerlink" title="tryAcquireShared()-获取共享资源"></a>tryAcquireShared()-获取共享资源</h4><p><strong>共享方式</strong>获取资源</p><ul><li>返回<code>负数</code>，表示资源获取失败</li><li>返回<code>0</code>，表示获取成功，但没有多余资源可获取</li><li>返回<code>&gt;0</code>，表示获取成功，且有剩余资源</li></ul><h4 id="tryReleaseShared-释放共享资源"><a href="#tryReleaseShared-释放共享资源" class="headerlink" title="tryReleaseShared()-释放共享资源"></a>tryReleaseShared()-释放共享资源</h4><p><strong>共享方式</strong>释放资源</p><ul><li>释放资源后，允许唤醒后续等待节点，返回<code>true</code></li><li>释放资源后，没有后续等待节点，返回<code>false</code></li></ul><p>子类主要实现上述几个方法，主要逻辑还是在<code>AQS</code>内部进行实现。</p><h3 id="获取资源-独占模式"><a href="#获取资源-独占模式" class="headerlink" title="获取资源-独占模式"></a>获取资源-独占模式</h3><p><img src="/images/AQS-独占模式-获取资源.png" srcset="/img/loading.gif" alt="AQS-独占模式-获取资源"></p><p>获取资源的入口是<code>acquire(int arg)</code>。<code>arg</code>是要获取资源的个数</p><ul><li><code>独占模式</code>：arg = 1</li><li><code>共享模式</code>：arg &gt;= 0</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="hljs-comment">//1⃣️</span>        acquireQueued( <span class="hljs-comment">//2⃣️</span>          addWaiter(Node.EXCLUSIVE), arg) <span class="hljs-comment">//3⃣️</span>        )        selfInterrupt();&#125;</code></pre><h4 id="tryAcquire-int-arg"><a href="#tryAcquire-int-arg" class="headerlink" title="tryAcquire(int arg)"></a>tryAcquire(int arg)</h4><p>子类实现的模板方法，在介绍<code>ReentrantLock</code>时会分析内部实现</p><h4 id="addWaiter-Node-EXCLUSIVE"><a href="#addWaiter-Node-EXCLUSIVE" class="headerlink" title="addWaiter(Node.EXCLUSIVE)"></a>addWaiter(Node.EXCLUSIVE)</h4><p>只有在<code>tryAcquire()</code>获取资源失败时，才会执行到该方法，将当前线程初始化为一个<code>Node</code>节点，加入到<code>等待队列</code>中。其中<code>Node.EXCLUSIVE</code>表示当前锁是独占的。</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//为当前线程创建指定模式的节点</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;       <span class="hljs-comment">//生成对应的Node节点</span>        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);        <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span>        Node pred = tail;        <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//采用尾插法</span>            node.prev = pred;          <span class="hljs-comment">//使用CAS尝试交换节点</span>            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;                pred.next = node;                <span class="hljs-keyword">return</span> node;            &#125;        &#125;     <span class="hljs-comment">//等待队列为空，或者CAS交换失败，插入队列</span>        enq(node);        <span class="hljs-keyword">return</span> node;    &#125;<span class="hljs-comment">//插入数据到队列中</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;        <span class="hljs-keyword">for</span> (;;) &#123;            Node t = tail;            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))                    tail = head;<span class="hljs-comment">//初始化等待队列</span>            &#125; <span class="hljs-keyword">else</span> &#123;                node.prev = t;<span class="hljs-comment">//新进节点放在队列尾部</span>                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="hljs-comment">//交换尾节点与插入节点</span>                    t.next = node;                    <span class="hljs-keyword">return</span> t;                &#125;            &#125;        &#125;    &#125;</code></pre><p>这一步的操作是为了，在等待队列的尾部插入新<code>Node</code>节点，但是可能存在多个线程同时争夺资源的情况，因为在插入节点时需要做线程安全操作，这里就是通过<code>CAS</code>保证线程操作的安全性。</p><p><img src="/images/AQS-独占模式-等待队列.jpg" srcset="/img/loading.gif" alt="AQS-独占模式-等待队列"></p><ol><li>执行<code>tryAcquire()</code>失败后，将当前线程初始化为一个<code>Node</code>节点，加入到<code>AQS</code>等待队列中-调用<code>addWaiter()</code></li><li>第一次加入等待队列，此时尚未初始化完成，<code>head</code>，<code>tail</code>都为<code>null</code></li><li>就需要在执行<code>enq()</code>将等待队列初始化，并插入<code>Node</code>节点，<strong>头节点为空线程</strong></li><li>后续再有新的申请进来后，<code>Node</code>节点直接插入到等待队列的尾部</li></ol><blockquote><p>为什么头节点为空线程？</p><p>此处的头节点<code>head</code>起到了一个<strong>哨兵</strong>的作用，<code>免去后续查找过程中的越界判断</code>。</p></blockquote><h4 id="acquireQueued-node-arg"><a href="#acquireQueued-node-arg" class="headerlink" title="acquireQueued(node,arg)"></a>acquireQueued(node,arg)</h4><p>经过<code>addWaiter()</code>之后，线程加入到等待队列中，但是线程还没有被挂起等待，而<code>acquireQueued()</code>去执行线程挂起的相关操作。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">final</span> Node p = node.predecessor();<span class="hljs-comment">//获取前一个节点</span>          <span class="hljs-comment">//前一个节点是 head，再尝试获取一次锁  </span>          <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                setHead(node);<span class="hljs-comment">//获取资源后，设置当前节点为头节点</span>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 原先头节点置为null，移出等待队列</span>                failed = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">return</span> interrupted;            &#125;          <span class="hljs-comment">//获取锁失败了，就将自己挂起进入`waiting`状态，直到`unpark`调用</span>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = <span class="hljs-keyword">true</span>;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (failed)            cancelAcquire(node);    &#125;&#125;</code></pre><p>若前一个节点是<code>head</code>，那么再次调用<code>tryAcquire()</code>去竞争锁；竞争失败了，就执行<code>shouldParkAfterFailedAcquire()</code>判断是否将自己的线程挂起</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;    <span class="hljs-keyword">int</span> ws = pred.waitStatus;<span class="hljs-comment">//前一个节点的状态</span>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<span class="hljs-comment">//前一个节点处于 阻塞挂起状态，当前线程可以挂起</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//前一个节点处于取消状态</span>        <span class="hljs-keyword">do</span> &#123;            node.prev = pred = pred.prev;<span class="hljs-comment">//移出已被取消的节点</span>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);        pred.next = node;    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//前一个节点处于 初始化或者 PRPPAGATE，当前需要一个信号才能将当前线程挂起。</span>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><blockquote><p>线程能否挂起的判断条件：</p><p><strong>前一个节点的<code>waitStatus</code>必须是<code>SIGNAL(-1)</code>，因为后面<code>unlock()</code>会去唤醒<code>waitStatus</code>为<code>SIGNAL</code>的线程去争夺锁。</strong></p></blockquote><p>若<code>shouldParkAfterFailedAcquire()</code>判断需要将当前线程挂起，则继续执行<code>parkAndCheckInterrupt()</code>挂起当前线程。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;    LockSupport.park(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//当前线程被挂起</span>    <span class="hljs-keyword">return</span> Thread.interrupted();<span class="hljs-comment">//返回中断标记并对当前线程进行复位</span>&#125;</code></pre><p><code>parkAndCheckInterrupt()</code>内部调用到了<code>LockSupport.park()</code>，该方法主要用于中断一个线程。</p><blockquote><p><code>LockSupport</code>是<code>Java 6</code>后引入的一个类，提供了基本的<code>线程同步原语</code>。</p><p>内部实际调用了<code>Unsafe</code>的函数。</p><p>主要提供了两个方法：</p><ul><li><code>park()</code>：阻塞当前线程</li><li><code>unpark(thread)</code>：使<code>thread</code>停止阻塞</li></ul></blockquote><p>在后续新增的节点进入<code>AQS等待队列</code>后，是通过<code>LockSupport.park()</code>使线程进入阻塞状态。</p><p><code>LockSupport.park()</code>遇到以下情况时，会立即中断阻塞状态</p><ul><li>其他线程调用了<code>unpark()</code>停止了当前线程的阻塞状态</li><li>其他线程中断了当前线程</li></ul><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;        Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            LockSupport.park();            System.err.println(<span class="hljs-string">"当前park无效 "</span>+Thread.currentThread().isInterrupted());            LockSupport.park();            System.err.println(<span class="hljs-string">"park无效"</span>);                   &#125;,<span class="hljs-string">"t1"</span>);        t1.start();        Thread.sleep(<span class="hljs-number">1000</span>);        t1.interrupt();    &#125;输出结果：  当前park无效 <span class="hljs-keyword">true</span>  park无效</code></pre><p>结合以上代码的运行结果可知以下几点：</p><ul><li>当一个线程<code>park()</code>时，其他线程中断该线程时，线程会立即恢复，且中断标记为<code>true</code>还不会抛出<code>InterruptedException</code>异常</li><li>当一个线程的中断标记为<code>true</code>时，调用<code>park()</code>无法挂起线程</li></ul><p>所以这就是为什么<code>parkAndCheckInterrupt()</code>返回了<code>Thread.interrupted()</code>去重置中断标记。</p><blockquote><p><code>interrupt()</code>：打一个中断标记，但不会中断当前线程</p><p><code>isInterrupted()</code>：返回当前线程的中断标记，如果执行过<code>interrupt()</code>则返回<code>true</code>，表示当前线程被中断过</p><p><code>interrupted()</code>：返回当前线程的中断标记，如果执行过<code>interrupt()</code>则返回<code>true</code>，表示当前线程被中断过。<strong>但是多执行了一步复位操作，后续调用<code>isInterrupted()</code>返回<code>false</code>。</strong></p></blockquote><p>若不执行<code>线程复位</code>操作，后续对当前线程执行<code>LockSupport.park()</code>时，挂起操作无法生效，就会导致发生死循环，耗尽资源。</p><p><img src="/images/AQS-获取资源.jpg" srcset="/img/loading.gif" alt="AQS-获取资源"></p><blockquote><p>简单文字概述<code>AQS-获取资源过程</code></p><ol><li>尝试获取资源——<code>tryAcquire()</code></li><li>获取资源失败，请求入队列——<code>addWaiter(Node.EXCLUSIVE)</code><ol><li>根据传入的模式(<code>EXCUSIVE</code>)创造节点(<code>Node</code>)</li><li>判断尾节点(<code>tail</code>)是否存在，不存在使用<code>enq(node)</code>初始化节点<code>head、tail</code>；存在<code>tail</code>，请求节点插入尾部</li><li>使用<code>CAS自旋</code>插入请求到尾端，插入失败的话，调用<code>enq(node)</code>自旋插入直到成功</li></ol></li><li>请求入队列后，需要不断去获取资源——<code>acquireQueued(node)</code><ol><li>不断获取当前节点的上一个节点是否为<code>head</code>，若是，则表示当前节点为<code>请求节点</code></li><li>若是<code>请求节点</code>，不断的调用<code>tryAcquire()</code>获取资源，获取成功执行<code>setHead()</code></li><li>若当前非<code>head</code>后的第一个<code>请求节点</code>或者<code>tryAcquire()</code>请求资源失败，需要通过<code>shouldParkAfterFailedAcquire()</code>判断当前节点是否需要阻塞(<code>判断前一个节点waitStatus == NODE.SIGNAL</code>)</li><li>若需要阻塞则执行<code>parkAndCheckInterrupt()</code>实质执行<code>LockSupport.park()</code></li></ol></li></ol></blockquote><h4 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire()"></a>cancelAcquire()</h4><p><code>acquireQueued()</code>执行到<code>finally</code>时就会执行该方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelAcquire</span><span class="hljs-params">(Node node)</span> </span>&#123;        <span class="hljs-comment">// Ignore if node doesn't exist</span>        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span>;        node.thread = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 已被取消的节点都移出等待队列</span>        Node pred = node.prev;        <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)            node.prev = pred = pred.prev;        <span class="hljs-comment">//找到有效节点的下一个节点</span>        Node predNext = pred.next;        <span class="hljs-comment">//设置当前节点为取消</span>        node.waitStatus = Node.CANCELLED;        <span class="hljs-comment">// If we are the tail, remove ourselves.</span>        <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;            <span class="hljs-comment">//当前为尾节点 直接移除</span>            compareAndSetNext(pred, predNext, <span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> ws;            <span class="hljs-keyword">if</span> (pred != head &amp;&amp; <span class="hljs-comment">//不是头节点</span>                ((ws = pred.waitStatus) == Node.SIGNAL || <span class="hljs-comment">//处于SIGNAL状态</span>                 (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<span class="hljs-comment">//pred设置为SIGNAL状态成功</span>                pred.thread != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//并且有 等待线程</span>                Node next = node.next;                <span class="hljs-keyword">if</span> (next != <span class="hljs-keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)                    compareAndSetNext(pred, predNext, next);            &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-comment">//当前为头节点的下一个有效节点</span>                unparkSuccessor(node);            &#125;            node.next = node; <span class="hljs-comment">// help GC</span>        &#125;    &#125;</code></pre><p>//TODO 补齐流程分析</p><h3 id="释放资源-独占模式"><a href="#释放资源-独占模式" class="headerlink" title="释放资源-独占模式"></a>释放资源-独占模式</h3><p><img src="/images/AQS-独占模式-释放资源.png" srcset="/img/loading.gif" alt="AQS-独占模式-释放资源"></p><p>释放资源的入口是<code>release(int arg)</code>，<code>arg</code>为释放资源的个数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;        Node h = head;        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<span class="hljs-comment">//头节点不为空，且状态不为新建</span>            unparkSuccessor(h);<span class="hljs-comment">//唤醒后续节点</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease()"></a>tryRelease()</h4><p>子类实现的模板方法，在介绍<code>ReentrantLock</code>时会分析内部实现</p><h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor()"></a>unparkSuccessor()</h4><p><code>tryRelease()</code>解锁成功后，执行该方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;       <span class="hljs-comment">//获取当前节点的等待状态</span>        <span class="hljs-keyword">int</span> ws = node.waitStatus;        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)          <span class="hljs-comment">//小于0 ，则重置为0</span>            compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);        Node s = node.next;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//节点不存在或被取消</span>            s = <span class="hljs-keyword">null</span>;           <span class="hljs-comment">//唤醒后续节点,如果还存在挂起的节点</span>            <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<span class="hljs-comment">//等待队列从后往前遍历</span>                <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)                    s = t;        &#125;        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)          <span class="hljs-comment">//取消对应线程的挂起状态</span>            LockSupport.unpark(s.thread);    &#125;</code></pre><p>如果不存在后续节点或后续节点被取消，就会从<code>AQS等待队列</code>的末尾从后往前遍历，就是为了<strong>避免找不到节点的情况</strong>，有可能在构造节点时，尚未构造<code>next</code>的值，导致无法继续向后遍历，但是向前的话一开始节点构造时就会设置<code>prev</code>节点数据。</p><p>找到了需要被唤醒的节点(<code>waitStatus == SIGNAL(-1)</code>)后，执行<code>LockSupport.unpark()</code>唤醒节点对应线程。</p><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h4><p>上面的方法执行到<code>LockSupport.unpark()</code>后，就会唤醒对应的线程</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;       LockSupport.park(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//当前线程被挂起</span>       <span class="hljs-keyword">return</span> Thread.interrupted();<span class="hljs-comment">//返回中断标记并对当前线程进行复位</span>   &#125;<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;       <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;           <span class="hljs-keyword">for</span> (;;) &#123;               <span class="hljs-keyword">final</span> Node p = node.predecessor();<span class="hljs-comment">//获取前一个节点</span>             <span class="hljs-comment">//前一个节点是 head，再尝试获取一次锁  </span>             <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                   setHead(node);<span class="hljs-comment">//获取资源后，设置当前节点为头节点</span>                   p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 原先头节点置为null，移出等待队列</span>                   failed = <span class="hljs-keyword">false</span>;                   <span class="hljs-keyword">return</span> interrupted;               &#125;             <span class="hljs-comment">//获取锁失败了，就将自己挂起进入`waiting`状态，直到`unpark`调用</span>               <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                   parkAndCheckInterrupt())                   interrupted = <span class="hljs-keyword">true</span>;           &#125;       &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-keyword">if</span> (failed)               cancelAcquire(node);       &#125;   &#125;</code></pre><p>此时<code>parkAndCheckInterrupt()</code>会继续执行，代码执行回到<code>acquireQueued()</code>的for循环中</p><p>此时资源已被释放，后续线程执行<code>tryAcquire()</code>就会获取资源成功，向下执行到<code>setHead()</code>并跳出了当前的循环</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHead</span><span class="hljs-params">(Node node)</span> </span>&#123;    head = node;    node.thread = <span class="hljs-keyword">null</span>;    node.prev = <span class="hljs-keyword">null</span>;&#125;</code></pre><p><code>setHead()</code>重置了一下<code>head</code>节点的属性，将当前节点置为了<code>head</code>节点，原先的就移出队列，等待回收。</p><p><code>return interrupted</code>继续回到上层方法<code>acquire()</code>中，中断掉当前线程，<code>release()</code>执行完毕。</p><p><img src="/images/AQS-独占模式-释放资源.jpg" srcset="/img/loading.gif" alt="AQS-独占模式-释放资源"></p><blockquote><p>简单文字描述AQS-资源释放过程</p><ol><li>通过<code>tryRelease()</code>释放资源，返回<code>true</code>表示资源已经被释放了，通知其他节点可以获取资源</li><li>释放成功后，执行<code>unparkSuccessor()</code>取消其他线程的阻塞状态</li><li>通过<code>从后往前遍历(入队列采用尾插法)</code>直到找到一个<code>有效节点(waitStatus&lt;=0)</code>，在执行<code>LockSupport.unpark()</code>取消对应节点<code>thread</code>的阻塞状态</li></ol></blockquote><h3 id="获取资源-共享模式"><a href="#获取资源-共享模式" class="headerlink" title="获取资源-共享模式"></a>获取资源-共享模式</h3><p><img src="/images/AQS-共享模式-获取资源.png" srcset="/img/loading.gif" alt="AQS-共享模式-获取资源"></p><p>获取共享资源的入口是<code>acquireShared()/acquireSharedInterruptibly()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)        doAcquireShared(arg);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span>        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">if</span> (Thread.interrupted())        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)        doAcquireSharedInterruptibly(arg);&#125;</code></pre><p>其中<code>acquireShared()</code>和<code>acquireSharedInterruptibly()</code>的区别在于后者可以<strong>响应中断</strong>，请求线程被中断时，就会抛出异常结束请求。</p><h4 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared()"></a>tryAcquireShared()</h4><p>子类实现的模板方法，在介绍<code>CountdownLatch</code>时会分析内部实现</p><h4 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared()"></a>doAcquireShared()</h4><p>只有在<code>tryAcquireShared()</code>返回值小于0(<code>获取共享资源失败</code>)时执行，<code>tryAcquireShared()</code>有三种返回结果：</p><ul><li><code>小于0</code>：获取共享资源失败</li><li><code>等于0</code>：获取共享资源成功，但后续节点无法获取共享资源</li><li><code>大于0</code>：获取共享资源成功，后续节点也可能继续获取共享资源。<em>需要检查后续节点请求的可用性</em></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="hljs-comment">//添加共享节点</span>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//判断是否需要取消节点</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">final</span> Node p = node.predecessor();<span class="hljs-comment">//获取前一个节点</span>            <span class="hljs-keyword">if</span> (p == head) &#123;                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);<span class="hljs-comment">//再次尝试获取共享资源</span>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//请求共享资源成功</span>                    <span class="hljs-comment">//设置当前节点为头节点，并尝试唤醒后续节点</span>                    setHeadAndPropagate(node, r);                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>                    <span class="hljs-keyword">if</span> (interrupted)                        selfInterrupt();                    failed = <span class="hljs-keyword">false</span>;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            <span class="hljs-comment">//是否需要阻塞当前节点请求</span>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = <span class="hljs-keyword">true</span>;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (failed)            cancelAcquire(node);    &#125;&#125;</code></pre><p>获取共享资源失败后，先调用<code>addWaiter(Node.SHARED)</code>添加共享节点到等待队列，在循环中不断判断<code>preNode == head</code>，如果符合继续尝试获取共享资源，若获取成功，执行<code>setHeadAndPropagate()</code>去设置头节点并唤醒后续节点；获取失败，则当前线程判断是否需要挂起(<code>preNode.waitStatus == Node.SIGNAL(-1)</code>)，需要挂起执行<code>LockSupport.park()</code>。</p><h4 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate()"></a>setHeadAndPropagate()</h4><p>获取到共享资源后调用该方法，主要的作用是<code>设置当前节点为头节点，同时唤醒后续节点</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;    Node h = head; <span class="hljs-comment">// Record old head for check below</span>    setHead(node);<span class="hljs-comment">//设置头节点</span>        <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> <span class="hljs-comment">//后续节点可以获取资源</span>        || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||        (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//后续的节点可以被唤醒</span>        Node s = node.next;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())<span class="hljs-comment">//后续节点为共享状态</span>            doReleaseShared();<span class="hljs-comment">//释放共享资源</span>    &#125;&#125;</code></pre><p><code>propagate &gt; 0</code>是<code>tryAcquireShared()</code>的返回值，<code>&gt;0</code>表示后续节点可以继续获取资源</p><p><code>waitStatus &lt; 0</code>此时存在两种情况</p><ul><li><code>waitStatus == SIGNAL(-1)</code>下一个节点可以被唤醒</li><li><code>waitStatus == PROPAGATE(-3)</code>继续传播状态</li></ul><h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h4><p>获取共享资源后且<code>tryAcquireShared()&gt; 0</code>表示后续节点也可以获取资源，并且<code>waitStatus &lt; 0 即 -1</code>可以唤醒后续等待的线程</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (;;) &#123;        Node h = head;        <span class="hljs-comment">//等待队列已初始化</span>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;<span class="hljs-comment">//队列至少存在了2个节点</span>            <span class="hljs-keyword">int</span> ws = h.waitStatus;            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<span class="hljs-comment">//后续线程可以被唤醒</span>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span>                unparkSuccessor(h);<span class="hljs-comment">//唤醒后续节点</span>            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<span class="hljs-comment">//当前节点为最后一个节点，将唤醒状态继续向下传播</span>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span>        &#125;        <span class="hljs-comment">//头节点没有发生变化，直接结束当前循环</span>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span>            <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><p>在等待队列存在后续线程的情况下，继续唤醒后续线程(<code>unparkSuccessor()</code>)。或者由于多个线程同时释放，导致<code>head.waitStatus==0</code>，需要设置<code>waitStatus</code>为<code>PROPAGATE</code>将唤醒状态继续向下传递，保证后续其他线程执行<code>setHeadAndPropagate()</code>时可以继续释放等待线程。</p><p><img src="/images/AQS-获取共享锁.jpg" srcset="/img/loading.gif" alt="AQS-获取共享锁"></p><blockquote><p>简单文字描述AQS-获取共享资源</p><ol><li>通过<code>tryAcquireShared()</code>尝试获取资源</li><li>若<code>tryAcquireShared()</code>返回值<code>&lt;0</code>表示获取资源失败，向下继续调用<code>doAcquireShared()</code></li><li>请求入队列执行<code>addWaiter(Node.SHARED)</code>，操作步骤同<code>AQS获取资源过程</code></li><li>请求入队列后，需要不断去获取资源<ol><li>不断获取当前节点的上一个节点是否为<code>head</code>，若是，则表示当前节点为<code>请求节点</code></li><li>若是<code>请求节点</code>，不断调用<code>tryAcquireShared()</code>继续获取共享资源<ul><li>获取成功，执行<code>setHeadAndPropagate()</code>去设置头节点，并且唤醒后续节点——<code>doReleaseShared()</code></li><li>获取失败，执行<code>LockSupport.unpark()</code>挂起当前线程</li></ul></li></ol></li></ol></blockquote><h3 id="释放资源-共享模式"><a href="#释放资源-共享模式" class="headerlink" title="释放资源-共享模式"></a>释放资源-共享模式</h3><p><img src="/images/AQS-共享模式-释放资源.png" srcset="/img/loading.gif" alt="AQS-共享模式-释放资源"></p><p>释放共享资源的入口是<code>releaseShared()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;        doReleaseShared();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><h4 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared()"></a>tryReleaseShared()</h4><p>子类实现的模板方法，在介绍<code>CountdownLatch</code>时会分析内部实现</p><h4 id="doReleaseShared-1"><a href="#doReleaseShared-1" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h4><p>参考 <a href="#doReleaseShared">doReleaseShared</a></p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><a href="/2020/10/08/Java-AQS-Condition原理及解析/" title="Java-AQS-Condition原理及解析">Java-AQS-Condition原理及解析</a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>AQS到底是什么？</p><blockquote><p><code>AQS</code>内部维护一个<code>CLH队列(FIFO)</code>来管理锁，将<code>当前线程(thread)以及等待状态信息(waitStatus)</code>封装成一个<code>Node节点</code>添加到<code>等待队列</code>中。</p><p>提供了<code>tryAcquire(),tryRelease(),tryAcquireShared(),tryReleaseShare()</code>等模板方法交由子类实现，去控制<code>资源的获取与释放</code>。</p><p><code>AQS</code>默认实现子类获取/释放资源后的操作，包括<code>Node节点的出入队列</code>。</p></blockquote></li><li><p>AQS获取资源失败的操作</p><blockquote><p>线程尝试获取锁失败后，，将<code>当前线程(thread)以及等待状态信息(waitStatus)</code>封装成一个<code>Node节点</code>添加到<code>等待队列</code>中。接着会不断循环尝试获取锁(<code>前置节点为head</code>)，如果不是进入阻塞状态，直至被唤醒。</p></blockquote></li><li><p>AQS等待队列数据结构</p><blockquote><p><code>CLH队列</code>：</p><ul><li>CLH锁是一个自旋锁，可以保证无饥饿性，提供<code>FIFO</code>的公平性。基于链表实现。</li><li>不断轮询<code>前置节点</code>的状态，如果前置节点被释放就结束自旋。</li></ul></blockquote></li><li><p>AQS等待队列插入节点顺序</p><blockquote><p><strong>尾插法</strong></p><p><code>addWaiter(node)</code>就是插入节点的主方法</p><pre><code class="hljs java">&gt;     <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;&gt;         Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);&gt;         <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span>&gt;         Node pred = tail;&gt;         <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;&gt;             node.prev = pred;<span class="hljs-comment">//node.prev = tail</span>&gt;             <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="hljs-comment">//tail = node 大致如此</span>&gt;                 pred.next = node;&gt;                 <span class="hljs-keyword">return</span> node;&gt;             &#125;&gt;         &#125;&gt;         enq(node);&gt;         <span class="hljs-keyword">return</span> node;&gt;     &#125;&gt;</code></pre></blockquote><blockquote><p>先执行的是<code>node.prev = pred(实际为tail)</code>，然后再是CAS操作，这是由于<strong>CAS在执行过程中可能存在一瞬间的需要替换的值为null</strong>，会使得一瞬间的队列数据不一致。</p></blockquote></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/6878135436561088520#heading-28" target="_blank" rel="noopener">JUC必知ReentrantLock和AQS同步队列实现原理分析</a></p><p><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin协程原理</title>
    <link href="/2020/09/04/Kotlin%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/"/>
    <url>/2020/09/04/Kotlin%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebRTC音频处理模块相关</title>
    <link href="/2020/08/14/WebRTC%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3/"/>
    <url>/2020/08/14/WebRTC%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><strong><a href="https://webrtc.googlesource.com/src/" target="_blank" rel="noopener">WebRTC源码</a></strong>基于提交版本<code>4c2f9c9</code></p><p>WebRTC音频处理模块，负责在传输音频时对音频进行一定的处理，例如<code>降噪、增益、回声消除</code>，整体模块代码位于<code>modules/audio_processing</code>。</p><p>按照以下模块分别介绍，各模块的功能以及相关配置和源码解析</p><p>默认音频处理配置如下：</p><pre><code class="hljs c++">AudioOptions options;   options.echo_cancellation = <span class="hljs-literal">true</span>;<span class="hljs-comment">//回声消除</span>   options.auto_gain_control = <span class="hljs-literal">true</span>;<span class="hljs-comment">//自动增益</span>   options.noise_suppression = <span class="hljs-literal">true</span>;<span class="hljs-comment">//降噪</span>   options.highpass_filter = <span class="hljs-literal">true</span>;<span class="hljs-comment">//高通滤波器开启 </span>   options.stereo_swapping = <span class="hljs-literal">false</span>;<span class="hljs-comment">//立体声</span>   options.audio_jitter_buffer_max_packets = <span class="hljs-number">200</span>;<span class="hljs-comment">//jitter_buffer相关配置</span>   options.audio_jitter_buffer_fast_accelerate = <span class="hljs-literal">false</span>;   options.audio_jitter_buffer_min_delay_ms = <span class="hljs-number">0</span>;   options.audio_jitter_buffer_enable_rtx_handling = <span class="hljs-literal">false</span>;   options.typing_detection = <span class="hljs-literal">true</span>;<span class="hljs-comment">//键盘声音检测</span>   options.experimental_agc = <span class="hljs-literal">false</span>;<span class="hljs-comment">//实验性增益控制</span>   options.experimental_ns = <span class="hljs-literal">false</span>;<span class="hljs-comment">//实验性降噪</span>   options.residual_echo_detector = <span class="hljs-literal">true</span>;<span class="hljs-comment">//残留回声检测</span></code></pre><blockquote><p>高通滤波器：只允许某一频率以上的信号无衰减的通过滤波器，去掉了信号中低于该概率的不必要成分或者说去掉了低于该频率的干扰信号。</p></blockquote><h2 id="WebRTCVoiceEngine初始化过程"><a href="#WebRTCVoiceEngine初始化过程" class="headerlink" title="WebRTCVoiceEngine初始化过程"></a>WebRTCVoiceEngine初始化过程</h2><blockquote><p>在配置后面的可选项之前，需要先行初始化<code>WebRTCVoiceEngine</code>，保证配置参数可以生效。 </p></blockquote><h2 id="AEC-回声消除"><a href="#AEC-回声消除" class="headerlink" title="AEC(回声消除)"></a>AEC(回声消除)</h2><blockquote><p>WebRTC中的<code>AEC</code>模块分为这几部分：<code>AECM(移动设备使用)</code>、<code>AEC3(实验模块)</code>、<code>AEC(PC使用)</code>，源码位于<code>modules/audio_processing/aec3、./aecm</code></p></blockquote><h3 id="硬件AEC"><a href="#硬件AEC" class="headerlink" title="硬件AEC"></a>硬件AEC</h3><blockquote><p>由硬件设备提供的<code>AEC</code>功能，当开启该功能时会主动屏蔽掉软件实现的<code>AEC</code>功能.</p></blockquote><p>通过配置<code>JavaAudioDeviceModule</code>实现硬件回声消除功能</p><pre><code class="hljs java">return JavaAudioDeviceModule.builder(context)                .setUseHardwareAcousticEchoCanceler(true)//开启硬件降噪                .createAudioDeviceModule();# org.webrtc.audio.WebRtcEffects//判断是否支持硬件AECpublic static boolean isAcousticEchoCancelerSupported() &#123;        return VERSION.SDK_INT &lt; 18 ? false : isEffectTypeAvailable(AudioEffect.EFFECT_TYPE_AEC, AOSP_ACOUSTIC_ECHO_CANCELER);    &#125;</code></pre><h3 id="软件AEC"><a href="#软件AEC" class="headerlink" title="软件AEC"></a>软件AEC</h3><pre><code class="hljs java"><span class="hljs-keyword">return</span> JavaAudioDeviceModule.builder(context)                .setUseHardwareAcousticEchoCanceler(<span class="hljs-keyword">false</span>)<span class="hljs-comment">//开启硬件降噪</span>                .createAudioDeviceModule();</code></pre><h3 id="AEC-Native代码"><a href="#AEC-Native代码" class="headerlink" title="AEC Native代码"></a>AEC Native代码</h3><pre><code class="hljs java"><span class="hljs-comment">//Native获取当前是否开启硬件AEC    </span><span class="hljs-meta">@CalledByNative</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAcousticEchoCancelerSupported</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isAcousticEchoCancelerSupported;    &#125;</code></pre><p>在此处获取Java层配置的参数</p><pre><code class="hljs c++"><span class="hljs-comment">// 源码位置：/sdk/android/src/jni/audio_device/audio_record_jni.cc</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">AudioRecordJni::IsAcousticEchoCancelerSupported</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;  RTC_DCHECK(thread_checker_.IsCurrent());  <span class="hljs-keyword">return</span> Java_WebRtcAudioRecord_isAcousticEchoCancelerSupported(      env_, j_audio_record_);&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">//源码位置：/sdk/android/src/jni/audio_device/audio_device/audio_device_module.cc</span>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BuiltInAECIsAvailable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span> </span>&#123;    RTC_LOG(INFO) &lt;&lt; __FUNCTION__;    <span class="hljs-keyword">if</span> (!initialized_)      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">bool</span> isAvailable = input_-&gt;IsAcousticEchoCancelerSupported();    RTC_LOG(INFO) &lt;&lt; <span class="hljs-string">"output: "</span> &lt;&lt; isAvailable;    <span class="hljs-keyword">return</span> isAvailable;  &#125;</code></pre><p>判断是否启用硬件AEC</p><pre><code class="hljs c++">pc/peer_connection_factory.cc -&gt; channel_manager.cc -&gt; media_engine.cc -&gt;webrtc_voice_engine.cc从media_engine.cc调用<span class="hljs-comment">//WebRTCVoiceEngine初始化</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WebRtcVoiceEngine::Init</span><span class="hljs-params">()</span> </span>&#123;  RTC_DCHECK(worker_thread_checker_.IsCurrent());  RTC_LOG(LS_INFO) &lt;&lt; <span class="hljs-string">"WebRtcVoiceEngine::Init"</span>;  <span class="hljs-comment">// TaskQueue expects to be created/destroyed on the same thread.</span>  low_priority_worker_queue_.reset(      <span class="hljs-keyword">new</span> rtc::TaskQueue(task_queue_factory_-&gt;CreateTaskQueue(          <span class="hljs-string">"rtc-low-prio"</span>, webrtc::TaskQueueFactory::Priority::LOW)));  <span class="hljs-comment">// Load our audio codec lists.</span>  RTC_LOG(LS_VERBOSE) &lt;&lt; <span class="hljs-string">"Supported send codecs in order of preference:"</span>;  send_codecs_ = CollectCodecs(encoder_factory_-&gt;GetSupportedEncoders());  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> AudioCodec&amp; codec : send_codecs_) &#123;    RTC_LOG(LS_VERBOSE) &lt;&lt; ToString(codec);  &#125;  RTC_LOG(LS_VERBOSE) &lt;&lt; <span class="hljs-string">"Supported recv codecs in order of preference:"</span>;  recv_codecs_ = CollectCodecs(decoder_factory_-&gt;GetSupportedDecoders());  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> AudioCodec&amp; codec : recv_codecs_) &#123;    RTC_LOG(LS_VERBOSE) &lt;&lt; ToString(codec);  &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(WEBRTC_INCLUDE_INTERNAL_AUDIO_DEVICE)</span>  <span class="hljs-comment">// No ADM supplied? Create a default one.</span>  <span class="hljs-keyword">if</span> (!adm_) &#123;    adm_ = webrtc::AudioDeviceModule::Create(        webrtc::AudioDeviceModule::kPlatformDefaultAudio, task_queue_factory_);  &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>  <span class="hljs-comment">// WEBRTC_INCLUDE_INTERNAL_AUDIO_DEVICE</span></span>  RTC_CHECK(adm());  webrtc::adm_helpers::Init(adm());  <span class="hljs-comment">// Set up AudioState.</span>  &#123;    webrtc::AudioState::Config config;    <span class="hljs-keyword">if</span> (audio_mixer_) &#123;      config.audio_mixer = audio_mixer_;    &#125; <span class="hljs-keyword">else</span> &#123;      config.audio_mixer = webrtc::AudioMixerImpl::Create();    &#125;    config.audio_processing = apm_;    config.audio_device_module = adm_;    audio_state_ = webrtc::AudioState::Create(config);  &#125;  <span class="hljs-comment">// Connect the ADM to our audio path.</span>  adm()-&gt;RegisterAudioCallback(audio_state()-&gt;audio_transport());  <span class="hljs-comment">// Set default engine options.</span>  &#123;    AudioOptions options;    options.echo_cancellation = <span class="hljs-literal">true</span>;    options.auto_gain_control = <span class="hljs-literal">true</span>;    options.noise_suppression = <span class="hljs-literal">true</span>;    options.highpass_filter = <span class="hljs-literal">true</span>;    options.stereo_swapping = <span class="hljs-literal">false</span>;    options.audio_jitter_buffer_max_packets = <span class="hljs-number">200</span>;    options.audio_jitter_buffer_fast_accelerate = <span class="hljs-literal">false</span>;    options.audio_jitter_buffer_min_delay_ms = <span class="hljs-number">0</span>;    options.audio_jitter_buffer_enable_rtx_handling = <span class="hljs-literal">false</span>;    options.typing_detection = <span class="hljs-literal">true</span>;    options.experimental_agc = <span class="hljs-literal">false</span>;    options.experimental_ns = <span class="hljs-literal">false</span>;    options.residual_echo_detector = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">bool</span> error = ApplyOptions(options);    RTC_DCHECK(error);  &#125;  initialized_ = <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">//源码位置：/sdk/android/src/meida/engine/webrtc_voice_engine.cc</span><span class="hljs-function">webrtc::AudioDeviceModule* <span class="hljs-title">WebRtcVoiceEngine::adm</span><span class="hljs-params">()</span> </span>&#123;  RTC_DCHECK(worker_thread_checker_.IsCurrent());  RTC_DCHECK(adm_);  <span class="hljs-keyword">return</span> adm_.get();&#125;<span class="hljs-comment">//指向AudioProcessing配置</span><span class="hljs-function">webrtc::AudioProcessing* <span class="hljs-title">WebRtcVoiceEngine::apm</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;  RTC_DCHECK(worker_thread_checker_.IsCurrent());  <span class="hljs-keyword">return</span> apm_.get();&#125;webrtc::AudioProcessing* ap = engine()-&gt;apm();...<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">WebRtcVoiceEngine::ApplyOptions</span><span class="hljs-params">(<span class="hljs-keyword">const</span> AudioOptions&amp; options_in)</span> </span>&#123;  ...<span class="hljs-comment">//默认配置 options.echo_cancellation 为true</span>  <span class="hljs-keyword">if</span> (options.echo_cancellation) &#123;    <span class="hljs-comment">// Check if platform supports built-in EC. Currently only supported on</span>    <span class="hljs-comment">// Android and in combination with Java based audio layer.</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> built_in_aec = adm()-&gt;BuiltInAECIsAvailable();<span class="hljs-comment">//开启硬件AEC就为true</span>    <span class="hljs-keyword">if</span> (built_in_aec) &#123;      <span class="hljs-comment">// Built-in EC exists on this device. Enable/Disable it according to the</span>      <span class="hljs-comment">// echo_cancellation audio option.</span>      <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> enable_built_in_aec = *options.echo_cancellation;      <span class="hljs-keyword">if</span> (adm()-&gt;EnableBuiltInAEC(enable_built_in_aec) == <span class="hljs-number">0</span> &amp;&amp;          enable_built_in_aec) &#123;        <span class="hljs-comment">// Disable internal software EC if built-in EC is enabled,</span>        <span class="hljs-comment">// i.e., replace the software EC with the built-in EC.</span>        options.echo_cancellation = <span class="hljs-literal">false</span>;        RTC_LOG(LS_INFO)            &lt;&lt; <span class="hljs-string">"Disabling EC since built-in EC will be used instead"</span>;      &#125;    &#125;  &#125;...  <span class="hljs-comment">//如果编译android源码，默认启用AECM</span>  <span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(WEBRTC_ANDROID)</span>  use_mobile_software_aec = <span class="hljs-literal">true</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>...  <span class="hljs-comment">//配置apm(AudioDeviceModule)参数</span>  <span class="hljs-keyword">if</span> (options.echo_cancellation) &#123;    apm_config.echo_canceller.enabled = *options.echo_cancellation;    apm_config.echo_canceller.mobile_mode = use_mobile_software_aec;  &#125;...  ap-&gt;ApplyConfig(apm_config);  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><p><code>options.echo_cancellation</code>参数配置完毕后需要应用参数</p><pre><code class="hljs c++"><span class="hljs-comment">//源码位置：modules/audio_processing/audio_processing_impl.cc</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AudioProcessingImpl::ApplyConfig</span><span class="hljs-params">(<span class="hljs-keyword">const</span> AudioProcessing::Config&amp; config)</span> </span>&#123;  ...  <span class="hljs-keyword">if</span> (aec_config_changed) &#123;    InitializeEchoController();  &#125;  ...&#125;<span class="hljs-comment">//初始化 AEC配置 </span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AudioProcessingImpl::InitializeEchoController</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">//是否启动回声消除</span>   <span class="hljs-keyword">bool</span> use_echo_controller =      echo_control_factory_ ||      (config_.echo_canceller.enabled &amp;&amp; !config_.echo_canceller.mobile_mode);    <span class="hljs-keyword">if</span> (use_echo_controller) &#123;    <span class="hljs-comment">// Create and activate the echo controller.</span>    <span class="hljs-keyword">if</span> (echo_control_factory_) &#123;      submodules_.echo_controller = echo_control_factory_-&gt;Create(          proc_sample_rate_hz(), num_reverse_channels(), num_proc_channels());      RTC_DCHECK(submodules_.echo_controller);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//AEC3模块</span>      EchoCanceller3Config config =          use_setup_specific_default_aec3_config_              ? EchoCanceller3::CreateDefaultConfig(num_reverse_channels(),                                                    num_proc_channels())              : EchoCanceller3Config();      submodules_.echo_controller = <span class="hljs-built_in">std</span>::make_unique&lt;EchoCanceller3&gt;(          config, proc_sample_rate_hz(), num_reverse_channels(),          num_proc_channels());    &#125;    ...  &#125; ...   <span class="hljs-comment">//移动端AECM模块设置</span>   <span class="hljs-keyword">if</span> (config_.echo_canceller.mobile_mode) &#123;    <span class="hljs-comment">// Create and activate AECM.</span>    <span class="hljs-keyword">size_t</span> max_element_size =        <span class="hljs-built_in">std</span>::max(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(<span class="hljs-number">1</span>),                 kMaxAllowedValuesOfSamplesPerBand *                     EchoControlMobileImpl::NumCancellersRequired(                         num_output_channels(), num_reverse_channels()));    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int16_t</span>&gt; <span class="hljs-title">template_queue_element</span><span class="hljs-params">(max_element_size)</span></span>;    aecm_render_signal_queue_.reset(        <span class="hljs-keyword">new</span> SwapQueue&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int16_t</span>&gt;, RenderQueueItemVerifier&lt;<span class="hljs-keyword">int16_t</span>&gt;&gt;(            kMaxNumFramesToBuffer, template_queue_element,            RenderQueueItemVerifier&lt;<span class="hljs-keyword">int16_t</span>&gt;(max_element_size)));    aecm_render_queue_buffer_.resize(max_element_size);    aecm_capture_queue_buffer_.resize(max_element_size);    submodules_.echo_control_mobile.reset(<span class="hljs-keyword">new</span> EchoControlMobileImpl());    submodules_.echo_control_mobile-&gt;Initialize(proc_split_sample_rate_hz(),                                                num_reverse_channels(),                                                num_output_channels());    <span class="hljs-keyword">return</span>;  &#125;  submodules_.echo_control_mobile.reset();  aecm_render_signal_queue_.reset();  &#125;</code></pre><h4 id="AEC3"><a href="#AEC3" class="headerlink" title="AEC3"></a>AEC3</h4><blockquote><p>TODO 简单算法介绍</p></blockquote><p>参考类为<code>src/api/audio/echo_canceller3/echo_canceller3_config.cc</code>(AEC3配置项)</p><p><code>echo_canceller3.cc</code>实际生效类</p><h4 id="AECM"><a href="#AECM" class="headerlink" title="AECM"></a>AECM</h4><blockquote><p>AEC的移动端精简版，降低了计算的复杂度，相比于原版会有更明显的回声</p></blockquote><p>参考类为<code>echo_control_mobile_impl.cc</code></p><p>提供了如下配置项：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int16_t</span> <span class="hljs-title">MapSetting</span><span class="hljs-params">(EchoControlMobileImpl::RoutingMode mode)</span> </span>&#123;  <span class="hljs-keyword">switch</span> (mode) &#123;    <span class="hljs-keyword">case</span> EchoControlMobileImpl::kQuietEarpieceOrHeadset:      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">case</span> EchoControlMobileImpl::kEarpiece:      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">case</span> EchoControlMobileImpl::kLoudEarpiece:      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    <span class="hljs-keyword">case</span> EchoControlMobileImpl::kSpeakerphone:      <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;    <span class="hljs-keyword">case</span> EchoControlMobileImpl::kLoudSpeakerphone:      <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;  &#125;  RTC_NOTREACHED();  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre><h2 id="NS-降噪"><a href="#NS-降噪" class="headerlink" title="NS(降噪)"></a>NS(降噪)</h2><blockquote><p>主要源代码位于<code>modules/audio_processing/ns</code></p></blockquote><h3 id="硬件NS"><a href="#硬件NS" class="headerlink" title="硬件NS"></a>硬件NS</h3><blockquote><p>由硬件设备提供的NS功能，开启硬件降噪时，软件降噪关闭</p></blockquote><p>通过配置<code>JavaAudioDeviceModule</code>实现硬件降噪功能</p><pre><code class="hljs java">return JavaAudioDeviceModule.builder(context)                .setUseHardwareNoiseSuppressor(true)//开启硬件降噪                .createAudioDeviceModule();# org.webrtc.audio.WebRtcEffects//判断是否支持硬件NS    public static boolean isNoiseSuppressorSupported() &#123;        return VERSION.SDK_INT &lt; 18 ? false : isEffectTypeAvailable(AudioEffect.EFFECT_TYPE_NS, AOSP_NOISE_SUPPRESSOR);    &#125;</code></pre><h3 id="软件NS"><a href="#软件NS" class="headerlink" title="软件NS"></a>软件NS</h3><pre><code class="hljs java"><span class="hljs-keyword">return</span> JavaAudioDeviceModule.builder(context)                .setUseHardwareNoiseSuppressor(<span class="hljs-keyword">false</span>)<span class="hljs-comment">//开启硬件降噪</span>                .createAudioDeviceModule();</code></pre><h3 id="NS-Native代码"><a href="#NS-Native代码" class="headerlink" title="NS Native代码"></a>NS Native代码</h3><pre><code class="hljs java"><span class="hljs-comment">//Native获取当前是否支持 硬件NS</span><span class="hljs-meta">@CalledByNative</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isNoiseSuppressorSupported</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNoiseSuppressorSupported;    &#125;</code></pre><p>获取Java端配置的参数</p><pre><code class="hljs c++"><span class="hljs-comment">// 源码位置：/sdk/android/src/jni/audio_device/audio_record_jni.cc</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">AudioRecordJni::IsNoiseSuppressorSupported</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;  RTC_DCHECK(thread_checker_.IsCurrent());  <span class="hljs-keyword">return</span> Java_WebRtcAudioRecord_isNoiseSuppressorSupported(env_,                                                           j_audio_record_);&#125;<span class="hljs-comment">//源码位置：/sdk/android/src/jni/audio_device/audio_device/audio_device_module.cc</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BuiltInNSIsAvailable</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span> </span>&#123;    RTC_LOG(INFO) &lt;&lt; __FUNCTION__;    <span class="hljs-keyword">if</span> (!initialized_)      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">bool</span> isAvailable = input_-&gt;IsNoiseSuppressorSupported();    RTC_LOG(INFO) &lt;&lt; <span class="hljs-string">"output: "</span> &lt;&lt; isAvailable;    <span class="hljs-keyword">return</span> isAvailable;  &#125;</code></pre><p>判断是否启用硬件NS</p><h2 id="AGC-音频增益"><a href="#AGC-音频增益" class="headerlink" title="AGC(音频增益)"></a>AGC(音频增益)</h2><p>gain_controller1、gain_controller2</p><h2 id="VAD-静音检测"><a href="#VAD-静音检测" class="headerlink" title="VAD(静音检测)"></a>VAD(静音检测)</h2><p> Voice_detection</p><h2 id="Other-其他模块"><a href="#Other-其他模块" class="headerlink" title="Other(其他模块)"></a>Other(其他模块)</h2><h3 id="HighPassFilter-高通滤波）"><a href="#HighPassFilter-高通滤波）" class="headerlink" title="HighPassFilter(高通滤波）"></a>HighPassFilter(高通滤波）</h3><h2 id="jitter-buffer"><a href="#jitter-buffer" class="headerlink" title="jitter_buffer"></a>jitter_buffer</h2><h2 id="WebRTC内部消息模型"><a href="#WebRTC内部消息模型" class="headerlink" title="WebRTC内部消息模型"></a>WebRTC内部消息模型</h2><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.cnblogs.com/LXP-Never/p/11703440.html" target="_blank" rel="noopener">AEC原理与实现</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>WebRTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebRTC相关记录</title>
    <link href="/2020/08/06/WebRTC%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/08/06/WebRTC%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="WebRTC连接流程"><a href="#WebRTC连接流程" class="headerlink" title="WebRTC连接流程"></a>WebRTC连接流程</h2><p><img src="https://pic4.zhimg.com/80/v2-02ce0ae8a59238a1d4303268ad5f76a5_1440w.jpg" srcset="/img/loading.gif" alt="连接过程"></p><p>当前采用服务端框架为 <code>LiCode</code></p><h2 id="WebRTC通话原理及相关概念"><a href="#WebRTC通话原理及相关概念" class="headerlink" title="WebRTC通话原理及相关概念"></a>WebRTC通话原理及相关概念</h2><h3 id="媒体协商"><a href="#媒体协商" class="headerlink" title="媒体协商"></a>媒体协商</h3><blockquote><p>彼此了解对方支持的媒体格式</p></blockquote><h4 id="SDP"><a href="#SDP" class="headerlink" title="SDP"></a>SDP</h4><h5 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a>参数含义</h5><h3 id="网络协商"><a href="#网络协商" class="headerlink" title="网络协商"></a>网络协商</h3><h2 id="WebRTC源码相关"><a href="#WebRTC源码相关" class="headerlink" title="WebRTC源码相关"></a>WebRTC源码相关</h2><h2 id="WebRTC业务SDK功能"><a href="#WebRTC业务SDK功能" class="headerlink" title="WebRTC业务SDK功能"></a>WebRTC业务SDK功能</h2><p>1.消息推送（语音电话提醒、新消息接收、对方挂断、支持拓展额外参数）</p><p>2.本地长连接（WebRTC dataChannel、保活）</p><p>3.语音通话（音频采集、降噪、回声消除、静音）</p><p>4.各种状态封装（连接成功、超时、失败、重连等）</p><h2 id="WebRTC待完成"><a href="#WebRTC待完成" class="headerlink" title="WebRTC待完成"></a>WebRTC待完成</h2><p>单独编译VAD（静音检测）、NS（降噪）、AECM（回声消除）三模块</p><p>NS：<code>RNNoise</code>和<code>WebRTC-NS</code></p><h2 id="WebRTC随手记"><a href="#WebRTC随手记" class="headerlink" title="WebRTC随手记"></a>WebRTC随手记</h2><p><code>SamplesReadyCallback</code>：在采集音频时可以获取音频信息</p><p><code>setAudioProcessingFactory()</code>：设置音频处理相关配置</p><p><code>webrtc_voice_engine.cc</code>音频控制</p><pre><code class="hljs c++"><span class="hljs-comment">//音频处理默认配置</span>  &#123;    AudioOptions options;    options.echo_cancellation = <span class="hljs-literal">true</span>;    options.auto_gain_control = <span class="hljs-literal">true</span>;    options.noise_suppression = <span class="hljs-literal">true</span>;    options.highpass_filter = <span class="hljs-literal">true</span>;    options.stereo_swapping = <span class="hljs-literal">false</span>;    options.audio_jitter_buffer_max_packets = <span class="hljs-number">200</span>;    options.audio_jitter_buffer_fast_accelerate = <span class="hljs-literal">false</span>;    options.audio_jitter_buffer_min_delay_ms = <span class="hljs-number">0</span>;    options.audio_jitter_buffer_enable_rtx_handling = <span class="hljs-literal">false</span>;    options.typing_detection = <span class="hljs-literal">true</span>;    options.experimental_agc = <span class="hljs-literal">false</span>;    options.experimental_ns = <span class="hljs-literal">false</span>;    options.residual_echo_detector = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">bool</span> error = ApplyOptions(options);    RTC_DCHECK(error);  &#125;<span class="hljs-comment">//降噪等级默认为 High  </span><span class="hljs-keyword">if</span> (options.noise_suppression) &#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> enabled = *options.noise_suppression;    apm_config.noise_suppression.enabled = enabled;    apm_config.noise_suppression.level =        webrtc::AudioProcessing::Config::NoiseSuppression::Level::kHigh;    RTC_LOG(LS_INFO) &lt;&lt; <span class="hljs-string">"NS set to "</span> &lt;&lt; enabled;  &#125;</code></pre><p><code>audio_processing_impl.cc</code> Audio_processing处理类，包含回声消除、降噪等功能</p>]]></content>
    
    
    
    <tags>
      
      <tag>WebRTC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Hot 100</title>
    <link href="/2020/08/03/LeetCode-Hot-100/"/>
    <url>/2020/08/03/LeetCode-Hot-100/</url>
    
    <content type="html"><![CDATA[<p>LeetCode 1：两数之和</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span>(map.containsKey(target-nums[i]))&#123;               <span class="hljs-keyword">int</span> value = map.get(target-nums[i]);               result[<span class="hljs-number">0</span>] = value;               result[<span class="hljs-number">1</span>] = i;               <span class="hljs-keyword">break</span>;            &#125;            map.put(nums[i],i);        &#125;        <span class="hljs-keyword">return</span> result;            &#125;&#125;</code></pre><p>LeetCode 2：两数相加</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式整体回顾</title>
    <link href="/2020/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E4%BD%93%E5%9B%9E%E9%A1%BE/"/>
    <url>/2020/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E4%BD%93%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android屏幕的刷新机制</title>
    <link href="/2020/05/30/View%E7%9A%84%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/05/30/View%E7%9A%84%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/View屏幕刷新xmind.png" srcset="/img/loading.gif" alt="View屏幕刷新"></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在显示系统中，一般包含三个部分<code>CPU、GPU，屏幕</code>。</p><p><code>CPU</code>：执行View的绘制流程<code>measure,layout.draw</code></p><p><code>GPU</code>：进一步处理数据，对图形数据进行渲染并放到<code>buffer缓冲区</code>中缓存</p><p><code>屏幕</code>：将<code>buffer缓冲区</code>的数据取出来填充屏幕像素点</p><p><strong>CPU绘制后提交数据，GPU进一步处理和缓存数据、最后屏幕从缓冲区获取数据并显示。</strong></p><p><img src="/images/webp-20200911191007410" srcset="/img/loading.gif" alt="img"></p><h3 id="屏幕刷新频率"><a href="#屏幕刷新频率" class="headerlink" title="屏幕刷新频率"></a>屏幕刷新频率</h3><blockquote><p>一秒内屏幕刷新的次数也即显示了多少帧的图像，单位<code>Hz</code>。一般都是60Hz。<em>该值取决于屏幕参数</em></p></blockquote><h3 id="逐行扫描"><a href="#逐行扫描" class="headerlink" title="逐行扫描"></a>逐行扫描</h3><blockquote><p>屏幕不是一次性进行画面显示，而是从左到右，从上到下的进行<code>逐行扫描</code>。</p></blockquote><h3 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h3><blockquote><p><strong>GPU一秒内绘制操作的帧数。</strong>Android系统默认60fps</p></blockquote><p>帧率是动态变化的。</p><h3 id="丢帧"><a href="#丢帧" class="headerlink" title="丢帧"></a>丢帧</h3><blockquote><p>在下一个<code>Vsync</code>信号到来时，由于下一帧数据尚未准备就绪，缓存没有交换，此时显示的上一帧的数据。该情况就为<strong>丢帧(Jank)</strong></p></blockquote><p><img src="/images/丢帧.png" srcset="/img/loading.gif" alt="丢帧"></p><h3 id="双缓冲-Double-Buffer"><a href="#双缓冲-Double-Buffer" class="headerlink" title="双缓冲(Double Buffer)"></a>双缓冲(<code>Double Buffer</code>)</h3><blockquote><p>为了解决<code>画面撕裂</code>提出的概念</p><p>画面撕裂：在GPU向缓冲区写入数据的同时，屏幕也在从<code>buffer缓冲区</code>读取数据，导致屏幕显示了不同帧的画面，产生<code>画面撕裂</code>。</p></blockquote><p>由绘制和屏幕拥有各自的<code>buffer缓冲区</code>：</p><p><code>GPU</code>处理完数据后，将图形数据写入<code>Back Buffer</code>。</p><p><code>屏幕</code>从<code>Frame Buffer</code>读取图形数据。</p><p>当屏幕刷新(Vsync信号到来)时，<code>FrameBuffer</code>与<code>BackBuffer</code>的数据进行交换(<strong>交换各自的内存地址</strong>)，然后屏幕进行绘制。与<code>屏幕刷新频率</code>保持一个交换频率。</p><p><img src="/images/双缓冲" srcset="/img/loading.gif" alt="双缓冲示意"></p><h3 id="垂直同步-VSync"><a href="#垂直同步-VSync" class="headerlink" title="垂直同步(VSync)"></a>垂直同步(<code>VSync</code>)</h3><blockquote><p><strong>通过屏幕硬件中断告诉系统应该什么时候刷新屏幕。</strong></p><p>开启后GPU会等待显示器的VSync信号发出后再进行新的一帧渲染和缓冲区更新。</p><p>在显卡帧率大于屏幕帧率时有效解决显示问题。</p></blockquote><p>配合<code>双缓冲</code>可以使<code>CPU/GPU</code>有充分时间处理数据，减少<code>jank(丢帧)</code></p><p><img src="/images/VSync.png" srcset="/img/loading.gif" alt="VSync"></p><p>每次收到<code>VSync</code>信号时，CPU开始处理各帧数据。</p><h3 id="三缓冲-Triple-Buffer"><a href="#三缓冲-Triple-Buffer" class="headerlink" title="三缓冲(Triple Buffer)"></a>三缓冲(<code>Triple Buffer</code>)</h3><blockquote><p>在<code>双缓冲</code>机制基础上增加了一个<code>Graphic Buffer</code>缓冲区，最大限度利用空闲时间，但是会多占用一个<code>Graphic buffer</code>缓冲区内存。</p></blockquote><p><img src="/images/三缓冲.png" srcset="/img/loading.gif" alt="三缓存"></p><ol><li>第一个<code>Jank</code>时无可避免的，在第二个时间段，CPU/GPU使用第三个<code>Graphic Buffer</code>完成<code>C帧</code>的计算，避免<code>Jank</code>问题频发</li><li>在第三段时，<code>A帧</code>计算完成，需要到第四个<code>Vsync</code>信号才会显示。</li><li>第二段中，<code>C帧</code>需要在第四段才可以显示，相当于多了16ms延迟。</li></ol><blockquote><p><strong>三缓冲</strong>有效利用等待<code>vsync</code>的时间，减少了<code>jank</code>，但是增加了延迟。</p><p><strong><code>Graphic Buffer</code>不是越多越好，一般还是两个，出现<code>jank</code>以后可以三个。</strong></p></blockquote><h3 id="Project-Buffer-黄油计划"><a href="#Project-Buffer-黄油计划" class="headerlink" title="Project Buffer(黄油计划)"></a>Project Buffer(黄油计划)</h3><p>前面提到的<code>VSYnc</code>、<code>双缓冲/三缓冲</code>都是<code>Project Buffer</code>的关键点，还有下面需要提到的<code>Choreographer</code>.</p><ul><li>核心关键：<strong>VSync</strong>实现定时中断</li><li><code>双缓冲/三缓冲</code>：一般情况下<code>双缓冲</code>足矣，当出现<code>jank</code>时，可以添加一块<code>Graphic Buffer</code>缓冲区，实现<code>三缓冲</code></li><li><code>Choreographer</code>：统一管理应用的绘制工作</li></ul><h2 id="Choreographer"><a href="#Choreographer" class="headerlink" title="Choreographer"></a>Choreographer</h2><p><img src="/images/View屏幕刷新-Choreographer.png" srcset="/img/loading.gif" alt="View屏幕刷新-Choreographer"></p><blockquote><p>Android4.1 之后加入的<code>Choreographer</code>控制<code>Input输入</code>、<code>Animation动画</code>，<code>Draw绘制</code>三个UI操作。</p><p>每隔16.6ms，<code>VSync</code>信号到来时，马上开始下一帧的渲染，<strong>CPU和GPU立即开始计算把数据写入Buffer中。</strong></p></blockquote><p><img src="/images/15722752299458.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>既然说<code>Choreographer</code>与<code>View</code>的显示有关，<code>View的绘制过程</code>起点位于<code>ViewRootImpl.setView()</code>，此处为<em>Activity执行到<code>onResume()</code>后，<code>window</code>添加到Activity上</em>。通过调用到<code>ViewRootImpl.setView()</code>开始绘制布局</p><pre><code class="hljs java"><span class="hljs-comment">//ActivityThread.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">boolean</span> finalStateRequest, <span class="hljs-keyword">boolean</span> isForward,            String reason)</span> </span>&#123;  ...    <span class="hljs-keyword">if</span> (a.mVisibleFromClient) &#123;                <span class="hljs-keyword">if</span> (!a.mWindowAdded) &#123;<span class="hljs-comment">//尚未添加window</span>                    a.mWindowAdded = <span class="hljs-keyword">true</span>;                    wm.addView(decor, l);<span class="hljs-comment">//准备添加View</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// The activity will get a callback for this &#123;@link LayoutParams&#125; change</span>                    <span class="hljs-comment">// earlier. However, at that time the decor will not be set (this is set</span>                    <span class="hljs-comment">// in this method), so no action will be taken. This call ensures the</span>                    <span class="hljs-comment">// callback occurs with the decor set.</span>                    a.onWindowAttributesChanged(l);                &#125;            &#125;  ...  &#125;<span class="hljs-comment">//WindowManagerGlobal.java WindowManager实现类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,            Display display, Window parentWindow)</span> </span>&#123;      ...        ViewRootImpl root;      ...        root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);      ...        <span class="hljs-keyword">try</span> &#123;                root.setView(view, wparams, panelParentView);            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;                <span class="hljs-comment">// BadTokenException or InvalidDisplayException, clean up.</span>                <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;                    removeViewLocked(index, <span class="hljs-keyword">true</span>);                &#125;                <span class="hljs-keyword">throw</span> e;            &#125;      ...    &#125;<span class="hljs-comment">//ViewRootImpl.java</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view <span class="hljs-comment">/*DecorView*/</span>, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;     ...       requestLayout();<span class="hljs-comment">//刷新布局</span>     ...       view.assignParent(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//设置DecorView 父类为 ViewRootImpl，此时将ViewRootImpl与DecorView进行绑定</span>     ...   &#125;<span class="hljs-comment">//View.java</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assignParent</span><span class="hljs-params">(ViewParent parent)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;            mParent = parent;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent == <span class="hljs-keyword">null</span>) &#123;            mParent = <span class="hljs-keyword">null</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"view "</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">" being added, but"</span>                    + <span class="hljs-string">" it already has a parent"</span>);        &#125;    &#125;<span class="hljs-comment">//ViewRootImpl.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;            checkThread();            mLayoutRequested = <span class="hljs-keyword">true</span>;            scheduleTraversals();        &#125;    &#125;</code></pre><p>根据上述源码可以得出以下结论：</p><ul><li>Activity走完<code>onResume()</code>之后会进行<code>window的添加</code></li><li><code>window添加</code>过程中在<code>ViewRootImpl.setView()</code>中将<code>DecorView</code>与<code>ViewRootImpl</code>进行绑定</li><li><code>ViewRootImpl</code>与<code>DecorView</code>绑定后开始进行View的绘制任务</li></ul><blockquote><p>为什么<code>onCreate()</code>无法获取View宽高？</p><p>此时未执行到<code>onResume()</code>尚未开始绘制，也还没开始执行<code>measure -&gt; layout -&gt; draw</code>过程，也就无法获取。</p></blockquote><p>以上只是<code>Activity启动</code>时相关的绘制过程，此外还有<code>属性动画、View.invalidate()</code>都会影响到<code>UI变化</code>。</p><p><strong>所有的UI变化都是走到<code>ViewRootImpl.scheduleTraversals()</code>。</strong></p><h4 id="ViewRootImpl-scheduleTraversals"><a href="#ViewRootImpl-scheduleTraversals" class="headerlink" title="ViewRootImpl.scheduleTraversals()"></a>ViewRootImpl.scheduleTraversals()</h4><p><code>UI变化</code>最终都会走到此处。</p><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>    <span class="hljs-keyword">final</span> ViewRootHandler mHandler = <span class="hljs-keyword">new</span> ViewRootHandler();    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;          <span class="hljs-comment">//保证多次调用UI刷新，只走一次绘制流程</span>            mTraversalScheduled = <span class="hljs-keyword">true</span>;          <span class="hljs-comment">//添加同步屏障，屏蔽同步消息，保证Vsync到来时优先绘制流程</span>            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();          <span class="hljs-comment">//使用到了 Choreographer</span>            mChoreographer.postCallback(                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);            ...        &#125;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraversalRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            doTraversal();        &#125;    &#125;    <span class="hljs-keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="hljs-keyword">new</span> TraversalRunnable();    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doTraversal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;          <span class="hljs-comment">//执行任务时，恢复状态</span>            mTraversalScheduled = <span class="hljs-keyword">false</span>;          <span class="hljs-comment">//移除同步屏障</span>            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);            <span class="hljs-keyword">if</span> (mProfile) &#123;                Debug.startMethodTracing(<span class="hljs-string">"ViewAncestor"</span>);            &#125;           <span class="hljs-comment">//开始View的绘制流程</span>            performTraversals();            <span class="hljs-keyword">if</span> (mProfile) &#123;                Debug.stopMethodTracing();                mProfile = <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;</code></pre><p><code>scheduleTraversals()</code>主要有以下逻辑：</p><ol><li>设置<code>mTraversalScheduled)</code>保证同时多次请求只会进行一次<code>View刷新</code></li><li>在<code>getLooper().getQueue()当前消息队列</code>添加<strong>同步屏障</strong>，保证<code>Vsync信号</code>到来时，可以立即执行对应任务。暂时屏蔽掉<code>同步消息</code>的处理。</li><li>调用<code>Choreographer.postCallback(,mTraversalRunnable,)</code>，在下一次<code>VSync信号到来时</code>，会执行<code>doTraversal()</code>，继续向下调用<code>performTraversals()</code>开始绘制流程。</li></ol><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="hljs java"><span class="hljs-comment">//Choreographer.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Choreographer <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sThreadInstance.get();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =            <span class="hljs-keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Choreographer <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">//获取当前线程的Looper对象</span>            Looper looper = Looper.myLooper();            <span class="hljs-keyword">if</span> (looper == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"The current thread must have a looper!"</span>);            &#125;            Choreographer choreographer = <span class="hljs-keyword">new</span> Choreographer(looper, VSYNC_SOURCE_APP);            <span class="hljs-keyword">if</span> (looper == Looper.getMainLooper()) &#123;                mMainInstance = choreographer;            &#125;            <span class="hljs-keyword">return</span> choreographer;        &#125;    &#125;;</code></pre><p><code>Choreographer</code>和<code>Handler</code>中的<code>Looper</code>一致，都是每个线程持有一个<code>Choreographer</code>，通过<code>ThreadLocal</code>进行获取。</p><p>接下来是<code>Choreographer</code>的构造方法</p><pre><code class="hljs java"><span class="hljs-comment">//Choreographer.java    </span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Choreographer</span><span class="hljs-params">(Looper looper, <span class="hljs-keyword">int</span> vsyncSource)</span> </span>&#123;        mLooper = looper;       <span class="hljs-comment">//创建Handler对象</span>        mHandler = <span class="hljs-keyword">new</span> FrameHandler(looper);       <span class="hljs-comment">//接收Vsync信号</span>        mDisplayEventReceiver = USE_VSYNC <span class="hljs-comment">//USE_VSYNC在4.1以上默认 true，表示可以接收VSync信号</span>                ? <span class="hljs-keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)                : <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//上一次帧绘制的时间点</span>        mLastFrameTimeNanos = Long.MIN_VALUE;        <span class="hljs-comment">//每帧的差值，一般为16.6ms</span>        mFrameIntervalNanos = (<span class="hljs-keyword">long</span>)(<span class="hljs-number">1000000000</span> / getRefreshRate());        <span class="hljs-comment">//初始化回调队列</span>        mCallbackQueues = <span class="hljs-keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;            mCallbackQueues[i] = <span class="hljs-keyword">new</span> CallbackQueue();        &#125;        <span class="hljs-comment">// b/68769804: For low FPS experiments.</span>        setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="hljs-number">1</span>));    &#125;</code></pre><p><code>Choreographer</code>在构造时分别执行了以下几步：</p><ul><li>初始化<code>FrameHandler(接收并处理消息)</code></li><li>初始化<code>FrameDisplayEventReceiver(接收VSync信号)</code></li><li>初始化<code>mLastFrameTimeNanos(上一次绘制帧时间点)</code>、<code>mFrameIntervalNanos(帧率)</code></li><li>初始化<code>mCallbackQueues(回调队列)</code></li></ul><h4 id="FrameHandler"><a href="#FrameHandler" class="headerlink" title="FrameHandler"></a>FrameHandler</h4><blockquote><p>发送异步消息（设置了同步屏障）。有延迟的任务发送延迟消息，不在主线程的任务发到主线程。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FrameHandler</span><span class="hljs-params">(Looper looper)</span> </span>&#123;        <span class="hljs-keyword">super</span>(looper);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (msg.what) &#123;            <span class="hljs-keyword">case</span> MSG_DO_FRAME:            <span class="hljs-comment">//执行绘制过程</span>                doFrame(System.nanoTime(), <span class="hljs-number">0</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MSG_DO_SCHEDULE_VSYNC:            <span class="hljs-comment">//当需要执行绘制任务时，申请VSync信号</span>                doScheduleVsync();                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:            <span class="hljs-comment">//执行需要延迟的任务</span>                doScheduleCallback(msg.arg1);                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><p>主要处理以下类型的消息：</p><ul><li><code>MSG_DO_FRAME</code>：开始绘制流程</li><li><code>MSG_DO_SCHEDULE_VSYNC</code>：请求VSync信号</li><li><code>MSG_DO_SCHEDULE_CALLBACK</code>：请求执行<code>Callback</code></li></ul><h4 id="FrameDisplayEventReceiver"><a href="#FrameDisplayEventReceiver" class="headerlink" title="FrameDisplayEventReceiver"></a>FrameDisplayEventReceiver</h4><blockquote><p>主要用来接收<code>VSync信号</code>，控制系统的同步操作</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameDisplayEventReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DisplayEventReceiver</span>            <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> mHavePendingVsync;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> mTimestampNanos;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mFrame;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FrameDisplayEventReceiver</span><span class="hljs-params">(Looper looper, <span class="hljs-keyword">int</span> vsyncSource)</span> </span>&#123;            <span class="hljs-keyword">super</span>(looper, vsyncSource);        &#125;  <span class="hljs-comment">//此处接收 VSync信号</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onVsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timestampNanos, <span class="hljs-keyword">int</span> builtInDisplayId, <span class="hljs-keyword">int</span> frame)</span> </span>&#123;            <span class="hljs-keyword">if</span> (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;                Log.d(TAG, <span class="hljs-string">"Received vsync from secondary display, but we don't support "</span>                        + <span class="hljs-string">"this case yet.  Choreographer needs a way to explicitly request "</span>                        + <span class="hljs-string">"vsync for a specific display to ensure it doesn't lose track "</span>                        + <span class="hljs-string">"of its scheduled vsync."</span>);                scheduleVsync();                <span class="hljs-keyword">return</span>;            &#125;                      <span class="hljs-keyword">long</span> now = System.nanoTime();            <span class="hljs-keyword">if</span> (timestampNanos &gt; now) &#123;                Log.w(TAG, <span class="hljs-string">"Frame time is "</span> + ((timestampNanos - now) * <span class="hljs-number">0.000001f</span>)                        + <span class="hljs-string">" ms in the future!  Check that graphics HAL is generating vsync "</span>                        + <span class="hljs-string">"timestamps using the correct timebase."</span>);                timestampNanos = now;            &#125;            <span class="hljs-keyword">if</span> (mHavePendingVsync) &#123;                Log.w(TAG, <span class="hljs-string">"Already have a pending vsync event.  There should only be "</span>                        + <span class="hljs-string">"one at a time."</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                mHavePendingVsync = <span class="hljs-keyword">true</span>;            &#125;          <span class="hljs-comment">//VSync信号到来的时间</span>            mTimestampNanos = timestampNanos;            mFrame = frame;          <span class="hljs-comment">//构建异步消息，传入本身作为任务的执行者，需要执行的任务就是 run()</span>            Message msg = Message.obtain(mHandler, <span class="hljs-keyword">this</span>);            msg.setAsynchronous(<span class="hljs-keyword">true</span>);            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);        &#125;  <span class="hljs-comment">//需要执行的任务</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            mHavePendingVsync = <span class="hljs-keyword">false</span>;            doFrame(mTimestampNanos, mFrame);        &#125;    &#125;</code></pre><p>接收到<code>VSync信号</code>后，回调到<code>onVsync()</code>方法，在其中构造一个<code>异步消息</code>，传入<code>FrameDisplayEventReceiver</code>为<code>runnable</code>，通过<code>FrameHandler</code>发送该消息，等到消息触发时就执行<code>doFrame()</code>。</p><h4 id="CallbackQueue"><a href="#CallbackQueue" class="headerlink" title="CallbackQueue"></a>CallbackQueue</h4><blockquote><p>存储对应任务类型的队列，在执行任务时从对应队列中获取任务</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> CallbackRecord mHead;  <span class="hljs-comment">//当前是否有等待执行的任务</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasDueCallbacksLocked</span><span class="hljs-params">(<span class="hljs-keyword">long</span> now)</span> </span>&#123;        <span class="hljs-keyword">return</span> mHead != <span class="hljs-keyword">null</span> &amp;&amp; mHead.dueTime &lt;= now;    &#125;  <span class="hljs-comment">//获取队列任务</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CallbackRecord <span class="hljs-title">extractDueCallbacksLocked</span><span class="hljs-params">(<span class="hljs-keyword">long</span> now)</span> </span>&#123;        CallbackRecord callbacks = mHead;        <span class="hljs-keyword">if</span> (callbacks == <span class="hljs-keyword">null</span> || callbacks.dueTime &gt; now) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        CallbackRecord last = callbacks;        CallbackRecord next = last.next;        <span class="hljs-keyword">while</span> (next != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (next.dueTime &gt; now) &#123;                last.next = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">break</span>;            &#125;            last = next;            next = next.next;        &#125;        mHead = next;        <span class="hljs-keyword">return</span> callbacks;    &#125;  <span class="hljs-comment">//添加消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCallbackLocked</span><span class="hljs-params">(<span class="hljs-keyword">long</span> dueTime, Object action, Object token)</span> </span>&#123;        CallbackRecord callback = obtainCallbackLocked(dueTime, action, token);        CallbackRecord entry = mHead;        <span class="hljs-keyword">if</span> (entry == <span class="hljs-keyword">null</span>) &#123;            mHead = callback;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (dueTime &lt; entry.dueTime) &#123;            callback.next = entry;            mHead = callback;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">while</span> (entry.next != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (dueTime &lt; entry.next.dueTime) &#123;                callback.next = entry.next;                <span class="hljs-keyword">break</span>;            &#125;            entry = entry.next;        &#125;        entry.next = callback;    &#125;  <span class="hljs-comment">//删除消息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeCallbacksLocked</span><span class="hljs-params">(Object action, Object token)</span> </span>&#123;        CallbackRecord predecessor = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">for</span> (CallbackRecord callback = mHead; callback != <span class="hljs-keyword">null</span>;) &#123;            <span class="hljs-keyword">final</span> CallbackRecord next = callback.next;            <span class="hljs-keyword">if</span> ((action == <span class="hljs-keyword">null</span> || callback.action == action)                    &amp;&amp; (token == <span class="hljs-keyword">null</span> || callback.token == token)) &#123;                <span class="hljs-keyword">if</span> (predecessor != <span class="hljs-keyword">null</span>) &#123;                    predecessor.next = next;                &#125; <span class="hljs-keyword">else</span> &#123;                    mHead = next;                &#125;                recycleCallbackLocked(callback);            &#125; <span class="hljs-keyword">else</span> &#123;                predecessor = callback;            &#125;            callback = next;        &#125;    &#125;&#125;</code></pre><p><code>CallbackQueue</code>存储的元素为<code>CallbackRecord</code></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackRecord</span> </span>&#123;    <span class="hljs-keyword">public</span> CallbackRecord next;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> dueTime;    <span class="hljs-keyword">public</span> Object action; <span class="hljs-comment">// Runnable or FrameCallback</span>    <span class="hljs-keyword">public</span> Object token;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTimeNanos)</span> </span>&#123;        <span class="hljs-keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;          <span class="hljs-comment">//执行了postFrameCallback()或 postFrameCallbackDelayed 执行此处</span>            ((FrameCallback)action).doFrame(frameTimeNanos);        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">//否则执行 run</span>            ((Runnable)action).run();        &#125;    &#125;&#125;</code></pre><p>根据源码<code>CallbackRecord</code>执行<code>run()</code>有两种情况：</p><ul><li><p>token不为null且<code>FRAME_CALLBACK_TOKEN</code></p><blockquote><p>执行<code>doFrame()</code>，实际这种情况只会执行<code>postFrameCallback()</code>或<code>postFrameCallbackDelayed()</code>。</p><p>这两个方法在<a href="/2020/10/12/Android动画-属性动画/" title="Android动画-属性动画">Android动画-属性动画</a>都会被调用到</p></blockquote></li><li><p>token为其他</p><blockquote><p>执行<code>run()</code>，此时<code>action</code>对应的就是<code>ViewRootImpl的mTraversalRunnable</code>也就会开始执行绘制流程</p></blockquote></li></ul><h3 id="设置任务-postCallback"><a href="#设置任务-postCallback" class="headerlink" title="设置任务-postCallback()"></a>设置任务-postCallback()</h3><p><code>ViewRootImpl.scheduleTraversals()</code>通过<code>postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)</code>添加绘制任务</p><pre><code class="hljs java"><span class="hljs-comment">//Choreographer.java </span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCallbackDelayedInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> callbackType,            Object action, Object token, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;        ...        <span class="hljs-keyword">synchronized</span> (mLock) &#123;          <span class="hljs-comment">//当前时间</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();          <span class="hljs-comment">//延迟时间</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> dueTime = now + delayMillis;          <span class="hljs-comment">//将任务添加到回调队列</span>            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);            <span class="hljs-keyword">if</span> (dueTime &lt;= now) &#123;              <span class="hljs-comment">//任务立即开始执行</span>                scheduleFrameLocked(now);            &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-comment">//封装异步消息等待执行</span>                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);                msg.arg1 = callbackType;                msg.setAsynchronous(<span class="hljs-keyword">true</span>);                mHandler.sendMessageAtTime(msg, dueTime);            &#125;        &#125;    &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;     ...     <span class="hljs-meta">@Override</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;       ...        <span class="hljs-keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:           doScheduleCallback(msg.arg1);           <span class="hljs-keyword">break</span>;     &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doScheduleCallback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> callbackType)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            <span class="hljs-keyword">if</span> (!mFrameScheduled) &#123;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();                <span class="hljs-keyword">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;                    scheduleFrameLocked(now);                &#125;            &#125;        &#125;    &#125;</code></pre><p><code>CallbackType</code>表示回调任务的类型，目前分为4种类型</p><ul><li><code>CALLBACK_INPUT</code>：输入回调，接收到<code>VSync信号</code>时首先运行，如处理Move事件</li><li><code>CALLBACK_ANIMATION</code>：动画回调</li><li><code>CALLBACK_TRAVERSAL</code>：Traversal回调，执行<code>measure-&gt;layout-&gt;draw</code></li><li><code>CALLBACK_COMMIT</code>：Commit回调，处理帧绘制完成后的操作，如整理应用内存，属性动画起始时间调整</li></ul><p><code>postCallback()</code>最后都会执行到<code>scheduleFrameLocked()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleFrameLocked</span><span class="hljs-params">(<span class="hljs-keyword">long</span> now)</span> </span>&#123;       <span class="hljs-keyword">if</span> (!mFrameScheduled) &#123;<span class="hljs-comment">//当前是否有帧在执行</span>           mFrameScheduled = <span class="hljs-keyword">true</span>;           <span class="hljs-keyword">if</span> (USE_VSYNC) &#123;<span class="hljs-comment">//支持VSync，默认true</span>               <span class="hljs-keyword">if</span> (DEBUG_FRAMES) &#123;                   Log.d(TAG, <span class="hljs-string">"Scheduling next frame on vsync."</span>);               &#125;                            <span class="hljs-comment">//当前运行在Looper所在的线程，立即执行申请VSync信号</span>               <span class="hljs-keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;                   scheduleVsyncLocked();               &#125; <span class="hljs-keyword">else</span> &#123;                 <span class="hljs-comment">//通过 mHandler发送异步消息到原线程，申请VSync信号</span>                   Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);                   msg.setAsynchronous(<span class="hljs-keyword">true</span>);                   mHandler.sendMessageAtFrontOfQueue(msg);               &#125;           &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//不支持 VSync</span>               <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nextFrameTime = Math.max(                       mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);               <span class="hljs-keyword">if</span> (DEBUG_FRAMES) &#123;                   Log.d(TAG, <span class="hljs-string">"Scheduling next frame in "</span> + (nextFrameTime - now) + <span class="hljs-string">" ms."</span>);               &#125;               <span class="hljs-comment">//执行 doFrame()</span>               Message msg = mHandler.obtainMessage(MSG_DO_FRAME);               msg.setAsynchronous(<span class="hljs-keyword">true</span>);               mHandler.sendMessageAtTime(msg, nextFrameTime);           &#125;       &#125;   &#125;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;     ...       <span class="hljs-meta">@Override</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;           <span class="hljs-keyword">switch</span> (msg.what) &#123;               <span class="hljs-keyword">case</span> MSG_DO_FRAME:                   doFrame(System.nanoTime(), <span class="hljs-number">0</span>);                   <span class="hljs-keyword">break</span>;               <span class="hljs-keyword">case</span> MSG_DO_SCHEDULE_VSYNC:                   doScheduleVsync();                   <span class="hljs-keyword">break</span>;               ...           &#125;       &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doScheduleVsync</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">synchronized</span> (mLock) &#123;           <span class="hljs-keyword">if</span> (mFrameScheduled) &#123;               scheduleVsyncLocked();           &#125;       &#125;   &#125;</code></pre><p><code>postCallback()</code>主要执行了以下几步：</p><ol><li>实际执行的为<code>postCallbackDelayedInternal()</code>，先将任务通过<code>addCallbackLocked()</code>添加到<code>CallbackQueue</code>中</li><li>判断任务执行时间与当前时间的差值<ul><li>执行时间在当前时间之前：直接执行<code>scheduleFrameLocked()</code></li><li>执行时间在当前时间之后：将任务封装成<code>异步消息</code>，通过<code>mHandler</code>发送消息，且消息为<code>MSG_CO_SCHEDULE_CALLBACK</code>。到达执行时间之后，也是执行<code>scheduleFrameLocked()</code></li></ul></li><li>执行<code>scheduleFrameLocked()</code>，需要先判断<code>mFrameSchduled</code>，在执行跳过此次任务；未执行，继续判断<code>是否支持VSync</code><ul><li>不支持<code>VSync</code>：封装异步消息，且消息为<code>MSG_DO_FRAME</code>，发送消息到主线程，执行<code>doFrame()</code></li><li>支持<code>VSync</code>：需要判断当前是否为UI线程<ul><li>是UI线程：立即执行<code>scheduleVsyncLocked()</code></li><li>非UI线程：封装异步消息，且消息为<code>MSG_DO_SCHEDULE_VSYNC</code>，发送消息到主线程，后执行<code>scheduleVsyncLocked()</code></li></ul></li></ul></li><li>执行<code>scheduleVsyncLocked()</code>去申请<code>Vsync信号</code>。</li></ol><blockquote><p>简单总结<code>postCallback()</code></p></blockquote><h3 id="申请和接收信号-onVsync"><a href="#申请和接收信号-onVsync" class="headerlink" title="申请和接收信号-onVsync()"></a>申请和接收信号-onVsync()</h3><p>上一节调用的<code>scheduleVsyncLocked()</code>申请<code>VSync信号</code></p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleVsyncLocked</span><span class="hljs-params">()</span> </span>&#123;        mDisplayEventReceiver.scheduleVsync();    &#125;<span class="hljs-comment">//DisplayEventReceiver.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleVsync</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (mReceiverPtr == <span class="hljs-number">0</span>) &#123;            Log.w(TAG, <span class="hljs-string">"Attempted to schedule a vertical sync pulse but the display event "</span>                    + <span class="hljs-string">"receiver has already been disposed."</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            nativeScheduleVsync(mReceiverPtr);        &#125;    &#125;</code></pre><p><code>nativeScheduleVsync()</code>调用native方法申请<code>VSync信号</code></p><pre><code class="hljs java"><span class="hljs-comment">//DisplayEventReceiver.java</span>    <span class="hljs-comment">// Called from native code.</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unused"</span>)    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchVsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timestampNanos, <span class="hljs-keyword">int</span> builtInDisplayId, <span class="hljs-keyword">int</span> frame)</span> </span>&#123;        onVsync(timestampNanos, builtInDisplayId, frame);    &#125;</code></pre><p>通过native调用<code>dispatchVsync()</code>回调<code>onVsync()</code></p><pre><code class="hljs java"><span class="hljs-comment">//Chorgegrapher.FrameDisplayEventReceiver.java</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrameDisplayEventReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DisplayEventReceiver</span>            <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;      ...      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onVsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timestampNanos, <span class="hljs-keyword">int</span> builtInDisplayId, <span class="hljs-keyword">int</span> frame)</span> </span>&#123;       ...            Message msg = Message.obtain(mHandler, <span class="hljs-keyword">this</span>);            msg.setAsynchronous(<span class="hljs-keyword">true</span>);            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);      &#125;              <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            mHavePendingVsync = <span class="hljs-keyword">false</span>;            doFrame(mTimestampNanos, mFrame);        &#125;    &#125;</code></pre><p>将本身作为<code>runnable</code>对象，执行的就是<code>run()</code>，最终执行的就是<code>doFrame()</code></p><h3 id="执行任务-doFrame"><a href="#执行任务-doFrame" class="headerlink" title="执行任务-doFrame()"></a>执行任务-doFrame()</h3><blockquote><p>最终在接收到<code>VSync</code>信号时，执行<code>doFrame()</code></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTimeNanos, <span class="hljs-keyword">int</span> frame)</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> startNanos;    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<span class="hljs-comment">//</span>        <span class="hljs-keyword">if</span> (!mFrameScheduled) &#123;<span class="hljs-comment">//当前有任务在执行</span>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// no work to do</span>        &#125;        ...        <span class="hljs-comment">//预期执行时间</span>        <span class="hljs-keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;        <span class="hljs-comment">//实际frame执行时间</span>        startNanos = System.nanoTime();        <span class="hljs-comment">//预期与实际时间差</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> jitterNanos = startNanos - frameTimeNanos;        <span class="hljs-keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;<span class="hljs-comment">//时间差大于一帧执行时长，当前为16.6ms</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;<span class="hljs-comment">//计算跳过的帧数</span>            <span class="hljs-keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;<span class="hljs-comment">//默认30</span>                <span class="hljs-comment">//跳过的帧数超出了30时，打印日志</span>                Log.i(TAG, <span class="hljs-string">"Skipped "</span> + skippedFrames + <span class="hljs-string">" frames!  "</span>                        + <span class="hljs-string">"The application may be doing too much work on its main thread."</span>);            &#125;            <span class="hljs-comment">//重新计算实际执行与当前时间的偏差值</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;            <span class="hljs-keyword">if</span> (DEBUG_JANK) &#123;                Log.d(TAG, <span class="hljs-string">"Missed vsync by "</span> + (jitterNanos * <span class="hljs-number">0.000001f</span>) + <span class="hljs-string">" ms "</span>                        + <span class="hljs-string">"which is more than the frame interval of "</span>                        + (mFrameIntervalNanos * <span class="hljs-number">0.000001f</span>) + <span class="hljs-string">" ms!  "</span>                        + <span class="hljs-string">"Skipping "</span> + skippedFrames + <span class="hljs-string">" frames and setting frame "</span>                        + <span class="hljs-string">"time to "</span> + (lastFrameOffset * <span class="hljs-number">0.000001f</span>) + <span class="hljs-string">" ms in the past."</span>);            &#125;            <span class="hljs-comment">//修正偏差值，方便后续同步工作</span>            frameTimeNanos = startNanos - lastFrameOffset;        &#125;      <span class="hljs-comment">//当前时间小于上一次绘制时间，就等待下一次绘制时机到老</span>        <span class="hljs-keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;            <span class="hljs-keyword">if</span> (DEBUG_JANK) &#123;                Log.d(TAG, <span class="hljs-string">"Frame time appears to be going backwards.  May be due to a "</span>                        + <span class="hljs-string">"previously skipped frame.  Waiting for next vsync."</span>);            &#125;            scheduleVsyncLocked();            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (mFPSDivisor &gt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">long</span> timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;            <span class="hljs-keyword">if</span> (timeSinceVsync &lt; (mFrameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; <span class="hljs-number">0</span>) &#123;                scheduleVsyncLocked();                <span class="hljs-keyword">return</span>;            &#125;        &#125;        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);        mFrameScheduled = <span class="hljs-keyword">false</span>;      <span class="hljs-comment">//记录上一次绘制时间</span>        mLastFrameTimeNanos = frameTimeNanos;    &#125;    <span class="hljs-keyword">try</span> &#123;       <span class="hljs-comment">//按类型顺序执行任务</span>        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="hljs-string">"Choreographer#doFrame"</span>);        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);        mFrameInfo.markInputHandlingStart();        <span class="hljs-comment">//输入</span>        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);        mFrameInfo.markAnimationsStart();        <span class="hljs-comment">//动画</span>        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);        mFrameInfo.markPerformTraversalsStart();        <span class="hljs-comment">//绘制</span>        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);        <span class="hljs-comment">//遍历完成的提交操作</span>        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);    &#125; <span class="hljs-keyword">finally</span> &#123;        AnimationUtils.unlockAnimationClock();        Trace.traceEnd(Trace.TRACE_TAG_VIEW);    &#125;    <span class="hljs-keyword">if</span> (DEBUG_FRAMES) &#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> endNanos = System.nanoTime();        Log.d(TAG, <span class="hljs-string">"Frame "</span> + frame + <span class="hljs-string">": Finished, took "</span>                + (endNanos - startNanos) * <span class="hljs-number">0.000001f</span> + <span class="hljs-string">" ms, latency "</span>                + (startNanos - frameTimeNanos) * <span class="hljs-number">0.000001f</span> + <span class="hljs-string">" ms."</span>);    &#125;&#125;</code></pre><p><code>doFrame()</code>主要执行了两步：</p><ol><li>修正<code>frame</code>执行时间</li><li>按照顺序，从<code>callbackQueue</code>获取<code>CallbackRecord</code>执行</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doCallbacks</span><span class="hljs-params">(<span class="hljs-keyword">int</span> callbackType, <span class="hljs-keyword">long</span> frameTimeNanos)</span> </span>&#123;        CallbackRecord callbacks;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            <span class="hljs-comment">// We use "now" to determine when callbacks become due because it's possible</span>            <span class="hljs-comment">// for earlier processing phases in a frame to post callbacks that should run</span>            <span class="hljs-comment">// in a following phase, such as an input event that causes an animation to start.</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = System.nanoTime();            <span class="hljs-comment">//根据回调类型获取可执行回调(已到达执行时间)</span>            callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(                    now / TimeUtils.NANOS_PER_MS);            <span class="hljs-keyword">if</span> (callbacks == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span>;            &#125;            mCallbacksRunning = <span class="hljs-keyword">true</span>;            ...            <span class="hljs-comment">//属于 提交任务类型</span>            <span class="hljs-keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> jitterNanos = now - frameTimeNanos;                Trace.traceCounter(Trace.TRACE_TAG_VIEW, <span class="hljs-string">"jitterNanos"</span>, (<span class="hljs-keyword">int</span>) jitterNanos);                <span class="hljs-keyword">if</span> (jitterNanos &gt;= <span class="hljs-number">2</span> * mFrameIntervalNanos) &#123;                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos                            + mFrameIntervalNanos;                    <span class="hljs-keyword">if</span> (DEBUG_JANK) &#123;                        Log.d(TAG, <span class="hljs-string">"Commit callback delayed by "</span> + (jitterNanos * <span class="hljs-number">0.000001f</span>)                                + <span class="hljs-string">" ms which is more than twice the frame interval of "</span>                                + (mFrameIntervalNanos * <span class="hljs-number">0.000001f</span>) + <span class="hljs-string">" ms!  "</span>                                + <span class="hljs-string">"Setting frame time to "</span> + (lastFrameOffset * <span class="hljs-number">0.000001f</span>)                                + <span class="hljs-string">" ms in the past."</span>);                        mDebugPrintNextFrameTimeDelta = <span class="hljs-keyword">true</span>;                    &#125;                    frameTimeNanos = now - lastFrameOffset;                    mLastFrameTimeNanos = frameTimeNanos;                &#125;            &#125;        &#125;        <span class="hljs-keyword">try</span> &#123;            Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);            <span class="hljs-comment">//迭代执行对应 callbackType队列的任务</span>            <span class="hljs-keyword">for</span> (CallbackRecord c = callbacks; c != <span class="hljs-keyword">null</span>; c = c.next) &#123;                <span class="hljs-keyword">if</span> (DEBUG_FRAMES) &#123;                    Log.d(TAG, <span class="hljs-string">"RunCallback: type="</span> + callbackType                            + <span class="hljs-string">", action="</span> + c.action + <span class="hljs-string">", token="</span> + c.token                            + <span class="hljs-string">", latencyMillis="</span> + (SystemClock.uptimeMillis() - c.dueTime));                &#125;              <span class="hljs-comment">//回调CallbackRecord的run()</span>                c.run(frameTimeNanos);            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">synchronized</span> (mLock) &#123;                mCallbacksRunning = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">do</span> &#123;                    <span class="hljs-keyword">final</span> CallbackRecord next = callbacks.next;                    recycleCallbackLocked(callbacks);                    callbacks = next;                &#125; <span class="hljs-keyword">while</span> (callbacks != <span class="hljs-keyword">null</span>);            &#125;            Trace.traceEnd(Trace.TRACE_TAG_VIEW);        &#125;    &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallbackRecord</span> </span>&#123;        ...        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTimeNanos)</span> </span>&#123;            <span class="hljs-keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;              <span class="hljs-comment">//执行了postFrameCallback()或 postFrameCallbackDelayed 执行此处</span>                ((FrameCallback)action).doFrame(frameTimeNanos);            &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-comment">//否则执行 run</span>                ((Runnable)action).run();            &#125;        &#125;    &#125;</code></pre><p><code>doCallbacks()</code>主要执行了以下几步：</p><ol><li><p><code>extractDueCallbacksLocked(now/TimeUtils.NANOS_PER_MS)</code>获取当前时间之前所有可执行的Callback，保存在单链表中。</p></li><li><p>关于<code>CALLBACK_COMMIT</code>的处理，如果当前<code>frame</code>渲染时间超出了两个<code>Vsync</code>间隔，将当前提交时间修正为上一次<code>VSync信号</code>发出时间。<strong>为了保证下一个frame的提交时间和当前frame的时间相差为1且不重复</strong>。</p><p><code>CALLBACK_COUNT</code>是为了解决<code>属性动画</code>的问题引入的，有时候可能因遍历时间或绘制时间过长，导致动画启动时间过长，发生跳帧，在此处<strong>修正动画的第一帧时间</strong>。</p><p><img src="/images/CALLBACK_COMMIT作用" srcset="/img/loading.gif" alt="img"></p><p>修正了动画启动时间，保证动画执行时间的正确性。</p></li><li><p>最后取出<code>CallbackRecord</code>，执行<code>run()</code></p></li></ol><p><img src="/images/View刷新过程.jpg" srcset="/img/loading.gif" alt="View刷新过程"></p><h2 id="Vsync申请和回调流程-Native"><a href="#Vsync申请和回调流程-Native" class="headerlink" title="Vsync申请和回调流程(Native)"></a>Vsync申请和回调流程(Native)</h2><h3 id="申请Vsync信号"><a href="#申请Vsync信号" class="headerlink" title="申请Vsync信号"></a>申请Vsync信号</h3><p><code>frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp</code></p><p><code>frameworks/native/libs/gui/DisplayEventDispatcher.cpp</code></p><blockquote><p>从<code>nativeScheduleVsync()</code>开始监听<code>VSync信号</code></p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//DisplayEventReceiver.java</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nativeScheduleVsync</span><span class="hljs-params">(<span class="hljs-keyword">long</span> receiverPtr)</span></span>;    <span class="hljs-comment">//初始化</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DisplayEventReceiver</span><span class="hljs-params">(Looper looper, <span class="hljs-keyword">int</span> vsyncSource)</span> </span>&#123;        <span class="hljs-keyword">if</span> (looper == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"looper must not be null"</span>);        &#125;        mMessageQueue = looper.getQueue();        mReceiverPtr = nativeInit(<span class="hljs-keyword">new</span> WeakReference&lt;DisplayEventReceiver&gt;(<span class="hljs-keyword">this</span>), mMessageQueue,                vsyncSource);        mCloseGuard.open(<span class="hljs-string">"dispose"</span>);    &#125;</code></pre><blockquote><p>执行<code>nativeInit()</code>初始化并创建<code>DisplayEventReceiver</code></p></blockquote><pre><code class="hljs c++"><span class="hljs-comment">//android_view_DisplayEventReceiver.cpp</span><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">nativeInit</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jobject receiverWeak,        jobject messageQueueObj, jint vsyncSource, jint configChanged)</span> </span>&#123;    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);    <span class="hljs-keyword">if</span> (messageQueue == <span class="hljs-literal">NULL</span>) &#123;        jniThrowRuntimeException(env, <span class="hljs-string">"MessageQueue is not initialized."</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//创建NAtiveDisplayEventReceiver，与DurfaceFlinger建立连接</span>    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="hljs-keyword">new</span> NativeDisplayEventReceiver(env,            receiverWeak, messageQueue, vsyncSource, configChanged);    <span class="hljs-keyword">status_t</span> status = receiver-&gt;initialize();    <span class="hljs-keyword">if</span> (status) &#123;        String8 message;        message.appendFormat(<span class="hljs-string">"Failed to initialize display event receiver.  status=%d"</span>, status);        jniThrowRuntimeException(env, message.<span class="hljs-built_in">string</span>());        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); <span class="hljs-comment">// retain a reference for the object</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(receiver.get());&#125;NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env,        jobject receiverWeak, <span class="hljs-keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource,        jint configChanged) :        DisplayEventDispatcher(messageQueue-&gt;getLooper(),                <span class="hljs-keyword">static_cast</span>&lt;ISurfaceComposer::VsyncSource&gt;(vsyncSource),                <span class="hljs-keyword">static_cast</span>&lt;ISurfaceComposer::ConfigChanged&gt;(configChanged)),        mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)),        mMessageQueue(messageQueue) &#123;    ALOGV(<span class="hljs-string">"receiver %p ~ Initializing display event receiver."</span>, <span class="hljs-keyword">this</span>);&#125;</code></pre><p>新建完<code>DisplayEventReceiver</code>，由<code>DisplayEventDispatcher</code>进行后续操作</p><pre><code class="hljs c++"><span class="hljs-comment">//DisplayEventReceiver.h</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisplayEventDispatcher</span> :</span> <span class="hljs-keyword">public</span> LooperCallback &#123;  <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DisplayEventDispatcher</span><span class="hljs-params">(            <span class="hljs-keyword">const</span> sp&lt;Looper&gt;&amp; looper,            ISurfaceComposer::VsyncSource vsyncSource = ISurfaceComposer::eVsyncSourceApp,            ISurfaceComposer::ConfigChanged configChanged =                    ISurfaceComposer::eConfigChangedSuppress)</span></span>;   ...         <span class="hljs-keyword">private</span>:    sp&lt;Looper&gt; mLooper;    DisplayEventReceiver mReceiver;    ...      &#125;<span class="hljs-comment">//DisplayEventDispatcher.cpp</span>DisplayEventDispatcher::DisplayEventDispatcher(<span class="hljs-keyword">const</span> sp&lt;Looper&gt;&amp; looper,                                               ISurfaceComposer::VsyncSource vsyncSource,                                               ISurfaceComposer::ConfigChanged configChanged)      : mLooper(looper), mReceiver(vsyncSource, configChanged), mWaitingForVsync(<span class="hljs-literal">false</span>) &#123;    ALOGV(<span class="hljs-string">"dispatcher %p ~ Initializing display event dispatcher."</span>, <span class="hljs-keyword">this</span>);&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">//DisplayEventReceiver.cpp</span>DisplayEventReceiver::DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource,                                           ISurfaceComposer::ConfigChanged configChanged) &#123;    <span class="hljs-function">sp&lt;ISurfaceComposer&gt; <span class="hljs-title">sf</span><span class="hljs-params">(ComposerService::getComposerService())</span></span>;    <span class="hljs-keyword">if</span> (sf != <span class="hljs-literal">nullptr</span>) &#123;        <span class="hljs-comment">//为客户端创建显示连接，通过该连接请求SurfaceFlinger发送及接收Vsync信号</span>        mEventConnection = sf-&gt;createDisplayEventConnection(vsyncSource, configChanged);        <span class="hljs-keyword">if</span> (mEventConnection != <span class="hljs-literal">nullptr</span>) &#123;            <span class="hljs-comment">//创建BitTube</span>            mDataChannel = <span class="hljs-built_in">std</span>::make_unique&lt;gui::BitTube&gt;();            <span class="hljs-comment">//通过Binder获取对应Connection的Socket</span>            mEventConnection-&gt;stealReceiveChannel(mDataChannel.get());        &#125;    &#125;&#125;</code></pre><h4 id="createDisplayEventConnection"><a href="#createDisplayEventConnection" class="headerlink" title="createDisplayEventConnection"></a>createDisplayEventConnection</h4><p><code>createDisplayEventConnection()</code>是一个Binder IPC</p><pre><code class="hljs c++"><span class="hljs-comment">//ISurfaceComposer.cpp</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> sp&lt;IDisplayEventConnection&gt; <span class="hljs-title">createDisplayEventConnection</span><span class="hljs-params">(VsyncSource vsyncSource,                                                                     ConfigChanged configChanged)</span> </span>&#123;        Parcel data, reply;        sp&lt;IDisplayEventConnection&gt; result;        <span class="hljs-keyword">int</span> err = data.writeInterfaceToken(                ISurfaceComposer::getInterfaceDescriptor());        <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;            <span class="hljs-keyword">return</span> result;        &#125;        data.writeInt32(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;(vsyncSource));        data.writeInt32(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;(configChanged));        <span class="hljs-comment">//请求SurfaceLinger处理 CREATE_DISPLAY_EVENT_CONNECTION</span>        err = remote()-&gt;transact(                BnSurfaceComposer::CREATE_DISPLAY_EVENT_CONNECTION,                data, &amp;reply);        <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;            ALOGE(<span class="hljs-string">"ISurfaceComposer::createDisplayEventConnection: error performing "</span>                    <span class="hljs-string">"transaction: %s (%d)"</span>, strerror(-err), -err);            <span class="hljs-keyword">return</span> result;        &#125;        result = interface_cast&lt;IDisplayEventConnection&gt;(reply.readStrongBinder());        <span class="hljs-keyword">return</span> result;    &#125;</code></pre><p>在<code>onTransact()</code>处理发过来的<code>CREATE_DISPLAY_EVENT_CONNECTION</code></p><pre><code class="hljs c++"><span class="hljs-comment">//ISurfaceComposer.cpp</span><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BnSurfaceComposer::onTransact</span><span class="hljs-params">(    <span class="hljs-keyword">uint32_t</span> code, <span class="hljs-keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-keyword">uint32_t</span> flags)</span></span>&#123;  ...          <span class="hljs-keyword">case</span> CREATE_DISPLAY_EVENT_CONNECTION: &#123;            CHECK_INTERFACE(ISurfaceComposer, data, reply);            <span class="hljs-keyword">auto</span> vsyncSource = <span class="hljs-keyword">static_cast</span>&lt;ISurfaceComposer::VsyncSource&gt;(data.readInt32());            <span class="hljs-keyword">auto</span> configChanged = <span class="hljs-keyword">static_cast</span>&lt;ISurfaceComposer::ConfigChanged&gt;(data.readInt32());            <span class="hljs-function">sp&lt;IDisplayEventConnection&gt; <span class="hljs-title">connection</span><span class="hljs-params">(                    createDisplayEventConnection(vsyncSource, configChanged))</span></span>;            reply-&gt;writeStrongBinder(IInterface::asBinder(connection));            <span class="hljs-keyword">return</span> NO_ERROR;        &#125;  ...&#125;</code></pre><p>通过<code>SurfaceFlinger</code>处理请求</p><pre><code class="hljs c++"><span class="hljs-function">sp&lt;IDisplayEventConnection&gt; <span class="hljs-title">SurfaceFlinger::createDisplayEventConnection</span><span class="hljs-params">(        ISurfaceComposer::VsyncSource vsyncSource, ISurfaceComposer::ConfigChanged configChanged)</span> </span>&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; handle =            vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;    <span class="hljs-keyword">return</span> mScheduler-&gt;createDisplayEventConnection(handle, configChanged);&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">//EventThread.cpp</span><span class="hljs-function">sp&lt;EventThreadConnection&gt; <span class="hljs-title">Scheduler::createConnectionInternal</span><span class="hljs-params">(        EventThread* eventThread, ISurfaceComposer::ConfigChanged configChanged)</span> </span>&#123;    <span class="hljs-keyword">return</span> eventThread-&gt;createEventConnection([&amp;] &#123; resync(); &#125;, configChanged);&#125;<span class="hljs-function">sp&lt;IDisplayEventConnection&gt; <span class="hljs-title">Scheduler::createDisplayEventConnection</span><span class="hljs-params">(        ConnectionHandle handle, ISurfaceComposer::ConfigChanged configChanged)</span> </span>&#123;    RETURN_IF_INVALID_HANDLE(handle, <span class="hljs-literal">nullptr</span>);    <span class="hljs-keyword">return</span> createConnectionInternal(mConnections[handle].thread.get(), configChanged);&#125;<span class="hljs-function">sp&lt;EventThreadConnection&gt; <span class="hljs-title">EventThread::createEventConnection</span><span class="hljs-params">(        ResyncCallback resyncCallback, ISurfaceComposer::ConfigChanged configChanged)</span> <span class="hljs-keyword">const</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EventThreadConnection(<span class="hljs-keyword">const_cast</span>&lt;EventThread*&gt;(<span class="hljs-keyword">this</span>), <span class="hljs-built_in">std</span>::move(resyncCallback),                                     configChanged);&#125;</code></pre><p>最后生成<code>EventConnection</code>对象，主要有两个作用：</p><ul><li>处理客户的的Vsync申请请求</li><li>向客户端发送事件(Vsync)</li></ul><pre><code class="hljs c++"><span class="hljs-comment">//EventThread.cpp</span>EventThreadConnection::EventThreadConnection(EventThread* eventThread,                                             ResyncCallback resyncCallback,                                             ISurfaceComposer::ConfigChanged configChanged)      : resyncCallback(<span class="hljs-built_in">std</span>::move(resyncCallback)),        mConfigChanged(configChanged),        mEventThread(eventThread),        mChannel(gui::BitTube::DefaultSize) &#123;&#125;</code></pre><p><code>BitTube</code>是一个<code>Socket pair</code>，主要有两个作用：</p><ul><li>封装用于显示时间的Socket通信</li><li>跨进程传递Socket文件描述符(<code>fd</code>)</li></ul><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventThreadConnection::onFirstRef</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> mEventThread doesn't hold a strong reference on us</span>    mEventThread-&gt;registerDisplayEventConnection(<span class="hljs-keyword">this</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">EventThread::registerDisplayEventConnection</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;    <span class="hljs-function"><span class="hljs-built_in">std</span>::lock_guard&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mMutex)</span></span>;    <span class="hljs-comment">// this should never happen</span>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">std</span>::find(mDisplayEventConnections.cbegin(),            mDisplayEventConnections.cend(), connection);    <span class="hljs-keyword">if</span> (it != mDisplayEventConnections.cend()) &#123;        ALOGW(<span class="hljs-string">"DisplayEventConnection %p already exists"</span>, connection.get());        mCondition.notify_all();        <span class="hljs-keyword">return</span> ALREADY_EXISTS;    &#125;    <span class="hljs-comment">//添加连接到集合中</span>    mDisplayEventConnections.push_back(connection);    mCondition.notify_all();    <span class="hljs-keyword">return</span> NO_ERROR;&#125;</code></pre><p><code>EventThread</code>与<code>EventThreadConnection</code>采用<code>观察者模式</code>，当有显示事件发生时，<code>EventThread</code>向<code>EventThreadConnection</code>传递事件。</p><h4 id="stealReceiveChannel"><a href="#stealReceiveChannel" class="headerlink" title="stealReceiveChannel"></a>stealReceiveChannel</h4><p>通过一系列操作得到<code>EventConnection</code>，在向下执行到<code>stealReceiveChannel()</code></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BpDisplayEventConnection</span> :</span> <span class="hljs-keyword">public</span> SafeBpInterface&lt;IDisplayEventConnection&gt; &#123;  ...        <span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">stealReceiveChannel</span><span class="hljs-params">(gui::BitTube* outChannel)</span> <span class="hljs-keyword">override</span> </span>&#123;        <span class="hljs-keyword">return</span> callRemote&lt;<span class="hljs-keyword">decltype</span>(                &amp;IDisplayEventConnection::stealReceiveChannel)&gt;(Tag::STEAL_RECEIVE_CHANNEL,                                                                outChannel);    &#125;  ...&#125;  <span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BnDisplayEventConnection::onTransact</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> code, <span class="hljs-keyword">const</span> Parcel&amp; data, Parcel* reply,                                              <span class="hljs-keyword">uint32_t</span> flags)</span> </span>&#123;    <span class="hljs-keyword">if</span> (code &lt; IBinder::FIRST_CALL_TRANSACTION || code &gt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(Tag::LAST)) &#123;        <span class="hljs-keyword">return</span> BBinder::onTransact(code, data, reply, flags);    &#125;    <span class="hljs-keyword">auto</span> tag = <span class="hljs-keyword">static_cast</span>&lt;Tag&gt;(code);    <span class="hljs-keyword">switch</span> (tag) &#123;        <span class="hljs-keyword">case</span> Tag::STEAL_RECEIVE_CHANNEL:            <span class="hljs-keyword">return</span> callLocal(data, reply, &amp;IDisplayEventConnection::stealReceiveChannel);        ...    &#125;&#125;</code></pre><p>监听<code>mReceivcer</code>所获的文件句柄，一旦有数据到来，回调给<code>this</code>即<code>DisplayEventDispatcher</code>的<code>handleEvent()</code></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">DisplayEventDispatcher::initialize</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">status_t</span> result = mReceiver.initCheck();    <span class="hljs-keyword">if</span> (result) &#123;        ALOGW(<span class="hljs-string">"Failed to initialize display event receiver, status=%d"</span>, result);        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-keyword">if</span> (mLooper != <span class="hljs-literal">nullptr</span>) &#123;        <span class="hljs-keyword">int</span> rc = mLooper-&gt;addFd(mReceiver.getFd(), <span class="hljs-number">0</span>, Looper::EVENT_INPUT, <span class="hljs-keyword">this</span>, <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">if</span> (rc &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> UNKNOWN_ERROR;        &#125;    &#125;    <span class="hljs-keyword">return</span> OK;&#125;</code></pre><blockquote><p><code>FrameDisplayEventReceiver</code></p></blockquote><h3 id="回调Vsync信号"><a href="#回调Vsync信号" class="headerlink" title="回调Vsync信号"></a>回调Vsync信号</h3><p>收到<code>Vsync信号</code>后，回调到<code>DisplayEventDispatcher.handleEvent()</code></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DisplayEventDispatcher::handleEvent</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span> events, <span class="hljs-keyword">void</span>*)</span> </span>&#123;    <span class="hljs-keyword">if</span> (events &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) &#123;        ALOGE(<span class="hljs-string">"Display event receiver pipe was closed or an error occurred.  "</span>              <span class="hljs-string">"events=0x%x"</span>,              events);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// remove the callback</span>    &#125;    <span class="hljs-keyword">if</span> (!(events &amp; Looper::EVENT_INPUT)) &#123;        ALOGW(<span class="hljs-string">"Received spurious callback for unhandled poll event.  "</span>              <span class="hljs-string">"events=0x%x"</span>,              events);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// keep the callback</span>    &#125;    <span class="hljs-comment">// Drain all pending events, keep the last vsync.</span>    <span class="hljs-keyword">nsecs_t</span> vsyncTimestamp;    PhysicalDisplayId vsyncDisplayId;    <span class="hljs-keyword">uint32_t</span> vsyncCount;    <span class="hljs-keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;        ALOGV(<span class="hljs-string">"dispatcher %p ~ Vsync pulse: timestamp=%"</span> PRId64              <span class="hljs-string">", displayId=%"</span> ANDROID_PHYSICAL_DISPLAY_ID_FORMAT <span class="hljs-string">", count=%d"</span>,              <span class="hljs-keyword">this</span>, ns2ms(vsyncTimestamp), vsyncDisplayId, vsyncCount);        mWaitingForVsync = <span class="hljs-literal">false</span>;        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// keep the callback</span>&#125;</code></pre><p>回调到<code>handleEvent()</code>在向下执行到<code>dispatchVsync()</code></p><pre><code class="hljs c++"><span class="hljs-comment">//android_view_DisplayEventReceiver.cpp</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">NativeDisplayEventReceiver::dispatchVsync</span><span class="hljs-params">(<span class="hljs-keyword">nsecs_t</span> timestamp, PhysicalDisplayId displayId,                                               <span class="hljs-keyword">uint32_t</span> count)</span> </span>&#123;    JNIEnv* env = AndroidRuntime::getJNIEnv();    <span class="hljs-function">ScopedLocalRef&lt;jobject&gt; <span class="hljs-title">receiverObj</span><span class="hljs-params">(env, jniGetReferent(env, mReceiverWeakGlobal))</span></span>;    <span class="hljs-keyword">if</span> (receiverObj.get()) &#123;        ALOGV(<span class="hljs-string">"receiver %p ~ Invoking vsync handler."</span>, <span class="hljs-keyword">this</span>);        env-&gt;CallVoidMethod(receiverObj.get(),                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, displayId, count);        ALOGV(<span class="hljs-string">"receiver %p ~ Returned from vsync handler."</span>, <span class="hljs-keyword">this</span>);    &#125;    mMessageQueue-&gt;raiseAndClearException(env, <span class="hljs-string">"dispatchVsync"</span>);&#125;</code></pre><p>此处调用到<code>DisplayEventReceiver.dispatchVsync()</code></p><h2 id="Handler异步消息与同步屏障"><a href="#Handler异步消息与同步屏障" class="headerlink" title="Handler异步消息与同步屏障"></a>Handler异步消息与同步屏障</h2><p>在<code>ViewRootImpl.schdeuleTraversals()</code>执行<code>mHandler.getLooper().getQueue().postSyncBarrier()</code>添加<code>同步屏障</code>，在<code>doTraversal()</code>执行<code>removeSyncBarrier()</code>移除<code>同步屏障</code>。</p><p><code>同步屏障</code>：为了<strong>提高异步消息优先级，保证Vsync信号和绘制的同步。</strong></p><a href="/2018/05/14/Handler机制即源码解析/" title="Handler机制源码解析">Handler机制源码解析</a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/View屏幕刷新-总结.png" srcset="/img/loading.gif" alt="总结"></p><p><strong>丢帧</strong>：这一帧的内容延迟显示，因为只有收到<code>VSync信号</code>才会进行Buffer交换。主要原因一般都是：<strong>布局层级较多或主线程耗时导致CPU/GPU执行时间变长，超出<code>16.6ms</code>就会导致丢帧</strong>。</p><p>一般屏幕的固定刷新率是<code>60Hz</code>，换算就是<code>60帧</code>，即每<code>16.6ms</code>切换一帧。</p><p>屏幕内容的绘制也是如此，没有绘制任务(没执行<code>scheduleTraversals()</code>)就不会执行绘制流程，但是<strong>底层仍然会每隔16.6ms切换下一帧画面，只不过一直显示相同的内容</strong>。当有绘制任务时，执行完<code>measure-&gt;layout-&gt;draw</code>流程后，依然需要等待收到<code>VSync信号</code>界面才会刷新。</p><p><code>VSync信号</code>发生在<em>扫描完一个屏幕后，需要从最下面回到第一行继续循环，此时会发出该信号保证双缓冲(CPU/GPU)数据交换</em>。</p><p>在同一时间多次调用<code>requestLayout()/invalidate()</code>不会导致多次页面刷新，由于<code>mTraversalScheduled</code>的设置，当存在任务的时候，就会过滤重复请求，因为<strong>最后的请求都会执行到<code>ViewRootImpl.scheduleTraversals()</code>，只要一次绘制就可以刷新所有View</strong>。</p><p><code>Choreographer</code>主要为了<strong>在VSync信号到来时开始处理消息即CPU/GPU绘制</strong>。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><img src="/images/View屏幕刷新-其他知识.png" srcset="/img/loading.gif" alt="其他"></p><ol><li><p>利用<code>Choreographer.postFrameCallback(frameCallback)</code>统计丢帧状况</p><p><code>postFrameCallback()</code>会在每次frame渲染的时候回调一次，然后执行<code>frameCallback.doFrame()</code>，在<code>doFrame()</code>可以获取每一帧的渲染时间然后判断是否发生丢帧</p><pre><code class="hljs java">Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">new</span> TestFrameCallback())<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFrameCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Choreographer</span>.<span class="hljs-title">FrameCallback</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(<span class="hljs-keyword">long</span> frameTimeNanos)</span></span>&#123;    ...    <span class="hljs-comment">//计算帧率 or others</span>          <span class="hljs-comment">//注册下一帧回调  </span>    Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">this</span>);  &#125;&#125;</code></pre></li><li><p><code>Choreographer.CALLBACK_INPUT</code>使用场景？</p><a href="/2020/10/21/Android事件分发/" title="Android事件分发">Android事件分发</a></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><a href="/2018/12/14/View的工作原理/" title="View的工作原理">View的工作原理</a><p><a href="http://gityuan.com/2017/02/25/choreographer/" target="_blank" rel="noopener">Choreographer原理</a></p><p><a href="cs.android.com">Android Code Search</a></p><p><a href="https://androidperformance.com/2019/10/22/Android-Choreographer/" target="_blank" rel="noopener">Android-Choreographer</a></p><p><a href="https://www.jianshu.com/p/304f56f5d486" target="_blank" rel="noopener">Android与SurfaceFlinger建立连接过程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重学Binder</title>
    <link href="/2020/05/19/%E9%87%8D%E5%AD%A6Binder/"/>
    <url>/2020/05/19/%E9%87%8D%E5%AD%A6Binder/</url>
    
    <content type="html"><![CDATA[<!--基于先前的学习内容，重新进行Binder理论知识的整理--><h2 id="Linux传统的进程间通信原理"><a href="#Linux传统的进程间通信原理" class="headerlink" title="Linux传统的进程间通信原理"></a>Linux传统的进程间通信原理</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Linux-IPC-Basics.png" srcset="/img/loading.gif" class="full-image" alt="Linux进程结构" title="Linux进程结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><blockquote><p>保护系统中进程互不干扰。在操作系统中，进程之间数据是不互通的，相互之间无法访问数据，保证数据的安全星。</p></blockquote><p>在<code>进程隔离</code>的条件下，需要通过<code>IPC(Inter Process Communication)机制</code>进行进程间的通信。</p><h3 id="进程空间划分"><a href="#进程空间划分" class="headerlink" title="进程空间划分"></a>进程空间划分</h3><blockquote><p>操作系统的核心是<strong>内核</strong>，独立于普通的应用程序，可以访问受保护的内存空间以及底层的硬件设备。</p></blockquote><p>为了使用户进程不能操作内核，保证内核的安全性。所以操作系统将虚拟空间划分为两部分：</p><ul><li><p><strong>内核空间</strong>(一般占1GB)</p><p>系统内核运行的空间</p></li><li><p><strong>用户空间</strong>(一般占3GB)</p><p>用于用户程序执行的空间</p></li></ul><p><strong>用户空间在不同进程之间不能共享，内核空间是各个进程之间共享的。</strong></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><blockquote><p>用户空间的权限低于内核空间，导致用户空间无法直接访问内核资源(例如文件操作、网络访问等)，就需要借助<strong>系统调用</strong>实现内核资源访问。</p></blockquote><p><strong>系统调用</strong>是用户空间访问内核的唯一方式，保证了所有资源访问都是在内核的控制下进行，避免用户程序对系统资源的越级访问，提升系统的安全和稳定性。</p><p>Linux采用两级保护机制：</p><ul><li>0级供系统内核使用</li><li>3级供用户程序使用</li></ul><p>当进程使用<code>系统调用</code>执行内核代码时，进程就进入了<strong>内核态</strong>，此时处理器处于<code>0级·</code>；当进程执行自己的代码时，进程就进入<strong>用户态</strong>，此时处理器位于<code>3级·</code>。</p><p><code>系统调用</code>主要通过以下两个函数实现：</p><ul><li><code>copy_from_user</code>：将数据从用户空间拷贝到内核空间</li><li><code>copy_to_user</code>：将数据从内核空间拷贝到用户空间</li></ul><h3 id="传统IPC功能实现"><a href="#传统IPC功能实现" class="headerlink" title="传统IPC功能实现"></a>传统IPC功能实现</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Linux-IPC.png" srcset="/img/loading.gif" class="full-image" alt="Linux IPC" title="Linux IPC"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ol><li>发送进程通过<code>系统调用 copy_from_user·</code>把自己的<code>内存缓存区(发送进程)</code>的数据拷贝到<code>内核缓存区</code>中</li><li>内核程序通过<code>系统调用 copy_to_user</code>把内核缓存区的数据拷贝到接收进程的<code>内存缓存区</code>中</li></ol><p>传统IPC通信过程中暴露了两个明显的缺点：</p><ol><li><strong>性能低下</strong>，需要经历两次数据拷贝过程：<code>发送进程内存缓存区 -&gt; 内核缓存区 -&gt; 接收进程内存缓存区</code></li><li><strong>空间、时间浪费</strong>，接收方需要事先开辟一块内存空间准备接受发送方的数据，由于不能确定数据的大小。所以只能开辟一块较大的空间(<code>空间浪费</code>)或者先行获取发送数据的大小(<code>时间浪费</code>)。</li></ol><h2 id="Binder通信"><a href="#Binder通信" class="headerlink" title="Binder通信"></a>Binder通信</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程相关合集整理</title>
    <link href="/2020/05/02/Java%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%90%88%E9%9B%86%E6%95%B4%E7%90%86/"/>
    <url>/2020/05/02/Java%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%90%88%E9%9B%86%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>应用程序在内存中分配的空间，也就是正在运行的程序。进程是系统运行程序的基本单位。</p></blockquote><p>CPU采用<code>时间片轮转</code>的方式运行进程：CPU为每个进程分配一个时间段，称作它的时间片。</p><p>如果在这个时间片结束进程还在进行，则暂停这个进程的运行，并且CPU会被分配到另一个进程(<strong>上下文切换</strong>)。</p><p>进程让操作系统的并发成为了可能。<code>进程就是程序的实体</code>。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>线程与进程类似，但线程比进程更小，是CPU调度和分配的基本单位。一个进程在其执行的过程中可以产生多个线程。</p></blockquote><p>线程让进程内部并发成为了可能。</p><h4 id="与进程的区别"><a href="#与进程的区别" class="headerlink" title="与进程的区别"></a>与进程的区别</h4><ul><li><code>进程</code>是一个独立的运行环境，线程只是在进程中执行的一个任务。本质区别是<strong>是否单独占有内存地址空间和其他系统资源。</strong></li><li><code>进程</code>间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互相不干扰；<code>线程</code>共享进程的数据，同步复杂。</li><li><code>进程</code>崩溃不会影响其他进程，不会影响主进程的稳定性；线程崩溃影响整个进程的稳定性，可靠性较低。</li><li><code>进程</code>创建和销毁需要保存<code>寄存器和栈信息</code>，还需要资源的回收和调度，开销较大；<code>线程</code>只需要保存<code>寄存器和栈信息</code>，开销较小。</li></ul><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><blockquote><p>每个进程拥有独立的资源，每个进程在单核处理器并发执行，在多核处理器并行执行。</p></blockquote><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote><p>一个进程可以包含多个线程，多个线程共享进程资源。可以合理利用CPU资源。</p></blockquote><p>相比于<code>多进程</code>有如下好处：</p><ul><li>进程间通信比较复杂，线程间的通信相对简单，通常情况下，进程共享资源的使用比较简单。</li><li>进程是重量级的，线程是轻量级的，系统开销更小。</li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><blockquote><p>同一时间段，多个任务都在执行。<code>多个任务交替执行，也可能串行执行。</code></p></blockquote><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><blockquote><p>同一时间段，多个任务同时执行，只有多核处理器可以做到。</p></blockquote><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><blockquote><p>CPU从一个进程(线程)切换到另一个进程(线程)，需要先存储当前进程(线程)的状态，然后载入另一个进程(线程)的数据，然后开始执行另一个进程(线程)。</p><p><code>上下文</code>指的就是切换时需要保存的数据，例如<strong>本地数据，程序指针等</strong>。</p></blockquote><p>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行完一个时间片后切换到下一个任务。<em>如果线程在时间片结束前阻塞或结束，则CPU立即进行切换。</em></p><p><code>上下文切换</code>通常是<code>计算密集型</code>的，意味着<strong>消耗大量的CPU时间，线程越多造成的压力越大。</strong></p><h4 id="计算机密集型-CPU密集型"><a href="#计算机密集型-CPU密集型" class="headerlink" title="计算机密集型(CPU密集型)"></a>计算机密集型(CPU密集型)</h4><blockquote><p>进行大量的计算，消耗CPU资源。</p></blockquote><h4 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h4><blockquote><p>涉及到网络、磁盘IO的任务较多，CPU消耗较少。</p></blockquote><h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h3 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h3><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"Hello Thread"</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Thread thread = <span class="hljs-keyword">new</span> ThreadTest();        thread.start();    &#125;&#125;</code></pre><p><strong>调用<code>start()</code>后线程才算启动。</strong>如果只调用<code>run()</code>就是普通的方法调用。</p><blockquote><p>调用了<code>start()</code>后，虚拟机会先创建一个线程，当线程获取<code>时间片</code>后再调用<code>run()</code>。</p><p><strong>不可多次调用<code>start()</code>，否则后续调用会抛出异常<code>java.lang.IllegalThreadStateException</code>。</strong></p></blockquote><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    MyRunnable instance = <span class="hljs-keyword">new</span> MyRunnable();    Thread thread = <span class="hljs-keyword">new</span> Thread(instance);    thread.start();&#125;</code></pre><p>调用<code>start()</code>后线程才算启动。</p><h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><blockquote><p>需要重写<code>call()</code>并配合<code>Future</code>或<code>FutureTask</code>使用。</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 模拟计算需要一秒</span>        Thread.sleep(<span class="hljs-number">1000</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;        <span class="hljs-comment">// 使用</span>        ExecutorService executor = Executors.newCachedThreadPool();        Task task = <span class="hljs-keyword">new</span> Task();        Future&lt;Integer&gt; result = executor.submit(task);        <span class="hljs-comment">// 注意调用get方法会阻塞当前线程，直到得到结果。</span>        <span class="hljs-comment">// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span>        System.out.println(result.get());     &#125;&#125;</code></pre><p><code>Callable</code>一般配合<code>ExecutorService</code>来使用的，可以返回<code>call()</code>结果。</p><h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-comment">//试图取消任务的执行。mayInterruptIfRunning确定是否应该以试图停止任务的方式中断执行任务流程。true 直接中断 false等待执行完成 </span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;    <span class="hljs-comment">//任务正常完成前将其取消，返回true</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//任务已完成或者因为正常终止、异常，取消而完成，返回true</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//等待计算结果的返回，如果被取消则抛出异常</span>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;    <span class="hljs-comment">//设定执行时间，超过时间则抛出Timeout异常</span>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;&#125;</code></pre><p>通过<code>Callable</code>可以得到一个<code>Future</code>对象，表示异步计算的结果。</p><h5 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-comment">/**     * Sets this Future to the result of its computation     * unless it has been cancelled.     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><code>FutureTask</code>实现了<code>RunnableFuture</code>接口，<code>FutureTask</code>可以简化使用。</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread类</td><td>编写简单，可以使用<code>this</code>直接访问当前线程</td><td>1.受限于Java类的单继承，无法继承其他类；<br>2.多个线程之间无法共享方法或实例变量</td></tr><tr><td>实现Runnable接口</td><td>多个线程可共享一个实现了<code>Runnable</code>接口的类，非常适合多个线程处理同一任务</td><td>1.<code>run()</code>没有返回值<br>2.不能直接捕获运行过程中的异常，需要使用<code>setDefaultUncaughtExceptionHandler()</code>捕获子线程的异常</td></tr><tr><td>实现Callable接口</td><td>多个线程可共享一个实现了<code>Callable</code>接口的类，非常适合多个线程处理同一任务；可以有返回值；可以抛出异常</td><td>编写略微复杂，要访问当前线程需要使用<code>Thread.currentThread()</code></td></tr></tbody></table><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Thread-State.png" srcset="/img/loading.gif" class="full-image" alt="线程状态" title="线程状态"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>如上图所示，线程共有6种状态</p><h4 id="NEW-新建状态"><a href="#NEW-新建状态" class="headerlink" title="NEW(新建状态)"></a>NEW(新建状态)</h4><p>线程此时尚未启动，还未调用<code>Thread.start()</code></p><blockquote><p>反复调用<code>start()</code>会抛出<code>IllegalThreadStateException</code>，就算线程执行完毕，进入<code>Terminated</code>状态，也无法调用<code>start()</code>重新启动线程。</p><pre><code class="hljs java">&gt; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;&gt;   <span class="hljs-comment">//第一次start之后，threadStatus不为0，后续再次调用出错</span>&gt;     <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)&gt;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();&gt; &gt;     group.add(<span class="hljs-keyword">this</span>);&gt; &gt;     <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;&gt;     <span class="hljs-keyword">try</span> &#123;&gt;         start0();&gt;         started = <span class="hljs-keyword">true</span>;&gt;     &#125; <span class="hljs-keyword">finally</span> &#123;&gt;         <span class="hljs-keyword">try</span> &#123;&gt;             <span class="hljs-keyword">if</span> (!started) &#123;&gt;                 group.threadStartFailed(<span class="hljs-keyword">this</span>);&gt;             &#125;&gt;         &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;&gt; &gt;         &#125;&gt;     &#125;&gt; &#125;&gt;</code></pre></blockquote><h4 id="RUNNABLE-可运行状态"><a href="#RUNNABLE-可运行状态" class="headerlink" title="RUNNABLE(可运行状态)"></a>RUNNABLE(可运行状态)</h4><p>当前线程正在运行中，也可能等待其他系统资源(IO资源)，资源调度完成就进入运行状态。</p><p><strong>可以被运行，无法知道是否正在运行。</strong></p><p>包含<code>Ready</code>和<code>running</code>两个状态。</p><h4 id="BLOCKED-阻塞状态"><a href="#BLOCKED-阻塞状态" class="headerlink" title="BLOCKED(阻塞状态)"></a>BLOCKED(阻塞状态)</h4><p>当前线程被阻塞，等待其他线程释放锁(<code>monitor lock</code>)，暂时不能运行。</p><h4 id="WAITING-无限期等待状态"><a href="#WAITING-无限期等待状态" class="headerlink" title="WAITING(无限期等待状态)"></a>WAITING(无限期等待状态)</h4><p>当前线程处于等待状态，需要其他线程显式唤醒。</p><p>与<code>BLOCKED</code>的区别在于，<code>阻塞</code>是被动的，<code>等待</code>是主动的。</p><p>调用如下方法可以进入<code>WAITING</code>状态</p><table><thead><tr><th>进入<code>WAITING</code>状态</th><th>退出<code>WAITING</code>状态</th></tr></thead><tbody><tr><td>Object.wait()</td><td>Object.notify()/Object.notifyAll()</td></tr><tr><td>Thread.join()</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park()</td><td>LockSupport.unpark(thread)</td></tr></tbody></table><h4 id="TIMED-WAITING-超时等待状态"><a href="#TIMED-WAITING-超时等待状态" class="headerlink" title="TIMED_WAITING(超时等待状态)"></a>TIMED_WAITING(超时等待状态)</h4><p>当前线程等待一个具体时间，时间到后会被系统自动唤醒。</p><p>与<code>WAITING</code>的区别在于，<code>TIMED_WAITING</code>是有限时间的等待。</p><p>调用如下方法可以进入<code>TIMED_WAITING</code>状态</p><table><thead><tr><th>进入<code>TIMED_WAITING</code>状态</th><th>退出<code>TIMED_WAITING</code>状态</th></tr></thead><tbody><tr><td>Thread.sleep(long mills)</td><td>时间结束</td></tr><tr><td>Object.wait(long timeout)</td><td>时间结束<br>Object.notify()<br>Object.notifyAll()</td></tr><tr><td>Thread.join(long mills)</td><td>时间结束<br>调用线程执行完毕</td></tr><tr><td>LockSupport.parkNanos(long nanos)</td><td>LockSupport.unpark(thread)</td></tr><tr><td>LockSupport.parkUntil(long deadline)</td><td>LockSupport.unpark(thread)</td></tr></tbody></table><h4 id="TERMINATED-终止状态"><a href="#TERMINATED-终止状态" class="headerlink" title="TERMINATED(终止状态)"></a>TERMINATED(终止状态)</h4><p>当前线程已经中止，可能是任务执行完毕或者发生了异常导致运行结束。</p><h3 id="线程常见方法"><a href="#线程常见方法" class="headerlink" title="线程常见方法"></a>线程常见方法</h3><h4 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h4><p>线程启动，表示线程进入<code>RUNNABLE</code>状态，等待CPU时间片分配可以执行</p><h4 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h4><p>只是调用线程中的执行代码</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a><code>join</code></h4><p>在线程中调用另一个线程的<code>join()</code>，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p><code>join(long)</code>设置等待时间</p><h4 id="sleep-long-mills"><a href="#sleep-long-mills" class="headerlink" title="sleep(long mills)"></a><code>sleep(long mills)</code></h4><p>主动放弃占用的CPU资源，进入<code>BLOCKED</code>状态，并进入休眠状态<code>mills</code>毫秒。当超过<code>mills</code>后，线程就会进入<code>RUNNABLE</code>状态，等待执行。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a><code>yield()</code></h4><p>主动放弃占用的CPU资源，进入<code>RUNNABLE</code>状态，等待CPU时间片。</p><p><strong>建议让步给它优先级比它高或者相同的待运行(<code>RUNNABLE</code>)的线程运行。放弃的时间不确定，可能会自己获取CPU时间片继续执行任务。</strong></p><h4 id="interrupte-interrupted-isInterrupted"><a href="#interrupte-interrupted-isInterrupted" class="headerlink" title="interrupte()/interrupted()/isInterrupted()"></a><code>interrupte()/interrupted()/isInterrupted()</code></h4><p><code>interrupt()</code>：中断线程，不会立即停止线程，设置线程中断状态为<code>true</code></p><p>如果该线程处于<code>BLOCKED、WAITING、TIMED_WAITING</code>状态，执行<code>interrupt()</code>会抛出<code>InterruptException</code>异常。</p><p><code>interrupted()</code>：测试当前线程是否中断，线程的中断状态受到这个方法的影响。例如调用一次设置中断状态为<code>true</code>，设置两次为<code>false</code>。线程会去检测中断位，判断线程是否中断。</p><p><code>isInterrupted()</code>：测试当前线程是否中断，调用这个方法不会影响线程中断状态。</p><blockquote><p>线程中断只是设置线程中断状态为<code>true</code>，具体线程何时中断，由线程自己而定，可能不会发生中断。</p></blockquote><h4 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority()"></a><code>setPriority()</code></h4><p>设置线程的优先级。<strong>高优先级的线程会更容易被执行，也需要视具体的系统决定。</strong></p><p>线程的调度策略采用<strong>抢占式</strong>，优先级高的线程比低的更大几率被执行。</p><p>线程优先级具有：</p><ul><li><code>继承性</code>：A线程启动B线程，则B线程与A线程优先级一致</li><li><code>随机性</code>：优先级高的不一定先执行</li></ul><p>优先级从<code>1~10</code>，越大优先级越高。</p><blockquote><p>如果某个线程的优先级大于所属<code>线程组(ThreadGroup)</code>的最大优先级，就会采用<code>线程组</code>的最大优先级。</p></blockquote><h2 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h2><blockquote><p>一个进程可以开启多个线程，多个线程共享进程资源，提高资源利用率。</p></blockquote><p>优点：</p><ul><li>资源利用率高</li><li>提高程序的执行效率(提高系统的整体的并发能力以及性能)</li><li>减少了线程<code>上下文切换</code>的开销(多个线程同时运行)</li></ul><p>缺点：</p><ul><li><p>设计更复杂</p><p>线程间的执行是无序的，线程同步产生的错误是难以发现</p></li><li><p>线程死锁</p></li><li><p>更多的资源消耗</p><p>除了<code>上下文切换</code>的开销，还有创建销毁线程的开销还有内存同步的开销</p></li></ul><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><blockquote><p>多个线程同时被阻塞，他们中的一个或多个都在等待某个资源释放，由于线程无限期堵塞，导致程序无法正常中止。</p></blockquote><p>产生死锁的4个条件：</p><ul><li>互斥条件：该资源任一时刻只能由一个线程占用</li><li>请求与保持条件：一个进程因请求资源阻塞时，对已获得的资源保持不放</li><li>不剥夺条件：线程获得的资源未使用完之前，无法被其他线程强行剥夺</li><li>循环等待条件：进程之间形成头尾相接的循环等待资源关系</li></ul><pre><code class="hljs java"><span class="hljs-comment">//死锁示例</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockDemo</span></span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object resource1 = <span class="hljs-keyword">new</span> Object();  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object resource2 = <span class="hljs-keyword">new</span> Object();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;             <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"线程1"</span>)&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">synchronized</span> (resource1)&#123;                    System.err.println(<span class="hljs-string">"get resource1"</span>);                    <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">1000</span>);                    &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;                        e.printStackTrace();                    &#125;                    <span class="hljs-keyword">synchronized</span> (resource2)&#123;                        System.err.println(<span class="hljs-string">"get resource2"</span>);                    &#125;                &#125;            &#125;        &#125;.start();        <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"线程2"</span>)&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">synchronized</span> (resource2)&#123;                    System.err.println(<span class="hljs-string">"get resource1"</span>);                    <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">1000</span>);                    &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;                        e.printStackTrace();                    &#125;                    <span class="hljs-keyword">synchronized</span> (resource1)&#123;                        System.err.println(<span class="hljs-string">"get resource2"</span>);                    &#125;                &#125;            &#125;        &#125;.start();  &#125;&#125;</code></pre><p>上述代码中的<code>线程1、线程2</code>都试图去获取对方的资源，进入<code>互相等待</code>的状态，也就会产生<code>死锁</code>。</p><h4 id="避免线程死锁"><a href="#避免线程死锁" class="headerlink" title="避免线程死锁"></a>避免线程死锁</h4><p>死锁产生的条件如上4种，只要破坏任意一个条件就可以解除死锁状态：</p><ul><li>破坏<code>互斥条件</code>：无法达成，锁本身就是互斥的</li><li>破坏<code>请求与保持条件</code>：一次性申请所有资源</li><li>破坏<code>不剥夺条件</code>：占用部分资源的线程进一步申请资源时，如果申请不到，就主动释放资源</li><li>破坏<code>循环等待条件</code>：按序申请资源</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><blockquote><p>当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就表示这个对象是线程安全的。</p></blockquote><p>线程安全有以下几种实现方式：</p><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p><strong>不可变得对象一定是线程安全的。</strong>无论是对象的方法实现还是方法的调用者，都不需要进行任何线程安全保障措施。</p><p>不可变的类型：</p><ul><li><code>final</code>关键字修饰的基本数据类型</li><li><code>String</code>用户调用方法，例如<code>subString()、replace()</code>都不会修改原值</li><li>枚举类型</li><li><code>Number</code>的部分子类，例如<code>Long、Double</code>等数值包装类型</li></ul><p>对于集合类型，可以使用<code>Collections.unmodifiableXX()</code>获取一个不可变集合</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);<span class="hljs-comment">//不可变map</span>        unmodifiableMap.put(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p><code>Collections.unmodifiableXX()</code>本质是 对原始集合进行拷贝，当外部调用修改集合方法时，直接抛出异常<code>UnsupportedOperationException</code>。</p><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p><strong>最常见也是最主要的并发正确保障手段。</strong>保证共享数据在同一时刻只被一条线程使用。</p><p>常用<code>互斥同步</code>手段如下：</p><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p><code>互斥同步</code>面临的主要问题是<strong>线程阻塞和唤醒所带来的性能问题</strong>，所以也被称为<strong>阻塞同步</strong>。</p><blockquote><p>基于冲突检测的乐观并发策略：<code>先进行操作，如果没有其他线程争用共享资源，那就直接操作成功；否则不断重试，知道成功为止。</code></p></blockquote><p>上述的<code>操作</code>和<code>重试检测</code>都依赖于<code>硬件指令集</code>的发展，不需要将线程阻塞。</p><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><a href="/2018/12/18/Atomic原子操作类分析/" title="CAS操作&Atomic原子操作类分析">CAS操作&Atomic原子操作类分析</a><h4 id="无同步"><a href="#无同步" class="headerlink" title="无同步"></a>无同步</h4><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><h3 id="线程池"><a href="#线程池" class="headerlink" title="*线程池"></a>*线程池</h3><h3 id="多线程开发良好实践"><a href="#多线程开发良好实践" class="headerlink" title="多线程开发良好实践"></a>多线程开发良好实践</h3><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关合集整理</title>
    <link href="/2020/05/02/JVM%E7%9B%B8%E5%85%B3%E5%90%88%E9%9B%86%E6%95%B4%E7%90%86/"/>
    <url>/2020/05/02/JVM%E7%9B%B8%E5%85%B3%E5%90%88%E9%9B%86%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本章主要针对JVM基础知识的整理以及拓展</p></blockquote><h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><!--1.8前后有差异，需要列出来--><blockquote><p>JVM在执行Java程序的过程中会把管理的内存分为若干个不同的数据区域。</p><p><strong>JDK1.8前后分区略有不同</strong></p></blockquote><div align="center"><br><img style="margin-right:30px" src="/images/jvm/jvm1.8前.jpg" srcset="/img/loading.gif" width="35%" alt="JDK 1.8之前"><img style="margin-left:30px" src="/images/jvm/jvm1.8.jpg" srcset="/img/loading.gif" width="50%" alt="JDK1.8之后"><br></div><p>根据上述两图，运行时数据区域按照<code>线程是否私有</code>分为两部分：</p><ul><li><code>线程私有</code>：程序计数器、虚拟机栈、本地方法栈</li><li><code>线程共享</code>：堆、方法区</li></ul><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote><p><strong>线程私有</strong>，当前线程所执行的字节码的<code>行号指示器</code>，记录当前线程执行的位置。</p></blockquote><p>程序计数器主要有两个作用：</p><ol><li>字节码解释器通过改变<code>程序计数器</code>来依次读取指令，从而实现代码的流程控制</li><li>在多线程的情况下，<code>程序计数器</code>用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到何处。<ul><li>线程执行Java方法时，计数器记录了<code>当前正在执行的字节码指令地址</code>。</li><li>线程执行Native方法时，计数器值为<code>Undefined</code>。</li></ul></li></ol><p><strong><code>程序计数器</code>是唯一一个不会出现<code>OutOfMemory</code>的内存区域，它的生命周期随着线程的创建而创建，随线程的结束而死亡。</strong></p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote><p><strong>线程私有</strong>，描述<code>Java方法执行的内存模型</code>，每次方法调用的数据都是通过栈传递的。</p></blockquote><p>Java内存可以粗糙的分为<strong>堆内存(Heap)</strong>和<strong>栈内存(Stack)</strong>，栈内存位于虚拟机栈上。</p><p><strong>栈内存</strong>：存储<code>局部变量</code>和<code>方法调用</code></p><p><strong>堆内存</strong>：存储<code>Java中的对象(无论成员变量、局部变量、类变量)</code></p><p><em>如果局部变量是<code>基本数据类型</code>，那局部变量的值存储于栈上；若局部变量是<code>对象</code>，该变量的引用存在于栈上，但是对象存储于堆中。</em></p><blockquote><p>基本数据类型：<code>boolean、byte、char、short、int、float、long、double</code></p></blockquote><p><br></p><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><code>虚拟机栈</code>由一个个<strong>栈帧</strong>组成，<code>栈帧</code>也叫<code>过程活动记录</code>，是用于支持虚拟机调用/执行程序方法的数据结构，记录了每一个方法从调用直至执行完成的过程。<em>栈帧随着方法的调用而创建，执行完成而销毁。</em></p><p><code>栈帧</code>主要由以下四部分组成：</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/栈帧结构.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-异常指令" title="操作指令-异常指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><blockquote><p>用于存储方法参数和定义在方法体的局部变量，包含了编译器可知的各种基本数据类型、对象引用、returnAddress类型。</p></blockquote><p>局部变量表的大小在编译期就已经确定了，对应了字节码中<code>Code属性表中的max_locals</code>。</p><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><blockquote><p>通过入栈、出栈操作来完成一次数据访问，本质是一个<strong>临时数据存储区域</strong>。</p><p>是一个后入先出栈(LIFO)</p></blockquote><p>操作数栈的大小在编译期已经确定，对应字节码中的<code>Code属性表中的max_stacks</code></p><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><blockquote><p>为了支持方法调用过程中的动态连接，调用编译期无法被确定的方法。</p><p><strong>在运行期将符号引用转换为所在内存地址的直接引用。</strong></p></blockquote><p>静态链接：被调用的目标方法在编译期可知且运行期保持不变时，那么这种情况下调用方法的符号引用可以转换为直接引用。</p><h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5><blockquote><p>记录方法被调用的位置，可以在方法执行结束后回到被调用处继续向下执行程序。</p></blockquote><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ul><li><strong>正常退出</strong>：方法中的代码正常执行完成，或者遇到任意一个方法返回的字节码指令(<code>return</code>)并退出，将返回值传递给上层的方法调用者，没有抛出任何异常。</li><li><strong>异常退出</strong>：执行方法过程中出现异常，并且没有处理该异常，导致方法退出。</li></ul><p>一般方法退出正常值为<code>调用者的PC计数器数值</code>。</p><p><br></p><p>在<code>虚拟机栈</code>会出现两种异常情况：</p><ul><li><code>StackOverflowError</code>：请求栈深度超出虚拟机栈说允许的深度时抛出</li><li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote><p><strong>线程私有</strong>，虚拟机执行Native方法的服务，和<code>虚拟机栈</code>功能类似。</p></blockquote><p>在<code>本地方法栈</code>会出现两种异常情况：</p><ul><li><code>StackOverflowError</code>：请求栈深度超出虚拟机栈说允许的深度时抛出</li><li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li></ul><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><strong>Java堆</strong></h3><blockquote><p><strong>线程共享</strong></p><p>JVM所管理内存中的最大一块，该区域唯一目的是<strong>存放对象实例</strong>，几乎所有对象实例都在这里分配内存。</p><p>因此他也是垃圾收集管理的主要区域，因此也被称作<code>GC堆</code>。</p></blockquote><p>由于现在基本都采用分代垃圾回收算法，按照对象存储时间的不同，还可以细分为<code>新生代(分为Eden和Survivor，大致比例为8:1:1)</code>和<code>老年代</code>。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/Java堆结构.jpg" srcset="/img/loading.gif" class="full-image" alt="Java堆结构" title="Java堆结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>在<code>Java堆</code>中会出现以下异常情况：</p><ul><li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li></ul><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>JVM堆内存溢出后，其他线程是否继续正常工作？</p><p>发生OOM之后会不会影响其他线程正常工作需要具体的场景分析。一般情况下，发生OOM的现场都会被终结，然后该线程持有的对象占用就会被GC，释放内存。</p><h3 id="方法区-版本区别较大"><a href="#方法区-版本区别较大" class="headerlink" title="方法区(版本区别较大)"></a>方法区(版本区别较大)</h3><blockquote><p><strong>线程共享</strong></p><p>用于存储<code>已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据</code>。</p><p><code>方法区</code>还有一个别名叫做<code>Non-Heap</code>，可以与上述的<code>Java堆</code>进行区分。</p></blockquote><h4 id="JDK-1-8前"><a href="#JDK-1-8前" class="headerlink" title="JDK 1.8前"></a>JDK 1.8前</h4><p>那时<code>方法区</code>也被称为<code>永久代</code>，GC在该区域是比较少出现的，但是不代表不进行GC操作。常见的异常为<code>java.lang.OutOfMemoryError:PermGen space</code>表示了<code>永久代异常信息</code>。</p><h4 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h4><p>这时<code>永久代</code>已被移除，代替它的是<code>元空间(meta space)</code>，<code>元空间</code>位于<code>直接内存</code>中，因此<code>元空间</code>的最大占用就是系统的内存空间，用户可通过<code>-XX:MetaspaceSize</code>设置<code>元空间</code>最大占用，避免占用过量内存。</p><h4 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h4><ul><li>由于<code>永久代</code>内存经常会溢出，导致OOM发生，因此JVM开发者希望这块内存可以被更灵活的管理，减少OOM错误的出现。</li><li><code>永久代</code>会为GC带来不必要的复杂度，并且回收效率偏低。</li><li><code>永久代</code>的大小难以确定，太小容易造成<code>方法区</code>发生OOM</li></ul><p>在<code>方法区</code>会出现两种异常情况：</p><ul><li><code>StackOverflowError</code>：请求栈深度超出虚拟机栈说允许的深度时抛出</li><li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li></ul><h4 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h4><p>如何使方法区发生OOM?</p><p>借助<code>CGLib</code>这类字节码技术，不断动态生成新类，新方法。或者使用不同的ClassLoader去加载同一个类(<code>不同的ClassLoader加载的同一个类也是不同的</code>)</p><ul><li><p>JDK1.8之前</p><p>可以通过配置<code>-XX:Maxpermsize</code>设置一个较小的值</p></li><li><p>JDK1.8</p><p>上述方法由于移除了<code>永久代</code>无法生效，可以通过配置<code>-XX:MetaspaceSize</code>一个较小的值，也可以模拟这个异常。</p></li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><!--String.intern()来举例--><blockquote><p>Java中常量池的概念主要有三个：</p><ul><li><code>字符串常量池</code></li><li><code>Class文件常量池</code></li><li><code>运行时常量池</code></li></ul><p>其中<code>Class文件常量池</code>存在于class文件中，不受JDK版本影响。</p><p><code>字符串常量池</code>在JDK1.6前位于<code>方法区</code>中，之后的版本存在于<code>Java堆</code>上</p><p><code>运行时常量池</code>在JDk1.7前位于<code>方法区</code>中，之后的版本存在于<code>元空间</code>上</p></blockquote><h4 id="Class文件常量池-Class-Constant-Pool"><a href="#Class文件常量池-Class-Constant-Pool" class="headerlink" title="Class文件常量池(Class Constant Pool)"></a>Class文件常量池(<code>Class Constant Pool</code>)</h4><blockquote><p>class文件除了包含<code>类的版本、字段、方法、接口等描述信息</code>外，还有一项信息就是<code>Class文件常量池</code>，用于存放编译器生成的<code>各种字面量和符号引用</code>。</p></blockquote><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><blockquote><p>接近Java语言层面的常量</p></blockquote><ul><li><p>文本字符串</p><pre><code class="hljs java">public String s = "abc";//其中abc为字面量对应字节码常量池数据为#31 = Utf8               abc</code></pre></li><li><p>8种基本类型的值</p><pre><code class="hljs java">public int value = 1;对应字节码常量池数据为#7 = Utf8               value#8 = Utf8               I</code></pre><p>常量池只保留了字段描述符(I)和字段名称(value)，字面量不存在于常量池中。</p></li><li><p>用<code>final</code>修饰的成员变量，包括<code>静态变量、实例变量，局部变量</code></p><pre><code class="hljs java">public final static int f = 2;//其中2为字面量对应字节码常量池数据为#11 = Integer               2</code></pre></li></ul><h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><blockquote><p>用一组符号描述所引用的目标，符号可以是任何形式的字面量。</p></blockquote><ul><li><p>类和接口的全限定名</p><pre><code class="hljs java">public String s = "abc";对应字节码常量池数据为#5 = Class              #10            // java/lang/String#10 = Utf8              Ljava/lang/String;</code></pre><p>其中<code>String</code>对应全限定名为<code>java/lang/String</code>存储于常量池中</p><p><strong>主要用于在运行时解析得到类的直接引用</strong></p></li></ul><ul><li><p>字段的名称和描述符</p><p>字段：类或接口中声明的变量，包括类级别变量和实例级的变量</p><pre><code class="hljs java">public int value = 1;对应字节码常量池数据为#4 = Fieldref           #5.#32         // JavaBasicKnowledge/JavaBean.value:I #5 = Class              #33            // JavaBasicKnowledge/JavaBean #32 = NameAndType       #7:#8          // value:I #7 = Utf8               value #8 = Utf8               I</code></pre><p><em>对于方法中的局部变量名，class常量池中仅仅保存字段名</em></p><pre><code class="hljs java">public void XX(int v)&#123;   int temp = 3;&#125;对应字节码常量池数据为 #23 = Utf8               v #24 = Utf8               temp</code></pre></li></ul><ul><li><p>方法的名称和描述符</p><p>保存的是<code>方法名、参数类型+返回值</code></p><pre><code class="hljs java">public void XX(int v)&#123;...&#125;对应字节码常量池数据为  #21 = Utf8               XX  //方法名  #22 = Utf8               (I)V //参数类型+返回值</code></pre></li></ul><h4 id="字符串常量池-String-Constant-Pool"><a href="#字符串常量池-String-Constant-Pool" class="headerlink" title="字符串常量池(String Constant Pool)"></a>字符串常量池(<code>String Constant Pool</code>)</h4><blockquote><p>在JDK1.7及之后版本中，<code>字符串常量池</code>被移动到<code>Java堆</code>中(可能是因为方法区的内存空间太小)。</p><ul><li><p>JDK1.7之前</p><p><code>字符串常量池</code>的位置在<code>方法区</code>，此时存储的是<strong>字符串对象</strong>。</p></li><li><p>JDK1.7及之后</p><p>字符串常量池中的内容是在类加载完成，经过<code>验证、准备</code>阶段之后在<code>Java堆</code>中生成字符串对象实例，然后将该对象实例引用值存在<code>字符串常量池</code>中。<strong>字符串常量池中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间进行存放的。</strong></p></li></ul></blockquote><p>在HotSpot VM里实现的<code>String Pool</code>对应一个<code>StringTable</code>类，实际是一个Hash表，默认值大小长度为<code>1009</code>(如果放入过多，导致Hash冲突使链表变长，导致查询性能大幅下降)。该<code>StringTable</code>在每个VM的实例只有一份，被所有的类共享。</p><p>在JDK1.7版本中，<code>StringTable</code>长度可以通过配置参数指定——<code>-XX:StringTableSize=${num}</code>指定长度。</p><h5 id="创建字符串对象"><a href="#创建字符串对象" class="headerlink" title="创建字符串对象"></a>创建字符串对象</h5><pre><code class="hljs java"><span class="hljs-comment">// 编译期就已经确定该字面量，会直接进入class文件常量池中，在字符串常量池中会保存一个引用</span>String s0 = <span class="hljs-string">"Hello"</span>;<span class="hljs-comment">// 调用了String的构造函数，创建的字符串对象是在堆内存上</span>String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Hello"</span>);</code></pre><h5 id="字面量何时进入常量池"><a href="#字面量何时进入常量池" class="headerlink" title="字面量何时进入常量池"></a>字面量何时进入常量池</h5><ol><li>加载类的时候，那些字面量会进入到当前类的<code>运行时常量池</code>，不会进入全局的<code>字符串常量池</code>中</li><li>当字面量赋值的时候，会翻译成字节码中的<code>ldc</code>指令，将常量从常量池中推送至栈顶。</li></ol><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><blockquote><p>在JDK1.7及之后的版本已将<code>运行时常量池</code>从<code>方法区</code>移了出来，在<code>Java堆</code>中开辟一块区域存放运行时常量池。</p><p>为了<strong>存储class文件常量池中的符号信息</strong>，在<code>解析</code>的时候会去查询<code>字符串常量池</code>，以保证运行时常量池所引用的字符串与<code>字符串常量池</code>中是一致的。</p></blockquote><p>JVM在执行某个类的时候，必须经过<strong>加载、链接(验证，准备，解析)、初始化</strong>过程。</p><p>当类执行<code>加载</code>过程后，JVM将<code>class常量池</code>中的内容存放到<code>运行时常量池</code>中，已知<code>class文件常量池</code>中存储的内容是<code>字面量与符号引用</code>。</p><p><code>准备</code>阶段在<code>Java堆</code>中生成字符串的实例对象，将生成的实例对象引用放置于<code>字符串常量池</code>。</p><p><code>解析</code>阶段将<code>class文件常量池</code>中的<code>符号引用</code>翻译成<code>直接引用</code>也是存储于<code>运行时常量池</code>中。</p><h5 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h5><p>Java规范并不要求常量只在运行时才能产生，也就是表示<em>运行时常量池的内容不一定都来自于class文件常量池</em>，在运行时可以通过代码生成常量放置于<code>运行时常量池</code>中，例如<code>String.intern()</code></p><h5 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h5><blockquote><ul><li><p>JDK 1.7之前</p><p><code>intern</code>的处理是：<strong>先判断字符串是否存在于<code>字符串常量池</code>中，如果存在直接返回该常量；如果没有找到，则将字符串常量加入到<code>字符串常量池</code>中。</strong></p></li><li><p>JDK 1.7及之后</p><p><code>intern</code>的处理是：先判断字符串是否存在于<code>字符串常量池</code>中，如果存在直接返回该常量；如果没找到，表示该字符串常量在堆中，然后把<code>Java堆</code>该对象的引用加入到<code>字符串常量池</code>中，以后别人拿到的就是该字符串常量的引用，实际字符串存在于堆中。</p></li></ul></blockquote><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><blockquote><p>直接内存并不是JVM的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，可能导致OOM的出现。</p></blockquote><p>在JDK1.4新加入了<code>NIO</code>类，引入一种基于<code>通道(Channel)</code>和<code>缓冲区(Buffer)</code>的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存在<code>Java堆</code>的对象作为这块内存的应用进行操作。</p><h2 id="Java对象创建过程以及访问方式"><a href="#Java对象创建过程以及访问方式" class="headerlink" title="Java对象创建过程以及访问方式"></a>Java对象创建过程以及访问方式</h2><h3 id="Java对象创建过程"><a href="#Java对象创建过程" class="headerlink" title="Java对象创建过程"></a>Java对象创建过程</h3><p>在Java语言层面上，创建对象只需要调用<code>new</code>关键字。</p><p>在JVM中，实际需要执行以下几步：</p><h4 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h4><p>遇到一条<code>new</code>指令时，先检查指令对应的参数是否在<code>常量池</code>中可以定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，需要执行相应的<code>类加载过程</code>。</p><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p><code>类加载检查</code>通过后，JVM将为新生对象<code>分配内存</code>，对象所需大小在类加载完成后便可以确定。</p><p>这块内存由<code>Java堆</code>划分出来。内存的分配方式由<strong>Java堆中内存是否规整</strong>决定，而<code>内存是否规整</code>由<strong>采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><ul><li><p><strong>指针碰撞</strong></p><blockquote><p><code>Java堆内存规整</code>，把指针向空闲空间挪动对象大小的距离</p></blockquote><p>对应GC收集器：Serial、ParNew</p><p><strong>关键看GC收集器采用了<code>标记-整理、标记-压缩、复制</code>算法进行回收</strong></p></li><li><p><strong>空闲列表</strong></p><blockquote><p><code>Java堆内存不规整</code>，虚拟机维护一个列表记录内存块中的可用区域，在分配内存的时候，找到一块儿足够大的空间划分给对象实例</p></blockquote><p>对应GC收集器：CMS</p><p><strong>关键看GC收集器采用了<code>标记-清除</code>算法进行回收</strong></p></li></ul><h5 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h5><p>创建对象是一个很频繁的事情，就会涉及一个很重要的问题——<strong>线程安全</strong>。作为虚拟机来讲，必须要保证线程安全，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><p><strong>CAS+失败重试</strong></p><blockquote><p>CAS是乐观锁的一种实现方式</p><p>乐观锁：假设没有冲突而去完成某项操作，若发生冲突就重试直到成功为止。</p></blockquote><p>采用这种方式可以保证更新操作的原子性。</p></li><li><p><strong>TLAB</strong>(本地线程分配缓存)</p><blockquote><p>每个线程预先在<code>Java堆</code>中分配一块内存，JVM在给对象分配内存时，首先在<code>TLAB</code>分配。如果分配的对象大于<code>TLAB</code>的剩余内存或<code>TLAB</code>内存已用尽时，再采用上述CAS方式进行内存分配。</p></blockquote></li></ul><h4 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h4><p><strong>内存分配完成时，虚拟机需要将分配到的内存空间初始化为零值(不包括对象头)。</strong>这一步操作可以保证对象的实例字段在代码中可以不赋值就直接使用，程序也可以访问到这些字段的数据类型所对应的零值。</p><h4 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h4><p><code>初始化零值</code>完成后，<strong>虚拟机要对对象进行必要的设置</strong>。将<code>类的元数据信息、对象的哈希码、对象的GC分代年龄</code>等信息，存放到<code>对象头</code>中。另外根据虚拟机运行状态的不同，如是否启用偏向锁等，对象头都会进行存储。</p><p>可以在<code>对象内存布局</code>这节看到对象头相关内容。</p><h4 id="执行-lt-init-gt-方法"><a href="#执行-lt-init-gt-方法" class="headerlink" title="执行&lt;init&gt;方法"></a>执行<code>&lt;init&gt;</code>方法</h4><p>从虚拟机角度来说，一个新的对象已经产生了。从代码角度来说，对象才刚开始创建，在执行<code>&lt;init&gt;</code>方法之前，所有的字段都还为零。一般执行完<code>new</code>指令后会接着执行<code>&lt;init&gt;</code>方法，把对象按照意愿进行初始化，这时就产生了一个真正可用的对象。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Jvm对象创建过程.png" srcset="/img/loading.gif" class="full-image" alt="Jvm对象创建过程" title="Jvm对象创建过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>对象内存布局分为以下三块区域：</p><h4 id="对象头-Header"><a href="#对象头-Header" class="headerlink" title="对象头(Header)"></a>对象头(Header)</h4><p>必须先了解 HotSpot虚拟机的对象(<strong>对象头部分</strong>)的内存布局：分为两部分</p><h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5><p>存储自身的运行时数据，如：<code>HashCode、GC分代年龄和锁信息</code>，这部分数据的长度在32和64位中的JVM中分别为32bit和64bit。<strong>它是实现轻量级锁和偏向锁的关键。</strong></p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/MarkWord.png" srcset="/img/loading.gif" class="full-image" alt="Mark Word" title="Mark Word"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h5 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h5><p>存储指向方法区对象类型数据的指针，如果是数组对象的话，额外会存储数据的长度。JVM通过这个指针来确定该对象是哪个类的实例。</p><h4 id="实例数据-Instance-Data"><a href="#实例数据-Instance-Data" class="headerlink" title="实例数据(Instance Data)"></a>实例数据(Instance Data)</h4><p>对象真正存储的有效信息，即在代码里面所定义的各种类型的字段内容。</p><h4 id="对齐填充-Padding"><a href="#对齐填充-Padding" class="headerlink" title="对齐填充(Padding)"></a>对齐填充(Padding)</h4><p>并非必然存在的，也没有特别的含义，仅仅起着<strong>占位符</strong>的作用。</p><h3 id="Java对象访问方式"><a href="#Java对象访问方式" class="headerlink" title="Java对象访问方式"></a>Java对象访问方式</h3><p>Java程序通过栈上的refrence数据来操作堆上的具体对象。</p><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><code>Java堆</code>可能会划分一块内存作为句柄池，refrence存储的就是<code>对象的句柄地址</code>，句柄中包含了对象的实例数据与类型数据的各自具体地址信息。</p> <span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/get_object_by_handle.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><strong>refrence中存储的稳定句柄地址，在对象被移动时(例如GC时)只会改变句柄中的实例数据指针，refrence本身不需要修改。</strong></p><h4 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h4><p><code>Java堆</code>中对象的内存布局就必须考虑如何设置访问类型数据的相关信息，refrence直接存储的就是<code>对象地址</code>。</p> <span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/get_object_direct.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><strong>最大好处就是速度快，节省了一次指针定位的时间开销。</strong>在HotSpot虚拟机中很常用。</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><blockquote><p>JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为虚拟机的类加载机制。</p></blockquote><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载、验证、准备、解析、初始化、使用、卸载</strong>七个阶段，其中<code>准备、解析、初始化</code>称为<strong>连接</strong>。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/class_lifecycle.png" srcset="/img/loading.gif" class="full-image" alt="类的生命周期" title="类的生命周期"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><blockquote><p>由JVM自带的类加载器(<code>BootstrapClassLoader根加载器、ExtensionClassLoader拓展加载器、ApplicationClassLoader应用加载器</code>)所加载的类，在虚拟机的生命周期中，都不会被卸载。</p><p><strong>只有由用户自定义的类加载器所加载的类是可以被卸载的。</strong></p></blockquote><p>类卸载的触发条件：</p><ul><li>该类所有的实例都已被GC，在JVM中不存在任何该类的实例</li><li>加载该类的ClassLoader也被GC</li><li>该类的Class对象没有被任何地方调用，反射也无法访问该类</li></ul><p>执行类卸载后，在方法区的二进制数据会被卸载。</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><blockquote><p>类加载过程包括上述的五步：<code>加载、验证、准备、解析、初始化</code>。</p></blockquote><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><blockquote><p>JVM找到class文件问生成字节流，然后根据字节流创建java.lang.class对象的过程。</p></blockquote><p>JVM在此过程需要完成三件事：</p><ul><li>通过一个类的 <code>全限定名(包名+类名)</code>来查找.class文件，并生成二进制字节流(<strong>使用ClassLoader进行加载</strong>)。其中字节码来源不一定是.class文件，也可以是jar包、zip包，甚至是来源于网络的字节流。</li><li>将字节流所代表的静态存储结构转化为JVM的特定的数据结构，并存储在<code>方法区</code></li><li>在内存中创建一个<code>java.lang.Class</code>类型的对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>一个非数组类的加载阶段(加载阶段获取二进制字节流的动作)是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式(重写类加载器的<code>findClass()</code>或<code>loadClass()</code>)。</p><p>对于数组类而言，数组类本身不通过类加载器创建，由JVM直接在内存中动态创建。</p><h5 id="加载时机"><a href="#加载时机" class="headerlink" title="加载时机"></a>加载时机</h5><p>一个项目经过编译之后，往往会产生大量.class文件，程序运行时，JVM不会一次性将这些文件全部加载到内存中，而是有一定的加载时机去进行加载操作。</p><h6 id="隐式装载"><a href="#隐式装载" class="headerlink" title="隐式装载"></a>隐式装载</h6><p>在程序运行过程中，当碰到通过<code>new</code>生成对象时，系统会隐式调用ClassLoader装载对应class到内存中(<code>loadClass()</code>)</p><pre><code class="hljs jaba">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</code></pre><h6 id="显示装载"><a href="#显示装载" class="headerlink" title="显示装载"></a>显示装载</h6><p>在编写源代码时，主动调用<code>Class.forName()</code>也会进行class装载操作。执行时会默认调用静态代码块<code>static{...}</code>以及分配静态变量存储空间</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String name, <span class="hljs-comment">/*要加载的Class名字*/</span> <span class="hljs-keyword">boolean</span> initialize,<span class="hljs-comment">/*默认为true,是否需要初始化-调用静态代码快及静态变量初始化*/</span>                               ClassLoader loader<span class="hljs-comment">/*指定ClassLoader进行加载*/</span>)</code></pre><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote><p>确保.class文件的字节流中包含的信息符合虚拟机规范的全部要求，并且不会危及虚拟机本身的安全。</p></blockquote><p>若代码被反复验证和使用过，可以通过配置<code>-XVerify:none</code>关闭大部分的验证措施，缩短加载时间</p><p>主要包含以下四个方面的验证：</p><h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><blockquote><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p></blockquote><p>这一阶段可能包含以下验证点：</p><ul><li>是否以魔数<code>0xCAFEBABE</code>开头</li><li>主次Java版本号是否在当前JVM接受范围内</li><li>…</li></ul><h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><blockquote><p>对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java语言规范的要求</p></blockquote><p>这一阶段可能包含以下验证点：</p><ul><li>这个类是否有父类(除了 java.lang.Object外，都应该有父类)</li><li>这个类是否继承了不允许被继承的类(被final修饰的类)</li><li>…</li></ul><h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><blockquote><p>通过数据流分析和控制流分析，确定程序语义是合法、符合逻辑的</p></blockquote><p>这一阶段可能包含以下验证点：</p><ul><li>任意时刻操作数栈的数据类型与指令代码序列都配合工作</li><li>任何跳转指令都不会跳到方法体以外的的字节码指令中</li><li>…</li></ul><h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><blockquote><p>发生于JVM将<code>符号引用</code>转换<code>直接引用</code>的时候。</p><p>对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验。通俗来说就是，该类是否缺少或者被禁止访问她依赖的某些外部类、方法、字段等资源。</p></blockquote><p>这一阶段可能包含以下验证点：</p><ul><li>符号引中通过字符串描述的全限定名能否找到对应的类</li><li>在指定类是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li><li>…</li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><blockquote><p>正式为类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置为变量初始值(<code>零值</code>)的阶段，不包括实例变量。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">100</span>;</code></pre><p>在准备阶段，JVM会为value分配内存，并将其设置为0。真正的100需要在初始化阶段进行设置。</p><table><thead><tr><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>Int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>reference</td><td>Null</td></tr></tbody></table><p>以上是通常情况下初始值是<code>零值</code>，还是会存在一些特殊情况——静态常量。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">100</span>;</code></pre><p>此时value的初始值就为100。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote><p>把常量池中的符号引用转换为直接引用，也就是具体的内存地址。JVM会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。</p></blockquote><h5 id="符号引用-1"><a href="#符号引用-1" class="headerlink" title="符号引用"></a>符号引用</h5><p>以一组符号描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。</p><h5 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h5><p>直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。<strong>对象真正的内存地址</strong></p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote><p>类加载的最后一个步骤，直到这一步，JVM才真正开始执行类中编写的Java代码。</p><p><strong>执行类构造器<clinit>()的过程，并真正初始化类变量(前面准备过程的零值在此时被赋予真正的值)</clinit></strong></p></blockquote><h5 id="初始化执行时机"><a href="#初始化执行时机" class="headerlink" title="初始化执行时机"></a>初始化执行时机</h5><p>JVM规范严格规定类class初始化的时机，主要有以下几种情况：</p><ul><li><p>虚拟机启动时，初始化包含<code>main()</code>的主类</p></li><li><p>遇到<code>new(创建对象实例)、getstatic(读取类静态字段)、putstatic(设置类静态字段)、invokestatic(调用类的静态方法)</code>这四条字节码指令时，如果目标对象没有经过初始化，需要执行初始化操作</p></li><li><p>当需要对类进行反射调用时，如果类型没有进行初始化，需要执行初始化操作</p></li><li><p>当初始化子类的时候，发现父类还没有进行初始化，需要执行父类的初始化操作</p></li><li><p>在第一次调用<code>java.lang.invoke.MethodHandle</code>实例时，需要初始化MethodHandle指向方法所在的类。<em>JDK7之后</em></p></li><li><p>当一个接口中定义了JDK8新加入的默认方法(<code>default</code>关键字修饰)，如果实现了这个接口的类进行初始化，那么接口需要执行初始化操作</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DefaultInterface</span> </span>&#123;    <span class="hljs-comment">//默认接口方法</span>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        System.err.println(<span class="hljs-string">"Default Interface Method"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;&#125;</code></pre></li></ul><p>以上6种情况在JVM中被称为<strong>主动引用</strong>，除此之外的其他应用方式都被称为<strong>被动引用</strong>，不会出发Class的初始化操作。</p><p>例如以下几种情况：</p><ul><li><p>通过子类调用父类的静态变量，不会导致子类初始化</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">1</span>;  <span class="hljs-keyword">static</span> &#123;    System.out.println(<span class="hljs-string">"Parent"</span>);  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;  <span class="hljs-keyword">static</span> &#123;    System.out.println(<span class="hljs-string">"Child"</span>);  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    Child.value = <span class="hljs-number">2</span>;  &#125;&#125;日志输出java NonInitTestParent</code></pre><p>只有直接定义这个字段的类才会被初始化，所以子类不会进行初始化。</p></li><li><p>静态常量引用时，不会触发定义常量类的初始化</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstClass</span></span>&#123;  <span class="hljs-keyword">static</span> &#123;    System.out.println(<span class="hljs-string">"Const"</span>);  &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String value =<span class="hljs-string">"Value"</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    System.out.println(ConstClass.value);  &#125;&#125;日志输出Value</code></pre><p>常量实际在编译阶段直接存储在Test类的常量池中，已于ConstClass无关，所以不会导致初始化。</p></li></ul><h5 id="Class初始化和对象的创建顺序"><a href="#Class初始化和对象的创建顺序" class="headerlink" title="Class初始化和对象的创建顺序"></a>Class初始化和对象的创建顺序</h5><p>在代码中使用<code>new</code>创建对象实例时，类中<code>静态代码块、非静态代码块、构造函数</code>之间的执行顺序是如何的？</p><pre><code class="hljs java">Parent.java <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String value = <span class="hljs-string">"Parent"</span>;    <span class="hljs-keyword">static</span> &#123;        System.err.println(<span class="hljs-string">"Parent Static Block"</span>);    &#125;    &#123;        System.err.println(<span class="hljs-string">"Parent non-static Block"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Parent</span><span class="hljs-params">()</span></span>&#123;        System.err.println(<span class="hljs-string">"Parent Constructor"</span>);    &#125;&#125;Child.java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;    <span class="hljs-keyword">static</span> &#123;        System.err.println(<span class="hljs-string">"Child Static Block"</span>);    &#125;    &#123;        System.err.println(<span class="hljs-string">"Child Non-Static Block"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Child</span><span class="hljs-params">()</span></span>&#123;        System.err.println(<span class="hljs-string">"Child Constructor"</span>);    &#125;&#125;Test.java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Parent p =<span class="hljs-keyword">new</span> Child();        System.err.println(<span class="hljs-string">"~~~~~~~~~~"</span>);        p = <span class="hljs-keyword">new</span> Child();    &#125;&#125;</code></pre><p>输出内容为</p><pre><code class="hljs java">Parent Static BlockChild Static BlockParent non-<span class="hljs-keyword">static</span> BlockParent ConstructorChild Non-Static BlockChild Constructor~~~~~~~~~~Parent non-<span class="hljs-keyword">static</span> BlockParent ConstructorChild Non-Static BlockChild Constructor</code></pre><p>按照上述输出内容，可以总结初始化顺序为：</p><pre><code class="hljs java"><span class="hljs-number">1</span>.父类静态变量和静态代码块<span class="hljs-number">2</span>.子类静态变量和静态代码块<span class="hljs-number">3</span>.父类普通成员变量和普通代码块<span class="hljs-number">4</span>.父类的构造函数<span class="hljs-number">5</span>.子类普通成员变量和普通代码块<span class="hljs-number">6</span>.子类的构造函数</code></pre><p>基础规则：<strong>静态变量/静态代码块 -&gt; 普通变量/普通代码块 -&gt; 构造函数</strong>。</p><p>特殊情况</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        staticFun();    &#125;    <span class="hljs-comment">//特殊之处</span>    <span class="hljs-keyword">static</span> StaticTest st = <span class="hljs-keyword">new</span> StaticTest();    <span class="hljs-keyword">static</span> &#123;        System.err.println(<span class="hljs-string">"1"</span>);    &#125;    &#123;        System.err.println(<span class="hljs-string">"2"</span>);    &#125;    StaticTest() &#123;        System.err.println(<span class="hljs-string">"3"</span>);        System.err.println(<span class="hljs-string">"a"</span> + a + <span class="hljs-string">" b"</span> + b);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticFun</span><span class="hljs-params">()</span> </span>&#123;        System.err.println(<span class="hljs-string">"4"</span>);    &#125;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">100</span>;&#125;</code></pre><p>TODO：需要好好分析流程。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><!--包括Android加载器--><p>在Java程序启动的时候，并不会一次性加载程序中所有的.class文件，而是在程序运行的过程中，动态加载相应的类到内存中。</p><p><strong>同一个类使用不同的类加载器，得到的类也是不一样的。</strong></p><h4 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h4><ul><li><p>启动类加载器(BootstrapClassLoader)</p><p>由C/C++语言编写的，本身属于虚拟机的一部分，无法在Java代码获取他的引用。可以以<code>null</code>代表引导类加载器。</p><p>负责加载存放在&lt;JAVA_HOME&gt;\lib目录，或者被-Xbootclasspath参数所指定路径的类库</p></li></ul><ul><li><p>拓展类加载器(ExtensionClassLoader)/PlatformClassLoader(JDK9后改名)</p><p>由Java语言编写，可以直接在程序中使用</p><p>负责加载&lt;JAVA_HOME&gt;\lib\ext目录中，或者被java.ext.dirs所指定的路径中的所有类库</p></li></ul><ul><li><p>应用程序/系统类加载器(ApplicationClassLoader)</p><p>负责加载用户类路径(<code>java.class.path</code>)上所有的类库，我们自己编写的代码以及使用的第三方jar通常由他进行加载。</p><p><strong>若没有自定义类加载器，默认由他进行类加载。</strong></p></li></ul><ul><li><p>自定义类加载器(CustomClassLoader)</p><p>上述三种加载器只能加载特定目录下的class文件，如果需要加载特殊位置下的jar包或类时(磁盘上的class)，就需要继承<code>java.lang.ClassLoader</code>去实现功能。</p><p>自定义ClassLoader步骤如下：</p><ol><li>自定义一个类继承<code>ClassLoader</code></li><li>重写<code>findClass()</code></li><li>在<code>findClass()</code>中，调用<code>defineClass()</code>将字节码转换成Class对象并返回</li></ol><p>伪代码如下：</p><pre><code class="hljs java">Class CustomClassLoader extends ClassLoader&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function">Class <span class="hljs-title">findClass</span><span class="hljs-params">(String name)</span></span>&#123;    <span class="hljs-comment">//获得字节码</span>    <span class="hljs-keyword">byte</span>[] code = loadClassData(name);    <span class="hljs-comment">//根据字节码获得Class对象</span>    <span class="hljs-keyword">return</span> defineClass(name,code);  &#125;    <span class="hljs-comment">//这里是获得Class的字节码数组</span>  <span class="hljs-keyword">byte</span>[] loadClassData(String name)&#123;      &#125;&#125;</code></pre></li></ul><h4 id="双亲委托模型"><a href="#双亲委托模型" class="headerlink" title="双亲委托模型"></a>双亲委托模型</h4><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/parent_loader.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="双亲委托模型"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>当类加载器收到类加载请求时，通常都是先委托给父类加载器进行加载，因此所有的类加载请求最终都会传送到最顶层的<code>启动类加载器</code>中，只有当父加载器无法完成这个加载请求时，子加载器才会去进行类加载过程。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent; <span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)        <span class="hljs-keyword">throws</span> ClassNotFoundException    &#123;        <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;            <span class="hljs-comment">// 首先，检查请求的类是否已经被加载过</span>            Class&lt;?&gt; c = findLoadedClass(name);            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">long</span> t0 = System.nanoTime();                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//父加载器不为空，调用父加载器loadClass()方法处理</span>                        c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span>                        c = findBootstrapClassOrNull(name);                    &#125;                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                   <span class="hljs-comment">//抛出异常说明父类加载器无法完成加载请求</span>                &#125;                <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">long</span> t1 = System.nanoTime();                    <span class="hljs-comment">//自己尝试加载</span>                    c = findClass(name);                &#125;            &#125;            <span class="hljs-keyword">if</span> (resolve) &#123;                resolveClass(c);            &#125;            <span class="hljs-keyword">return</span> c;        &#125;    &#125;</code></pre><p>按照源码分析，双亲委托模型总共4步：</p><ol><li>判断class是否被加载，已加载直接返回class</li><li>class未被加载且<code>parent(父加载器)</code>不为空，父加载器进行加载class</li><li><code>parent(父加载器)</code>为空，直接调用<code>BootstrapClassLoader</code>加载class</li><li>如果<code>parent</code>或<code>Bootstrap</code>都未加载成功，则调用当前classLoader继续尝试加载class</li></ol><h5 id="双亲委托模型好处"><a href="#双亲委托模型好处" class="headerlink" title="双亲委托模型好处"></a>双亲委托模型好处</h5><ul><li><strong>避免类的重复加载</strong>，若class已被加载直接从缓存读取</li><li><strong>保证类加载的安全</strong>，避免核心API被篡改，无论哪一个类加载去加载核心类(例<code>java.lang.Object</code>)，最终都会由<code>BootstrapClassLoader</code>进行加载。</li></ul><h5 id="破坏模型"><a href="#破坏模型" class="headerlink" title="破坏模型"></a>破坏模型</h5><blockquote><p><code>双亲委托机制</code>只是Java推荐的机制，并不是强制的机制，可以通过一些手段破坏该模型</p></blockquote><p>可以通过继承<code>java.lang.ClassLoader</code>实现自己的类加载器</p><ul><li>保持<code>双亲委托模型</code>，只要重写<code>findClass()</code></li><li>破坏<code>双亲委托模型</code>，需要重写<code>loadClass()</code></li></ul><h4 id="Android类加载器"><a href="#Android类加载器" class="headerlink" title="Android类加载器"></a>Android类加载器</h4><!--dex2oat dexopt过程--><blockquote><p>本质上，Android和传统的JVM是一样，也要通过<code>ClassLoader</code>加载目标类到内存，但是加载细节略有差别。</p><p>基本运行方式：<code>传入dex文件，然后进行优化，保存优化后的dex文件(odex)到optimizedDirectory目录</code></p></blockquote><p>Android无法直接运行<code>.class文件</code>，会将所有的<code>.class文件</code>转换<code>.dex</code>文件，Android通过自定义的<code>BaseDexClassLoader</code>加载<code>dex文件</code>，也会通过继承<code>BaseDexClassLoader</code>实现特定功能的子类。</p><h5 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a>BaseDexClassLoader</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseDexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseDexClassLoader</span><span class="hljs-params">(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Stub!"</span>);    &#125;    ...&#125;</code></pre><ul><li><p>dexPath</p><p>包含目标类或资源的<code>apk,dex,jar文件的路径，也可以是SD卡的路径</code>，存在多个路径时使用<code>;</code>分割</p></li><li><p>optimizedDirectory</p><p>优化后dex文件(<code>odex</code>)存在的目录，可以为null，<em>Android8.0之后，该参数被废弃</em></p></li><li><p>librarySearchPath</p><p>存放目标文件使用的native库，存在多个路径使用<code>;</code>分割</p></li><li><p>parent</p><p>父加载器</p></li></ul><h5 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h5><blockquote><p>加载Android系统类和应用程序的类，在<code>Dalvik</code>只能加载已安装的apk的dex文件(<code>/data/app</code>)，在ART没有这个限制。</p><p><strong>支持加载外部的dex/apk文件</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PathClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDexClassLoader</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, ClassLoader parent)</span> </span>&#123;        <span class="hljs-keyword">super</span>((String)<span class="hljs-keyword">null</span>, (File)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, (ClassLoader)<span class="hljs-keyword">null</span>);        ...    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, String libraryPath, ClassLoader parent)</span> </span>&#123;        <span class="hljs-keyword">super</span>((String)<span class="hljs-keyword">null</span>, (File)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, (ClassLoader)<span class="hljs-keyword">null</span>);        ...    &#125;&#125;</code></pre><p><code>PathClassLoader</code>传入的<code>optimizedDictory</code>为空，表示只能加载系统默认位置(<code>/data/dalvik-cache/</code>)的<code>odex</code>文件。</p><h5 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h5><blockquote><p><strong>支持加载外部的dex/apk文件</strong>，但是可以配置<code>optimizedDirectory</code>指定<code>odex</code>存放位置。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDexClassLoader</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DexClassLoader</span><span class="hljs-params">(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)</span> </span>&#123;        <span class="hljs-keyword">super</span>((String)<span class="hljs-keyword">null</span>, (File)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, (ClassLoader)<span class="hljs-keyword">null</span>);      ...    &#125;&#125;</code></pre><p>可以支持<code>BaseDexClassLoader</code>配置的所有参数。</p><h3 id="Android类加载过程"><a href="#Android类加载过程" class="headerlink" title="Android类加载过程"></a>Android类加载过程</h3><a href="/2019/12/19/Android-Art类加载过程/" title="Android-Art类加载过程">Android-Art类加载过程</a><h2 id="JVM垃圾回收机制-GC"><a href="#JVM垃圾回收机制-GC" class="headerlink" title="JVM垃圾回收机制(GC)"></a>JVM垃圾回收机制(GC)</h2><blockquote><p>GC：自动管理回收不再引用的内存数据</p><p>JVM内存运行时区域分为5部分，其中<code>程序计数器、虚拟机栈、本地方法栈</code>3个区域<strong>随线程生而生，随线程灭而灭</strong>，是不需要考虑内存回收的问题，内存自然会回收。<code>Java堆和方法区</code>不一样，只有在程序运行期间才知道创建哪些对象，这部分内存的分配和回收是动态的，主要在这两部分触发GC。</p></blockquote><h3 id="对象是否已死-什么是垃圾"><a href="#对象是否已死-什么是垃圾" class="headerlink" title="对象是否已死(什么是垃圾)"></a>对象是否已死(什么是<code>垃圾</code>)</h3><p>堆中几乎存放所有的对象实例，垃圾回收(GC)前的第一步是判断哪些对象已经死亡(不再被任何途径引用的对象)。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><blockquote><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；引用失效，计数器减1；任何时候计数器为0的对象就是不可能在被使用的。</p></blockquote><p><code>引用计数法</code>虽然需要占用额外的内存空间来进行计数，但是<strong>原理简单，效率也高</strong>。</p><p>但是主流的Java虚拟机里面都没有使用该方法，主要原因是<strong>必须配合大量额外处理才能保证正确的工作，例如无法解决对象之间相互循环引用的问题</strong>。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote><p>通过一系列称为<code>GC Roots</code>的根对象作为起始点，从这些节点开始搜索，搜索过程走过的路径称为<strong>引用链</strong>，如果一个对象到<code>GC Roots</code>没有任何引用链相连的话，则证明此对象是不可用的。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_reachability_analysis.png" srcset="/img/loading.gif" class="full-image" alt="可达性分析算法" title="可达性分析算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>可以作为<code>GC Roots</code>的对象类型：</p><ul><li>虚拟机栈中的引用对象(局部变量表)</li><li>方法区中静态属性引用的对象(字符串常量池中的引用)，常量引用的对象</li><li>本地方法栈中JNI所引用的对象</li></ul><h3 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h3><p>一般会在以下两种情况下触发GC</p><ol><li><code>Allocation Failure</code>：如果内存剩余可用空间不足导致对象内存分配失败，系统会触发一次GC</li><li><code>System.gc()</code>：开发者可主动调用该API触发一次GC</li></ol><h3 id="四大引用类型-Java堆"><a href="#四大引用类型-Java堆" class="headerlink" title="四大引用类型(Java堆)"></a>四大引用类型(Java堆)</h3><table><thead><tr><th>引用类型</th><th>GC时机</th><th>用途</th></tr></thead><tbody><tr><td>强引用</td><td>不会被回收</td><td>对象一般状态</td></tr><tr><td>软引用</td><td>内存不足时(即将OOM时)</td><td>内存敏感的高速缓存</td></tr><tr><td>弱引用</td><td>触发GC时</td><td>对象缓存</td></tr><tr><td>虚引用</td><td></td></tr></tbody></table><h4 id="强引用Strong-Reference"><a href="#强引用Strong-Reference" class="headerlink" title="强引用Strong Reference"></a>强引用<code>Strong Reference</code></h4><blockquote><p>在程序代码间普遍存在的引用赋值。<strong>无论何种情况，只要存在强引用关系，就永远不会被垃圾回收器回收。即使发生OOM。</strong></p><p><strong>强引用也是造成Java内存泄露的原因之一。</strong></p></blockquote><p>对于一个普通的对象，如果没有其他的引用关系，若显式的将对象赋值为null，就可以认为该对象可以被回收。</p><p><em>设置对象为null，不代表对象会被立即回收，具体回收时机需要看垃圾收集策略。</em></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;  Object o1 = <span class="hljs-keyword">new</span> Object();  Object o2 = o1;  o1= <span class="hljs-keyword">null</span>;  System.gc();  System.out.println(o1);  <span class="hljs-comment">//null</span>  System.out.println(o2);  <span class="hljs-comment">//java.lang.Object@XX</span>&#125;</code></pre><h4 id="软引用Soft-Reference"><a href="#软引用Soft-Reference" class="headerlink" title="软引用Soft Reference"></a>软引用<code>Soft Reference</code></h4><blockquote><p>描述一些还有用，但并未必需的对象。对于<code>软引用</code>关联的对象，在系统即将发生<code>OOM</code>之前，会把这些对象进行GC，如果GC完毕还没有充足空间，就抛出OOM异常。</p><p><strong>实现内存敏感的高速缓存。</strong></p><p><em>只有系统内存不足时才会被回收，其他情况下等效强引用。</em></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;   Object o1 = <span class="hljs-keyword">new</span> Object();   SoftReference&lt;Object&gt; s1 = <span class="hljs-keyword">new</span> SoftReference&lt;Object&gt;(o1);   System.out.println(o1);   System.out.println(s1.get());   o1 = <span class="hljs-keyword">null</span>;   System.gc();   System.out.println(o1); <span class="hljs-comment">// null</span>   System.out.println(s1.get()); <span class="hljs-comment">//java.lang.Object@XX</span>&#125;<span class="hljs-comment">//JVM配置`-Xms5m -Xmx5m`</span><span class="hljs-comment">//试图new一个大对象，使内存不足产生OOM，看软引用回收情况</span>...  <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>]；  ...    此时会去试图回收软引用对象。</code></pre><h4 id="弱引用Weak-Reference"><a href="#弱引用Weak-Reference" class="headerlink" title="弱引用Weak Reference"></a>弱引用<code>Weak Reference</code></h4><blockquote><p>弱引用也是描述非必须对象，但强度比<code>软引用</code>更弱一些，被弱引用关联的对象只能生存在下一次GC前。</p><p><strong>无论内存是否足够，弱引用关联的对象都会被回收。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Object o1 = <span class="hljs-keyword">new</span> Object();        WeakReference&lt;Object&gt; w1 = <span class="hljs-keyword">new</span> WeakReference&lt;Object&gt;(o1);        System.out.println(o1);        System.out.println(w1.get());        o1 = <span class="hljs-keyword">null</span>;        System.gc();        System.out.println(o1); <span class="hljs-comment">//null</span>        System.out.println(w1.get()); <span class="hljs-comment">//null</span>    &#125;</code></pre><p><code>WeakHashMap</code>就是<code>弱引用</code>的一个使用实例</p><p>其中<code>key</code>为弱引用类型，当key不在引用时，对应的key/value也会被移除</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    WeakHashMap&lt;String,String&gt; weakHashMap = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();    String key = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"111"</span>);    <span class="hljs-comment">//String key ="111";</span>    String value= <span class="hljs-string">"value"</span>;    weakHashMap.put(key,value);    System.err.println(weakHashMap);<span class="hljs-comment">// &#123;111=value&#125;</span>    key = <span class="hljs-keyword">null</span>;    System.gc();    System.err.println(key); <span class="hljs-comment">//null</span>    System.err.println(weakHashMap); <span class="hljs-comment">//&#123;&#125;</span>&#125;</code></pre><p>当使用<code>String key = “111”</code>时，本质引用的对象已经变成<code>字符串常量池</code>中的对象，这部分的回收无法被GC处理。也导致了<code>weakHashMap</code>对象不为空。</p><h4 id="虚引用Phantom-Reference"><a href="#虚引用Phantom-Reference" class="headerlink" title="虚引用Phantom Reference"></a>虚引用<code>Phantom Reference</code></h4><blockquote><p>最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对生存时间构成影响，也无法通过<code>虚引用</code>来取得一个对象实例。</p><p>主要用于<code>跟踪对象垃圾回收的状态，在这个对象被回收时可以收到一个系统通知或者后续添加进一步的处理。</code></p></blockquote><p><code>虚引用</code>必须与<code>引用队列</code>联合使用，当准备回收一个对象时，发现对象存在<code>虚引用</code>，就会在回收对象之前把<code>虚引用</code>加入关联的<code>引用队列</code>中，可以根据<code>引用队列</code>是否已加入<code>虚引用</code>来判断被引用的对象是否要被回收。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Object o1 = <span class="hljs-keyword">new</span> Object();        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;Object&gt;();        PhantomReference&lt;Object&gt; phantomReference = <span class="hljs-keyword">new</span> PhantomReference&lt;Object&gt;(o1,referenceQueue);        System.out.println(o1); <span class="hljs-comment">//java.lang.Object@xxx</span>        System.out.println(referenceQueue.poll()); <span class="hljs-comment">//null</span>        System.out.println(phantomReference.get()); <span class="hljs-comment">//null</span>        o1 = <span class="hljs-keyword">null</span>;        System.gc();        Thread.sleep(<span class="hljs-number">3000</span>);        System.out.println(o1); <span class="hljs-comment">//null </span>        System.out.println(referenceQueue.poll()); <span class="hljs-comment">//引用队列中 java.lang.PhantomReference@xxx</span>        System.out.println(phantomReference.get());<span class="hljs-comment">//null</span>    &#125;</code></pre><h4 id="引用队列Reference-Queue"><a href="#引用队列Reference-Queue" class="headerlink" title="引用队列Reference Queue"></a>引用队列<code>Reference Queue</code></h4><blockquote><p>配合引用工作的，当GC准备回收一个对象时，如果发现对象被<code>软引用或弱引用或虚引用</code>包装，就会在回收对象前将引用加入到<code>引用队列</code>中。</p><p><strong>如果一个引用(软引用、弱引用、虚引用)存在引用队列中，则表示该引用指向的对象已被回收。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ReferenceQueue&lt;String&gt; referenceQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();    String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"11"</span>);    WeakReference&lt;String&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;String&gt;(s,referenceQueue);    s= <span class="hljs-keyword">null</span>;    System.gc();    System.err.println(s); <span class="hljs-comment">//null</span>    <span class="hljs-comment">//被回收了对象</span>    System.err.println(weakReference.isEnqueued()); <span class="hljs-comment">//true</span>    System.err.println(referenceQueue.poll()); <span class="hljs-comment">//java.lang.ref.WeakReference@5e481248</span>&#125;</code></pre><p><code>ReferenceQueue</code>是一个先进先出的队列。</p><h4 id="引用-Reference"><a href="#引用-Reference" class="headerlink" title="引用 Reference"></a>引用 <code>Reference</code></h4><p>上面的<code>弱引用、软引用、虚引用</code>都是<code>java.lang.ref.Reference</code>的直接子类。</p><p><code>Reference</code>主要存在四种状态</p><ul><li><p>Active</p><p>新创建的实例为<code>Active</code>状态</p></li><li><p>Pending</p><p>当实例等待进入<code>引用队列</code>时，处于<code>Pending</code>状态。未注册<code>引用队列</code>时永远不会处于此状态</p></li><li><p>Enqueued</p><p>当实例进入<code>引用队列</code>时，处于<code>Enqueued</code>状态。未注册<code>引用队列</code>时永远不会处于此状态</p></li><li><p>Inactive</p><p>该引用实例指向的实际对象一定已被回收。引用实例未注册<code>引用队列</code>直接从<code>Active</code>状态进入到<code>Inactive</code>状态。</p></li></ul><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>例如<code>Leakcanary</code>，内部主要原理就是：<code>弱引用+引用队列</code>。</p><p>在一个Activity执行完<code>onDestroy()</code>后，用<code>WeakReference</code>引用<code>Activity</code>，再将引用对象与<code>ReferenceQueue</code>关联。这时再从<code>ReferenceQueue</code>中查看是否存在该弱引用对象</p><p>如果存在，执行一次手动GC，再次移除引用，如果弱引用不存在，则这次执行结束。</p><p>如果不存在，执行一次手动GC，再次查看是否存在弱引用对象，如果不存在则表示已发生内存泄露。</p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><blockquote><p>方法区的GC性价比比较低，方法区的回收条件比较苛刻，比较少用。</p></blockquote><p>方法区的垃圾收集主要回收两部分内容：</p><h4 id="废弃常量"><a href="#废弃常量" class="headerlink" title="废弃常量"></a>废弃常量</h4><p>如果常量池中存在字符串<code>wxy</code>，但是当前没有任何String对象引用该字符串常量。就表示了当前这个常量处于废弃状态，当发生内存回收的时候而且有必要进行方法区回收，就会清理<code>wxy</code>出常量池。</p><h4 id="无用类"><a href="#无用类" class="headerlink" title="无用类"></a>无用类</h4><p>需要同时满足以下三个条件：</p><ul><li>该类所有的实例都已被回收，Java堆中已不存在该类的任何实例</li><li>加载该类的类加载器已被回收，所以必须是<strong>自定义加载器去加载</strong></li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，也无法在任何地方被反射访问。</li></ul><p>GC可以对满足上述三个条件的无用类进行回收，但不是必然会进行回收。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><blockquote><p>最基础的收集算法</p></blockquote><p>算法分为两个阶段：</p><ul><li><p>标记(Mark)</p><p><code>标记所有需要回收的对象</code>。找到内存中所有的GC Root对象，然后找到与上述对象没有关联的对象(<code>需要回收的垃圾</code>)。</p></li><li><p>清除(Sweep)</p><p><code>回收掉所有被标记的对象</code>。</p></li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_mark_sweep.png " srcset="/img/loading.gif" class="full-image" alt="标记-清除算法" title="标记-清除算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>优点：</p><ul><li>实现简单，不需要移动对象</li></ul><p>缺点：</p><ul><li><code>执行效率不稳定</code>。如果存在大部分需要回收的对象，导致标记、清除两个动作执行效率降低。</li><li><code>内存碎片问题</code>。清除过程后会产生大量不连续的内存碎片，导致下次分配大对象时没有连续内存导致再次触发GC。</li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将可用内存分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，将剩下的对象复制到另一块内存上。然后再清理已使用过的另一块内存，完成GC。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_copying.png" srcset="/img/loading.gif" class="full-image" alt="整理算法" title="整理算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>优点：</p><ul><li>按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片</li></ul><p>缺点：</p><ul><li><code>可用内存减少一半</code>。对象存活率较高时会频繁进行复制。</li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><blockquote><p><code>标记-清除算法</code>的升级版</p></blockquote><p>算法分为两个阶段：</p><ul><li><p>标记(Mark)</p><p><code>标记所有需要回收的对象</code>。找到内存中所有的GC Root对象，然后找到与上述对象没有关联的对象(<code>需要回收的垃圾</code>)。</p></li><li><p>整理(Compact)</p><p><code>移动剩余存活对象到内存的某一端</code>。然后直接清理边界外的内存对象。</p></li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_mark_compact.png" srcset="/img/loading.gif" class="full-image" alt="标记-整理算法" title="标记-整理算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>优点：</p><ul><li>避免内存碎片的产生 <em>相比于标记-清除算法</em></li><li>高效利用内存空间 <em>相比于复制算法</em></li></ul><p>缺点：</p><ul><li>移动对象的过程必须全程暂停用户应用程序(<strong>STW-Stop The World</strong>)，降低了效率。</li></ul><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="*分代收集理论"></a>*分代收集理论</h4><blockquote><p>主流JVM使用的垃圾收集算法</p></blockquote><p>根据对象存活的周期不同，把堆内存划分几块，一般分为<strong>新生代</strong>和<strong>老年代</strong>。根据不同年代的特点使用不同的垃圾收集算法。</p><p><strong>对于新创建的对象会在<code>新生代</code>分配内存，此区域的对象生命周期一般较短。如果经过多次回收仍然存活下来，则将他们转移到<code>老年代</code>中。</strong></p><h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><blockquote><p>新生成的对象优先存放<code>新生代</code>，新生代对象朝生夕死，存活率很低，所以回收效率很高。</p><p>新生代经常要进行一些复制操作，所以一般采用<strong>复制算法</strong>进行回收。</p></blockquote><p>新生代继续分为3部分：<code>Eden、From Survivor、To Survivor</code>。这三部分并非均分，而是按照<strong>8:1:1</strong>的比例进行划分。</p><p>新生代GC过程如下：</p><ol><li>绝大多数新创建对象都会先存放在<code>Eden</code>区</li><li>当<code>Eden</code>区满时，会执行一次GC(<strong>Minor GC</strong>)，清除<code>Eden</code>区的垃圾对象，将存活的对象复制到<code>From Survivor</code>区</li><li>当<code>From Survivor</code>区满时，会执行一次<code>Minor GC</code>，将存活的对象复制到<code>To Survivor</code>区。<em>如果存在可以<code>晋升</code>的对象会直接放到<code>老年代</code>中。</em></li><li>将<code>From Survivor</code>与<code>To Survivor</code>区域进行切换。<em>每次切换过程中即GC过后，对象的年龄+1，直到达到<code>晋升年龄阈值(一般为15)</code>之后，对象被放到老年代。——<code>长期存活的对象直接进入老年代</code></em></li></ol><p><code>晋升年龄阈值</code>：该值的大小影响着对象在<code>新生代</code>中的停留时间，可以通过<code>-XX:MaxTenuringThreshold</code>配置数值。</p><h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><blockquote><p>在新生代经历了N次(<code>晋升年龄阈值</code>)回收之后仍然存活的对象，就会放入<code>老年代</code>。</p><p><code>老年代</code>的内存一般比<code>新生代</code>大(大概比例为2:1)，可以存放更多的对象。</p><p><em>如果对象比较大(<code>升入老年代对象大小</code>)，并且新生代无法存放，则这个大对象会被直接分配<code>老年代</code>上。——<code>大对象直接进入老年代</code>。</em></p><p><code>老年代</code>通常使用<code>标记-清除、标记-整理</code>算法进行GC。</p></blockquote><p><code>升入老年代对象大小</code>：如果新生代的对象需要分配一块较大连续内存空间才可以存放，且该大小大于该值，则直接在<code>老年代</code>进行内存分配，可以通过<code>-XX:PretenureSizeThreshold</code>配置数值。</p><p><code>老年代</code>发生的GC称为<code>Major GC</code>，针对<code>老年代</code>的GC操作，通常伴随一次<code>Minor GC</code></p><p>在某些虚拟机中，还有<code>Full GC</code>，针对<code>新生代与老年代</code>的GC，回收整个堆的内存。发生时，会导致长时间停顿。</p><p><br></p><p><code>老年代</code>有时候会引用<code>新生代</code>对象，当执行<code>Minor GC</code>时可能就需要查询<code>老年代</code>的引用情况。导致GC过程低效。</p><p>所以老年代会维护一个<code>Card table</code>，记录老年代所引用的新生代对象信息，在发生<code>Minor GC</code>时，只要检查<code>Card table</code>即可。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_java_heap_memory.png" srcset="/img/loading.gif" class="full-image" alt="Java堆内存" title="Java堆内存"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_collectors.png" srcset="/img/loading.gif" class="full-image" alt="垃圾收集器" title="垃圾收集器"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><blockquote><p><strong>最基本，发展历史最悠久的收集器。</strong></p><p>是一个<code>单线程</code>工作的收集器，只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是进行垃圾回收时，必须停止其他所有工作线程(<code>Stop The World</code>)，直到收集结束。</p></blockquote><p><strong>新生代采用<code>复制算法</code>，老年代采用<code>标记-整理算法</code>。</strong></p><p>优点：</p><ul><li>简单而高效</li><li>没有线程交互的开销，可以获得最高的单线程收集效率</li></ul><p>缺点：</p><ul><li>Stop The World可能时间过长</li></ul><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><blockquote><p>其实就是<code>Serial收集器</code>的多线程版本，不同的就是使用多线程进行垃圾收集</p></blockquote><p><strong>新生代采用<code>复制算法</code>，老年代采用<code>标记-整理算法</code>。</strong></p><p>除了<code>Serial收集器</code>以外，只有它可以和<code>CMS收集器</code>配合工作。</p><p>默认开启的收集线程数与CPU数一致。</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="*CMS收集器"></a>*CMS收集器</h4><blockquote><p>以<code>获取最短回收停顿时间</code>为目标的收集器。</p><p>基于<code>标记-清除</code>算法实现。整体上来说是<code>内存回收线程</code>与<code>用户线程</code>并发执行。</p><p>应用于<code>老年代</code>的垃圾收集器。</p></blockquote><p>运作过程比较复杂，分为以下4步：</p><ol><li><p><code>初始标记</code></p><p>暂停所有其他线程，并记录下与GC Roots关联的对象。<strong>触发Stop-The-World</strong></p></li><li><p><code>并发标记</code></p><p>从GC Roots直接关联对象开始遍历整个对象图的过程(<code>GC Roots Tracing</code>)。这个过程耗时较长但不用停顿用户线程，主要跟踪记录发生引用更新的地方。</p></li><li><p><code>重新标记</code></p><p>为了修正<code>并发标记</code>期间，因用户线程继续运行而导致标记产生变动的对象的标记记录。<strong>触发Stop-The-World</strong></p></li><li><p><code>并发清除</code></p><p>清理删除掉在标记阶段判断的垃圾对象，可以与用户线程一起工作。</p></li></ol><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_collectors_CMS.png" srcset="/img/loading.gif" class="full-image" alt="CMS" title="CMS"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>优点：</p><ul><li>并发收集</li><li>低停顿</li></ul><p>缺点：</p><ul><li>对CPU资源非常敏感</li><li>无法处理<code>浮动垃圾</code></li><li>产生大量内存碎片(由于<code>标记-清除算法</code>的实现)</li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="*G1收集器"></a>*G1收集器</h4><blockquote><p>主要面向服务器的垃圾收集器，以极高概率满足GC、停顿时间要求的同时，还具备高吞吐量性能特征。</p></blockquote><p>具备如下特点：</p><ul><li><p><strong>并行与并发</strong></p><p>使用多个CPU缩短<code>STW</code>时间，还可以通过并发的方式让Java程序继续运行。</p></li><li><p><strong>分代收集</strong></p><p>分代概念在<code>G1收集器</code>中进行了保留，但<code>G1</code>可以直接管理新生代和老年代，然后采用不同的方式去管理。</p></li><li><p><strong>空间整合</strong></p><p>整体基于<code>标记-整理算法</code>，局部(两个Region之间)采用了<code>复制算法</code></p></li><li><p><strong>可预测的停顿</strong></p><p>除了追求低停顿外，还可以建立可预测的时间模型，用户去指定期望停顿时间。</p></li></ul><p>运作过程分为以下4步：</p><ol><li><p><code>初始标记</code></p><p>标记一下与GC Roots直接关联的对象。<strong>需要停顿线程</strong></p></li><li><p><code>并发标记</code></p><p>从GC Roots对象开始对堆中对象进行可达性分析，找出需要回收的对象。</p></li><li><p><code>最终标记</code></p><p>修正<code>并发标记</code>期间因为用户线程继续运行导致标记发生变动的对象。<strong>需要停顿线程</strong></p></li><li><p><code>筛选回收</code></p><p>对各个Region的回收价值和成本进行排序，根据用户指定<code>期望停顿时间</code>制定回收计划。然后把决定回收的那部分Region存活对象复制到空Region中，再清理旧Region空间。</p><p><strong>必须暂停用户线程，因为涉及到对象的移动。</strong></p></li></ol><p><code>Region</code></p><p>Java堆的内存布局被划分为多个大小相等的区域(<code>Region</code>)，虽然保留了分代概念，但<code>新生代</code>与<code>老年代</code>都变成了<code>Region</code>的集合。</p><p><code>G1收集器</code>认为大小超过<code>Region</code>容量一半的对象判定为<code>大对象</code>，存放于<code>Humongous</code>区域。</p><p><code>可停顿的时间模型</code></p><p>在后台维护了一个优先列表，每次根据用户设置的<code>期望停顿时间</code>，优先选择回收价值(<code>回收获得的空间大小以及回收所需时间的经验值</code>)最大的Region。</p><p><code>记忆集(Remembered Set)</code></p><p>每个<code>Region</code>都会存在一个<code>记忆集</code>，里面记录下别的<code>Region</code>指向自己的指针并标记这些指针分别在哪些页卡的范围之内。</p><p>通常约占Heap大小的20%或者更高。</p><h4 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h4><blockquote><p>在JDK 11中加入的低延迟垃圾收集器。</p></blockquote><p>主要新增了两项新技术</p><ul><li><p>着色指针</p><p>将少量额外的信息存储在指针上，在对象的内存发生变化的时候，指针颜色就会发生变化。就能知道当前对象状态</p></li><li><p>读屏障</p><p>由于<code>着色指针</code>的存在，程序访问对象的时候可以轻易知道对象的存储状态，若发现指针变色，则会触发<code>读屏障</code>，会更新指针并重新返回结果，虽然存在一定的耗费但是可以达到与用户线程并发的效果。</p></li></ul><blockquote><p>与标记对象的传统算法相比。ZGC在指针上做标记，并在访问指针时加入<code>读屏障</code>，比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就先把指针更新为有效地址再返回，永远只会有单个对象读取时有概率被减速(需要更新指针地址)，而不会再发生Stop-The-World。</p></blockquote><h2 id="JVM内存分配策略"><a href="#JVM内存分配策略" class="headerlink" title="JVM内存分配策略"></a>JVM内存分配策略</h2><ul><li><p>对象优先在<code>Eden区</code>分配</p><blockquote><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次<code>Minor GC</code>。</p><p>每次GC后，对象依然存在就会进入<code>两块Survivor区内</code>。</p></blockquote></li><li><p>大对象直接进入<code>老年代</code></p><blockquote><p> 大对象：那种很长的字符串或者元素数量很多的数据。<strong>需要连续内存空间的Java对象。</strong></p></blockquote></li><li><p>长期存活的对象直接进入<code>老年代</code></p><blockquote><p>每经过一次<code>Minor GC</code>仍然存活的对象，并且能被<code>Survivor</code>容纳，其对象年龄就会+1，当达到<code>晋升年龄阈值</code>对象就会晋升到<code>老年代</code>。</p><p><code>晋升年龄阈值</code>：默认为15，通过<code>-XX:MaxTenuringThreshold</code>进行配置。</p></blockquote></li><li><p>动态对象年龄判定</p><blockquote><p>为了更好适应不同的内存情况，不一定对象达到年龄阈值才能晋升老年代。</p><p>如果在<code>survivor区</code>相同年龄的对象大小总和超过<code>Survivor</code>空间的一半，所有年龄大于或等于该年龄的对象都可以直接晋升老年代。</p></blockquote></li><li><p>空间分配担保</p><blockquote><p>如果<code>survivor</code>没有足够空间存放在<code>Eden区</code>存活对象，这些对象将通过<code>分配担保机制</code>直接进入老年代。</p></blockquote></li></ul><h2 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h2><h3 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h3><h4 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h4><p>线程是CPU调度的最小单位。</p><p>由于CPU的发展，执行速度越来越快，内存与CPU的执行差距会越来越大，导致数据的交互需要等待较长时间。</p><p>因此，为了提升CPU的使用效率，在CPU中添加了<code>高速缓存(cache)</code>作为内存与CPU之间的缓冲：<em>将运算需要的数据复制到Cache中，让运算能快速进行，当运算完成之后，将运算结果刷回主内存，这样CPU就无需等待内存读写完毕。</em></p><p>由于每个CPU都有自己的<code>cache</code>，当多个CPU共同操作一块主内存时，可能导致各自<code>cache</code>中的数据不一致，发生<strong>缓存一致性</strong>问题。</p><p>为了解决<code>缓存一致性</code>的问题，需要各个处理器访问缓存时遵循一些协议，在读写时要根据协议来进行操作，这类协议有<strong>MESI</strong>、<code>MSI</code>、<code>MOSI</code>等。</p><h4 id="MESI-缓存一致性协议"><a href="#MESI-缓存一致性协议" class="headerlink" title="MESI(缓存一致性协议)"></a>MESI(缓存一致性协议)</h4><blockquote><p> 当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态。<br>因此当其他CPU需要读取这个变量时，发现自己缓存变量的缓存行无效时，就需要从主内存中重新获取变量值。</p></blockquote><p>上面介绍到<em>每个处理器都会去检测自己的缓存变量是否有效？</em>，这个检测机制就是通过<strong>嗅探</strong>来实现的。</p><p><code>嗅探</code>：每个处理器都会去检测<code>主内存</code>上的数据来判断自己的缓存数据是否有效，当CPU发现缓存数据对应的内存地址发生修改时，就意味着缓存数据已经无效，需要做以下几步：</p><ul><li>将当前CPU的缓存行设置无效</li><li>当CPU需要操作该数据时，就需要重新从主内存中读取数据</li><li>读取完毕后更新自己的缓存对象</li></ul><p><code>嗅探</code>需要持续的从主内存检测数据并且通过<code>CAS</code>进行循环获取，导致<strong>占用的总线带宽较高</strong>。这也被称之为<strong>总线风暴</strong>。</p><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>为了使CPU的运算单元能够尽量被充分利用，CPU会对输入的代码进行重排序处理，也就是<code>处理器优化</code>。</p><h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a><code>as-if-serial</code></h4><blockquote><p>不管怎么重排序，都不允许单线程下的程序执行结果发生改变。</p></blockquote><p>编译器、runtime和CPU都必须遵守<code>as-if-serial</code>协议。</p><p>一般重排序分为以下三种：</p><ul><li>编译器优化的重排序</li><li>指令级并行的重排序</li><li>内存系统的重排序</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>描述了Java程序中各种变量(<code>线程共享变量</code>)的访问规则，屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各种平台都能达到一致的内存访问效果。</p><h3 id="主要目的"><a href="#主要目的" class="headerlink" title="主要目的"></a>主要目的</h3><p>定义程序中各种变量的访问规则，关注的是<code>虚拟机中把变量值存储到内存中和从内存中取出变量值这样的底层细节</code>。</p><p>此处的<code>变量</code>指的是<code>实例字段、静态字段和构成诉诸对象的元素</code>，不包括<code>局部变量</code>。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/JVM-JMM.png" srcset="/img/loading.gif" class="full-image" alt="线程-主内存-工作内存的交互关系" title="线程-主内存-工作内存的交互关系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><strong>主内存</strong>：所有的变量都存储于此</p><p><strong>工作内存</strong>：每条线程都存在自己的<code>工作内存</code>，保存了该线程使用<code>变量的主内存副本</code>。线程对变量所有的操作都必须在<code>工作内存</code>中进行，无法直接操作<code>主内存</code>数据。不同线程之间也不能互相访问<code>工作内存</code>中的变量，线程间传值都需要通过<code>主内存</code>中转完成。</p><h3 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3><blockquote><p>JMM模型具有以下特征：<strong>原子性、可见性、有序性</strong>。</p></blockquote><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>对基本数据类型的变量读取和赋值操作都是<code>原子性</code>操作，<strong>这些操作不可被中断，要么执行，要么不执行。</strong></p></blockquote><p>可以通过<code>synchronized</code>和<code>Lock</code>实现<code>原子性</code>，因为两者能够<strong>保证同一时刻只有一个线程访问该代码块</strong>。</p><p><code>原子性</code>操作包括：</p><ul><li>除<code>long</code>和<code>double</code>之外的基本数据类型赋值和读取操作，如果需要保证原子性需要加上<code>volatile</code>关键字修饰</li><li>所有引用<code>refrence</code>的赋值操作</li><li><code>java.util.concurrent.atomic.*</code>包下的操作，例如<code>AtomicInteger</code></li></ul><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote><p>当一个线程修改了共享变量的值，其他线程能够立即得知这个修改，<strong>修改后的值立即更新到主内存中，在其他线程读取时，会重新从主内存获取值</strong>。</p></blockquote><p><code>volatile</code>可以保证<code>可见性</code>，具体参考<a href="#volatile">volatile</a></p><p><code>synchronized</code>和<code>Lock</code>也可以保证<code>可见性</code>，可以保证<strong>同一时刻只有一个线程访问共享资源，并在其释放锁之前将修改变量更新到主内存中</strong>。</p><p><code>final</code>也可以实现<code>可见性</code>，对象一旦初始化完成，其他线程都可以该值。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote><p>如果在本线程内观察，所有的操作都是有序的；——<code>as-if-serial</code></p><p>如果其他线程观察，所有操作都是无序的。——<code>指令重排序</code></p><p><strong>程序代码按照先后顺序执行。</strong></p></blockquote><p><code>volatile</code>可以保证<code>有序性</code>，具体参考<a href="#volatile">volatile</a></p><p><code>synchronized</code>和<code>Lock</code>也可以保证<code>有序性</code>，可以保证<strong>同一时刻只有一个线程能执行同步代码，线程可以顺序执行代码</strong>。</p><h3 id="Happens-Before-先行发生-原则"><a href="#Happens-Before-先行发生-原则" class="headerlink" title="Happens-Before(先行发生)原则"></a>Happens-Before(先行发生)原则</h3><p>JMM天生具有一定的<code>有序性</code>，不需要任何手段保证有序性，通常这个称为<strong>happens-before(先行发生)原则</strong>。</p><blockquote><p>用于描述两个操作的内存可见性，通过保证可见性的机制可以让应用程序免于数据竞争干扰。</p><p><strong>如果一个操作的执行结果需要另一操作可见，那么这俩操作必须存在Happen-before关系。</strong></p></blockquote><p>主要有以下几条规则：</p><h4 id="程序次序规则"><a href="#程序次序规则" class="headerlink" title="程序次序规则"></a>程序次序规则</h4><p>按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。<em>需要考虑分支、循环等结构。</em></p><h4 id="管程锁定规则"><a href="#管程锁定规则" class="headerlink" title="管程锁定规则"></a>管程锁定规则</h4><p>一个锁的<code>unlock</code>操作先行发生于<code>lock</code>操作</p><h4 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h4><p>对<code>volatile</code>修饰的变量的写操作先行发生于读操作</p><h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><p><code>Thread</code>的<code>start()</code>先行发生于此线程的每一个动作。</p><h4 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h4><p><code>Thread</code>的<code>interrupt()</code>先行发生于线程中断检测代码<code>Thread.interrupted()</code></p><h4 id="线程终止规则"><a href="#线程终止规则" class="headerlink" title="线程终止规则"></a>线程终止规则</h4><p><code>Thread</code>的所有操作都先行发生于此线程的终止检测，例如<code>Thread.join()，Thread.isAlive()</code></p><h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><p>对象的初始化完成先行发生于<code>finalize()</code>执行</p><blockquote><p><code>finalize</code>：垃圾回收器准备释放内存的时候，会先调用<code>finalize()</code>，可以在执行的时候做点工作。</p></blockquote><h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><p>如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><a href="/2020/05/02/Java线程相关合集整理/" title="Java线程相关合集整理">Java线程相关合集整理</a><h2 id="Class文件结构-字节码"><a href="#Class文件结构-字节码" class="headerlink" title="Class文件结构(字节码)"></a>Class文件结构(字节码)</h2><h2 id="DVM-amp-ART-Android虚拟机"><a href="#DVM-amp-ART-Android虚拟机" class="headerlink" title="DVM&amp;ART(Android虚拟机)"></a>DVM&amp;ART(Android虚拟机)</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://cloud.tencent.com/developer/article/1450501" target="_blank" rel="noopener">彻底弄懂Java中的常量池</a></p><p><a href="https://www.cnblogs.com/gxyandwmm/p/9495923.html" target="_blank" rel="noopener">字符串常量池相关问题</a></p><p><a href="https://juejin.im/post/5ec73c99f265da770c0ee3b1#heading-8" target="_blank" rel="noopener">Java四大引用</a></p><p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">Java应用的GC优化</a></p><p><a href="https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw" target="_blank" rel="noopener">ZGC基础概念</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议相关</title>
    <link href="/2020/03/31/TCP-IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3/"/>
    <url>/2020/03/31/TCP-IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h1><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><blockquote><p>由一系列网络协议所组成的一个<strong>网络分层</strong>模型，是Internet的核心协议并被广泛应用于局域网和互联网。</p></blockquote><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><blockquote><p>为什么要分层？</p><ul><li>每层内部的设计可以自由改动，只需要修改替换对应分层即可</li><li>设计变得简单，分层只需要考虑当前的任务，不需要在意其他分层情况</li><li><strong>网络的不稳定性</strong></li></ul></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP分层.png" srcset="/img/loading.gif" class="full-image" alt="TCP分层" title="TCP分层"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层(Application Layer)"></a>应用层(Application Layer)</h4><blockquote><p>向用户提供应用服务时通信的活动</p></blockquote><p>相关协议：</p><ul><li>HTTP协议</li><li>FTP协议-文件传输</li><li>DNS协议-域名解析</li></ul><h4 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层(Transport Layer)"></a>传输层(Transport Layer)</h4><blockquote><p>提供处于网络连接中的两台计算机之间的数据传输</p></blockquote><p>相关协议：</p><ul><li>TCP协议</li><li>UDP协议</li></ul><h4 id="网络层-Internet-Layer"><a href="#网络层-Internet-Layer" class="headerlink" title="网络层(Internet Layer)"></a>网络层(Internet Layer)</h4><blockquote><p>处理网络上流动的数据包，规定如何将数据包传送给对方</p></blockquote><p>相关协议：</p><ul><li>IP协议</li></ul><h4 id="数据链路层-Link-Layer"><a href="#数据链路层-Link-Layer" class="headerlink" title="数据链路层(Link Layer)"></a>数据链路层(Link Layer)</h4><blockquote><p>处理连接网络的硬件部分，例如网卡、光纤等</p></blockquote><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><u>物理层</u></h4><blockquote><p>例如，网线啥的</p></blockquote><h3 id="如何通信传输？"><a href="#如何通信传输？" class="headerlink" title="如何通信传输？"></a>如何通信传输？</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP-IP通信传输.jpg" srcset="/img/loading.gif" class="full-image" alt="TCP/IP通信传输" title="TCP/IP通信传输"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>进行通信时，会按照分层顺序与对方进行通信。<em>发送端数据从应用层向下走，接收端数据向应用层往上走。</em></p><p>如上图所示：</p><ul><li>客户端向服务端发起请求<ul><li>在应用层(HTTP协议)发送请求数据</li><li>传输层(TCP协议)接收到数据，并进行分割打上标记转发给网络层</li><li>网络层(IP协议)，增加做为通信目的地的服务器MAC地址转发给链路层</li><li>链路层驱动硬件进行传输。</li></ul></li><li>服务端接受客户端数据<ul><li>链路层接收到数据</li><li>网络层继续向上转发数据到传输层</li><li>传输层向上转发到应用层</li><li>应用层接收到数据</li><li>一次HTTP请求完成</li></ul></li></ul><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><!--TCP三次握手、四次挥手 Tcp和Udp的区别？TCP的三次握手？两次行不行？为什么？TCP攻击知道吗？如何进行攻击？--><blockquote><p>TCP协议位于传输层，提供可靠的字节流服务</p><p>字节流服务：方便数据的传输，将大块数据分割成<code>报文段</code>的数据包进行管理。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP协议要点.png" srcset="/img/loading.gif" class="full-image" alt="TCP协议要点" title="TCP协议要点"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><table><thead><tr><th>特点</th><th>具体描述</th></tr></thead><tbody><tr><td>面向连接</td><td>使用TCP传输数据前，必须先建立TCP连接；传输完成后在释放连接</td></tr><tr><td>面向字节流</td><td>虽然应用程序和TCP的交互是一次一个数据块，但TCP只把数据看为一连串无结构的字节流。数据以流的形式传输</td></tr><tr><td>全双工通信</td><td>建立TCP连接后，通信双方都能发送数据</td></tr><tr><td>可靠</td><td>TCP首部格式TCP传输的数据：不丢失、无差错、不重复，按序到达</td></tr></tbody></table><h3 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP首部格式结构.png" srcset="/img/loading.gif" class="full-image" alt="TCP首部格式结构" title="TCP首部格式结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP首部格式.jpg" srcset="/img/loading.gif" class="full-image" alt="TCP首部格式结构" title="TCP首部格式结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><p>源端口号</p><p>表示<code>发送端端口号</code>，字段长16位</p></li><li><p>目标端口号</p><p>表示<code>接收端端口号</code>，字段长16位</p></li><li><p><strong>序列号</strong></p><p>指的是<strong>本报文段第一个字节的序列号</strong>，长32位。每发送一次数据，就累加一次该数据的字节流大小。</p><p><strong>序列号不会从0、1开始，而是以一个随机数作为初始值(ISN)，通过SYN包发送给服务端。</strong></p><p>主要作用如下：</p><ul><li>在<code>SYN</code>报文中交换彼此的初始序列号(<code>ISN</code>)</li><li>保证数据报按正确的顺序发送</li></ul><p><strong>ISN</strong>：随机生成的一个初始值，在三次握手过程中双端互相交换。</p><blockquote><p>ISN基本是每4ms加一，溢出则回到0，使猜测ISN过程变得困难。</p><p>以上操作是为了<strong>避免被攻击者预测到，防止攻击者伪造<code>RST</code>控制位，导致连接被强制关闭。</strong></p></blockquote></li><li><p><strong>确认号</strong></p><p>表示<code>告知对方下一个期望接收的序列号</code>，长度为32位。<strong>小于确认号的所有字节已被全部正常接收。</strong></p></li><li><p>首部长度</p><p>表示<code>TCP传输的数据部分应该从TCP包的第几位开始计算</code>，等价于TCP首部的长度。剩下的都为数据长度</p></li><li><p>保留</p><p>该字段是为了以后扩展时使用，长度为4位。</p></li><li><p>控制位/标记位</p><p>用来控制连接的流程</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/控制位结构.jpg" srcset="/img/loading.gif" class="full-image" alt="控制位结构" title="控制位结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li>CWR：控制拥塞窗口</li><li>ECE：值为1时，通知通信对方当前网络有拥塞。</li><li>URG：值为1时，表示包中有需要紧急处理的数据。</li><li><strong>ACK</strong>：确认应答的字段变为有效。<em>TCP规定除了最初建立连接时的SYN包之外该值必须设置为1。</em></li><li><strong>PSH</strong>：若值为1，告知通信对方收到的数据应该直接上传到上层的应用层；若值为0，不需要立即上传而是先进行缓存。</li><li><strong>RST</strong>：值为1，表示TCP连接出现异常必须强制断开连接。</li><li><strong>SYN</strong>：用于建立连接，值为1表示希望建立连接，并进行初始序列号(<code>ISN</code>)的设置</li><li><strong>FIN</strong>：值为1，表示今后不会再有数据发送，希望断开连接。</li></ul></li><li><p>窗口大小<br>长度为16位，用于<code>通知从相同TCP首部的确认号所指位置开始能接收的数据大小</code>。告知对方允许发送的数据量。</p><blockquote><p>实际上该大小是不够用的。因此TCP支持<code>窗口缩放</code>选项，作为窗口缩放比例因子，范围在<code>0~14</code>，可以扩大当前窗口值为2^n。</p></blockquote></li><li><p>校验和</p><p>长度为16位，<strong>防止传输过程中数据包有损坏，如果数据不正确，则等待重传。</strong></p></li><li><p>紧急指针</p><p>长为16位，只有在<code>URG</code>控制位为1时才有效。</p><p>表示<code>本报文段中紧急数据的指针——数据首位到紧急数据指针之间的都是紧急数据。</code></p><p>一般用于<code>暂时中断通信</code></p></li><li><p>可选项</p><p>主要用于<strong>提高TCP的传输性能</strong>。</p></li></ul><table><thead><tr><th>类型</th><th>长度</th><th>意义</th><th>描述</th></tr></thead><tbody><tr><td>2</td><td>4</td><td>Maximum Segment Size(MSS)</td><td>TCP允许从对方接收的最大报文段</td></tr><tr><td>3</td><td>3</td><td>WSOPT-Window Scale</td><td>扩大窗口，可提高吞吐量</td></tr><tr><td>5</td><td>N</td><td>SACK</td><td>选择确认选项<br>可以允许最大四次的方式确认应答，在数据时不时丢失的情况下，避免无用重发并提高重发速度。</td></tr><tr><td>8</td><td>10</td><td>TSOPT-Time Stamp Option</td><td>用于高速通信中对序列号的管理，可以区分新老序列号。</td></tr></tbody></table><p>  <code>TSOPT-Time Stamp Option</code>：记录序列号发送时的内核时间在报文中。</p><blockquote><p>格式：kind(1字节)+length(1字节)+info(8字节)</p><p>按照上表来看，<code>kind</code>为8，<code>length</code>为10，info包含<code>timestamp</code>和<code>timestamp echo</code>。</p></blockquote><p>  可以解决以下两大问题：</p><ol><li><p>计算往返时延(RTT)</p><ul><li>客户端向服务端发送数据时，<code>timestamp</code>存储当前内核时间<code>ta1</code></li><li>服务端回复客户端时，<code>timestamp</code>存放服务端内核时间<code>tb</code></li><li>客户端收到数据时，可以解析得到<code>timestamp</code>为客户端内核时间<code>ta2</code>，在解析<code>timestamp echo</code>得到第一次发送时的内核时间<code>ta1</code>，然后<code>ta2-ta1</code>就是<code>RTT</code>。</li></ul></li><li><p>防止序列号的回绕问题</p><p>在传输不稳定的网络情况下，有可能会在较晚的时间内收到较早时发送的一个数据报，由于记录了<code>timestamp</code>那么可以比较<code>timestamp</code>来判断是否同一个数据报。</p></li></ol><h3 id="TCP连接建立——三次握手"><a href="#TCP连接建立——三次握手" class="headerlink" title="*TCP连接建立——三次握手"></a>*TCP连接建立——三次握手</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP建立连接-三次握手.png" srcset="/img/loading.gif" class="full-image" alt="TCP三次握手过程" title="TCP三次握手过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/TCP三次握手过程.webp" srcset="/img/loading.gif" class="full-image" alt="TCP三次握手过程" title="TCP三次握手过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li>初始时，客户端与服务端都处于<code>CLOSED</code>状态，服务端为了提供服务，主动监听端口，然后进入<code>LISTEN</code>状态</li><li>客户端主动发起连接(发起<code>SYN</code>包)，进入<code>SYN-SENT</code>状态。——<em>第一次握手</em></li><li>服务端收到<code>SYN</code>包后，回复<code>SYN、ACK</code>包，然后服务端进入<code>SYN-RCVD</code>状态——<em>第二次握手</em></li><li>客户端收到服务端发来的<code>SYN、ACK</code>包后，确认服务端通信建立，在回复<code>ACK</code>包，并进入<code>ESTABLISHED</code>状态；服务端接收到<code>ACK</code>之后，也变成了<code>ESTABLISHED</code>状态。——<em>第三次握手</em></li></ul><p><strong>此时，双方进入了正常的数据传输过程。</strong></p><blockquote><ul><li>SYN：sunchronize，该包需要对端的确认</li><li>ACK：acknowldgement</li></ul></blockquote><p><strong>前两次握手过程中不能携带数据，第三次握手时可以携带数据。</strong>若有人在第一次发送的<code>SYN</code>包时注入大量数据，势必导致服务端要耗费更多的资源进行数据处理，降低了服务器的性能。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><h5 id="为什么不能两次握手？"><a href="#为什么不能两次握手？" class="headerlink" title="为什么不能两次握手？"></a>为什么不能两次握手？</h5><p>根本原因：<strong>无法确认客户端的接收能力。</strong></p><p>当客户端发送<code>SYN</code>后想进行第一次握手，但是由于网络原因导致该<code>SYN</code>包滞留而没有发送到服务端。此时触发<strong>超时重传</strong>机制，于是客户端会重新发出<code>SYN</code>包，由于是两次握手，客户端与服务端建好了连接。</p><p>但是过一段时间后，连接已经被关闭，这时上面被滞留的<code>SYN</code>包就可能会发送到服务端，此时服务端继续发送<code>SYN、ACK</code>包与客户端建立了连接。导致了<strong>连接资源的浪费</strong>。</p><h5 id="TCP攻击"><a href="#TCP攻击" class="headerlink" title="TCP攻击"></a>TCP攻击</h5><p>利用TCP的三次握手机制，模拟多个客户端对服务端发起连接请求(发送<code>SYN</code>包)，但是不处理服务端所返回的<code>SYN、ACK</code>包，导致服务端一直处于一种<strong>半连接</strong>状态，大量消耗服务器资源，导致死机。</p><p><em>即使配置了超时重试功能，也会因为数量过大，导致无限等待。</em></p><p>这个就叫做<code>SYN FLOOD攻击</code>，如何去应对上述攻击：</p><ul><li>增加<code>SYN</code>连接数，想办法增加<code>半连接队列</code>的容量</li><li>减少<code>SYN+ACK</code>重试次数，避免堆积大量的<code>超时重发</code>任务</li><li>也可以利用<code>SYN Cookie</code>技术，服务端收到<code>SYN</code>包后不先去分配资源，而是根据<code>SYN</code>包计算出一个<code>SYN Cookie</code>，在第二次握手时回复给客户端进行保存，这样在客户端回复<code>ACK</code>时带上<code>SYN Cookie</code>，服务端验证合法后就可以分配资源。</li></ul><h5 id="半连接-全连接队列"><a href="#半连接-全连接队列" class="headerlink" title="半连接/全连接队列"></a>半连接/全连接队列</h5><p><strong>半连接队列</strong>：客户端发送<code>SYN包</code>到服务端后，服务端会回复<code>ACK、SYN</code>，并且切换状态至<code>SYN-RECV</code>，该连接就会进入<code>半连接队列</code>。</p><p><strong>全连接队列</strong>：客户端接收到服务端的<code>ACK、SYN</code>包后，三次握手即完成。这时，该连接就会加入至<code>全连接队列</code>。</p><h3 id="TCP连接关闭——四次挥手"><a href="#TCP连接关闭——四次挥手" class="headerlink" title="*TCP连接关闭——四次挥手"></a>*TCP连接关闭——四次挥手</h3><p>TCP断开连接——四次挥手</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP断开连接-四次挥手.png" srcset="/img/loading.gif" class="full-image" alt="TCP四次挥手过程" title="TCP四次挥手过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/TCP四次挥手过程.webp" srcset="/img/loading.gif" class="full-image" alt="TCP四次挥手过程" title="TCP四次挥手过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li>初始时，客户端与服务端都处于<code>ESTABLISHED</code>状态并双向传输数据</li><li>客户端准备断开连接，然后发出<code>FIN</code>包并且指定一个<code>seq序列号</code>，发出后客户端进入<code>FIN-WAIT-1</code>状态——<em>第一次挥手</em></li><li>服务端收到<code>FIN</code>包后，回复<code>ACK</code>到客户端，并进入<code>CLOSE-WAIT</code>状态；客户端在收到服务端的<code>ACK</code>包后，也进入<code>FIN-WAIT-2</code>状态，等待服务端的最终释放连接报文(<code>FIN</code>)——<em>第二次挥手</em></li><li>服务端此时也要准备断开连接，发送<code>FIN、ACK</code>包到客户端，表示自己准备断开连接，然后进入<code>LAST-ACK</code>状态——<em>第三次挥手</em></li><li>客户端收到<code>FIN、ACK</code>消息后，会回复<code>ACK</code>包到服务端，并进入<code>TIME-WAIT</code>状态。<strong>出于稳定和安全性考虑，客户端会等待<code>2MSL</code>的时长，然后进入<code>CLOSED</code>状态。</strong>服务端在收到客户端的<code>ACK</code>包后，也进入<code>CLOSED</code>状态。——<em>第四次挥手</em></li></ul><p><strong>此时，双方都进入<code>CLOSED</code>状态，表明正式断开了连接。</strong></p><blockquote><ul><li><p>FIN：连接释放报文段</p></li><li><p>MSL：最长报文段寿命，表示<strong>任何报文段在网络上的最长存活时间，超过这个时间的报文都将被丢弃。</strong></p><p>协议规定<code>MSL</code>为2分钟，常用的多是<code>30s、1min、2min</code></p></li></ul></blockquote><h4 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h4><h5 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h5><p>当关闭连接时，客户端发送<code>FIN</code>报文到服务端，服务端先返回一个<code>ACK</code>报文到客户端，但是不会关闭掉当前的连接，这也导致会出现第三次挥手的情况，必须等到服务端任务处理完毕，才能发送<code>FIN</code>报文到客户端，通知客户端准备关闭。</p><p>如果服务端直接发送<code>FIN、ACK</code>包，如果此时网络出现延迟就会导致客户端触发<code>超时重传</code>一直发送<code>FIN</code>包，浪费连接资源。</p><h5 id="为什么需要等待2MSL时间在关闭？"><a href="#为什么需要等待2MSL时间在关闭？" class="headerlink" title="为什么需要等待2MSL时间在关闭？"></a>为什么需要等待<code>2MSL</code>时间在关闭？</h5><ul><li>首先，客户端如果不等待<code>2MSL</code>而是直接关闭，就会导致服务端后续发送的包无法被接收，并且客户端端口已被其他使用，就会产生无用数据，导致数据包混乱</li><li>用一个<code>MSL</code>保证四次挥手中主动关闭方最后的<code>ACK</code>报文可以到达对方，上面示例表示的就是<code>客户端发出的ACK包可以被服务端接收</code></li><li>另一个<code>MSL</code>可以保证<strong>已失效的连接请求报文段</strong>不会出现在连接中，避免下一个新的连接出现旧的连接请求报文。</li></ul><h3 id="TCP状态机"><a href="#TCP状态机" class="headerlink" title="TCP状态机"></a>TCP状态机</h3><blockquote><p>将连接建立和断开的两个时序状态图结合起来，就是<code>TCP状态机</code>。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP状态机.webp" srcset="/img/loading.gif" class="full-image" alt="TCP状态机" title="TCP状态机"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="TCP快速打开——TCP-Fast-Open"><a href="#TCP快速打开——TCP-Fast-Open" class="headerlink" title="TCP快速打开——TCP Fast Open"></a>TCP快速打开——TCP Fast Open</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP快速打开-TFO.png" srcset="/img/loading.gif" class="full-image" alt="TCP快速打开" title="TCP快速打开"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>TCP快速打开为了优化后续的TCP握手流程，快速建立连接。——TFO</p><p>主要利用的原理就是<strong>SYN Cookie</strong></p></blockquote><p>在第一次建立连接时，服务端会计算得出一个<code>SYN Cookie</code>，然后放置于<code>SYN、ACK</code>数据包中的<code>FAST OPEN</code>选项返回给客户端，客户端收到<code>SYN、ACK</code>数据包时，解析<code>FAST_OPEN</code>选项，缓存其中的Cookie。</p><p>在后续建立连接的过程中，客户端会直接发送<code>SYN包、HTTP请求以及SYN Cookie</code>到服务端，只要服务端验证<code>SYN Cookie</code>通过，就会返回<code>SYN、ACK</code>包以及<code>HTTP请求的响应数据</code>。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP快速打开流程.jpg" srcset="/img/loading.gif" class="full-image" alt="TCP快速打开流程" title="TCP快速打开流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="可靠性保证"><a href="#可靠性保证" class="headerlink" title="*可靠性保证"></a>*可靠性保证</h3><blockquote><p>无论对方以多快的的速度发送数据，接收方总来得及处理收到的数据</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP可靠性保证.png" srcset="/img/loading.gif" class="full-image" alt="TCP可靠性保证" title="TCP可靠性保证"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ul><li><strong>出错重传</strong>：出现错误时，让发送方重新发送数据</li><li><strong>速度匹配</strong>：当接收方来不及处理接收的数据时，通知发送方降低数据传输速率。</li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><blockquote><p>接收方根据自己接收缓存的大小，动态调整发送窗口的大小，从而控制对方的发送速率。</p></blockquote><h5 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h5><blockquote><p><strong>传输层进行流量控制</strong>的一种措施，接收方通过告知发送方自己的窗口大小，从而控制对方的发送速率，达到防止对方数据发送过快导致自己处理不完的问题。</p></blockquote><p>滑动窗口分为以下两部分</p><ul><li><p>发送窗口</p><blockquote><p>任意时刻，发送方维持的一组连续的，允许发送帧的帧序号。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/滑动窗口协议-发送窗口.png" srcset="/img/loading.gif" class="full-image" alt="滑动窗口协议-发送窗口" title="滑动窗口协议-发送窗口"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>其中黑框部分就是<strong>发送窗口</strong>。是由下面的<code>已经发送但没有收到确认帧</code>和<code>未发送但可以发送数据</code>这两部分组成。</p><p><br></p><p><strong>发送窗口</strong>包含以下四大部分：</p><ul><li>已经发送并收到确认帧(<code>Sent and Acknowledged</code>)</li><li><strong>已经发送但没收到确认帧</strong>(<code>Sent but not yet Acknowledged</code>)</li><li><strong>未发送但可以发送(<code>Not sent Recipient Ready to Receive</code>)</strong></li><li>未发送且不能发送(<code>Not send and not ready to receive</code>)</li></ul><p><br></p><p>每收到一个接收方返回的确认帧，发送窗口就向前移动一帧。当<code>发送窗口</code>里都为<code>已经发送但没收到确认帧</code>，那么<code>发送窗口</code>停止发送数据，直到收到接收方发出的确认帧则继续向后移动，直到发送窗口内无数据可以发送。</p></li></ul><ul><li><p>接收窗口</p><blockquote><p>任意时刻，接收方维持的一组连续的，允许接收帧的帧序号。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/滑动窗口协议-接收窗口.png" srcset="/img/loading.gif" class="full-image" alt="滑动窗口协议-接收窗口" title="滑动窗口协议-接收窗口"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>其中黑框部分就是<strong>接收窗口</strong>。是由下面的<code>未接受准备接收数据帧</code>组成。</p><p><strong>接收窗口</strong>包含以下三大部分：</p><ul><li>已接收数据帧</li><li><strong>未接收但准备接收数据帧</strong></li><li>未接收且未准备接收数据帧</li></ul><p><br></p><p>每收到一个发送方发送的数据帧，接收窗口就向前移动一帧，并返回确认帧到发送端。</p><p>若收到的数据帧不在接收窗口内，则丢弃该数据帧。</p></li></ul><h5 id="流量控制过程"><a href="#流量控制过程" class="headerlink" title="流量控制过程"></a>流量控制过程</h5><ul><li>接收端向发送端通知自己可以接收的数据的大小<code>a</code></li><li>发送端就会发送不超过<code>a</code>大小的数据</li><li>后续，接收端缓冲区面临溢出时，又会通知一个更小的窗口值<code>b</code>到发送端</li><li>发送端收到通知后再发送不超过<code>b</code>大小的数据</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/流量控制过程.jpg" srcset="/img/loading.gif" class="full-image" alt="流量控制过程" title="流量控制过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h5 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h5><p>若接收端发给发送端的<code>窗口调整通知</code>中途丢失的话，可能会导致无法继续通信，甚至出现<strong>死锁问题</strong>(由于发送方一直等待接收方的窗口通知，然后接收方一直等到发送方的数据)。</p><p>解决方案：</p><p>TCP为每一个连接设计持续计时器，只要TCP发送方收到<code>零窗口通知</code>，就启动该计时器。若计时器结束，则会发出一个<code>零窗口探测</code>的数据报，等待对方给出<code>窗口大小</code>。为0则重新设置计时器，不为0则打破死锁状态。</p><blockquote><p>死锁的形成条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用</li><li>占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不可强行占有：进程已获得的资源，未使用完之前不能强行剥夺</li><li>循环等待：若干进程形成一种头尾相接的循环等待资源关系。</li></ul></blockquote><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><blockquote><p>防止过多的数据注入到网络中，使得网络中的路由器和链路不至于过载。</p></blockquote><h5 id="拥塞窗口-cwrd"><a href="#拥塞窗口-cwrd" class="headerlink" title="拥塞窗口(cwrd)"></a>拥塞窗口(cwrd)</h5><blockquote><p>指目前自己还能传输的数据量大小</p></blockquote><p><code>接收窗口</code>与<code>拥塞窗口</code>都是接收端上的概念，两者计算后可以得出<code>发送窗口</code>的大小。</p><pre><code class="hljs undefined">发送窗口大小 = min(接收窗口大小，拥塞窗口大小)</code></pre><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><blockquote><p>当主机开始发送数据时，由小到大逐渐增加<strong>拥塞窗口(发送窗口)数值</strong>，从而由小到大逐渐增大发送报文段。</p></blockquote><p>得到的是<strong>慢启动阈值(ssthresh)</strong>，当发送窗口到达这个阈值时，就先暂停一下发送。</p><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><blockquote><p>当发送窗口到达<strong>慢启动阈值</strong>时，使得<code>拥塞窗口</code>大小按规律线性增长。每经过一轮<code>RTT(往返时延)</code>，拥塞窗口大小+1。</p></blockquote><h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>TCP传输的过程中，如果发生了丢包——接收端发现数据端不是按序到达，那么就需要发送端重新发送丢失的数据。</p><p>例如发送了<code>4 5 6 7</code>四个数据报到接收端，但是接收端没有收到<code>5</code>，通常的情况下需要发送端等待一个<code>RTO(超时重传时间)</code>然后重新发送<code>4 5 6 7</code>数据报。</p><blockquote><p> 当发送方至少收到3个重复的ACK时，意识到丢包了，就会立即重新重传对方尚未收到的报文段，而不用等待一个<code>RTO</code>。</p></blockquote><h6 id="选择性重传"><a href="#选择性重传" class="headerlink" title="选择性重传"></a>选择性重传</h6><blockquote><p>当接收端已经收到了部分数据时，回复发送端<code>ACK</code>报文时，可以设置<code>可选项(Option)</code>，加上<code>SACK</code>熟悉，通过<code>left edge</code>、<code>right edge</code>告知发送端已接收的数据范围。</p><p>然后发送端就会发送不在该范围内的数据给接收端，减少数据量。</p></blockquote><h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><blockquote><p>当发送端接收到三次重复ACK之后，就会发现传输过程中出现了数据丢失，就会进入<code>快速恢复</code>阶段。</p></blockquote><ul><li>cwnd大小缩小为当前的一半</li><li><code>ssthresh</code>设置为缩小后的<code>cwnd</code>大小</li><li>cwnd大小线性增加</li></ul><h3 id="提高网络利用率"><a href="#提高网络利用率" class="headerlink" title="提高网络利用率"></a>提高网络利用率</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/TCP提高利用率.png" srcset="/img/loading.gif" class="full-image" alt="TCP提高利用率" title="TCP提高利用率"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><blockquote><p>发送端即使还有应该发送的数据，但如果这部分的数据还很少的话，则进行延迟发送。</p><p><strong>主要为了避免小包的频繁发送。</strong></p></blockquote><p>立即发送条件</p><ul><li>已发送的数据都已经收到确认应答时</li><li>数据包发送的大小达到<code>MSS（最大报文长度）</code>时</li></ul><p>可能的问题</p><p>可能产生某种程度的延迟。可以通过设置<code>TCP_NODELAY</code>关闭该算法。</p><h4 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h4><blockquote><p>接收端收到数据以后并不立即返回确认应答(<code>ACK</code>)，而是等待一定时间内合并多个<code>ACK</code>在回复给发送端。</p></blockquote><p><em>TCP要求这个时延必须小于<strong>500ms</strong>(可能导致发送端重新发送数据)，一般操作系统不会设置超过<strong>200ms</strong></em>。</p><p>立即回复条件</p><ul><li>需要调整发送窗口大小</li><li>TCP处于<code>quickack</code>模式，通过<code>tcp_in_quickack_mode</code>开启</li><li>发现了乱序包</li></ul><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/UDP协议.png" srcset="/img/loading.gif" class="full-image" alt="UDP协议" title="UDP协议"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>UDP协议位于传输层，但不保证可靠性。</p></blockquote><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><table><thead><tr><th>UDP特点</th><th>具体描述</th></tr></thead><tbody><tr><td>无连接</td><td>使用UDP传输数据，不需要建立连接</td></tr><tr><td>不可靠</td><td>UDP的数据包发送后，不管其是否会到达接收方</td></tr><tr><td>面向报文</td><td>数据 以<strong>数据报文(包)</strong>的形式传输</td></tr><tr><td>无拥塞控制</td><td>由于是不可靠传输，不管是否到达接收方，所以不需要拥塞控制</td></tr></tbody></table><h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/http/UDP首部格式.jpg" srcset="/img/loading.gif" class="full-image" alt="UDP首部格式" title="UDP首部格式"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><p>源端口号</p><p>表示<code>发送端端口号</code>，长<code>16位</code>。</p><p>可以不设置该端口号，默认为<code>0</code>，表示单方面发送消息，不需要接受端的返回信息。</p></li><li><p>目标端口号</p><p>表示<code>接收端端口号</code>，长<code>16位</code>。</p></li><li><p>UDP包长度</p><p>保存了<code>UDP首部的长度和数据的长度之和</code>。</p></li><li><p>UDP校验和</p><p>为了提供可靠的<code>UDP首部和数据而设计</code>。检测用户数据报在传输过程中是否有错。</p></li></ul><h3 id="TCP、UDP的区别"><a href="#TCP、UDP的区别" class="headerlink" title="TCP、UDP的区别"></a>TCP、UDP的区别</h3><ul><li><p>TCP是<code>面向连接</code>的，UDP是面向无连接的</p><p><strong>所谓连接，是为了在客户端和服务端之间建立连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。</strong></p></li><li><p>TCP<code>提供可靠交付</code>，通过<code>TCP</code>传输的数据，<strong>不丢失、无差错、不重复，按序到达</strong>。而UDP继承了IP包的特性，不保证不丢失，不保证按序到达。</p></li><li><p>TCP是<code>面向字节流</code>的，把每个数据块看为<code>一串无结构的字节流</code>，方便进行维护；而UDP继承IP包特性，基于<code>数据报</code>的，一个个的向外发或者接收。</p></li><li><p>TCP是有<code>拥塞控制</code>的，意识到丢包或者网络环境不好时，会调整自己的行为，调整发包频率；UDP只要有包就会发送，无论是否到达接收方。</p></li><li><p>TCP是<code>有状态</code>的服务，会记录当前状态，例如包是否发送，该发送哪个；UDP是无状态的，不会记录下来</p></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</li><li>不需要一对一沟通，建立连接，而是可以广播的应用</li><li>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络堵塞，也不能受到影响。</li></ol><p>例如：<code>流媒体的协议(视频播放)</code>、<code>实时游戏</code>、<code>IoT物联网</code>、<code>移动通信领域(语言、视频通话)</code>。</p><h3 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h3><blockquote><p>Google提出的一种基于UDP改进的通信协议，目的是<strong>降低网络通信的延迟，提供更好的用户体验</strong>。该协议位于<code>应用层</code>上。</p></blockquote><ul><li>自定义连接机制</li><li>自定义重传机制</li><li>无阻塞的多路复用</li><li>自定义流量控制</li></ul><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href>图解TCP/IP</a></p><p><a href="https://zh.wikipedia.org/wiki/TCP快速打开" target="_blank" rel="noopener">TCP快速打开</a></p><p><a href="https://cloud.tencent.com/developer/article/1017235" target="_blank" rel="noopener">QUIC 协议原理分析</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP的原理和工作机制</title>
    <link href="/2020/03/29/HTTP%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/03/29/HTTP%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP的原理和工作机制"><a href="#HTTP的原理和工作机制" class="headerlink" title="HTTP的原理和工作机制"></a>HTTP的原理和工作机制</h1><p><img src="/images/http/HTTP大纲.png" srcset="/img/loading.gif" alt="HTTP大纲"></p><h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h2><blockquote><p>HyperText(可以指向其他文本的链接文本) Transfer Protocol——超文本传输协议。位于<code>TCP/IP</code>协议的最顶层——应用层。</p></blockquote><p>从日常角度来说，在App中调用网络请求，直接就会使用到HTTP。发送数据(<code>Request</code>)到服务端，等待服务端数据处理完毕再返回(<code>Response</code>)到App，App在进行后续处理，例如页面展示等。</p><h3 id="HTTP工作机制"><a href="#HTTP工作机制" class="headerlink" title="HTTP工作机制"></a>HTTP工作机制</h3><h4 id="浏览器输入地址后发生了什么？"><a href="#浏览器输入地址后发生了什么？" class="headerlink" title="浏览器输入地址后发生了什么？"></a>浏览器输入地址后发生了什么？</h4><ul><li>浏览器向DNS服务器请求解析该url中的域名对应的IP地址</li><li>解析得到IP地址后，根据IP地址和端口，与服务器建立TCP连接</li><li>浏览器发出读取文件的HTTP请求</li><li>服务器对浏览器请求做出响应，返回html文本到浏览器</li><li>根据Header中的<code>Connection</code>判断是否需要释放TCP连接，若为<code>close</code>则关闭连接；为<code>keep-alive</code>则保持该连接一段时间，可以继续接受服务器数据</li><li>浏览器解析服务端返回的html文本并显示</li></ul><h3 id="HTTP特点与缺点"><a href="#HTTP特点与缺点" class="headerlink" title="HTTP特点与缺点"></a>HTTP特点与缺点</h3><p><img src="/images/HTTP优点和缺点mind.png" srcset="/img/loading.gif" alt="HTTP优点和缺点mind"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>灵活可拓展<ul><li>只规定基本格式，没有语法的限制</li><li>传输形式多样性，支持文本、图片、视频等数据</li></ul></li><li>传输可靠，基于TCP/IP，继承其特性</li><li>无状态，通信过程不会记录上下文信息，每次请求都是独立的，减少了网络开销</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>无状态</p><p>需要长连接的场景中，需要保存信息时，导致传输大量无用的信息，这时就是缺点</p><p>如果只是单纯的获取数据，不需要保存信息时，反而减少了网络开销</p></li><li><p>明文传输</p><p>协议里的报文使用文本形式传递，为调试提供便利但是会把明文信息暴露给外界，导致请求不安全。</p></li><li><p>队头阻塞问题</p><p>当http开启长连接时(<code>Connection:Keep-Alive</code>)，共用同一个TCP连接，同一时刻只能处理同一个请求，当头部请求耗时过长，会导致后续请求堵塞，产生<strong>队头阻塞</strong>问题。</p></li></ul><h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><p><img src="/images/http/HTTP报文结构mind.png" srcset="/img/loading.gif" alt="HTTP报文结构mind"></p><h4 id="请求报文-Request"><a href="#请求报文-Request" class="headerlink" title="请求报文(Request)"></a>请求报文(<code>Request</code>)</h4><p><img src="/images/HTTP_RequestMessage.png" srcset="/img/loading.gif" alt="HTTP_RequestMessage"></p><h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><blockquote><p>声明请求方法、主机域名和协议版本</p></blockquote><p>基本格式： <strong>Method Request-URI HTTP-Version CRLF</strong></p><p>Method：表示请求方法，例如<code>GET、POST...</code></p><p>Request-URI：统一资源标识符，例如<code>https://leo-wxy.github.io/</code></p><p>HTTP-Version：HTTP协议版本，例如<code>HTTP/1.1 HTTP/2.0</code></p><p>CRLF：表示回车和换行，<code>\r\n</code></p><p>示例数据： <code>GET http://leo-wxy.github.io/ HTTP/1.1</code></p><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><blockquote><p>声明客户端的首部信息</p></blockquote><p>参考后面章节的 <code>Headers</code></p><h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5><blockquote><p>存放客户端发送给服务端的数据信息，若为<code>GET</code>请求则没有该结构</p></blockquote><p>参考后面章节的 <code>Body</code></p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><table><thead><tr><th>请求行</th><th><strong>GET /test/index.html HTTP/1.1</strong></th></tr></thead><tbody><tr><td><strong>请求头</strong></td><td>Host : <a href="http://www.github.io" target="_blank" rel="noopener">www.github.io</a></td></tr><tr><td></td><td>User-Agent : Mozilla/5.0</td></tr><tr><td><strong>空行</strong></td><td>(用于隔开请求头和请求体)</td></tr><tr><td><strong>请求体</strong></td><td>id=0&amp;page=1</td></tr></tbody></table><h4 id="响应报文-Response"><a href="#响应报文-Response" class="headerlink" title="响应报文(Response)"></a>响应报文(<code>Response</code>)</h4><p><img src="/images/HTTP_ResponseMessage.png" srcset="/img/loading.gif" alt="HTTP_ResponseMessage"></p><h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><blockquote><p>声明协议版本、状态码和描述(对状态码进行描述)</p></blockquote><p>​    基本格式： <strong>HTTP-Version Status-Code Reason-Parse CRLF</strong></p><p>​    HTTP-Version：HTTP协议版本，例如<code>HTTP/1.1 HTTP/2.0</code></p><p>​    Status-Code：服务器返回的状态码，对应上面的<a href="#响应状态码">响应状态码</a></p><p>​    Reason-Parse：状态码的文本描述，对应上面的<a href="#响应状态码">响应状态码</a></p><p>​    CRLF：表示回车和换行，<code>\r\n</code></p><p>​    示例数据： <code>HTTP/1.1 404 Not Found</code></p><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><blockquote><p>声明客户端、服务端的报头信息</p></blockquote><p>参考后面章节的 <code>Headers</code></p><h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><blockquote><p>存放反给客户端的数据信息</p></blockquote><p>参考后面章节的 <code>Body</code></p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><table><thead><tr><th>状态行</th><th>HTTP/1.1 200 OK</th></tr></thead><tbody><tr><td><strong>响应报头</strong></td><td>Connection : keep-alive</td></tr><tr><td></td><td>Server : Nginx</td></tr><tr><td><strong>空行</strong></td><td>(用于隔开响应头和响应正文)</td></tr><tr><td><strong>响应正文</strong></td><td>{“error”:false,”result”:1}</td></tr></tbody></table><h3 id="HTTP-Request-Methods"><a href="#HTTP-Request-Methods" class="headerlink" title="HTTP Request Methods"></a>HTTP Request Methods</h3><p><img src="/images/HTTP请求方法mind.png" srcset="/img/loading.gif" alt="HTTP请求方法mind.png"></p><blockquote><p>HTTP协议所定义的请求方法</p></blockquote><table><thead><tr><th>请求方法</th><th>作用</th><th>描述</th><th>简化</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td><td>客户端需要从服务器读取资源时使用<br>一般用于获取/查询信息<br>通过URL传递且参数长度是有限制的<br>请求格式 <code>/test/result?key=key&amp;page=1</code><br>请求是安全的，因为只读，不会改变服务器数据</td><td>用于获取资源<br> 不设置Body <br>不会改变服务器数据<br>符合<strong>幂等性</strong></td></tr><tr><td>POST</td><td>传输实体主体</td><td>客户端向服务端提供信息时使用<br>可以附带数据，用于更新服务器数据<br>将请求参数封装在请求数据中，可传输大量数据<br>传参方式更加安全，但是请求是不安全的，会导致服务器数据发生改变</td><td>会改变服务器数据，增加或修改资源<br> 需要设置Body<br>不符合<strong>幂等性</strong></td></tr><tr><td>HEAD</td><td>获取报文首部</td><td>不返回报文实体部分，主要用于确认URL有效性以及资源更新日期</td><td>几乎与<code>GET</code>相同<br>服务器不返回Body<br>可用于下载场景，获取信息</td></tr><tr><td>PUT</td><td>上传文件</td><td>自身不带验证机制，存在安全性问题。<strong>一般不使用</strong></td><td>会改变服务器数据，只能修改资源<br>不设置Body<br>符合<strong>幂等性</strong></td></tr><tr><td>PATCH</td><td>对资源部分进行修改</td><td>可以部分对资源进行修改</td><td></td></tr><tr><td>DELETE</td><td>删除文件</td><td>自身不带验证机制，存在安全性问题。</td><td>会改变服务器数据，删除资源<br>不设置Body<br>符合<strong>幂等性</strong></td></tr><tr><td>OPTIONS</td><td>查询支持的方法</td><td>查询指定的URL可以提供的方法。<br>返回示例：<code>Allow: GET , POST</code></td><td></td></tr><tr><td>CONNECT</td><td>要求与代理服务器通信时建立隧道</td><td>对通信内容进行加密后通过网络隧道传输</td><td></td></tr><tr><td>TRACE</td><td>追踪路径</td><td>将通信路径返回给客户端</td></tr></tbody></table><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><h5 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a><strong>幂等性</strong></h5><blockquote><p>对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。</p></blockquote><p>HTTP请求方法中的<code>GET、PUT、DELETE</code>是满足<code>幂等性</code>的。</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="GET和POST请求有什么区别？"><a href="#GET和POST请求有什么区别？" class="headerlink" title="GET和POST请求有什么区别？"></a>GET和POST请求有什么区别？</h5><ul><li>GET请求会被主动缓存下来，留下历史记录；POST不会缓存</li><li>GET方式提交的数据长度有限制(URL长度限制)，POST请求数据可以非常大</li><li>GET请求只能进行URL编码；POST没有限制</li><li>GET请求都是放在URL中的，安全性不高；POST可以放在请求体中，增强安全性</li><li><strong>(本质区别)GET请求是幂等的；POST不是</strong></li></ul><h3 id="HTTP-Status-Code"><a href="#HTTP-Status-Code" class="headerlink" title="HTTP Status Code"></a>HTTP Status Code</h3><p><img src="/images/HTTP状态码mind.png" srcset="/img/loading.gif" alt="HTTP状态码mind"></p><blockquote><p>位于服务端返回<strong>响应报文</strong>中的第一行，包含了状态码以及原因短语，用来告知客户端请求结果。</p></blockquote><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational(信息性状态码)</td><td>接收请求正在处理</td></tr><tr><td>2XX</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作完成请求</td></tr><tr><td>4XX</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error(服务端错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><h4 id="1XX-信息状态码"><a href="#1XX-信息状态码" class="headerlink" title="1XX 信息状态码"></a>1XX 信息状态码</h4><ul><li>100 Continue：客户端继续发送请求</li><li>101 Switching Protocls：正在切换协议，可以切换HTTP 2.0</li></ul><h4 id="2XX-成功状态码"><a href="#2XX-成功状态码" class="headerlink" title="2XX 成功状态码"></a>2XX 成功状态码</h4><ul><li>200 OK：请求成功</li><li>204 No Content：请求成功，但没有body数据</li><li>206 Partial Content：部分内容，用于分块下载和断点续传，与<code>Content-Range</code>一起使用</li></ul><h4 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a>3XX 重定向状态码</h4><ul><li>301 Moved Permanently：永久性重定向 <em>常见</em></li><li>302 Found：临时性重定向</li><li>304 Not Modified：内容没有改变，与Http缓存有关</li></ul><h4 id="4XX-客户端错误状态码"><a href="#4XX-客户端错误状态码" class="headerlink" title="4XX 客户端错误状态码"></a>4XX 客户端错误状态码</h4><ul><li>400 Bad Request：请求报文存在语法错误</li><li>401 Unauthorized：未认证用户-<code>服务端不知道你是谁</code></li><li>403 Forbiden：请求被拒绝-<code>服务端知道你是谁，但你不配</code></li><li>404 Not Found：找不到对应服务器</li></ul><h4 id="5XX-服务端错误状态码"><a href="#5XX-服务端错误状态码" class="headerlink" title="5XX 服务端错误状态码"></a>5XX 服务端错误状态码</h4><ul><li>500 Internal Server Error：服务器执行请求发生错误</li><li>502 Bad Gateway：返回响应无效</li><li>503 Server Unavliable：服务器无法处理请求</li><li>504 Gateway Time-out：服务器处理请求超时</li></ul><h3 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h3><p><img src="/images/HTTP首部格式mind.png" srcset="/img/loading.gif" alt="HTTP首部格式mind"></p><blockquote><p>HTTP消息的元数据(metadata)，例如消息长度、格式等。</p></blockquote><h4 id="请求报文Header"><a href="#请求报文Header" class="headerlink" title="请求报文Header"></a>请求报文Header</h4><h5 id="Accept：客户端可以接受的MIME类型"><a href="#Accept：客户端可以接受的MIME类型" class="headerlink" title="Accept：客户端可以接受的MIME类型"></a><strong>Accept</strong>：客户端可以接受的MIME类型</h5><blockquote><p>MIME类型：描述消息内容类型的因特网标准，包含文本、图像、音频、视频以及其他应用 程序专用数据，例如PDF之类的</p></blockquote><p><code>文本类型</code>：text/html、text/css</p><p><code>图片文件</code>：image/gif、image/png</p><p><code>视频文件</code>：video/mpeg、video/mp4</p><p><code>应用程序二进制文件</code>：application/json、application/pdf</p><p>如果<code>Accept</code>包含了某类型，表示客户端可以支持该格式数据处理。</p><p>一般MIME类型会和<code>q</code>这个属性一起使用，</p><p>例如<code>Accept:text/html,application/json;q=0.9,image/webp;q=0.8,*/*;q=0.8</code></p><p><code>q</code>表示了<strong>媒体类型增加优先级</strong>，权重高的优先处理。</p><p>例如上述数据表示：</p><table><thead><tr><th>权重</th><th>MIME类型</th></tr></thead><tbody><tr><td>1.0</td><td>text/html</td></tr><tr><td>0.9</td><td>application/json</td></tr><tr><td>0.8</td><td>Image/webp</td></tr></tbody></table><h6 id="Accept-Encoding：支持的压缩方式"><a href="#Accept-Encoding：支持的压缩方式" class="headerlink" title="Accept-Encoding：支持的压缩方式"></a><strong>Accept-Encoding</strong>：支持的压缩方式</h6><blockquote><p>一般都会对传输数据进行编码压缩，设置客户端可接受的压缩方式</p></blockquote><p><code>gzip</code>：由文件压缩gzip程序产生的编码格式 <strong>最常用</strong></p><p><code>deflate</code>：使用zlib结构和deflate算法产生的压缩格式</p><p><code>br</code>：使用Brotil算法的压缩格式</p><p>如果配置了<code>q</code>，也表示相对优先级，例如<code>Accept-Encoding:gzip;q=0.9</code></p><h6 id="Accept-Language：支持的语言"><a href="#Accept-Language：支持的语言" class="headerlink" title="Accept-Language：支持的语言"></a><strong>Accept-Language</strong>：支持的语言</h6><blockquote><p>指定客户端支持的语言</p></blockquote><p>如果配置了<code>q</code>，也表示相对优先级，例如<code>Accept-Language:zh-CN;q=0.9</code></p><h6 id="Accept-Charset：支持的字符集"><a href="#Accept-Charset：支持的字符集" class="headerlink" title="Accept-Charset：支持的字符集"></a><strong>Accept-Charset</strong>：支持的字符集</h6><blockquote><p>指定客户端支持的字符集</p></blockquote><p>如果配置了<code>q</code>，也表示相对优先级，例如<code>Accept-Charset:utf-8;q=0.9</code></p><p><strong>Host</strong>：请求资源所在服务器</p><p><strong>User-Agent</strong>：当前访问服务器的用户信息</p><p><strong>Range</strong>：设置下载数据的范围，可用于断点续传/多线程下载。</p><h4 id="响应报文Header"><a href="#响应报文Header" class="headerlink" title="响应报文Header"></a>响应报文Header</h4><p><strong>Location</strong>：重定向后的目标url</p><p><strong>Accept-Range</strong>：表示当前可以按照<code>bytes</code>来进行资源获取</p><p><strong>Content-Type</strong>：指定请求体(Body)类型/响应体返回数据类型</p><ul><li><code>text/html</code>：返回Html文本</li><li><code>application/json、image/jpeg</code>：返回文本或文件内容，也可用于向服务器传输文件</li><li><code>application/x-www-form-urlencoded</code>：普通表单类型提交，只支持传文本</li><li><code>multitype/form-data</code>：支持提交二进制文件，例如图片啥的</li><li><code>charset=utf-8</code>：表示设置的字符集 对标于<code>Accept-Charset</code></li></ul><p><strong>Content-Encoding</strong>：服务端设置的压缩格式 对标于<code>Accept-Encoding</code></p><p><strong>Content-Language</strong>：服务端设置的语言 对标于<code>Accept-Language</code></p><h4 id="通用Header-请求-响应都可以用"><a href="#通用Header-请求-响应都可以用" class="headerlink" title="通用Header(请求/响应都可以用)"></a>通用Header(请求/响应都可以用)</h4><p><strong>Content-Length</strong>：指定请求体(Body)长度/响应体返回数据长度</p><p><strong>Connection</strong>：允许发送的指令连接选项</p><ul><li><code>keep-alive</code>：保持连接</li><li><code>close</code>：通讯完成后关闭连接</li></ul><p><strong>Cache-Control</strong>：对数据进行缓存，减少从服务器获取数据次数，优化网络性能</p><ul><li><code>no-cache</code>：需要使用到<code>对比缓存</code></li><li><code>no-store</code>：不要缓存数据</li><li><code>max-age:XX</code>：缓存在XX时间后失效</li><li><code>private</code>：客户端可以缓存数据(个人化信息)</li><li><code>public</code>：客户端与中间节点都可以进行缓存(所有人都能使用)</li><li><code>s-maxage</code>：限定缓存在代理服务器中可以存放多久</li></ul><h3 id="HTTP-Cache"><a href="#HTTP-Cache" class="headerlink" title="HTTP Cache"></a>HTTP Cache</h3><p><img src="/images/HTTP缓存mind.png" srcset="/img/loading.gif" alt="HTTP缓存mind"></p><blockquote><p>Web性能优化的重要手段，主要依赖于上节中配置的<code>Header</code>。会去指定缓存的来源 </p></blockquote><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><blockquote><p>在第一次请求数据时，服务端在Header会携带<code>缓存规则信息</code>，只要符合缓存规则，就直接取缓存数据，不会重新发起请求。按照服务端给予的<code>缓存时间</code>比较，不超出则一直使用缓存数据。</p></blockquote><p>通过<code>Cache-Control</code>验证强缓存是否可用，如果设置了<code>max-age=XXX</code>，表示缓存会在<code>XXX</code>后的时间失效，在这期间只要请求资源，都会从缓存中获取数据。</p><p>在HTTP1.0版本使用的是<code>Expires</code>字段，存放的是一个具体的过期时间，但是存在<strong>服务器与客户端时间不同步</strong>问题，导致缓存失效时间无法确定。所以在HTTP1.1是废弃了该字段。</p><h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><blockquote><p>需要按照<code>Header</code>中的配置来判断是否需要读取缓存还是重新从服务器中拉取数据。</p></blockquote><p>按照缓存下来的数据标识，需要每次与服务器进行交互去验证<code>缓存标识</code>是否有效，有效则继续使用缓存数据即可。</p><p>以下则为认证时用到的<code>缓存标识</code>：</p><p><strong>Last-Modified/If-Modified-Since</strong></p><ul><li><code>Last-Modified</code>：服务端返回给客户端，表示资源的最后修改时间</li><li><code>If-Modified-Since</code>：客户端发送服务端，表示服务端返回的上次资源修改时间</li></ul><p>服务端在收到<code>If-Modified-Since</code>之后，与服务端资源进行比较</p><ul><li>若本地时间大于接收的时间，则返回<code>200</code>，需要客户端重新缓存资源</li><li>否则，返回<code>304</code>，表示资源没有发生变化，客户端可以继续使用本地缓存资源</li></ul><p><strong>ETag/If-None-Match</strong></p><ul><li><code>ETag</code>：服务端返回给客户端，表示当前资源在服务器的唯一标识</li><li><code>If-None-Match</code>：客户端发送给服务端，表示服务端说返回的资源唯一标识</li></ul><p>服务端在收到<code>If-None-Match</code>之后，进行服务器资源的唯一标识比对</p><ul><li>标识不一致，返回<code>200</code>，需要客户端重新缓存资源</li><li>否则，返回<code>304</code>，客户端可以继续使用本地缓存资源</li></ul><p><em>强制缓存的优先级是高于对比缓存的。</em></p><p><strong>Etag/If-None-Match</strong>这组标识符的优先级是高于<strong>Last-Modified/If-Modified-Since</strong>，如果存在则优先执行。</p><p><img src="/images/http缓存流程.jpg" srcset="/img/loading.gif" alt="http缓存流程"></p><h4 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h4><blockquote><p>每次客户端缓存失效都需要从源服务器获取的话，会产生较大的压力。所以引入<code>代理缓存</code>机制，由代理服务器进行数据的缓存，但代理服务器缓存过期了才从源服务器请求数据。</p></blockquote><p>缓存代理的控制分为两部分：<strong>源服务端的控制</strong>，<strong>客户端的控制</strong>。</p><h5 id="源服务端的控制"><a href="#源服务端的控制" class="headerlink" title="源服务端的控制"></a>源服务端的控制</h5><p>通过配置<code>Cache-Control</code>属性进行控制</p><p><code>Cache-Control:public</code>：允许代理服务器进行缓存</p><p><code>Cache-Control:private</code>：只允许客户端进行缓存</p><p><code>Cache-Control:s-maxage=XXX</code>：允许缓存服务器最多缓存XXX时间</p><p>与<code>max-age</code>的区别是，<code>max-age</code>管理的是客户端的缓存有效时间。</p><h5 id="客户端的控制"><a href="#客户端的控制" class="headerlink" title="客户端的控制"></a>客户端的控制</h5><p>通过在请求头配置属性进行控制</p><p><code>max-stale:num</code>：表示客户端在代理服务器拿到缓存时，最多允许<code>num</code>的过期时间</p><p><code>min-fresh:num</code>：表示代理缓存在到期<code>num</code>秒之前可以获取</p><p><code>only-if-cached</code>：表示客户端只从代理缓存获取数据，获取缓存无效则返回<code>504</code>超时</p><h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><p><img src="/images/HTTP-Cookiemind.png" srcset="/img/loading.gif" alt="HTTP-Cookiemind"></p><blockquote><p><code>由于HTTP协议是无状态的，不对之前发生的请求和响应进行管理。</code>Cookie就是为了解决这类问题所提供的。可以用于对用户进行认证以及保存部分信息。客户端保存本地后，后续请求就会带上该信息。</p></blockquote><p><code>Cookie</code>会根据从服务端发送的响应报文(<code>Response</code>)内的一个叫做<code>Set-Cookie</code>的<code>Header</code>信息，通知客户端保存Cookie信息。当下次再发起请求时，客户端会自动在请求报文(<code>Request</code>)中加入<code>Cookie</code>值后发送到服务端。</p><p><img src="/images/Cookie交互流程.jpg" srcset="/img/loading.gif" alt="Cookie交互流程"></p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>domain</td><td>String</td><td>指定浏览器发出HTTP请求时，哪些域名需要附加Cookie信息</td></tr><tr><td>expires</td><td>Date</td><td>指定一个具体的Cookie到期时间，值为UTC格式</td></tr><tr><td>httponly</td><td>Boolean</td><td>指定该无法通过JS脚本拿到，主要是<code>Document.cookie</code>获取</td></tr><tr><td>maxAge</td><td>String</td><td>指定从现在开始的Cookie存在秒数，超过则失效</td></tr><tr><td>path</td><td>String</td><td>指定浏览器发出Http请求时，哪些路径要附带这个Cookie信息</td></tr><tr><td>secure</td><td>Boolean</td><td>指定浏览器只有在<code>HTTPS</code>协议下可以发送Cookie到服务器</td></tr><tr><td>signed</td><td>Boolean</td><td>给浏览器发送一个加密的Cookie，服务端可以校验该Cookie是否被篡改</td></tr><tr><td>SameSite</td><td>String</td><td>设置第三方Cookie属性</td></tr></tbody></table><p>按照功能可以将以上7个属性进行分类</p><h5 id="Cookie生命周期-expires-maxAge"><a href="#Cookie生命周期-expires-maxAge" class="headerlink" title="Cookie生命周期-expires,maxAge"></a>Cookie生命周期-<code>expires,maxAge</code></h5><p><code>expires</code>设置的是一个<code>Date</code>格式的时间，<code>maxAge</code>设置的是一个<code>毫秒时间戳</code>。<strong>推荐使用maxAge</strong></p><p>若同时指定了<code>expires</code>和<code>maxAge</code>，那么<code>maxAge</code>属性优先生效。</p><p><em>若不设置任一属性的值，那么该Cookie仅在当前页面生效，关闭就不会再保留。</em></p><h5 id="Cookie作用域-domain-path"><a href="#Cookie作用域-domain-path" class="headerlink" title="Cookie作用域-domain,path"></a>Cookie作用域-<code>domain,path</code></h5><p><code>domain</code>设置哪些域名需要附加Cookie信息，<code>path</code>设置哪些路径需要附加Cookie信息(若<code>path:&#39;/&#39;</code>表示该域名下所有路径都附加Cookie信息)。</p><p><em>若与任一属性值不匹配，那么请求服务端时就不会带上Cookie信息。</em></p><h5 id="Cookie安全性-secure-httponly-SameSite"><a href="#Cookie安全性-secure-httponly-SameSite" class="headerlink" title="Cookie安全性-secure,httponly,SameSite"></a>Cookie安全性-<code>secure,httponly,SameSite</code></h5><p><code>secure</code>设置只有在<code>HTTPS协议</code>下可以传输Cookie；<code>httponly</code>设置Cookie只能通过HTTP协议进行传输，其他方式都无法获取Cookie信息。</p><p><code>SameSite</code>主要为了预防<code>CSRF攻击</code>，可以设置为3个值：</p><ul><li>None：显式关闭SameSite属性，但是必须设置<code>secure:true</code>，否则设置无效</li><li>Lax：只能在<code>GET</code>请求下使用，请求时会携带Cookie，否则不会有信息</li><li>Strict：浏览器完全禁止第三方请求携带Cookie信息，只能在同一域名下生效。</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>状态记录</strong>：记录当前状态，例如用户登录，操作记录</li><li><strong>用户偏好</strong>：记录用户的个性化设置</li><li><strong>行为分析</strong>：分析用户的行为，可以了解用户喜好</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>容量缺陷</strong>：Cookie保存的诗句不能超过4K，而且浏览器会设置保存Cookie的上限</li><li><strong>性能缺陷</strong>：Cookie默认跟随域名一起发起请求，无论需要与否，导致性能浪费。<em>可以通过设置<code>domain</code>和<code>path</code>减少使用。</em></li><li><strong>安全权限</strong>：Cookie以纯文本形式进行传递，很容易被非法截获，然后进行篡改后再发给服务端，降低安全性。</li></ul><h4 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h4><ul><li><p><strong>XSS(跨站脚本攻击)</strong>：被JavaScript获取用户Cookie，然后发送到其他网站，就会导致Cookie泄漏，危害数据安全。</p><p>解决方案：在Cookie信息中添加<code>HttpOnly</code>属性，就保证当前Cookie只会用于网络请求，而不会被获取。</p></li><li><p><strong>CSRF(跨站请求伪造)</strong>：随机访问可能存有Cookie的网址，然后越权操作用户数据。</p><p>解决方案：</p><ul><li><p>同源检测</p><ul><li><p>使用<code>Origin Header</code>确定来源域名</p></li><li><p>使用<code>Referer Header</code>确定来源域名</p></li></ul></li><li>CSRF Token</li><li>SameSite Cookie属性</li></ul></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><blockquote><p>是以安全为目标的HTTP通信，在HTTP下加入了SSL/TLS协议，用于保障HTTP的加密传输。</p><p><code>TLS(传输层安全性协议)</code>：前身为<code>SSL(安全套接层)</code>，目的是为互联网通信提供安全及数据完整性保障。</p><p>使用<code>SSL</code>后，HTTPS就具有<strong>加密、认证，完整性保护</strong>功能</p></blockquote><h3 id="HTTPS加密"><a href="#HTTPS加密" class="headerlink" title="HTTPS加密"></a>HTTPS加密</h3><p><img src="/images/HTTPSmind.png" srcset="/img/loading.gif" alt="HTTPS"></p><h4 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h4><blockquote><p>采用单钥密码系统的加密方法，同一个密钥可以用作信息的加密和解密。</p><p>也可叫<code>单密钥加密</code>。</p></blockquote><h5 id="常用加密算法"><a href="#常用加密算法" class="headerlink" title="常用加密算法"></a>常用加密算法</h5><p>DES、AES</p><p><img src="/images/对称密钥加解密过程.png" srcset="/img/loading.gif" alt="对称密钥加解密过程"></p><h4 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h4><blockquote><p>需要两个密钥来进行加密和解密，这两个密钥分别是<strong>公钥(public key)</strong>和<strong>私钥(private key)</strong>。</p><p>公钥所有人都可以获得，通信方得到公钥后，就可以对发送内容进行加密，然后传递至服务端，服务端就可以利用私钥进行解密。</p><p>私钥还可以对服务端返回内容进行签名，利用公钥去验证签名是否正确，防止被人篡改。</p></blockquote><h5 id="常用加密算法-1"><a href="#常用加密算法-1" class="headerlink" title="常用加密算法"></a>常用加密算法</h5><p>RSA，ECC</p><p><img src="/images/非对称密钥加解密过程.png" srcset="/img/loading.gif" alt="非对称密钥加解密过程"></p><h4 id="混合加密-HTTPS采用方案"><a href="#混合加密-HTTPS采用方案" class="headerlink" title="混合加密(HTTPS采用方案)"></a>混合加密(HTTPS采用方案)</h4><p>采用了<code>对称加密与非对称加密</code>混合加密的形式，只用<code>对称加密</code>，会有安全隐患；只用<code>非对称加密</code>，性能消耗太大。所以需要结合两者，保证性能的同时又保证安全。</p><ul><li>客户端向服务器发送<code>client_random</code>和加密方法列表(例如RSA方法)</li><li>服务端收到后，返回<code>server_random</code>、加密方法(RSA)以及<code>非对称加密公钥</code>到客户端</li><li>客户端收到后，再生成一个<code>pre_random</code>，使用<code>非对称加密公钥</code>加密后发送给服务器</li><li>服务端使用<code>非对称加密私钥</code>解密后，得到的就是<code>对称加密用到的密钥</code></li><li>双方持有<code>对称加密用到的密钥</code>后，后续数据通信就用<code>对称加密</code>的方式进行。</li></ul><p>本质就是为了<strong>防止私钥加密的数据外传。</strong></p><h4 id="数字证书-解决身份伪装问题"><a href="#数字证书-解决身份伪装问题" class="headerlink" title="数字证书(解决身份伪装问题)"></a>数字证书(解决身份伪装问题)</h4><blockquote><p>为了向服务器证明自己的身份，可以解决身份伪装问题。</p></blockquote><p>上面两种加密方式的结合，可以实现加密传输。但是还会存在一些问题，若发生了DNS劫持，那么传输过程中的所有内容都有可能造假，不能保证安全性。</p><p>数字证书的使用流程大概如下：</p><ol><li>服务器首先向一个大家都信任的第三方机构(<code>CA</code>)获取授权，获取通过后获取<strong>数字证书</strong>。</li><li>客户端向服务器建立通信之前向服务器请求获得服务器的证书</li><li>服务器收到请求之后发送<strong>数字证书</strong>给客户端</li><li>客户端获得证书之后，向第三方机构进行验证，验证通过后进行正常的内容通信。</li></ol><p>数字证书有两个作用：</p><ul><li>服务器向客户端证明自己的身份</li><li>把<code>非对称加密公钥</code>传给客户端</li></ul><h5 id="CA机构"><a href="#CA机构" class="headerlink" title="CA机构"></a>CA机构</h5><p>证书颁发机构。是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p><h4 id="数字签名-解决数据篡改问题"><a href="#数字签名-解决数据篡改问题" class="headerlink" title="数字签名(解决数据篡改问题)"></a>数字签名(解决数据篡改问题)</h4><blockquote><p>功能类似写在纸上的普通签名，可以用于校验通信双方数据的准确性以及完整性。</p></blockquote><p>数字签名有两个作用：</p><ul><li>验证数据是否为意料中的对象发出</li><li>对数据的完整性进行验证，验证数据是否被篡改过</li></ul><p><strong>使用私钥加密(生成签名)，公钥解密(验证签名)。</strong></p><p>服务端对消息进行私钥加密，客户端使用服务端传递的公钥进行验证，验证通过则表示消息一致，数字签名是正确的。</p><p>通常会对消息进行<strong>摘要</strong>，然后拿到消息的Hash值再进行私钥签名(<code>Hash值一般都会小于消息原文</code>)，大大提升签名效率。</p><p><strong>哈希摘要算法</strong>：根据任意长度数据计算出固定签名长度的算法。常用的有<code>SHA256、SHA384</code>。</p><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p><img src="/images/http/HTTPS通信过程.jpg" srcset="/img/loading.gif" alt="HTTPS通信过程"></p><h4 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h4><blockquote><p>客户端发送消息到服务端</p></blockquote><p>客户端生成随机数<code>client_random</code>，然后发送<code>TLS版本</code>，<code>加密算法列表</code>发送给服务端。</p><p>例如：发送消息为</p><ul><li><p><code>Random</code>：client_random</p></li><li><p><code>Version</code>：TLS 1.2</p></li><li><p><code>Cipher Suites</code>：TLS_AES_128_GCM_SHA256（<code>只是其中一种，整体是一个List型</code>）</p><p>服务端会从列表中选择一种加密算法，后续使用该算法进行通信。</p></li></ul><h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><blockquote><p>服务端发送消息到客户端</p></blockquote><p>服务端同样生成随机数<code>server_random</code>，以及<code>确认的TLS版本</code> 、<code>服务端选择的加密算法</code>，<code>服务器的证书信息</code>返回给客户端。</p><p>例如：返回消息为</p><ul><li><code>Random</code>：server_random</li><li><code>Cipher Suite</code>：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256（<code>返回一个来确定后续都用这种加密方式</code>）<ul><li>ECDHE：密钥协商算法</li><li>RSA：证书公钥加密算法</li><li>AES_128：对称加密算法以及密法长度</li><li>GCM：AES加密模式</li><li>SHA256：消息摘要算法</li></ul></li><li><code>Certificate</code>：返回的服务端证书信息，以及<code>非对称加密使用的公钥</code></li></ul><h4 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h4><blockquote><p>客户端验证数字证书以及验证通过后发送消息到服务端</p></blockquote><p>客户端验证服务端传来<code>证书</code>和<code>签名</code>是否通过，如果通过，按照协议不同有以下两种处理方式</p><ul><li><p>传统RSA版本</p><p>客户端再生成一个随机数<code>pre_random</code>，并且使用证书携带的RSA公钥加密，传给服务端</p></li><li><p>TLS 1.2版本</p><p>客户端生产<code>client_params</code>参数给服务端</p></li></ul><h4 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a>Server Key Exchange</h4><blockquote><p>服务端根据传递的参数生成对称加密使用的密钥</p></blockquote><ul><li><p>传统RSA版本</p><p>服务端接收到客户端传来的<code>pre_random</code>，使用私钥进行解密，然后拿着<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code></p></li><li><p>TLS 1.2版本</p><p>服务端接收到客户端传来的<code>client_params</code>，使用<code>ECDHE(椭圆曲线加密)</code>，根据已有的<code>client_params</code>和<code>server_params</code>生成最后的<code>pre_random</code>，最后使用<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code></p></li></ul><p>服务端生成<code>secret</code>后，给客户端发送一个收尾消息，该收尾消息包含两部分：</p><ul><li><code>Change Cipher Spec</code>：提示客户端后续消息会采用<code>secret</code>的对称加密进行传递</li><li><code>Finished</code>：对之前报文的所有数据进行摘要，加密后交由客户端进行解密，解密通过则表示协商成功</li></ul><h4 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h4><blockquote><p>客户端根据已有的参数生成对称加密使用的密钥</p></blockquote><ul><li><p>传统RSA版本</p><p>客户端根据已有的<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code></p></li><li><p>TLS 1.2版本</p><p>客户端通过<code>ECDHE</code>算法计算出<code>pre_random</code>，其中传入两个参数:<strong>server_params</strong>和<strong>client_params</strong>。现在你应该清楚这个两个参数的作用了吧，由于<code>ECDHE</code>基于<code>椭圆曲线离散对数</code>，这两个参数也称作<code>椭圆曲线的公钥</code>。</p><p>客户端根据<code>client_random</code>、<code>server_random</code>以及<code>pre_random</code>按照约定算法生成最终的<code>secret(对称加密密钥)</code>。</p></li></ul><p>客户端生成<code>secret</code>后，会给服务端发送一个收尾消息，该收尾消息包含两部分：</p><ul><li><code>Change Cipher Spec</code>：提示服务器后续消息会采用<code>secret</code>的对称加密进行传递</li><li><code>Finished</code>：对之前报文的所有数据进行摘要，加密后交由服务端进行解密，解密通过则表示协商成功</li></ul><p>当客户端与服务端都收到<code>finished</code>消息后，客户端和服务端都会持有<code>secret</code>，后续的请求都会使用<code>secret</code>进行对称加密传递消息。</p><h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h3><ol><li>HTTPS协议握手阶段比较费时，因为需要加密/解密过程</li><li>SSL证书是需要收费</li><li>HTTPS加密范围有限，而且证书不一定是可以信任的</li></ol><h3 id="与HTTP区别"><a href="#与HTTP区别" class="headerlink" title="与HTTP区别"></a>与HTTP区别</h3><ul><li>https协议需要向<code>CA</code>申请证书，需要一定费用</li><li>http信息是明文传输，HTTPS具有安全性的ssl加密传输协议</li><li>http和https使用的是完全不同的连接方式，端口不同，http使用了<code>80</code>端口，https使用<code>443</code>端口</li><li>http连接是简单的，无状态的；HTTPS由<code>http+ssl</code>构成的可进行加密传输，身份认证的网络协议，更加安全。</li></ul><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><blockquote><p>攻击者与通信两端(服务端与客户端)分别创建独立的联系，并交换所受到的数据，使通信的两端认为他们正在通过一个私密的连接与对方直接通信，事实上整个会话都被攻击者完全控制、</p><p>中间人攻击者可以拦截通讯双方的通话并插入新的内容。</p></blockquote><p><img src="/images/中间人攻击.jpg" srcset="/img/loading.gif" alt="中间人攻击"></p><h4 id="如何防御中间人攻击？"><a href="#如何防御中间人攻击？" class="headerlink" title="如何防御中间人攻击？"></a>如何防御中间人攻击？</h4><ul><li><p>公钥基础建设PKI</p><p>PKI相互认证机制，服务端验证客户端，客户端验证服务端</p></li><li><p>使用复杂加密哈希函数运行计算以造成数十秒的延迟</p><p>如果双方通信时间过长，可以基本判断存在中间人</p></li></ul><h2 id="HTTP协议版本区别"><a href="#HTTP协议版本区别" class="headerlink" title="HTTP协议版本区别"></a>HTTP协议版本区别</h2><p><img src="/images/HTTP协议版本区别mind.png" srcset="/img/loading.gif" alt="HTTP协议版本区别mind"></p><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><ul><li>默认短连接</li><li>增加了POST、HEAD命令</li></ul><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><ul><li>默认长连接(默认添加Header<code>Connection:Keep-Alive</code>)</li><li>增加了请求方法(<code>OPTIONS、PUT、DELETE、TRACE、CONNECT</code>)</li><li>请求消息和响应消息都支持Host头域</li><li>支持chunked编码传输</li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li><p>头部压缩</p><p>针对请求头字段进行压缩，采用了<code>HPACK</code>算法</p><p>HPACK算法：</p><ul><li>在服务端与客户端建立哈希表，存放使用的字段，只要在传输过程传输索引值，然后按照索引表查询即可</li><li>对于整数和字符串进行<strong>哈夫曼编码</strong></li></ul></li><li><p>多路复用</p><p>允许同时通过单一的HTTP2连接发起多重请求，由于把HTTP通信的基本单位缩小为一个个的二进制帧，各自对应着信息。</p><p>被拆分为很多互不依赖的<code>二进制帧</code>后，这些<code>二进制帧</code>就可以乱序发送。</p><p><img src="/images/v2-a3b152bfae26b0cfa2aa96ab2c638b4b_1440w.jpg" srcset="/img/loading.gif" alt="img"></p></li><li><p>二进制分帧</p><p>HTTP/2在 应用层和传输层增加一个<code>二进制分层</code>，在该分层中将传输的信息分割为更小的消息和帧，并采用二进制格式的编码。</p><blockquote><p>HTTP队头阻塞：在同一个TCP长连接中，前面的请求没有得到响应的话，后面的请求就无法被处理，导致阻塞。</p><p><code>并发连接</code>：对于一个域名分配多个长连接，相当于增加了任务队列，可以分散任务。</p><p><code>域名分片</code>：对一个域名分配多个二级域名，但是指向同一台服务器，使并发变多。</p></blockquote><p><img src="/images/v2-bb03351e6eac392c2afd89dafcf1e90f_1440w.jpg" srcset="/img/loading.gif" alt="img"></p></li><li><p>服务端推送    </p><p>在客户端请求之前发送数据，客户端请求一个资源后，服务端判断可能还需要其他资源，就会主动发送消息到客户端，减少客户端的等待</p><p><img src="/images/v2-fd019652daff484a0c06bbfb27404bc9_1440w.jpg" srcset="/img/loading.gif" alt="img"></p><p>需要注意以下两点：</p><ul><li>服务端推送遵循<code>同源策略</code></li><li>服务端推送基于客户端的请求响应来确定的</li></ul><blockquote><p>当服务端需要主动推送某个资源时，便会发送一个<code>PUSH_PROMISE</code>的<code>二进制帧(Frame)</code>，里面携带了<code>Stream ID</code>，表示服务端会用这个<code>ID</code>来推送资源，客户端解析时，需要从这个ID获取资源。</p></blockquote></li></ul><h2 id="HTTP相关协议"><a href="#HTTP相关协议" class="headerlink" title="HTTP相关协议"></a>HTTP相关协议</h2><p><img src="/images/HTTP相关协议mind.png" srcset="/img/loading.gif" alt="HTTP相关协议mind"></p><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><blockquote><p>提供域名到IP地址之间的解析服务，能够使人更方便地访问互联网。</p><p>还可以根据多个地址做负载均衡，并且选择一个就近的地点IP进行访问。</p></blockquote><h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><ol><li>客户端访问<code>XX.com</code>域名，先去请求本地DNS解析器</li><li>本地DNS解析器先去查看本地缓存是否有对应记录，若有直接使用；否则请求本地DNS服务器</li><li>本地DNS服务器一般部署在运营商网络中，然后本地DNS服务器也会查看是否存在本地缓存，存在则直接使用；否则递归请求根服务器</li><li>直到请求到顶级域名服务器，例如<code>.com</code>，查到数据后返回真实的IP地址。</li></ol><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><h5 id="域名缓存问题"><a href="#域名缓存问题" class="headerlink" title="域名缓存问题"></a>域名缓存问题</h5><p>由于DNS会优先获取本地缓存，如果缓存没有及时刷新，就会导致访问失败。</p><h5 id="域名转发问题"><a href="#域名转发问题" class="headerlink" title="域名转发问题"></a>域名转发问题</h5><p>DNS解析请求可能会被转发到其他DNS服务器进行处理，导致解析时无法判断地址，而返回一个较远IP使访问异常。</p><h5 id="域名更新问题"><a href="#域名更新问题" class="headerlink" title="域名更新问题"></a>域名更新问题</h5><p>忽略域名缓存IP的有效时间，导致结果更新不及时，一样会有访问异常问题</p><h5 id="解析延迟问题"><a href="#解析延迟问题" class="headerlink" title="解析延迟问题"></a>解析延迟问题</h5><p>DNS会进行递归解析，可能经过多个服务器，才可以获得最终结果，中间时间非常漫长</p><h4 id="HTTPDNS"><a href="#HTTPDNS" class="headerlink" title="HTTPDNS"></a>HTTPDNS</h4><blockquote><p>不走传统的DNS解析模式，自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商。需要进行DNS解析时，直接通过HTTP请求这个集群得到结果即可。</p></blockquote><h5 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h5><p>在客户端动态请求HTTPDNS服务端，获取解析的IP结果以及失效时间缓存到本地。后续在缓存未失效的情况下可直接返回对应域名的IP信息。如果没有返回信息，也可以降级回最初的LocalDNS解析方案。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote><p>内容分发网络(Content Delivery Network)。主要目的是<strong>改善互联网服务质量</strong>，提高用户访问网站的响应速度和成功率。</p></blockquote><p>通过权威DNS服务器来实现最优节点的选择，通过<strong>缓存</strong>来减少源站的压力</p><h3 id="URL-URI"><a href="#URL-URI" class="headerlink" title="URL/URI"></a>URL/URI</h3><blockquote><p>用户在浏览器地址栏输入的或者是App发起请求时设置的地址</p></blockquote><p><code>URI</code>：统一资源标识符，唯一的标记互联网资源</p><p><code>URL</code>：统一资源定位符，也就是<strong>网址</strong>，实际为<code>URI</code>的子集</p><h4 id="URI结构"><a href="#URI结构" class="headerlink" title="URI结构"></a>URI结构</h4><p><img src="/images/URI结构.webp" srcset="/img/loading.gif" alt="URI结构"></p><h5 id="协议类型-scheme"><a href="#协议类型-scheme" class="headerlink" title="协议类型(scheme)"></a>协议类型(<code>scheme</code>)</h5><p>比如<code>http</code>,<code>https</code>,<code>file</code>等，必须和<code>://</code>连在一起</p><h5 id="服务器地址-host-port"><a href="#服务器地址-host-port" class="headerlink" title="服务器地址(host:port)"></a>服务器地址(<code>host:port</code>)</h5><p>对应的是所需接受浏览器/App请求的服务器地址</p><h5 id="请求路径-path"><a href="#请求路径-path" class="headerlink" title="请求路径(path)"></a>请求路径(<code>path</code>)</h5><p>对应请求需要处理的位置</p><h5 id="查询参数-query"><a href="#查询参数-query" class="headerlink" title="查询参数(query)"></a>查询参数(<code>query</code>)</h5><p>为<code>key=value</code>这类的形式，存在多个用<code>&amp;</code>进行连接</p><h5 id="锚点-fragment"><a href="#锚点-fragment" class="headerlink" title="锚点(fragment)"></a>锚点(<code>fragment</code>)</h5><p>表示URI定位资源内的一个锚点，通过这个锚点可以跳转到指定位置</p><pre><code class="hljs undefined">https://juejin.im/search?query=s#heading-1</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href>图解HTTP</a></p><p><a href="https://mp.weixin.qq.com/s/smYo1tECl6-TS6anKF8Jgw" target="_blank" rel="noopener">深入理解HTTPS</a></p><p><a href="https://juejin.im/post/5e76bd516fb9a07cce750746#heading-74" target="_blank" rel="noopener">HTTP灵魂之问</a></p><p><a href="https://zh.wikipedia.org/wiki/中间人攻击" target="_blank" rel="noopener">中间人攻击</a></p><p><a href="https://www.jianshu.com/p/52d86558ca57" target="_blank" rel="noopener">HTTP协议版本差异</a></p><p><a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">GET与POST区别</a></p><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html" target="_blank" rel="noopener">CSRF防护</a></p><p><a href="https://www.zhihu.com/question/36514327/answer/193768864" target="_blank" rel="noopener">CDN相关</a></p><p><a href="https://mp.weixin.qq.com/s/KTKVu3uCC5MFlU5oylZPFA" target="_blank" rel="noopener">TCP拥塞控制详解</a></p><p>​            </p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android性能优化-内存优化详解</title>
    <link href="/2020/03/23/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/03/23/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Android内存优化"><a href="#Android内存优化" class="headerlink" title="Android内存优化"></a>Android内存优化</h1><h2 id="内存的概念"><a href="#内存的概念" class="headerlink" title="内存的概念"></a>内存的概念</h2><p>内存是计算机中最重要的部件之一，是硬盘与CPU之间沟通的桥梁，所有程序都是运行其上，会对程序的性能造成很大的影响。</p><h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><h3 id="系统层面"><a href="#系统层面" class="headerlink" title="系统层面"></a>系统层面</h3><!--进程优先级--><p><code>LowMemoryKiller</code></p><h3 id="进程层面"><a href="#进程层面" class="headerlink" title="进程层面"></a>进程层面</h3><p>GC</p><h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><!--分析流程--><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><h3 id="内存抖动"><a href="#内存抖动" class="headerlink" title="内存抖动"></a>内存抖动</h3><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h2 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a>优化工具</h2><h2 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.android.com/topic/performance/memory-overview" target="_blank" rel="noopener">内存管理概览</a></p><p><a href="https://mp.weixin.qq.com/s/EerrwaRGdTkOFPLrg8_-oQ" target="_blank" rel="noopener">探索Android内存优化方法</a></p><p><a href="https://juejin.im/post/5e780257f265da575209652c#heading-6" target="_blank" rel="noopener">探索Android内存优化</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OkHttp-HTTPDNS实践</title>
    <link href="/2020/02/19/OKHTTP-HTTPDNS%E5%AE%9E%E8%B7%B5/"/>
    <url>/2020/02/19/OKHTTP-HTTPDNS%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>设计方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Art类加载过程</title>
    <link href="/2019/12/19/Android-Art%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/12/19/Android-Art%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Dex文件加载"><a href="#Dex文件加载" class="headerlink" title="Dex文件加载"></a>Dex文件加载</h2><blockquote><p>加载Dex文件后会生成<code>DexFile</code>对象，里面储存了多个类文件信息。</p></blockquote><p>通过<code>PathClassLoader</code>或者<code>DexClassLoader</code>去加载<code>Dex</code>文件，最后还是调用到<code>BaseDexClassLoader</code>的加载方法</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseDexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLaoder</span></span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseDexClassLoader</span><span class="hljs-params">(String dexPath, File optimizedDirectory,            String librarySearchPath, ClassLoader parent)</span> </span>&#123;        <span class="hljs-keyword">super</span>(parent);        <span class="hljs-keyword">this</span>.pathList = <span class="hljs-keyword">new</span> DexPathList(<span class="hljs-keyword">this</span>, dexPath, librarySearchPath, <span class="hljs-keyword">null</span>);...    &#125;&#125;</code></pre><ul><li><p>DexPathList</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DexPathList</span></span>&#123;  <span class="hljs-keyword">private</span> Element[] dexElements;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NativeLibraryElement[] nativeLibraryPathElements;    ...      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DexPathList</span><span class="hljs-params">(ClassLoader definingContext, String dexPath,            String librarySearchPath, File optimizedDirectory)</span> </span>&#123;   ...   <span class="hljs-comment">// 记录所有的dexFile</span>   <span class="hljs-keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,                       suppressedExceptions, definingContext);       <span class="hljs-comment">//记录app目录的Native库</span>   <span class="hljs-keyword">this</span>.nativeLibraryDirectories = splitPaths(librarySearchPath, <span class="hljs-keyword">false</span>);   <span class="hljs-comment">//记录系统使用的Native库</span>   <span class="hljs-keyword">this</span>.systemNativeLibraryDirectories =                splitPaths(System.getProperty(<span class="hljs-string">"java.library.path"</span>), <span class="hljs-keyword">true</span>);   <span class="hljs-comment">//记录所有使用的Native库</span>   <span class="hljs-keyword">this</span>.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories);  &#125;&#125;</code></pre><p>为了初始化以下两个字段：</p><ul><li><code>dexElements</code>：记录所有的DexFile，按照<code>;</code>进行路径分割</li><li><code>nativeLibraryPathElements</code>：记录所有的Native代码库，包括<code>app</code>和<code>系统</code>使用的Native库</li></ul></li><li><p>makeDexElements</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,        List&lt;IOException&gt; suppressedExceptions, ClassLoader loader) &#123;  Element[] elements = <span class="hljs-keyword">new</span> Element[files.size()]; <span class="hljs-keyword">for</span> (File file : files) &#123;  ...    <span class="hljs-comment">//以 dex 文件名结尾</span>    <span class="hljs-keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//加载Dex文件</span>         DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements);         <span class="hljs-keyword">if</span> (dex != <span class="hljs-keyword">null</span>) &#123;             elements[elementsPos++] = <span class="hljs-keyword">new</span> Element(dex, <span class="hljs-keyword">null</span>);         &#125;         &#125; <span class="hljs-keyword">catch</span> (IOException suppressed) &#123;           &#125;    &#125;<span class="hljs-keyword">else</span>&#123;      dex = loadDexFile(file, optimizedDirectory, loader, elements);                        <span class="hljs-keyword">if</span> (dex == <span class="hljs-keyword">null</span>) &#123;              elements[elementsPos++] = <span class="hljs-keyword">new</span> Element(file);          &#125; <span class="hljs-keyword">else</span> &#123;              elements[elementsPos++] = <span class="hljs-keyword">new</span> Element(dex, file);          &#125;    &#125; &#125; ... &#125;</code></pre><p>根据传入的Dex文件路径转换<code>Element</code>数组</p></li><li><p>loadDexFile</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DexFile <span class="hljs-title">loadDexFile</span><span class="hljs-params">(File file, File optimizedDirectory, ClassLoader loader,                                   Element[] elements)</span>        <span class="hljs-keyword">throws</span> IOException </span>&#123;   <span class="hljs-comment">//优化后Dex文件 存放地址是否为空</span>    <span class="hljs-keyword">if</span> (optimizedDirectory == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//为空创建DexFile对象</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DexFile(file, loader, elements);    &#125; <span class="hljs-keyword">else</span> &#123;        String optimizedPath = optimizedPathFor(file, optimizedDirectory);      <span class="hljs-comment">//不为空将优化后的Dex文件存放到指定目录</span>        <span class="hljs-keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="hljs-number">0</span>, loader, elements);    &#125;&#125;</code></pre><p>此处为了加载Dex文件</p></li><li><p>DexFile</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DexFile</span> </span>&#123;     DexFile(File file, ClassLoader loader, DexPathList.Element[] elements)            <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-keyword">this</span>(file.getPath(), loader, elements);    &#125;    ...        DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) <span class="hljs-keyword">throws</span> IOException &#123;        mCookie = openDexFile(fileName, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, loader, elements);        mInternalCookie = mCookie;        mFileName = fileName;    &#125;  ...        <span class="hljs-function"><span class="hljs-keyword">static</span> DexFile <span class="hljs-title">loadDex</span><span class="hljs-params">(String sourcePathName, String outputPathName,        <span class="hljs-keyword">int</span> flags, ClassLoader loader, DexPathList.Element[] elements)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DexFile(sourcePathName, outputPathName, flags, loader, elements);    &#125;  ...&#125;</code></pre><p><code>loadDex</code>本质也是调用了<code>new DexFile(...)</code>去加载Dex文件的。</p></li><li><p>openDexFile</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">openDexFile</span><span class="hljs-params">(String sourceName, String outputName, <span class="hljs-keyword">int</span> flags,        ClassLoader loader, DexPathList.Element[] elements)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// Use absolute paths to enable the use of relative paths when testing on host.</span>    <span class="hljs-comment">//加载Dex文件</span>    <span class="hljs-keyword">return</span> openDexFileNative(<span class="hljs-keyword">new</span> File(sourceName).getAbsolutePath(),                             (outputName == <span class="hljs-keyword">null</span>)                                 ? <span class="hljs-keyword">null</span>                                 : <span class="hljs-keyword">new</span> File(outputName).getAbsolutePath(),                             flags,                             loader,                             elements);&#125;</code></pre><p><code>openDexFile</code>为了加载Dex文件</p></li><li><p>openDexFileNative</p><pre><code class="hljs c"><span class="hljs-comment">// art/runtime/native/dalvik_system_DexFile.cc</span><span class="hljs-function"><span class="hljs-keyword">static</span> jobject <span class="hljs-title">DexFile_openDexFileNative</span><span class="hljs-params">(JNIEnv* env,                                         jclass,                                         jstring javaSourceName,                                         jstring javaOutputName ATTRIBUTE_UNUSED,                                         jint flags ATTRIBUTE_UNUSED,                                         jobject class_loader,                                         jobjectArray dex_elements)</span> </span>&#123;  <span class="hljs-function">ScopedUtfChars <span class="hljs-title">sourceName</span><span class="hljs-params">(env, javaSourceName)</span></span>;  <span class="hljs-keyword">if</span> (sourceName.c_str() == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  Runtime* <span class="hljs-keyword">const</span> runtime = Runtime::Current();  ClassLinker* linker = runtime-&gt;GetClassLinker();  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> DexFile&gt;&gt; dex_files;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; error_msgs;  <span class="hljs-keyword">const</span> OatFile* oat_file = <span class="hljs-literal">nullptr</span>;  dex_files = runtime-&gt;GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(),                                                               class_loader,                                                               dex_elements,                                                               <span class="hljs-comment">/*out*/</span> &amp;oat_file,                                                               <span class="hljs-comment">/*out*/</span> &amp;error_msgs);...    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  &#125;&#125;</code></pre><p><code>openDexFileNative</code>主要处理dex文件，并生成<code>odex</code>到<code>optimizedDirectory</code>里</p></li><li><p>openDexFilesFromOat</p><p>//TODO 版本差异较大</p><pre><code class="hljs c"><span class="hljs-comment">//art/runtime/oat_file_manager.cc</span><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">const</span> DexFile&gt;&gt; <span class="hljs-title">OatFileManager::OpenDexFilesFromOat</span><span class="hljs-params">(    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* dex_location,    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* oat_location,    jobject class_loader,    jobjectArray dex_elements,    <span class="hljs-keyword">const</span> OatFile** out_oat_file,    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;* error_msgs)</span> </span>&#123;  &#125;oat_file_manager.cc  oat_file_assistant.cc</code></pre></li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/Dex加载过程.png" srcset="/img/loading.gif" class="full-image" alt="Dex加载过程" title="Dex加载过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="Dex中的类文件加载"><a href="#Dex中的类文件加载" class="headerlink" title="Dex中的类文件加载"></a>Dex中的类文件加载</h2><blockquote><p>Dex文件是由多个Class类文件组成，Android加载类需要从Dex中找到对应类进行加载，实际<code>从DexFile找到Class</code></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseDexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123; ...   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DexPathList pathList;        <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;        <span class="hljs-comment">// First, check whether the class is present in our shared libraries.</span>        <span class="hljs-comment">//加载需要使用的Native库</span>        <span class="hljs-keyword">if</span> (sharedLibraryLoaders != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (ClassLoader loader : sharedLibraryLoaders) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">return</span> loader.loadClass(name);                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) &#123;                &#125;            &#125;        &#125;        <span class="hljs-comment">// Check whether the class in question is present in the dexPath that</span>        <span class="hljs-comment">// this classloader operates on.</span>        List&lt;Throwable&gt; suppressedExceptions = <span class="hljs-keyword">new</span> ArrayList&lt;Throwable&gt;();        <span class="hljs-comment">// 找寻Dex中对应class</span>        Class c = pathList.findClass(name, suppressedExceptions);        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;            ClassNotFoundException cnfe = <span class="hljs-keyword">new</span> ClassNotFoundException(                    <span class="hljs-string">"Didn't find class \""</span> + name + <span class="hljs-string">"\" on path: "</span> + pathList);            <span class="hljs-keyword">for</span> (Throwable t : suppressedExceptions) &#123;                cnfe.addSuppressed(t);            &#125;            <span class="hljs-keyword">throw</span> cnfe;        &#125;        <span class="hljs-keyword">return</span> c;    &#125;&#125;</code></pre><ul><li><p>DexPathList - findClass</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;    <span class="hljs-keyword">for</span> (Element element : dexElements) &#123;        Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed);        <span class="hljs-keyword">if</span> (clazz != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> clazz;        &#125;    &#125;      <span class="hljs-keyword">if</span> (dexElementsSuppressedExceptions != <span class="hljs-keyword">null</span>) &#123;        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p><code>findClass</code>为了找到Dex文件中的对应类</p><blockquote><p><code>dexElements</code>是由<code>Dex</code>文件加载后得到的<code>DexFile</code>组装成的<code>Element</code>集合形成的。</p><p><code>findClass</code>实质是去遍历已加载完成的<code>Dex</code>文件中的Class，只要找到对应的Class就会结束循环。</p><p><strong>当两个相同的类出现在不同的Dex时，系统会优先处理排在前面的Dex文件中的类，后面出现的就不会被加载。</strong></p><p>热修复的核心逻辑：<code>将需要修复的类所打包的Dex文件插入到dexElements的首位</code>。</p></blockquote></li></ul><ul><li><p>Element - findClass</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; findClass(String name, ClassLoader definingContext,         List&lt;Throwable&gt; suppressed) &#123;     <span class="hljs-keyword">return</span> dexFile != <span class="hljs-keyword">null</span> ? dexFile.loadClassBinaryName(name, definingContext, suppressed)             : <span class="hljs-keyword">null</span>; &#125;</code></pre></li></ul><ul><li><p>DexFile - loadClassBinaryName</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">loadClassBinaryName</span><span class="hljs-params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;    <span class="hljs-keyword">return</span> defineClass(name, loader, mCookie, <span class="hljs-keyword">this</span>, suppressed);&#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class <span class="hljs-title">defineClass</span><span class="hljs-params">(String name, ClassLoader loader, Object cookie,                                 DexFile dexFile, List&lt;Throwable&gt; suppressed)</span> </span>&#123;    Class result = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//定义Class</span>        result = defineClassNative(name, loader, cookie, dexFile);    &#125; <span class="hljs-keyword">catch</span> (NoClassDefFoundError e) &#123;        <span class="hljs-keyword">if</span> (suppressed != <span class="hljs-keyword">null</span>) &#123;            suppressed.add(e);        &#125;    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;        <span class="hljs-keyword">if</span> (suppressed != <span class="hljs-keyword">null</span>) &#123;            suppressed.add(e);        &#125;    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></li></ul><ul><li><p>Dalvik_system_DexFile.cc - DexFile_defineClassNative</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> jclass <span class="hljs-title">DexFile_defineClassNative</span><span class="hljs-params">(JNIEnv* env,                                        jclass,                                        jstring javaName,                                        jobject javaLoader,                                        jobject cookie,                                        jobject dexFile)</span> </span>&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> DexFile*&gt; dex_files;  <span class="hljs-keyword">const</span> OatFile* oat_file;  <span class="hljs-keyword">if</span> (!ConvertJavaArrayToDexFiles(env, cookie, <span class="hljs-comment">/*out*/</span> dex_files, <span class="hljs-comment">/*out*/</span> oat_file)) &#123;    VLOG(class_linker) &lt;&lt; <span class="hljs-string">"Failed to find dex_file"</span>;    DCHECK(env-&gt;ExceptionCheck());    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  &#125;  <span class="hljs-function">ScopedUtfChars <span class="hljs-title">class_name</span><span class="hljs-params">(env, javaName)</span></span>;  <span class="hljs-keyword">if</span> (class_name.c_str() == <span class="hljs-literal">nullptr</span>) &#123;    VLOG(class_linker) &lt;&lt; <span class="hljs-string">"Failed to find class_name"</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">descriptor</span><span class="hljs-params">(DotToDescriptor(class_name.c_str()))</span></span>;  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">(ComputeModifiedUtf8Hash(descriptor.c_str()))</span></span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dex_file : dex_files) &#123;    <span class="hljs-keyword">const</span> DexFile::ClassDef* dex_class_def =        OatDexFile::FindClassDef(*dex_file, descriptor.c_str(), hash);    <span class="hljs-keyword">if</span> (dex_class_def != <span class="hljs-literal">nullptr</span>) &#123;      <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;      ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();...        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;      &#125;      <span class="hljs-comment">//创建目标类对象</span>      ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;DefineClass(soa.Self(),                                                               descriptor.c_str(),                                                               hash,                                                               class_loader,                                                               *dex_file,                                                               *dex_class_def);      <span class="hljs-comment">// Add the used dex file. This only required for the DexFile.loadClass API since normal</span>      <span class="hljs-comment">// class loaders already keep their dex files live.</span>      class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object&gt;(dexFile),                                                 class_loader.Get());      <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">nullptr</span>) &#123;        VLOG(class_linker) &lt;&lt; <span class="hljs-string">"DexFile_defineClassNative returning "</span> &lt;&lt; result                           &lt;&lt; <span class="hljs-string">" for "</span> &lt;&lt; class_name.c_str();        <span class="hljs-keyword">return</span> soa.AddLocalReference&lt;jclass&gt;(result);      &#125;    &#125;  &#125;  VLOG(class_linker) &lt;&lt; <span class="hljs-string">"Failed to find dex_class_def "</span> &lt;&lt; class_name.c_str();  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;</code></pre></li><li><p>Class_linker.cc  - DefineClass</p><pre><code class="hljs c"><span class="hljs-function">mirror::Class* <span class="hljs-title">ClassLinker::DefineClass</span><span class="hljs-params">(Thread* self,                                        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* descriptor,                                        <span class="hljs-keyword">size_t</span> hash,                                        Handle&lt;mirror::ClassLoader&gt; class_loader,                                        <span class="hljs-keyword">const</span> DexFile&amp; dex_file,                                        <span class="hljs-keyword">const</span> DexFile::ClassDef&amp; dex_class_def)</span> </span>&#123;  ...  <span class="hljs-keyword">if</span> (klass == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-comment">//加载类实例</span>    klass.Assign(AllocClass(self, SizeOfClassWithoutEmbeddedTables(dex_file, dex_class_def)));  &#125;  ObjPtr&lt;mirror::DexCache&gt; dex_cache = RegisterDexFile(*new_dex_file, class_loader.Get());  <span class="hljs-keyword">if</span> (dex_cache == <span class="hljs-literal">nullptr</span>) &#123;    self-&gt;AssertPendingException();    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  &#125;  <span class="hljs-comment">//设置Dex缓存，后续数据从缓存中读取</span>  klass-&gt;SetDexCache(dex_cache);  <span class="hljs-comment">//设置Class信息</span>  SetupClass(*new_dex_file, *new_class_def, klass, class_loader.Get());  <span class="hljs-comment">// 把 Class 插入 ClassLoader 的 class_table 中做一个缓存</span>  ObjPtr&lt;mirror::Class&gt; existing = InsertClass(descriptor, klass.Get(), hash);  <span class="hljs-comment">// 加载类属性</span>  LoadClass(self, *new_dex_file, *new_class_def, klass);&#125;</code></pre><p>每当一个类被加载时，ART运行时都会检查该类所属的Dex文件是否已经关联一个<code>dex_cache</code>。</p><p>如果尚未关联，就会创建一个<code>dex_cache</code>与Dex文件建立关联，建立关联后，通过调用<code>RegisterDexFile</code>注册到aRT运行时中去，后续可以直接使用。</p><p><code>dex_cache</code>用来缓存包含在一个Dex文件里的<code>类型(Type)、方法(Method)、域(Field)、字符串(String)和静态存储区(Static Storage)</code>等信息。</p><p><code>通过dex_cache间接调用类方法，可以做到延时解析类方法(只有方法第一次调用才会被解析，可以避免解析永远不调用的方法)；一个类方法只会被解析一次，解析的结果存在dex_cache中，下次调用时可以直接从dex_cache进行调用。</code></p></li></ul><h3 id="加载类成员"><a href="#加载类成员" class="headerlink" title="加载类成员"></a>加载类成员</h3><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://gityuan.com/2017/03/19/android-classloader/" target="_blank" rel="noopener">Android类加载器ClassLoader</a></p><p><a href="cs.android.com">相关源码</a></p><p><a href="https://juejin.im/post/5d6a79de5188256c3920b8f7#heading-4" target="_blank" rel="noopener">谈谈 Android 中的 PathClassLoader 和 DexClassLoader</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见名词概念</title>
    <link href="/2019/12/11/%E5%B8%B8%E8%A7%81%E5%90%8D%E8%AF%8D%E6%A6%82%E5%BF%B5/"/>
    <url>/2019/12/11/%E5%B8%B8%E8%A7%81%E5%90%8D%E8%AF%8D%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git常用指令及作用(速查)</title>
    <link href="/2019/12/06/Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E4%BD%9C%E7%94%A8/"/>
    <url>/2019/12/06/Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>git log //显示提交信息<br>git log –oneline //简要日志输出<br>git log –oneline -5 //输出最近5次提交日志</p><h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p>git status //显示当前git状态<br>git status -s //简要信息</p><p>git push origin HEAD:refs/for/master //推送代码</p><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><p>git tag //列举标签</p><p>git tag  version //给提交设置标签<br>git push origin ​version //推送设置标签的动作</p><h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><p>git checkout //切换分支<br>git checkout dev //切换本地分支<br>git checkout remote/master //切换远程分支<br>git checkout –track origin/master //基于远程分支创建本地分支并跟踪<br>git checkout -b dev //基于本地分支 创建新分支</p><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>git commit -m “XXX” //提交概要信息<br>git commit –amend //编辑提交信息<br>git commit –amend –no-edit //跳过编辑直接提交<br>git commit –no-verify -m “XXX” //跳过校验直接提交</p><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>git reset –hard commit_sha1 //丢弃回滚提交前的所有改动<br>git reset –soft commit_sha1 //回滚提交前的改动放回暂存区与工作区<br>git reset –mixed commit_sha1 //回滚提交前的改动放回工作区并清空暂存区</p><h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><p>git revert commit-sha1 //回滚到某次提交</p><h2 id="rebase-（慎用）"><a href="#rebase-（慎用）" class="headerlink" title="rebase （慎用）"></a>rebase （慎用）</h2><p>只对尚未推送的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。<br>git rebase 0i git-sha1|branch //进入交互变基模式</p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>git merge –ff branchName //合并分支并不创造新的commit节点</p><p>git merge –no-ff branchName //保留合并分支的提交记录</p><h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>git pull //拉取代码</p><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>git push origin HEAD:refs/for/BranchName //推送远程分支</p><p>git push -d origin BranchName //删除远程分支</p><p>git push -f origin BranchName //强制推送远程分支</p><p>git push –force-with-lease //远程分支与本地保持一致时，推送成功，否则失败</p><h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><blockquote><p>维护多个仓库源使用</p></blockquote><p>git remote add origin url //关联远程仓库</p><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><blockquote><p>操作分支命令</p></blockquote><p>git branch //列举远程分支 </p><p>git branch -a //列举所有分支 包括本地分支</p><p>上述结果中 <code>*</code>表示当前使用分支</p><p>git branch -c [oldBranchName] branchName //复制分支</p><p>git branch -C [oldBranchName] branchName //强制复制分支</p><p>git branch -m [oldBranchName] branchName //移动分支</p><p>git branch -M [oldBranchName] branchName //强制移动分支</p><p>git branch -d branchName //删除分支</p><p>git branch -D branchName //强制删除分支</p><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><blockquote><p>暂存当前修改的代码 <strong>每次暂存的时候 设置一下描述信息</strong></p></blockquote><p>git stash push -m “XX” //暂存文件并设置描述信息</p><p>git stash apply stash@{0} //使用但保留暂存记录</p><p>git stash pop stash@{0} //使用并删除暂存记录</p><p>git stash list //列举暂存记录</p><p>git stash drop stash@{0} //丢弃指定暂存记录</p><p>git stash show stash@{0} //查看指定暂存记录修改内容</p><h2 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h2><blockquote><p>记录所有git操作行为</p></blockquote><p>git reflog -5 //打印最近5次操作</p><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><blockquote><p>从其他分支选择需要的commit合并到一个分支中</p></blockquote><p>git cherry-pick commit-sha1 //合并其他分支的提交</p><p>git cherry-pick commit-sha1 commit-sha2 //合并多个提交</p><p>git cherry-pick startCommit-sha1…endCommitSha1 //按照提交区间进行合并</p><p>git cherry-pick (–continue | –skip | –abort | —quit) //后续的操作 继续合并｜跳过｜完全放弃恢复初始状态｜为冲突的合入，冲突的放弃</p><h2 id="rm（慎用）"><a href="#rm（慎用）" class="headerlink" title="rm（慎用）"></a>rm（慎用）</h2><blockquote><p>移除版本控制中的文件</p></blockquote><p>git rm —cache file_path //移除缓存中的索引</p><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><blockquote><p>对提交记录进行比较</p></blockquote><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><blockquote><p>添加工作目录中的文件到缓存区，缓存区中是需要提交的文件。</p></blockquote><p>git add <file> //加入文件到缓存区</file></p><p>git add <dic> //加入目录到缓存区</dic></p><p>git add -p //交互式加入文件</p><blockquote><p>使用 <code>y</code> 缓存某一处更改，使用 <code>n</code> 忽略某一处更改，使用 <code>s</code> 将某一处分割成更小的几份，使用 <code>e</code> 手动编辑某一处更改，使用 <code>q</code> 退出编辑。</p></blockquote><p>git add .</p><p>git add -A</p><blockquote><p>上述两命令都表示 加入所有文件到缓存区 包括<code>New File(新增文件),Update File(有修改的文件),Deleted File(已删除文件)</code></p></blockquote><p>git add -u //只提交被修改和被删除的文件</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java字节码学习-应用场景</title>
    <link href="/2019/11/18/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2019/11/18/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<!-- ASM基本原理、代码中的动态替换  非静态调用通过字节码编辑改为静态调用 字节码注入 SPI Transform-->]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java字节码学习-操作指令</title>
    <link href="/2019/11/14/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/"/>
    <url>/2019/11/14/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对常见的字节码操作指令进行整理，方便日后进行查询。为了在字节码应用时可以进行合理利用。</p></blockquote><p>JVM采用基于栈的架构，操作指令由<strong>操作码和操作数</strong>组成。<code>操作码</code>决定要完成的操作，<code>操作数</code>指参加运算的数据及其所在的单元地址。</p><p>操作码：一个字节长度（0～299），操作码个数不能不能超过256</p><p>操作数：一条指令可以包含0个或多个操作数。</p><blockquote><p>为了提升传输效率，减少数据量。字节码指令放弃了 操作数对齐，减少了填充与间隔符号的使用。但是如果操作码处理超过一个字节的数据时，必须在运行时从字节码里构建出具体的数据结构，占用CPU，导致解释执行字节码会损失部分性能。</p></blockquote><h2 id="操作指令（按功能分类）"><a href="#操作指令（按功能分类）" class="headerlink" title="操作指令（按功能分类）"></a>操作指令（按功能分类）</h2><p><strong>大部分数据类型相关指令，都没有支持byte、short、char数据类型，并且没有任何支持boolean类型的指令。</strong></p><p>编译器会在编译期或运行期将<code>byte、short</code>转为<strong>带符号拓展的int型数据</strong>，将<code>char、boolean</code>转为<strong>零位拓展的int型数据</strong>。</p><h3 id="加载存储指令"><a href="#加载存储指令" class="headerlink" title="加载存储指令"></a>加载存储指令</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/字节码-操作指令-加载指令.jpg" srcset="/img/loading.gif" class="full-image" alt="字节码-操作指令-加载指令" title="字节码-操作指令-加载指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/操作指令-加载指令.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-加载指令" title="操作指令-加载指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>主要用于<em>局部变量与操作数栈交换数据</em>、<em>常量装载到操作数栈</em>。</p></blockquote><h4 id="局部变量与操作数栈交换数据"><a href="#局部变量与操作数栈交换数据" class="headerlink" title="局部变量与操作数栈交换数据"></a>局部变量与操作数栈交换数据</h4><h5 id="load"><a href="#load" class="headerlink" title="load"></a>load</h5><blockquote><p>加载局部变量表指定位置的相应类型变量到操作数栈栈顶</p></blockquote><p><code>iload、iload_&lt;n&gt;</code>：将<code>第n+1</code>个<code>int</code>变量推到栈顶</p><p><code>lload、lload_&lt;n&gt;</code>：将<code>第n+1</code>个<code>long</code>变量推到栈顶</p><p><code>fload、fload_&lt;n&gt;</code>：将<code>第n+1</code>个<code>float</code>变量推到栈顶</p><p><code>dload、dload_&lt;n&gt;</code>：将<code>第n+1</code>个<code>double</code>变量推到栈顶</p><p><code>aload、aload_&lt;n&gt;</code>：将<code>第n+1</code>个<code>引用</code>变量推到栈顶</p><h5 id="store"><a href="#store" class="headerlink" title="store"></a>store</h5><blockquote><p>将操作数栈栈顶的相应类型数据保存到局部变量的指定位置</p></blockquote><p><code>istore、istore_&lt;n&gt;</code>：将栈顶的<code>int</code>类型数值保存到<code>n+1</code>的局部变量中</p><p><code>lstore、lstore_&lt;n&gt;</code>：将栈顶的<code>long</code>类型数值保存到<code>n+1</code>的局部变量中</p><p><code>fstore、fstore_&lt;n&gt;</code>：将栈顶的<code>float</code>类型数值保存到<code>n+1</code>的局部变量中</p><p><code>dstore、dstore_&lt;n&gt;</code>：将栈顶的<code>double</code>类型数值保存到<code>n+1</code>的局部变量中</p><p><code>astore、astore_&lt;n&gt;</code>：将栈顶的<code>引用</code>类型数值保存到<code>n+1</code>的局部变量中</p><p><code>XXX_&lt;n&gt;</code>，其中<code>n</code>表示非负整数，范围在0~3之间，超过这个范围则表示成<code>XXX n</code></p><p>例 <code>iload 4</code>，将第5个<code>int</code>类型数值推到栈顶。</p><h4 id="常量装载到操作数栈"><a href="#常量装载到操作数栈" class="headerlink" title="常量装载到操作数栈"></a>常量装载到操作数栈</h4><h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><blockquote><p>相应类型常量数值放入栈顶</p></blockquote><p><code>bipush</code>：单字节的常量值(-128~127)进栈<br>例：    <code>static final int a = 123</code></p><p><code>sipush</code>：短整型常量值(-32768~32767)进栈<br>例：    <code>static final int a =456</code></p><p>对应上述操作码的操作数为 <strong>常量的数值</strong>，例 <code>bipush 123</code></p><h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><blockquote><p>将相应的数值类型放入栈顶，无对应操作数</p></blockquote><p><code>iconst_m1、iconst_&lt;n&gt;</code>：<code>int</code>型常量进栈，<code>m1</code>指代-1，n为<code>1~5</code></p><p>例 <code>int a = -1</code>,若<code>int a=6</code>则对应<code>bipush 6</code></p><p><code>lconst_0,lconst_1</code>：<code>long</code>型常量进栈，只有0L、1L有效</p><p>例 <code>long a = 0L</code></p><p><code>fconst_0,fconst_1,fconst_2</code>：<code>float</code>型常量进栈，只有0F、1F、2F有效</p><p>例 <code>float a = 0f</code></p><p><code>dconst_0,dconst_1</code>：<code>double</code>型常量进栈，只有0D、1D有效</p><p>例 <code>double a = 0d</code></p><p><code>aconst_null</code>：对象<code>null</code>进栈，只有<code>null</code>有效</p><p>例 <code>String a = null</code></p><h5 id="ldc"><a href="#ldc" class="headerlink" title="ldc"></a>ldc</h5><blockquote><p>把数值常量或String型常量从常量池中推送至栈顶，<code>操作数为常量池索引</code></p></blockquote><p><strong>所有不是通过new方式创建的String都是放在常量池中的。</strong></p><p><code>ldc</code>：<code>int、float或String型常量</code>推送至栈顶</p><p>例 <code>int a = 66666</code>，对应<code>ldc #18</code>，18代指了常量池中的位置，<em>索引为8位</em></p><p><code>ldc_w</code>：<code>int、float或String型常量</code>推送至栈顶，<strong>宽索引</strong></p><p>例<code>宽索引</code>：表示常量池的行号，索引的字段长度。<em>索引为16位</em></p><p><code>ldc2_w</code>：<code>long、double型常量</code>推送至栈顶，<strong>宽索引</strong></p><p>例 <code>doubla a = 2.3</code>，对应<code>ldc2_w #19</code>，#19表示了<code>double 2.3</code></p><h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/操作指令-操作数栈管理指令.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-操作数栈管理指令" title="操作指令-操作数栈管理指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>对操作数栈进行直接操作：<strong>出栈、复制栈顶元素、交换栈顶元素</strong></p></blockquote><h4 id="操作数栈栈顶出栈"><a href="#操作数栈栈顶出栈" class="headerlink" title="操作数栈栈顶出栈"></a>操作数栈栈顶出栈</h4><h5 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h5><blockquote><p>操作数栈栈顶元素出栈 <strong>不能是long、double</strong>，只支持一个字节的数据</p></blockquote><h5 id="pop2"><a href="#pop2" class="headerlink" title="pop2"></a>pop2</h5><blockquote><p>操作数栈栈顶元素出栈 ，支持两个字节的数据，例如<code>long/double</code>一个数值，其他类型是两个数值</p></blockquote><h4 id="操作数栈栈顶复制"><a href="#操作数栈栈顶复制" class="headerlink" title="操作数栈栈顶复制"></a>操作数栈栈顶复制</h4><p>以下三个操作指令支持的数据类型 不包括<strong>long、double</strong>，其他类型例如<code>int、returnAddress、refrence</code>都支持</p><h5 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h5><blockquote><p>复制栈顶一个字节长度的元素，复制后的数据重新压入栈顶</p></blockquote><p>原始操作数栈    …-&gt;value3-&gt;value2-&gt;value1</p><p>dup操作后         …-&gt;value3-&gt;value2-&gt;value1-&gt;value1</p><p>例 <code>int a = 0; a= ++a;</code> 对应字节码为 <code>dup</code></p><h5 id="dup-x1"><a href="#dup-x1" class="headerlink" title="dup_x1"></a>dup_x1</h5><blockquote><p>复制栈顶一个字节长度的元素，弹出栈顶两个字节长度元素后，压入复制的数据，再将弹出的两个字节长度元素压入栈顶</p></blockquote><p>原始操作数栈    …-&gt;value3-&gt;value2-&gt;value1</p><p>dup_x1操作后    …-&gt;value3-&gt;value1-&gt;value2-&gt;value1</p><h5 id="dup-x2"><a href="#dup-x2" class="headerlink" title="dup_x2"></a>dup_x2</h5><blockquote><p>复制栈顶一个字节长度的元素，弹出栈顶三个字节长度元素后，压入复制的数据，再将弹出的三个字节长度元素压入栈顶</p></blockquote><p>原始操作数栈    …-&gt;value3-&gt;value2-&gt;value1</p><p>dup_x2操作后    …-&gt;value1-&gt;value3-&gt;value2-&gt;value1</p><p><br></p><p>以下三个操作指令支持所有数据类型</p><h5 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h5><blockquote><p>复制栈顶两个字节长度的元素，复制后的数据重新压入栈顶</p></blockquote><p>原始操作数栈    …-&gt;value3-&gt;value2-&gt;value1</p><p>dup2操作后        …-&gt;value3-&gt;value2-&gt;value1-&gt;value2-&gt;value1</p><p>若value1为<code>long/double</code> …-&gt;value3-&gt;value2-&gt;value1-&gt;value1</p><p>例 <code>long a = 0L; a= ++a;</code> 对应字节码为 <code>dup2</code></p><h5 id="dup2-x1"><a href="#dup2-x1" class="headerlink" title="dup2_x1"></a>dup2_x1</h5><blockquote><p>复制栈顶两个字节长度的元素，弹出栈顶三个字长的数据，压入复制的数据，再将弹出的三个字长的数据压入栈顶</p></blockquote><p>原始操作数栈    …-&gt;value3-&gt;value2-&gt;value1</p><p>dup2_x1操作后  …-&gt;value2-&gt;value1-&gt;value3-&gt;value2-&gt;value1</p><p>若value1 为<code>long/double</code>     …-&gt;value3-&gt;value1-&gt;value2-&gt;value1</p><h5 id="dup2-x2"><a href="#dup2-x2" class="headerlink" title="dup2_x2"></a>dup2_x2</h5><blockquote><p>复制栈顶两个字节长度的元素，弹出栈顶四个字长的数据，压入复制的数据，再将弹出的四个字长的数据压入栈顶</p></blockquote><p>原始操作数栈    …-&gt;value4-&gt;value3-&gt;value2-&gt;value1</p><p>dup2_x2操作后  …-&gt;value2-&gt;value1-&gt;value4-&gt;value3-&gt;value2-&gt;value1</p><p>若value1、value2为<code>long/double</code>  …-&gt;value4-&gt;value3-&gt;value2-&gt;value1-&gt;value2-&gt;value1</p><h4 id="操作数栈栈顶元素交换"><a href="#操作数栈栈顶元素交换" class="headerlink" title="操作数栈栈顶元素交换"></a>操作数栈栈顶元素交换</h4><h5 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h5><blockquote><p>栈顶的两个数值互换，且不能是<strong>long、double</strong></p></blockquote><p>原始操作数栈    …-&gt;value3-&gt;value2-&gt;value1</p><p>swap操作后         …-&gt;value3-&gt;value1-&gt;value2</p><h3 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/操作指令-对象操作指令.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-对象操作指令" title="操作指令-对象操作指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>主要是操作对象（主要指类）的创建与访问，例如<code>新建对象实例，访问对象实例变量与类变量等</code></p></blockquote><h4 id="创建对象实例"><a href="#创建对象实例" class="headerlink" title="创建对象实例"></a>创建对象实例</h4><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><blockquote><p>创建新对象实例</p></blockquote><p>例 <code>String a = new String(&quot;new&quot;)</code> 对应指令为 <code>new</code></p><h4 id="访问类变量（实例变量、静态变量）"><a href="#访问类变量（实例变量、静态变量）" class="headerlink" title="访问类变量（实例变量、静态变量）"></a>访问类变量（实例变量、静态变量）</h4><h5 id="getField"><a href="#getField" class="headerlink" title="getField"></a>getField</h5><blockquote><p>从常量池中获取对象的字段，并压入栈顶</p></blockquote><p>例 <code>getField #18</code>，取出常量池中索引为18的字段</p><h5 id="putField"><a href="#putField" class="headerlink" title="putField"></a>putField</h5><blockquote><p>给从常量池中获取的对象赋值</p></blockquote><p>例 <code>putField #18</code>，给常量池索引为18的字段赋值</p><h5 id="getStatic"><a href="#getStatic" class="headerlink" title="getStatic"></a>getStatic</h5><blockquote><p>获取类的静态(static)变量，并压入栈顶</p></blockquote><p>例 <code>getStatic #19</code>，取出常量池索引为19的静态变量</p><h5 id="putStatic"><a href="#putStatic" class="headerlink" title="putStatic"></a>putStatic</h5><blockquote><p>给类的静态(static)变量进行赋值</p></blockquote><p>例 <code>putStatic #19</code>，给常量池索引为19的静态变量赋值</p><h4 id="对象类型操作"><a href="#对象类型操作" class="headerlink" title="对象类型操作"></a>对象类型操作</h4><h5 id="checkcast"><a href="#checkcast" class="headerlink" title="checkcast"></a>checkcast</h5><blockquote><p>类型转换检测</p></blockquote><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><blockquote><p>判断类型是否相符，操作数为常量池索引</p></blockquote><p>例 <code>str instanceof String</code> 对应<code>instanceof #13</code></p><h3 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/数组操作指令.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-数组操作指令" title="操作指令-数组操作指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>主要是对数组对象的操作，包括<strong>创建数组、加载数组元素、获取数组长度</strong>等</p></blockquote><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><h5 id="newarray"><a href="#newarray" class="headerlink" title="newarray"></a>newarray</h5><blockquote><p>创建数组且<strong>类型必须是基础数据类型</strong>，操作数为<strong>基础数据类型</strong></p></blockquote><p>例 <code>int[] a = new int[2]</code> 对应操作指令为 <code>newarray int</code></p><h5 id="anewarray"><a href="#anewarray" class="headerlink" title="anewarray"></a>anewarray</h5><blockquote><p>创建数组且<strong>类型为引用类型</strong>，操作数为<strong>常量池类名索引</strong></p></blockquote><p>例 <code>String[] a=new String[2]</code> 对应操作指令为 <code>anewarray #18</code></p><h5 id="multianewarray"><a href="#multianewarray" class="headerlink" title="multianewarray"></a>multianewarray</h5><blockquote><p>创建多维度的数组，操作数为<strong>常量池类名索引以及维度</strong></p></blockquote><p>例<code>int[][] a = new int[2][3]</code> 对应操作指令为 <code>multianewarray #2,2</code>代表类来自索引为2的类名以及维度为2，有两层嵌套</p><h4 id="数组元素与操作数栈交换数据"><a href="#数组元素与操作数栈交换数据" class="headerlink" title="数组元素与操作数栈交换数据"></a>数组元素与操作数栈交换数据</h4><blockquote><p>由于数组也是对象，故前缀为<code>a</code>，</p></blockquote><h5 id="X-aload"><a href="#X-aload" class="headerlink" title="(X)aload"></a>(X)aload</h5><blockquote><p>数组元素加载到操作数栈栈顶，X可以为<strong>b(byte)、c(char)、s(short)、i(int)、l(long)、f(float)、d(double)、a(refrence)</strong></p></blockquote><p>例 <code>int c = a[2]</code>，对应操作指令为</p><pre><code class="hljs java"><span class="hljs-number">41</span>: aload_0 <span class="hljs-comment">//加载数组对象</span><span class="hljs-number">42</span>: iconst_2 <span class="hljs-comment">//设置取索引为2的值</span><span class="hljs-number">43</span>: iaload <span class="hljs-comment">//获取对应值</span></code></pre><h5 id="X-astore"><a href="#X-astore" class="headerlink" title="(X)astore"></a>(X)astore</h5><blockquote><p>操作数栈的值给对应数组元素赋值，X可以为<strong>b(byte)、c(char)、s(short)、i(int)、l(long)、f(float)、d(double)、a(refrence)</strong></p></blockquote><p>例 <code>a[5] = 5</code>，对应操作指令为</p><pre><code class="hljs java">aload_0 <span class="hljs-comment">//加载数组对象</span>iconst_5 <span class="hljs-comment">//设置常量为5</span>bipush <span class="hljs-number">6</span> <span class="hljs-comment">//赋值对应元素为6</span>iastore  <span class="hljs-comment">//保存赋值</span></code></pre><h4 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h4><h5 id="arraylength"><a href="#arraylength" class="headerlink" title="arraylength"></a>arraylength</h5><blockquote><p>获取对应数组的长度，无操作数</p></blockquote><h3 id="方法操作指令"><a href="#方法操作指令" class="headerlink" title="方法操作指令"></a>方法操作指令</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/操作指令-方法操作指令.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-方法操作指令" title="操作指令-方法操作指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>主要是对方法进行操作，包括<strong>方法调用、方法返回</strong></p></blockquote><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><blockquote><p>调用类中不同的方法指令</p></blockquote><h5 id="invokevirtual"><a href="#invokevirtual" class="headerlink" title="invokevirtual"></a>invokevirtual</h5><blockquote><p>调用实例方法，操作数为<strong>常量池的索引，索引的值为 方法符号引用</strong> 属于静态分派</p></blockquote><p>例 <code>System.out.println(&quot;aaa&quot;)</code>对应操作指令为</p><pre><code class="hljs java">invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</code></pre><h5 id="invokestatic"><a href="#invokestatic" class="headerlink" title="invokestatic"></a>invokestatic</h5><blockquote><p>调用类的静态(static)方法，操作数为<strong>常量池的索引，索引的值为 方法符号引用</strong> </p></blockquote><p>例 <code>Test.test(int a,boolean b)</code> 对应操作指令为</p><pre><code class="hljs java">invokestatic  #11                 // Method test:(IZ)V</code></pre><h5 id="invokeinterface"><a href="#invokeinterface" class="headerlink" title="invokeinterface"></a>invokeinterface</h5><blockquote><p>调用接口方法，运行时搜索由特定对象所实现的接口方法，并找到合适的进行调用，操作数为<strong>常量池的索引，索引值为 接口方法符号引用</strong>。还有个<code>count</code>???</p></blockquote><p>例<code>new ArrayList&lt;String&gt;().add(&quot;sd&quot;);</code> 对应操作指令为</p><pre><code class="hljs java">invokeinterface #16,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</code></pre><h5 id="invokespecial"><a href="#invokespecial" class="headerlink" title="invokespecial"></a>invokespecial</h5><blockquote><p>调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法、私有方法、父类方法</strong>。操作数为 <strong>常量池的索引且值为 方法符号引用</strong></p></blockquote><h5 id="invokedynamic？？"><a href="#invokedynamic？？" class="headerlink" title="*invokedynamic？？"></a>*invokedynamic？？</h5><blockquote><p>Java7中引入，在Java8中允许调用</p><p>调用动态链接方法 ，用于<code>lambda</code>表达式中</p></blockquote><p>//TODO 拓展一节</p><h4 id="方法返回"><a href="#方法返回" class="headerlink" title="方法返回"></a>方法返回</h4><blockquote><p>方法的返回指令根据返回数据类型进行区分</p></blockquote><h5 id="ireturn"><a href="#ireturn" class="headerlink" title="ireturn"></a>ireturn</h5><blockquote><p>返回数据类型为 <code>boolean、byte、short、char、int</code>时调用</p></blockquote><p>例 <code>int getResult()</code>，对应操作指令为<code>ireturn</code></p><h5 id="lreturn"><a href="#lreturn" class="headerlink" title="lreturn"></a>lreturn</h5><blockquote><p>返回数据类型为<code>long</code></p></blockquote><h5 id="freturn"><a href="#freturn" class="headerlink" title="freturn"></a>freturn</h5><blockquote><p>返回数据类型为<code>float</code></p></blockquote><h5 id="dreturn"><a href="#dreturn" class="headerlink" title="dreturn"></a>dreturn</h5><blockquote><p>返回数据类型为<code>double</code></p></blockquote><h5 id="areturn"><a href="#areturn" class="headerlink" title="areturn"></a>areturn</h5><blockquote><p>返回数据类型为<code>reference</code></p></blockquote><h5 id="return"><a href="#return" class="headerlink" title="return"></a>return</h5><blockquote><p>返回<code>void</code></p></blockquote><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3>{% fullimage /images/操作指令-控制转移指令.png,操作指令-控制转移指令,操作指令-控制转移指令%}<blockquote><p>让JVM有条件或无条件的从指定位置的指令继续执行程序，而不是当前控制转移指令的下一条，从而达到<strong>控制流程</strong>目标。</p></blockquote><h4 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h4><blockquote><p>对栈顶元素进行判断，操作数为<strong>可能跳转的指令行号</strong></p></blockquote><h5 id="ifeq、ifne"><a href="#ifeq、ifne" class="headerlink" title="ifeq、ifne"></a>ifeq、ifne</h5><blockquote><p>若栈顶int元素值【=0或!=0】则跳转</p></blockquote><pre><code class="hljs java">a==<span class="hljs-number">0</span> <span class="hljs-comment">//ifne 11</span>a!=<span class="hljs-number">0</span> <span class="hljs-comment">//ifeg 11</span></code></pre><h5 id="iflt、ifle"><a href="#iflt、ifle" class="headerlink" title="iflt、ifle"></a>iflt、ifle</h5><blockquote><p>若栈顶int元素值【小于(&lt;)0或小于等于(&lt;=)0】则跳转</p></blockquote><pre><code class="hljs java">a&gt;=<span class="hljs-number">0</span> <span class="hljs-comment">//iflt 11</span>a&gt;<span class="hljs-number">0</span> <span class="hljs-comment">//ifle 11</span></code></pre><h5 id="ifgt、ifge"><a href="#ifgt、ifge" class="headerlink" title="ifgt、ifge"></a>ifgt、ifge</h5><blockquote><p>若栈顶int元素值【大于(&gt;)0或大于等于(&gt;=)0】则跳转</p></blockquote><pre><code class="hljs java">a&lt;=<span class="hljs-number">0</span> <span class="hljs-comment">//ifgt 11</span>a&lt;<span class="hljs-number">0</span> <span class="hljs-comment">//ifge 11</span></code></pre><h5 id="ifnull、ifnotnull"><a href="#ifnull、ifnotnull" class="headerlink" title="ifnull、ifnotnull"></a>ifnull、ifnotnull</h5><blockquote><p>若栈顶引用值为【==null或!=null】则跳转</p></blockquote><pre><code class="hljs java">a==<span class="hljs-keyword">null</span> <span class="hljs-comment">//ifnotnull 11</span>a!=<span class="hljs-keyword">null</span> <span class="hljs-comment">//ifnull 11</span></code></pre><h4 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h4><h5 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h5><blockquote><p>无条件跳转指定位置，操作数为<strong>指定行数</strong></p></blockquote><p>还有<code>goto_w</code>，无条件跳转不过<code>w</code>表示宽索引</p><h5 id="jsr（Java7及以后不使用）"><a href="#jsr（Java7及以后不使用）" class="headerlink" title="jsr（Java7及以后不使用）"></a>jsr（Java7及以后不使用）</h5><blockquote><p>Java 6之前 finally语句生成，跳转到子例程序</p></blockquote><h5 id="ret（Java7及以后不使用）"><a href="#ret（Java7及以后不使用）" class="headerlink" title="ret（Java7及以后不使用）"></a>ret（Java7及以后不使用）</h5><blockquote><p>Java 6之前 返回由指定局部变量所给出的指令地址</p></blockquote><h5 id="athrow"><a href="#athrow" class="headerlink" title="athrow"></a>athrow</h5><blockquote><p>显式抛出异常</p></blockquote><h4 id="复合条件跳转指令"><a href="#复合条件跳转指令" class="headerlink" title="复合条件跳转指令"></a>复合条件跳转指令</h4><h5 id="tableswitch"><a href="#tableswitch" class="headerlink" title="tableswitch"></a>tableswitch</h5><blockquote><p>通过索引访问跳转表，并跳转</p></blockquote><p>例</p><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (a) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;</code></pre><p>对应操作指令为</p><pre><code class="hljs java">tableswitch   &#123; <span class="hljs-comment">// 0 to 5</span>                      <span class="hljs-number">0</span>: <span class="hljs-number">40</span>                      <span class="hljs-number">1</span>: <span class="hljs-number">42</span>                      <span class="hljs-number">2</span>: <span class="hljs-number">44</span>                      <span class="hljs-number">3</span>: <span class="hljs-number">48</span>                      <span class="hljs-number">4</span>: <span class="hljs-number">48</span>                      <span class="hljs-number">5</span>: <span class="hljs-number">46</span>                <span class="hljs-keyword">default</span>: <span class="hljs-number">48</span>           &#125;</code></pre><p>其中源码未出现的3,4都跳转默认指令行数</p><h5 id="lookupswitch"><a href="#lookupswitch" class="headerlink" title="lookupswitch"></a>lookupswitch</h5><blockquote><p>通过键值访问跳转表，并跳转</p></blockquote><p>例</p><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (a) &#123;            <span class="hljs-keyword">case</span> -<span class="hljs-number">5</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;</code></pre><p>对应操作指令为</p><pre><code class="hljs java">lookupswitch  &#123; <span class="hljs-comment">// 4</span>                     -<span class="hljs-number">5</span>: <span class="hljs-number">44</span>                      <span class="hljs-number">1</span>: <span class="hljs-number">46</span>                      <span class="hljs-number">2</span>: <span class="hljs-number">48</span>                      <span class="hljs-number">5</span>: <span class="hljs-number">50</span>                <span class="hljs-keyword">default</span>: <span class="hljs-number">52</span>           &#125;</code></pre><blockquote><p>为何后续<code>switch</code>可以支持<code>String</code>类型，由于在字节码的过程中会被转换成<code>str.hashcode</code>，根据对应的<code>hashcode</code>进行判断。</p></blockquote><h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><blockquote><p>比较操作数栈栈顶两个元素的大小，然后根据比较结果压入操作数栈中</p></blockquote><h5 id="dcmpg、dcmpl"><a href="#dcmpg、dcmpl" class="headerlink" title="dcmpg、dcmpl"></a>dcmpg、dcmpl</h5><blockquote><p>比较栈顶两double类型值，</p><p><strong>前者大，1入栈<br>都相等，0入栈<br>后者大，-1入栈<br>存在NaN，则-1入栈</strong></p></blockquote><p>例</p><pre><code class="hljs java"><span class="hljs-keyword">double</span> da = <span class="hljs-number">1f</span>;<span class="hljs-keyword">double</span> db = <span class="hljs-number">2f</span>;<span class="hljs-keyword">double</span> dc = Double.NaN;<span class="hljs-keyword">double</span> dd = <span class="hljs-number">1f</span>;System.err.println(da&gt;db); <span class="hljs-comment">//dcmpl  (-1)  ifle</span>System.err.println(db&lt;da); <span class="hljs-comment">//dcmpg  ( 1)  ifge</span>System.err.println(da=dd); <span class="hljs-comment">//dcmpl  ( 0)  ifne</span>System.err.println(da&gt;dc); <span class="hljs-comment">//dcmpl  (-1)  ifle</span>System.err.println(da&lt;dc); <span class="hljs-comment">//dcmpg  (-1)  ifge</span></code></pre><h5 id="fcmpg、fcmpl"><a href="#fcmpg、fcmpl" class="headerlink" title="fcmpg、fcmpl"></a>fcmpg、fcmpl</h5><blockquote><p>比较栈顶两float类型值，</p><p><strong>前者大，1入栈<br>都相等，0入栈<br>后者大，-1入栈<br>存在NaN，则-1入栈</strong></p></blockquote><p>例</p><pre><code class="hljs java"><span class="hljs-keyword">float</span> fa = <span class="hljs-number">1f</span>;<span class="hljs-keyword">float</span> fb = <span class="hljs-number">2f</span>;<span class="hljs-keyword">float</span> fc = Float.NaN;System.err.println(fa&gt;fb); <span class="hljs-comment">//fcmpl  (-1)  ifle</span>System.err.println(fa&lt;fb); <span class="hljs-comment">//fcmpg  (-1)  ifge</span>System.err.println(fb&lt;fa); <span class="hljs-comment">//fcmpg  ( 1)  ifge</span>System.err.println(fa&gt;fc); <span class="hljs-comment">//fcmpl  (-1)  ifle</span>System.err.println(fa&lt;fc); <span class="hljs-comment">//fcmpg  (-1)  ifge</span></code></pre><h5 id="lcmp"><a href="#lcmp" class="headerlink" title="lcmp"></a>lcmp</h5><blockquote><p>比较栈顶两long类型值</p><p><strong>前者大，1入栈<br>都相等，0入栈<br>后者大，-1入栈</strong></p></blockquote><p>上述的比较指令是只针对于<code>float、double、long</code>型的数据，剩下的还有<code>int、refrence</code></p><h5 id="if-icmpeq、if-icmpne"><a href="#if-icmpeq、if-icmpne" class="headerlink" title="if_icmpeq、if_icmpne"></a>if_icmpeq、if_icmpne</h5><blockquote><p>栈顶两int类型值是否相等</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">int</span> a =<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b =<span class="hljs-number">2</span>;a==b <span class="hljs-comment">//if_icmpne 11</span>a!=b <span class="hljs-comment">//if_icmpeq 11</span></code></pre><h5 id="if-icmplt、if-icmple"><a href="#if-icmplt、if-icmple" class="headerlink" title="if_icmplt、if_icmple"></a>if_icmplt、if_icmple</h5><blockquote><p>栈顶两int类型是否前者【小于(&lt;)或小于等于(&lt;=)】后者</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">int</span> a =<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b =<span class="hljs-number">2</span>;a&gt;=b <span class="hljs-comment">//if_icmplt 11</span>a&gt;b <span class="hljs-comment">//if_icmple 11</span></code></pre><h5 id="if-icmpgt、if-icmpge"><a href="#if-icmpgt、if-icmpge" class="headerlink" title="if_icmpgt、if_icmpge"></a>if_icmpgt、if_icmpge</h5><blockquote><p>栈顶两int类型是否前者【大于(&gt;)或大于等于(&gt;=)】后者</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">int</span> a =<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> b =<span class="hljs-number">2</span>;a&lt;=b <span class="hljs-comment">//if_icmplt 11</span>a&lt;b <span class="hljs-comment">//if_icmple 11</span></code></pre><h5 id="if-acmpeq、if-acmpne"><a href="#if-acmpeq、if-acmpne" class="headerlink" title="if_acmpeq、if_acmpne"></a>if_acmpeq、if_acmpne</h5><blockquote><p>栈顶两引用类型值是否相等</p></blockquote><pre><code class="hljs java">String sa = <span class="hljs-string">"1"</span>;String sb = <span class="hljs-string">"2"</span>;sa==sb <span class="hljs-comment">//if_acmpne 11</span>sa!=sb <span class="hljs-comment">//if_acmpeq 11</span></code></pre><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/操作指令-类型转换指令.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-类型转换指令" title="操作指令-类型转换指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>对两种不同类型的数值进行转换。<strong>一般用于实现用户代码中的显式类型转换操作，或者用来解决字节码指令集不完备的问题（例如byte、short、char、boolean需要转换为int）。</strong></p></blockquote><h4 id="宽化类型转换"><a href="#宽化类型转换" class="headerlink" title="宽化类型转换"></a>宽化类型转换</h4><blockquote><p><strong>存储长度由小到大转换，无需显式的转换指令，并且是安全的操作。</strong></p><p>转换范围由小到大为：<strong>int &lt;&lt; long &lt;&lt; float &lt;&lt; double</strong></p></blockquote><h5 id="i2l、i2f、i2d"><a href="#i2l、i2f、i2d" class="headerlink" title="i2l、i2f、i2d"></a>i2l、i2f、i2d</h5><blockquote><p><code>int</code>转换为<code>long、float、double</code></p></blockquote><h5 id="l2f、l2d"><a href="#l2f、l2d" class="headerlink" title="l2f、l2d"></a>l2f、l2d</h5><blockquote><p><code>long</code>转换为<code>float、double</code></p></blockquote><h5 id="f2d"><a href="#f2d" class="headerlink" title="f2d"></a>f2d</h5><blockquote><p><code>float</code>转换为<code>double</code></p></blockquote><h4 id="窄化类型转换"><a href="#窄化类型转换" class="headerlink" title="窄化类型转换"></a>窄化类型转换</h4><blockquote><p><strong>存储长度由大到小转换，需要显式的调用转换指令，很可能导致精度丢失。</strong></p><p>转换范围由大到小为：<strong>double &gt;&gt; float &gt;&gt; long &gt;&gt; int</strong></p></blockquote><h5 id="d2f、d2l、d2i"><a href="#d2f、d2l、d2i" class="headerlink" title="d2f、d2l、d2i"></a>d2f、d2l、d2i</h5><blockquote><p><code>double</code>转换为<code>float、long、int</code></p></blockquote><h5 id="f2l、f2i"><a href="#f2l、f2i" class="headerlink" title="f2l、f2i"></a>f2l、f2i</h5><blockquote><p><code>float</code>转换为<code>long、int</code></p></blockquote><h5 id="l2i"><a href="#l2i" class="headerlink" title="l2i"></a>l2i</h5><blockquote><p><code>long</code>转换为<code>int</code></p></blockquote><h5 id="i2b、i2s、i2c"><a href="#i2b、i2s、i2c" class="headerlink" title="i2b、i2s、i2c"></a>i2b、i2s、i2c</h5><blockquote><p><code>int</code>转换为<code>byte、short、char</code>。通过将栈顶<code>int</code>类型截断成对应类型，然后将对应类型通过<code>符号拓展</code>成int型。</p></blockquote><p><code>i2b</code>：<code>byte</code>占8位，就是取出int转换二进制后的低八位的补码即为结果</p><p><code>i2s</code>：<code>short</code>占16位，取出int转换二进制后的低16位的补码即为结果</p><p><code>i2c</code>：数字转换字符后，会当做<code>ASCII</code>编码来处理</p><blockquote><p>当遭遇到<code>Float.NaN或者Double.NaN</code>就转换为对应类型的0！</p></blockquote><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/操作指令-运算指令.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-运算指令" title="操作指令-运算指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>对操作数栈的两个数值进行运算，并将结果重新存入操作数栈中。</p><p>只支持<strong>整数类型与浮点类型</strong>数据的运算。</p></blockquote><h4 id="通用运算指令"><a href="#通用运算指令" class="headerlink" title="通用运算指令"></a>通用运算指令</h4><blockquote><p>包括一些<strong>加、减、乘、除、求余、取反</strong>等操作</p></blockquote><h5 id="Xadd"><a href="#Xadd" class="headerlink" title="Xadd"></a>Xadd</h5><blockquote><p>运算指令 ——加法，栈顶两数相加，结果入栈</p><p>X为<code>i(int)、l(long)，f(float)、d(double)</code></p></blockquote><h5 id="Xsub"><a href="#Xsub" class="headerlink" title="Xsub"></a>Xsub</h5><blockquote><p>运算指令 ——减法，栈顶两数相减，结果入栈</p><p>X为<code>i(int)、l(long)，f(float)、d(double)</code></p></blockquote><h5 id="Xmul"><a href="#Xmul" class="headerlink" title="Xmul"></a>Xmul</h5><blockquote><p>运算指令 ——乘法，栈顶两数相乘，结果入栈</p><p>X为<code>i(int)、l(long)，f(float)、d(double)</code></p></blockquote><h5 id="Xdiv"><a href="#Xdiv" class="headerlink" title="Xdiv"></a>Xdiv</h5><blockquote><p>运算指令 ——除法，栈顶两数相除，结果入栈</p><p>X为<code>i(int)、l(long)，f(float)、d(double)</code></p></blockquote><h5 id="Xrem"><a href="#Xrem" class="headerlink" title="Xrem"></a>Xrem</h5><blockquote><p>运算指令 ——求余，栈顶两数取模，结果入栈</p><p>X为<code>i(int)、l(long)，f(float)、d(double)</code></p></blockquote><p>例<code>a % b</code> 对应操作指令为<code>rem</code></p><h5 id="Xneg"><a href="#Xneg" class="headerlink" title="Xneg"></a>Xneg</h5><blockquote><p>运算指令 ——取反，栈顶数据取反，结果入栈</p><p>X为<code>i(int)、l(long)，f(float)、d(double)</code></p></blockquote><h4 id="其他运算指令"><a href="#其他运算指令" class="headerlink" title="其他运算指令"></a>其他运算指令</h4><blockquote><p>包括一些<strong>移位运算、按位布尔运算、自增运算</strong></p></blockquote><h5 id="Xshl、Xshr、Xushr"><a href="#Xshl、Xshr、Xushr" class="headerlink" title="Xshl、Xshr、Xushr"></a>Xshl、Xshr、Xushr</h5><blockquote><p>运算指令——移位运算，栈顶数据进行移位运算结果入栈</p><p>X为<code>i(int)、l(long)</code></p></blockquote><p><code>Xshl</code>：左移运算，<strong>丢弃最高位，往左移位，右侧空位补0</strong></p><p>例 <code>5 &lt;&lt; 2</code>，5 转换二进制为<code>0101</code> 向左移2位后，得到<code>01 0100</code>值为20</p><p><code>Xshr</code>：算术右移运算，<strong>丢弃最低位，往右移位，左侧空位补符号位</strong></p><p>例<code>5&gt;&gt;2</code>，5 转换二进制为<code>0101</code> ，向右移2位后，得到<code>0001</code>值为1</p><p><code>Xushr</code>：无符号右移，逻辑右移运算，<strong>丢弃最低位，向右移位，左边空出来的位置补0</strong></p><p>例<code>-7&gt;&gt;&gt;2</code>，-7转换二进制为<code>11111111 11111111 11111111 11111001</code>，右移2位得到<code>00111111 11111111 11111111 11111110</code>得到<code>1073741822</code></p><p><strong>在不大于自身数值类型最大位数的移位时，一个数左移n位，就是将这个数乘以2的n次幂；一个数右移n位，就是将这个数除2的n次幂，然后取整。</strong></p><blockquote><p>若需要移位的数值大于32，等价于移位数和32取余得到的结果为移位数。</p></blockquote><h5 id="Xand、Xor、Xxor"><a href="#Xand、Xor、Xxor" class="headerlink" title="Xand、Xor、Xxor"></a>Xand、Xor、Xxor</h5><blockquote><p>运算指令——按位布尔运算，栈顶数据进行按位运算后结果入栈</p><p>X为<code>i(int)、l(long)</code></p></blockquote><p><code>Xand</code>：按位与运算，<strong>都为1就是1，否则为0——同1为1</strong></p><p>例<code>4 &amp; 2</code>，4的二进制为<code>0100</code>，2的二进制为<code>0010</code>，结果为<code>0000</code>得0</p><p><code>Xor</code>：按位或运算，<strong>有1得1，否则为0——有1为1</strong></p><p>例<code>4 | 2</code>，4的二进制为<code>0100</code>，2的二进制为<code>0010</code>，结果为<code>0110</code>得6</p><p><code>Xxor</code>：按位异或运算，<strong>数值相同为0，否则为1——同0异1</strong></p><p>例<code>4 ^ 2</code>，4的二进制为<code>0100</code>，2的二进制为<code>0010</code>，结果为<code>0110</code>得6</p><h5 id="iinc"><a href="#iinc" class="headerlink" title="iinc"></a>iinc</h5><blockquote><p>运算指令——自增运算。 指定数据进行自增后结果入栈。</p><p>操作数有两个，一个是操作数栈的索引(对应需要自增的数值)，一个是自增的步长(一次加多少)</p></blockquote><p>例<code>b+=2</code>，对应操作指令为<code>iinc 1,2</code>，<code>1</code>对应的是操作数栈索引，<code>2</code>对应的是自增步长</p><blockquote><p>还有非运算(<code>~</code>)，不过字节码中转换成为了<code>x xor -1</code></p></blockquote><p>例<code>~4</code> ，即<code>4 xor -1</code>，4的二进制为<code>0000 0100</code>，-1的二进制为<code>1111 1111</code>，结果为<code>1111 1011</code>再取一次补码得到<code>1111 1101</code>得到<code>-5</code></p><h3 id="同步与异常指令"><a href="#同步与异常指令" class="headerlink" title="同步与异常指令"></a>同步与异常指令</h3><h4 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h4><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/操作指令-同步指令.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-同步指令" title="操作指令-同步指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>同步指令集序列，由<code>synchronized语句块</code>进行控制</p></blockquote><h5 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h5><blockquote><p>进入并获得对象监视锁(<strong>加锁</strong>)</p></blockquote><h5 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h5><blockquote><p>释放并退出对象监视锁(<strong>释放锁</strong>)</p></blockquote><p><code>synchronized</code>锁分为两种：<strong>对象锁</strong>、<strong>类锁</strong>。</p><p>未被锁定的对象的该计数器为0，当一个线程获得锁（执行<code>monitorenter</code>）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行<code>monitorexit</code>指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</p><p><code>synchronized</code>修饰方法时，通过<code>ACC_SYNCHRONIZED</code>进行隐式加锁。</p><h4 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h4><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/操作指令-异常指令.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-异常指令" title="操作指令-异常指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>显式抛出异常以及<code>throw</code>语句都是通过异常指令实现</p></blockquote><h5 id="athrow-1"><a href="#athrow-1" class="headerlink" title="athrow"></a>athrow</h5><blockquote><p>显示的抛出异常</p><p><em>在JVM中，<code>catch</code>代码不由字节码指令来实现，需要通过异常表(Exception Table)表示</em></p></blockquote><p>关于<code>finally</code>块中的指令采用的是每个分支代码中冗余一份，就是<code>try</code>，n个<code>catch</code>方法中字节码部分都会冗余finally的代码。</p><p>如果出现未显式捕获的异常则通过<code>athrow</code>指令抛出。如果出现已声明捕获的异常，在前面的字节码中就会执行，不会走到<code>athrow</code>指令行数。</p><h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><h3 id="堆、栈的区别"><a href="#堆、栈的区别" class="headerlink" title="堆、栈的区别"></a>堆、栈的区别</h3><blockquote><p>最主要区别是：</p><p><code>栈内存</code>用来存储 <strong>局部变量和方法调用</strong></p><p><code>堆内存</code>用来存储 <strong>Java中的对象。无论是成员变量、局部变量、类变量 他们指向的对象都存储在堆内存中。</strong></p><p>额外补充：如果局部变量是 基本数据类型 ，那么局部变量的值 直接存储于栈中；如果局部变量是 对象 ，那么该变量的引用存在栈中，但是对象存储于堆中。</p></blockquote><ul><li><code>栈内存</code> 线程私有，<code>堆内存</code> 所有线程共享</li><li><code>栈内存</code> 抛出<code></code>StackOverflowError<code>，</code>堆内存<code>抛出</code>OutOfMemoryError`</li></ul><h3 id="栈的组成"><a href="#栈的组成" class="headerlink" title="栈的组成"></a>栈的组成</h3><blockquote><p>栈 主要用于存储 <strong>栈帧</strong>，栈帧也叫<code>过程活动记录</code>，一种用于支持JVM调用/执行程序方法的数据结构，每个方法被调用时都会创建一个栈帧存储所需的数据信息，<code>栈帧伴随方法的调用而创建，执行结束而销毁</code>。</p><p><strong>每一个方法从调用开始到执行完成都对应着一个栈帧在JVM里面从入栈到出栈的过程。</strong></p></blockquote><p><code>栈帧</code>主要存储了以下四部分：</p><ul><li><p>局部变量表：<code>用于存储方法参数和定义在方法体的局部变量，这些包含了各类原始数据类型、对象引用、returnAddress类型。</code>局部变量表的大小在编译期就已经确定，对应的是字节码中的<code>Code-LocalVariableTable</code>属性。</p><p>局部变量表中最小的存储单元是<code>slot</code>，除了<code>double,float</code>占用两个<code>slot</code>，其他都是一个<code>slot</code>。</p><p><code>slot</code>是可以被重用的，用于<code>节省栈帧的占用空间</code>，当某个变量执行完毕时，它对应的<code>slot</code>就可以被其他变量所使用。</p></li><li><p>操作数栈：<code>通过入栈、出栈操作来完成一次数据访问。本质是个**临时数据存储区域**。</code>操作数栈的大小在编译期就已经确定，对应的是字节码中的<code>Code-maxStack</code></p><blockquote><p>当一个方法开始执行时，操作数栈为空，在执行过程中由于<code>出栈、入栈</code>操作，往操作数栈中写入和提取内容。</p></blockquote></li><li><p>动态链接：<code>表示指向运行时常量池中该栈帧所属方法的引用，为了支持当前方法的代码能够实现 动态连接</code>。主要用于<code>将编译期无法被确定的方法调用，在运行期符号引用转换为调用方法的直接引用</code>。</p><ul><li>静态链接：被调用的目标方法在编译期可知，且运行期保持不变时，那么这种情况下调用方法的符号引用转换为直接引用的过程为静态链接。</li></ul><blockquote><p>两者主要区别在于：</p><ul><li>静态链接可以在类加载的解析阶段（编译期）将符号引用转为直接引用</li><li>动态链接在每一次运行时期（运行期）将符号引用转为直接引用</li></ul></blockquote></li><li><p>方法返回值：<code>记录方法被调用的位置，可以在方法执行结束后回到被调用处继续向下执行</code>。</p><p>有两种方式可以退出方法调用：</p><ul><li><p>正常调用：执行引擎遇到了返回的字节码指令(例如<code>ireturn(int,boolean,byte,short,char)、lreturn(long)、freturn(float)、dreturn(double)、areturn(refrence)，return(void)</code>)，这时将返回值传递给上层的方法调用者。</p></li><li><p>异常调用：在执行过程中遇到了异常，并且没有处理该异常，就会导致方法退出并且不会返回值。</p></li></ul><p>一般方法正常退出该值为<code>调用者的PC计数器的值</code>。</p></li></ul><h3 id="零位拓展与符号位拓展"><a href="#零位拓展与符号位拓展" class="headerlink" title="零位拓展与符号位拓展"></a>零位拓展与符号位拓展</h3><p>符号位拓展</p><blockquote><p>需要使用更多内存存储一个有符号数时，需要保持符号位一直在第一位。</p><p>当对一个负数进行符号位拓展时，<strong>把拓展之后数的高位全部设置为1</strong>；</p><p>例如二进制表示-1，10000001，需要使用十六位则表示为 1111111110000001，高位全补1</p><p>当对一个正数进行符号位拓展时，<strong>把拓展之后数的高位全部设置为0</strong>；</p><p>例如二进制表示1，00000001，需要使用十六位则表示为 0000000000000001，高位全补0</p></blockquote><p>零位拓展</p><blockquote><p>无论高位多少，拓展后全补0</p></blockquote><p><strong>有符号数向其他类型进行转换时，需要用到符号位拓展；无符号数向其他类型进行转换时，使用零位拓展。</strong></p><h3 id="二进制相关知识"><a href="#二进制相关知识" class="headerlink" title="二进制相关知识"></a>二进制相关知识</h3><p><code>原码</code>：对于二进制值，最高位为符号位，0表示正数，1表示负数，剩余部分表示正值。</p><p><code>补码</code>：对于二进制值，正数的补码为本身；负数的补码除符号位按位取反，末位加一。</p><p><code>反码</code>：对于二进制值，正数的反码为本身；负数的反码除符号位按位取反。</p><p><strong>负数的二进制为 正数的补码= 正数的反码+1</strong></p><p><strong>补码还原原码为 补码的补码为原码</strong></p><p>例 <code>byte a = (byte)300;</code> 按照上述规则</p><ul><li>300转换二进制为<code>01 1001 0000</code></li><li>截取低八位为<code>1001 0000</code></li><li>转换补码为 <code>1111 0000</code>为<code>-112</code></li></ul><table><thead><tr><th>基本类型</th><th>占字节数</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>boolean</td><td></td><td></td><td></td></tr><tr><td>char</td><td>16bit</td><td></td><td></td></tr><tr><td>byte</td><td>8bit</td><td>-2^7</td><td>2^7-1</td></tr><tr><td>short</td><td>16bit</td><td>-2^15</td><td>2^15-1</td></tr><tr><td>int</td><td>32bit</td><td>-2^31</td><td>2^31-1</td></tr><tr><td>long</td><td>64bit</td><td>-2^63</td><td>2^63-1</td></tr><tr><td>float</td><td>32bit</td><td>IEEE754</td><td>IEEE754</td></tr><tr><td>double</td><td>64bit</td><td>IEEE754</td><td>IEEE754</td></tr><tr><td>void</td><td>-</td><td></td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://gityuan.com/2015/10/24/jvm-bytecode-grammar/" target="_blank" rel="noopener">字节码指令</a></p><p><a href="http://www.blogjava.net/DLevin/archive/2011/09/13/358497.html" target="_blank" rel="noopener">Java二进制指令代码解析</a></p><p><a href="https://www.cnblogs.com/noteless/p/9556928.html" target="_blank" rel="noopener">java虚拟机 JVM字节码 指令集 bytecode 操作码 指令分类用法 助记符</a></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10.1.9.monitorenter" target="_blank" rel="noopener">Jvm官方文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Dex文件学习</title>
    <link href="/2019/09/24/Android-Dex%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/09/24/Android-Dex%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<!--https://source.android.com/devices/tech/dalvik/dex-format dex组成 dex如何转换机器码 dex到odex过程 dex2oat过程分析--><h2 id="Dex文件"><a href="#Dex文件" class="headerlink" title="Dex文件"></a>Dex文件</h2><h2 id="Dex转换过程"><a href="#Dex转换过程" class="headerlink" title="Dex转换过程"></a>Dex转换过程</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://source.android.com/devices/tech/dalvik/dex-format" target="_blank" rel="noopener">Android Developer Dex文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java字节码学习</title>
    <link href="/2019/09/24/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/09/24/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<!-- https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html https://juejin.im/post/5d884c766fb9a06ae76444dc https://www.cnblogs.com/zzlove2018/p/9097885.html --><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/字节码结构大纲.png" srcset="/img/loading.gif" class="full-image" alt="字节码结构大纲" title="字节码结构大纲"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><a id="more"></a><blockquote><p>Java的最大特性——<strong>一次编译，到处运行</strong>。Java的<code>跨平台性</code>非常强大，如此强大的<code>跨平台性</code>主要依赖了两部分：<strong>JVM（执行器）</strong>、<strong>字节码</strong>。</p><p><code>JVM</code>：主要是翻译功能，将<code>字节码</code>翻译成对应平台的计算机指令。</p><p><code>字节码</code>：Java源代码拓展名为<code>.java</code>经过编译后变成<code>.class</code>文件，该文件中包含的内容就是<code>字节码</code>。</p><p>现在大热的<code>Kotlin</code>也是通过最终编译成<code>字节码</code>实现了与Java的兼容性。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Java运行流程.png" srcset="/img/loading.gif" class="full-image" alt="字节码执行过程" title="字节码执行过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>字节码</code>由<code>十六进制值</code>组成，JVM以字节为单位进行读取。如上图所示，通过Java编译器(<code>javac</code>)编译后得到了<code>.class</code>文件，里面包含的就是字节码，可通过<code>javap -verbose</code>获得完整字节码文件。</p><p>获得字节码文件后，就需要交由JVM进行加载。</p><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><a href="/2018/04/12/JVM相关及其拓展-二/" title="JVM相关及其拓展(二) -- 虚拟机类加载机制">JVM相关及其拓展(二) -- 虚拟机类加载机制</a><h2 id="字节码结构分析"><a href="#字节码结构分析" class="headerlink" title="字节码结构分析"></a>字节码结构分析</h2><p>先编写一个简单的Java文件，用以分析字节码的基本结构，后续通过拓展方法来展现其他字节码结构。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BytecodeDemo</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        System.out.println(<span class="hljs-string">"Hello World"</span>);    &#125;&#125;</code></pre><p>通过<code>javac</code>编译该类，得到<code>BytecodeDemo.class</code></p><p>使用例如<code>010Editor</code>或者<code>VSCode(安装hexdump for VSCode插件)</code>就可以查看<code>.class</code>文件原始代码。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/BytecodeDemo字节码.png" srcset="/img/loading.gif" class="full-image" alt="字节码" title="字节码"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>图片中就是一堆十六进制数并按字节为单位进行分割。这些十六进制符号长串是遵守<a href="https://github.com/waylau/java-virtual-machine-specification" target="_blank" rel="noopener">Java虚拟机规范</a>的。</p><p>下列结构全部是有规范的，此处规范<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">参考网址</a></p><h3 id="魔数-magic"><a href="#魔数-magic" class="headerlink" title="魔数(magic)"></a>魔数(magic)</h3><blockquote><p>占4个字节(u4)，且为固定值<strong>0xCAFEBABE</strong>。用于校验字节码文件是否符合虚拟机规范，符合继续执行。</p></blockquote><h3 id="版本号-version"><a href="#版本号-version" class="headerlink" title="版本号(version)"></a>版本号(version)</h3><h4 id="次版本号-minor-version"><a href="#次版本号-minor-version" class="headerlink" title="次版本号(minor_version)"></a>次版本号(minor_version)</h4><blockquote><p>占两个字节(u2)，表示<strong>生成字节码文件的次版本号</strong>。</p></blockquote><p>上图中为<code>0x0000</code></p><h4 id="主版本号-major-version"><a href="#主版本号-major-version" class="headerlink" title="主版本号(major_version)"></a>主版本号(major_version)</h4><blockquote><p>占两个字节(u2)，表示<strong>编译该字节码文件的Java版本</strong>，<code>低版本的虚拟机是无法运行高版本的字节码文件，但高版本虚拟机是兼容低版本编译的字节码文件。</code></p></blockquote><p>上图中为<code>0x0034</code>。对应实际的Java版本就为<code>JDK 1.8</code></p><p>查询本机Java版本号为<code>java version &quot;1.8.0_181&quot;</code>符合上述描述。</p><h3 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="*常量池(constant_pool)"></a>*常量池(constant_pool)</h3><h4 id="常量池数-constant-pool-count"><a href="#常量池数-constant-pool-count" class="headerlink" title="常量池数(constant_pool_count)"></a>常量池数(constant_pool_count)</h4><blockquote><p>占两个字节(u2)，表示<strong>常量池中常量的数目</strong></p></blockquote><p>上图中为<code>0x0026</code>，转换得到<code>38</code>。实际上常量数目为<code>37</code>。由于特殊的规定，第0位可以表示<strong>类或接口中未出现的引用</strong>。</p><h4 id="常量池数组-constant-pool"><a href="#常量池数组-constant-pool" class="headerlink" title="*常量池数组(constant_pool[])"></a>*常量池数组(constant_pool[])</h4><p>跟在<code>常量池数(0x0026)</code>后面的就是<code>常量池数组</code></p><blockquote><p>由<code>constant_pool_count-1</code>个<code>cp_info</code>结构组成，一个<code>cp_info</code>对应一个常量，规范规定了总共有14种类型。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//cp_info结构</span>cp_info&#123;   u1 tag;   u1 info[];&#125;</code></pre><p>共14种类型如下：</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/常量池类型.png" srcset="/img/loading.gif" class="full-image" alt="常量池结构" title="常量池结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>BytecodeDemo</code>字节码解析出的常量池数据如下：</p><pre><code class="hljs java">Constant pool:   #1 = Methodref          #12.#41        // java/lang/Object."&lt;init&gt;":()V   #2 = Fieldref           #11.#42        // BytecodeDemo.a:I   #3 = Fieldref           #43.#42        // LruCache.a:I   #4 = Fieldref           #11.#44        // BytecodeDemo.b:I   #5 = Fieldref           #11.#45        // BytecodeDemo.c:I   #6 = Fieldref           #46.#47        // java/lang/System.out:Ljava/io/PrintStream;   #7 = String             #48            // Hello World   #8 = Methodref          #49.#50        // java/io/PrintStream.println:(Ljava/lang/String;)V   #9 = Methodref          #11.#51        // BytecodeDemo.getResult:(II)I  #10 = Methodref          #12.#52        // java/lang/Object.clone:()Ljava/lang/Object;  #11 = Class              #53            // BytecodeDemo  #12 = Class              #54            // java/lang/Object  #13 = Class              #55            // java/lang/Cloneable  #14 = Class              #56            // java/io/Serializable  #15 = Utf8               a  #16 = Utf8               I  #17 = Utf8               b  #18 = Utf8               c  #19 = Utf8               &lt;init&gt;  #20 = Utf8               ()V  #21 = Utf8               Code  #22 = Utf8               LineNumberTable  #23 = Utf8               LocalVariableTable  #24 = Utf8               this  #25 = Utf8               LBytecodeDemo;  #26 = Utf8               main  #27 = Utf8               ([Ljava/lang/String;)V  #28 = Utf8               args  #29 = Utf8               [Ljava/lang/String;  #30 = Utf8               getResult  #31 = Utf8               (II)I  #32 = Utf8               x  #33 = Utf8               y  #34 = Utf8               test  #35 = Utf8               clone  #36 = Utf8               ()Ljava/lang/Object;  #37 = Utf8               Exceptions  #38 = Class              #57            // java/lang/CloneNotSupportedException  #39 = Utf8               SourceFile  #40 = Utf8               BytecodeDemo.java  #41 = NameAndType        #19:#20        // "&lt;init&gt;":()V  #42 = NameAndType        #15:#16        // a:I  #43 = Class              #58            // LruCache  #44 = NameAndType        #17:#16        // b:I  #45 = NameAndType        #18:#16        // c:I  #46 = Class              #59            // java/lang/System  #47 = NameAndType        #60:#61        // out:Ljava/io/PrintStream;  #48 = Utf8               Hello World  #49 = Class              #62            // java/io/PrintStream  #50 = NameAndType        #63:#64        // println:(Ljava/lang/String;)V  #51 = NameAndType        #30:#31        // getResult:(II)I  #52 = NameAndType        #35:#36        // clone:()Ljava/lang/Object;  #53 = Utf8               BytecodeDemo  #54 = Utf8               java/lang/Object  #55 = Utf8               java/lang/Cloneable  #56 = Utf8               java/io/Serializable  #57 = Utf8               java/lang/CloneNotSupportedException  #58 = Utf8               LruCache  #59 = Utf8               java/lang/System  #60 = Utf8               out  #61 = Utf8               Ljava/io/PrintStream;  #62 = Utf8               java/io/PrintStream  #63 = Utf8               println  #64 = Utf8               (Ljava/lang/String;)V</code></pre><h5 id="方法符号引用-CONSTANT-Methodref-info"><a href="#方法符号引用-CONSTANT-Methodref-info" class="headerlink" title="方法符号引用(CONSTANT_Methodref_info)"></a>方法符号引用(CONSTANT_Methodref_info)</h5><blockquote><p>可用于表示<strong>方法信息包含调用类、名称，入参及返回值类型</strong></p><p>由三部分组成：</p><p>tag(偏移地址): 占1字节 <strong>0x0A</strong></p><p>index(类或接口描述符索引) : 占2字节 例<code>00 07</code></p><p>index(名称和类型描述符索引)：占2字节 例<code>00 17</code></p></blockquote><p>字节码文件解析出的整段格式为 <code>0A 00 07 00 17</code></p><p>对应常量池 就为 #7，#23 最终执行的是<code>BytecodeDemo</code>初始化方法</p><h5 id="类或接口符号引用-CONSTANT-Class-info"><a href="#类或接口符号引用-CONSTANT-Class-info" class="headerlink" title="类或接口符号引用(CONSTANT_Class_info)"></a>类或接口符号引用(CONSTANT_Class_info)</h5><blockquote><p>可用于表示<strong>类的全限定名</strong></p><p>由两部分组成：</p><p>tag(偏移地址): 占1字节 <strong>0x07</strong></p><p>index(全限定名常量项索引) : 占2字节 例<code>00 1E</code></p></blockquote><p>字节码文件解析出的整段格式为 <code>07 00 1E</code></p><p>对应常量池 就为 #31 指向<code>java/lang/Object</code></p><h5 id="名称和类型描述符索引-CONSTANT-NameAndType-info"><a href="#名称和类型描述符索引-CONSTANT-NameAndType-info" class="headerlink" title="名称和类型描述符索引(CONSTANT_NameAndType_info)"></a>名称和类型描述符索引(CONSTANT_NameAndType_info)</h5><blockquote><p>可用于表示<strong>方法的名称、入参及返回值类型</strong></p><p>由三部分组成：</p><p>tag(偏移地址): 占1字节 <strong>0x0C</strong></p><p>index(字段或方法 名称常量项索引–常量信息描述符索引) : 占2字节 例<code>00 0A</code></p><p>index(字段或方法 描述符索引–常量信息描述符索引)：占2字节 例<code>00 0B</code></p></blockquote><p>字节码文件解析出的整段格式为 <code>0C 00 0A 00 0B</code></p><p>对应常量池为 #10 #11 表示 <code>&lt;init&gt; V</code></p><h5 id="常量信息描述符索引-CONSTANT-Utf8-info"><a href="#常量信息描述符索引-CONSTANT-Utf8-info" class="headerlink" title="常量信息描述符索引(CONSTANT_Utf8_info)"></a>常量信息描述符索引(CONSTANT_Utf8_info)</h5><blockquote><p>可用于表示：<strong>文本字符串、类或接口全限定名、字段名称和描述符，方法名称及描述符等常量信息。</strong></p><p>由三部分组成：</p><p>tag(偏移地址): 占1字节 <strong>0x01</strong></p><p>length(字符串长度)：占2字节</p><p>bytes(字符串内容)：占<code>length</code>字节</p></blockquote><p>字节码文件解析出的整段格式为 <code>01 00 0B 48 65 6C 6C 6F 20 57 6F 72 6C 64</code></p><p>字符串长度为11位，对应内容为<code>Hello World</code></p><h5 id="参数信息描述符索引-CONSTANT-Fieldref-info"><a href="#参数信息描述符索引-CONSTANT-Fieldref-info" class="headerlink" title="参数信息描述符索引(CONSTANT_Fieldref_info)"></a>参数信息描述符索引(CONSTANT_Fieldref_info)</h5><blockquote><p>可用于表示<strong>类中的全局变量以及引用其他类中的参数信息</strong></p><p>由三部分组成：</p><p>tag(偏移地址): 占1字节 <strong>0x09</strong></p><p>index(类或接口描述符索引)：占2字节 例<code>00 06</code></p><p>index(名称和类型描述符索引)：占2字节 例<code>00 18</code></p></blockquote><p>字节码文件解析出的整段格式为<code>09 00 06 00 18</code></p><p>对应内容为：<code>ByteDemo.a(I)</code></p><h3 id="类访问标志-access-flags"><a href="#类访问标志-access-flags" class="headerlink" title="类访问标志(access_flags)"></a>类访问标志(access_flags)</h3><blockquote><p>占2字节，紧随<code>常量池</code>结构。可用于<strong>表示类或者接口层次的访问信息——Class是类还是接口，是否定义为public，是否为abstract类型。</strong></p></blockquote><p>具体的标志位以及标志描述如下：</p><table><thead><tr><th>类修饰标志</th><th>标志值</th><th>描述</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public类型</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>private类型</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>protected类型</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>static类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>final类型，表示类不允许被继承</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用<code>invokespecail</code>字节码指令</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>表示该class为一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>表示抽象类</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>这个类不是由用户代码生成</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>表示为注解类型</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>表示为枚举类型</td></tr></tbody></table><p><strong>实际的访问标志多是由上述几个标志进行<code>或运算</code>组合而成。</strong></p><p>字节码文件紧随常量池数组后的为 <code>0x0021</code>，在上表中无法找出对应的标志，结果是由<code>ACC_PUBLIC，ACC_SUPER</code>组合得到。</p><p>当前对应的是类所设置的访问标志，后面会讲到<code>参数(field_info) 、方法(method_info)</code>中的访问标志，与类中会有些许不同。</p><h3 id="当前类索引-this-class"><a href="#当前类索引-this-class" class="headerlink" title="当前类索引(this_class)"></a>当前类索引(this_class)</h3><blockquote><p>占2个字节，指向类的全限定名</p></blockquote><p>字节码文件解析出<code>00 06</code>，指向了#6 BytecodeDemo</p><h3 id="父类索引-super-class"><a href="#父类索引-super-class" class="headerlink" title="父类索引(super_class)"></a>父类索引(super_class)</h3><blockquote><p>占2个字节，指向父类的全限定名</p></blockquote><p>字节码文件解析出<code>00 07</code>，指向了#7 java/lang/Object</p><h3 id="接口索引-interfaces"><a href="#接口索引-interfaces" class="headerlink" title="接口索引(interfaces)"></a>接口索引(interfaces)</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/字节码-接口索引结构.png" srcset="/img/loading.gif" class="full-image" alt="字节码-接口索引结构" title="字节码-接口索引结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>可用于表示<strong>类或接口引用到的接口信息</strong></p><p>由两部分组成：</p><p>interfaces_count(接口引用数量)：占2字节 例<code>00 02</code></p><p>interfaces[interfaces_count] (接口名称常量索引)：占2*interfaces_count字节 例<code>00 0D 00 0E</code></p></blockquote><pre><code class="hljs java">.... #13 = Class              #55            // java/lang/Cloneable#14 = Class              #56            // java/io/Serializable</code></pre><p>字节码文件解析出<code>00 02 00 0D 00 0E</code></p><p>对应内容为类实现了<code>Cloneable、Serializable</code>两个接口</p><h3 id="字段表集合-fields"><a href="#字段表集合-fields" class="headerlink" title="字段表集合(fields)"></a>字段表集合(fields)</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/字节码-字段表结构.png" srcset="/img/loading.gif" class="full-image" alt="字节码-字段表结构" title="字节码-字段表结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>可用于表示<strong>类或接口声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量</strong></p><p>由两部分组成：</p><p>fields_count(字段个数)：占2字节 例<code>00 03</code></p><p>fields[fields_count] (字段信息)：占n字节，由fields_count个<code>field_info</code>组成</p></blockquote><pre><code class="hljs java">field_info&#123;  u2          access_flags;  u2          name_index;  u2          descriptor_index;  u2          attributes_count;  attribute_infoattributes[attributes_count];&#125;</code></pre><h4 id="字段访问标志-access-flags"><a href="#字段访问标志-access-flags" class="headerlink" title="字段访问标志(access_flags)"></a>字段访问标志(access_flags)</h4><p>与上面的<code>类访问标志</code>相比基本是一致的，除了以下几项是字段所特有的</p><table><thead><tr><th>字段访问标志</th><th>标志值</th><th>描述</th></tr></thead><tbody><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>表示volatile，可实现<code>可见性、有序性</code><br>不能完全实现<code>原子性</code></td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>不参与序列化过程</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>表示 该字段为枚举的一个值</td></tr></tbody></table><p>字节码文件解析出数据为<code>00 00</code>,为默认标志</p><h4 id="字段名称索引-name-index"><a href="#字段名称索引-name-index" class="headerlink" title="字段名称索引(name_index)"></a>字段名称索引(name_index)</h4><blockquote><p> 占2字节，指向常量池中<code>CONSTANT_Utf8_info</code>中的有效索引，表示字段名称</p></blockquote><p>字节码文件解析出数据为<code>00 0F</code>，为<code>a</code></p><h4 id="字段描述符索引-descriptor-index"><a href="#字段描述符索引-descriptor-index" class="headerlink" title="字段描述符索引(descriptor_index)"></a>字段描述符索引(descriptor_index)</h4><blockquote><p>占2字节，指向常量池中<code>CONSTANT_Utf8_info</code>中的有效索引，表示字段属性</p></blockquote><p>字节码文件解析出数据为<code>00 10</code>，为<code>I</code></p><h4 id="字段额外属性个数-attributes-count"><a href="#字段额外属性个数-attributes-count" class="headerlink" title="字段额外属性个数(attributes_count)"></a>字段额外属性个数(attributes_count)</h4><blockquote><p>占2字节，表示字段额外属性个数</p></blockquote><p>字节码文件解析出数据为<code>00 00</code>，为0</p><h4 id="字段额外属性列表-attributes-attributes-count"><a href="#字段额外属性列表-attributes-attributes-count" class="headerlink" title="字段额外属性列表(attributes[attributes_count])"></a>字段额外属性列表(attributes[attributes_count])</h4><blockquote><p>占n字节，描述字段的额外属性</p></blockquote><p>字节码文件未解析出该字段</p><p><code>field_info</code>支持的额外属性格式如下：</p><h5 id="常量值-ConstantValue"><a href="#常量值-ConstantValue" class="headerlink" title="常量值(ConstantValue)"></a>常量值(ConstantValue)</h5><blockquote><p>由<code>static、final</code>关键字定义的常量值，在class文件中才有这个属性。</p></blockquote><p>在类加载过程的<code>准备</code>阶段时，会直接由设置的值进行初始化，而不使用默认值，仅限<code>基本数值类型和String</code>。</p><pre><code class="hljs java">ConstantValue_attribute&#123; u2 attribute_name_index;<span class="hljs-comment">//固定 ConstanValue</span> u4 attribute_length; u2 constantvalue_index;&#125;</code></pre><h6 id="属性名称索引-attribute-name-index"><a href="#属性名称索引-attribute-name-index" class="headerlink" title="属性名称索引(attribute_name_index)"></a>属性名称索引(attribute_name_index)</h6><blockquote><p>占2字节，指向常量池中<code>CONSTANT_Utf8_info</code>中的有效索引，表示属性名称</p></blockquote><p>解析为<code>00 14</code>，指向#20 表示<code>ConstantValue</code></p><h6 id="属性长度-attribute-length"><a href="#属性长度-attribute-length" class="headerlink" title="属性长度(attribute_length)"></a>属性长度(attribute_length)</h6><blockquote><p>占4字节，值必定为<code>00 00 00 02</code>，表示2</p></blockquote><h6 id="常量值索引-constantvalue-index"><a href="#常量值索引-constantvalue-index" class="headerlink" title="常量值索引(constantvalue_index)"></a>常量值索引(constantvalue_index)</h6><blockquote><p>占2字节，指向常量池中中的有效索引，表示常量值数值</p></blockquote><p>解析为<code>00 15</code>，指向#21，表示了<code>Integer 3</code>，即常量值为3</p><table><thead><tr><th>字段类型</th><th>常量池中类型</th></tr></thead><tbody><tr><td>long</td><td>CONSTANT_Long</td></tr><tr><td>float</td><td>CONSTANT_Float</td></tr><tr><td>double</td><td>CONSTANT_Double</td></tr><tr><td>int,short,char,byte,boolean</td><td>CONSTANT_Integer</td></tr><tr><td>String</td><td>CONSTANT_String</td></tr></tbody></table><p>列举出字节码文件中的一部分字段表信息</p><pre><code class="hljs java"><span class="hljs-number">00</span> <span class="hljs-number">18</span> | <span class="hljs-number">00</span> <span class="hljs-number">13</span> | <span class="hljs-number">00</span> <span class="hljs-number">10</span> | <span class="hljs-number">00</span> <span class="hljs-number">01</span> | <span class="hljs-number">00</span> <span class="hljs-number">14</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span>表示为<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> d = <span class="hljs-number">3</span></code></pre><h3 id="方法表集合-methods"><a href="#方法表集合-methods" class="headerlink" title="方法表集合(methods)"></a>方法表集合(methods)</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/字节码-方法表结构.png" srcset="/img/loading.gif" class="full-image" alt="字节码-方法表结构" title="字节码-方法表结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>可用于表示<strong>类或接口中的方法</strong></p><p>由两部分组成：</p><p>methods_count(方法个数)：占2字节，例如<code>00 05</code></p><p>methods[methods_count] (方法信息)：占n字节，由methods_count个<code>method_info</code>组成</p></blockquote><pre><code class="hljs java">method_info&#123;  u2          access_flags;  u2          name_index;  u2          descriptor_index;  u2          attributes_count;  attribute_infoattributes[attributes_count];&#125;</code></pre><h4 id="方法访问标志-access-flags"><a href="#方法访问标志-access-flags" class="headerlink" title="方法访问标志(access_flags)"></a>方法访问标志(access_flags)</h4><p>相比于<code>类访问标志</code>，多了几项<code>方法访问标志</code></p><table><thead><tr><th>字段访问标志</th><th>标志值</th><th>描述</th></tr></thead><tbody><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法为<code>synchronized</code>类型的，将方法包入到<code>monitor</code>中</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>为桥接方法，是编译后自动生成的方法<br>在使用泛型时，编译器自动生成桥接方法用于校验泛型转换实际类型</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>声明了可变数量的参数</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>声明Native方法，不是由Java语言实现的</td></tr></tbody></table><p>字节码文件解析出数据为<code>00 01</code>,表示<code>public</code></p><h4 id="方法名称索引-name-index"><a href="#方法名称索引-name-index" class="headerlink" title="方法名称索引(name_index)"></a>方法名称索引(name_index)</h4><blockquote><p>占2字节，指向常量池中<code>CONSTANT_Utf8_info</code>中的有效索引，表示方法名称</p></blockquote><p>字节码文件解析出数据为<code>00 13</code>,指向#19 ,表示<code>&lt;init&gt;</code>——初始化方法</p><h4 id="方法描述符索引-descriptor-index"><a href="#方法描述符索引-descriptor-index" class="headerlink" title="方法描述符索引(descriptor_index)"></a>方法描述符索引(descriptor_index)</h4><blockquote><p>占2字节，指向常量池中<code>CONSTANT_Utf8_info</code>中的有效索引，表示方法属性</p></blockquote><p>字节码文件解析出数据为<code>00 14</code>，指向#20,表示<code>()V</code>——没有入参，返回参数类型为<code>void</code></p><h4 id="方法额外属性个数-attributes-count"><a href="#方法额外属性个数-attributes-count" class="headerlink" title="方法额外属性个数(attributes_count)"></a>方法额外属性个数(attributes_count)</h4><blockquote><p>占2字节，表示方法额外属性个数</p></blockquote><p>字节码文件解析出数据为<code>00 01</code>，有1个额外属性</p><h4 id="方法额外属性列表-attributes-attributes-count"><a href="#方法额外属性列表-attributes-attributes-count" class="headerlink" title="方法额外属性列表(attributes[attributes_count])"></a>方法额外属性列表(attributes[attributes_count])</h4><blockquote><p>占n字节，描述方法的额外属性信息</p></blockquote><p>字节码文件解析出的数据为<code>00 15</code>，指向<code>Code</code></p><h5 id="Code"><a href="#Code" class="headerlink" title="*Code"></a>*Code</h5><blockquote><p>描述<code>method_info</code>相关信息，<strong>method_info必有一个该属性，除了<code>native和abstract修饰的方法</code></strong>。</p><p><code>Code_attribute</code>组成了<code>Code</code>。</p></blockquote><pre><code class="hljs java">Code_attribute&#123; u2 attribute_name_index;<span class="hljs-comment">//常量池索引，表示额外属性名称，此处为`Code`</span> u4 attribute_length; u2 max_stack;<span class="hljs-comment">//???</span> u2 max_locals;<span class="hljs-comment">//</span> u4 code_length;<span class="hljs-comment">//JVM操作指令个数 0&lt;code_length&lt;65535</span> u1 code[code_length];<span class="hljs-comment">//操作指令信息</span> u2 exception_table_length;<span class="hljs-comment">//异常集合长度</span>  &#123;    u2 start_pc;    u2 end_pc;    u2 handler_pc;    u2 vatch_type;  &#125; exception_table[exception_table_length];  u2 attributes_count;<span class="hljs-comment">//Code内部属性个数</span>  attribute_info attributes[attribute_count];&#125;</code></pre><h6 id="属性长度-attribute-length-1"><a href="#属性长度-attribute-length-1" class="headerlink" title="属性长度(attribute_length)"></a>属性长度(attribute_length)</h6><blockquote><p>属性值长度，需要排除<code>attribute_name_index</code>以及<code>attribute_length</code>6个字节长度，其他的累加起来就得到结果。</p></blockquote><h6 id="最大栈深度-max-stack"><a href="#最大栈深度-max-stack" class="headerlink" title="最大栈深度(max_stack)"></a>最大栈深度(max_stack)</h6><blockquote><p>最大操作数栈，</p></blockquote><h6 id="局部变量最大空间数-max-locals"><a href="#局部变量最大空间数-max-locals" class="headerlink" title="*局部变量最大空间数(max_locals)"></a>*局部变量最大空间数(max_locals)</h6><blockquote><p>描述当前方法的局部变量表。单位为<code>slot</code>,<code>long,double</code>占两个<code>slot</code>，其他类型都占一个<code>slot</code></p></blockquote><h6 id="操作指令集-code"><a href="#操作指令集-code" class="headerlink" title="操作指令集(code[])"></a>操作指令集(code[])</h6><blockquote><p>表示当前方法编译后的字节码操作指令集合</p></blockquote><p>主要内容参照 <a href="/2019/11/14/Java字节码学习-操作指令/" title="Java字节码学习-操作指令">Java字节码学习-操作指令</a></p><h6 id="异常表集合-exception-table"><a href="#异常表集合-exception-table" class="headerlink" title="异常表集合(exception_table[])"></a>异常表集合(exception_table[])</h6><blockquote><p>表示当前方法需要声明抛出的异常类型</p><p>exception_info{<br> u2 start_pc; //异常判断包裹的起始位置(字节码行号) 指向try{<br> u2 end_pc; //异常判断包裹的结束位置(字节码行号) 指向}catch 不包含该位置</p><p> u2 handler_pc;//异常捕获时 处理的位置(字节码行号)<br> u2 catch_type;//捕获的异常类型 若不为0 则表示为 常量池中对应的索引位置 ；为0则表示 是任意 Throwable<br>}</p></blockquote><p>一个方法可以抛出的异常类型遵循三点：</p><ul><li>抛出的异常是<code>RuntimeException</code>类型或其子类</li><li>抛出的异常是<code>Error</code>类型或其子类</li><li>抛出的异常是<code>Exception</code>类型或其子类</li></ul><h6 id="Code中额外属性-attributes-attributes-size"><a href="#Code中额外属性-attributes-attributes-size" class="headerlink" title="Code中额外属性(attributes[attributes_size])"></a>Code中额外属性(attributes[attributes_size])</h6><blockquote><p>Code区块中的额外属性：主要有以下三种</p></blockquote><ul><li><p>行号表(LineNumberTable)</p><blockquote><p>将Code区的字节码操作指令与源代码行号对应，可以在Debug时定位对应源代码。</p></blockquote></li><li><p>本地变量表(LocalVariableTable)</p><blockquote><p>包含This和局部变量，之所以每一个方法内部都可以调用this，是因为JVM将this作为方法的第一个参数隐式传入。<strong>若为static方法就没有该特性</strong></p></blockquote></li><li><p>栈表(StackMapTable)</p><blockquote><p>提高JVM在类型检查的验证过程的效率</p></blockquote></li></ul><h3 id="属性表集合-attributes"><a href="#属性表集合-attributes" class="headerlink" title="属性表集合(attributes)"></a>属性表集合(attributes)</h3><blockquote><p>存放了在该文件中类或接口定义属性的基本信息</p><p>attribute_info {</p><p> u2 attribute_name_index; //属性名称</p><p> u4 attribute_length; //属性值的字节长度</p><p> u1 info[attribute_length]; //属性的详细信息</p><p>}</p></blockquote><p>常用额外属性如下，按照可使用场景区分</p><table><thead><tr><th>属性</th><th>含义</th><th>使用位置</th></tr></thead><tbody><tr><td>SourceFile</td><td>记录和当前字节码对应的源代码文件</td><td>ClassFile</td></tr><tr><td>InnerClasses</td><td>记录当前类的所有内部类，包括在方法中定义的内部类</td><td>ClassFile</td></tr><tr><td>EnclosingMethod</td><td>当且仅当一个类是匿名类或者本地类，该类才会包含该属性</td><td>ClassFile</td></tr><tr><td>ConstantValue</td><td>每个常量字段(final，静态或实例常量)会包含该属性</td><td>field_info</td></tr><tr><td>Code</td><td>包含一个方法的栈、局部变量，字节码以及与代码相关属性<br>不会在<code>abstract</code>,<code>native</code>方法中出现</td><td>method_info</td></tr><tr><td>Exceptions</td><td>记录方法需要检查的异常类型</td><td>method_info</td></tr><tr><td>Depreated</td><td>表示一种弃用状态</td><td>ClassFile<br>method_info<br>field_info</td></tr><tr><td>LineNumberTable</td><td>获取字节码指令所对应的源码行号</td><td>Code</td></tr><tr><td>LocalVariableTable</td><td>获取方法运行时的局部变量</td><td>Code</td></tr><tr><td>StackMapTable</td><td>记录类型检查时需要用到的信息，如字节码的偏移量、局部变量的验证类型等</td><td>Code</td></tr></tbody></table><h2 id="字节码操作指令"><a href="#字节码操作指令" class="headerlink" title="字节码操作指令"></a>字节码操作指令</h2><a href="/2019/11/14/Java字节码学习-操作指令/" title="Java字节码学习-操作指令">Java字节码学习-操作指令</a><h2 id="字节码应用"><a href="#字节码应用" class="headerlink" title="字节码应用"></a>字节码应用</h2><a href="/2019/11/18/Java字节码学习-应用场景/" title="Java字节码学习-应用场景">Java字节码学习-应用场景</a><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="描述符-Descriptor"><a href="#描述符-Descriptor" class="headerlink" title="描述符(Descriptor)"></a>描述符(Descriptor)</h3><blockquote><p>定义了字段或方法的类型。</p><p><em>A </em>descriptor<em> is a string representing the type of a field or method. Descriptors are represented in the <code>class</code> file format using modified UTF-8 strings</em></p></blockquote><h4 id="字段描述符-Field-Descriptor"><a href="#字段描述符-Field-Descriptor" class="headerlink" title="字段描述符(Field Descriptor)"></a>字段描述符(Field Descriptor)</h4><blockquote><p>定义了<code>字段、局部变量、返回参数等类型</code>的字符串，由<code>FieldType</code>组成</p></blockquote><p>主要分为以下三种：</p><h5 id="基本类型（BaseType）"><a href="#基本类型（BaseType）" class="headerlink" title="基本类型（BaseType）"></a>基本类型（BaseType）</h5><table><thead><tr><th>基本类型</th><th>对应字符</th></tr></thead><tbody><tr><td>byte</td><td>B</td></tr><tr><td>char</td><td>C</td></tr><tr><td>double</td><td>D</td></tr><tr><td>float</td><td>F</td></tr><tr><td>int</td><td>I</td></tr><tr><td>long</td><td>J</td></tr><tr><td>short</td><td>S</td></tr><tr><td>boolean</td><td>Z</td></tr></tbody></table><p>例如：I =&gt; int</p><h5 id="对象类型（ObjectType）"><a href="#对象类型（ObjectType）" class="headerlink" title="对象类型（ObjectType）"></a>对象类型（ObjectType）</h5><p><strong>L${fullClassName};</strong></p><p>例如：Ljava/lang/Object =&gt; Object;</p><p>嵌套表达：Ljava/util/List&lt;Ljava/lang/String;&gt;; =&gt; List&lt;String&gt;</p><h5 id="数组类型（ArrayType）"><a href="#数组类型（ArrayType）" class="headerlink" title="数组类型（ArrayType）"></a>数组类型（ArrayType）</h5><p><strong>[${BaseType}</strong> <strong>[${ObjectType}</strong></p><p>例如：[java/lang/String =&gt; String[]</p><p>嵌套表达：[[I =&gt; int[][]</p><h4 id="方法描述符-Method-Descriptor"><a href="#方法描述符-Method-Descriptor" class="headerlink" title="方法描述符(Method Descriptor)"></a>方法描述符(Method Descriptor)</h4><blockquote><p>定义了<code>方法参数、方法返回等信息</code>的字符串</p></blockquote><p><strong>(${ParameterDescriptor}) ${ReturnDescriptor}</strong></p><h5 id="参数描述符（ParameterDescriptor）"><a href="#参数描述符（ParameterDescriptor）" class="headerlink" title="参数描述符（ParameterDescriptor）"></a>参数描述符（ParameterDescriptor）</h5><p>由<code>FieldType</code>组成</p><h5 id="返回值描述符（ReturnDescriptor）"><a href="#返回值描述符（ReturnDescriptor）" class="headerlink" title="返回值描述符（ReturnDescriptor）"></a>返回值描述符（ReturnDescriptor）</h5><p>由<code>FieldType</code>组成或者<code>VoidDescriptor(代指void)</code></p><p>例如：(IJD)V =&gt; void (int a,long b,double c)</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">The class File Format</a></p><p><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a></p><p><a href="https://www.jianshu.com/p/e5062d62a3d1" target="_blank" rel="noopener">认识class文件的字节码结构</a></p><p><a href="http://www.blogjava.net/DLevin/archive/2011/09/05/358034.html" target="_blank" rel="noopener">字节码格式详解</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-线程池</title>
    <link href="/2019/09/13/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2019/09/13/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/Java-线程池mind.png" srcset="/img/loading.gif" alt="Java线程池"></p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li><strong>线程</strong>：进程中负责执行的执行单元，一个进程中至少有一个线程,<strong>操作系统能够进行调度的最小单位</strong></li><li><strong>进程</strong>：一个执行中的程序的实例</li><li><strong>多线程</strong>：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU确定，因此多线程具有不确定性</li><li><strong>线程池</strong>： 基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象回归池中，避免反复创建线程对象所带来的性能开销，节省系统资源。</li></ul><h3 id="线程池的概念"><a href="#线程池的概念" class="headerlink" title="线程池的概念"></a>线程池的概念</h3><p>在执行一个异步任务或并发任务时，往往会通过<code>new Thread()</code>方法去开启一个子线程去执行任务，等到子线程操作完成后在利用<code>Handler</code>切换至主线程。但是利用这种方法我们无法对自己创建的子线程进行有效的管理，然后由于过多的创建子线程，他们之间相互竞争会导致资源的过度占用。线程池的出现就是为了来对子线程进行管理。</p><h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h3><ul><li><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li><strong>提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就可以立即执行</li><li><strong>提高线程的可管理性。</strong>线程是稀缺资源，大量创建会导致系统资源过度消耗且会降低系统的稳定性，线程池可以有效控制线程数，并进行统一的分配、调优和监控。</li></ul><h3 id="线程池的构造参数与对象成员变量"><a href="#线程池的构造参数与对象成员变量" class="headerlink" title="线程池的构造参数与对象成员变量"></a>线程池的构造参数与对象成员变量</h3><p><img src="/images/Java-线程池构造参数.png" srcset="/img/loading.gif" alt="线程池构造参数"></p><p><code>Executors</code>提供了基础的四类线程池方法，最终都是通过<code>ThreadPoolExecutor</code>类完成。对于这个类的描述<code>他维护了一个线程池，对于提交Executor中的任务，不是创建新的线程而是使用池内的线程来执行任务。可以显著减少对于任务执行的开销。</code></p><ol><li><p>ThreadPoolExecutor构造函数介绍</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,                              <span class="hljs-keyword">int</span> maximumPoolSize,                              <span class="hljs-keyword">long</span> keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler)</span></span></code></pre><p>参数介绍：</p><ul><li><p><strong><code>corePoolSize 核心线程数</code></strong> 表示线程池中的基本线程数量即核心线程数量。一般情况下核心线程会一直存活在线程池中，即便他们处于闲置状态。只有在<code>ThreadPoolExecutor的allowCoreThreadTimeOut设置为true</code>的时候，会有一个超时策略（超过设置好的超时时间，闲置的核心线程会被终止）。<strong>当创建的线程数小于corePoolSize时，不管有没有空闲线程都会创建新的线程</strong>。</p></li><li><p><strong><code>maximumPoolSize 最大线程数</code></strong>  表示线程池中允许的最大创建线程数，当活动的线程数达到数值后，后续新任务会被阻塞。<strong>使用有界队列时，未达到该值则会创建新的线程，使用无界队列时该值无效。</strong></p></li><li><p><strong><code>keepAliveTime 非核心线程闲置时的超时时长</code></strong> 表示空闲非核心线程的最大存活时间，一旦超过即被销毁。<strong>当<code>ThreadPoolExecutor的allowCoreThreadTimeOut设置为true</code>的时候，该参数也可作用于核心线程</strong></p></li><li><p><strong><code>unit 存活时间的时间单位</code></strong> 用于指定keepAliveTime参数的时间单位，为一个枚举类型。包含下列参数：<code>NANOSECONDS（纳秒）</code>,<code>MICROSECONDS（微秒）</code>,<code>MILLSECONDS（毫秒）</code>,<code>SECONDS（）秒</code>,<code>MINUTES（分）</code>,<code>HOURS（时）</code>,<code>DAYS（天）</code></p></li><li><p><strong><code>workQueue 线程池中的任务队列</code></strong> 该队列是<code>java.util.BlockingQueue&lt;E&gt;</code>的一个实例，是一种阻塞队列用来存放等待执行的任务。通过<code>execute()</code>方法将提交的Runnable对象存储进去。根据具体实现类的不同可以分为以下三种队列策略：</p><ul><li><code>容量为0即直接提交策略--SynchronousQueue</code>：等待队列容量为0 ，所有需要阻塞的任务必须等待池内的某个线程有空闲才可以继续执行，否则阻塞。<code>CachedThreadPool</code>使用该队列策略。</li><li><code>容量无限即无界队列策略--LinkedBlockingQueue</code>：等待队列的长度无穷大，在这种策略下不会出现多余corePoolSize的线程被创建，所以maximumPoolSize以及handler无效，因为不存在队列满的情况。不过也有缺点：<strong>线程的执行速度会比提交速度慢，会导致无界队列快速增长，直到系统资源耗尽。</strong><code>fixedThreadPool</code>采用了这种队列策略。</li><li><code>容量有限即有界队列策略--指定了容量的任何BlockingQueue</code>：等待队列的长度为限制长度，指定了容量后可以<strong>防止过多的资源被消耗</strong>。 </li></ul></li><li><p><strong><code>threadFactory 线程工厂</code></strong>：是一个接口可以为线程池提供新线程的创建。由同一个threadFactory创建的线程同属于一个ThreadGroup，优先级都为Thread.NORM_PRIORITY，以及为非进程守护状态。默认都是采用<code>Executors.defaultThreadFactory()</code>返回值。</p></li><li><p><strong><code>handler 拒绝策略</code></strong>：当<strong>使用有界队列时且队列任务被填满后并且线程数也达到了最大值，就会触发拒绝策略</strong>。如果任务被拒绝执行，则会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法，默认调用<code>AbortPolicy</code>拒绝策略，也可以由用户自定义。JDK中定义了4种拒绝策略：</p><ul><li><p><code>AbortPolicy</code><strong>处理程序遭到拒绝则直接抛出<code>RejectedExecutionException</code>异常然后丢弃该任务。</strong></p><p>实现源码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;       <span class="hljs-comment">/**        * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.        */</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">"Task "</span> + r.toString() +                                                <span class="hljs-string">" rejected from "</span> +                                                e.toString());       &#125;   &#125;</code></pre><p>样例演示：</p><pre><code class="hljs java"> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;        TestRunnable(<span class="hljs-keyword">int</span> id) &#123;            <span class="hljs-keyword">this</span>.id = id;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.err.println(Thread.currentThread().getName()+<span class="hljs-string">" 当前线程id="</span>+ <span class="hljs-keyword">this</span>.id);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abortPolicyDemo</span><span class="hljs-params">()</span> </span>&#123;        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">2</span>));        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">3</span>));        threadPoolExecutor.shutdown();    &#125;运行结果：添加进程时直接抛出异常但是没有影响后续的进行pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span>Exception in thread <span class="hljs-string">"main"</span> java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@<span class="hljs-number">4</span>b1210ee rejected from java.util.concurrent.ThreadPoolExecutor@<span class="hljs-number">4</span>d7e1886[Running, pool size = <span class="hljs-number">1</span>, active threads = <span class="hljs-number">1</span>, queued tasks = <span class="hljs-number">1</span>, completed tasks = <span class="hljs-number">0</span>]    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="hljs-number">2047</span>)    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="hljs-number">823</span>)    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="hljs-number">1369</span>)    at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:<span class="hljs-number">112</span>)    at threadpool.ThreadPoolDemo.abortPolicyDemo(ThreadPoolDemo.java:<span class="hljs-number">140</span>)    at threadpool.ThreadPoolDemo.main(ThreadPoolDemo.java:<span class="hljs-number">13</span>)pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span></code></pre></li><li><p><code>CallerRunsPolicy</code><strong>在调用<code>execute</code>方法的调用者所在线程来执行被拒绝的任务，提供简单的反馈控制机制，可以减缓新任务的提交速度。</strong></p><p>实现源码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;        <span class="hljs-comment">/**         * Creates a &#123;<span class="hljs-doctag">@code</span> CallerRunsPolicy&#125;.         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CallerRunsPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;            <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;                r.run();            &#125;        &#125;    &#125;</code></pre><p>样例演示：</p><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callerRunsPolicyDemo</span><span class="hljs-params">()</span></span>&#123;        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">2</span>));        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">3</span>));        threadPoolExecutor.shutdown();    &#125;运行结果：task2执行在了主线程，由于被拒绝执行所以在调用者线程执行了任务pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span>main 当前线程id=<span class="hljs-number">3</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span></code></pre></li><li><p><code>DiscardPolicy</code><strong>被拒绝即无法执行的任务被直接删除</strong></p><p>实现源码：   </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;              <span class="hljs-comment">/**               * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardPolicy&#125;.               */</span>              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;              &#125;          &#125;</code></pre><p>样例演示：</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discardPolicyDemo</span><span class="hljs-params">()</span></span>&#123;        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy());        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">2</span>));        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">3</span>));        threadPoolExecutor.shutdown();    &#125;运行结果：由于被拒绝执行在该策略下被直接抛弃pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span></code></pre></li><li><p><code>DiscardOldestPolicy</code><strong>判断线程池是否被关闭，没有则丢弃最老的一个请求，再尝试提交当前任务。</strong></p><p>实现源码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;             <span class="hljs-comment">/**              * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.              */</span>             <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardOldestPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;             <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;                 <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;                     e.getQueue().poll();                     e.execute(r);                 &#125;             &#125;         &#125;</code></pre><p>样例演示：</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discardOldestPolicyDemo</span><span class="hljs-params">()</span></span>&#123;        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">2</span>));        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">3</span>));        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">4</span>));        threadPoolExecutor.shutdown();    &#125;运行结果：???pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">4</span></code></pre></li><li><p><code>CustomRejectPolicy 自定义拒绝策略</code><strong>可以用来记录运行日志或者记录无法处理的任务</strong></p><p>样例演示：</p><pre><code class="hljs java"><span class="hljs-comment">/*** 自定义拒绝策略，实现RejectedExecutionHandler接口即可*/</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomRejectedPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span></span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;            <span class="hljs-keyword">if</span> (!executor.isShutdown())&#123;                    System.err.println(<span class="hljs-string">"自定义异常日志记录:  "</span>+  r.toString());            &#125;        &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customPolicyDemo</span><span class="hljs-params">()</span></span>&#123;        ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> CustomRejectedPolicy());    <span class="hljs-comment">//使用execute是因为使用submit时会被封装成RunnableFuture对象</span>        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">2</span>));        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">3</span>));        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">4</span>));        threadPoolExecutor.shutdown();    &#125;运行结果：由于<span class="hljs-number">4</span>号被拒绝，记录日志自定义异常日志记录:  java.util.concurrent.FutureTask@<span class="hljs-number">4</span>b1210eepool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">3</span></code></pre></li><li><p>额外参数扩展 <code>allowCoreThreadTimeOut 允许核心线程过期</code>默认值为false（线程池已不被使用，但是其中还有活着的线程，则该线程池无法被回收，会造成内存泄露）。所以用户可以显式调用<code>shutDown()</code>或者该值设置为true，则会被回收。</p></li></ul></li></ul></li><li><p>ThreadPoolExecutor的使用</p><p>向线程池提交一个任务的方式有两种：</p><ul><li><p><code>execute</code>：这种方法提交任务，是没有返回值的即无法判断在线程池中是否完成该任务</p><pre><code class="hljs java">threadPoolExecutor.execute(<span class="hljs-keyword">new</span> TestRunnable(<span class="hljs-number">1</span>));</code></pre></li><li><p><code>submit</code>：使用<code>submit</code>方法提交任务时，会返回一个future，可以通过这个future来判断任务是否执行成功也可以根据<code>future的get()</code>方法获取返回值。<strong>若子线程任务没完成，<code>get()</code>方法会阻塞直到任务完成，若使用<code>get(long timeout,TimeUnit unit)</code>则会阻塞一段时间后返回，可能尚未完成任务。</strong></p><pre><code class="hljs java">Future&lt;Integer&gt; future = fixedThreadPool.submit(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;                    <span class="hljs-meta">@Override</span>               <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                   System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" , index = "</span> + index);                   <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;               &#125;           &#125;);                <span class="hljs-keyword">try</span> &#123;               System.err.println(<span class="hljs-string">"Future return :"</span> + future.get().toString());           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;               e.printStackTrace();           &#125;</code></pre></li></ul></li><li><p>线程池的关闭</p><p>线程池关闭方法有两种：</p><ul><li><p><code>shutdown()</code>：将线程池的状态置为SHUTDOWN状态，然后中断没有正在执行的线程。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;        mainLock.lock();        <span class="hljs-keyword">try</span> &#123;            checkShutdownAccess();            advanceRunState(SHUTDOWN);            interruptIdleWorkers();            onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            mainLock.unlock();        &#125;        tryTerminate();    &#125;</code></pre></li><li><p><code>shutdownNow()</code>：将线程池的状态设为STOP状态，中断所有任务包括执行中的线程，并返回等待执行的任务列表。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Runnable&gt; tasks;        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;        mainLock.lock();        <span class="hljs-keyword">try</span> &#123;            checkShutdownAccess();            advanceRunState(STOP);            interruptWorkers();            tasks = drainQueue();        &#125; <span class="hljs-keyword">finally</span> &#123;            mainLock.unlock();        &#125;        tryTerminate();        <span class="hljs-keyword">return</span> tasks;    &#125;</code></pre><p>中断线程需要采用<code>interrput</code>方法，<strong>无法响应中断的任务可能永远无法终止。</strong></p><p>当需要立即中断所有线程并且不在乎任务是否执行完成时，可以使用<code>shutdownNow</code>方法。</p></li></ul></li><li><p>线程池的拓展</p><p><code>ThreadPoolExecutor</code>默认提供三个空方法，可以通过重写这三个方法来监控线程池。</p><pre><code class="hljs java"><span class="hljs-comment">//任务执行前 记录任务开始前时间</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> </span>&#123; &#125;<span class="hljs-comment">//任务执行后 记录任务结束时间</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> </span>&#123; &#125;<span class="hljs-comment">//线程池关闭 记录线程池关闭事件以及执行过的线程数量</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">terminated</span><span class="hljs-params">()</span> </span>&#123; &#125;</code></pre><p>样例演示：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;            <span class="hljs-keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> </span>&#123;            <span class="hljs-keyword">super</span>.beforeExecute(t, r);            System.err.println(<span class="hljs-string">"beforeExecute"</span>+r.toString());        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> </span>&#123;            <span class="hljs-keyword">super</span>.afterExecute(r, t);            System.err.println(<span class="hljs-string">"afterExecute"</span>+r.toString());        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">terminated</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">super</span>.terminated();            System.err.println(<span class="hljs-string">"线程关闭"</span>);        &#125;    &#125;</code></pre></li></ol><h3 id="线程池的分类以及各自的特性"><a href="#线程池的分类以及各自的特性" class="headerlink" title="线程池的分类以及各自的特性"></a>线程池的分类以及各自的特性</h3><p><img src="/images/Java-常见线程池.png" srcset="/img/loading.gif" alt="Java-常见线程池"></p><p>利用<code>Executors</code>类提供了四种不同的线程池，他们都是直接或者间接配置<code>ThreadPoolExecutor</code>来实现功能。下面分别介绍着四个线程池</p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><code>newFixedThreadPool</code></h4><blockquote><p>创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就不会发生变化，如果某个线程因为异常而结束，则会补充一个新进程。</p><p>由于只设置核心线程大小，所以可以<strong>更快的响应外界请求</strong></p><p>线程池的大小设置，可以使用<code>Runtime.getRuntime().availableProcessors()</code></p></blockquote><ul><li><p>实现源码</p><pre><code class="hljs java"><span class="hljs-comment">/*** 设置了核心线程，并且没有超时机制，使用LinkedBlockingQueue则任务队列大小是无上限的*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                      <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());    &#125;</code></pre></li><li><p>样例演示</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fixedThreadPoolDemo</span><span class="hljs-params">()</span></span>&#123;        ExecutorService fixedThreadPool= Executors.newFixedThreadPool(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">6</span> ; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index=i;            fixedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    System.err.println(Thread.currentThread().getName()+<span class="hljs-string">" , index = "</span>+index);                &#125;            &#125;);            <span class="hljs-keyword">try</span>&#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;                e.printStackTrace();            &#125;        &#125;    &#125;运行结果：整个过程都在pool-<span class="hljs-number">1</span>的线程池中运行,然后复用线程pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">0</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> , index = <span class="hljs-number">1</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> , index = <span class="hljs-number">2</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">3</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> , index = <span class="hljs-number">4</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> , index = <span class="hljs-number">5</span></code></pre></li><li><p>适用场景</p><p>用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。</p></li></ul><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><code>newCachedThreadPool</code></h4><blockquote><p>可根据需要创建新线程的线程池，但是在一起构造的线程可用时将重用他们。对于很多短期异步任务的程序而言，这类线程池可以提高性能。</p><p>如果现有线程没有可用的，则会创建一个新的线程并添加到池中，终止并从缓存中移除那些超过60s没有使用的线程。<strong>因此，长时间保持空闲的newCachedThreadPool线程池是不存在任何线程的，所以这时候几乎不占用系统资源。</strong></p></blockquote><ul><li><p>实现源码</p><pre><code class="hljs java"><span class="hljs-comment">/*** 核心线程数为0 线程最大为Int的最大值所以可以认定为线程池最大线程无限大，设置了超时时间为60s。任务队列采用了阻塞队列(必须池内有空闲线程才可以执行)*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());    &#125;</code></pre></li><li><p>样例演示</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cachedThreadPoolDemo</span><span class="hljs-params">()</span></span>&#123;        ExecutorService cachedThreadPool= Executors.newCachedThreadPool();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">6</span> ; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index=i;            cachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    System.err.println(Thread.currentThread().getName()+<span class="hljs-string">" , index = "</span>+index);                &#125;            &#125;);            <span class="hljs-keyword">try</span>&#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;                e.printStackTrace();            &#125;        &#125;    &#125;运行结果：整个过程都在同一个线程pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>中执行，后面线程复用前面的线程pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">0</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">1</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">2</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">3</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">4</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">5</span></code></pre></li><li><p>适用场景</p><p>并发执行大量短期的小任务，或者负载较轻的服务器</p></li></ul><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><code>newScheduledThreadPool</code></h4><blockquote><p>创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p></blockquote><ul><li><p>实现源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);&#125;<span class="hljs-comment">/*** 核心线程数固定，非核心线程数为无限大，当非核心数处于闲置状态的时候会被立即回收*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;    <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,          <span class="hljs-keyword">new</span> DelayedWorkQueue());&#125;</code></pre></li><li><p>样例演示</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleThreadPoolDemo</span><span class="hljs-params">()</span> </span>&#123;        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);     <span class="hljs-comment">//延迟一定时间后执行Runnable任务</span>        scheduledThreadPool.schedule(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" delay 2s"</span>);            &#125;        &#125;, <span class="hljs-number">2</span>, TimeUnit.SECONDS);     <span class="hljs-comment">//延迟一定时间后执行Callable任务</span>        scheduledThreadPool.schedule(<span class="hljs-keyword">new</span> Callable&lt;Object&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125;, <span class="hljs-number">2</span>, TimeUnit.SECONDS);     <span class="hljs-comment">//延迟一定时间（initialDelay）后,以(period)时间间隔执行任务</span>        scheduledThreadPool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" every 3s"</span>);            &#125;        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);     <span class="hljs-comment">//延迟一定时间（initialDelay）后,以(delay即上一个任务执行结束到下一个任务开始的间隔)执行</span>        scheduledThreadPool.scheduleWithFixedDelay(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" delay 3s"</span>);            &#125;        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);    &#125;运行结果：pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> every <span class="hljs-number">3</span>spool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> delay <span class="hljs-number">3</span>spool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> delay <span class="hljs-number">3</span>s <span class="hljs-number">1</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> every <span class="hljs-number">3</span>s</code></pre></li><li><p>适用场景</p><p>用于需要多个后台线程执行周期任务，同时需要限制线程数量</p></li></ul><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><code>newSingleThreadExecutor</code></h4><blockquote><p>创建一个单线程池，该线程池中只有一个线程在工作，其他任务都会依次在任务中排列中等候依次执行，任务是串行执行的。此线程池保证所有的任务的执行顺序按照任务提交顺序执行(FIFO-先进先出)。</p></blockquote><ul><li><p>实现源码</p><pre><code class="hljs java"><span class="hljs-comment">/*** 只有一个核心线程，对任务队列没有大小限制，将所有外界任务统一到一个线程执行所有我们不需要处理线程同步的问题。*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));    &#125;</code></pre></li><li><p>样例演示</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">singleThreadPoolDemo</span><span class="hljs-params">()</span></span>&#123;        ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = i;            singleThreadExecutor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" , index = "</span> + index);                &#125;            &#125;);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;运行结果：所有的任务都是在pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>中依次运行pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">0</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">1</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">2</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">3</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">4</span>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">5</span></code></pre></li><li><p>适用场景</p><p>用于串行执行任务的场景，每个任务需要顺序执行</p></li></ul><table><thead><tr><th></th><th>newCachedThreadPool</th><th>newFixedThreadPool</th><th>newSingleThreadExecutor</th><th>newScheduledThreadPool</th></tr></thead><tbody><tr><td>corePoolSize/<br>maximumPoolSize</td><td>0/Integer.MAX<br> <code>创建非核心线程</code>执行任务</td><td>n/n<br><code>创建核心线程</code>执行任务</td><td>1/1<br><code>只创建1个核心线程</code>执行任务</td><td>n/Integer.MAX</td></tr><tr><td>workQueue</td><td>SynchronousQueue</td><td>LinkedBlockingQueue(Integer.MAX)</td><td>LinkedBlockingQueue(Integer.MAX)</td><td>DelayedQueue</td></tr><tr><td>keepAliveTime</td><td>60s<br>即使没有任务进来，线程也会被很快回收</td><td>0ms<br>没有任务的情况下，线程会一直被阻塞等待任务</td><td>0ms<br>没有任务的情况下，线程会一直被阻塞等待任务</td><td>10s</td></tr><tr><td>适用场景</td><td>并发执行大量短期的小任务，或者负载较轻的服务器</td><td>用于负载较重的服务器，合理的利用服务器资源</td><td>用于串行执行任务的场景，每个任务按照<strong>先来先执行</strong>的原则</td><td>用于执行后台周期性任务</td></tr><tr><td>缺点</td><td>最大线程数为<code>Integer.MAX</code>，导致创建大量请求，消耗服务器资源</td><td>等待队列长度为<code>Integer.MAX</code>，导致大量请求堆积，消耗服务器资源</td><td>最大线程数为<code>Integer.MAX</code>，导致创建大量请求，消耗服务器资源</td><td>等待队列长度为<code>Integer.MAX</code>，导致大量请求堆积，消耗服务器资源</td></tr></tbody></table><h3 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h3><blockquote><p>线程池的生命周期是<strong>伴随线程池的运行，由内部进行维护的</strong>。</p><p>由两个值进行维护</p><ul><li><code>runState</code>：运行状态</li><li><code>workerCount</code>：线程数量</li></ul></blockquote><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));</code></pre><p><code>ctl</code>结合两个关键参数，来保证运行状态的一致。</p><p>高三位：<code>runState</code>，低29位：<code>workerCount</code>，两个变量互相不干扰。</p><p><img src="/images/582d1606d57ff99aa0e5f8fc59c7819329028.png" srcset="/img/loading.gif" alt="图3 线程池生命周期"></p><table><thead><tr><th>运行状态</th><th>描述</th></tr></thead><tbody><tr><td>RUNNING(<code>线程池运行状态</code>)</td><td>可以接受新任务，并且也能处理阻塞队列的任务</td></tr><tr><td>SHUTDOWN(<code>线程池关闭状态</code>)</td><td>不再接受新的任务，但是依然可以处理阻塞队列的任务</td></tr><tr><td>STOP(<code>线程池停止状态</code>)</td><td>不再处理阻塞队列的任务，并且中断正在进行的任务</td></tr><tr><td>TIDYING(<code>线程池正在终止状态</code>)</td><td>所有任务都已停止，<code>workerCount</code>为0</td></tr><tr><td>TERMINATED(<code>线程池终止状态</code>)</td><td>线程池已停止运行，所有工作线程都被销毁，所有任务都已被清空或执行完毕</td></tr></tbody></table><p>源码内部提供了如下方法去获取当前线程池的状态</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="hljs-comment">//运行状态</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125; <span class="hljs-comment">//工作线程数量</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125; <span class="hljs-comment">//当前runstate与workercount的和</span></code></pre><p><img src="/images/640" srcset="/img/loading.gif" alt="img"></p><h3 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h3><p><img src="/images/77441586f6b312a54264e3fcf5eebe2663494.png" srcset="/img/loading.gif" alt="图2 ThreadPoolExecutor运行流程"></p><ol><li>判断<code>corePoolSize(核心线程数)</code>是否已到达，没到达则可以创建一个新线程执行任务</li><li>判断<code>workQueue(工作队列)</code>是否已满，没满则添加入阻塞队列等待执行</li><li>判断<code>maximumPoolSize(最大线程数)</code>是否已到达，没到达则创建一个新线程执行任务。</li><li>已经达到了<code>maximumPoolSize(最大线程数)</code>或者线程池不处于<code>RUNNABLE</code>状态，执行<code>handler(任务拒绝策略)</code></li></ol><h3 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h3><p><img src="/images/Java-线程池原理.png" srcset="/img/loading.gif" alt="Java线程池原理"></p><h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><p>线程池通过调用<code>submit()</code>或<code>execute()</code>提交线程任务，其中<code>submit()</code>可以拿到线程执行结果，内部通过<code>execute()</code>实现。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;        <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-comment">//1.当前工作线程 &lt; 核心线程时</span>        <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;            <span class="hljs-comment">//直接创建新的Worker执行任务</span>            <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))                <span class="hljs-keyword">return</span>;            <span class="hljs-comment">//重新获取运行状态</span>            c = ctl.get();        &#125;        <span class="hljs-comment">//2.线程池处于running状态，任务加入 工作队列</span>        <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;            <span class="hljs-keyword">int</span> recheck = ctl.get();            <span class="hljs-comment">//线程不处于running状态，直接执行拒绝任务策略</span>            <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))                reject(command);            <span class="hljs-comment">//当无可用工作线程时，创建新的工作线程执行任务</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)                addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);        &#125;        <span class="hljs-comment">//无法添加任务，可能线程池被终止，或者最大线程已经满了</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))            <span class="hljs-comment">//执行拒绝策略</span>            reject(command);    &#125;</code></pre><blockquote><p>为什么执行<code>isRunning()</code>两次？</p><p>多线程环境下，线程池状态时刻发生变化，很可能刚获取的线程池状态突然就发生改变了。</p><p>万一线程池处于非<code>RUNNING</code>状态，那么任务永远不会执行。</p></blockquote><p>添加任务都是通过<code>addWorker()</code>执行</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core<span class="hljs-comment">/*是否核心线程*/</span>)</span> </span>&#123;    retry:    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-keyword">int</span> rs = runStateOf(c);        <span class="hljs-comment">// 当线程池处于 STOP、TIDYING、TERMINATED状态时，无法添加新任务</span>        <span class="hljs-comment">// 或者处于SHUTDOWN时，阻塞队列还有任务就需要继续执行完毕</span>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;            ! (rs == SHUTDOWN &amp;&amp;               firstTask == <span class="hljs-keyword">null</span> &amp;&amp;               ! workQueue.isEmpty()))            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">//获取工作线程数量</span>            <span class="hljs-keyword">int</span> wc = workerCountOf(c);            <span class="hljs-comment">//比较工作线程数量，若超出不予执行</span>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||                wc &gt;= (core ? corePoolSize : maximumPoolSize))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                <span class="hljs-keyword">break</span> retry;            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)                <span class="hljs-keyword">continue</span> retry;            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span>        &#125;    &#125;    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;    Worker w = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//新建工作对象</span>        w = <span class="hljs-keyword">new</span> Worker(firstTask);        <span class="hljs-keyword">final</span> Thread t = w.thread;        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;            mainLock.lock();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// Recheck while holding lock.</span>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span>                <span class="hljs-comment">// shut down before lock acquired.</span>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();                    workers.add(w);                    <span class="hljs-keyword">int</span> s = workers.size();                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                        largestPoolSize = s;                    workerAdded = <span class="hljs-keyword">true</span>;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                mainLock.unlock();            &#125;            <span class="hljs-keyword">if</span> (workerAdded) &#123;              <span class="hljs-comment">//启动新任务</span>                t.start();                workerStarted = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">//线程启动失败，移除worker</span>        <span class="hljs-keyword">if</span> (! workerStarted)            addWorkerFailed(w);    &#125;    <span class="hljs-keyword">return</span> workerStarted;&#125;</code></pre><ol><li>线程池处于<code>RUNNABLE状态</code>或者<code>SHUTDOWN状态并且阻塞队列还有任务</code>，需要添加新线程执行任务</li><li><code>Worker</code>封装了线程对象</li><li>线程启动失败，则移除对应<code>Worker</code></li></ol><h5 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a><code>Worker</code></h5><blockquote><p>内部封装了<code>线程</code>对象，并且本身也是一个<code>Runnable</code>对象。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span>     <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span>     <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;     <span class="hljs-comment">/** Worker实际执行的线程 */</span>     <span class="hljs-keyword">final</span> Thread thread;     <span class="hljs-comment">/** 初始化的任务，可以为null */</span>     Runnable firstTask;     <span class="hljs-comment">/** Per-thread task counter */</span>     <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> completedTasks;     Worker(Runnable firstTask) &#123;         setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span>         <span class="hljs-keyword">this</span>.firstTask = firstTask;         <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);     &#125;     <span class="hljs-comment">/** Delegates main run loop to outer runWorker. */</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;         runWorker(<span class="hljs-keyword">this</span>);     &#125;   ... &#125;</code></pre><p><code>Worker</code>持有两个对象：</p><ul><li><code>thread</code>：用来执行任务</li><li><code>firstTask</code>：保存传入的第一个任务，如果该值非空，则优先执行该任务。若为空，就需要创建一个工作线程去执行<code>workQueue</code>中的任务</li></ul><p><code>Worker</code>继承了<code>AQS</code>来实现<code>独占锁</code>功能，可以保证线程的执行状态是正确的。</p><p>获取独占锁，表示<strong>当前线程正在执行中，任务不可以被中断</strong>。</p><p>未获取独占锁，表示<strong>当前线程没有处理任务，可以进行线程中断</strong>。中断后就可以安全的进行线程回收。</p><h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><p><code>addWorker()</code>添加任务完毕后，就需要执行任务<code>runWorker()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;        Thread wt = Thread.currentThread();        Runnable task = w.firstTask;        w.firstTask = <span class="hljs-keyword">null</span>;        w.unlock(); <span class="hljs-comment">// allow interrupts</span>        <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//存在firstTask则先执行，否则从getTasks()获取阻塞队列的任务</span>            <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;                w.lock();                <span class="hljs-comment">//检测线程池状态</span>                <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||                     (Thread.interrupted() &amp;&amp;                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                    !wt.isInterrupted())                    wt.interrupt();                <span class="hljs-keyword">try</span> &#123;                   <span class="hljs-comment">//可重写该方法监听任务执行状态</span>                    beforeExecute(wt, task);                    Throwable thrown = <span class="hljs-keyword">null</span>;                    <span class="hljs-keyword">try</span> &#123;                      <span class="hljs-comment">//执行任务</span>                        task.run();                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;                        thrown = x; <span class="hljs-keyword">throw</span> x;                    &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;                        thrown = x; <span class="hljs-keyword">throw</span> x;                    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;                        thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);                    &#125; <span class="hljs-keyword">finally</span> &#123;                       <span class="hljs-comment">//可重写该方法监听任务执行状态</span>                        afterExecute(task, thrown);                    &#125;                &#125; <span class="hljs-keyword">finally</span> &#123;                    task = <span class="hljs-keyword">null</span>;                    w.completedTasks++;                    w.unlock();                &#125;            &#125;            completedAbruptly = <span class="hljs-keyword">false</span>;        &#125; <span class="hljs-keyword">finally</span> &#123;          <span class="hljs-comment">//线程池无任务可以执行</span>            processWorkerExit(w, completedAbruptly);        &#125;    &#125;</code></pre><p>若<code>firstTask</code>不为null，则优先执行<code>firstTak</code>。<code>fistTask</code>未设置时，从<code>getTasks()</code>获取<code>workQueue</code>中的任务去执行。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span>    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-keyword">int</span> rs = runStateOf(c);        <span class="hljs-comment">// Check if queue empty only if necessary.</span>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;            decrementWorkerCount();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">int</span> wc = workerCountOf(c);        <span class="hljs-comment">// 是否允许核心线程超时释放 或者 当前工作线程数大于核心线程</span>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimedout || wc &gt; corePoolSize;        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">try</span> &#123;            Runnable r = timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="hljs-comment">//等待 keepAliveTime 后释放线程</span>                workQueue.take(); <span class="hljs-comment">//使用take()获取任务，阻塞线程，直到拿到任务为止</span>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)                <span class="hljs-keyword">return</span> r;            timedOut = <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;            timedOut = <span class="hljs-keyword">false</span>;        &#125;    &#125;&#125;</code></pre><p>线程池里的线程从<code>workQueue阻塞队列</code>里拿任务，如果存在非核心线程且<code>workQueue</code>没有任务，非核心线程就会等到<code>keppAliveTime</code>时间后被释放。如果当前仅有核心线程存在时，设置了<code>allowCoreThreadTimedout(true)</code>，核心线程也会被释放。否则就会通过<code>take()</code>一致阻塞直到拿到任务为止。</p><p>核心线程不会被释放的原因：<strong>通过<code>workQueue.take()</code>一直阻塞线程</strong>。</p><p><br></p><p>核心线程与非核心线程的区别：</p><p>这两者之间并没有明显的标志区分，根据上面的代码可以发现，两者的区别在于<strong>核心线程可以无限等待获取任务(阻塞队列take())，非核心线程要限时获取任务(keepAliveTime之内)</strong>。核心线程其实指代的就是<code>0~corePoolSize</code>之间创建的线程，<code>corePoolSize~maximumPoolSie</code>表示的就是非核心线程。</p><p><img src="/images/03268b9dc49bd30bb63064421bb036bf90315.png" srcset="/img/loading.gif" alt="图7 Worker执行任务"></p><p>通过调用<code>execute(runnable)</code>传进去的<code>runnable</code>对象不是直接通过<code>new Thread(runnable).start()</code>的方式去执行，而是通过一个<strong>正在运行的线程</strong>去执行<code>runnable.run()</code>。根据上述源码中的<code>runWorker()</code>，在执行完<code>firstTask</code>后就会调用<code>getTask()</code>获取任务去执行，如果<code>getTask()</code>没有获取到任务，就会在等待<code>keepAliveTime</code>之后关闭非核心线程，核心线程通过<code>workQueue.take()</code>阻塞线程避免自身被回收。</p><h4 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h4><p><code>getTask()</code>获取不到任务时，执行<code>processWorkerExit()</code>进行线程回收</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn't adjusted</span>        <span class="hljs-comment">//减少工作线程数</span>        decrementWorkerCount();    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;    mainLock.lock();    <span class="hljs-keyword">try</span> &#123;        completedTaskCount += w.completedTasks;        workers.remove(w);    &#125; <span class="hljs-keyword">finally</span> &#123;        mainLock.unlock();    &#125;    <span class="hljs-comment">//尝试终止线程池</span>    tryTerminate();    <span class="hljs-keyword">int</span> c = ctl.get();   <span class="hljs-comment">//线程池处于RUNNABLE或SHUTDOWN状态</span>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;            <span class="hljs-comment">//根据是否配置 allowCoreThreadTimeout 来判断线程池的最小保留线程数</span>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;            <span class="hljs-comment">//阻塞队列还有任务的话，至少保留一个线程去执行任务</span>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())                min = <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span>        &#125;        <span class="hljs-comment">//因为线程中断，导致没有线程执行阻塞队列任务</span>        <span class="hljs-comment">//尝试新建线程去执行任务</span>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);    &#125;&#125;</code></pre><h4 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h4><p>当线程池处于<code>非RUNNABLE</code>状态或者<code>workerCount &gt; maximumPoolSize</code>时，就会执行<code>reject(runnable)</code>拒绝策略</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;        <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">int</span> c = ctl.get();        <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;            <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))                <span class="hljs-keyword">return</span>;            c = ctl.get();        &#125;        <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;            <span class="hljs-keyword">int</span> recheck = ctl.get();            <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="hljs-comment">//当前不是RUNNABLE，移除当前任务</span>                reject(command);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)                addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<span class="hljs-comment">//添加非核心线程失败，表示已经超出了maximumPoolSize</span>            reject(command);    &#125;    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(Runnable command)</span> </span>&#123;        handler.rejectedExecution(command, <span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;        <span class="hljs-comment">/**         * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">"Task "</span> + r.toString() +                                                 <span class="hljs-string">" rejected from "</span> +                                                 e.toString());        &#125;    &#125;</code></pre><p>通过自定义类实现<code>RejectedExecutionHandler</code>接口，执行对应的拒绝策略。默认拒绝策略是<code>AbortPolicy</code>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/640-1293801." srcset="/img/loading.gif" alt="img"></p><p>线程里容纳了一定的<code>Worker(执行任务的线程)</code>。根据线程池状态的不同，有新任务加入时，执行不同的操作。</p><ul><li>核心线程未满(<code>workerCount &lt; corePoolSize</code>)，创建<code>核心线程</code>执行任务</li><li>核心线程已满(<code>workerCount&gt;= corePoolSize</code>)，将任务添加到<code>workQueue</code>中</li><li><code>workQueue</code>已满(<code>workerCount&lt; maximumPoolSize</code>)，创建<code>非核心线程</code>执行任务</li><li>最大任务队列已满(<code>workerCount = maximumPoolSize</code>)，执行<code>handler</code>拒绝策略</li></ul><p>线程执行任务时，先执行<code>Worker的firstTask</code>，后续从<code>getTask()</code>获取任务去执行，根据线程池的容量区间获取任务的方式也不同</p><ul><li>容量区间位于<code>0~corePoolSize(核心线程)</code>，执行<code>workQueue.take()</code>阻塞获取任务，不会被回收。<em>若设置<code>allowCoreThreadTimeout(true)</code>也会被回收</em></li><li>容量区间位于<code>corePoolSize~maximumPoolSize(非核心线程)</code>，执行<code>workQueue.poll(keepAliveTime)</code>获取任务，超出<code>keepAliveTime</code>该线程就会被回收</li></ul><h3 id="线程池中的线程策略"><a href="#线程池中的线程策略" class="headerlink" title="线程池中的线程策略"></a>线程池中的线程策略</h3><h4 id="增长策略"><a href="#增长策略" class="headerlink" title="增长策略"></a>增长策略</h4><p>默认情况下，线程池是根据任务先<strong>创建足够核心线程数的线程去执行任务</strong>，当核心线程满了时<strong>将任务放入等待队列</strong>。待队列满了的时候，继续<strong>创建新线程执行任务直到达到最大线程数停止</strong>。此时再进入新任务的话，那就只能<strong>执行拒绝策略或是抛出异常</strong>。</p><h4 id="收缩策略"><a href="#收缩策略" class="headerlink" title="收缩策略"></a>收缩策略</h4><p>当线程池内的线程数大于核心线程数并且当前存在空闲线程并且空闲线程的空闲时间大于<code>keepAliveTime</code>时，会对空闲线程进行回收，直到线程数量等于核心线程数(<code>corePoolSize</code>)为止。</p><h3 id="线程池的使用注意"><a href="#线程池的使用注意" class="headerlink" title="线程池的使用注意"></a>线程池的使用注意</h3><ol><li><p>线程池不要用<code>Executors</code>的方式去创建，应该利用<code>ThreadPoolExecutor</code>的方式，这样可以帮助更好理解实现方式以及避免资源消耗过度的问题。</p><p><strong><code>fixThreadPool以及singleThreadPool</code>,由于设置的等待队列长度为Integer.MAX_VALUE，导致大量请求堆积，消耗大量资源。</strong></p><p><strong><code>cachedThreadPool以及scheduledThreadPool</code>,由于运行允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的请求，消耗大量资源。</strong></p></li><li><p>针对具体情况去配置线程池参数，不同的任务类别应采用不同规模的线程池，任务类别分为3种：</p><ul><li><p><strong><code>CPU密集型任务(需要进行大量计算，处理)</code></strong>：线程池中线程个数尽量少，不应大于CPU核心数，避免出现每个线程都需要长时间使用但是线程过多去抢占资源。建议<code>corePoolSize</code>为<strong>n+1</strong></p></li><li><p><strong><code>IO密集型任务(主要时间都在IO，CPU空闲时间比较多)</code></strong>：线程池可以配置尽量多的线程，由于CPU大部分时间空闲，可以提高CPU的利用率。建议<code>corePoolSize</code>为<strong>2n</strong></p></li><li><p><strong><code>混合型任务</code></strong>：如果可以拆分，则拆分成一个CPU密集型以及IO密集型任务，只要执行任务效率相差不大。若相差太大则没必要拆分。</p></li></ul></li></ol><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><ol><li><p><code>submit()</code>和<code>execute()</code>区别</p><p><code>submit()</code>返回一个<code>future</code>，根据<code>future</code>可以判断任务是否完成–实现<code>Callable</code>接口</p><p><code>execute()</code>无返回值。只是执行了任务，不知道结果如何 – 实现<code>Runnable</code>接口</p></li><li><p><code>BlockingQueue</code>介绍</p><a href="/2018/12/24/Java-BockingQueue阻塞队列/" title="Java-BockingQueue阻塞队列">Java-BockingQueue阻塞队列</a></li><li><p><code>AbstractQueuedSynchronizer</code>介绍</p><a href="/2020/09/13/Java-AbstractQueuedSynchronizer简介/" title="Java-AbstractQueuedSynchronizer简介">Java-AbstractQueuedSynchronizer简介</a></li><li><p>为什么存在<code>newSingleThreadExecutor</code>?不能使用<code>newFixedThreadPool(1)</code>代替</p><p>再次对比一下两者的源码</p><pre><code class="hljs java"><span class="hljs-comment">/*     * Creates an Executor that uses a single worker thread operating     * off an unbounded queue, and uses the provided ThreadFactory to     * create a new thread when needed. Unlike the otherwise     * equivalent &#123;@code newFixedThreadPool(1, threadFactory)&#125; the     * returned executor is guaranteed not to be reconfigurable to use     * additional threads.       */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<span class="hljs-comment">//nThreads为1</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class="hljs-comment">//1 , 1</span>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                      <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());    &#125;</code></pre><p>两者之间最大的差异就在于包装类的区别：</p><ul><li><code>newSingleThreadExecutor</code>——FinalizableDelegatedExecutorService</li><li><code>newFixedThreadPool</code>——ThreadPoolExecutor</li></ul><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalizableDelegatedExecutorService</span>           <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatedExecutorService</span> </span>&#123;       FinalizableDelegatedExecutorService(ExecutorService executor) &#123;           <span class="hljs-keyword">super</span>(executor);       &#125;       <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> </span>&#123;           <span class="hljs-keyword">super</span>.shutdown();       &#125;   &#125;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatedExecutorService</span>           <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExecutorService</span> </span>&#123;       <span class="hljs-comment">// Android-added: @ReachabilitySensitive</span>       <span class="hljs-comment">// Needed for FinalizableDelegatedExecutorService below.</span>       <span class="hljs-meta">@ReachabilitySensitive</span>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService e;       DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123; e.execute(command); &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123; e.shutdown(); &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> e.shutdownNow(); &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> e.isShutdown(); &#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isTerminated</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> e.isTerminated(); &#125;      ...   &#125;</code></pre><p><code>DelegatedExecutorService</code>就是<code>ExecutorService接口实现类</code>的包装类，包装后的对象仅仅暴露<code>ExecutorService</code>接口方法，而<code>FinalizableDelegatedExecutorService</code>屏蔽了大多数实现方法，避免被强制转换时修改配置导致行为出现问题。</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFixed</span><span class="hljs-params">()</span></span>&#123;        ExecutorService s = Executors.newFixedThreadPool(<span class="hljs-number">1</span>);        ((ThreadPoolExecutor)s).setCorePoolSize(<span class="hljs-number">2</span>);        System.err.println(<span class="hljs-string">"ss "</span>+((ThreadPoolExecutor) s).getCorePoolSize());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSingle</span><span class="hljs-params">()</span></span>&#123;        ExecutorService s = Executors.newSingleThreadExecutor();        ((ThreadPoolExecutor)s).setCorePoolSize(<span class="hljs-number">2</span>);        System.err.println(<span class="hljs-string">"ss"</span>+((ThreadPoolExecutor) s).getCorePoolSize());    &#125;输出结果：  ss <span class="hljs-number">2</span>Exception in thread <span class="hljs-string">"main"</span> java.lang.ClassCastException: java.util.concurrent.Executors$FinalizableDelegatedExecutorService cannot be cast to java.util.concurrent.ThreadPoolExecutorat thread.TestThreadPool.testSingle(TestThreadPool.java:<span class="hljs-number">31</span>)at thread.TestThreadPool.main(TestThreadPool.java:<span class="hljs-number">20</span>)</code></pre><p>观察上面的结果，可以看出<code>newSingleThreadExecutor</code>与<code>newFixedThreadPool</code>最大区别在于，前者不可配置参数，可以保证<strong>任务的串行执行</strong>，后者在运行的过程中可以通过强制类型转换得到<code>ThreadPoolExecutor</code>去进行参数的重新配置，导致<strong>任务可能变成并行执行</strong>。使应用的执行逻辑出现错误，导致应用异常。</p></li><li><p>ss</p></li></ol><h3 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h3><p><a href="https://juejin.im/post/5bdbbc3d6fb9a0224a5e486f#heading-14" target="_blank" rel="noopener">线程池</a></p><p><a href="https://mp.weixin.qq.com/s/HpMu_QI_N-J18fNJG96yzA" target="_blank" rel="noopener">线程池深入解析</a></p><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android崩溃优化</title>
    <link href="/2019/07/20/Android%E5%B4%A9%E6%BA%83%E4%BC%98%E5%8C%96/"/>
    <url>/2019/07/20/Android%E5%B4%A9%E6%BA%83%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin-委托相关知识</title>
    <link href="/2019/07/09/Kotlin-%E5%A7%94%E6%89%98%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2019/07/09/Kotlin-%E5%A7%94%E6%89%98%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>委托：有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。</p></blockquote><p>在Kotlin中，对<code>委托</code>进行了简化，通过<code>by</code>就可以实现委托的效果。例如前面提到的<code>by lazy</code>延迟初始化就是利用了<code>委托</code>。</p><p>Kotlin中主要分为两种：<strong>类委托、委托属性</strong>。</p><p>基本语法:</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span>/<span class="hljs-keyword">var</span> &lt;属性名&gt;:&lt;类型&gt; <span class="hljs-keyword">by</span> &lt;表达式&gt; <span class="hljs-comment">//&lt;表达式&gt; 指向委托</span></code></pre><h2 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h2><blockquote><p>在不使用继承的情况下，拓展一个类的功能，使之提供更多的功能。类似<code>装饰模式</code>。</p><p><code>装饰模式</code>的缺点就是需要较多的样板代码，装饰类需要实现接口的全部方法，并需要调用到原始对象的方法。</p></blockquote><p>Kotlin可以<strong>零样板代码进行原生支持</strong>，通过<code>by</code>关键字进行实现。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseImpl</span></span>(<span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span>) : Base &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> &#123;        print(x)    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span></span>(b: Base) : Base <span class="hljs-keyword">by</span> b<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-keyword">val</span> b = BaseImpl(<span class="hljs-number">10</span>)    Derived(b).print()&#125;</code></pre><p>利用<code>by</code>，将新类的接口委托给原始对象，生成后的新类会自动生成接口方法，并默认返回原始类的具体实现。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Base</span> </span>&#123;   <span class="hljs-comment">// $FF: synthetic field</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Base $$delegate_0;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Derived</span><span class="hljs-params">(@NotNull Base b)</span> </span>&#123;      Intrinsics.checkParameterIsNotNull(b, <span class="hljs-string">"b"</span>);      <span class="hljs-keyword">super</span>();      <span class="hljs-keyword">this</span>.$$delegate_0 = b;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.$$delegate_0.print();   &#125;&#125;</code></pre><p>观察上述反编译后的Java代码，看到实际生成的<code>Derived</code>已经默认实现了接口方法。可以按照需求去重载某些方法，而不必写过多的样板代码。</p><h2 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h2><blockquote><p>将属性的访问器(<code>get()、set()</code>)委托给一个符合属性委托约定规则的对象。</p></blockquote><p>委托属性对象规则：</p><ul><li><p>对于一个<strong>只读属性(<code>val</code>声明)</strong>，委托必须提供一个名为<code>getValue()</code>的函数。</p><pre><code class="hljs kotlin"><span class="hljs-comment">/*** 只读属性*/</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadOnlyProperty</span>&lt;<span class="hljs-type">in R, out T</span>&gt; </span>&#123;   <span class="hljs-comment">/**  * [thisRef] 必须与属性所有者类型相同或者是它的超类  * [property] 必须是KProperty&lt;*&gt;或其超类  * [T] 返回与属性相同的类型  */</span>  <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">R</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: T &#125;</code></pre></li></ul><p>  <code>ReadOnlyProperty</code>由Kotlin提供的接口，方便开发者使用于<code>val</code>声明变量</p><ul><li><p>对于一个<strong>可变属性(<code>var</code>声明)</strong>，委托必须额外提供一个<code>setValue()</code></p><pre><code class="hljs kotlin"><span class="hljs-comment">/*** 可变属性*/</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadWriteProperty</span>&lt;<span class="hljs-type">in R, T</span>&gt; </span>&#123;   <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">R</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: T   <span class="hljs-comment">/**  * [value] 必须与属性同类型或者超类  */</span>  <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">R</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">T</span>)</span></span> &#125;</code></pre></li></ul><p>  <code>ReadWriteProperty</code>由Kotlin提供的接口，方便开发者使用于<code>var</code>声明变量</p><p>使用示例：</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">var</span> name:String <span class="hljs-keyword">by</span> MyDelegate()&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDelegate</span> : <span class="hljs-type">ReadWriteProperty</span>&lt;<span class="hljs-type">Any?,String</span>&gt;</span>&#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Kotlin"</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;    &#125;&#125;</code></pre><h2 id="Kotlin自带委托"><a href="#Kotlin自带委托" class="headerlink" title="Kotlin自带委托"></a>Kotlin自带委托</h2><h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><blockquote><p>利用<code>变量 by lazy</code>可以实现 延迟初始化。</p></blockquote><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>()&#123;        <span class="hljs-keyword">val</span> sex: String <span class="hljs-keyword">by</span> lazy &#123;        <span class="hljs-string">"male"</span>    &#125;&#125;</code></pre><p><code>lazy</code>接收初始化该值的<code>lambda</code>表达式，并返回一个<code>getValue()</code>的对象。</p><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>先分析反编译该段代码后的结果：</p><pre><code class="hljs java">public final class Demo &#123;     @NotNull   //生成对应参数的委托信息   private final Lazy sex$delegate;  static final KProperty[] $$delegatedProperties =     new KProperty[]&#123;(KProperty)Reflection.property(    new PropertyReference1Impl(Reflection.getOrCreateKotlinClass(Bird.class), "sex", "getSex()Ljava/lang/String;"))&#125;;   @NotNull   public final String getSex() &#123;      Lazy var1 = this.sex$delegate;      KProperty var3 = $$delegatedProperties[0];      boolean var4 = false;      //在第一次使用的时候 获取对应数据      return (String)var1.getValue();   &#125;  public Demo()&#123;    //执行指定的初始代码块     this.sex$delegate = LazyKt.lazy((Function0)null.INSTANCE);  &#125;&#125;</code></pre><p>最终通过获取<code>lazy</code>函数的<code>getValue()</code>获取所需结果。</p><h3 id="属性改变通知"><a href="#属性改变通知" class="headerlink" title="属性改变通知"></a>属性改变通知</h3><blockquote><p>通过调用<code>value by Delegates.observable(value)</code>来监听<code>value</code>的数据变化。</p><p>另外还提供了<code>value by Delegates.vetoable(value)</code>也同样起到监听的效果，但是该方法返回一个<code>Boolean</code>类型来<strong>判断是否需要对value进行赋值。</strong></p></blockquote><h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><pre><code class="hljs kotlin"><span class="hljs-comment">//对age的数据变化进行监听   </span><span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> Delegates.observable(age) &#123; property, oldValue, newValue -&gt;      println(<span class="hljs-string">"<span class="hljs-subst">$&#123;property.name&#125;</span> oldValue=&gt;<span class="hljs-variable">$oldValue</span> newValue=&gt;<span class="hljs-variable">$newValue</span>"</span>)  &#125;age = <span class="hljs-number">3</span> <span class="hljs-comment">//初始赋值</span>age = <span class="hljs-number">4</span> <span class="hljs-comment">//age oldValue=&gt;3 newValue=&gt;4</span>println(age) <span class="hljs-comment">// 4</span><span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> Delegates.vetoable(age) &#123; property, oldValue, newValue -&gt;      println(<span class="hljs-string">"<span class="hljs-subst">$&#123;property.name&#125;</span> oldValue=&gt;<span class="hljs-variable">$oldValue</span> newValue=&gt;<span class="hljs-variable">$newValue</span>"</span>)      <span class="hljs-literal">true</span><span class="hljs-comment">// true代表监听并修改数据  false只监听不修改对应数据</span>  &#125;age = <span class="hljs-number">3</span> <span class="hljs-comment">//初始赋值</span>age = <span class="hljs-number">4</span> <span class="hljs-comment">//age oldValue=&gt;3 newValue=&gt;4</span>  println(age) <span class="hljs-comment">//为true 4 为false 3</span></code></pre><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>先分析<code>Delegates</code>相关代码的实现</p><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">observable</span><span class="hljs-params">(initialValue: <span class="hljs-type">T</span>, <span class="hljs-keyword">crossinline</span> onChange: (<span class="hljs-type">property</span>: <span class="hljs-type">KProperty</span>&lt;*&gt;, <span class="hljs-type">oldValue</span>: <span class="hljs-type">T</span>, <span class="hljs-type">newValue</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>:        ReadWriteProperty&lt;Any?, T&gt; = <span class="hljs-keyword">object</span> : ObservableProperty&lt;T&gt;(initialValue) &#123;            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterChange</span><span class="hljs-params">(property: <span class="hljs-type">KProperty</span>&lt;*&gt;, oldValue: <span class="hljs-type">T</span>, newValue: <span class="hljs-type">T</span>)</span></span> = onChange(property, oldValue, newValue)        &#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">vetoable</span><span class="hljs-params">(initialValue: <span class="hljs-type">T</span>, <span class="hljs-keyword">crossinline</span> onChange: (<span class="hljs-type">property</span>: <span class="hljs-type">KProperty</span>&lt;*&gt;, <span class="hljs-type">oldValue</span>: <span class="hljs-type">T</span>, <span class="hljs-type">newValue</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>:            ReadWriteProperty&lt;Any?, T&gt; =        <span class="hljs-keyword">object</span> : ObservableProperty&lt;T&gt;(initialValue) &#123;            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beforeChange</span><span class="hljs-params">(property: <span class="hljs-type">KProperty</span>&lt;*&gt;, oldValue: <span class="hljs-type">T</span>, newValue: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = onChange(property, oldValue, newValue)        &#125;</code></pre><p><code>observable</code>通过<code>ObservableProperty.afterChange()</code>来监听变化，<code>vetoable</code>通过<code>ObservableProperty.beforeChange()</code>来监听变化并对数据的赋值进行拦截</p><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableProperty</span>&lt;<span class="hljs-type">T</span>&gt;</span>(initialValue: T) : ReadWriteProperty&lt;Any?, T&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value = initialValue    <span class="hljs-comment">//在值修改前调用</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">beforeChange</span><span class="hljs-params">(property: <span class="hljs-type">KProperty</span>&lt;*&gt;, oldValue: <span class="hljs-type">T</span>, newValue: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">true</span>    <span class="hljs-comment">//在值修改后调用</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">afterChange</span><span class="hljs-params">(property: <span class="hljs-type">KProperty</span>&lt;*&gt;, oldValue: <span class="hljs-type">T</span>, newValue: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Unit</span> &#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;        <span class="hljs-keyword">return</span> value    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">T</span>)</span></span> &#123;        <span class="hljs-keyword">val</span> oldValue = <span class="hljs-keyword">this</span>.value        <span class="hljs-comment">//返回false 则不进行赋值操作</span>        <span class="hljs-keyword">if</span> (!beforeChange(property, oldValue, value)) &#123;            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">this</span>.value = value        <span class="hljs-comment">//调用继承类复写的 afterChange() 对应外部的则是`onChange`</span>        afterChange(property, oldValue, value)    &#125;&#125;</code></pre><h3 id="可变属性延迟初始化"><a href="#可变属性延迟初始化" class="headerlink" title="可变属性延迟初始化"></a>可变属性延迟初始化</h3><blockquote><p><code>by lazy</code>只对<code>val变量</code>可用，当变量为<code>var</code>时则无法使用，这时就需要用到<code>var value by Delegates.notNull&lt;String&gt;</code>来表示</p></blockquote><h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;  <span class="hljs-keyword">var</span> value <span class="hljs-keyword">by</span> Delegates.notNull&lt;String&gt;    <span class="hljs-keyword">init</span>&#123;    <span class="hljs-comment">//延迟初始化</span>    a= <span class="hljs-string">"init"</span>  &#125;&#125;</code></pre><h4 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h4><pre><code class="hljs kotlin"></code></pre><h2 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Kotlin核心编程》读书笔记-面向对象</title>
    <link href="/2019/06/23/%E3%80%8AKotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/06/23/%E3%80%8AKotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>内容摘自《Kotlin核心编程》第3章，在其基础上对一些概念进行拓展了解</p></blockquote><p>本章主要讲Kotlin中一些面向对象的类和方法讲解以及一些相对Java的优化点。</p><h2 id="类和构造方法"><a href="#类和构造方法" class="headerlink" title="类和构造方法"></a>类和构造方法</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>与Java相同使用<code>class结构体</code>来声明一个类</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span></span>&#123;  <span class="hljs-comment">//颜色</span>  <span class="hljs-keyword">val</span> color :String =<span class="hljs-string">"blue"</span>  <span class="hljs-comment">//年纪</span>  <span class="hljs-keyword">var</span> age : <span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span>  <span class="hljs-comment">//动作</span>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#125;</code></pre><p>上述代码就定义了一个鸟对象（蓝色、1岁、会飞）。</p><p>Kotlin声明类的语法非常类似于Java，但还是存在一些不同</p><ul><li><strong>不可变属性成员</strong>：通过<code>val</code>声明引用不可变的属性成员，在反编译成class时，该参数是由<code>final</code>进行修饰</li><li><strong>属性默认值</strong>：除非显式的声明参数延迟初始化，否则必须指定属性的默认值</li><li><strong>不同的访问修饰符</strong>：Kotlin类中的成员默认是<code>public</code>的，Java的默认可见域是<code>protected</code></li></ul><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><p>Kotlin中的接口与Java 8类似，既包含抽象方法的声明也包含实现。在Java 8引入了一个新特性-<strong>接口方法支持默认实现</strong>。而Kotlin是兼容Java 6，也提供了这种实现。</p><p>Java 8中接口的实现</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyer</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">kind</span><span class="hljs-params">()</span></span>;    <span class="hljs-keyword">int</span> speed = <span class="hljs-number">0</span>;    <span class="hljs-comment">//默认实现</span>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"I can fly"</span>);    &#125;&#125;</code></pre><p>其中<code>fly()</code>是一个默认方法，其他继承该接口的类都不需要实现该方法。</p><p>Kotlin中接口的实现</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyer</span></span>&#123;    <span class="hljs-keyword">val</span> speed:<span class="hljs-built_in">Int</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">kind</span><span class="hljs-params">()</span></span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;        print(<span class="hljs-string">"I can fly"</span>)    &#125;&#125;</code></pre><p>拓展知识：</p><p>Kotlin是如何支持接口的默认方法？</p><p>首先对Kotlin定义的接口进行转换，转成容易理解的Java代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyer</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSpeed</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kind</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultImpls</span> </span>&#123;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(Flyer $<span class="hljs-keyword">this</span>)</span> </span>&#123;         String var1 = <span class="hljs-string">"I can fly"</span>;         <span class="hljs-keyword">boolean</span> var2 = <span class="hljs-keyword">false</span>;         System.out.print(var1);      &#125;   &#125;&#125;</code></pre><p>Kotlin内部通过一个<code>DefaultImpls</code>这个静态内部类提供了<code>fly()</code>的默认实现。</p><p>Kotlin的方法中还支持声明属性，但内部通过观察反编译的Java代码可知是提供了一个<code>get()</code>提供支持，但是无法对接口定义的属性直接进行赋值，也是因为这个原因。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyer</span></span>&#123;  <span class="hljs-comment">//可通过该方法进行实现</span>  <span class="hljs-keyword">val</span> speed     <span class="hljs-keyword">get</span>() = <span class="hljs-number">100</span>&#125;</code></pre><h3 id="构造类对象"><a href="#构造类对象" class="headerlink" title="构造类对象"></a>构造类对象</h3><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> bird = Bird()</code></pre><p>在Kotlin中并不会使用到<code>new</code>关键字，可以直接进行类的声明</p><p>如果构造方法中需要添加参数，直接在<code>Bird()</code>内添加参数即可，不需要进行方法的重载而产生多个方法。</p><p>要实现这种功能，需要依赖下面提到的Kotlin中的相关构造语法</p><h4 id="主从构造函数"><a href="#主从构造函数" class="headerlink" title="主从构造函数"></a>主从构造函数</h4><p>Kotlin中的每个类最多存在一个<strong>主构造函数</strong>以及多个<strong>从构造函数</strong>。</p><h5 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h5><p><code>主构造函数</code>：是类头的一部分，跟在类名之后</p><pre><code class="hljs Kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(name:String) &#123;&#125;或<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">constructor</span></span>(name:String)&#123;&#125;</code></pre><p>一般情况下<code>constructor</code>可进行省略即第一种方式，特殊情况下必须显示（<code>存在注解或者可见性修饰符</code>）。<code>class Person @Deprecated(message = &quot;111&quot;) public constructor(name: String)</code>(一般不会这样写~)</p><p>主构造函数中不能包含任何代码，如果需要初始化要在<code>init语句块</code>中实现，在主构造函数中<code>()</code>内的属性有两种定义方式：</p><ul><li><p><code>class Person(name:String)</code>此时的name是局部变量，无法在其他方法中直接进行使用，只可以在<code>init语句块或属性声明</code>进行使用</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(name:String)&#123;  <span class="hljs-keyword">init</span>&#123;    <span class="hljs-keyword">val</span> length1 = name.length  &#125;  <span class="hljs-keyword">val</span> length2 = name.length  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// name.length 无法调用</span>  &#125;&#125;</code></pre><p>将上述代码反编译成Java代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> length2;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span></span>&#123;    <span class="hljs-keyword">int</span> length1 = name.length();    <span class="hljs-keyword">this</span>.length2 = name.length();  &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> test&#123;    <span class="hljs-comment">//name.length 无法调用</span>  &#125;&#125;</code></pre><p>观察Java代码可知 <code>init{}</code>以及声明时相关逻辑都会在<code>Person(String name)</code>中执行，所以不会出错。</p></li><li><p><code>class Person(val name:String)</code>此时的name是全局变量，可以在任意地方进行使用。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword">val</span> name: String) &#123;    <span class="hljs-keyword">init</span> &#123;        <span class="hljs-keyword">val</span> length1 = name.length    &#125;    <span class="hljs-keyword">val</span> length2 = name.length    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">val</span> length3 = name.length    &#125;&#125;</code></pre><p>将上述代码反编译成Java代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> length2;   <span class="hljs-meta">@NotNull</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;     <span class="hljs-meta">@NotNull</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;   &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> length3 = <span class="hljs-keyword">this</span>.name.length();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(@NotNull String name)</span> </span>&#123;      Intrinsics.checkParameterIsNotNull(name, <span class="hljs-string">"name"</span>);      <span class="hljs-keyword">super</span>();      <span class="hljs-keyword">this</span>.name = name;      <span class="hljs-keyword">int</span> var2 = <span class="hljs-keyword">this</span>.name.length();      <span class="hljs-keyword">this</span>.length2 = <span class="hljs-keyword">this</span>.name.length();   &#125;&#125;</code></pre><p> 此时的<code>name</code>就是一个全局变量，可以在任意地方使用。</p></li></ul><h5 id="从构造函数"><a href="#从构造函数" class="headerlink" title="从构造函数"></a>从构造函数</h5><p><code>从构造函数</code>：由两部分组成：对其他构造方法的委托；另一部分由<code>{}</code>构成的代码块。<strong>如果存在主构造函数，从构造函数都需要直接或间接委托给主构造函数（通过<code>this(...)</code>）。</strong></p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword">val</span> name: String)&#123;    <span class="hljs-comment">//委托主构造函数</span>    <span class="hljs-keyword">constructor</span>(name:String,age:<span class="hljs-built_in">Int</span>):<span class="hljs-keyword">this</span>(name)&#123;         &#125;&#125;</code></pre><p><code>从构造函数</code>参数不能声明<code>val/var</code>。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KotlinView</span> : <span class="hljs-type">View &#123;</span></span>      <span class="hljs-keyword">constructor</span>(context:Context):<span class="hljs-keyword">this</span>(context,<span class="hljs-literal">null</span>)&#123; &#125;      <span class="hljs-keyword">constructor</span>(context:Context,attrs:AttributeSet?):<span class="hljs-keyword">this</span>(context,attrs,<span class="hljs-number">0</span>)&#123; &#125;      <span class="hljs-keyword">constructor</span>(context:Context,attrs:AttributeSet?，defStyleAttr:<span class="hljs-built_in">Int</span>):<span class="hljs-keyword">super</span>(context,attrs,defStyleAttr)&#123; &#125;    &#125;</code></pre><h4 id="构造方法默认参数"><a href="#构造方法默认参数" class="headerlink" title="构造方法默认参数"></a>构造方法默认参数</h4><p>Java在方法重载时需要额外的添加方法，导致方法过多。在Kotlin中可以通过给构造方法中的参数指定默认值，从而避免不必要的方法重载。<strong>当省略相应的参数时需要使用默认值</strong>。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span></span>(<span class="hljs-keyword">val</span> weight:<span class="hljs-built_in">Double</span> = <span class="hljs-number">0.00</span>,<span class="hljs-keyword">val</span> age:<span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span>,<span class="hljs-keyword">val</span> color:String = <span class="hljs-string">"blue"</span>)&#123;&#125;<span class="hljs-comment">//调用Bird对象</span><span class="hljs-keyword">val</span> bird1 = Bird()<span class="hljs-comment">//全部是默认值</span><span class="hljs-keyword">val</span> bird2 = Bird(weight = <span class="hljs-number">1000.00</span>,color=<span class="hljs-string">"white"</span>) <span class="hljs-comment">//重1kg 1岁的 白鸟</span></code></pre><p>由于参数默认值的存在，在创建一个类对象时，<em>最好指定参数的名称</em>（命名参数），否则必须按照实际参数的顺序进行赋值。</p><p>例如上述代码中的<code>weight=1000.00</code>，就是对<code>weight</code>参数进行指定赋值</p><blockquote><p><code>命名参数</code>：在函数调用时使用命名的函数参数，在函数有大量参数或者默认参数时使用方便。</p></blockquote><h4 id="init语句块"><a href="#init语句块" class="headerlink" title="init语句块"></a><code>init</code>语句块</h4><p>由于<code>主构造函数</code>不能包含任何的代码，所以引入了<code>init语句块</code>的语法，可以作为实例的初始化方法。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span></span>(<span class="hljs-keyword">var</span> weight:<span class="hljs-built_in">Double</span> = <span class="hljs-number">0.00</span>,<span class="hljs-keyword">var</span> age:<span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span>,<span class="hljs-keyword">var</span> color:String = <span class="hljs-string">"blue"</span>)&#123;    <span class="hljs-keyword">init</span> &#123;        color = <span class="hljs-string">"Bird color is <span class="hljs-variable">$color</span>"</span>        println(color)    &#125;&#125;</code></pre><p>对<code>color</code>属性在初始化时进行操作。</p><p>在构造方法中还可以拥有多个<code>init语句块</code>，他们会在对象创建时按照类从上到下的顺序先后执行。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span></span>(<span class="hljs-keyword">var</span> weight:<span class="hljs-built_in">Double</span> = <span class="hljs-number">0.00</span>,<span class="hljs-keyword">var</span> age:<span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span>,<span class="hljs-keyword">var</span> color:String = <span class="hljs-string">"blue"</span>)&#123;  <span class="hljs-keyword">init</span> &#123;    color = <span class="hljs-string">"Bird's color is <span class="hljs-variable">$color</span>"</span>    println(<span class="hljs-string">"<span class="hljs-variable">$color</span>"</span>)  &#125;    <span class="hljs-keyword">init</span>&#123;    println(weight)  &#125;    <span class="hljs-keyword">init</span>&#123;    println(age)  &#125;  &#125;<span class="hljs-comment">//输出结果</span>Bird color <span class="hljs-keyword">is</span> blue<span class="hljs-number">0.0</span><span class="hljs-number">1</span></code></pre><p>多个<code>init语句块</code>有利于对初始化的操作进行职能分离，在复杂的业务开发中可以起到很大的作用。</p><h4 id="变量延迟初始化"><a href="#变量延迟初始化" class="headerlink" title="变量延迟初始化"></a>变量延迟初始化</h4><p>一般地，属性声明为非空类型必须在构造函数中进行初始化，否则无法正常编译。Kotlin可以不用在类对象初始化的时候就必须有值。提供了<code>by lazy、lateinit</code>两种语法来实现延迟初始化的效果。</p><h5 id="by-lazy（懒初始化）"><a href="#by-lazy（懒初始化）" class="headerlink" title="by lazy（懒初始化）"></a><code>by lazy（懒初始化）</code></h5><p>如果是用<code>val</code>声明的变量，可以用该语法来修饰</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span></span>(<span class="hljs-keyword">var</span> weight:<span class="hljs-built_in">Double</span> = <span class="hljs-number">0.00</span>,<span class="hljs-keyword">var</span> age:<span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span>,<span class="hljs-keyword">var</span> color:String = <span class="hljs-string">"blue"</span>)&#123;  <span class="hljs-keyword">val</span> sex : String <span class="hljs-keyword">by</span> lazy&#123;    <span class="hljs-keyword">if</span>(color==<span class="hljs-string">"yellow"</span>) <span class="hljs-string">"male"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"female"</span>  &#125; &#125;</code></pre><p>语法特点如下：</p><ul><li>修饰变量必须是<code>val</code></li><li>只有再被首次调用时，才会进行赋值操作，一旦被赋值不会再被修改</li></ul><p><code>lazy()</code>接收一个<code>lambda表达式</code>并返回一个<code>lazy&lt;T&gt;</code>实例的函数，第一次访问该属性时，会执行对应的<code>lazy</code>中的<code>lambda表达式</code>并记录结果，后续访问时只是返回所记录的值。</p><p>另外可以对<code>lazy</code>属性进行设置，共支持三种属性：</p><ul><li><code>LazyThreadSafetyMode.SYNCHRONIZED(默认属性)</code>：加上同步锁，在同一时刻只允许一个线程对<code>lazy</code>属性进行初始化，所以是<strong>线程安全</strong>。</li><li><code>LazyThreadSafetyMode.PUBLICATION</code>：允许多个线程进行初始化操作</li><li><code>LazyThreadSafetyMode.NONE</code>：若确定初始化总是发生单线程上，可以设置该参数，就不会存在线程方面的开销。</li></ul><p><code>by lazy</code>内部实现原理涉及到<strong>属性委托</strong>相关概念，后面会讲到相关内容。</p><h5 id="lateinit（延迟初始化）"><a href="#lateinit（延迟初始化）" class="headerlink" title="lateinit（延迟初始化）"></a><code>lateinit（延迟初始化）</code></h5><p><code>lateinit</code>允许编译器识别非空类型属性的值然后跳过空检查，使之正常编译。</p><p><code>lateinit</code>主要用于<code>var</code>声明变量，然而<strong>不支持修饰基本类型(Int,Long)，因为基本类型的属性在类加载后的准备阶段会被初始化为默认值。需要用<code>Integer</code>这类包装类来替代。</strong></p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span></span>(<span class="hljs-keyword">var</span> weight:<span class="hljs-built_in">Double</span> = <span class="hljs-number">0.00</span>,<span class="hljs-keyword">var</span> age:<span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span>,<span class="hljs-keyword">var</span> color:String = <span class="hljs-string">"blue"</span>)&#123;    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> sex : String&#125;</code></pre><blockquote><p>使用<code>lateinit</code>关键字的时候，只是跳过了编译器的校验，如果在使用时没有进行赋值还是会出错。</p></blockquote><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>除了<code>by lazy</code>还有一种方案可以实现变量延迟初始化，通过使用<code>Delegates.notNull&lt;T&gt;</code>，也是利用了<code>委托</code>这个概念实现的。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">by</span> Delegates.notNull&lt;String&gt;()<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">()</span></span>&#123;  a=<span class="hljs-string">"test"</span>&#125;</code></pre><h2 id="不同的访问控制原则"><a href="#不同的访问控制原则" class="headerlink" title="不同的访问控制原则"></a>不同的访问控制原则</h2><p>与Java一样，Kotlin也提供了各种修饰符来描述<em>类、方法，属性的可见性</em>。</p><h3 id="限制修饰符"><a href="#限制修饰符" class="headerlink" title="限制修饰符"></a>限制修饰符</h3><blockquote><p>用于指定<code>类、方法或属性</code>的修改或者重写权限，就会用到<code>限制修饰符</code>。</p></blockquote><p>Kotlin定义的类是默认<code>final</code>即不可继承和修改，使程序变得更加安全，但是会在开发过程中带来很多的不便。在Java中类是默认可以被继承，除非主动添加<code>final</code>修饰符。</p><p>Kotlin提供了<code>open</code>修饰符使类可以被继承，若需要一个方法可以被重写，也需要添加<code>open</code>修饰。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> </span>&#123;  <span class="hljs-keyword">val</span> weight : <span class="hljs-built_in">Double</span> = <span class="hljs-number">500.0</span>  <span class="hljs-keyword">val</span> age = <span class="hljs-number">1</span>  <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maque</span> : <span class="hljs-type">Bird</span></span>()&#123;  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#125;</code></pre><p>除了<code>open</code>限制修饰符，Kotlin提供了<code>final、abstract</code>，两者的效果与Java对应修饰符一致。</p><table><thead><tr><th>修饰符</th><th>含义</th><th>与Java比较</th></tr></thead><tbody><tr><td>open</td><td>允许被继承或重写</td><td>Java默认类设置</td></tr><tr><td>abstract</td><td>抽象类或抽象方法</td><td>效果一致</td></tr><tr><td>final</td><td>不允许被继承与重写（默认设置）</td><td>与Java<code>fianl</code>修饰符效果一致</td></tr></tbody></table><h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><blockquote><p>不管是<code>类、对象、接口、方法、属性</code>都具有<code>可见性修饰符</code>，Kotlin提供了以下四种修饰符，在不同的场景下有不同的功能。</p></blockquote><h4 id="public"><a href="#public" class="headerlink" title="public"></a><code>public</code></h4><p>Kotlin的默认修饰符，表示<strong>声明随处可用</strong>。与Java中的<code>public</code>功能一致</p><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a><code>protected</code></h4><p>Kotlin设置该修饰符后，只允许<code>类及子类</code>访问，在Java中还允许同<code>包</code>下类文件访问</p><h4 id="private"><a href="#private" class="headerlink" title="private"></a><code>private</code></h4><p>表示该类私有，只能在当前文件中进行访问，Java中不允许对类进行<code>private</code>修饰</p><h4 id="internal"><a href="#internal" class="headerlink" title="internal"></a><code>internal</code></h4><p>Kotlin特有修饰符，只允许在<strong>模块中进行访问</strong>。</p><blockquote><p>模块：一起编译的Kotlin文件的集合。包括以下几种：</p><ul><li>一个Eclipse项目</li><li>一个Intellij IDEA项目</li><li>一个Maven项目</li><li>一个Gradle项目</li><li>由Ant任务执行编译的代码</li></ul></blockquote><p>提供该修饰符的原因：保证类的安全性，保证只在当前模块中调用，外部如果需要调用只能拷贝源码。</p><table><thead><tr><th>修饰符</th><th>含义</th><th>与Java比较</th></tr></thead><tbody><tr><td><code>public</code></td><td><strong>Kotlin默认修饰符</strong><br>全局可见</td><td>等同于Java中的<code>public</code>效果</td></tr><tr><td><code>private</code></td><td><strong>私有修饰符</strong><br>类内修饰，只有本类可见<br>类外修饰，文件内可见</td><td>只有类内可见</td></tr><tr><td><code>protected</code></td><td><strong>受保护修饰符</strong><br>本类及子类可见</td><td>作用域除了本类与子类，还包括包内可见</td></tr><tr><td><code>internal</code></td><td><strong>内部可见修饰符</strong><br>模块内可见</td><td>无</td></tr></tbody></table><p><code>private</code>修饰符功能代码解释</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(<span class="hljs-keyword">val</span> bookName: String) &#123;    <span class="hljs-comment">//类内修饰</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> privateBook = <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;        <span class="hljs-keyword">val</span> bird = Maque()    &#125;&#125;<span class="hljs-comment">//类外修饰</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> privateOutVal = <span class="hljs-number">2</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maque</span> : <span class="hljs-type">Bird</span></span>() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> aaa = <span class="hljs-number">1</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span> &#123;        println(<span class="hljs-string">"Maque fly"</span>+ privateOutVal) <span class="hljs-comment">// Maquefly2</span>    &#125;&#125;</code></pre><h2 id="解决多继承问题"><a href="#解决多继承问题" class="headerlink" title="解决多继承问题"></a>解决多继承问题</h2><p>Java是不支持类的多继承，Kotlin亦是如此。但是Kotlin可以通过特殊的语法提供多种不同的多继承解决方案。<strong>多继承最大的问题就是导致继承关系的语义混淆</strong>。</p><h3 id="多继承困惑"><a href="#多继承困惑" class="headerlink" title="多继承困惑"></a>多继承困惑</h3><p>容易导致<strong>钻石问题(菱形继承问题)</strong>，在类的多重继承下，会在继承关系下产生歧义。并且会导致代码维护上的困扰以及代码的耦合性增加。</p><h3 id="接口实现多继承"><a href="#接口实现多继承" class="headerlink" title="接口实现多继承"></a>接口实现多继承</h3><p>一个类可以实现多个接口，在Java中是很常见的。Kotlin中的接口还可以<code>声明抽象的属性</code>，这个可以帮助Kotlin来通过接口实现多继承。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NewFlyer</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">kind</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"flying animals"</span>&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NewAnimal</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">kind</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"flying new animals"</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewBird</span></span>(<span class="hljs-keyword">val</span> name:String):NewFlyer,NewAnimal&#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span> &#123;        println(<span class="hljs-string">"I can fly"</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">kind</span><span class="hljs-params">()</span></span>: String &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>&lt;NewAnimal&gt;.kind()    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;        println(<span class="hljs-string">"I can eat"</span>)    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;    <span class="hljs-keyword">val</span> bird = NewBird(<span class="hljs-string">"Maque"</span>)    println(bird.kind())&#125;<span class="hljs-comment">//输出</span>flying new animals</code></pre><p>上述定义的<code>NewFlyer、NewAnimal</code>接口，都设置了<code>kind()</code>，就会引起继承上的歧义问题。Kotlin通过提供<code>super&lt;T&gt;</code>用来指定继承哪个父类接口方法。</p><h3 id="内部类实现多继承"><a href="#内部类实现多继承" class="headerlink" title="内部类实现多继承"></a>内部类实现多继承</h3><blockquote><p>内部类：将一个类的定义放在另一个类的内部，内部类可以继承一个与外部类无关的类，保证了内部类的独立性。内部类会带有一个对外部类对象的引用。</p></blockquote><h4 id="Kotlin实现内部类"><a href="#Kotlin实现内部类" class="headerlink" title="Kotlin实现内部类"></a>Kotlin实现内部类</h4><p>在Java中是如下实现内部类的</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterJava</span></span>&#123;  <span class="hljs-keyword">private</span> String name = <span class="hljs-string">"inner class"</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerJava</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span></span>&#123;      System.out.println(name) <span class="hljs-comment">//inner class</span>    &#125;  &#125;&#125;</code></pre><p>Kotlin仿照上述实现</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterKotlin</span></span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name = <span class="hljs-string">"inner class"</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerKotlin</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span></span>&#123;      print(<span class="hljs-string">"<span class="hljs-variable">$name</span>"</span>) <span class="hljs-comment">//Unresolved reference ：name</span>    &#125;  &#125;&#125;</code></pre><p>这个时候，<code>InnerKotlin</code>属于嵌套类。</p><blockquote><p>嵌套类：不包含对外部类实例的引用，无法调用其外部类的属性。</p></blockquote><p>真正的实现方案</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterKotlin</span></span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name = <span class="hljs-string">"inner class"</span>  <span class="hljs-keyword">inner</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerKotlin</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span></span>&#123;      print(<span class="hljs-string">"<span class="hljs-variable">$name</span>"</span>) <span class="hljs-comment">//inner class</span>    &#125;  &#125;&#125;</code></pre><p>利用<code>inner</code>关键字就可以实现内部类。</p><h4 id="内部类多继承方案"><a href="#内部类多继承方案" class="headerlink" title="内部类多继承方案"></a>内部类多继承方案</h4><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Horse</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFast</span><span class="hljs-params">()</span></span>&#123;        println(<span class="hljs-string">"like horse runFast"</span>)    &#125;&#125;<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Donkey</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFast</span><span class="hljs-params">()</span></span>&#123;        println(<span class="hljs-string">"like Donkey runFast"</span>)    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mule</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">inner</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HorseC</span>:<span class="hljs-type">Horse</span></span>()    <span class="hljs-keyword">private</span> <span class="hljs-keyword">inner</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DonkeyC</span>:<span class="hljs-type">Donkey</span></span>()    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runFast</span><span class="hljs-params">()</span></span>&#123;        HorseC().runFast()    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runSlow</span><span class="hljs-params">()</span></span>&#123;        DonkeyC().runFast()    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;    <span class="hljs-keyword">val</span> mule = Mule()    mule.runFast()    mule.runSlow()&#125;</code></pre><ol><li>可以在一个类内部定义多个内部类，每个内部类的实例都有自己的独立状态并且与外部的信息相互独立</li><li>通过内部类继承外部类，可以在实例对象中获得外部类不同的状态和行为</li><li>可以通过<code>private</code>修饰内部类，避免其他类访问内部类，保证封装性。</li></ol><h3 id="使用委托代替多继承"><a href="#使用委托代替多继承" class="headerlink" title="使用委托代替多继承"></a>使用委托代替多继承</h3><p><strong>委托</strong>是Kotlin新引入的语法</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/65914552" target="_blank" rel="noopener">Kotlin懒加载语法</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Kotlin核心编程》读书笔记-基础语法</title>
    <link href="/2019/06/19/%E3%80%8AKotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2019/06/19/%E3%80%8AKotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>内容摘自《Kotlin核心编程》第2章，在其基础上对一些概念进行拓展了解</p></blockquote><p>本章主要讲Kotlin一些基础语法.</p><h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p><em>尽可能采用<code>val</code>、不可变对象及纯函数来设计程序。</em></p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = <span class="hljs-string">"Hello World"</span>或<span class="hljs-keyword">val</span> a:String = <span class="hljs-string">"Hello World"</span></code></pre><blockquote><p><code>val</code>：引用不可变。反编译后的Java代码中是通过<code>final</code>对变量进行修饰。<strong>声明了只读变量，引用对象不可变，但是可以修改对象中的可变成员。</strong></p><p>Java中的变量默认是可变的，在开发过程中很容易因为使用方式导致变量发生变化出现不可预期的错误。</p><p><code>var</code>：引用可变。<strong>可以让程序的表达显得直接、易于理解。</strong></p></blockquote><p>上述代码中的<code>:String</code>可以进行省略，由于Kotlin提供了更智能的<code>Smart Casts</code>，可以对类型自动进行推导，提升开发效率。</p><h3 id="声明函数返回类型"><a href="#声明函数返回类型" class="headerlink" title="声明函数返回类型"></a>声明函数返回类型</h3><pre><code class="hljs kotlin"><span class="hljs-comment">//代码块函数体</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(x:<span class="hljs-type">Int</span>,y:<span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span> &#123;  <span class="hljs-keyword">return</span> x+y&#125;或<span class="hljs-comment">//表达式函数体</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(x:<span class="hljs-type">Int</span>,y:<span class="hljs-type">Int</span>)</span></span>:<span class="hljs-built_in">Int</span> = x+y<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">(text:<span class="hljs-type">String</span>)</span></span> <span class="hljs-comment">/*: Unit*/</span>&#123;  <span class="hljs-comment">//do sth</span>&#125;</code></pre><p>函数如果没有指定返回值，默认使用<code>Unit</code>类型，如果需要指定返回值类型，就必须要进行声明，否则会抛出异常。</p><blockquote><p>暂时可以把<code>Unit</code>认为类似于Java中的<code>void</code></p></blockquote><h2 id="高阶函数与Lambda"><a href="#高阶函数与Lambda" class="headerlink" title="高阶函数与Lambda"></a>高阶函数与Lambda</h2><p>Kotlin天然支持部分函数式特征。<strong>函数是头等公民</strong></p><blockquote><p><code>高阶函数</code>：以其他函数作为参数或返回值的函数，高阶函数是一种更加高级的抽象机制，极大的增强了语言的表达能力。</p></blockquote><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><p>函数类型的声明格式非常简单：<code>(Int) -&gt; Unit</code></p><p>Kotlin的函数类型声明需要遵循以下几点：</p><ul><li>通过<code>-&gt;</code>来组织参数类型和返回值类型，左边是参数类型，右边是返回值类型。</li><li>必须用一个括号来包裹参数类型</li><li>返回值类型即使是<code>Unit</code>也需要显式声明</li></ul><p><code>高阶函数</code>支持返回另一个函数：<code>(Int)-&gt;((Int)-&gt;Unit)</code></p><h3 id="方法和成员引用"><a href="#方法和成员引用" class="headerlink" title="方法和成员引用"></a>方法和成员引用</h3><p>Kotlin存在一种特殊的语法，可以通过<code>::</code>实现对于某个类的方法进行引用。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(<span class="hljs-keyword">val</span> bookName:String)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;    <span class="hljs-keyword">val</span> getBook = ::Book    println(getBook(<span class="hljs-string">"Kotlin"</span>).bookName)    <span class="hljs-comment">//println(getBook("Kotlin")::bookName.get()) 输出Kotlin</span>&#125;</code></pre><p><code>::Book</code>等价于<code>new Book()</code>  <code>getBook(&quot;Kotlin&quot;)</code>等价于<code>new Book(&quot;Kotlin&quot;)</code></p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote><p>只能用在函数的参数中，不支持单独定义</p></blockquote><p>Kotlin支持在缺省函数名的情况下，直接定义一个函数。</p><pre><code class="hljs kotlin"><span class="hljs-comment">//empty其实就是一个入参为 String 出参为 Boolean的函数</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showName</span><span class="hljs-params">(aName: <span class="hljs-type">String</span>, empty: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>: String &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (empty(aName)) <span class="hljs-string">"Empty Name"</span>    <span class="hljs-keyword">else</span> aName&#125;showName(<span class="hljs-string">"nihao"</span>, <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<span class="hljs-keyword">return</span> name.isEmpty()&#125;)</code></pre><p>其中<code>fun(name: String): Boolean {...}</code>就是一个匿名函数，避免创建大量方法</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>本质是一个<strong>简化表达后的匿名函数</strong>。以表达式形式传递的未声明函数。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;简化：<span class="hljs-keyword">val</span> sum1 =  &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<span class="hljs-keyword">val</span> sum2: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x, y -&gt; x + y &#125;</code></pre><p>上述都是Lambda表达式</p><p>总结下Lambda的语法：</p><ul><li>一个Lambda表达式必须通过<code>{}</code>包裹</li><li>如果Lambda声明了参数的类型，且返回值支持类型推导，Lambda变量就可以忽略函数类型声明<code>类似sum1</code></li><li>如果Lambda声明了函数类型，那么Lambda就可以忽略参数部分的类型声明</li></ul><h4 id="单个参数的隐式名称"><a href="#单个参数的隐式名称" class="headerlink" title="单个参数的隐式名称"></a>单个参数的隐式名称</h4><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list: List&lt;String&gt; = listOf(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span></span>&#123;  list.forEach&#123;it -&gt; print(it)&#125;&#125;</code></pre><p>其中声明了<code>it</code>这个关键字，表示的就是<code>单个参数的隐式名称</code>。只针对于单个参数时使用</p><h4 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h4><p>Kotlin在JVM层设计了<code>Function类型</code>，主要就是为了<strong>兼容Java端的Lambda表达式(在JDK8之后添加了支持)</strong>。</p><p>后续的更新中会具体讲到该类型的使用</p><h4 id="invoke"><a href="#invoke" class="headerlink" title="invoke()"></a><code>invoke()</code></h4><p>高阶函数可以以<code>其他函数</code>作为参数或者返回值，我们调用的<code>其他函数</code>实质只是构造了一个<code>Function类型的对象</code>，需要调用到<code>invoke()</code>才能实质去执行该函数。</p><h3 id="柯里化风格"><a href="#柯里化风格" class="headerlink" title="柯里化风格"></a>柯里化风格</h3><blockquote><p><code>柯里化</code>：接收多个参数的函数转变成接收一个单一参数(最初函数的第一个参数)的函数，并且返回接收余下的参数而返回结果的新函数。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(x:<span class="hljs-type">Int</span>,y:<span class="hljs-type">Int</span>,z:<span class="hljs-type">Int</span>)</span></span>:<span class="hljs-built_in">Int</span> = x+y+z<span class="hljs-comment">//柯里化换换</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(x:<span class="hljs-type">Int</span>)</span></span> = &#123;  y:<span class="hljs-built_in">Int</span> -&gt; &#123;    z:<span class="hljs-built_in">Int</span> -&gt; x+y+z  &#125;&#125;</code></pre><p>上述两种函数是等价的。</p><p>在Kotlin中柯里化只是一种近似的效果，并不是真正意义上的柯里化。</p><h2 id="面向表达式编程"><a href="#面向表达式编程" class="headerlink" title="面向表达式编程"></a>面向表达式编程</h2><blockquote><p>在Kotlin中利用了各种表达式来增强程序的表达以及流程控制能力。</p></blockquote><p><code>语句</code>：程序往往都是由一个个语句组成的。以一行作为一个语句</p><p><code>表达式</code>：表达式可以是一个值、常量、变量、操作符、函数，或他们之间的组合，编程语言对其进行解释和计算，以求产生另一个值。</p><h3 id="表达式比语句更安全"><a href="#表达式比语句更安全" class="headerlink" title="表达式比语句更安全"></a>表达式比语句更安全</h3><p>表达式目的是产生另一个值，相比于语句增加了安全性。</p><h3 id="复合表达式"><a href="#复合表达式" class="headerlink" title="复合表达式"></a>复合表达式</h3><p>表达式具备更好的<strong>隔离性</strong>，在使用表达式时就可保证更好的安全性。</p><blockquote><p>表达式由于返回的都是值，可以更好的进行组合，可以将一个表达式作为另一个表达式的组成部分，而后形成一个复合表达式。</p></blockquote><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><pre><code class="hljs kotlin"><span class="hljs-comment">//普通枚举类</span><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RGB</span> </span>&#123; RED, GREEN, BLUE &#125;<span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RGB</span></span>(<span class="hljs-keyword">val</span> index:<span class="hljs-built_in">Int</span>)&#123;  RED(<span class="hljs-number">1</span>),  GREEN(<span class="hljs-number">2</span>),  BLUE(<span class="hljs-number">3</span>);  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Int</span>&#123;    <span class="hljs-keyword">return</span> index;  &#125;&#125;</code></pre><blockquote><p>当在枚举类中存在额外的方法或属性定义时，必须强制加上<code>;</code>。</p></blockquote><p>定义完成后，对枚举类进行调用</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> color = Day.valueOf(<span class="hljs-string">"GREEN"</span>).index <span class="hljs-comment">//2</span>或<span class="hljs-keyword">val</span> color = enumValueOf&lt;Day&gt;(<span class="hljs-string">"MON"</span>).index <span class="hljs-comment">//2</span></code></pre><h4 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a><code>when</code>表达式</h4><blockquote><p><code>when</code>表达式类似<code>switch</code>语句，由<code>when</code>关键字开始，用<code>{}</code>包含多个逻辑分支，每个分支有<code>-&gt;</code>连接。按照条件由上到下匹配，直到匹配完为止。否则执行<code>else</code>分支的逻辑等价于<code>switch中的default</code>。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">when</span>(x)&#123;  -<span class="hljs-number">2</span>,-<span class="hljs-number">1</span> -&gt; println(<span class="hljs-string">"负数"</span>)  <span class="hljs-number">0</span> -&gt; println(<span class="hljs-string">"是0"</span>)  <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">"其他值"</span>)&#125;</code></pre><p><strong>后续会有<code>when</code>相关高级用法</strong></p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h4><blockquote><p><code>for</code>可以对任何提供迭代器(iterator)的对象进行遍历，例如<code>List、Map</code>。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">3</span>) println(i) <span class="hljs-comment">//1 2 3</span><span class="hljs-keyword">val</span> list = listOf&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> list) println(i) <span class="hljs-comment">// 1 2 3</span></code></pre><h5 id="范围表达式"><a href="#范围表达式" class="headerlink" title="范围表达式"></a>范围表达式</h5><p>上面讲到的<code>1..3</code>就是<code>范围表达式</code>的一种。</p><blockquote><p>范围表达式需要通过<code>rangeTo()</code>实现，通过<code>..</code>操作符与某种类型的对象组成，除了整型等基本类型之外，还需要去实现<code>Comparable</code>接口。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//顺序打印</span><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">3</span>) print(i) <span class="hljs-comment">//1 2 3</span><span class="hljs-comment">//指定步长打印</span><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> step <span class="hljs-number">2</span>)<span class="hljs-comment">//1 3 5</span><span class="hljs-comment">//倒序打印</span><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">5</span> downTo <span class="hljs-number">1</span> step <span class="hljs-number">2</span>)<span class="hljs-comment">//5 3 1</span><span class="hljs-comment">//半开区间</span><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> until <span class="hljs-number">4</span>) <span class="hljs-comment">//1 2 3</span></code></pre><p>上述的<code>in</code>关键字除了可以在范围表达式中当做循环使用，还可以用于<em>检查一个元素是否是一个区间或集合中的成员</em>。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list: List&lt;String&gt; = listOf(<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>)<span class="hljs-string">"2"</span> <span class="hljs-keyword">in</span> list <span class="hljs-comment">//true</span></code></pre><p>补充：</p><ol><li><p>可以通过<code>withIndex()</code>输出一个键值元组</p><pre><code class="hljs kotlin">    <span class="hljs-keyword">for</span> ((index, value) <span class="hljs-keyword">in</span> list.withIndex()) &#123;          println(<span class="hljs-string">"<span class="hljs-variable">$index</span> =&gt; <span class="hljs-variable">$value</span>"</span>)    &#125;<span class="hljs-comment">// 0 =&gt; 1</span><span class="hljs-comment">// 1 =&gt; 2</span><span class="hljs-comment">// 2 =&gt; 3</span></code></pre></li></ol><h4 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h4><blockquote><p>上述讲到了一些<code>in downTo step</code>这些的调用方式与普通<code>.</code>不同，他们是直接忽略了<code>.以及()</code>，这些就称之为<code>中缀表达式</code>。</p></blockquote><p>定义一个<code>中缀函数</code>必须满足以下要求：</p><ul><li>必须是某个类型的<strong>拓展函数或者成员方法</strong></li><li>只能有一个参数</li><li>参数必须不是<strong>可变参数</strong>且<strong>参数不能有默认值</strong></li></ul><blockquote><p><code>可变参数</code>：支持接收可变数量的参数，在Java中用<code>Arg...</code>来进行表示且必须是放在最后一个参数，Kotlin采用的是<code>vararg</code>进行表示，可以放在任意位置。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letters: Array&lt;String&gt; = arrayOf(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>)<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printLetters</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> letters: <span class="hljs-type">String</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> (letter <span class="hljs-keyword">in</span> letters)        print(letter)&#125;<span class="hljs-comment">//使用*传入外部的变量作为可变参数的变量</span>printLetters(*letters)</code></pre><p>示例：</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">called</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> &#123;        println(<span class="hljs-string">"my name is <span class="hljs-variable">$name</span>"</span>)    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callName</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//      called("World")</span>        <span class="hljs-keyword">this</span> called <span class="hljs-string">"World"</span><span class="hljs-comment">//在接收者自身调用 中缀函数时 需要显式指定 this</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;  <span class="hljs-keyword">val</span> p = Person()  <span class="hljs-comment">//p.called("Hello")</span>  p called <span class="hljs-string">"Hello"</span> <span class="hljs-comment">//my name is Hello</span>  p.callName() <span class="hljs-comment">//my name is World</span>&#125;</code></pre><h3 id="字符串的定义和操作"><a href="#字符串的定义和操作" class="headerlink" title="字符串的定义和操作"></a>字符串的定义和操作</h3><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> str = <span class="hljs-string">"Hello World"</span>str.length <span class="hljs-comment">//11</span>str.subString(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)<span class="hljs-comment">//Hello</span>str.replace(<span class="hljs-string">"World"</span>,<span class="hljs-string">"Kotlin"</span>) <span class="hljs-comment">//Hello Kotlin</span>str[<span class="hljs-number">0</span>] <span class="hljs-comment">//H</span>str.first() <span class="hljs-comment">//H</span>str.last() <span class="hljs-comment">//d</span><span class="hljs-comment">//是否为空</span>str.isEmpty()<span class="hljs-comment">//false</span></code></pre><h4 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h4><ol><li><p>定义原生字符串</p><pre><code class="hljs kotlin">    <span class="hljs-keyword">val</span> rawString = <span class="hljs-string">"""HelloWorld"""</span></code></pre></li></ol><p>   利用<code>&quot;&quot;&quot;&quot;&quot;&quot;</code>包裹的内容最终打印出的格式与代码定义格式保持一致。</p><ol start="2"><li>字符串模板</li></ol><blockquote><p>字符串中可以包含<code>模板表达式(一小段代码)</code>，通过<code>$</code>做开头以标记，单纯放入一个参数(<code>$arg</code>)，或放置一个表达式(<code>${expression}</code>)。</p><p><strong>大大提升了代码的紧凑性与可读性。</strong></p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> str = <span class="hljs-string">"Kotlin"</span>print(<span class="hljs-string">"It is <span class="hljs-variable">$str</span>"</span>) <span class="hljs-comment">//It is Kotlin</span>print(<span class="hljs-string">"<span class="hljs-variable">$str</span> length is <span class="hljs-subst">$&#123;str.length&#125;</span>"</span>)<span class="hljs-comment">//6</span></code></pre><ol start="3"><li><p>字符串判等</p><p>Koltin判断是否相等主要有两种类型：</p><ul><li><p><strong>结构相等</strong>：判断内容是否相等</p><p>通过<code>==</code>来进行判断，否定是用<code>!=</code>表示</p></li><li><p><strong>引用相等</strong>：判断两个对象的引用是否相等</p><p>通过<code>===</code>进行判断，否定是用<code>!==</code>表示</p></li></ul><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"Java"</span><span class="hljs-keyword">var</span> b = <span class="hljs-string">"Java"</span>print(a==b)<span class="hljs-comment">//true</span>print(a===b)<span class="hljs-comment">//false</span></code></pre></li></ol><p>更多操作可以参考<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html" target="_blank" rel="noopener">String API</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle学习笔记-Project</title>
    <link href="/2019/06/14/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Project/"/>
    <url>/2019/06/14/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Project/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Project</code>对应着项目中的<code>build.gradle</code>文件，每个gradle文件被解析后都会生成一个Project对象。所有<code>build.gradle</code>中定义的属性及方法都可以通过<code>Project</code>进行调用。</p></blockquote><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#N153F9" target="_blank" rel="noopener">Project官方文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle学习笔记-Task</title>
    <link href="/2019/05/08/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Task/"/>
    <url>/2019/05/08/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Task/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Gradle的两个重要的概念：<code>Project</code>和<code>Task</code>，一个<code>Project</code>由多个<code>Task</code>组成。</p></blockquote><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><blockquote><p>Gradle脚本中的最小执行单元，也是Gradle中的一个原子操作。</p></blockquote><h3 id="Task-Result-任务结果"><a href="#Task-Result-任务结果" class="headerlink" title="Task Result(任务结果)"></a>Task Result(任务结果)</h3><p>当Task执行时，最终控制台都会输出执行的结果，后面都会带有一个标签，这些标签表示了<em>是否有Task需要执行，是否执行了Task</em>等状态。</p><table><thead><tr><th>结果标签</th><th>结果描述</th><th>如何触发</th></tr></thead><tbody><tr><td>没有标签<br>EXECUTED</td><td>任务执行完毕</td><td>任务有动作且被执行</td></tr><tr><td>UP-TO-DATE</td><td>任务输出没有改变</td><td>任务没有动作也没有依赖<br>任务有输入输出但是没有发生变化<br>任务没有动作但存在依赖，且依赖非执行完毕</td></tr><tr><td>NO-SOURCE</td><td>任务不需要执行</td><td>包含了输入输出，但是没有Sources？？？</td></tr><tr><td>FROM-CACHE</td><td>在缓存中找到了任务执行结果</td><td>构建缓存中已存在构建结果</td></tr><tr><td>SKIPPED</td><td>任务没有执行</td><td>指定跳过该任务<br>任务设置了<code>onlyIf</code>且返回false<br>任务被禁用<code>enabled=false</code></td></tr></tbody></table><h3 id="Task-Create-创建任务"><a href="#Task-Create-创建任务" class="headerlink" title="Task Create(创建任务)"></a>Task Create(创建任务)</h3><pre><code class="hljs groovy">task createTask1 &lt;&lt; &#123;  println <span class="hljs-string">"doLast in createTask1"</span>&#125;task createTask2 doLast &#123;  println <span class="hljs-string">"doLast in createTask2"</span>&#125;<span class="hljs-comment">//三种方式皆可</span>project.task(<span class="hljs-string">"createTask3"</span>).doLast &#123;  println <span class="hljs-string">"doLast in createTask3"</span>&#125;project.task(<span class="hljs-string">"createTask3"</span>) doLast &#123;  println <span class="hljs-string">"doLast in createTask3"</span>&#125;project.task(<span class="hljs-string">"createTask3"</span>) &lt;&lt; &#123;  println <span class="hljs-string">"doLast in createTask3"</span>&#125;<span class="hljs-comment">//通过TaskContainer创建Task</span>project.tasks.create(<span class="hljs-string">"createTask4"</span>).doLast &#123;   println <span class="hljs-string">"doLast in createTask4"</span>&#125;project.tasks.create(<span class="hljs-string">"createTask4"</span>) doLast &#123;   println <span class="hljs-string">"doLast in createTask4"</span>&#125;project.tasks.create(<span class="hljs-string">"createTask4"</span>) &lt;&lt; &#123;   println <span class="hljs-string">"doLast in createTask4"</span>&#125;</code></pre><blockquote><p>其中<code>&lt;&lt;</code>等价于<code>doLast</code>，但是在<code>Gradle 5.0</code>之后该方法已被废弃。</p></blockquote><p>上述只是基础的创建方法，创建时还包括了其他的参数。</p><table><thead><tr><th>参数名</th><th>含义</th><th>参数属性</th></tr></thead><tbody><tr><td>name</td><td>任务名称</td><td>必须有值，不能为空</td></tr><tr><td>description</td><td>任务描述</td><td>可以为空</td></tr><tr><td>group</td><td>任务所属分组名</td><td>可以为空</td></tr><tr><td>type</td><td>任务的父类</td><td>默认为<code>org.gradle.api.DefaultTask</code></td></tr><tr><td><strong>dependsOn</strong></td><td>任务依赖的其他Task</td><td>可以为空</td></tr><tr><td>overwrite</td><td>是否覆盖已存在的同名任务</td><td>false</td></tr><tr><td>constructorArgs</td><td>任务构造函数参数</td><td>可以为空(若依赖父类有构造参数，需要设置值)</td></tr><tr><td><strong>action</strong></td><td>任务的顺序执行序列</td><td><code>doLast(最后执行)</code>、<code>doFirst(最先执行)</code></td></tr></tbody></table><h3 id="Task-Action-执行序列"><a href="#Task-Action-执行序列" class="headerlink" title="Task Action(执行序列)"></a>Task Action(执行序列)</h3><blockquote><p>一个<code>Task</code>由一系列<code>Action</code>组成的，通过设置<code>action</code>，实质上就是在创建Task时调用到的<code>doFirst</code>、<code>doLast</code>这两个方法。</p></blockquote><pre><code class="hljs groovy">task Task1 &#123;  println <span class="hljs-string">"Task configure"</span>  doFirst &#123;    println <span class="hljs-string">"Task doFirst"</span>  &#125;  doLast &#123;    println <span class="hljs-string">"Task doLast"</span>  &#125;&#125;</code></pre><p>上述代码不同的执行方式结果不同</p><ul><li><p>执行整个<code>gradle</code>文件：</p><pre><code class="hljs xml">Task configure</code></pre></li><li><p>执行<code>Task1</code>：<code>./gradlew Task1</code></p><pre><code class="hljs xml">Task configureTask doFirstTask doLast</code></pre></li></ul><p>观察上述结果，得出以下结论</p><blockquote><p>在创建Task时，除了<code>doFirst</code>、<code>doLast</code>之外的代码，都定义为<code>Task</code>的配置项，在脚本的配置阶段都会执行；而<code>doFirst</code>、<code>doLast</code>代码只会在<code>Task</code>真正执行时才会调用(gradle 指定运行该<code>Task</code>)。</p></blockquote><h3 id="Task-DependsOn-执行依赖"><a href="#Task-DependsOn-执行依赖" class="headerlink" title="Task DependsOn(执行依赖)"></a>Task DependsOn(执行依赖)</h3><blockquote><p>Gradle中的任务执行顺序是不确定的，需要通过task之间的依赖关系，保证被依赖的task优先执行，可通过<code>dependsOn</code>来确定依赖关系。</p></blockquote><pre><code class="hljs groovy">task first doLast &#123;    println(<span class="hljs-string">"first"</span>)&#125;task second doLast &#123;    println(<span class="hljs-string">"second"</span>)&#125;<span class="hljs-comment">//second 依赖于 first</span>second.dependsOn(first)<span class="hljs-comment">//third 依赖于 first,second</span>task third(<span class="hljs-string">dependsOn:</span>[first, second]) doLast &#123;    println(<span class="hljs-string">"third"</span>)&#125;</code></pre><p>此时调用<code>./gradlew third</code></p><pre><code class="hljs xml">输出结果&gt; Task :plugin:firstfirst&gt; Task :plugin:secondsecond&gt; Task :plugin:thirdthird</code></pre><p>由于<code>third</code>依赖于<code>first、second</code>所以在执行<code>third</code>时，<code>first、second</code>也需要执行。</p><h3 id="Task-Type-任务类型"><a href="#Task-Type-任务类型" class="headerlink" title="Task Type(任务类型)"></a>Task Type(任务类型)</h3><blockquote><p>默认Type为<code>DefaultTask</code>，系统还提供了几种常用的类型以供使用，也可以通过自定义Type来实现功能。</p></blockquote><h4 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a><a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Copy.html" target="_blank" rel="noopener">Copy</a></h4><blockquote><p>将文件复制到目标目录，此任务在复制时也可以执行重命名和过滤文件操作。</p></blockquote><pre><code class="hljs groovy">task CopyFile(<span class="hljs-string">type:</span>Copy)&#123;    <span class="hljs-comment">//源文件目录</span>    from <span class="hljs-string">'../app/src/main'</span>    <span class="hljs-comment">//目标目录</span>    into <span class="hljs-string">'./src/main/java'</span>&#125;</code></pre><p><code>from</code>、<code>into</code>是最基础的配置，其他常用包括以下：</p><table><thead><tr><th>配置项</th><th>释义</th><th>示例</th></tr></thead><tbody><tr><td>include</td><td>只包含配置的文件</td><td><code>include &#39;**/*.java&#39;,   &#39;**/*.kt&#39;</code></td></tr><tr><td>exclude</td><td>排除配置的文件</td><td><code>exclude &#39;**/*.xml&#39;</code></td></tr><tr><td>includeEmptyDirs</td><td>是否包括空文件夹</td><td><code>true</code>文件夹下的所有文件夹也会被拷贝进来<br><code>false</code>不会存在空文件夹</td></tr><tr><td>rename</td><td>对指定的文件进行重命名</td><td><code>rename &#39;activity_*.xml&#39; &#39;rename&#39;</code></td></tr><tr><td>with</td><td>执行一个闭包</td><td>def dataContent = copySpec {<br>     from (‘../src/main’) { <br>        include ‘*<em>/</em>.xml’    <br> } }<br>with dataContent</td></tr></tbody></table><h4 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a><a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Sync.html" target="_blank" rel="noopener">Sync</a></h4><blockquote><p>与Copy任务类似，不同的是<strong>将源目录中的文件复制到目标目录中，但是会删除目标目录中非复制过来的文件。</strong></p></blockquote><pre><code class="hljs groovy">task syncFile(<span class="hljs-string">type:</span>Sync)&#123;    from <span class="hljs-string">'../app/src/main/java'</span>    rename <span class="hljs-string">'Main*'</span>, <span class="hljs-string">'SSS'</span>    into <span class="hljs-string">'./src/main/java'</span>    includeEmptyDirs = <span class="hljs-literal">false</span>&#125;</code></pre><p>可通过设置<code>preverse</code>属性，控制哪些文件不会被覆盖</p><pre><code class="hljs groovy">task syncFile(<span class="hljs-string">type:</span>Sync)&#123;    from <span class="hljs-string">'../app/src/main/java'</span>    rename <span class="hljs-string">'Main*'</span>, <span class="hljs-string">'SSS'</span>    into <span class="hljs-string">'./src/main/java'</span>    includeEmptyDirs = <span class="hljs-literal">false</span>    preserve &#123;        include <span class="hljs-string">'**/*.xml'</span>    &#125;&#125;</code></pre><p>那么目标目录原有的<code>xml</code>不会被删除</p><h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><p>通过<a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="noopener">官网介绍</a>来查询其他系统支持类型</p><h4 id="自定义Type"><a href="#自定义Type" class="headerlink" title="自定义Type"></a>自定义Type</h4><pre><code class="hljs groovy"><span class="hljs-comment">//设置父类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultTask</span>&#123;</span>    String msg = <span class="hljs-string">"parent"</span>    <span class="hljs-keyword">int</span> age    <span class="hljs-keyword">int</span> score    <span class="hljs-meta">@Inject</span>    ParentTask(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> score)&#123;        <span class="hljs-keyword">this</span>.age = age        <span class="hljs-keyword">this</span>.score = score    &#125;    <span class="hljs-meta">@TaskAction</span>    <span class="hljs-keyword">void</span> sayHello()&#123;        println <span class="hljs-string">"hello $msg age is $age and score is $score"</span>    &#125;&#125;<span class="hljs-comment">//设置type即父类为 ParentTask 设置参数为 30,100</span>task Task1(<span class="hljs-string">type:</span>ParentTask,<span class="hljs-string">constructorArgs:</span>[<span class="hljs-number">30</span>,<span class="hljs-number">100</span>])task Task2(<span class="hljs-string">type:</span> ParentTask,<span class="hljs-string">constructorArgs:</span> [<span class="hljs-number">10</span>,<span class="hljs-number">70</span>])&#123;    msg=<span class="hljs-string">"wxy"</span>&#125;输出结果：&gt; <span class="hljs-string">Task :</span><span class="hljs-string">plugin:</span>Task1hello parent age is <span class="hljs-number">30</span> and score is <span class="hljs-number">100</span>&gt; <span class="hljs-string">Task :</span><span class="hljs-string">plugin:</span>Task2hello wxy age is <span class="hljs-number">10</span> and score is <span class="hljs-number">70</span></code></pre><h3 id="Task-Group-任务分组-amp-Task-Description-任务描述"><a href="#Task-Group-任务分组-amp-Task-Description-任务描述" class="headerlink" title="Task Group(任务分组)&amp;Task Description(任务描述)"></a>Task Group(任务分组)&amp;Task Description(任务描述)</h3><blockquote><p>对任务进行分组整理，使结构清晰明了</p><p>对任务进行描述，说明任务的作用</p></blockquote><pre><code class="hljs groovy">task MyTask(<span class="hljs-string">description:</span><span class="hljs-string">"Task的介绍"</span>,<span class="hljs-string">group:</span><span class="hljs-string">"MyTaskGroup"</span>) doLast &#123;  println <span class="hljs-string">"group $group "</span>&#125;&gt; <span class="hljs-string">Task :</span><span class="hljs-string">plugin:</span>MyTaskgroup is MyTaskGroup and description is Task的介绍</code></pre><p>可以通过执行<code>./gradlew -q tasks --all</code>查看所有task信息</p><pre><code class="hljs xml">MyTaskGroup tasks-----------------plugin:MyTask - Task的介绍</code></pre><h3 id="Task-Overwrite-任务重写"><a href="#Task-Overwrite-任务重写" class="headerlink" title="Task Overwrite(任务重写)"></a>Task Overwrite(任务重写)</h3><blockquote><p>对上面的任务进行覆盖，后续只会执行该任务</p></blockquote><pre><code class="hljs groovy">task MyTask(<span class="hljs-string">description:</span><span class="hljs-string">"Task的介绍"</span>,<span class="hljs-string">group:</span><span class="hljs-string">"MyTaskGroup"</span>) doLast &#123;  println <span class="hljs-string">"group is $group and description is $description"</span>&#125;task MyTask(<span class="hljs-string">overwrite:</span><span class="hljs-literal">true</span>) doLast &#123;  println <span class="hljs-string">"Cover Same Task"</span>&#125;</code></pre><p>后续只会输出<code>Cover Same Task</code></p><h3 id="Task-Enable-任务启用"><a href="#Task-Enable-任务启用" class="headerlink" title="Task Enable(任务启用)"></a>Task Enable(任务启用)</h3><blockquote><p>通过设置<code>enabled</code>属性，用于启用和禁用任务，默认为<code>true</code>，表示启用。<code>false</code>则禁止该任务执行</p></blockquote><pre><code class="hljs groovy">task MyTask &#123;  enabled <span class="hljs-literal">false</span>&#125;</code></pre><p>运行会提示 <code>Task :plugin:zipFile SKIPPED</code></p><h3 id="TaskContainer-任务集合"><a href="#TaskContainer-任务集合" class="headerlink" title="TaskContainer(任务集合)"></a><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/TaskContainer.html" target="_blank" rel="noopener">TaskContainer(任务集合)</a></h3><blockquote><p>管理所有的Task实例，可通过<code>Project.getTasks()</code>或者<code>tasks</code>使用该实例</p></blockquote><p>提供了以下常用的方法</p><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td><code>create(name:String) : Task</code></td><td>创建任务</td></tr><tr><td><code>create(name:String,configureClosure:Closure) : Task</code></td><td>创建任务</td></tr><tr><td><code>create(options: Map&lt;String, ?&gt;,configure: Closure): Task</code></td><td>创建任务</td></tr><tr><td><code>findByPath(path: String): Task</code></td><td>查找任务</td></tr><tr><td><code>getByName(name: String): Task</code></td><td>根据Task名字查找任务</td></tr><tr><td><code>withType(type: Class): TaskCollection</code></td><td>根据Type查找任务</td></tr><tr><td><code>register(String name):TaskProvider</code></td><td>按需加载任务</td></tr><tr><td><code>replace(String name):Task</code></td><td>替换当前同名任务</td></tr><tr><td><code>remove(Task task)</code></td><td>删除任务</td></tr><tr><td><code>whenTaskAdded(action:Closure)</code></td><td>task添加进TaskContainer时监听</td></tr></tbody></table><pre><code class="hljs groovy"><span class="hljs-comment">//创建Task</span>tasks.create(<span class="hljs-string">"Task1"</span>)&#123;&#125;tasks.create(<span class="hljs-string">"Task2"</span>, Copy<span class="hljs-class">.<span class="hljs-keyword">class</span>)&#123;</span>    from <span class="hljs-string">'../app/src/main/java'</span>    into <span class="hljs-string">'./src/main/java'</span>&#125;tasks.create([<span class="hljs-string">name:</span><span class="hljs-string">"Task3"</span>,<span class="hljs-string">group:</span><span class="hljs-string">"customGroup"</span>,<span class="hljs-string">desription:</span><span class="hljs-string">"desc"</span>,<span class="hljs-string">dependsOn:</span>[<span class="hljs-string">"Task1"</span>]])&#123;  &#125;<span class="hljs-comment">//查找Task</span><span class="hljs-keyword">def</span> task1 = tasks.findByName(<span class="hljs-string">"Task1"</span>)<span class="hljs-keyword">def</span> task2 = tasks.withType(Copy<span class="hljs-class">.<span class="hljs-keyword">class</span>)//替换<span class="hljs-title">Task</span><span class="hljs-title">tasks</span>.<span class="hljs-title">replace</span>("<span class="hljs-title">Task1</span>")&#123;</span>  &#125;<span class="hljs-comment">//监听Task添加</span>tasks.whenTaskAdded &#123; task-&gt;    <span class="hljs-keyword">if</span>(task.name == <span class="hljs-string">"Task1"</span> )&#123;        println <span class="hljs-string">"Task1 is added"</span>    &#125;<span class="hljs-keyword">else</span>&#123;      println <span class="hljs-string">"$&#123;task.name&#125; is added"</span>    &#125;&#125;</code></pre><h3 id="Task增量构建"><a href="#Task增量构建" class="headerlink" title="Task增量构建"></a>Task增量构建</h3><blockquote><p>Task会缓存每次运行的结果，在下次运行时会检查输出结果是否进行改变，没有发生变化就会跳过当次运行 。为了<strong>提高Gradle的编译速度</strong>。</p><p>在控制台会显示<code>up-to-date</code>表示跳过该次执行。</p></blockquote><h4 id="Task-Input-Output-任务输入-输出"><a href="#Task-Input-Output-任务输入-输出" class="headerlink" title="Task Input/Output(任务输入/输出)"></a>Task Input/Output(任务输入/输出)</h4><blockquote><p>任务需要接收</p></blockquote><h3 id="Task-Other"><a href="#Task-Other" class="headerlink" title="Task Other"></a>Task Other</h3><h4 id="onlyIf断言"><a href="#onlyIf断言" class="headerlink" title="onlyIf断言"></a><code>onlyIf</code>断言</h4><blockquote><p><code>onlyIf</code>接收一个闭包作为参数，若闭包中返回<code>true</code>则执行任务，否则跳过该任务(<code>SKIPPED</code>)。<strong>主要用于控制任务的执行场景。</strong></p></blockquote><pre><code class="hljs groovy">task testOnlyIf&#123;    println <span class="hljs-string">"setOnlyIf"</span>    doLast&#123;        println <span class="hljs-string">"testOnlyIf run "</span>    &#125;&#125;testOnlyIf.onlyIf&#123;    <span class="hljs-keyword">if</span>(project.hasProperty(<span class="hljs-string">"skip"</span>))&#123;         !project.property(<span class="hljs-string">"skip"</span>)    &#125;    <span class="hljs-literal">false</span>&#125;</code></pre><p>命令行中输入<code>./gradlew testOnlyIf -Pskip=true</code>则提示<code>Task :testOnlyIf SKIPPED</code>。设置<code>-Pskip=false</code>则输出<code>testOnlyIf run</code>。</p><blockquote><p>命令行中<code>-P</code>表示为<code>Project</code>指定<code>K-V</code>格式的属性键值对，使用格式为<code>-PK=V</code></p></blockquote><h4 id="finalizer任务"><a href="#finalizer任务" class="headerlink" title="finalizer任务"></a><code>finalizer</code>任务</h4><blockquote><p>监听任务结束状态，可以在结束后执行其他任务</p></blockquote><pre><code class="hljs groovy">task taskx &#123;    doLast&#123;        println <span class="hljs-string">"taskx"</span>    &#125;&#125;task tasky &#123;    doLast&#123;        println <span class="hljs-string">"tasky"</span>    &#125;&#125;taskx.finalizedBy tasky</code></pre><p><code>./gradlew taskx -q</code>运行结果为 </p><pre><code class="hljs undefined">&gt; Task :plugin:taskxtaskx&gt; Task :plugin:taskytaskytaskx执行完毕就会执行tasky</code></pre><blockquote><p><code>Finalizer</code>即使运行过程中出现异常也不会影响到后续任务的执行，只有一种情况下会出现无法执行后续任务。<strong>当前置任务根本没有执行时，不会触发后续任务执行。</strong></p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://docs.gradle.org/current/userguide/more_about_tasks.html" target="_blank" rel="noopener">Gradle官方文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle学习笔记-Groovy基础</title>
    <link href="/2019/04/23/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Groovy/"/>
    <url>/2019/04/23/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Groovy/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Groovy是基于JVM的一种动态语言，语法与Java相近，上手较快。<strong>Groovy完全兼容Java。</strong>又增加了很多动态类型和灵活的特性，是一门比较灵活的动态脚本语言。</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Groovy中通过<code>def</code>定义变量，无需指定变量类型，自动判断。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><pre><code class="hljs groovy">task printDef &lt;&lt; &#123;<span class="hljs-comment">//字符串</span><span class="hljs-keyword">def</span> str1 = <span class="hljs-string">"str"</span><span class="hljs-keyword">def</span> str2 = <span class="hljs-string">'str'</span><span class="hljs-keyword">def</span> str3 = <span class="hljs-string">'''str    23        45'''</span> <span class="hljs-comment">//三引号字符串可以保留文本的换行及缩进</span><span class="hljs-comment">//数值</span><span class="hljs-keyword">def</span> intV = <span class="hljs-number">1</span><span class="hljs-keyword">def</span> doubleV = <span class="hljs-number">2.0</span><span class="hljs-keyword">def</span> floatV = <span class="hljs-number">3.0</span>fprintln(<span class="hljs-string">"字符串 $&#123;str1&#125; $&#123;str2&#125; 数值 $&#123;intV&#125; $&#123;doubleV&#125; $&#123;floatV&#125;"</span>)&#125;<span class="hljs-comment">//在控制台输出结果</span>./gradlew printDef</code></pre><blockquote><p><code>println</code>输出到控制台，只有双引号标记的<code>${ }</code>才可以生效。</p></blockquote><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><blockquote><p>Groovy在Java的集合类基础上进行了拓展与增强，并对原有集合完美兼容。</p></blockquote><pre><code class="hljs groovy">task printList &lt;&lt; &#123;  <span class="hljs-comment">//初始化一个数组 默认ArrayList类型</span>  <span class="hljs-keyword">def</span> numList = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]  <span class="hljs-comment">//设置List类型为 LinkedList</span>  <span class="hljs-keyword">def</span> linkList = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> LinkedList  <span class="hljs-comment">//输出第一个元素</span>  println numList[<span class="hljs-number">0</span>]  <span class="hljs-comment">//输出最后一个元素</span>  println numList[<span class="hljs-number">-1</span>]  <span class="hljs-comment">//输出第一到第三个元素</span>  println numList[<span class="hljs-number">0.</span><span class="hljs-number">.2</span>]  <span class="hljs-comment">//输出倒数第一到倒数第三个元素</span>  println numList[<span class="hljs-number">-1.</span>.<span class="hljs-number">-3</span>]  <span class="hljs-comment">//添加元素</span>  numList &lt;&lt; <span class="hljs-number">5</span>  numList.add(<span class="hljs-number">5</span>)  <span class="hljs-comment">//移除元素</span>  numList.remove(<span class="hljs-number">1</span>) <span class="hljs-comment">//移除第二个元素</span>  <span class="hljs-comment">//遍历输出</span>  numList.each&#123; print <span class="hljs-string">"$&#123;it&#125;,"</span> &#125;  <span class="hljs-comment">//显示索引</span>  numList.eachWithIndex&#123; it,i -&gt; print(<span class="hljs-string">"$&#123;i&#125;,"</span>) &#125;  <span class="hljs-comment">//Collect语法</span>  <span class="hljs-comment">//查找list元素</span>  println numList.find&#123; it&gt;<span class="hljs-number">3</span> &#125;  <span class="hljs-comment">//查找list所有符合条件元素</span>  println numList.findAll&#123; it&gt;<span class="hljs-number">3</span> &#125;  <span class="hljs-comment">//查找list元素并返回下标</span>  println numList.findIndexOf&#123; it ==<span class="hljs-number">4</span> &#125;  println numList.findFirstIndexOf&#123;it==<span class="hljs-number">4</span>&#125;  println numList.findLastIndexOf&#123;it==<span class="hljs-number">4</span>&#125;  <span class="hljs-comment">//List排序</span>  numList.sort()  <span class="hljs-comment">//List去重</span>  numList.unique()&#125;</code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><blockquote><p>Map用法与List类似，只不过它的值是一个KV键值对。</p></blockquote><pre><code class="hljs groovy">task PrintMap &lt;&lt; &#123;  <span class="hljs-comment">//初始化Map 默认LinkedHashMap</span>  <span class="hljs-keyword">def</span> map = [<span class="hljs-string">one:</span><span class="hljs-string">"111"</span>,<span class="hljs-string">two:</span><span class="hljs-string">"222"</span>,<span class="hljs-string">three:</span><span class="hljs-string">"333"</span>]  <span class="hljs-comment">//根据key输出value</span>  println map[<span class="hljs-string">"one"</span>] <span class="hljs-comment">//111</span>  println map.one <span class="hljs-comment">//111</span>  <span class="hljs-comment">//遍历Map</span>  map.each &#123;    println <span class="hljs-string">"Key：$&#123;it.key&#125; value：$&#123;it.value&#125;"</span>  &#125;  <span class="hljs-comment">//判定Map中存在key</span>  println map.containKey(<span class="hljs-string">"one"</span>) <span class="hljs-comment">//true</span>  <span class="hljs-comment">//判定Map中存在value</span>  println map.containValue(<span class="hljs-string">"222"</span>)  <span class="hljs-comment">//清除Map的内容</span>  map.clear()&#125;</code></pre><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><blockquote><p>Groovy提供的一种容器类，是对List的拓展</p></blockquote><pre><code class="hljs groovy">task printRange &lt;&lt; &#123;  <span class="hljs-comment">//定义一个Range</span>  <span class="hljs-keyword">def</span> range = <span class="hljs-number">1.</span><span class="hljs-number">.5</span>    print range <span class="hljs-comment">//[1,2,3,4,5]</span>  <span class="hljs-comment">//获取range长度</span>  println range.size() <span class="hljs-comment">//5</span>  <span class="hljs-comment">//获取index为1的元素</span>  println range.get(<span class="hljs-number">1</span>) <span class="hljs-comment">//2</span>  <span class="hljs-comment">//是否包含元素3</span>  println range.contains(<span class="hljs-number">3</span>) <span class="hljs-comment">//true</span>  <span class="hljs-comment">//获取第一个元素</span>  println range.first()<span class="hljs-comment">//1</span>  println range.from()<span class="hljs-comment">//1</span>  <span class="hljs-comment">//获取最后一个元素</span>  println range.last()<span class="hljs-comment">//5</span>  println range.to()<span class="hljs-comment">//5</span>  <span class="hljs-comment">//添加新元素</span>  range.add(<span class="hljs-number">6</span>)  <span class="hljs-comment">//移除元素</span>  range.remove(<span class="hljs-number">0</span>)  <span class="hljs-comment">//清空数据</span>  range.clear()  <span class="hljs-comment">//遍历range</span>  range.each &#123;println it&#125;&#125;</code></pre><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="**运算符"></a><code>**</code>运算符</h3><blockquote><p>等同于 2^3 = 8</p></blockquote><pre><code class="hljs groovy"><span class="hljs-number">2</span> ** <span class="hljs-number">3</span> = <span class="hljs-number">8</span></code></pre><h3 id="占位符"><a href="#占位符" class="headerlink" title="?.占位符"></a><code>?.</code>占位符</h3><blockquote><p>用于避免空指针异常</p></blockquote><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> person = <span class="hljs-keyword">new</span> Person()println person?.name?:<span class="hljs-string">""</span> <span class="hljs-comment">//为null 则返回空</span></code></pre><h3 id="操作符-1"><a href="#操作符-1" class="headerlink" title=".@操作符"></a><code>.@</code>操作符</h3><blockquote><p>直接跳过写的<code>getXX()</code>获取对应值</p></blockquote><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span>    String name    Integer age = <span class="hljs-number">10</span>    <span class="hljs-keyword">int</span> getAge() &#123; age+<span class="hljs-number">10</span> &#125;&#125;task printClass &lt;&lt; &#123;    Person p = <span class="hljs-keyword">new</span> Person();    p.name = <span class="hljs-string">"wxy"</span>    println p.name <span class="hljs-comment">//wxy</span>    println p.<span class="hljs-meta">@age</span> <span class="hljs-comment">//10</span>    println p.age <span class="hljs-comment">//20</span>&#125;</code></pre><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> name<span class="hljs-comment">//类Java写法</span><span class="hljs-keyword">def</span> result = name==<span class="hljs-literal">null</span>?"null":name<span class="hljs-comment">//Groovy写法</span><span class="hljs-keyword">def</span> result = name?:<span class="hljs-string">"null"</span>print result</code></pre><p>###<code>asType</code></p><blockquote><p>数据类型转换</p></blockquote><pre><code class="hljs groovy">String string = <span class="hljs-string">"23"</span><span class="hljs-comment">//转成int</span><span class="hljs-keyword">def</span> toInt = string <span class="hljs-keyword">as</span> <span class="hljs-keyword">int</span><span class="hljs-keyword">def</span> toInt = string.asType(Integer)</code></pre><h3 id="lt-gt-比较操作符"><a href="#lt-gt-比较操作符" class="headerlink" title="&lt;=&gt;比较操作符"></a><code>&lt;=&gt;</code>比较操作符</h3><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span> (<span class="hljs-number">1</span> &lt;=&gt; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span><span class="hljs-keyword">assert</span> (<span class="hljs-number">1</span> &lt;=&gt; <span class="hljs-number">2</span>) == <span class="hljs-number">-1</span><span class="hljs-keyword">assert</span> (<span class="hljs-number">2</span> &lt;=&gt; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span></code></pre><h3 id="展开运算符"><a href="#展开运算符" class="headerlink" title="*.展开运算符"></a><code>*.</code>展开运算符</h3><blockquote><p>得到原集合中各元素的组合后的集合</p></blockquote><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span>  String name  <span class="hljs-keyword">int</span> age&#125;<span class="hljs-keyword">def</span> persons = [<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"a"</span>,<span class="hljs-number">1</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"b"</span>,<span class="hljs-number">2</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"c"</span>,<span class="hljs-number">3</span>)]<span class="hljs-keyword">def</span> names = persons*.name  <span class="hljs-comment">// [a,b,c]</span><span class="hljs-keyword">def</span> names = persons.collect&#123;it.name&#125; <span class="hljs-comment">//[a,b,c]</span></code></pre><p><code>*.</code>操作符是空安全的，支持传入<code>null</code></p><h3 id="with操作符"><a href="#with操作符" class="headerlink" title="with操作符"></a><code>with</code>操作符</h3><blockquote><p>简化对同一对象进行赋值的操作</p></blockquote><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span>  String name  <span class="hljs-keyword">int</span> age  <span class="hljs-keyword">int</span> score&#125;task testWith &lt;&lt; &#123;  Person person = <span class="hljs-keyword">new</span> Person()  person.with &#123;    name=<span class="hljs-string">"a"</span>    age=<span class="hljs-number">12</span>    score=<span class="hljs-number">60</span>  &#125;&#125;</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote><p>Groovy中的方法与Java方法相似，但是提供了更便利的实现。</p></blockquote><pre><code class="hljs groovy">task printMethod &lt;&lt; &#123;    add(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)    add <span class="hljs-number">1</span>,<span class="hljs-number">4</span>  <span class="hljs-comment">//1</span>    println minus (<span class="hljs-number">5</span>,<span class="hljs-number">2</span>)&#125;<span class="hljs-keyword">def</span> add(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)&#123;    println a+b&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> minus(a,b)&#123;<span class="hljs-comment">//3</span>  println <span class="hljs-string">"a=$&#123;a&#125; b=$&#123;b&#125;"</span>    a-b <span class="hljs-comment">//2</span>&#125;</code></pre><ol><li>语句后面的分号可以省略</li><li>方法中的括号可以省略 <em>类似注释1</em></li><li>return 可以省略掉 <em>类似注释2</em> <strong>最后一行代码为返回值的最终结果</strong></li><li>参数类型可以忽略掉 <em>类似注释3</em></li></ol><p>默认方法修饰符为<code>public</code>。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote><p>Groovy类类似于Java类</p></blockquote><pre><code class="hljs groovy">task printClass &lt;&lt; &#123;    Person p = <span class="hljs-keyword">new</span> Person();    p.increaseAge(<span class="hljs-number">2</span>)    p.name=<span class="hljs-string">"wxy"</span>    println p.name    println p.age&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span>    String name    Integer age =<span class="hljs-number">10</span>    <span class="hljs-keyword">int</span> getAge()&#123; age &#125;    <span class="hljs-keyword">def</span> increaseAge(Integer years)&#123;        <span class="hljs-keyword">this</span>.age+=years    &#125;&#125;</code></pre><ol><li>默认类的修饰符为<code>public</code></li><li>没有可见修饰符的会自动生成对应的<code>getter/setter</code>方法</li><li>类不需要与它的源文件有相同的名称，建议采用相同的名称</li></ol><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><blockquote><p>用于进行单元测试</p></blockquote><pre><code class="hljs groovy">tasl test &lt;&lt; &#123;  <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span>+<span class="hljs-number">2</span>==<span class="hljs-number">6</span> <span class="hljs-comment">//进行测试</span>&#125;</code></pre><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><blockquote><p>循环语句</p></blockquote><pre><code class="hljs groovy">task testFor &lt;&lt; &#123;  <span class="hljs-keyword">def</span> x= <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.3</span>)&#123;    x+=i  &#125;  <span class="hljs-comment">//效果等同于 0..3</span>  <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.&lt;<span class="hljs-number">4</span>)&#123;    x+=i  &#125;  println x <span class="hljs-comment">//6</span>    x = <span class="hljs-number">0</span>  <span class="hljs-keyword">def</span> list = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]  <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> list)&#123;    x+=i  &#125;  println x <span class="hljs-comment">//6</span>    x = <span class="hljs-number">0</span>;  <span class="hljs-keyword">def</span> map =[<span class="hljs-string">a:</span><span class="hljs-number">1</span>,<span class="hljs-string">b:</span><span class="hljs-number">2</span>,<span class="hljs-string">c:</span><span class="hljs-number">3</span>]  <span class="hljs-keyword">for</span>( i <span class="hljs-keyword">in</span> map.values)&#123;    x+=i  &#125;  println x <span class="hljs-comment">//6</span>&#125;</code></pre><h3 id="time语句"><a href="#time语句" class="headerlink" title="time语句"></a>time语句</h3><blockquote><p>用于进行循环输出</p></blockquote><pre><code class="hljs groovy"><span class="hljs-number">4.</span>times &#123;  print it&#125;输出<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><blockquote><p>选择语句</p></blockquote><pre><code class="hljs groovy"><span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> returnSwitch(x)&#123;    <span class="hljs-keyword">def</span> result = <span class="hljs-string">""</span>    <span class="hljs-keyword">switch</span>(x)&#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">"ok"</span>:            result = <span class="hljs-string">"found ok"</span>            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-string">String:</span>            result = <span class="hljs-string">"isString"</span>            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>:            result = <span class="hljs-string">"in range"</span>            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-string">Integer:</span>            result = <span class="hljs-string">"is Integer"</span>            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]:            result = <span class="hljs-string">"is List"</span>            <span class="hljs-keyword">break</span><span class="hljs-symbol">        default:</span>            result = <span class="hljs-string">"default"</span>        <span class="hljs-keyword">return</span> result    &#125;&#125;</code></pre><p><code>switch</code>除了Java支持的数据类型<code>Integer、String</code>以外，还支持数组类型、区间、列表等</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><blockquote><p>写法同Java一致</p></blockquote><pre><code class="hljs groovy">    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// do sth</span>    &#125; <span class="hljs-keyword">catch</span> (EOFException e) &#123;        e.printStackTrace()    &#125;<span class="hljs-comment">//Groovy写法</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// do sth</span>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<span class="hljs-comment">//可忽略类型</span>        e.printStackTrace()    &#125;</code></pre><h2 id="I-O操作"><a href="#I-O操作" class="headerlink" title="I/O操作"></a>I/O操作</h2><blockquote><p>对原有Java I/O操作进行了封装，简化了使用方法</p></blockquote><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><pre><code class="hljs groovy">task testFileRead &lt;&lt; &#123;    <span class="hljs-keyword">def</span> filePath = <span class="hljs-string">"$path"</span>    <span class="hljs-keyword">def</span> file = <span class="hljs-keyword">new</span> File(filePath) <span class="hljs-comment">//基础使用方式</span>    <span class="hljs-comment">//输出所有文本内容</span>    println file.text     <span class="hljs-comment">//逐行输出</span>    file.eachLine &#123;        println it    &#125; <span class="hljs-comment">//Reader操作方式 </span>    <span class="hljs-keyword">def</span> line = <span class="hljs-string">""</span>    file.withReader &#123;reader -&gt;       <span class="hljs-keyword">while</span>(line = reader.readLine())&#123;           println line       &#125;    &#125;    <span class="hljs-comment">//设置编码格式</span>    file.withReader(<span class="hljs-string">"utf-8"</span>)&#123;reader-&gt;        <span class="hljs-keyword">while</span>(line = reader.readLine())&#123;            println line        &#125;    &#125; <span class="hljs-comment">//InputStream </span>    <span class="hljs-keyword">def</span> is = file.newInputStream()    is.eachLine &#123;        println it    &#125;    <span class="hljs-comment">//使用完后 需要及时关闭</span>    is.close()    <span class="hljs-comment">// 使用 withInputStream 不需要close流</span>    file.withInputStream &#123; stream -&gt;        stream.eachLine &#123;            println it        &#125;    &#125;&#125;</code></pre><p><code>Reader</code>：即使读取过程中抛出异常也可以自动关闭IO操作</p><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><pre><code class="hljs groovy">task testFileWrite &lt;&lt; &#123;  <span class="hljs-keyword">def</span> file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"%path"</span>)<span class="hljs-comment">//基础使用方式</span>  file.withWriter(<span class="hljs-string">"utf-8"</span>)&#123;writer-&gt;    writer.writeLine <span class="hljs-string">"Hello"</span>    writer.writeLine <span class="hljs-string">","</span>    writer.writeLine <span class="hljs-string">"World"</span>  &#125;  file &lt;&lt; <span class="hljs-string">'''Hello  ,  World'''</span><span class="hljs-comment">//OutputStream</span>    <span class="hljs-keyword">def</span> bytes = [<span class="hljs-number">66</span>,<span class="hljs-number">22</span>,<span class="hljs-number">11</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">byte</span>[]    <span class="hljs-keyword">def</span> out = file.newOutputStream()    out.write(bytes)    out.flush()    out.close()      file.withOutputStream &#123;stream-&gt;        stream.write(bytes)        stream.write(bytes)    &#125;<span class="hljs-comment">//PrintWriter</span>    <span class="hljs-keyword">def</span> out = file.newPrintWriter()    out.write(<span class="hljs-string">"sasd"</span>)    out.write(<span class="hljs-string">"sdds"</span>)    out.flush()    out.close()      file.withPrintWriter &#123; writer -&gt;        writer.append(<span class="hljs-string">"ssss"</span>)        writer.println(<span class="hljs-string">"dfff"</span>)        writer.write(<span class="hljs-string">"12333"</span>)    &#125;&#125;</code></pre><h3 id="文件遍历"><a href="#文件遍历" class="headerlink" title="文件遍历"></a>文件遍历</h3><blockquote><p>可用于检测文件是否重复，例如代码中的重复资源引用</p></blockquote><pre><code class="hljs groovy">task testFileEach &lt;&lt; &#123;  <span class="hljs-keyword">def</span> file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"$path"</span>)  <span class="hljs-comment">//遍历目录下的文件</span>  file.eachFile &#123; file-&gt;    println file.name <span class="hljs-comment">//打印文件名包括文件夹名字，不能嵌套处理</span>  &#125;  <span class="hljs-comment">//遍历嵌套目录</span>  file.eachFileRecurse&#123;file-&gt;    println file.name <span class="hljs-comment">//打印文件名 包含嵌套目录及文件</span>  &#125;  <span class="hljs-comment">//按照文件类型 遍历目录</span>  file.eachFileRecurse(FileType.FILES)&#123;file-&gt;    println file.name <span class="hljs-comment">//只会打印出文件</span>  &#125;  <span class="hljs-comment">//按照正则匹配文件</span>    &#125;</code></pre><p><code>FileType</code>包含以下三种类型：</p><ul><li><code>FileType.ANY</code>：可获取所有类型，包含文件、目录</li><li><code>FileType.FILES</code>：只能获取文件类型</li><li><code>FileType.DIRECTORIES</code>：只能获取文件夹类型</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><strong>闭包</strong></h2><blockquote><p>Groovy中一个重要的特性，是<strong>DSL</strong>的基础。使得代码变得<em>灵活、轻量、可复用</em>。</p></blockquote><h3 id="基础样式"><a href="#基础样式" class="headerlink" title="基础样式"></a>基础样式</h3><pre><code class="hljs groovy">task testClosure &lt;&lt; &#123;    <span class="hljs-comment">//闭包单参数 默认it 也称为隐含参数 可以指定名称</span>    customEach&#123; iii-&gt;        print iii    &#125;   <span class="hljs-comment">/*    *customEach&#123;    *   print it    *&#125;    */</span>&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> customEach(closure<span class="hljs-comment">/*闭包*/</span>)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>)&#123;        closure(i)    &#125;&#125;</code></pre><h3 id="多参数"><a href="#多参数" class="headerlink" title="多参数"></a>多参数</h3><blockquote><p>如果闭包中只有一个参数，默认可以使用<code>it</code>。也可以自己指定名称。<em>多参数情况时，就需要列举出所有参数</em></p></blockquote><pre><code class="hljs groovy">task testClosure &lt;&lt; &#123;    <span class="hljs-comment">//闭包多参数</span>    eachMap&#123;k,v-&gt;        print <span class="hljs-string">"$&#123;k&#125; : $&#123;v&#125;"</span>    &#125;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> eachMap(closure)&#123;    <span class="hljs-keyword">def</span> map =[<span class="hljs-string">"1"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"2"</span>:<span class="hljs-number">2</span>]    map.each &#123;        closure(it.key,it.value)    &#125;&#125;</code></pre><h3 id="闭包调用"><a href="#闭包调用" class="headerlink" title="闭包调用"></a>闭包调用</h3><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> closure1 = &#123;  <span class="hljs-comment">//定义了闭包的参数</span>  String name,<span class="hljs-keyword">int</span> age -&gt;   println <span class="hljs-string">"$&#123;name&#125; is $&#123;age&#125;"</span>&#125;<span class="hljs-comment">//调用方式</span>closure1(<span class="hljs-string">"wxy"</span>,<span class="hljs-number">111</span>)或closure1.call(<span class="hljs-string">"wxy"</span>,<span class="hljs-number">111</span>)特殊实例：<span class="hljs-comment">//无参闭包</span><span class="hljs-keyword">def</span> closureSpecial = &#123;  -&gt; println <span class="hljs-string">"special"</span>&#125;<span class="hljs-comment">//调用方式</span>closureSpecial.call()closureSpecial()</code></pre><h3 id="闭包委托"><a href="#闭包委托" class="headerlink" title="闭包委托"></a>闭包委托</h3><blockquote><p>Groovy的闭包有<code>thisObject、owner、delegate</code>三个属性，当你在闭包内调用方法时，由他们来确定使用哪个对象来处理。</p></blockquote><table><thead><tr><th>对象</th><th>含义</th><th>方法</th></tr></thead><tbody><tr><td>thisObject</td><td>对应于定义闭包的那个类<br>如果在内部类中定义，指向的是内部类</td><td><code>getThisObject()</code></td></tr><tr><td>owner</td><td>对应于定义闭包的那个类或闭包<br>如果在闭包中定义，对应闭包，与<code>thisObject</code>一致</td><td><code>getOwner()</code></td></tr><tr><td>delegate</td><td>默认与<code>owner</code>一致<br>可以进行自定义拓展更多功能</td><td><code>getDelegate()</code></td></tr></tbody></table><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> &#123;</span>        <span class="hljs-keyword">def</span> outerClosure = &#123;            <span class="hljs-keyword">def</span> innerClosure = &#123;            &#125;            printMsg(<span class="hljs-string">"innerClosure"</span>, innerClosure)            printMsg(<span class="hljs-string">"outerClosure"</span>, outerClosure)        &#125;        <span class="hljs-keyword">void</span> printMsg(flag,closure)&#123;            <span class="hljs-keyword">def</span> thisObject = closure.getThisObject()            <span class="hljs-keyword">def</span> ownerObject = closure.getOwner()            <span class="hljs-keyword">def</span> delegate = closure.getDelegate()            println(<span class="hljs-string">"$&#123;flag&#125; this : $&#123;thisObject.toString()&#125;"</span>)            println(<span class="hljs-string">"$&#123;flag&#125; owner : $&#123;ownerObject.toString()&#125;"</span>)            println(<span class="hljs-string">"$&#123;flag&#125; delegate : $&#123;delegate.toString()&#125;"</span>)        &#125;    &#125;    <span class="hljs-keyword">def</span> callInnerMethod()&#123;        <span class="hljs-keyword">def</span> innerClass = <span class="hljs-keyword">new</span> InnerClass()        innerClass.outerClosure.call()        println(<span class="hljs-string">"outerClosure toString $&#123;innerClass.outerClosure.toString()&#125;"</span>)    &#125;&#125;<span class="hljs-comment">//打印闭包</span>task printBibao &lt;&lt; &#123;    <span class="hljs-keyword">new</span> OuterClass().callInnerMethod()&#125;.....................输出结果.........................&gt; <span class="hljs-string">Task :</span><span class="hljs-string">CustomPlugin:</span>printBibaoinnerClosure <span class="hljs-string">this :</span> OuterClass$InnerClass@<span class="hljs-number">4</span>ee95feeinnerClosure <span class="hljs-string">owner :</span> OuterClass$InnerClass$_closure1@<span class="hljs-number">1177369</span>dinnerClosure <span class="hljs-string">delegate :</span> OuterClass$InnerClass$_closure1@<span class="hljs-number">1177369</span>douterClosure <span class="hljs-string">this :</span> OuterClass$InnerClass@<span class="hljs-number">4</span>ee95feeouterClosure <span class="hljs-string">owner :</span> OuterClass$InnerClass@<span class="hljs-number">4</span>ee95feeouterClosure <span class="hljs-string">delegate :</span> OuterClass$InnerClass@<span class="hljs-number">4</span>ee95feeouterClosure toString OuterClass$InnerClass$_closure1@<span class="hljs-number">1177369</span>d</code></pre><p>根据上述的输出结果可以对应出上面的表格。</p><h4 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a><strong>delegate</strong></h4><blockquote><p>委托中最关键的就是<strong>delegate</strong>，它负责<code>将闭包和一个具体的对象关联起来</code>。</p></blockquote><pre><code class="hljs groovy">task printClosure &lt;&lt; &#123;    Main main = <span class="hljs-keyword">new</span> Main()    Man man = <span class="hljs-keyword">new</span> Man(<span class="hljs-string">name:</span><span class="hljs-string">"sd"</span>,<span class="hljs-string">age:</span><span class="hljs-number">11</span>)    println man.toString()    main.cc.delegate = man  <span class="hljs-comment">//main.cc.setResolveStrategy(Closure.DELEGATE_FIRST)</span>    main.cc.call()    println man.toString()&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> &#123;</span>    String name    <span class="hljs-keyword">int</span> age    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> eat(food) &#123;        println <span class="hljs-string">"eat $&#123;food&#125;"</span>    &#125;    <span class="hljs-meta">@Override</span>    String toString() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Man&#123; name = $&#123;name&#125; age = $&#123;age&#125; &#125;"</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> eat(food)&#123;        println <span class="hljs-string">"Main eat $food"</span>    &#125;    <span class="hljs-keyword">def</span> cc = &#123;        name = <span class="hljs-string">"wxy"</span>        age = <span class="hljs-number">12</span>        eat(<span class="hljs-string">"ss"</span>)    &#125;&#125;输出结果：Man&#123; name = sd age = <span class="hljs-number">11</span> &#125;Main eat ssMan&#123; name = wxy age = <span class="hljs-number">12</span> &#125;<span class="hljs-comment">//设置了 setResolveStrategy(Closure.DELEGATE_FIRST)时</span>Man&#123; name = sd age = <span class="hljs-number">11</span> &#125;eat ssMan&#123; name = wxy age = <span class="hljs-number">12</span> &#125;</code></pre><p>上述的执行结果，最终调用到了<code>Main.eat()</code>而不是<code>Man.eat()</code>，考虑到这个情况，<code>Closure</code>提供了<code>setResolveStrategy()</code>来控制调用同名方法的来源。</p><table><thead><tr><th><code>setResolveStrategy()</code>设置对应属性</th><th>参数含义</th></tr></thead><tbody><tr><td>Closure.OWNER_FIRST(<em>默认值</em>)</td><td>优先在owner中寻找，没有就去delegate中寻找</td></tr><tr><td>Closure.DELEGATE_FIRST</td><td>优先在delegate中寻找，没有就去owner中寻找</td></tr><tr><td>Closure.OWNER_ONLY</td><td>只在owner中寻找</td></tr><tr><td>Closure.DELEGATE_ONLY</td><td>只在delegate中寻找</td></tr><tr><td>Closure.TO_SELF</td><td>???</td></tr></tbody></table><blockquote><p>在上述实例中，<code>owner</code>相当于<code>Main</code>，<code>delegate</code>相当于<code>Man</code></p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="http://groovy-lang.org/documentation.html#languagespecification" target="_blank" rel="noopener">Apache-Groovy</a></p><p><a href="https://www.jianshu.com/p/6dc2074480b8" target="_blank" rel="noopener">搞定Groovy闭包</a></p><p><a href="https://blog.csdn.net/zhaoyanjun6/article/details/70313790" target="_blank" rel="noopener">Groovy 使用完全解析</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle学习笔记-基础</title>
    <link href="/2019/04/22/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/04/22/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Gradle是一种自动化构建语言，是一种<code>DSL(Domain Specific Language 特点领域语言)</code>，目前是Android的默认构件构建工具，是一个编程框架。</p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>将<code>Java/Kotlin(逻辑代码)</code>、<code>XML(界面代码)</code>、<code>NDK C/C++(JNI)</code>、<code>资源文件</code>，<em><code>RenderScript(并行运算)</code></em>这些文件通过编译过程打包成一个<code>Apk</code>。</p></blockquote><ul><li>解决自己的问题</li><li>帮助其他人优化开发流程</li><li>可以分享出自己的插件</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><table><thead><tr><th>语言</th><th><strong>Groovy</strong>先编译成Java类字节码，然后通过JVM来执行该类</th></tr></thead><tbody><tr><td>支持的环境</td><td>Android Studio及命令行调用</td></tr><tr><td>构建粒度</td><td>支持多个Project/Module、多个版本、多种构建类型</td></tr><tr><td>可拓展性</td><td>丰富的API及插件架构</td></tr><tr><td>其他构建工具</td><td>Ant、Maven</td></tr></tbody></table><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="GradleWrapper"><a href="#GradleWrapper" class="headerlink" title="GradleWrapper"></a>GradleWrapper</h3><p>一个Gradle的封装体，即便机器上没有安装Gradle，也可以执行Gradle的构建工作。在Android项目下分为<code>gradlew(Mac、Linux下使用)</code>，<code>gradlew.bat(Win下使用)</code></p><p>通过<code>gradle.properties</code>配置Gradle参数</p><pre><code class="hljs properties">#Fri Feb 15 15:39:54 CST 2019#Gradle解包后的存储目录distributionBase=GRADLE_USER_HOME#Gradle解包后存放位置distributionPath=wrapper/dists#Gradle压缩包存储目录zipStoreBase=GRADLE_USER_HOME#Gradle压缩包存放位置zipStorePath=wrapper/dists#Gradle压缩包下载地址distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip</code></pre><p>分别的执行命令为</p><pre><code class="hljs bash">//Mac、Linux使用./gradlew ...task//win下使用./gradlew.bat ...task</code></pre><h3 id="Closure-闭包"><a href="#Closure-闭包" class="headerlink" title="Closure(闭包)"></a>Closure(闭包)</h3><pre><code class="hljs gradle"><span class="hljs-keyword">repositories</span> &#123;   google()   jcenter()&#125;</code></pre><p>  <code>闭包</code>省略了表达式中的括号，<code>Groovy</code>表达式省略括号的规范：</p><ul><li>所有顶级表达式的括号可以省略</li><li>当闭包是一个顶级表达式的最后一个参数时，可以省略括号</li><li>当函数嵌套调用已经有函数没有参数时不能省略</li></ul><blockquote><p>闭包和函数的区别：</p><p>闭包：<code>def addNumbers = { left , right -&gt; left+right }</code></p><p>函数：<code>def addNumbers( left , right ){ left+right }</code></p></blockquote><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>Gradle为每个<code>build.gradle</code>创建一个相应的Project领域对象，在编写Gradle脚本时，实际是在操作诸如Project这样的Gradle领域对象。</p><p>一个完整项目中一般包含：</p><ul><li><p><code>settings.gradle</code>：一个，一般包含了<code>module及app的引用</code></p></li><li><p><code>build.gradle</code>：一个<code>root project</code>及多个<code>module project</code></p></li></ul><p><code>dependencies</code>：设置Gradle依赖库</p><ul><li><code>implememtation</code>：加入的依赖，表示这个依赖库只能自己用，其他依赖该module的无法引用该库。(<em>可以提高编译速度。</em>)</li><li><code>api</code>：加入的依赖，其他引用该Module的也可以使用该库，类似于以前的<code>compile</code></li></ul><h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><p>一个Project由一个或多个<code>Task</code>组成，它是构建过程中的原子任务，可以是编译Class，上传jar包等。</p><blockquote><p>可以在 Gradle文件目录下查看所有Task 或者通过执行 <code>./gradlew tasks</code>来查看</p></blockquote><p>task包含以下内容</p><table><thead><tr><th>参数</th><th>含义</th><th>默认量</th></tr></thead><tbody><tr><td>name</td><td>task名字</td><td>不能为空，必须指定</td></tr><tr><td>type</td><td>task父类</td><td>DefaultTask</td></tr><tr><td>overwrite</td><td>是否替换已存在的task</td><td>false</td></tr><tr><td>dependsOn</td><td>task依赖的task集合</td><td>[]</td></tr><tr><td>group</td><td>task属于哪个组</td><td>null</td></tr><tr><td>description</td><td>task的描述</td><td>null</td></tr></tbody></table><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><p>Gradle插件打包了可以复用的构建逻辑块，这些逻辑可以在不同的项目中构建使用。</p><h2 id="Gradle工作流程"><a href="#Gradle工作流程" class="headerlink" title="Gradle工作流程"></a>Gradle工作流程</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Gradle-workflow.png" srcset="/img/loading.gif" class="full-image" alt="Gradle工作流程" title="Gradle工作流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><code>Initialzation phase(初始化阶段)</code>：就是执行<code>setting.gradle</code></li><li><code>Configuration phase(配置阶段)</code>：解析每个<code>project</code>中的<code>build.gradle</code>，可以在此期间添加一些<code>Hook</code>，需要通过API进行添加。配置完成后，内部建立一个有向图来描述Task之间的依赖关系。</li><li><code>Execution phase(执行阶段)</code>：执行任务</li></ul><h2 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP学习笔记-APT</title>
    <link href="/2019/04/17/AOP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-APT/"/>
    <url>/2019/04/17/AOP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-APT/</url>
    
    <content type="html"><![CDATA[<blockquote><p>APT全称<code>Annotation Processing Tool</code>-注解处理器，用于在代码编译期间解析注解并生成新的Java文件，减少手动的代码输入。</p><p>主要通过生成注解类所在类的代理类，在运行期直接调用代理类中的方法实现功能。</p></blockquote><h2 id="注解处理方案-反射"><a href="#注解处理方案-反射" class="headerlink" title="注解处理方案-反射"></a>注解处理方案-反射</h2><h2 id="注解处理方案-APT"><a href="#注解处理方案-APT" class="headerlink" title="注解处理方案-APT"></a>注解处理方案-APT</h2>]]></content>
    
    
    
    <tags>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin-协程</title>
    <link href="/2019/04/12/Kotlin%E5%8D%8F%E7%A8%8B%E4%BD%93%E9%AA%8C/"/>
    <url>/2019/04/12/Kotlin%E5%8D%8F%E7%A8%8B%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>协程本质上是<strong>轻量级的线程</strong>。</p></blockquote><h2 id="协程的概念"><a href="#协程的概念" class="headerlink" title="协程的概念"></a>协程的概念</h2><p>协程是一种<strong>非抢占式或协作式</strong>的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。避免在异步编程中使用大量的回调，同时相比于传统的多线程技术，更容易<em>提升系统的高并发处理能力。</em></p><p>线程和协程属于<strong>一对多</strong>关系，一个线程上允许存在多个协程。</p><blockquote><p>线程大多数的实现是映射到内核的线程，当线程中的代码逻辑在线程抢到CPU的时间片才可以执行，否则只能等待。而协程之所以<strong>轻量级</strong>，协程并不会映射到内核线程，调度可以在用户态搞定，任务之间调度并非抢占式。</p></blockquote><h2 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h2><pre><code class="hljs kotlin">GlobalScope.launch(Dispatchers.Main + ,start = CoroutineStart.DEFAULT)&#123;  <span class="hljs-comment">// TODO</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,<span class="hljs-comment">//协程作用域</span>    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,<span class="hljs-comment">//协程启动方式</span>    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span> <span class="hljs-comment">//协程内需要执行的操作</span>)</span></span>: Job &#123;...&#125;</code></pre><h3 id="协程作用域-CoroutineScope"><a href="#协程作用域-CoroutineScope" class="headerlink" title="协程作用域(CoroutineScope)"></a>协程作用域(<code>CoroutineScope</code>)</h3><blockquote><p>在Android环境中，通常每个界面(Activity、Fragment)启动的协程(<code>Coroutine</code>)只在该界面有效，当退出界面时，协程执行的任务也没有意义。所以在设计<code>Coroutine</code>时会要求在<code>Scope</code>中执行，当<code>CoroutineScope</code>取消时，对应的<code>Coroutine</code>也需要自动取消。</p></blockquote><h4 id="阻塞协程作用域-runBlocking"><a href="#阻塞协程作用域-runBlocking" class="headerlink" title="阻塞协程作用域(runBlocking)"></a>阻塞协程作用域(<code>runBlocking</code>)</h4><blockquote><p>调用<code>runBlocking</code>的线程会被阻塞直到内部协程任务执行完毕</p></blockquote><pre><code class="hljs kotlin">runBlocking &#123;    launch &#123;        println(<span class="hljs-string">"Hello <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)        delay(<span class="hljs-number">1000</span>)    &#125;&#125;println(<span class="hljs-string">"world <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)输出结果：Hello <span class="hljs-number">1597924663541</span>world <span class="hljs-number">1597924664551</span>结果相差接近<span class="hljs-number">1</span>s</code></pre><p><strong>多用于单元测试代码中，不会用于实际的业务开发。就因为会堵塞当前线程</strong></p><h4 id="全局协程作用域-GlobalScope"><a href="#全局协程作用域-GlobalScope" class="headerlink" title="全局协程作用域(GlobalScope)"></a>全局协程作用域(<code>GlobalScope</code>)</h4><blockquote><p>作用于整个应用的生命周期中，并且无法被取消，在界面中使用，例如<code>Activity</code>中使用，就会导致内存泄露</p></blockquote><pre><code class="hljs kotlin">GlobalScope.launch(Dispatchers.Unconfined) &#123;    println(<span class="hljs-string">"Hello <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)    delay(<span class="hljs-number">1000</span>)&#125;println(<span class="hljs-string">"world <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)输出结果：Hello <span class="hljs-number">1597924937030</span>world <span class="hljs-number">1597924937038</span>结果接近</code></pre><p>通过<code>GlobalScope</code>创建的协程将不会有<code>父协程</code>，也被称为<code>根协程</code>。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;    <span class="hljs-comment">/**     * Returns [EmptyCoroutineContext].     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext <span class="hljs-comment">//返回一个上下文但并没有进行上下文关联，导致无法被取消</span>&#125;</code></pre><h4 id="自定义协程作用域-CoroutineScope"><a href="#自定义协程作用域-CoroutineScope" class="headerlink" title="自定义协程作用域(: CoroutineScope)"></a>自定义协程作用域(<code>: CoroutineScope</code>)</h4><blockquote><p>自定义协程的作用域，就不会造成作用域过大导致的内存泄漏</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job()<span class="hljs-comment">//协程上下文</span><span class="hljs-keyword">val</span> coroutineScope = CoroutineScope(coroutineContext)<span class="hljs-comment">//自定义作用域</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;  coroutineScope.launch&#123;      println(<span class="hljs-string">"Hello <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)      delay(<span class="hljs-number">1000</span>)  &#125;  println(<span class="hljs-string">"world <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)  <span class="hljs-comment">//主动控制作用域的取消</span>  coroutineScope.cancel()&#125;</code></pre><p>自定义协程作用域最关键的就是<strong>定义CoroutineContext属性</strong>。</p><p>自定义<code>CoroutineContext</code>主要由两部分构成：<code>dispatcher</code>、<code>job</code>。</p><p><code>dispatcher</code>：用于指定协程默认使用的调度器(<em>后续会介绍</em>)</p><p><code>job</code>：可在任意时刻取消协程(<em>后续会介绍</em>)</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job()</code></pre><p>用<code>+</code>连接多个上下文，其中如果出现多个同类型的上下文，后面新添加的会成为使用的上下文，例如</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Unconfined + Job() + Dispatchers.IOprint(coroutineContext.toString())输出结果：[JobImpl&#123;Active&#125;@<span class="hljs-number">300f</span>fa5d, Dispatchers.IO] <span class="hljs-comment">//采用了新添加的调度器</span></code></pre><h4 id="系统提供协程作用域"><a href="#系统提供协程作用域" class="headerlink" title="系统提供协程作用域"></a>系统提供协程作用域</h4><h5 id="MainScope"><a href="#MainScope" class="headerlink" title="MainScope"></a>MainScope</h5><blockquote><p>为了方便开发使用，kotlin标准库中定义了<code>MainScope()</code>可以快速生成<code>CoroutineScope</code></p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//MainScope实现源码</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MainScope</span><span class="hljs-params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)使用方式：<span class="hljs-keyword">val</span> mainScope  = MainScope()<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;  mainScope.launch&#123;    <span class="hljs-comment">//TODO</span>  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>&#123;  mainScope.cancel()&#125;</code></pre><h5 id="viewModelScope"><a href="#viewModelScope" class="headerlink" title="viewModelScope"></a>viewModelScope</h5><blockquote><p>在AndroidX中 引入了<code>viewModelScope</code>，当ViewModel销毁时会自动取消协程任务。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//引用viewModelScope</span>implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-viewmodel-ktx:2.1.0-beta01:"</span> <span class="hljs-comment">//也可以引用更高版本</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewModel</span>:<span class="hljs-type">ViewModel</span></span>()&#123;  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    viewModelScope.launch&#123;      <span class="hljs-comment">//TODO </span>    &#125;  &#125;&#125;</code></pre><p>简单源码解析：</p><pre><code class="hljs kotlin"><span class="hljs-comment">//lifecycle/lifecycle-viewmodel-ktx/src/main/java/androidx/lifecycle/ViewModel.kt</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> JOB_KEY = <span class="hljs-string">"androidx.lifecycle.ViewModelCoroutineScope.JOB_KEY"</span><span class="hljs-comment">/** * [CoroutineScope] tied to this [ViewModel]. * This scope will be canceled when ViewModel will be cleared, i.e [ViewModel.onCleared] is called * * This scope is bound to * [Dispatchers.Main.immediate][kotlinx.coroutines.MainCoroutineDispatcher.immediate] */</span><span class="hljs-comment">//使用拓展方法</span><span class="hljs-keyword">val</span> ViewModel.viewModelScope: CoroutineScope        <span class="hljs-keyword">get</span>() &#123;            <span class="hljs-keyword">val</span> scope: CoroutineScope? = <span class="hljs-keyword">this</span>.getTag(JOB_KEY)          <span class="hljs-comment">//缓存中读取 对应scope</span>            <span class="hljs-keyword">if</span> (scope != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">return</span> scope            &#125;           <span class="hljs-comment">//对应了ViewModel内部的实现代码</span>            <span class="hljs-keyword">return</span> setTagIfAbsent(JOB_KEY,                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate))        &#125;<span class="hljs-comment">//自动取消 coroutineScope</span><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseableCoroutineScope</span></span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext = context    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123;        coroutineContext.cancel()    &#125;&#125;</code></pre><p><code>viewModelScope</code>默认调度器为<code>Dispatchers.Main</code>，因为<code>ViewModel</code>与UI交互较为频繁，减少线程间的切换。</p><pre><code class="hljs kotlin"><span class="hljs-comment">//lifecycle/lifecycle-viewmodel/src/main/java/androidx/lifecycle/ViewModel.java</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; mBagOfTags = new HashMap&lt;&gt;();<span class="hljs-comment">//同步存值</span>    &lt;T&gt; T setTagIfAbsent(String key, T newValue) &#123;        T previous;        synchronized (mBagOfTags) &#123;            previous = (T) mBagOfTags.<span class="hljs-keyword">get</span>(key);            <span class="hljs-keyword">if</span> (previous == <span class="hljs-literal">null</span>) &#123;                mBagOfTags.put(key, newValue);            &#125;        &#125;        T result = previous == <span class="hljs-literal">null</span> ? newValue : previous;        <span class="hljs-keyword">if</span> (mCleared) &#123;            closeWithRuntimeException(result);        &#125;        <span class="hljs-keyword">return</span> result;    &#125; <span class="hljs-meta">@MainThread</span><span class="hljs-comment">//销毁ViewModel</span>    <span class="hljs-keyword">final</span> void clear() &#123;        mCleared = <span class="hljs-literal">true</span>;        <span class="hljs-comment">// Since clear() is final, this method is still called on mock objects</span>        <span class="hljs-comment">// and in those cases, mBagOfTags is null. It'll always be empty though</span>        <span class="hljs-comment">// because setTagIfAbsent and getTag are not final so we can skip</span>        <span class="hljs-comment">// clearing it</span>        <span class="hljs-keyword">if</span> (mBagOfTags != <span class="hljs-literal">null</span>) &#123;            synchronized (mBagOfTags) &#123;              <span class="hljs-comment">//读取缓存好的 viewModelScope对象</span>                <span class="hljs-keyword">for</span> (Object value : mBagOfTags.values()) &#123;                    <span class="hljs-comment">// see comment for the similar call in setTagIfAbsent</span>                    closeWithRuntimeException(value);                &#125;            &#125;        &#125;        onCleared();    &#125;<span class="hljs-comment">//清理缓存对象 这也是CloseableCoroutineScope存在的原因</span> <span class="hljs-keyword">private</span> static void closeWithRuntimeException(Object obj) &#123;        <span class="hljs-keyword">if</span> (obj instanceof Closeable) &#123;            <span class="hljs-keyword">try</span> &#123;                ((Closeable) obj).close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                <span class="hljs-keyword">throw</span> new RuntimeException(e);            &#125;        &#125;    &#125;</code></pre><h3 id="协程启动模式-CoroutineStart"><a href="#协程启动模式-CoroutineStart" class="headerlink" title="协程启动模式(CoroutineStart)"></a>协程启动模式(<code>CoroutineStart</code>)</h3><blockquote><p>控制协程创建后的调用规则</p></blockquote><h4 id="CoroutineStart-DEFAULT"><a href="#CoroutineStart-DEFAULT" class="headerlink" title="CoroutineStart.DEFAULT"></a>CoroutineStart.DEFAULT</h4><blockquote><p>协程的默认启动模式，为<code>饿汉式调用</code>，调用协程后，会立即进入调度状态(等待调度器初始化完毕)。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;    print(<span class="hljs-number">1</span>)    <span class="hljs-keyword">val</span> job = GlobalScope.launch &#123;        print(<span class="hljs-number">2</span>)        delay(<span class="hljs-number">1000</span>)    &#125;    print(<span class="hljs-number">3</span>)    job.join()    print(<span class="hljs-number">4</span>)&#125;输出结果：<span class="hljs-number">123</span>(delay <span class="hljs-number">1000</span>ms)<span class="hljs-number">4</span></code></pre><p><strong>协程创建后，立即开始调度，在调度前如果协程被取消，将直接进入取消响应的状态。</strong></p><h4 id="CoroutineStart-LAZY"><a href="#CoroutineStart-LAZY" class="headerlink" title="CoroutineStart.LAZY"></a>CoroutineStart.LAZY</h4><blockquote><p><code>懒汉式调用</code>，<code>launch</code>后并不会有任何调度行为，协程也不会执行，直到调用执行时，协程才会执行。</p><p>只有主动调用<code>start、join、或await</code>后协程才会开始调度。</p><p><code>job.start()</code>：启动协程</p><p><code>job.join()</code>：启动协程并等待任务执行结束</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;    print(<span class="hljs-number">1</span>)    <span class="hljs-keyword">val</span> job = coroutineScope.launch(start = CoroutineStart.LAZY) &#123;        print(<span class="hljs-number">2</span>)        delay(<span class="hljs-number">1000</span>)    &#125;    print(<span class="hljs-number">3</span>)    job.start()  <span class="hljs-comment">//job.join()</span>    print(<span class="hljs-number">4</span>)&#125;输出结果：job.start() <span class="hljs-number">1324</span> 没有延迟输出<span class="hljs-number">4</span>job.join() <span class="hljs-number">1324</span> 延迟<span class="hljs-number">1</span>s后输出<span class="hljs-number">4</span></code></pre><p><strong>协程创建后，只有被需要使用时才会执行，例如调用<code>start、join</code>才会开始调度执行。</strong></p><h4 id="CoroutineStart-ATOMIC-实验版"><a href="#CoroutineStart-ATOMIC-实验版" class="headerlink" title="CoroutineStart.ATOMIC(实验版)"></a>CoroutineStart.ATOMIC(实验版)</h4><blockquote><p>协程创建后，立即开始调度，在<strong>协程执行到第一个挂起点之前不会响应<code>cancel</code>操作</strong></p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;    print(<span class="hljs-number">1</span>)  <span class="hljs-comment">//val job = GlobalScope.launch(start = CoroutineStart.DEFAULT) &#123;</span>    <span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;        print(<span class="hljs-number">2</span>)        delay(<span class="hljs-number">1000</span>)    &#125;    job.cancel()    print(<span class="hljs-number">3</span>)    print(<span class="hljs-number">4</span>)&#125;输出结果：DEFAULT：<span class="hljs-number">134</span> 由于在准备执行时触发了cancel，导致<span class="hljs-number">2</span>无法输出ATOMIC：<span class="hljs-number">1324</span> ATOMIC在执行前不会响应到cancel，所以<span class="hljs-number">2</span>正常输出</code></pre><p><strong>ATOMIC将<code>调度</code>与<code>执行</code>合二为一，是一个原子化操作。</strong></p><p>升级版示例：</p><pre><code class="hljs kotlin">    print(<span class="hljs-number">1</span>)    <span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;        print(<span class="hljs-number">2</span>)        delay(<span class="hljs-number">1000</span>)        print(<span class="hljs-number">5</span>)    &#125;    job.cancel()    print(<span class="hljs-number">3</span>)    print(<span class="hljs-number">4</span>)输出结果：<span class="hljs-number">1342</span> 不输出<span class="hljs-number">5</span>的原因是：`ATOMIC`在第一个挂起点时忽略`cancel`，后续在执行挂起时,`cancel`功能生效，导致后续无法输出，这里`delay`就是下一次的挂起操作。</code></pre><h4 id="CoroutineStart-UNDISPATCHED-实验版"><a href="#CoroutineStart-UNDISPATCHED-实验版" class="headerlink" title="CoroutineStart.UNDISPATCHED(实验版)"></a>CoroutineStart.UNDISPATCHED(实验版)</h4><blockquote><p>协程创建后立即在当前函数调用栈中执行，直到第一个挂起点？</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;    println(<span class="hljs-string">"<span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span> 1"</span>)    <span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123; <span class="hljs-comment">// val job = GlobalScope.launch(start = CoroutineStart.DEFAULT) &#123;</span>        println(<span class="hljs-string">"<span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span> 2"</span>)        delay(<span class="hljs-number">1000</span>)        println(<span class="hljs-string">"<span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span> 5"</span>)    &#125;    println(<span class="hljs-string">"<span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span> 3"</span>)    job.join()    println(<span class="hljs-string">"<span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span> 4"</span>)&#125;输出结果：DEFAULTThread[main,<span class="hljs-number">5</span>,main] <span class="hljs-number">1</span>Thread[main,<span class="hljs-number">5</span>,main] <span class="hljs-number">3</span>Thread[DefaultDispatcher-worker-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main] <span class="hljs-number">2</span>Thread[DefaultDispatcher-worker-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main] <span class="hljs-number">5</span>Thread[DefaultDispatcher-worker-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main] <span class="hljs-number">4</span>UNDISPATCHEDThread[main,<span class="hljs-number">5</span>,main] <span class="hljs-number">1</span>Thread[main,<span class="hljs-number">5</span>,main] <span class="hljs-number">2</span>Thread[main,<span class="hljs-number">5</span>,main] <span class="hljs-number">3</span>Thread[DefaultDispatcher-worker-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main] <span class="hljs-number">5</span>Thread[DefaultDispatcher-worker-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main] <span class="hljs-number">4</span></code></pre><p>比较<code>DEFAULT</code>结果可见，在<code>UNDISPATCHED</code>条件下，未达到挂起点时，代码会执行在调用函数栈中，例如<code>UNDISPATCHED</code>的<code>print(2)</code>就输出在<code>Main</code>线程下。</p><table><thead><tr><th>CoroutineStart配置</th><th>功能</th></tr></thead><tbody><tr><td>DEFAULT</td><td>协程创建后立即执行</td></tr><tr><td>LAZY</td><td>协程创建后，等待需要调用时才会执行协程<br><code>start、join、await</code>等代码调用</td></tr><tr><td>ATOMIC</td><td>功能类似<code>DEFAULT</code>，但是在执行协程前无法被取消，直到执行到了第一个<code>suspend函数</code>,例如<code>delay()</code>就是个<code>suspend</code>函数</td></tr><tr><td>UNDISPATCHED</td><td>立即在当前线程执行协程，直到执行到了第一个<code>suspend函数</code></td></tr></tbody></table><h3 id="协程上下文-CoroutineContext"><a href="#协程上下文-CoroutineContext" class="headerlink" title="*协程上下文(CoroutineContext)"></a>*协程上下文(<code>CoroutineContext</code>)</h3><blockquote><p>本体是一个数据结构，可以看做是<code>map</code>，内部实现为<code>单链表</code></p><p><code>上下文</code>记录了协程所需信息：</p><ul><li>协程调度器：Dispatchers</li><li>执行任务：Job</li><li>协程名字：CoroutineName</li><li>协程异常处理：CoroutineExceptionHandler</li></ul></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job() + CoroutineName(<span class="hljs-string">"name"</span>)<span class="hljs-comment">//协程上下文</span></code></pre><h4 id="自定义上下文"><a href="#自定义上下文" class="headerlink" title="自定义上下文"></a>自定义上下文</h4><p>Kotlin提供了<code>AbstractCoroutineContextElement</code>可以快速实现自定义上下文，例如<code>CoroutineName</code>就是依赖这个实现的</p><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineName</span></span>(    <span class="hljs-comment">/**     * User-defined coroutine name.     */</span>    <span class="hljs-keyword">val</span> name: String) : AbstractCoroutineContextElement(CoroutineName) &#123;    <span class="hljs-comment">/**     * Key for [CoroutineName] instance in the coroutine context.     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;    <span class="hljs-comment">/**     * Returns a string representation of the object.     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String = <span class="hljs-string">"CoroutineName(<span class="hljs-variable">$name</span>)"</span>&#125;</code></pre><h4 id="协程上下文的父子关系"><a href="#协程上下文的父子关系" class="headerlink" title="协程上下文的父子关系"></a>协程上下文的父子关系</h4><blockquote><p>每个协程都会有一个父级对象，协程的父级对象的<code>上下文</code>也会和父级协程的<code>上下文</code>不一致。</p></blockquote><p>关系遵循如下公式</p><p><strong>父级上下文 = 默认值 + 继承的<code>CoroutineContext</code> + 参数</strong></p><p><code>默认值</code>：一些元素包含的默认值，例如默认<code>Dispatcher</code>就是<code>Dispatchers.Default</code></p><p><code>继承的CoroutineContext</code>：父协程的<code>CoroutineContenxt</code></p><p><code>参数</code>：后续子协程配置的参数，如上文所示组成部分，新添加的参数会覆盖前面的对应配置。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testCoroutineContextExtend</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> parentContext: CoroutineContext = Dispatchers.Default + Job() + CoroutineName(<span class="hljs-string">"parent"</span>)    <span class="hljs-keyword">val</span> parentScope = CoroutineScope(parentContext)    parentScope.launch &#123;        log(currentCoroutineContext().toString()) <span class="hljs-comment">//打印当前上下文内容</span>        <span class="hljs-keyword">val</span> childContext = parentContext + Dispatchers.IO + CoroutineName(<span class="hljs-string">"child"</span>)        <span class="hljs-keyword">val</span> job =  launch(childContext) &#123;            log(currentCoroutineContext().toString())        &#125;    &#125;&#125;输出结果：<span class="hljs-number">19</span>:<span class="hljs-number">29</span>:<span class="hljs-number">57</span>:<span class="hljs-number">497</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] [CoroutineName(parent), StandaloneCoroutine&#123;Active&#125;@<span class="hljs-number">4815</span>c1f8, Dispatchers.Default]<span class="hljs-number">19</span>:<span class="hljs-number">29</span>:<span class="hljs-number">57</span>:<span class="hljs-number">500</span> [DefaultDispatcher-worker-<span class="hljs-number">2</span>] [CoroutineName(child), StandaloneCoroutine&#123;Active&#125;@<span class="hljs-number">2</span>ca2b65d, Dispatchers.IO]</code></pre><p>根据上述输出结果可得到<strong>后续的同类内容会覆盖前面的元素</strong>。</p><p><code>CoroutineContext</code>使用<strong>+</strong>进行元素的合并，加号右侧的元素会覆盖左侧的元素，最后得到一个新的<code>CoroutineContext</code>元素。</p><p>//TODO 后续会补充如何调用自定义上下文</p><h3 id="协程拦截器-ContinuationInterceptor"><a href="#协程拦截器-ContinuationInterceptor" class="headerlink" title="协程拦截器(ContinuationInterceptor)"></a>协程拦截器(<code>ContinuationInterceptor</code>)</h3><blockquote><p>协程拦截器也是<code>CoroutineContext</code>的一个实现，可以控制协程的执行流程，功能类似于<code>Okhttp的拦截器</code>。</p><p><code>协程拦截器</code>永远置于<code>CoroutineContext</code>组合的最后一位，保证不会被其他实现所覆盖。</p><p><strong>协程拦截器最多只能存在1个。</strong></p><!--如何配置多个拦截器？--></blockquote><pre><code class="hljs kotlin">class CustomInterceptor : ContinuationInterceptor &#123;    override val key = ContinuationInterceptor    override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt;  = CustomContinuation&lt;T&gt;(continuation)    class CustomContinuation&lt;T&gt;(val continuation: Continuation&lt;T&gt;) : Continuation&lt;T&gt; &#123;        override val context: CoroutineContext = continuation.context        override fun resumeWith(result: Result&lt;T&gt;) &#123;            println("result = $result")            //对result进行多次处理，也可以联动成多个拦截器的处理            //此处hook 返回值可对其进行修改或者拓展            continuation.resumeWith(result)        &#125;    &#125;&#125;GlobalScope.launch(CustomInterceptor())&#123;  //TODO ...&#125;</code></pre><h3 id="协程调度器-CoroutineDispatcher"><a href="#协程调度器-CoroutineDispatcher" class="headerlink" title="协程调度器(CoroutineDispatcher)"></a>协程调度器(<code>CoroutineDispatcher</code>)</h3><blockquote><p>属于<code>CoroutineContext</code>的子类，同时实现了<code>ContinuationInterceptor</code>接口，通过拦截功能实现协程的调度。</p><p>调度器的主要目的<strong>切换执行线程</strong>。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineDispatcher</span> :    <span class="hljs-type">AbstractCoroutineContextElement</span></span>(ContinuationInterceptor), ContinuationInterceptor &#123;        ...       <span class="hljs-comment">//此处切换任务执行线程</span>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#125;</code></pre><p>先了解源码中提供的调度器</p><h4 id="Dispatchers-Default"><a href="#Dispatchers-Default" class="headerlink" title="Dispatchers.Default"></a>Dispatchers.Default</h4><blockquote><p>默认协程调度器，适合处理后台计算，为<code>CPU密集型</code>任务调度器</p></blockquote><!--ForkJoinPool--><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> Dispatchers &#123;      <span class="hljs-meta">@JvmStatic</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">val</span> Default: CoroutineDispatcher = createDefaultDispatcher()  ...&#125;<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDefaultDispatcher</span><span class="hljs-params">()</span></span>: CoroutineDispatcher =    <span class="hljs-keyword">if</span> (useCoroutinesScheduler) DefaultScheduler <span class="hljs-keyword">else</span> CommonPool<span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> DefaultScheduler : ExperimentalCoroutineDispatcher() &#123;    <span class="hljs-keyword">val</span> IO: CoroutineDispatcher = LimitingDispatcher(        <span class="hljs-keyword">this</span>,        systemProp(IO_PARALLELISM_PROPERTY_NAME, <span class="hljs-number">64</span>.coerceAtLeast(AVAILABLE_PROCESSORS)),        <span class="hljs-string">"Dispatchers.IO"</span>,        TASK_PROBABLY_BLOCKING    )    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">throw</span> UnsupportedOperationException(<span class="hljs-string">"<span class="hljs-variable">$DEFAULT_DISPATCHER_NAME</span> cannot be closed"</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String = DEFAULT_DISPATCHER_NAME    <span class="hljs-meta">@InternalCoroutinesApi</span>    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">"UNUSED"</span>)</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toDebugString</span><span class="hljs-params">()</span></span>: String = <span class="hljs-keyword">super</span>.toString()&#125;</code></pre><h4 id="Dispatchers-IO（仅JVM可用）"><a href="#Dispatchers-IO（仅JVM可用）" class="headerlink" title="Dispatchers.IO（仅JVM可用）"></a>Dispatchers.IO（仅JVM可用）</h4><blockquote><p>IO调度器，适合执行IO相关操作，例如读写文件，为<code>IO密集型</code>任务调度器</p></blockquote><p>IO仅在JVM上有定义，基于<code>Default</code>调度器，并实现了独立的队列和限制，因此<code>Default与IO</code>切换不会触发线程切换。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    log(<span class="hljs-string">"1"</span>)    <span class="hljs-keyword">val</span> job = GlobalScope.async(Dispatchers.IO) &#123;        log(<span class="hljs-number">2</span>)        withContext(Dispatchers.Default)&#123;            log(<span class="hljs-number">3</span>)            withContext(Dispatchers.IO)&#123;                log(<span class="hljs-number">4</span>)                withContext(Dispatchers.Default)&#123;                    log(<span class="hljs-number">5</span>)                    <span class="hljs-number">123</span>                &#125;            &#125;        &#125;    &#125;    log(job.await())&#125;输出结果：<span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">564</span> [main] <span class="hljs-number">1</span><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">581</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">2</span><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">586</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">3</span><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">586</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">4</span><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">587</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">5</span> <span class="hljs-comment">//切换过程中一直在同一线程</span><span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">588</span> [DefaultDispatcher-worker-<span class="hljs-number">2</span>] <span class="hljs-number">123</span></code></pre><p><code>Default</code>与<code>IO</code>调度器对任务的执行做了优化，可以保证线程执行效率较高。</p><p>主要原理为：Kotlin实现了<code>CoroutineScheduler</code>，支持抢占任务。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineScheduler</span></span>(    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> corePoolSize: <span class="hljs-built_in">Int</span>,    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> maxPoolSize: <span class="hljs-built_in">Int</span>,    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> idleWorkerKeepAliveNs: <span class="hljs-built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> schedulerName: String = DEFAULT_SCHEDULER_NAME) : Executor, Closeable &#123;  ...  <span class="hljs-comment">//CPU密集任务队列</span>    <span class="hljs-meta">@JvmField</span>    <span class="hljs-keyword">val</span> globalCpuQueue = GlobalQueue()  <span class="hljs-comment">//IO密集任务队列</span>    <span class="hljs-meta">@JvmField</span>    <span class="hljs-keyword">val</span> globalBlockingQueue = GlobalQueue()    ...      <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: <span class="hljs-type">Runnable</span>, taskContext: <span class="hljs-type">TaskContext</span> = NonBlockingContext, tailDispatch: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>)</span></span> &#123;        trackTask() <span class="hljs-comment">// this is needed for virtual time support</span>        <span class="hljs-keyword">val</span> task = createTask(block, taskContext)        <span class="hljs-comment">// try to submit the task to the local queue and act depending on the result</span>        <span class="hljs-keyword">val</span> currentWorker = currentWorker()        <span class="hljs-comment">//任务优先插入本地队列中执行</span>        <span class="hljs-keyword">val</span> notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)        <span class="hljs-comment">//本地队列已满，就将任务插入到全局队列中</span>        <span class="hljs-keyword">if</span> (notAdded != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (!addToGlobalQueue(notAdded)) &#123;                <span class="hljs-comment">// Global queue is closed in the last step of close/shutdown -- no more tasks should be accepted</span>                <span class="hljs-keyword">throw</span> RejectedExecutionException(<span class="hljs-string">"<span class="hljs-variable">$schedulerName</span> was terminated"</span>)            &#125;        &#125;      ...    &#125;  <span class="hljs-comment">//执行的任务</span>   <span class="hljs-keyword">internal</span> <span class="hljs-keyword">inner</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>() : Thread() &#123;      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> = runWorker()     <span class="hljs-comment">//执行任务</span>     <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runWorker</span><span class="hljs-params">()</span></span> &#123;            <span class="hljs-keyword">var</span> rescanned = <span class="hljs-literal">false</span>            <span class="hljs-keyword">while</span> (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) &#123;              <span class="hljs-comment">//从队列中找到任务</span>                <span class="hljs-keyword">val</span> task = findTask(mayHaveLocalTasks)              ...            &#125;   &#125;    <span class="hljs-comment">//找到本地队列任务</span>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findTask</span><span class="hljs-params">(scanLocalQueue: <span class="hljs-type">Boolean</span>)</span></span>: Task? &#123;            <span class="hljs-comment">//获取CPU控制权</span>            <span class="hljs-keyword">if</span> (tryAcquireCpuPermit()) <span class="hljs-keyword">return</span> findAnyTask(scanLocalQueue)            <span class="hljs-comment">// If we can't acquire a CPU permit -- attempt to find blocking task</span>            <span class="hljs-keyword">val</span> task = <span class="hljs-keyword">if</span> (scanLocalQueue) &#123;                localQueue.poll() ?: globalBlockingQueue.removeFirstOrNull()            &#125; <span class="hljs-keyword">else</span> &#123;                globalBlockingQueue.removeFirstOrNull()            &#125;           <span class="hljs-comment">//从其他队列获取任务执行</span>            <span class="hljs-keyword">return</span> task ?: trySteal(blockingOnly = <span class="hljs-literal">true</span>)        &#125;     <span class="hljs-comment">//从其他队列获取任务</span>     <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">trySteal</span><span class="hljs-params">(blockingOnly: <span class="hljs-type">Boolean</span>)</span></span>: Task? &#123;            assert &#123; localQueue.size == <span class="hljs-number">0</span> &#125;            <span class="hljs-keyword">val</span> created = createdWorkers            <span class="hljs-comment">// 0 to await an initialization and 1 to avoid excess stealing on single-core machines</span>            <span class="hljs-keyword">if</span> (created &lt; <span class="hljs-number">2</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>            &#125;            <span class="hljs-keyword">var</span> currentIndex = nextInt(created)            <span class="hljs-keyword">var</span> minDelay = <span class="hljs-built_in">Long</span>.MAX_VALUE            repeat(created) &#123;                ++currentIndex                <span class="hljs-keyword">if</span> (currentIndex &gt; created) currentIndex = <span class="hljs-number">1</span>                <span class="hljs-keyword">val</span> worker = workers[currentIndex]                <span class="hljs-keyword">if</span> (worker !== <span class="hljs-literal">null</span> &amp;&amp; worker !== <span class="hljs-keyword">this</span>) &#123;                    assert &#123; localQueue.size == <span class="hljs-number">0</span> &#125;                  <span class="hljs-comment">//从其他工作线程中获取任务来执行</span>                    <span class="hljs-keyword">val</span> stealResult = <span class="hljs-keyword">if</span> (blockingOnly) &#123;                        localQueue.tryStealBlockingFrom(victim = worker.localQueue)                    &#125; <span class="hljs-keyword">else</span> &#123;                        localQueue.tryStealFrom(victim = worker.localQueue)                    &#125;                    <span class="hljs-keyword">if</span> (stealResult == TASK_STOLEN) &#123;                        <span class="hljs-keyword">return</span> localQueue.poll()                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stealResult &gt; <span class="hljs-number">0</span>) &#123;                        minDelay = min(minDelay, stealResult)                    &#125;                &#125;            &#125;            minDelayUntilStealableTaskNs = <span class="hljs-keyword">if</span> (minDelay != <span class="hljs-built_in">Long</span>.MAX_VALUE) minDelay <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>        &#125;  &#125;</code></pre><p>总体设计分为三步：</p><ol><li>优先任务放在本地线程中，放在<code>Worker</code>中的<code>LocalQueue</code>中</li><li>使用双重队列<code>GlobalCpuQueue(CPU密集任务队列)</code>、<code>GlobalBlockingQueue(IO密集任务队列)</code>，<code>LocalQueue</code>满后，任务会放到对应全局队列中</li><li>当<code>LocalQueue</code>和<code>GlobalQueue</code>中的任务执行完时，会从其他正在执行任务的<code>Worker</code>中获取他的<code>LocalQueue</code>的任务放到自己的<code>LocalQueue</code>中执行。</li></ol><p>这三步可以保证<strong>线程资源的充分利用，减少了多线程的切换开销，提高了使用效率</strong>。实现参考的是<code>ForkJoinPool</code>。</p><h4 id="Dispatchers-Main"><a href="#Dispatchers-Main" class="headerlink" title="Dispatchers.Main"></a>Dispatchers.Main</h4><blockquote><p>UI调度器，根据执行平台不同会初始化为对应平台UI线程的调度器</p><p>在Android中，就会通过<code>Handler</code>调度到<code>UI线程</code>执行任务</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//加载各个平台下定义的`MainDispatcherFactory`</span><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadMainDispatcher</span><span class="hljs-params">()</span></span>: MainCoroutineDispatcher &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">val</span> factories = <span class="hljs-keyword">if</span> (FAST_SERVICE_LOADER_ENABLED) &#123;                FastServiceLoader.loadMainDispatcherFactory()            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// We are explicitly using the</span>                <span class="hljs-comment">// `ServiceLoader.load(MyClass::class.java, MyClass::class.java.classLoader).iterator()`</span>                <span class="hljs-comment">// form of the ServiceLoader call to enable R8 optimization when compiled on Android.</span>                ServiceLoader.load(                        MainDispatcherFactory::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>,                        <span class="hljs-type">MainDispatcherFactory::class.java.classLoader</span></span>                ).iterator().asSequence().toList()            &#125;            <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">"ConstantConditionIf"</span>)</span>            factories.maxBy &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)                ?: createMissingDispatcher()        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;            <span class="hljs-comment">// Service loader can throw an exception as well</span>            createMissingDispatcher(e)        &#125;    &#125;</code></pre><p>拿Android举例，分析下如何实现<code>Dispatchers.Main</code>功能</p><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadMainDispatcherFactory</span><span class="hljs-params">()</span></span>: List&lt;MainDispatcherFactory&gt; &#123;    <span class="hljs-keyword">val</span> clz = MainDispatcherFactory::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span></span>    <span class="hljs-keyword">if</span> (!ANDROID_DETECTED) &#123;        <span class="hljs-keyword">return</span> load(clz, clz.classLoader)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">val</span> result = ArrayList&lt;MainDispatcherFactory&gt;(<span class="hljs-number">2</span>)      <span class="hljs-comment">//加载对应类名的类</span>        createInstanceOf(clz, <span class="hljs-string">"kotlinx.coroutines.android.AndroidDispatcherFactory"</span>)?.apply &#123; result.add(<span class="hljs-keyword">this</span>) &#125;        createInstanceOf(clz, <span class="hljs-string">"kotlinx.coroutines.test.internal.TestMainDispatcherFactory"</span>)?.apply &#123; result.add(<span class="hljs-keyword">this</span>) &#125;        result    &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;        <span class="hljs-comment">// Fallback to the regular SL in case of any unexpected exception</span>        load(clz, clz.classLoader)    &#125;&#125;</code></pre><p>Android下的实现</p><pre><code class="hljs kotlin"><span class="hljs-comment">//在Android编译完成后，可以读取到该类</span><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidDispatcherFactory</span> : <span class="hljs-type">MainDispatcherFactory &#123;</span></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDispatcher</span><span class="hljs-params">(allFactories: <span class="hljs-type">List</span>&lt;<span class="hljs-type">MainDispatcherFactory</span>&gt;)</span></span> = HandlerContext(Looper.getMainLooper().asHandler(async = <span class="hljs-literal">true</span>), <span class="hljs-string">"Main"</span>)&#125;<span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerContext</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler: Handler,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> invokeImmediately: <span class="hljs-built_in">Boolean</span>) : HandlerDispatcher(), Delay &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(        handler: Handler,        name: String? = <span class="hljs-literal">null</span>    ) : <span class="hljs-keyword">this</span>(handler, name, <span class="hljs-literal">false</span>)    <span class="hljs-comment">//android中需要向主looper进行提交调度</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isDispatchNeeded</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;        <span class="hljs-keyword">return</span> !invokeImmediately || Looper.myLooper() != handler.looper    &#125;    <span class="hljs-comment">//通过持有主线程looper的handler进行调度</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;        handler.post(block)    &#125;    ...&#125;</code></pre><p>Android的<code>Dispatchers.Main</code>通过<code>Handler</code>将任务放到主线程中执行。</p><h4 id="Dispatchers-Unconfined"><a href="#Dispatchers-Unconfined" class="headerlink" title="Dispatchers.Unconfined"></a>Dispatchers.Unconfined</h4><blockquote><p>在协程体中，遇到第一个挂起函数前的代码运行在原线程中，执行挂起函数后，就运行在子线程中，</p></blockquote><h4 id="自定义调度器"><a href="#自定义调度器" class="headerlink" title="自定义调度器"></a>自定义调度器</h4><blockquote><p><code>Default</code>和<code>IO</code>的底层实现都依赖了<code>线程池</code>，执行到<code>挂起函数</code>时还是会发生线程的切换。可以通过自定义调度器减少这类切换的发生。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myDispatcher= Executors.newSingleThreadExecutor&#123; r -&gt; Thread(r, <span class="hljs-string">"MyThread"</span>) &#125;.asCoroutineDispatcher() <span class="hljs-comment">//转换线程池到 Dispatcher</span><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;  GlobalScope.launch(myDispatcher)&#123;    <span class="hljs-comment">//TODO </span>  &#125;    <span class="hljs-comment">//任务执行完毕后关闭线程池，避免内存泄漏</span>  myDispatcher.close()   &#125;</code></pre><h3 id="协程执行任务-Job"><a href="#协程执行任务-Job" class="headerlink" title="协程执行任务(Job)"></a>协程执行任务(<code>Job</code>)</h3><blockquote><p><code>Job</code>用于处理协程。封装了协程需要执行的代码逻辑，并且拥有简单的生命周期。</p><p><strong>负责管理协程的声明周期。</strong></p></blockquote><p>主要有以下几个生命周期：</p><ul><li><code>New</code> 新建任务</li><li><code>Active</code> 任务活跃</li><li><code>Completing</code> 任务完成中</li><li><code>Cancelling</code> 任务取消中</li><li><code>Cancelled</code> 任务已取消</li><li><code>Completed</code> 任务已完成</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Job生命周期.jpg" srcset="/img/loading.gif" class="full-image" alt="ViewTree" title="ViewTree"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>Job.join()</code>：中断与当前<code>Job</code>关联的协程，直到所有<code>子Job</code>执行完成，所关联的协程才可以继续执行。</p><p><code>join()</code>由<code>suspend</code>修饰，所以必须在协程内部被调用。</p><h4 id="SupervisorJob"><a href="#SupervisorJob" class="headerlink" title="SupervisorJob"></a><code>SupervisorJob</code></h4><p>使用<code>Job</code>时，若发生异常会导致异常进行传递，导致<code>父任务及兄弟任务都会被取消</code>。</p><p><code>SupervisorJob</code>针对异常传播情况进行处理，当发生异常时，只会影响自身，其他任务不受影响。</p><p><strong><code>SupervisorJob</code>只有在<code>supervisorScope</code>或者<code>CoroutineScope(SupervisorJob())</code>内执行可以生效。</strong></p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> scope = CoroutineScope(SupervisorJob())scope.launch&#123;  launch&#123;     <span class="hljs-comment">//child 1</span>  &#125;    launch&#123;    <span class="hljs-comment">// child 2</span>  &#125;&#125;若 child1 发生异常 child2可以继续运行。</code></pre><h3 id="协程构造器-Coroutine-Builders"><a href="#协程构造器-Coroutine-Builders" class="headerlink" title="协程构造器(Coroutine Builders)"></a>协程构造器(<code>Coroutine Builders</code>)</h3><blockquote><p>配置完上述的<code>启动模式、调度器、上下文</code>之后，就要开始构造一个<code>协程</code>。</p></blockquote><p>协程提供了几个通用的构造器</p><h4 id="launch"><a href="#launch" class="headerlink" title="launch"></a><code>launch</code></h4><blockquote><p>默认构建一个新的协程，并返回一个<code>Job</code>对象，可以对该<code>Job</code>进行操作，例如<code>start()、join()</code>启动协程,<code>cancel()</code>取消该协程。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> job = GlobalScope.launch&#123;  <span class="hljs-comment">//TODO ...</span>&#125;job.cancel()</code></pre><p><code>Job</code>代表了协程本身，封装了协程需要执行的代码逻辑，并且拥有简单的生命周期。</p><h4 id="async"><a href="#async" class="headerlink" title="async"></a><code>async</code></h4><blockquote><p>创建一个协程后，会返回一个<code>Deferred&lt;T&gt;</code>对象，可以通过该对象调用<code>await()</code>获取返回值。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> job = GlobalScope.async(Dispatchers.IO) &#123;log(<span class="hljs-number">2</span>)  delay(<span class="hljs-number">1000</span>)  <span class="hljs-number">123</span>&#125;<span class="hljs-keyword">val</span> result = job.await()</code></pre><p><code>async</code>允许<strong>并行的允许多个子线程任务</strong>。减少请求的耗时。</p><p><code>Deferred</code>提供了<code>await()</code>，用<code>suspend</code>修饰，需要获取<code>Deferred</code>对象的结果时，调用<code>await()</code>等待执行结果返回。</p><h3 id="协程异常处理-Coroutine-Exception"><a href="#协程异常处理-Coroutine-Exception" class="headerlink" title="协程异常处理(Coroutine Exception)"></a>协程异常处理(<code>Coroutine Exception</code>)</h3><p>以下是会导致协程异常发生的测试代码</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = <span class="hljs-number">1</span><span class="hljs-comment">//模拟产生异常方法</span><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span> =    suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;        <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) &#123;            continuation.resume(a)        &#125; <span class="hljs-keyword">else</span> &#123;            continuation.resumeWithException(IllegalArgumentException(<span class="hljs-string">"haha"</span>))        &#125;    &#125;<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;    <span class="hljs-keyword">val</span> dispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher();    coroutineScope.launch(dispatcher) &#123;        log(<span class="hljs-number">1</span>)        <span class="hljs-comment">//创建子协程</span>        <span class="hljs-keyword">val</span> job = coroutineScope.async &#123;            test2()        &#125;        job.join()        log(<span class="hljs-number">2</span>)    &#125;    log(<span class="hljs-number">3</span>)    dispatcher.close()&#125;输出结果：[main] <span class="hljs-number">3</span>[pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] <span class="hljs-number">1</span>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"pool-1-thread-1"</span> java.lang.IllegalArgumentException: hahaProcess finished with exit code <span class="hljs-number">0</span> <span class="hljs-comment">//程序终止</span></code></pre><p>有以下两种手段来对异常进行捕获处理</p><h4 id="局部异常捕获"><a href="#局部异常捕获" class="headerlink" title="局部异常捕获"></a>局部异常捕获</h4><blockquote><p>这部分主要涉及到<code>协程作用域</code>的概念，根据上面对<code>协程作用域</code>的描述，主要分为<code>GlobalScope</code>以及<code>自定义CoroutineScope</code>两种。</p><p>对于这两种<code>协程作用域</code>异常传播也有不同的形式。</p></blockquote><h5 id="不传播异常"><a href="#不传播异常" class="headerlink" title="不传播异常"></a>不传播异常</h5><p>上面提到过<code>GlobalScope</code>为全局作用域，本身不存在父协程，发生异常后，只会输出异常信息，不会对运行产生影响。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span> &#123;    coroutineScope.launch &#123;        log(<span class="hljs-number">1</span>)        <span class="hljs-keyword">val</span> job = GlobalScope.launch &#123;            <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"11"</span>)        &#125;        log(<span class="hljs-number">2</span>)        delay(<span class="hljs-number">1000</span>)        log(<span class="hljs-number">3</span>)    &#125;    delay(<span class="hljs-number">1000</span>)    log(<span class="hljs-number">4</span>)&#125;输出结果：<span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">29</span>:<span class="hljs-number">623</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">1</span><span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">29</span>:<span class="hljs-number">625</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">2</span>Global Exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">catch</span> and msg = <span class="hljs-number">11</span>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"DefaultDispatcher-worker-3"</span> java.lang.NullPointerException: <span class="hljs-number">11</span>at com.webrtc.lib_licode_adaptation.MyClassKt$test5$<span class="hljs-number">2</span>$job$<span class="hljs-number">1</span>.invokeSuspend(MyClass.kt:<span class="hljs-number">183</span>)<span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">632</span> [kotlinx.coroutines.DefaultExecutor] <span class="hljs-number">4</span><span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">632</span> [DefaultDispatcher-worker-<span class="hljs-number">3</span>] <span class="hljs-number">3</span>Process finished with exit code <span class="hljs-number">0</span></code></pre><p>使用<code>GlobalScope</code>启动协程，发生异常时，不会影响外部协程的运行。</p><h5 id="传播异常"><a href="#传播异常" class="headerlink" title="传播异常"></a>传播异常</h5><blockquote><p><strong>将异常主动往外抛到启动顶层协程所在的线程。</strong></p><p>主要采用<code>try{..}catch{...}</code>方式进行异常捕获</p></blockquote><p><code>coroutineScope</code></p><blockquote><p>协程默认作用域，在该作用域内当自身执行任务失败的时候，触发双向传播。</p><p><strong>子协程异常&lt;=&gt;父协程异常</strong></p></blockquote><p>示例：</p><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span> &#123;    log(<span class="hljs-number">1</span>)    coroutineScope &#123;        <span class="hljs-comment">// 启动一个子协程</span>        launch &#123;            <span class="hljs-keyword">try</span> &#123;                delay(<span class="hljs-number">1000</span>)                println(<span class="hljs-string">"3"</span>)            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;                println(e.message)            &#125;        &#125;        delay(<span class="hljs-number">100</span>)        <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"111"</span>)        println(<span class="hljs-string">"3"</span>)    &#125;&#125;输出结果：<span class="hljs-number">10</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46</span>:<span class="hljs-number">738</span> [main] <span class="hljs-number">1</span>Parent job <span class="hljs-keyword">is</span> Cancelling <span class="hljs-comment">//由于父协程异常，导致子协程的执行取消</span>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.NullPointerException: <span class="hljs-number">111</span></code></pre><p><img src="/Users/wxy/myblog/blog/source/images/640.gif" srcset="/img/loading.gif" alt="img"></p><p><code>supervisorScope</code></p><blockquote><p>在作用域内当自身执行任务失败的时候，只会向下传播关闭子协程，不会影响父协程及其他同级协程的运行。</p><p><strong>父协程异常-&gt;子线程异常，子协程异常不影响父协程</strong></p><p><code>supervisorScope</code>使用<code>SupervisorJob</code></p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupervisorJobImpl</span></span>(parent: Job?) : JobImpl(parent) &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">childCancelled</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//子协程不影响父协程</span>&#125;</code></pre><p>示例：</p><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span> &#123;    println(<span class="hljs-number">1</span>)    supervisorScope &#123;        println(<span class="hljs-string">"2"</span>)        <span class="hljs-comment">// 启动一个子协程</span>        launch &#123;            <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"111"</span>)<span class="hljs-comment">// 故意让子协程出现异常</span>        &#125;        delay(<span class="hljs-number">100</span>)        println(<span class="hljs-string">"3"</span>)    &#125;    println(<span class="hljs-string">"4"</span>)&#125;输出结果：<span class="hljs-number">1</span><span class="hljs-number">2</span>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"DefaultDispatcher-worker-1"</span> java.lang.NullPointerException: <span class="hljs-number">111</span>...<span class="hljs-number">3</span><span class="hljs-number">4</span></code></pre><p><code>supervisorScope</code>内子协程的异常不影响父协程的继续运行。</p><p><img src="/Users/wxy/myblog/blog/source/images/640.png" srcset="/img/loading.gif" alt="img"></p><h4 id="全局异常捕获"><a href="#全局异常捕获" class="headerlink" title="全局异常捕获"></a>全局异常捕获</h4><blockquote><p>类似<code>Java</code>，协程也提供了捕获全局异常(<code>未声明捕获异常</code>)的方式。</p></blockquote><p><code>Java</code>的全局异常捕获方式：</p><pre><code class="hljs java">Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> UncaughtExceptionHandler() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;        <span class="hljs-comment">//TODO 异常处理</span>    &#125;&#125;);</code></pre><h5 id="协程内全局异常捕获方式（针对协程作用域内未捕获的异常）"><a href="#协程内全局异常捕获方式（针对协程作用域内未捕获的异常）" class="headerlink" title="协程内全局异常捕获方式（针对协程作用域内未捕获的异常）"></a>协程内全局异常捕获方式（<code>针对协程作用域内未捕获的异常</code>）</h5><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;        log(<span class="hljs-string">"Throws an exception with message: <span class="hljs-subst">$&#123;throwable.message&#125;</span>"</span>)    &#125;    log(<span class="hljs-number">1</span>)    <span class="hljs-keyword">val</span> job = coroutineScope.launch(exceptionHandler) &#123;        log(<span class="hljs-number">3</span>)        <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">"Hey!"</span>)    &#125;    log(<span class="hljs-number">2</span>)  <span class="hljs-comment">//避免执行过程中 进程中断，导致输出结果不一致</span>    delay(<span class="hljs-number">1000</span>)&#125;输出结果：<span class="hljs-number">15</span>:<span class="hljs-number">31</span>:<span class="hljs-number">47</span>:<span class="hljs-number">846</span> [main] <span class="hljs-number">1</span><span class="hljs-number">15</span>:<span class="hljs-number">31</span>:<span class="hljs-number">47</span>:<span class="hljs-number">927</span> [main] <span class="hljs-number">2</span><span class="hljs-number">15</span>:<span class="hljs-number">31</span>:<span class="hljs-number">47</span>:<span class="hljs-number">929</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">3</span><span class="hljs-number">15</span>:<span class="hljs-number">31</span>:<span class="hljs-number">47</span>:<span class="hljs-number">933</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] Throws an exception with message: Hey! <span class="hljs-comment">//捕获到异常</span>Process finished with exit code <span class="hljs-number">0</span></code></pre><p>上述代码调用了<code>launch</code>的构造方式，<code>async</code>的输出结果会如何？</p><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;        log(<span class="hljs-string">"Throws an exception with message: <span class="hljs-subst">$&#123;throwable.message&#125;</span>"</span>)    &#125;    log(<span class="hljs-number">1</span>)    <span class="hljs-keyword">val</span> job = coroutineScope.async(exceptionHandler) &#123;        log(<span class="hljs-number">3</span>)        <span class="hljs-number">4</span>        <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">"Hey!"</span>)    &#125;    log(<span class="hljs-number">2</span>)    log(job.await())    delay(<span class="hljs-number">1000</span>)&#125;输出结果：<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">14</span>:<span class="hljs-number">980</span> [main] <span class="hljs-number">1</span><span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">013</span> [main] <span class="hljs-number">2</span><span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">015</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">3</span>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.ArithmeticException: Hey!at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$<span class="hljs-number">1</span>.invokeSuspend(MyClass.kt:<span class="hljs-number">171</span>)</code></pre><p><code>async</code>直接抛出未捕获异常，导致当前进程执行中断</p><p>针对<code>launch</code>和<code>async</code>的不同表现，需要从源码层面进行分析</p><pre><code class="hljs kotlin">`launch`执行指向以下代码<span class="hljs-comment">// kotlinx.coroutines.BuildersKt</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,<span class="hljs-comment">//启动方式</span>    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: Job &#123;    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span>        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)    coroutine.start(start, coroutine, block)    <span class="hljs-keyword">return</span> coroutine&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandaloneCoroutine</span></span>(    parentContext: CoroutineContext,    active: <span class="hljs-built_in">Boolean</span>) : AbstractCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt;(parentContext, active) &#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;        handleCoroutineException(context, exception)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleCoroutineException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> &#123;    <span class="hljs-comment">// Invoke an exception handler from the context if present</span>    <span class="hljs-comment">//若context存在 ExceptionHandler 则会对异常进行处理</span>    <span class="hljs-keyword">try</span> &#123;        context[CoroutineExceptionHandler]?.let &#123;            it.handleException(context, exception)            <span class="hljs-keyword">return</span>        &#125;    &#125; <span class="hljs-keyword">catch</span> (t: Throwable) &#123;        handleCoroutineExceptionImpl(context, handlerException(exception, t))        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-comment">// If a handler is not present in the context or an exception was thrown, fallback to the global handler</span>    handleCoroutineExceptionImpl(context, exception)&#125;`async`执行指向如下代码<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> CoroutineScope.<span class="hljs-title">async</span><span class="hljs-params">(    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span>)</span></span>: Deferred&lt;T&gt; &#123;    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)        LazyDeferredCoroutine(newContext, block) <span class="hljs-keyword">else</span>        DeferredCoroutine&lt;T&gt;(newContext, active = <span class="hljs-literal">true</span>)    coroutine.start(start, coroutine, block)    <span class="hljs-keyword">return</span> coroutine&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeferredCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(    parentContext: CoroutineContext,    active: <span class="hljs-built_in">Boolean</span>) : AbstractCoroutine&lt;T&gt;(parentContext, active), Deferred&lt;T&gt;, SelectClause1&lt;T&gt; &#123;  <span class="hljs-comment">//没有对 exception进行处理，导致全局异常无法处理</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getCompleted</span><span class="hljs-params">()</span></span>: T = getCompletedInternal() <span class="hljs-keyword">as</span> T    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T = awaitInternal() <span class="hljs-keyword">as</span> T    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> onAwait: SelectClause1&lt;T&gt; <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">registerSelectClause1</span><span class="hljs-params">(select: <span class="hljs-type">SelectInstance</span>&lt;<span class="hljs-type">R</span>&gt;, block: <span class="hljs-type">suspend</span> (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span> =        registerSelectClause1Internal(select, block)&#125;</code></pre><p>综上所述：<strong>在全局异常处理下，只有用<code>launch</code>启动的协程才可以捕获异常，而<code>async</code>不能被捕获异常，会继续抛出异常。</strong></p><h5 id="真·全局异常捕获方式"><a href="#真·全局异常捕获方式" class="headerlink" title="真·全局异常捕获方式"></a>真·全局异常捕获方式</h5><p>上述实现的<code>ExceptionHandler</code>只能在协程内使用，而无法处理其他协程的异常情况。需要使用<code>ServiceLoader</code>来实现全局协程异常捕获</p><p>实现全局的异常捕获需要如下几步：</p><ol><li><p>新建全局<code>ExceptionHandler</code>类</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> : <span class="hljs-type">CoroutineExceptionHandler&#123;</span></span>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> &#123;        print(<span class="hljs-string">"Global Exception is catch and msg = <span class="hljs-subst">$&#123;exception.message&#125;</span>"</span>)    &#125;&#125;</code></pre></li></ol><ol start="2"><li><p><code>classpath</code>中注册该类</p><p>在<code>src/main</code>目录下新建<code>resources/META-INF/</code>文件夹，然后新建文件命名为<code>kotlinx.coroutines.CoroutineExceptionHandler</code>，文件内写入</p><pre><code class="hljs undefined">com.XX.lib.GlobalExceptionHandler</code></pre><p>目录结构如下：</p><p>src</p><p>​    -main</p><p>​        -java</p><p>​        -resources</p><p>​            -META-INF</p><p>​                -services</p><p>​                    -kotlinx.coroutines.CoroutineExceptionHandler</p></li><li><p>测试效果</p><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;        print(<span class="hljs-string">"Throws an exception with message: <span class="hljs-subst">$&#123;throwable.message&#125;</span>"</span>)    &#125;    log(<span class="hljs-number">1</span>)    <span class="hljs-keyword">val</span> job = coroutineScope.launch() &#123; <span class="hljs-comment">//exceptionHandler配置</span>        log(<span class="hljs-number">3</span>)        <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">"Hey!"</span>)    &#125;    log(<span class="hljs-number">2</span>)  <span class="hljs-comment">//避免执行过程中 进程中断，导致输出结果不一致</span>    delay(<span class="hljs-number">1000</span>)&#125;输出结果：<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">14</span>:<span class="hljs-number">980</span> [main] <span class="hljs-number">1</span><span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">013</span> [main] <span class="hljs-number">2</span><span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">015</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">3</span>Global Exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">catch</span> and msg = Hey!Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.ArithmeticException: Hey!at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$<span class="hljs-number">1</span>.invokeSuspend(MyClass.kt:<span class="hljs-number">171</span>)若配置了exceptionHandler就会覆盖Global的配置输出如下内容：<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">14</span>:<span class="hljs-number">980</span> [main] <span class="hljs-number">1</span><span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">013</span> [main] <span class="hljs-number">2</span><span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">015</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">3</span>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.ArithmeticException: Hey!at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$<span class="hljs-number">1</span>.invokeSuspend(MyClass.kt:<span class="hljs-number">171</span>)</code></pre><p><strong>全局异常捕获的配置只对<code>launch</code>有效，<code>async</code>无效。</strong></p><p><code>真·全局异常捕获</code>不支持<code>JS以及Native</code>平台。</p><p>拓展：</p><ol><li><p>SPI机制</p><blockquote><p>全称为<code>Service Provider Interface</code>，JDK内置的一种服务提供发现机制，主要源码在<code>java,util.ServiceLoader</code>。</p></blockquote><p>使用时需要在<code>META-INF/services</code>创建和服务同名的<strong>全限定名</strong>相同的文件(例如<em>com.xx.xx.service</em>)，在文件中写入<strong>服务提供者</strong>的全限定名(例如<em>com.xxx.xx.XXService</em>)。</p><p>实现原理：</p><ol><li>调用<code>ServiceLaoder.load()</code>创建新的<code>ServiceLoader</code></li><li>再通过迭代器获取对象实例<ul><li>判断<code>providers</code>是否缓存实例对象，若存在则返回</li><li>不存在，则执行类的装载过程：<ol><li>读取<code>META-INF/services</code>的配置文件，获得需要被实例化类的名称</li><li>反射调用<code>Class.forName()</code>并调用<code>instance()</code>进行类实例化。<strong>需要对应类必须存在一个无参构造方法。</strong></li><li>实例化对象存到<code>providers</code>缓存对象中并返回实例对象。</li></ol></li></ul></li></ol><p>缺点：</p><ol><li>无法按需加载，只能通过遍历的方式获取全部接口实现类</li><li>无法直接获取实例对象，只能通过遍历匹配对应实现类</li><li>并发<code>serviceLoader</code>是不安全的</li></ol></li></ol></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p><strong>协程内部异常处理流程</strong></p><ul><li>在作用域内使用<code>try..catch</code>可以直接捕获子线程中的异常</li><li>如果未设置异常捕获，则会走<code>全局异常捕获流程</code>(<strong>只在<code>launch</code>创建协程下生效</strong>)<ul><li>若设置<code>CoroutineExceptionHandler</code>则处理</li><li>没配置，向<code>GlobalExceptionHandler</code>进行处理，该配置时全局的，对所有协程任务生效</li></ul></li></ul></li><li><p><strong>异常传播不同作用域表现</strong></p><ul><li><code>GlobalScope</code>：异常不会向外传递，因为已经是<code>根协程</code></li><li><code>coroutineScope</code>：异常进行<code>双向传递</code>，父协程和子协程都会被取消</li><li><code>supervisorScope</code>：异常进行<code>单向传递</code>，只有父协程向子协程传递异常，子协程会被取消，父协程不受影响</li></ul></li><li><p><code>launch/join</code>和<code>async/await</code>表现不同</p><p><code>launch/join</code>关注的是<strong>任务是否执行完成</strong>，<code>async/await</code>关注的是<strong>任务的执行结果</strong>，所以在局部异常捕获的时候，两种创建方式的异常捕获也会有区别</p></li><li><p><strong>全局的异常处理器(CoroutineExceptionHandler)只会对父协程生效，子协程的异常最后还是会传递到根协程进行处理。</strong>非<code>supervisorScope</code>条件下。</p></li></ol><h3 id="协程取消-Coroutine-Cancel"><a href="#协程取消-Coroutine-Cancel" class="headerlink" title="协程取消(Coroutine Cancel)"></a>协程取消(<code>Coroutine Cancel</code>)</h3><blockquote><p>取消针对<code>Job</code>而设的，调用<code>cancel()</code>可以取消正在运行的协程。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//官方示例代码</span><span class="hljs-keyword">val</span> job = launch &#123;    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;        println(<span class="hljs-string">"I'm sleeping <span class="hljs-variable">$i</span> ..."</span>)        delay(<span class="hljs-number">500L</span>)    &#125;&#125;delay(<span class="hljs-number">1300L</span>) <span class="hljs-comment">// 等待一段时间</span>println(<span class="hljs-string">"main: I'm tired of waiting!"</span>)job.cancel() <span class="hljs-comment">// 取消 job</span>job.join() <span class="hljs-comment">// 等待 job 结束</span>println(<span class="hljs-string">"main: Now I can quit."</span>)</code></pre><p>上述代码是最基础的<code>cancel</code>使用方式</p><h4 id="协程之间的关系"><a href="#协程之间的关系" class="headerlink" title="协程之间的关系"></a>协程之间的关系</h4><blockquote><p>协程之间是存在着父子关系的，<strong>取消父协程时，也会取消所有子协程！</strong></p></blockquote><p>主要有以下三种关系：</p><h5 id="父协程调用cancel-主动或者触发异常结束时，会立即取消所有子协程；子协程调用cancel-不影响父协程及兄弟协程执行。"><a href="#父协程调用cancel-主动或者触发异常结束时，会立即取消所有子协程；子协程调用cancel-不影响父协程及兄弟协程执行。" class="headerlink" title="父协程调用cancel()主动或者触发异常结束时，会立即取消所有子协程；子协程调用cancel()不影响父协程及兄弟协程执行。"></a>父协程调用<code>cancel()</code>主动或者触发异常结束时，会立即取消所有子协程；子协程调用<code>cancel()</code>不影响父协程及兄弟协程执行。</h5><pre><code class="hljs kotlin">基础调用流程Job.cancel() =&gt; JobImpl.cancel() =&gt; JobSupport.cancelImpl() =&gt; JobSupport.notifyCancelling()    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">notifyCancelling</span><span class="hljs-params">(list: <span class="hljs-type">NodeList</span>, cause: <span class="hljs-type">Throwable</span>)</span></span> &#123;        <span class="hljs-comment">// first cancel our own children</span>        onCancelling(cause)        notifyHandlers&lt;JobCancellingNode&lt;*&gt;&gt;(list, cause)        <span class="hljs-comment">// then cancel parent</span>        cancelParent(cause) <span class="hljs-comment">// tentative cancellation -- does not matter if there is no parent</span>    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancelParent</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;        <span class="hljs-comment">// Is scoped coroutine -- don't propagate, will be rethrown</span>        <span class="hljs-keyword">if</span> (isScopedCoroutine) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        <span class="hljs-keyword">val</span> isCancellation = cause <span class="hljs-keyword">is</span> CancellationException        <span class="hljs-keyword">val</span> parent = parentHandle        <span class="hljs-comment">// No parent -- ignore CE, report other exceptions.</span>        <span class="hljs-keyword">if</span> (parent === <span class="hljs-literal">null</span> || parent === NonDisposableHandle) &#123;            <span class="hljs-keyword">return</span> isCancellation        &#125;        <span class="hljs-comment">//调用所有子协程进行取消任务，子线程也会收到 CancellException</span>        <span class="hljs-keyword">return</span> parent.childCancelled(cause) || isCancellation    &#125;</code></pre><h5 id="父协程必须等到所有子协程完成-执行完成-或-取消-才算完成"><a href="#父协程必须等到所有子协程完成-执行完成-或-取消-才算完成" class="headerlink" title="父协程必须等到所有子协程完成(执行完成 或 取消)才算完成"></a>父协程必须等到所有子协程完成(执行完成 或 取消)才算完成</h5><h5 id="子协程抛出未捕获的异常时，默认情况下会取消父协程-CancellationException除外"><a href="#子协程抛出未捕获的异常时，默认情况下会取消父协程-CancellationException除外" class="headerlink" title="子协程抛出未捕获的异常时，默认情况下会取消父协程(CancellationException除外)"></a>子协程抛出未捕获的异常时，默认情况下会取消父协程(<code>CancellationException除外</code>)</h5><h4 id="只有可取消的协程代码，才可以被取消"><a href="#只有可取消的协程代码，才可以被取消" class="headerlink" title="只有可取消的协程代码，才可以被取消"></a>只有可取消的协程代码，才可以被取消</h4><blockquote><p>协程的代码必须与外界配合，才能够被取消！</p></blockquote><p>目前只有<code>kotlinx.coroutines</code>中的所有挂起函数都是<strong>可取消的</strong>。这些挂起函数会检查协程是否被取消，并在被取消时抛出<code>CancellationException</code>异常。</p><p>例如<code>delay()、yield()</code>这些预置的挂起函数，或者封装的挂起函数都是可以被取消的。</p><h5 id="delay"><a href="#delay" class="headerlink" title="delay()"></a>delay()</h5><blockquote><p>让协程挂起，而且不会阻塞CPU。</p><!--Thread.sleep 让出CPU，不会释放锁。wait会释放锁，等待notify进行唤醒--></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> (timeMillis &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// don't delay</span>    <span class="hljs-keyword">return</span> suspendCancellableCoroutine <span class="hljs-symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; -&gt;        <span class="hljs-comment">//将任务放到</span>        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)    &#125;&#125;<span class="hljs-comment">//默认延迟线程池</span><span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> CoroutineContext.delay: Delay <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">get</span>(ContinuationInterceptor) <span class="hljs-keyword">as</span>? Delay ?: DefaultDelay<span class="hljs-comment">//EventLoopImplBase</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleResumeAfterDelay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>, continuation: <span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;        <span class="hljs-keyword">val</span> timeNanos = delayToNanos(timeMillis)<span class="hljs-comment">//设置执行时间</span>        <span class="hljs-keyword">if</span> (timeNanos &lt; MAX_DELAY_NS) &#123;            <span class="hljs-keyword">val</span> now = nanoTime()            DelayedResumeTask(now + timeNanos, continuation).also &#123; task -&gt; <span class="hljs-comment">//按照延时添加任务</span>                continuation.disposeOnCancellation(task)                schedule(now, task)            &#125;        &#125;    &#125;</code></pre><p>关键点就在于<code>suspendCancellableCoroutine</code>提供了普通函数的挂起转换</p><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(    <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T =    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;        <span class="hljs-keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)        <span class="hljs-comment">/*         * For non-atomic cancellation we setup parent-child relationship immediately         * in case when `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but         * properly supports cancellation.         */</span>        cancellable.initCancellability()        block(cancellable)        cancellable.getResult()    &#125;</code></pre><h5 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h5><blockquote><p>挂起当前协程，然后将协程分发到<code>Dispatcher</code>的队列，可以让该协程所在线程或线程池可以运行其他协程逻辑，然后等待<code>Disapcher</code>空闲的时候继续执行原来协程。</p><!--Thread.yield() 让出CPU调度，只能让 同优先级的线程有执行机会--></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> dispatcher = Executors.newFixedThreadPool(<span class="hljs-number">2</span>).asCoroutineDispatcher()  coroutineScope.launch(dispatcher)&#123;            launch &#123; <span class="hljs-comment">//协程1</span>                repeat(<span class="hljs-number">3</span>) &#123;                    log(<span class="hljs-string">"job1 repeat <span class="hljs-variable">$it</span> times"</span>)                    yield() <span class="hljs-comment">//让协程2得以执行</span>                &#125;            &#125;            launch &#123; <span class="hljs-comment">//协程2</span>                repeat(<span class="hljs-number">3</span>) &#123;                    log(<span class="hljs-string">"job2 repeat <span class="hljs-variable">$it</span> times"</span>)<span class="hljs-comment">//                    yield()</span>                &#125;            &#125;    &#125;delay(<span class="hljs-number">1000</span>)dispatcher.close()输出结果：<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">808</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] job1 repeat <span class="hljs-number">0</span> times<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">809</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] job2 repeat <span class="hljs-number">0</span> times<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">809</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] job2 repeat <span class="hljs-number">1</span> times<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">809</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] job2 repeat <span class="hljs-number">2</span> times<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">809</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] job1 repeat <span class="hljs-number">1</span> times<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">809</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] job1 repeat <span class="hljs-number">2</span> times</code></pre><p><code>yield()</code>相关源码</p><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> = suspendCoroutineUninterceptedOrReturn <span class="hljs-symbol">sc@</span> &#123; uCont -&gt;    <span class="hljs-keyword">val</span> context = uCont.context    context.checkCompletion()    ...    COROUTINE_SUSPENDED&#125;</code></pre><h5 id="suspendCoroutineUninterceptedOrReturn"><a href="#suspendCoroutineUninterceptedOrReturn" class="headerlink" title="*suspendCoroutineUninterceptedOrReturn"></a>*suspendCoroutineUninterceptedOrReturn</h5><p>根据上面两个源码发现，转换挂起函数的关键在于<code>suspendCoroutineUninterceptedOrReturn</code>，只要实现了该函数，就可以转换为可被取消的挂起函数</p><p>通常做转换的时候，可以使用系统提供的两个转换函数</p><ul><li><code>suspendCoroutine</code></li><li><code>suspendCancellableCoroutine</code></li></ul><p>这两者都调用了<code>suspendCoroutineUninterceptedOrReturn</code>函数</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> aa = <span class="hljs-number">0</span><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ttt</span><span class="hljs-params">()</span></span> = suspendCancellableCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; cancellableContinuation -&gt;    <span class="hljs-keyword">if</span> (aa == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//执行完毕抛出结果</span>        cancellableContinuation.resume(<span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 执行过程异常捕获</span>            log(<span class="hljs-string">"aaa <span class="hljs-subst">$&#123;it.message&#125;</span>"</span>)        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        cancellableContinuation.resumeWithException(IllegalArgumentException(<span class="hljs-string">"123"</span>))    &#125;    cancellableContinuation.invokeOnCancellation &#123;       <span class="hljs-comment">//协程任务执行cancel时，回调该方法</span>        log(<span class="hljs-string">"我被取消了"</span>)    &#125;&#125;</code></pre><h4 id="取消计算代码-使用isActive判断"><a href="#取消计算代码-使用isActive判断" class="headerlink" title="取消计算代码(使用isActive判断)"></a>取消计算代码(使用<code>isActive</code>判断)</h4><blockquote><p>如果协程正处在某个计算过程当中，并且不进行检查状态的取消，那它就是无法被取消的。</p></blockquote><p>对于这种情况有两种处理方式：</p><ol><li>周期性调用挂起函数(<code>采用上面的手段得到挂起函数</code>)，检查协程是否被取消</li><li>显式检查协程是否被取消</li></ol><p>在这一节，采用的就是第二种方案取消协程。</p><pre><code class="hljs kotlin">suspend fun test9() &#123;    val startTime = System.currentTimeMillis()    val dispatcher = Executors.newFixedThreadPool(3).asCoroutineDispatcher()    val job = coroutineScope.launch(dispatcher) &#123;        var nextPrintTime = startTime        var i = 0        while (isActive) &#123; // 一个浪费 CPU 的计算任务循环            // 每秒打印信息 2 次            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;                i++                log(i)                nextPrintTime += 500L            &#125;        &#125;    &#125;    delay(1300L) // 等待一段时间    println("main: I'm tired of waiting!")    job.cancelAndJoin() // 取消 job, 并等待它结束    println("main: Now I can quit.")    dispatcher.close()&#125;输出结果：19:30:01:805 [pool-1-thread-1] 119:30:02:292 [pool-1-thread-1] 219:30:02:792 [pool-1-thread-1] 3main: I'm tired of waiting!main: Now I can quit.</code></pre><p>相关源码</p><pre><code class="hljs kotlin">JobSupport.cancelImpl() =&gt; JobSupport.makeCancelling() =&gt; JobSupport.tryMakeCancelling()    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryMakeCancelling</span><span class="hljs-params">(state: <span class="hljs-type">Incomplete</span>, rootCause: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;        assert &#123; state !<span class="hljs-keyword">is</span> Finishing &#125; <span class="hljs-comment">// only for non-finishing states</span>        assert &#123; state.isActive &#125; <span class="hljs-comment">// only for active states</span>        <span class="hljs-comment">// get state's list or else promote to list to correctly operate on child lists</span>        <span class="hljs-keyword">val</span> list = getOrPromoteCancellingList(state) ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        <span class="hljs-comment">// Create cancelling state (with rootCause!)</span>        <span class="hljs-keyword">val</span> cancelling = Finishing(list, <span class="hljs-literal">false</span>, rootCause)        <span class="hljs-keyword">if</span> (!_state.compareAndSet(state, cancelling)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        <span class="hljs-comment">// Notify listeners</span>        notifyCancelling(list, rootCause)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Finishing</span></span>(        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> list: NodeList,        isCompleting: <span class="hljs-built_in">Boolean</span>,        rootCause: Throwable?    ) : SynchronizedObject(), Incomplete &#123;            ...       <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = rootCause == <span class="hljs-literal">null</span> <span class="hljs-comment">// !isCancelling 此处isActive就变为false</span>    &#125;</code></pre><h4 id="禁止取消"><a href="#禁止取消" class="headerlink" title="禁止取消"></a>禁止取消</h4><blockquote><p>当任务被取消时，挂起函数会收到<code>CancellationException</code>后续如果需要执行一些其他的挂起函数任务将无法执行。</p></blockquote><p>可以通过对挂起函数调用<code>withContext(NonCancellable)</code>进行包含，保证挂起函数正常执行</p><pre><code class="hljs kotlin">suspend fun test9() &#123;    val startTime = System.currentTimeMillis()    val dispatcher = Executors.newFixedThreadPool(3).asCoroutineDispatcher()    val job = coroutineScope.launch(dispatcher) &#123;        try &#123;            var nextPrintTime = startTime            var i = 0            //按道理 这边会被取消，因为设置了 NonCancellable导致任务无法被取消            withContext(NonCancellable)&#123;                log("111")                delay(2000)            &#125;        &#125;        finally &#123;                withContext(NonCancellable)&#123;                    delay(1000)                &#125;                log("111")        &#125;    &#125;    delay(1300L) // 等待一段时间    println("main: I'm tired of waiting!")    job.cancelAndJoin() // 取消 job, 并等待它结束    println("main: Now I can quit.")    dispatcher.close()&#125;输出结果：20:31:35:163 [pool-1-thread-1] 111main: I'm tired of waiting!20:31:38:173 [pool-1-thread-3] 111  //间隔大概3smain: Now I can quit.</code></pre><p><code>NonCancellable</code>就是一个普通的对象</p><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> NonCancellable : AbstractCoroutineContextElement(Job), Job &#123; ...      <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = <span class="hljs-literal">true</span> <span class="hljs-comment">//永远为true</span>&#125;</code></pre><h4 id="超时取消"><a href="#超时取消" class="headerlink" title="超时取消"></a>超时取消</h4><blockquote><p>大部分取消协程的原因都是<strong>超出了预期的执行时间</strong>，此时就会去触发取消的操作。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testTimeout</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">try</span> &#123;        withTimeout(<span class="hljs-number">1300</span>) &#123;            repeat(<span class="hljs-number">5</span>) &#123;                delay(<span class="hljs-number">500</span>)            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;        log(<span class="hljs-string">"e.msg = <span class="hljs-subst">$&#123;e.message&#125;</span>"</span>) <span class="hljs-comment">//捕获超时异常</span>    &#125; <span class="hljs-keyword">finally</span> &#123;        log(<span class="hljs-string">"job cancelled"</span>) <span class="hljs-comment">//任务取消后，可以做一些其他工作</span>    &#125;    delay(<span class="hljs-number">1000</span>)&#125;输出结果：<span class="hljs-number">13</span>:<span class="hljs-number">25</span>:<span class="hljs-number">54</span>:<span class="hljs-number">484</span> [kotlinx.coroutines.DefaultExecutor] e.msg = Timed <span class="hljs-keyword">out</span> waiting <span class="hljs-keyword">for</span> <span class="hljs-number">1300</span> ms<span class="hljs-number">13</span>:<span class="hljs-number">25</span>:<span class="hljs-number">54</span>:<span class="hljs-number">485</span> [kotlinx.coroutines.DefaultExecutor] job cancelled</code></pre><p>执行超过<code>timeout</code>的时候，会抛出<code>TimeoutCancellationException</code>异常</p><p>上述<code>withTimeout()</code>超时时会抛出异常，系统另外提供了<code>withTimeoutOrNull()</code>超时的时候不会抛出异常，而是返回一个null</p><h3 id="协程挂起-suspend"><a href="#协程挂起-suspend" class="headerlink" title="协程挂起(suspend)"></a>协程挂起(<code>suspend</code>)</h3><p>在上节<code>协程取消</code>中，说到取消协程的一个要求就是<code>必须为可被取消的协程代码</code>，里面就有讲到转换成<code>挂起函数</code>就可以被取消。</p><blockquote><p>把协程当成一个任务，运行在某个线程之上，该任务是可以中止也可以被继续恢复执行。</p><p><code>协程挂起</code>指的就是<em>任务的中止，而且不会阻塞当前的线程。</em></p><p><code>协程挂起</code>的条件是<em>在协程调用<code>挂起函数</code>时，才可以被挂起</em>。</p></blockquote><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><h5 id="续体接口-Continuation"><a href="#续体接口-Continuation" class="headerlink" title="续体接口(Continuation)"></a>续体接口(<code>Continuation</code>)</h5><blockquote><p>作为协程调用<code>挂起函数</code>时的回调，<code>挂起函数</code>执行结束后通过使用该接口唤醒调用者。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-meta">@SinceKotlin(<span class="hljs-meta-string">"1.3"</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Continuation</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;    <span class="hljs-comment">/**     * The context of the coroutine that corresponds to this continuation.     * 定义的协程上下文     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> context: CoroutineContext    <span class="hljs-comment">/**     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the     * return value of the last suspension point.     * 执行完毕回调，回调成功或失败的结果     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>&#125;<span class="hljs-comment">//提供拓展函数，支持直接调用成功或失败回调</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Unit</span> =    resumeWith(Result.success(value))<span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resumeWithException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Unit</span> =    resumeWith(Result.failure(exception))</code></pre><p><code>Continuation</code>作为<code>挂起函数</code>调用时的一个<code>隐式参数</code>传入，封装了协程恢复后的执行代码逻辑。</p><h5 id="挂起函数-suspend-function"><a href="#挂起函数-suspend-function" class="headerlink" title="挂起函数(suspend function)"></a>挂起函数(<code>suspend function</code>)</h5><blockquote><p> <code>suspend</code>修饰挂起函数，可以通过调用其他<code>挂起函数</code>执行代码，而且<strong>不阻塞当前执行线程</strong>。</p><p><code>挂起函数</code>的运行可以被中止，运行<code>挂起函数</code>的线程可以去执行其他任务。</p><p><strong>挂起函数无法被其他常规函数调用！</strong></p></blockquote><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;  ...&#125;</code></pre><p>上述实例为<code>挂起函数</code>。</p><p>当<code>挂起函数</code>在一个协程中被调用时，该挂起函数内部会增加一个参数<code>Continuation</code>，类似下面的代码</p><pre><code class="hljs java"><span class="hljs-function">fun <span class="hljs-title">test</span><span class="hljs-params">(contimuation:Continuation)</span></span>&#123;  ...&#125;</code></pre><p>这种转换被称为<strong>CPS（续体传递风格）</strong>，每个<code>挂起函数</code>或<code>挂起Lambda表达式</code>都会附加一个<code>Continuation</code>参数，在外界调用<code>挂起函数</code>时隐式入参。 </p><h2 id="协程的原理"><a href="#协程的原理" class="headerlink" title="协程的原理"></a>协程的原理</h2><p>上述的基础概念已基本涵盖协程的整套执行流程，后面会在<a href="/2020/09/04/Kotlin协程原理/" title="Kotlin协程原理">Kotlin协程原理</a> 串联整体流程。</p><h2 id="协程在Android中的应用"><a href="#协程在Android中的应用" class="headerlink" title="协程在Android中的应用"></a>协程在Android中的应用</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="CPU上下文"><a href="#CPU上下文" class="headerlink" title="CPU上下文"></a>CPU上下文</h3><blockquote><p><strong>CPU寄存器和程序计数器</strong>，这两者都是CPU在运行任务前，都必须的依赖环境。</p><p><code>CPU寄存器</code>：CPU内置的容量小、但速度极快的内存</p><p><code>程序计数器</code>：存储CPU正在执行的指令位置，或即将执行的下一条指令位置</p></blockquote><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><blockquote><p>把前一个任务的<code>CPU上下文</code>保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后在跳转到程序计数器所指的新位置，运行新任务。</p><p>被保存的上下文会存储到<em>系统内核</em>中，在任务被重新调度时重新加载。</p></blockquote><h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><blockquote><p>从一个进程切换到另一个进程运行。</p></blockquote><p>进程的运行空间分为：</p><ul><li><code>内核空间</code>：具有最高权限，可以访问进程间的所有资源。（进程运行其中称为<strong>内核态</strong>。）</li><li><code>用户空间</code>：只能访问受限资源，不能直接访问内存等硬件设备，必须通过<strong>系统调用</strong>陷入到内核中，才能访问所有资源。（进程运行其中为<strong>用户态</strong>。）</li></ul><p><code>系统调用(system-call)</code>：进程从<code>用户态</code>到<code>内核态</code>的转变，需要通过<code>系统调用</code>实现。过程如下：</p><ul><li>保存CPU寄存器里原来用户态的指令位</li><li>为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置</li><li>跳转到内核态执行内核任务</li><li>系统调用结束后，CPU寄存器需要回复到原来保存的用户态，然后再切换到用户空间，继续运行线程。</li></ul><p><code>系统调用</code>过程中，总共发生了<code>两次CPU上下文切换</code>(用户态-&gt;内核态-&gt;用户态)。</p><h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><blockquote><p>从一个线程切换到另一个线程执行。</p></blockquote><p><strong>线程时调度的基本单位，进程这是资源拥有的基本单位。</strong>内核中的任务调度，实际调度对象为线程；进程只是给线程提供了<code>虚拟内存、全局变量</code>等资源。</p><p>线程发生上下文切换时，还需要保存线程所拥有的私有数据，例如栈、寄存器等。</p><p>线程上下文切换场景：</p><ul><li>切换的线程不处于同一进程中，因为资源不共享，执行的流程同<code>进程上下文切换</code>。</li><li>切换的线程处于同一进程中，资源是共享的，公共资源就不需要进行切换，只要切换线程的私有数据。</li></ul><h4 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h4><blockquote><p>中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。打断进程时，只需要保留当前进程的运行状态，中断执行结束后，继续从愿状态运行。</p></blockquote><p>中断上下文切换不涉及进程的用户态，在中断触发时，只需要保存内核态中断服务程序所必需的状态。例如<code>CPU寄存器、内核堆栈、硬件中断参数等</code>。</p><p><strong>中断上下文切换比进程上下文切换拥有更高的优先级，两者不会在同一CPU上同时发生。</strong></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/6844903858368413704" target="_blank" rel="noopener">viewModelScope简易介绍</a></p><p><a href="https://blog.csdn.net/weixin_42063726/article/details/106198068" target="_blank" rel="noopener">Kotlin-调度器介绍</a></p><p><a href="https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html" target="_blank" rel="noopener">协程官方文档</a></p><p><a href="http://zhoukaibo.com/2019/03/16/java-spi-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/" target="_blank" rel="noopener">SPI机制</a></p><p><a href="https://github.com/Kotlin-zh/KEEP/blob/master/proposals/coroutines.md" target="_blank" rel="noopener">Kotlin协程设计思路</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652055127&amp;idx=2&amp;sn=283de8250bfc8a7bd8287a7aadad1339&amp;chksm=808c8612b7fb0f047702c2101d27f4de42363ae5dd462be977ec897c7ae6a36e57b94675750a&amp;scene=178#rd" target="_blank" rel="noopener">揭秘suspend修饰符</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter学习大纲</title>
    <link href="/2019/04/01/Flutter%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    <url>/2019/04/01/Flutter%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Flutter</code>是Google全新推出的跨平台应用开发框架，主打<strong>跨平台、高保真、高性能</strong>，需要通过<code>Dart</code>语言进行开发App，编写完成后即可实现 <em>一套代码运行多个平台</em>，目前只是支持了<code>Android及iOS</code>平台，后续还会拓展到PC上。</p></blockquote><p>整套学习大纲会按照由表及里，由简到难的过程进行深入的学习<code>Flutter</code>。</p><ul><li style="list-style: none"><input type="checkbox"> 搭建开发环境 </li><li style="list-style: none"><input type="checkbox"> 新建一个Flutter应用</li><li style="list-style: none"><input type="checkbox"> <strong>Dart语言相关</strong></li><li style="list-style: none"><input type="checkbox"> 基础部件</li><li style="list-style: none"><input type="checkbox"> <strong>Widget</strong></li><li style="list-style: none"><input type="checkbox"> 自定义Widget</li><li style="list-style: none"><input type="checkbox"> 事件处理与通知</li><li style="list-style: none"><input type="checkbox"> 文件操作与网络请求</li><li style="list-style: none"><input type="checkbox"> Flutter插件</li><li style="list-style: none"><input type="checkbox"> <strong>Flutter性能优化</strong></li><li style="list-style: none"><input type="checkbox"> Flutter与Native的通信</li><li style="list-style: none"><input type="checkbox"> <strong>Flutter布局原理</strong></li><li style="list-style: none"><input type="checkbox"> <strong>Flutter界面绘制原理</strong></li><li style="list-style: none"><input type="checkbox"> <strong>Flutter运行机制</strong></li><li style="list-style: none"><input type="checkbox"> <strong>Flutter初始化流程</strong></li></ul><p>上述章节的学习会在实现一个完整的App基础上进行，<strong>学以致用</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang学习笔记-基本概念</title>
    <link href="/2019/03/28/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/03/28/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Golang环境"><a href="#安装Golang环境" class="headerlink" title="安装Golang环境"></a>安装Golang环境</h2><p>通过<code>brew install go</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件间通信——LiveDataBus</title>
    <link href="/2019/03/21/%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94LiveDataBus/"/>
    <url>/2019/03/21/%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94LiveDataBus/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>LiveData</code>是一个可以被观察的数据持有类，可以感知并遵循<code>Activity、Fragment，Service</code>等组件的生命周期。由于这种特性可以使他做到在特定生命周期执行特定的操作。</p></blockquote><p><code>LiveData</code>优点：</p><ul><li><strong>UI和实时数据保持一致</strong>：可以在数据发生改变时立即响应到</li><li><strong>避免内存泄漏</strong>：当绑定的组件被销毁时，会自动清理数据以及移除引用，避免泄漏</li></ul><p>根据上述优点，就可以利用<code>LiveData</code>去实现一个组件间通信的方案，这套方案相对于<code>EventBus</code>、<code>RxBus</code>有着明显的优势，不需要显式的去调用反注册方法(<em>以免内存泄漏</em>)，而且其自带生命周期感知，可以在Activity等组件处于前台状态时，进行UI更改，避免浪费资源。</p><h2 id="LiveDataBus的组成"><a href="#LiveDataBus的组成" class="headerlink" title="LiveDataBus的组成"></a>LiveDataBus的组成</h2><ul><li><strong>消息</strong>：用于在组件中通信所传递的数据，可能是基本类型也可能是自定义Model</li><li><strong>消息通道</strong>：用消息通道来甄别不同的LiveData(<em>处理对象</em>)</li><li><strong>订阅者</strong>：通过消息通道获取对应的<code>LiveData</code>，调用<code>observe()</code>进行订阅</li><li><strong>发布者</strong>：通过消息通道获取对应的<code>LiveData</code>，调用<code>postValue()、setValue()</code>进行消息发送</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/LiveDataBus结构.png" srcset="/img/loading.gif" class="full-image" alt="LiveDataBus结构" title="LiveDataBus结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="LiveDataBus的实现"><a href="#LiveDataBus的实现" class="headerlink" title="LiveDataBus的实现"></a>LiveDataBus的实现</h2><p>按照上述结构图，可以马上就写出一个大致结构</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiveDataBus</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>() &#123;    <span class="hljs-comment">//用于存放消息通道</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> map: MutableMap&lt;String, MutableLiveData&lt;Any&gt;?&gt;    <span class="hljs-keyword">init</span> &#123;        map = HashMap()    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">getChannel</span><span class="hljs-params">(target: <span class="hljs-type">String</span>, type: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: MutableLiveData&lt;T&gt; &#123;        <span class="hljs-keyword">if</span> (!map.containsKey(target)) &#123;            map[target] = MutableLiveData()        &#125;        <span class="hljs-keyword">return</span> map[target] <span class="hljs-keyword">as</span> MutableLiveData&lt;T&gt;    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getChannel</span><span class="hljs-params">(target: <span class="hljs-type">String</span>)</span></span>: MutableLiveData&lt;Any&gt; &#123;        <span class="hljs-keyword">return</span> getChannel(target, Any::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>    &#125;    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;        <span class="hljs-keyword">val</span> instance: LiveDataBus <span class="hljs-keyword">by</span> lazy &#123; LiveDataBus() &#125;    &#125;&#125;</code></pre><p>对应发送数据方法</p><pre><code class="hljs kotlin"><span class="hljs-comment">//同步发送</span>LiveDataBus.instance.getChannel(<span class="hljs-string">"web"</span>, String::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>).<span class="hljs-title">value</span> = "<span class="hljs-title">ssa</span>"</span><span class="hljs-comment">//异步发送</span>LiveDataBus.instance.getChannel(<span class="hljs-string">"web"</span>,String::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>).<span class="hljs-title">postValue</span></span>(<span class="hljs-string">"ssa"</span>)</code></pre><p>对应接收数据方法</p><pre><code class="hljs kotlin">LiveDataBus.instance.getChannel(<span class="hljs-string">"web"</span>, String::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>           .observe(<span class="hljs-keyword">this</span><span class="hljs-symbol">@MainActivity</span>, Observer &#123; s -&gt;                Log.e(<span class="hljs-string">"web"</span>, s)           &#125;)</code></pre><p>但是在实际的使用过程中发现了另一个问题，再打开一个新页面时，如果也存在监听者，就会收到该页面打开前所发送的消息，类似<em>粘性事件</em>，但大部分场景下是不需要这样的，所以需要针对这个问题进行改进。</p><h2 id="LiveDataBus改进"><a href="#LiveDataBus改进" class="headerlink" title="LiveDataBus改进"></a>LiveDataBus改进</h2><p>根据这部分源码分析可知，LiveData中的数据分发流程如下图所示：</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/LiveData-dispatch.png" srcset="/img/loading.gif" class="full-image" alt="LiveData Dispatch" title="LiveData Dispatch"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据上述流程分析：调用到<code>setValue()/postValue()</code>将用户数据进行发送，然后进入到<code>dispatchValue()</code>下进行分发，设置<code>mVersion++(mVersion表示调用方法次数)</code>，想下调用到<code>considerNotify()</code>内部需要判断<code>observer.mLastVersion(Observer注册次数)</code>与<code>mVersion</code>大小，如果小于就会调用到对应<code>Observer.onChanged()</code>事件进行分发。</p><p><em>由于初始化时，先会调用到<code>postValue()/setValue()</code>此时mVersion+1，就比<code>mLastVersion</code>要大，就会触发事件的分发。</em></p><h3 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h3><p><strong>只要可以设置<code>mLastVersion</code>与<code>mVersion</code>保持一致，就不会进行事件的分发。</strong></p><p>此时需要利用<strong>反射</strong>的方式对<code>LiveData</code>中的数据进行改变，首先按照需求，先要找到<code>Observer</code>，然后修改其中的<code>mLastVersion</code>即可。</p><pre><code class="hljs java"><span class="hljs-meta">@MainThread</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">observe</span><span class="hljs-params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;       <span class="hljs-keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;           <span class="hljs-comment">// ignore</span>           <span class="hljs-keyword">return</span>;       &#125;       LifecycleBoundObserver wrapper = <span class="hljs-keyword">new</span> LifecycleBoundObserver(owner, observer);       <span class="hljs-comment">//存储所有的Observer对象</span>       ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);       <span class="hljs-keyword">if</span> (existing != <span class="hljs-keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot add the same observer"</span>                   + <span class="hljs-string">" with different lifecycles"</span>);       &#125;       <span class="hljs-keyword">if</span> (existing != <span class="hljs-keyword">null</span>) &#123;           <span class="hljs-keyword">return</span>;       &#125;       owner.getLifecycle().addObserver(wrapper);   &#125;</code></pre><p>需要从<code>mObservers</code>中入手，然后找到对应<code>Observer</code>即可。</p><blockquote><p>除了<code>observer()</code>外，还有一个<code>observerForever()</code>，该方法是一直存在监听的，而且不会绑定对应的组件，所以可以在任意组件中监听到事件，如果使用时，需要注意销毁。</p></blockquote><h3 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h3><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.wxy.router.eventbus.utils<span class="hljs-keyword">import</span> android.arch.lifecycle.LifecycleOwner<span class="hljs-keyword">import</span> android.arch.lifecycle.LiveData<span class="hljs-keyword">import</span> android.arch.lifecycle.MutableLiveData<span class="hljs-keyword">import</span> android.arch.lifecycle.Observer<span class="hljs-keyword">import</span> android.icu.lang.UCharacter.GraphemeClusterBreak.T<span class="hljs-keyword">import</span> java.lang.Exception<span class="hljs-keyword">import</span> java.lang.NullPointerException<span class="hljs-keyword">import</span> java.util.*<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiveDataBus</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>() &#123;    <span class="hljs-comment">//用于存放消息通道</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> map: MutableMap&lt;String, BusMutableLiveData&lt;Any&gt;?&gt;    <span class="hljs-keyword">init</span> &#123;        map = HashMap()    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">getChannel</span><span class="hljs-params">(target: <span class="hljs-type">String</span>, type: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: BusMutableLiveData&lt;T&gt; &#123;        <span class="hljs-keyword">if</span> (!map.containsKey(target)) &#123;            map[target] = BusMutableLiveData()        &#125;        <span class="hljs-keyword">return</span> map[target] <span class="hljs-keyword">as</span> BusMutableLiveData&lt;T&gt;    &#125;    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getChannel</span><span class="hljs-params">(target: <span class="hljs-type">String</span>)</span></span>: BusMutableLiveData&lt;Any&gt; &#123;        <span class="hljs-keyword">return</span> getChannel(target, Any::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>    &#125;    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;        <span class="hljs-keyword">val</span> instance: LiveDataBus <span class="hljs-keyword">by</span> lazy &#123; LiveDataBus() &#125;    &#125;    <span class="hljs-comment">//Observer装饰类</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverWrapper</span>&lt;<span class="hljs-type">T</span>&gt;</span>() : Observer&lt;T&gt; &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> observer: Observer&lt;T&gt;? = <span class="hljs-literal">null</span>        <span class="hljs-keyword">constructor</span>(observer: Observer&lt;T&gt;) : <span class="hljs-keyword">this</span>() &#123;            <span class="hljs-keyword">this</span>.observer = observer        &#125;        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(t: <span class="hljs-type">T</span>?)</span></span> &#123;            observer?.let &#123;                <span class="hljs-keyword">if</span> (isCallOnObserve()) <span class="hljs-keyword">return</span><span class="hljs-symbol">@let</span>                it.onChanged(t)            &#125;        &#125;        <span class="hljs-comment">//判断当前 Observer类型是否为永久存在，如果是则不予处理</span>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isCallOnObserve</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;            <span class="hljs-keyword">val</span> stackTrace = Thread.currentThread().stackTrace            <span class="hljs-keyword">if</span> (stackTrace.isNotEmpty()) &#123;                stackTrace.forEach &#123; stackTraceElement -&gt;                    <span class="hljs-keyword">if</span> (<span class="hljs-string">"android.arch.lifecycle.LiveData"</span> == stackTraceElement.className &amp;&amp;                        <span class="hljs-string">"observeForever"</span> == stackTraceElement.methodName                    ) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>                    &#125;                &#125;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusMutableLiveData</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">MutableLiveData</span>&lt;<span class="hljs-type">T</span>&gt;</span>() &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> observerMap: MutableMap&lt;Observer&lt;T&gt;, Observer&lt;T&gt;&gt; = hashMapOf()        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">observe</span><span class="hljs-params">(owner: <span class="hljs-type">LifecycleOwner</span>, observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;            <span class="hljs-keyword">super</span>.observe(owner, observer)            <span class="hljs-keyword">try</span> &#123;                hook(observer)            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;                e.printStackTrace()            &#125;        &#125;        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">observeForever</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;            <span class="hljs-keyword">if</span> (!observerMap.containsKey(observer)) &#123;                observerMap[observer] = LiveDataBus.ObserverWrapper(observer)            &#125;            <span class="hljs-keyword">super</span>.observeForever(observer)        &#125;                <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;            <span class="hljs-keyword">val</span> realObserver: Observer&lt;T&gt;? = <span class="hljs-keyword">if</span> (observerMap.containsKey(observer)) &#123;                observerMap.remove(observer)            &#125; <span class="hljs-keyword">else</span> &#123;                observer            &#125;            realObserver?.let &#123; <span class="hljs-keyword">super</span>.removeObserver(it) &#125;        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hook</span><span class="hljs-params">(observer: <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">val</span> classLiveData = LiveData::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span></span>                <span class="hljs-comment">//获取LiveData中的 mObservers 对象</span>                <span class="hljs-keyword">val</span> fieldObservers = classLiveData.getDeclaredField(<span class="hljs-string">"mObservers"</span>)                fieldObservers.isAccessible = <span class="hljs-literal">true</span>                <span class="hljs-keyword">val</span> objectObservers = fieldObservers.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>)                <span class="hljs-keyword">val</span> classObservers = objectObservers.javaClass                <span class="hljs-keyword">val</span> methodGet = classObservers.getDeclaredMethod(<span class="hljs-string">"get"</span>, Object::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>                methodGet.isAccessible = <span class="hljs-literal">true</span>                <span class="hljs-keyword">val</span> objectWrapperEntry = methodGet.invoke(objectObservers, observer)                <span class="hljs-keyword">var</span> objectWrapper: Any? = <span class="hljs-literal">null</span>                <span class="hljs-keyword">if</span> (objectWrapperEntry <span class="hljs-keyword">is</span> Map.Entry&lt;*, *&gt;) &#123;                    objectWrapper = objectWrapperEntry.value                &#125;                <span class="hljs-keyword">if</span> (objectWrapper == <span class="hljs-literal">null</span>)                    <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"wrapper can not be null"</span>)                <span class="hljs-comment">//获取对应Observer对象</span>                <span class="hljs-keyword">val</span> classObserverWrapper = objectWrapper.javaClass.superclass                <span class="hljs-comment">//获取其中 mLastVersion数据</span>                <span class="hljs-keyword">val</span> fieldLastVersion = classObserverWrapper.getDeclaredField(<span class="hljs-string">"mLastVersion"</span>)                fieldLastVersion.isAccessible = <span class="hljs-literal">true</span>                <span class="hljs-comment">//获取其中mVersion数据</span>                <span class="hljs-keyword">val</span> fieldVersion = classLiveData.getDeclaredField(<span class="hljs-string">"mVersion"</span>)                fieldVersion.isAccessible = <span class="hljs-literal">true</span>                <span class="hljs-keyword">val</span> objectVersion = fieldVersion.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>)                <span class="hljs-comment">//重新赋值 使两者相等则事件不会进行分发</span>                fieldLastVersion.<span class="hljs-keyword">set</span>(objectWrapper, objectVersion)            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;                e.printStackTrace()            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的锁事</title>
    <link href="/2019/03/15/Java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8B/"/>
    <url>/2019/03/15/Java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p>Java中提供了种类丰富的锁，定义这些锁可以在适当的场景中发挥更好的作用。</p><h2 id="乐观锁-amp-悲观锁"><a href="#乐观锁-amp-悲观锁" class="headerlink" title="乐观锁&amp;悲观锁"></a>乐观锁&amp;悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote><p>每次去拿取数据的时候认为不会有人进行修改，所以不会去添加锁。只是会在更新数据时去判断是否有其他线程对这个数据进行了修改。通过判断<strong>版本号</strong>检测是否发生了更新，未发生变化直接写入新数据；发生了变化，就需要重复执行<strong>‌读版本号-比较有无发生变化-写入新数据</strong>操作。<br>在Java中一般通过<code>CAS算法</code>实现。例如<code>Atomic*</code>类内部都是通过<code>CAS</code>实现的。<br>乐观锁适合<strong>读操作多</strong>的场景，不加锁可以大大提升读操作的效率。</p></blockquote><h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h4><blockquote><p><code>compare and swap(比较与交换)</code>，是一种无锁算法(<em>在不使用锁的情况下实现线程间的变量同步</em>)。</p></blockquote><p><code>CAS算法</code>涉及了三个操作数：</p><ul><li>需要读写的内存值 <strong>V</strong></li><li>进行比较的值 <strong>A</strong></li><li>要写入的新值 <strong>B</strong></li></ul><p><strong>当且仅当V的值等于A时，CAS通过原子方式更新V的值为B。否则不会执行任何操作(<code>比较与更新为一个原子操作</code>)，一般情况下为一个<code>自旋操作</code>，需要不断进行重试。</strong></p><h4 id="乐观锁缺点"><a href="#乐观锁缺点" class="headerlink" title="乐观锁缺点"></a>乐观锁缺点</h4><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p><code>CAS</code>需要在操作值的时候检查内存值是否发生了变化，没有发生变化才会去更新值。但有一种特殊情况，内存中的值发生了<code>A-&gt;B-&gt;A</code>这类变化，在检查时得到的结果就是没有发生变化，这显然是不合理的。</p><p>解决该问题的方法有两种：</p><ul><li>通过在变量前面添加版本号，每次变量更新时进行版本号增加操作，可以保证监听到值的变化</li><li>通过<code>AtomicStampedReference</code>类解决，需要检查当前引用与预期引用，当前标记与预期标记是否相同，相同则更新。</li></ul><h5 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h5><p><code>CAS</code>操作不成功时，默认会进行自旋操作(<em>直到成功为止</em>)，会一直占用CPU资源造成极大的消耗。</p><p>可以通过<code>处理器的pause指令</code>进行解决。</p><blockquote><p><code>pause指令</code>有两个作用：</p><ul><li>延迟流水线执行</li><li>避免退出循环时因为内存顺序冲突引起CPU流水线被清空</li></ul></blockquote><h5 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h5><p><code>CAS</code>只对单个变量有效，无法对多个变量同时生效。</p><p>可以通过<code>AtomicReference</code>来保证引用对象之间的原子性，把多个变量放于同一个对象里进行CAS操作。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><blockquote><p>每次去拿取数据的时候都认为别人会进行修改，所以每次在拿数据的时候都会进行上锁操作，确保数据不会被其他线程修改。在其他线程想要操作该数据时，就会被<strong>阻塞</strong>直到得到锁(<em>共享资源每次只给一个线程使用，其他线程被阻塞，等到当前线程使用完毕后，其他线程才可以获取锁</em>)。</p><p>可以通过<code>Thread.holdsLock()</code>来获取当前线程是否持有锁。</p></blockquote><p>悲观锁适合<strong>写操作多</strong>的场景，可以保证进行写操作时的数据正确。</p><p>其中Java中的<code>synchronized</code>及<code>Lock</code>就是悲观锁的具体实现。</p><h2 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h2><p>在JVM中锁的状态分为四种：</p><ul><li>无锁：例如CAS操作</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁：<code>synchronized</code></li></ul><p>锁的进化状态为：<strong>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</strong>。<code>不可退化</code></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><blockquote><p>锁的每个状态都是有标记的，他们都存储于<strong>对象头的Mark Word</strong>中。</p></blockquote><p>对象头分为两部分：<code>Mark Word</code>、<code>Klass Pointer</code></p><p><code>Mark Word</code>：存储对象的HashCode，分代年龄、线程ID以及锁标志信息。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/MarkWord.png" srcset="/img/loading.gif" class="full-image" alt="Mark Word" title="Mark Word"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>其中四种锁状态主要对应在锁标志位上</p><table><thead><tr><th>锁状态</th><th>锁标志</th><th>存储内容</th></tr></thead><tbody><tr><td>无锁</td><td>01</td><td>对象的HashCode、分代年龄、是否是偏向锁(0)</td></tr><tr><td>偏向锁</td><td>01</td><td>偏向线程ID、偏向时间戳、分代年龄，是否是偏向锁(1)</td></tr><tr><td>轻量级锁</td><td>00</td><td>指向栈中锁记录的指针</td></tr><tr><td>重量级锁</td><td>10</td><td>指向互斥量(重量级锁)的指针</td></tr></tbody></table><p><code>Klass Pointer</code>：对象指向它的类元数据指针，虚拟机通过该指针确定实例。</p><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><blockquote><p>不会对资源进行锁定，所有线程都能访问并修改同一个资源，但是只能有一个线程修改成功在同一时间内。</p></blockquote><p>无锁的特点就是修改操作在循环中进行，线程会不断的去尝试修改共享资源。如果修改成功就直接退出，否则继续循环尝试。</p><p><strong>在已存在线程修改共享资源时，其他线程会进入自旋状态直至修改成功。</strong></p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><blockquote><p>如果持有锁的线程能在很短的时间内就释放锁，其他需要等待竞争锁的线程就不需要在<strong>内核态和用户态</strong>之间进行切换，导致进入阻塞状态，其他线程只有执行<strong>自旋</strong>，等待执行操作的线程释放锁之后就可以去直接获取锁，避免线程切换的开销。</p></blockquote><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>自旋锁尽可能的减少<strong>阻塞</strong>发生，对于<code>锁的竞争不激烈且不会占用锁事件过长的操作</code>性能提升明显，自旋的消耗相对线程的切换小很多。在线程阻塞和唤醒的过程中会发生两次<em>上下文切换</em>过程。</p><blockquote><p>上下文切换：当CPU执行从一个线程切换到另一个线程时，需要先存储当前线程的本地数据、程序指针等。然后载入另一线程的本地数据、程序指针等，然后开始执行另一个线程。</p></blockquote><p>自旋锁本身是有缺点的，无法代替<strong>阻塞</strong>功能。自旋虽然避免了线程切换的开销，但是需要占用CPU。如果锁被占用的时间很短，自旋锁的效果就会非常好。</p><p>但是，如果锁被占用的时间很长，其他自旋等待的线程就会一直占用CPU资源，导致极大的浪费。这时就需要去关闭自旋锁。</p><p><em>默认设置自旋次数超过10次<code>-XX:PreBlockSpin进行修改</code>就会自动关闭并挂起当前线程。</em></p><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><blockquote><p>在1.6之前，自旋次数上限是写死的，在1.6之后引入了<code>自适应自旋锁</code>，意味着自旋上限不再是固定的，而是根据 <strong>上一次同一个锁上的自旋时间以及锁拥有者的状态进行决定的</strong>。</p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><blockquote><p>一段同步代码一直被同一个线程访问，那么该线程自动获取锁，降低获取锁的代价。</p></blockquote><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>始终只有一个线程在执行同步代码块，即使没有执行完，也不会有其他线程去执行同步代码块。<strong>为了在只有一个线程执行同步代码块时提高性能。</strong></p><p>在高并发场景下会直接禁用偏向锁，通过设置<code>-XX:-UseBiasedLocking</code>。关闭后，会进入<strong>轻量级锁</strong>。</p><h4 id="获取过程"><a href="#获取过程" class="headerlink" title="获取过程"></a>获取过程</h4><ol><li>当线程访问同步块代码并获取锁时，会在<code>Mark Word</code>中存入当前线程的ID并设置偏向锁标识为1</li><li>再次有线程访问该代码块时，先去判断<code>Mark Word</code>中偏向锁标识是否为1且线程ID是否一致</li><li>若一致，则执行同步代码</li><li>不一致时，需要通过<code>CAS</code>去获取锁，如果竞争成功，修改<code>Mark Word</code>中的线程ID为当前线程</li><li>若竞争失败，说明当前还有其他线程在竞争锁。那么就需要释放偏向锁。</li></ol><h4 id="释放过程"><a href="#释放过程" class="headerlink" title="释放过程"></a>释放过程</h4><p>偏向锁只有遇到其他线程竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。</p><p>偏向锁的释放，需要等待<strong>全局安全点(safe-point)-当前时间点没有字节码在执行</strong>，会首先暂停拥有偏向锁的线程，并判断该锁对象是否处于被锁定状态。</p><p>释放偏向锁后恢复<strong>无锁</strong>状态或进化到<strong>轻量级锁(标记00)</strong>状态。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><blockquote><p>轻量级锁是由偏向锁升级来的，当偏向锁被另一个线程访问时，偏向锁就会升级为轻量锁。</p><p>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。<strong>轻量级锁并不是用来替代传统重量级锁。</strong></p></blockquote><h4 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h4><ol><li>代码进入同步块的时候，如果同步对象锁状态为无锁状态(标志位01，是否为偏向锁0)，在当前线程的栈帧中建立一个<code>Lock record</code>用于存储<code>Mark Word</code>，名为<code>Displaced Mark Word</code>。</li><li>拷贝当前线程对象头的<code>Mark Word</code>到<code>Lock Record</code>中</li><li>拷贝成功后，虚拟机使用<code>CAS</code>操作尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>指针，并将<code>Lock Record</code>指针指向<code>Mark Word</code></li><li>更新成功，该线程就拥有了对象的锁，并且设置<code>Mark Word</code>的锁标志位为<code>00</code>，表明当前处于轻量级锁定状态。</li></ol><blockquote><p>如果更新失败，虚拟机首先检查<code>Mark Word</code>。</p></blockquote><h4 id="释放锁过程"><a href="#释放锁过程" class="headerlink" title="释放锁过程"></a>释放锁过程</h4><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><h2 id="其他锁分类"><a href="#其他锁分类" class="headerlink" title="其他锁分类"></a>其他锁分类</h2><h3 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁&amp;非公平锁"></a>公平锁&amp;非公平锁</h3><h3 id="可重入锁-amp-非重入锁"><a href="#可重入锁-amp-非重入锁" class="headerlink" title="可重入锁&amp;非重入锁"></a>可重入锁&amp;非重入锁</h3><h3 id="独占锁-amp-共享锁"><a href="#独占锁-amp-共享锁" class="headerlink" title="独占锁&amp;共享锁"></a>独占锁&amp;共享锁</h3><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote><p>两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们会互相阻塞。</p></blockquote><p>产生死锁的条件有4个：</p><ul><li>互斥条件：一个资源每次只能被一个线程占用</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件：线程已获得的资源，未使用完之前不得强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5c8a00e56fb9a049a42feb54#heading-21" target="_blank" rel="noopener">JAVA中锁的深入理解与解析</a></p><p><a href="https://juejin.im/post/5bee576fe51d45710c6a51e0#heading-2" target="_blank" rel="noopener">不可不说的Java“锁”事</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客导读</title>
    <link href="/2019/03/14/%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%AF%BB/"/>
    <url>/2019/03/14/%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对博客内的文章提供快速入口，按照分类进行查看。</p></blockquote><p>其中主要涉及了以下几大模块</p><h2 id="Android学习路线"><a href="#Android学习路线" class="headerlink" title="Android学习路线"></a>Android学习路线</h2><p><strong>Android高级进阶</strong> <a href="/2018/12/09/Android需要的必备知识/" title="Android需要的必备知识">Android需要的必备知识</a></p><h2 id="计算机网络相关"><a href="#计算机网络相关" class="headerlink" title="计算机网络相关"></a>计算机网络相关</h2><p><strong>HTTP的原理和工作机制</strong> <a href="/2020/03/29/HTTP的原理和工作机制/" title="HTTP的原理和工作机制">HTTP的原理和工作机制</a></p><p><strong>TCP/IP协议相关</strong> <a href="/2020/03/31/TCP-IP协议相关/" title="TCP/IP协议相关">TCP/IP协议相关</a></p><h2 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h2><p><strong>JVM相关合集整理</strong> <a href="/2020/05/02/JVM相关合集整理/" title="JVM相关合集整理">JVM相关合集整理</a></p><p><strong>JVM内存区域</strong> <a href="/2018/04/10/JVM相关及其拓展/" title="JVM相关及其拓展（一）-- JVM内存区域">JVM相关及其拓展（一）-- JVM内存区域</a></p><p><strong>类加载机制</strong> <a href="/2018/04/12/JVM相关及其拓展-二/" title="JVM相关及其拓展(二) -- 虚拟机类加载机制">JVM相关及其拓展(二) -- 虚拟机类加载机制</a></p><p>Java ClassLoader <a href="/2018/04/16/JVM相关及其拓展-三/" title="JVM相关及其拓展(三) -- 虚拟机类加载器">JVM相关及其拓展(三) -- 虚拟机类加载器</a></p><p><strong>GC相关</strong> <a href="/2018/05/04/JVM相关及其拓展-四/" title="JVM相关及其拓展(四) -- 垃圾收集器与内存分配策略">JVM相关及其拓展(四) -- 垃圾收集器与内存分配策略</a></p><p>Java内存模型 <a href="/2018/05/09/JVM相关及其拓展-五/" title="JVM相关及其拓展(五) -- Java内存模型">JVM相关及其拓展(五) -- Java内存模型</a></p><p><strong>Java线程</strong> <a href="/2018/12/18/JVM相关及其拓展-六/" title="JVM相关及其拓展(六) -- Java与线程">JVM相关及其拓展(六) -- Java与线程</a></p><p>线程安全与锁优化 <a href="/2018/12/19/JVM相关及其拓展-七/" title="JVM相关及其拓展(七) — 线程安全与锁优化">JVM相关及其拓展(七) — 线程安全与锁优化</a></p><p>静态与动态分派 <a href="/2019/02/21/JVM相关及其拓展-八/" title="JVM相关及其拓展(八) — 静态分派&动态分派">JVM相关及其拓展(八) — 静态分派&动态分派</a></p><h2 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h2><p><strong>Java线程相关合集整理</strong> <a href="/2020/05/02/Java线程相关合集整理/" title="Java线程相关合集整理">Java线程相关合集整理</a></p><p>基础知识 <a href="/2018/01/17/Java-基础知识/" title="Java基础知识">Java基础知识</a></p><p>引用类型 <a href="/2018/03/18/Android-Study-Plan-VIII/" title="Android Study Plan VIII - Java引用类型">Android Study Plan VIII - Java引用类型</a></p><p><strong>线程池</strong> <a href="/2019/09/13/Java-线程池/" title="Java-线程池">Java-线程池</a></p><p>CAS <a href="/2018/12/18/Atomic原子操作类分析/" title="CAS操作&Atomic原子操作类分析">CAS操作&Atomic原子操作类分析</a></p><p>BlockingQueue阻塞队列 <a href="/2018/12/24/Java-BockingQueue阻塞队列/" title="Java-BockingQueue阻塞队列">Java-BockingQueue阻塞队列</a> </p><p>ReentrantLock原理及解析<a href="/2018/12/19/Java-ReentrantLock原理及解析/" title="Java-ReentrantLock原理及解析">Java-ReentrantLock原理及解析</a>[待完成]</p><p>CountDownLatch原理及解析<a href="/2020/10/08/Java-CountDownLatch原理及解析/" title="Java-CountDownLatch原理及解析">Java-CountDownLatch原理及解析</a>[待完成]</p><p>AbstractQueuedSynchronizer原理及解析<a href="/2020/09/13/Java-AbstractQueuedSynchronizer简介/" title="Java-AbstractQueuedSynchronizer简介">Java-AbstractQueuedSynchronizer简介</a></p><p>Condition原理及解析<a href="/2020/10/08/Java-AQS-Condition原理及解析/" title="Java-AQS-Condition原理及解析">Java-AQS-Condition原理及解析</a>[待完成]</p><p>final <a href="/2019/02/26/final关键字/" title="final关键字">final关键字</a> [待完成]</p><p>static <a href="/2019/02/25/static关键字分析/" title="static关键字分析">static关键字分析</a></p><p><strong>synchronized</strong> </p><p><strong>volatile</strong> </p><p><strong>ThreadLocal原理分析</strong> <a href="/2018/12/09/ThreadLocal原理分析/" title="ThreadLocal原理分析">ThreadLocal原理分析</a></p><p><strong>Java-反射</strong> <a href="/2018/12/14/Java-反射/" title="Java - 反射">Java - 反射</a></p><p>Java-泛型 <a href="/2019/01/02/Java-泛型/" title="Java - 泛型">Java - 泛型</a></p><p>Java-注解 <a href="/2019/02/19/Java-注解/" title="Java - 注解">Java - 注解</a></p><p><strong>Java字节码学习</strong> <a href="/2019/09/24/Java字节码学习/" title="Java字节码学习">Java字节码学习</a></p><p><strong>Java字节码学习-操作指令</strong> <a href="/2019/11/14/Java字节码学习-操作指令/" title="Java字节码学习-操作指令">Java字节码学习-操作指令</a></p><p><strong>Java字节码学习-应用场景</strong> <a href="/2019/11/18/Java字节码学习-应用场景/" title="Java字节码学习-应用场景">Java字节码学习-应用场景</a></p><h2 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h2><p><strong>排序算法</strong> <a href="/2018/03/20/基础排序算法介绍/" title="基础排序算法介绍">基础排序算法介绍</a></p><p><strong>红黑树</strong> <a href="/2018/12/20/数据结构-红黑树/" title="数据结构-红黑树">数据结构-红黑树</a></p><p>链表 <a href="/2018/04/25/数据结构-链表/" title="数据结构-链表">数据结构-链表</a></p><p>树 <a href="/2018/06/03/数据结构-树/" title="数据结构-树">数据结构-树</a></p><p><strong>ArrayList</strong> <a href="/2019/01/15/ArrayList实现原理及简析/" title="数据结构--ArrayList实现原理及简析">数据结构--ArrayList实现原理及简析</a></p><p>Android-ArrayMap <a href="/2019/03/08/ArrayMap简析/" title="ArrayMap简析">ArrayMap简析</a></p><p>Android-SparseArray <a href="/2019/01/28/SparseArray分析/" title="SparseArray简析">SparseArray简析</a></p><p><strong>ConcurrentHashMap</strong> <a href="/2019/01/16/Java-ConcurrentHashMap原理及解析/" title="数据结构--ConcurrentHashMap原理及解析">数据结构--ConcurrentHashMap原理及解析</a></p><p>CopyOnWriteArrayList <a href="/2019/01/18/Java-CopyOnWriteArrayList实现原理及简析/" title="数据结构--CopyOnWriteArrayList实现原理及简析">数据结构--CopyOnWriteArrayList实现原理及简析</a></p><p><strong>HashMap</strong> <a href="/2018/05/09/HashMap实现原理及解析/" title="数据结构--HashMap实现原理及解析">数据结构--HashMap实现原理及解析</a></p><p>LinkedHashMap <a href="/2019/03/08/LinkedHashMap简析/" title="LinkedHashMap简析">LinkedHashMap简析</a> [待完成]</p><h2 id="Android源码相关"><a href="#Android源码相关" class="headerlink" title="Android源码相关"></a>Android源码相关</h2><p>Window相关 <a href="/2019/01/10/理解Window及WindowManager/" title="理解Window及WindowManager">理解Window及WindowManager</a></p><p><strong>WindowManagerService</strong> <a href="/2019/01/30/WindowManagerService简析/" title="WindowManagerService简析">WindowManagerService简析</a> [待完成]</p><p>Activity-Window-View </p><p>Activity生命周期及启动模式 <a href="/2019/01/04/Activity的生命周期和启动模式/" title="Activity的生命周期和启动模式">Activity的生命周期和启动模式</a></p><p><strong>Activity启动过程</strong> <a href="/2019/01/02/Activity启动过程/" title="Activity启动过程">Activity启动过程</a></p><p>Service工作过程 <a href="/2019/01/10/Service工作过程/" title="Service工作过程">Service工作过程</a></p><p>Android补间动画  <a href="/2018/06/11/Android-动画分析/" title="Android-动画分析">Android-动画分析</a></p><p>Android动画-属性动画 <a href="/2020/10/12/Android动画-属性动画/" title="Android动画-属性动画">Android动画-属性动画</a></p><p>Android-Drawable  <a href="/2019/01/10/Android-Drawable相关/" title="Android - Drawable相关">Android - Drawable相关</a></p><p>Android中的线程<code>AsyncTask、IntentService、HandlerThread</code> <a href="/2018/12/21/Android-线程相关/" title="Android-线程相关">Android-线程相关</a></p><p><strong>Android触摸事件</strong> <a href="/2018/04/09/Android触摸事件分发/" title="Android触摸事件分发">Android触摸事件分发</a></p><p><strong>Android中的IPC机制</strong> <a href="/2018/12/11/Binder及AIDL/" title="IPC机制">IPC机制</a></p><p><strong>Android-Binder</strong> <a href="/2019/01/06/Binder系列-Binder/" title="Binder系列-Binder">Binder系列-Binder</a></p><p><strong>Android-Handler</strong> <a href="/2018/05/14/Handler机制即源码解析/" title="Handler机制源码解析">Handler机制源码解析</a></p><p><strong>Handler拓展知识</strong> <a href="/2018/10/07/Handler机制源码解析-二/" title="Handler机制源码解析(二)">Handler机制源码解析(二)</a></p><p><strong>ListView</strong> <a href="/2019/01/04/ListView简析/" title="ListView简析">ListView简析</a></p><p><strong>RecyclerView</strong> <a href="/2018/12/20/RecycleView简析/" title="RecyclerView简析">RecyclerView简析</a></p><p>SharedPreferences简析 <a href="/2019/01/13/SharesPreference简析/" title="SharedPreferences简析">SharedPreferences简析</a></p><p><strong>View工作原理</strong> <a href="/2018/12/14/View的工作原理/" title="View的工作原理">View的工作原理</a></p><p><strong>View事件体系</strong> <a href="/2018/12/25/View的事件体系/" title="View的事件体系">View的事件体系</a></p><p><strong>View刷新机制</strong> <a href="/2020/05/30/View的刷新机制/" title="Android屏幕的刷新机制">Android屏幕的刷新机制</a></p><p><strong>Android Dex学习</strong> <a href="/2019/09/24/Android-Dex文件学习/" title="Android Dex文件学习">Android Dex文件学习</a></p><h2 id="Android三方库源码分析"><a href="#Android三方库源码分析" class="headerlink" title="Android三方库源码分析"></a>Android三方库源码分析</h2><p><strong>组件间通信</strong> <a href="/2019/03/21/组件间通信——LiveDataBus/" title="组件间通信——LiveDataBus">组件间通信——LiveDataBus</a></p><p>组件间跳转  <a href="/2018/12/24/Android-简单实现Router功能/" title="Android-简单实现Router功能">Android-简单实现Router功能</a>[待完成]</p><p><strong>LruCache</strong> <a href="/2018/12/14/LRUCache原理/" title="LruCache原理">LruCache原理</a></p><p>DiskLruCache <a href="/2018/12/17/DiskLruCache源码分析/" title="DiskLruCache源码分析">DiskLruCache源码分析</a>[待完成]</p><p><strong>Glide源码解析</strong> <a href="/2018/03/18/Glide源码解析要点/" title="Glide源码解析要点">Glide源码解析要点</a></p><p><strong>OkHttp源码解析</strong> <a href="/2019/03/08/OkHttp简析/" title="OkHttp简析">OkHttp简析</a></p><p><strong>RxJava源码解析</strong> <a href="/2019/01/10/RxJava-使用及解析/" title="RxJava 使用及解析">RxJava 使用及解析</a></p><p>AAC-Lifecycle <a href="/2019/02/15/Jetpack-Lifecycle简析/" title="Jetpack-Lifecycle简析">Jetpack-Lifecycle简析</a></p><p>AAC-LiveData <a href="/2019/02/15/Jetpack-LiveData简析/" title="Jetpack-LiveData简析">Jetpack-LiveData简析</a></p><p>AAC-ViewModel <a href="/2019/02/15/Jetpack-ViewModel简析/" title="Jetpack-ViewModel简析">Jetpack-ViewModel简析</a></p><h2 id="Android其他知识"><a href="#Android其他知识" class="headerlink" title="Android其他知识"></a>Android其他知识</h2><p><strong>计算机网络</strong> <a href="/2018/05/31/计算机网络基础/" title="计算机网络基础">计算机网络基础</a></p><p><strong>进程保活</strong> <a href="/2018/04/12/进程保活介绍/" title="进程保活介绍">进程保活介绍</a></p><p><strong>WebView相关知识</strong> <a href="/2019/03/12/WebView相关知识/" title="WebView相关知识">WebView相关知识</a></p><p><strong>热修复</strong> <a href="/2018/04/07/热修复基本原理及其实现/" title="热修复基本原理">热修复基本原理</a></p><p>插件化 <a href="/2019/02/05/插件化实现原理简析/" title="插件化实现原理简析(基础概念)">插件化实现原理简析(基础概念)</a></p><p>Hook技术 <a href="/2019/02/06/Hook技术简析/" title="Hook技术简析">Hook技术简析</a></p><p>自定义View <a href="/2019/01/02/自定义View实践/" title="自定义View实践">自定义View实践</a></p><p>自定义ViewGroup <a href="/2019/01/02/自定义ViewGroup实践/" title="自定义ViewGroup实践">自定义ViewGroup实践</a></p><p>组件化 <a href="/2019/02/27/组件化原理及实践/" title="组件化原理及实践">组件化原理及实践</a></p><p>Service基本使用 {}</p><p><strong>Android性能优化</strong> <a href="/2018/12/20/Android性能优化/" title="Android性能优化">Android性能优化</a></p><p><strong>Android布局优化</strong> <a href="/2019/01/03/include、merge-ViewStub相关/" title="include、merge及ViewStub相关">include、merge及ViewStub相关</a></p><p>Dalvik&amp;ART <a href="/2018/05/13/Android中的GC分析-Dalvik和ART虚拟机/" title="Android中的GC分析-Dalvik和ART虚拟机">Android中的GC分析-Dalvik和ART虚拟机</a></p><p><strong>ANR分析</strong> <a href="/2019/01/28/ANR分析/" title="ANR分析">ANR分析</a></p><p><strong>Bitmap分析</strong> <a href="/2019/01/28/Bitmap分析/" title="Bitmap分析">Bitmap分析</a></p><p>Fragment <a href="/2018/01/10/Fragment相关/" title="Fragment相关">Fragment相关</a></p><p>MVC、MVP、MVVM的选择 <a href="/2018/04/15/MVC-MVP-MVVM的理解/" title="MVC,MVP,MVVM的理解">MVC,MVP,MVVM的理解</a></p><h2 id="Kotlin学习笔记"><a href="#Kotlin学习笔记" class="headerlink" title="Kotlin学习笔记"></a>Kotlin学习笔记</h2><p>《Kotlin核心编程》读书笔记-基础语法 <a href="/2019/06/19/《Kotlin核心编程》读书笔记-基础语法/" title="《Kotlin核心编程》读书笔记-基础语法">《Kotlin核心编程》读书笔记-基础语法</a></p><p>《Kotlin核心编程》读书笔记-面向对象 <a href="/2019/06/23/《Kotlin核心编程》读书笔记-面向对象/" title="《Kotlin核心编程》读书笔记-面向对象">《Kotlin核心编程》读书笔记-面向对象</a></p><p>Kotlin-拓展函数[待完成]</p><p>Kotlin-协程及原理[待完成]  <a href="/2019/04/12/Kotlin协程体验/" title="Kotlin-协程">Kotlin-协程</a></p><p>Kotlin-委托相关知识[待完成] <a href="/2019/07/09/Kotlin-委托相关知识/" title="Kotlin-委托相关知识">Kotlin-委托相关知识</a></p><h2 id="算法题相关"><a href="#算法题相关" class="headerlink" title="算法题相关"></a>算法题相关</h2><p><strong>剑指Offer</strong> <a href="/2018/01/16/常见算法题整理/" title="常见算法题整理 - 来自《剑指Offer》">常见算法题整理 - 来自《剑指Offer》</a>[待完成]</p><p>位运算 <a href="/2018/12/27/位运算/" title="位运算">位运算</a>[待完成]</p><h2 id="设计模式相关"><a href="#设计模式相关" class="headerlink" title="设计模式相关"></a>设计模式相关</h2><p>基本原则 <a href="/2018/12/14/设计模式-基本原则/" title="设计模式--基本原则">设计模式--基本原则</a></p><p>单例模式 <a href="/2018/12/13/设计模式-单例模式/" title="设计模式--单例模式">设计模式--单例模式</a></p><p>工厂模式 <a href="/2019/02/11/设计模式-工厂模式/" title="设计模式-工厂模式">设计模式-工厂模式</a>[待完成]</p><p>代理模式 <a href="/2018/04/09/动态代理模式原理及实现/" title="设计模式--静态代理模式和动态代理模式原理及实现">设计模式--静态代理模式和动态代理模式原理及实现</a></p><p>责任链模式 <a href="/2019/01/11/设计模式-责任链模式/" title="设计模式--责任链模式">设计模式--责任链模式</a></p><p>装饰模式 <a href="/2019/01/11/设计模式-装饰模式/" title="设计模式--装饰模式">设计模式--装饰模式</a></p><h2 id="Gradle学习笔记"><a href="#Gradle学习笔记" class="headerlink" title="Gradle学习笔记"></a>Gradle学习笔记</h2><p><strong>Gradle相关</strong> <a href="/2018/04/03/Gradle操作小记/" title="Gradle操作小记">Gradle操作小记</a>[待完成]</p><p>Gradle学习笔记-Groovy <a href="/2019/04/23/Gradle学习笔记-Groovy/" title="Gradle学习笔记-Groovy基础">Gradle学习笔记-Groovy基础</a></p><p>Gradle学习笔记-Task <a href="/2019/05/08/Gradle学习笔记-Task/" title="Gradle学习笔记-Task">Gradle学习笔记-Task</a>[待完成]</p><p>Gradle学习笔记-Project <a href="/2019/06/14/Gradle学习笔记-Project/" title="Gradle学习笔记-Project">Gradle学习笔记-Project</a>[待完成]</p><p>Gradle学习笔记-自定义插件[待完成]</p><p>Gradle学习笔记-Android中的自定义插件[待完成]</p><h2 id="AOP学习笔记"><a href="#AOP学习笔记" class="headerlink" title="AOP学习笔记"></a>AOP学习笔记</h2><p>AOP学习笔记-基础概念[待完成]</p><p>AOP学习笔记-APT[待完成] 包含基础概念的理解以及实例代码</p><p>AOP学习笔记-AspectJ[待完成] 需要针对Kotlin对应的进行原理分析</p><p>AOP学习笔记-ASM[待完成] 与Gradle中的Transform协同使用</p><p>AOP学习笔记-AST[待完成]</p><h2 id="Flutter学习笔记"><a href="#Flutter学习笔记" class="headerlink" title="Flutter学习笔记"></a>Flutter学习笔记</h2><p>学习大纲 <a href="/2019/04/01/Flutter学习大纲/" title="Flutter学习大纲">Flutter学习大纲</a>[待完成]</p><h2 id="TypeScript学习笔记"><a href="#TypeScript学习笔记" class="headerlink" title="TypeScript学习笔记"></a>TypeScript学习笔记</h2>]]></content>
    
    
    
    <tags>
      
      <tag>目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebView相关知识</title>
    <link href="/2019/03/12/WebView%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2019/03/12/WebView%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<!--webview--><blockquote><p>WebView是一个基于WebKit引擎，展现Web页面的控件。</p><p>主要提供以下功能：</p><ul><li>显示和渲染Web页面</li><li>直接使用html文件做布局</li><li>可以和js进行交互</li></ul></blockquote><h2 id="WebView基本使用"><a href="#WebView基本使用" class="headerlink" title="WebView基本使用"></a>WebView基本使用</h2><h3 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.INTERNET"</span>/&gt;</span></code></pre><h3 id="生成一个WebView组件"><a href="#生成一个WebView组件" class="headerlink" title="生成一个WebView组件"></a>生成一个WebView组件</h3><p>直接引入</p><pre><code class="hljs java">WebView webView = <span class="hljs-keyword">new</span> WebView(<span class="hljs-keyword">this</span>);</code></pre><p>写在xml中引入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">WebView</span>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/wv"</span>    <span class="hljs-attr">android:width</span>=<span class="hljs-string">"match_parent"</span>    <span class="hljs-attr">android:height</span> = <span class="hljs-string">"match_parent"</span>      /&gt;</span>WebView webview = (WebView) findViewById(R.id.wv);</code></pre><h3 id="设置WebView基本信息"><a href="#设置WebView基本信息" class="headerlink" title="设置WebView基本信息"></a>设置WebView基本信息</h3><p>主要利用<code>WebSetting、WebViewClient，WebChromeClient</code></p><h4 id="WebSetting"><a href="#WebSetting" class="headerlink" title="WebSetting"></a><code>WebSetting</code></h4><blockquote><p>进行基本属性配置</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//声明WebSettings子类</span>WebSettings webSettings = webView.getSettings();<span class="hljs-comment">//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript</span>webSettings.setJavaScriptEnabled(<span class="hljs-keyword">true</span>);  <span class="hljs-comment">//支持插件</span>webSettings.setPluginsEnabled(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//设置自适应屏幕，两者合用</span>webSettings.setUseWideViewPort(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//将图片调整到适合webview的大小 </span>webSettings.setLoadWithOverviewMode(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 缩放至屏幕的大小</span><span class="hljs-comment">//缩放操作</span>webSettings.setSupportZoom(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//支持缩放，默认为true。是下面那个的前提。</span>webSettings.setBuiltInZoomControls(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//设置内置的缩放控件。若为false，则该WebView不可缩放</span>webSettings.setDisplayZoomControls(<span class="hljs-keyword">false</span>); <span class="hljs-comment">//隐藏原生的缩放控件</span><span class="hljs-comment">//其他细节操作</span>webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); <span class="hljs-comment">//关闭webview中缓存 </span>webSettings.setAllowFileAccess(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//设置可以访问文件 </span>webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//支持通过JS打开新窗口 </span>webSettings.setLoadsImagesAutomatically(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//支持自动加载图片</span>webSettings.setDefaultTextEncodingName(<span class="hljs-string">"utf-8"</span>);<span class="hljs-comment">//设置编码格式</span></code></pre><h4 id="WebViewClient"><a href="#WebViewClient" class="headerlink" title="WebViewClient"></a><code>WebViewClient</code></h4><blockquote><p>处理各种通知以及请求事件</p></blockquote><pre><code class="hljs java">webView.setWebViewClient(<span class="hljs-keyword">new</span> WebViewClient()&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldOverrideUrlLoading</span><span class="hljs-params">(WebView view, String url)</span> </span>&#123;①          view.loadUrl(url);          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">onPageStarted</span><span class="hljs-params">(WebView view, String url, Bitmap favicon)</span> </span>&#123;②               &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageFinished</span><span class="hljs-params">(WebView view, String url)</span> </span>&#123;③               &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLoadResource</span><span class="hljs-params">(WebView view, String url)</span> </span>&#123;④               &#125;    <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceivedError</span><span class="hljs-params">(WebView view, <span class="hljs-keyword">int</span> errorCode, String description, String failingUrl)</span></span>&#123;⑤<span class="hljs-comment">//errorCode表示了 加载错误对应的错误码</span>      &#125;    <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceivedSslError</span><span class="hljs-params">(WebView view, SslErrorHandler handler, SslError error)</span> </span>&#123;⑥       &#125;      &#125;);</code></pre><h5 id="shouldOverrideUrlLoading"><a href="#shouldOverrideUrlLoading" class="headerlink" title="shouldOverrideUrlLoading"></a><code>shouldOverrideUrlLoading</code></h5><blockquote><p>复写该方法，避免打开外部浏览器</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldOverrideUrlLoading</span><span class="hljs-params">(WebView view, String url)</span> </span>&#123;①          view.loadUrl(url);          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125;</code></pre><h5 id="onPageStarted"><a href="#onPageStarted" class="headerlink" title="onPageStarted"></a><code>onPageStarted</code></h5><blockquote><p>开始载入页面时回调该方法</p></blockquote><h5 id="onPageFinished"><a href="#onPageFinished" class="headerlink" title="onPageFinished"></a><code>onPageFinished</code></h5><blockquote><p>页面载入结束时回调该方法</p></blockquote><h5 id="onLoadResource"><a href="#onLoadResource" class="headerlink" title="onLoadResource"></a><code>onLoadResource</code></h5><blockquote><p>页面资源开始加载时调用，并且每次加载时都会调用</p></blockquote><h5 id="onReceivedError"><a href="#onReceivedError" class="headerlink" title="onReceivedError"></a><code>onReceivedError</code></h5><blockquote><p>加载页面出现错误时回调，可用于显示不同错误码的展示页面</p></blockquote><h5 id="onReceivedSslError"><a href="#onReceivedSslError" class="headerlink" title="onReceivedSslError"></a><code>onReceivedSslError</code></h5><blockquote><p>WebView默认是不处理HTTPs请求的，页面会显示空白</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceivedSslError</span><span class="hljs-params">(WebView view, SslErrorHandler handler, SslError error)</span> </span>&#123;          handler.proceed();    <span class="hljs-comment">//表示等待证书响应</span>   <span class="hljs-comment">// handler.cancel();      //表示挂起连接，为默认方式</span>   <span class="hljs-comment">// handler.handleMessage(null);    //可做其他处理</span>  &#125;</code></pre><h4 id="WebChromeClient"><a href="#WebChromeClient" class="headerlink" title="WebChromeClient"></a><code>WebChromeClient</code></h4><blockquote><p>辅助WebView处理js、网站标题等属性</p></blockquote><pre><code class="hljs java">webview.setWebChromeClient(<span class="hljs-keyword">new</span> WebChromeClient()&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgressChanged</span><span class="hljs-params">(WebView view, <span class="hljs-keyword">int</span> newProgress)</span> </span>&#123;①           <span class="hljs-comment">//newProgress 当前加载进度</span>      &#125;);     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceivedTitle</span><span class="hljs-params">(WebView view, String title)</span> </span>&#123;②         <span class="hljs-comment">//title 当前页面标题</span>    &#125;&#125;</code></pre><h5 id="onProgressChanged"><a href="#onProgressChanged" class="headerlink" title="onProgressChanged"></a><code>onProgressChanged</code></h5><blockquote><p>获得当前页面的加载进度</p></blockquote><h5 id="onReceivedTitle"><a href="#onReceivedTitle" class="headerlink" title="onReceivedTitle"></a><code>onReceivedTitle</code></h5><blockquote><p>获得当前页面的标题</p></blockquote><h3 id="设置WebView要显示的网页"><a href="#设置WebView要显示的网页" class="headerlink" title="设置WebView要显示的网页"></a>设置WebView要显示的网页</h3><pre><code class="hljs java"><span class="hljs-comment">//load本地</span>webView.loadUrl(<span class="hljs-string">"file:///android_asset/hellotest.html"</span>);<span class="hljs-comment">//load在线</span>webView.loadUrl(<span class="hljs-string">"http://www.google.com"</span>);</code></pre><h3 id="结束时销毁WebView"><a href="#结束时销毁WebView" class="headerlink" title="结束时销毁WebView"></a>结束时销毁WebView</h3><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (webView != <span class="hljs-keyword">null</span>) &#123;            webView.loadDataWithBaseURL(<span class="hljs-keyword">null</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"text/html"</span>, <span class="hljs-string">"utf-8"</span>, <span class="hljs-keyword">null</span>);            webView.clearHistory();            ((ViewGroup) webView.getParent()).removeView(webView);            webView.destroy();            webView = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">super</span>.onDestroy();    &#125;</code></pre><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>前进/后退网页</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onKeyDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;    <span class="hljs-keyword">if</span> (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; webView.canGoBack()) &#123;         webView.goBack();<span class="hljs-comment">// 返回前一个页面   </span>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onKeyDown(keyCode, event);&#125;..................................<span class="hljs-comment">//是否可以前进                     </span>Webview.canGoForward()<span class="hljs-comment">//前进网页</span>Webview.goForward()</code></pre><h2 id="Android与Js的交互"><a href="#Android与Js的交互" class="headerlink" title="Android与Js的交互"></a>Android与Js的交互</h2><blockquote><p> Android与JS间的交互唯一桥梁就是<code>WebView</code>。</p></blockquote><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebView Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>         //用于调用Android中方法         function callAndroid()&#123;            myObj.hello("js调用了android中的hello方法");         &#125;         //用于测试第二种调用方法          function callAndroidWithLoadUrl()&#123;           document.location="js://showMsg?msg=android"         &#125;         //用于调用js方法         function callJS()&#123;      alert("Android调用了JS的callJS方法");    &#125;         function callJsWithParams(params)&#123;            alert("Android调用了JS的callJsWithParams方法" + params);          &#125;         function callJsWithParamsAndResult(params)&#123;            alert("Android调用了JS的callJsWithParamsAndResult" + params);            return "Success";         &#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"button1"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"callAndroid()"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="Android调用JS"><a href="#Android调用JS" class="headerlink" title="Android调用JS"></a>Android调用JS</h3><h4 id="通过WebView-loadUrl-调用"><a href="#通过WebView-loadUrl-调用" class="headerlink" title="通过WebView.loadUrl()调用"></a>通过<code>WebView.loadUrl()</code>调用</h4><blockquote><p><strong>Js的调用一定要在<code>onPageFinished()</code>回调之后才可调用，否则会导致失败。</strong></p></blockquote><pre><code class="hljs java">webView.loadUrl(<span class="hljs-string">"javascript:callJS()"</span>);webView.loadUrl(<span class="hljs-string">"javascript:callJsWithParams("</span>+params+<span class="hljs-string">")"</span>)</code></pre><p>在4.4之前并没有直接提供调用js函数并获取返回值的方法，需要操作的是 <strong>Android调用Js，Js执行完毕后，再通过Js继续调用Android方法返回值。</strong></p><h4 id="通过WebView-evaluateJavascript-调用-4-4后新增"><a href="#通过WebView-evaluateJavascript-调用-4-4后新增" class="headerlink" title="通过WebView.evaluateJavascript()调用(4.4后新增)"></a>通过<code>WebView.evaluateJavascript()</code>调用(4.4后新增)</h4><blockquote><p>该方法效率高于<code>loadUrl()</code>，不会导致页面的刷新。</p></blockquote><pre><code class="hljs java">mWebView.evaluateJavascript（<span class="hljs-string">"javascript:callJsWithParamsAndResult("</span>+params+<span class="hljs-string">")"</span>, <span class="hljs-keyword">new</span> ValueCallback&lt;String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceiveValue</span><span class="hljs-params">(String value)</span> </span>&#123;            <span class="hljs-comment">// value 为 Success</span>        &#125;    &#125;);</code></pre><p>在具体使用时，可以将两者进行结合使用</p><pre><code class="hljs java"><span class="hljs-comment">// Android版本变量</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> version = Build.VERSION.SDK_INT;<span class="hljs-comment">// 因为该方法在 Android 4.4 版本才可使用，所以使用时需进行版本判断</span><span class="hljs-keyword">if</span> (version &lt; <span class="hljs-number">18</span>) &#123;    mWebView.loadUrl(<span class="hljs-string">"javascript:callJS()"</span>);&#125; <span class="hljs-keyword">else</span> &#123;    mWebView.evaluateJavascript（<span class="hljs-string">"javascript:callJS()"</span>, <span class="hljs-keyword">new</span> ValueCallback&lt;String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceiveValue</span><span class="hljs-params">(String value)</span> </span>&#123;                    &#125;    &#125;);&#125;</code></pre><h3 id="JS调用Android"><a href="#JS调用Android" class="headerlink" title="JS调用Android"></a>JS调用Android</h3><h4 id="通过WebView-addJavascriptInterface-进行对象映射"><a href="#通过WebView-addJavascriptInterface-进行对象映射" class="headerlink" title="通过WebView.addJavascriptInterface()进行对象映射"></a>通过<code>WebView.addJavascriptInterface()</code>进行对象映射</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span></span>&#123;  <span class="hljs-meta">@JavascriptInterface</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(String msg)</span></span>&#123;      &#125;&#125;<span class="hljs-comment">//将Java对象映射到Js上</span>webView.addJavascriptInterface(<span class="hljs-keyword">new</span> MyObject(), <span class="hljs-string">"myObj"</span>);</code></pre><p><strong>该方法在4.2以下存在严重的安全漏洞问题，下一节中会有相关的解决方法。</strong></p><h4 id="利用WebViewClient-shouldOverrideUrlLoading-拦截url"><a href="#利用WebViewClient-shouldOverrideUrlLoading-拦截url" class="headerlink" title="利用WebViewClient.shouldOverrideUrlLoading()拦截url"></a>利用<code>WebViewClient.shouldOverrideUrlLoading()</code>拦截url</h4><pre><code class="hljs java">mWebView.setWebViewClient(<span class="hljs-keyword">new</span> WebViewClient() &#123;                                      <span class="hljs-meta">@Override</span>                                      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldOverrideUrlLoading</span><span class="hljs-params">(WebView view, String url)</span> </span>&#123;                                          <span class="hljs-comment">// 步骤2：根据协议的参数，判断是否是所需要的url</span>                                          <span class="hljs-comment">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span>                                          <span class="hljs-comment">//假定传入进来的 url = "js://webview?arg1=111&amp;arg2=222"（同时也是约定好的需要拦截的）</span>                                          Uri uri = Uri.parse(url);                                                                           <span class="hljs-comment">// 如果url的协议 = 预先约定的 js 协议</span>                                          <span class="hljs-comment">// 就解析往下解析参数</span>                                          <span class="hljs-keyword">if</span> ( uri.getScheme().equals(<span class="hljs-string">"js"</span>)) &#123;                                              <span class="hljs-comment">// 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议</span>                                              <span class="hljs-comment">// 所以拦截url,下面JS开始调用Android需要的方法</span>                                              <span class="hljs-keyword">if</span> (uri.getAuthority().equals(<span class="hljs-string">"webview"</span>)) &#123;                                                 <span class="hljs-comment">//  步骤3：</span>                                                  <span class="hljs-comment">// 执行JS所需要调用的逻辑</span>                                                  System.out.println(<span class="hljs-string">"js调用了Android的方法"</span>);                                                  <span class="hljs-comment">// 可以在协议上带有参数并传递到Android上</span>                                                  HashMap&lt;String, String&gt; params = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                                                  Set&lt;String&gt; collection = uri.getQueryParameterNames();                                              &#125;                                              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                                          &#125;                                          <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldOverrideUrlLoading(view, url);                                      &#125;                                  &#125;        );   &#125;</code></pre><h4 id="利用WebChromeClient回调接口的三个方法拦截消息"><a href="#利用WebChromeClient回调接口的三个方法拦截消息" class="headerlink" title="利用WebChromeClient回调接口的三个方法拦截消息"></a>利用<code>WebChromeClient</code>回调接口的三个方法拦截消息</h4><blockquote><p>对相关的接口进行拦截，这里拦截的是 Js中的几个提示方法，也就是几种样式的对话框。</p></blockquote><table><thead><tr><th>Js中方法</th><th>作用</th><th>返回值</th><th>对应拦截方法</th></tr></thead><tbody><tr><td><code>alert()</code></td><td>弹出警告框</td><td>没有</td><td><code>onJsAlert()</code></td></tr><tr><td><code>confirm()</code></td><td>弹出确认框</td><td>true/false</td><td><code>onJsConfirm()</code></td></tr><tr><td><code>prompt()</code></td><td>弹出输入框</td><td>任意设置返回值<em>输入内容</em></td><td><code>onJsPrompt()</code></td></tr></tbody></table><p>只有在<code>onJsPrompt()</code>中可以返回任意字段，可以在其中进行拦截判断，以调用对应方法。</p><h2 id="WebView执行漏洞"><a href="#WebView执行漏洞" class="headerlink" title="WebView执行漏洞"></a>WebView执行漏洞</h2><h3 id="任意代码执行漏洞"><a href="#任意代码执行漏洞" class="headerlink" title="任意代码执行漏洞"></a>任意代码执行漏洞</h3><h4 id="WebView中的addJavascriptInterface-接口"><a href="#WebView中的addJavascriptInterface-接口" class="headerlink" title="WebView中的addJavascriptInterface()接口"></a>WebView中的<code>addJavascriptInterface()</code>接口</h4><blockquote><p>当Js获取到这个对象后，就可以调用到该对象的所有方法，导致漏洞产生。</p></blockquote><h4 id="WebView内置导出的searchBoxJavaBridge-对象"><a href="#WebView内置导出的searchBoxJavaBridge-对象" class="headerlink" title="WebView内置导出的searchBoxJavaBridge_对象"></a>WebView内置导出的<code>searchBoxJavaBridge_</code>对象</h4><blockquote><p>Android3.0以下 系统默认通过<code>searchBoxJavaBridge_</code>给WebView添加一个Js映射对象：<code>searchBoxJavaBridge_</code>对象</p></blockquote><h4 id="WebView内置导出的accessibility和accessibilityTraversal对象"><a href="#WebView内置导出的accessibility和accessibilityTraversal对象" class="headerlink" title="WebView内置导出的accessibility和accessibilityTraversal对象"></a>WebView内置导出的<code>accessibility</code>和<code>accessibilityTraversal</code>对象</h4><h3 id="密码明文存储漏洞"><a href="#密码明文存储漏洞" class="headerlink" title="密码明文存储漏洞"></a>密码明文存储漏洞</h3><p>当WebView开启密码保存功能时导致漏洞<code>webView.setSavePassword(true)</code>，密码会被明文保存到<code>/data/data/com.package.name/databases/webview.db</code>中，有泄漏危险。</p><p>通过设置<code>webView.setSavePassword(false)</code>关闭密码保存提醒功能。</p><h3 id="域控制不严格漏洞"><a href="#域控制不严格漏洞" class="headerlink" title="域控制不严格漏洞"></a>域控制不严格漏洞</h3><p>A应用可以通过B应用导出的Activity让B应用家在一个恶意的file协议的url，从而获取到B应用的内部私有文件，带来数据泄露威胁。</p><p>对于不需要使用 file 协议的应用，禁用 file 协议；</p><pre><code class="hljs java"><span class="hljs-comment">// 禁用 file 协议；</span>setAllowFileAccess(<span class="hljs-keyword">false</span>); setAllowFileAccessFromFileURLs(<span class="hljs-keyword">false</span>);setAllowUniversalAccessFromFileURLs(<span class="hljs-keyword">false</span>);</code></pre><p>对于需要使用 file 协议的应用，禁止 file 协议加载 JavaScript。</p><pre><code class="hljs java"><span class="hljs-comment">// 需要使用 file 协议</span>setAllowFileAccess(<span class="hljs-keyword">true</span>); setAllowFileAccessFromFileURLs(<span class="hljs-keyword">false</span>);setAllowUniversalAccessFromFileURLs(<span class="hljs-keyword">false</span>);<span class="hljs-comment">// 禁止 file 协议加载 JavaScript</span><span class="hljs-keyword">if</span> (url.startsWith(<span class="hljs-string">"file://"</span>) &#123;    setJavaScriptEnabled(<span class="hljs-keyword">false</span>);&#125; <span class="hljs-keyword">else</span> &#123;    setJavaScriptEnabled(<span class="hljs-keyword">true</span>);&#125;</code></pre><h2 id="WebView优化"><a href="#WebView优化" class="headerlink" title="WebView优化"></a>WebView优化</h2><h3 id="WebView内存泄漏"><a href="#WebView内存泄漏" class="headerlink" title="WebView内存泄漏"></a>WebView内存泄漏</h3><p><strong>最好是可以去开启一个单独的进程去使用WebView并且当这个进程结束时，手动调用<code>System.exit(0)</code></strong>。</p><h3 id="后台无法释放js导致耗电"><a href="#后台无法释放js导致耗电" class="headerlink" title="后台无法释放js导致耗电"></a>后台无法释放js导致耗电</h3><p>在Js中可能会有一些动画或音频播放会一直执行，即时WebView挂在后台，这些资源也会继续使用，导致耗电加快。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">super</span>.onResume();  webView.setJavascriptEnabled(<span class="hljs-keyword">true</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">super</span>.onStop();  webView.setJavascriptEnabled(<span class="hljs-keyword">false</span>);&#125;</code></pre><h3 id="setBuiltInZoomControls引起的Crash"><a href="#setBuiltInZoomControls引起的Crash" class="headerlink" title="setBuiltInZoomControls引起的Crash"></a><code>setBuiltInZoomControls</code>引起的Crash</h3><p>当调用<code>setsetBuiltInZoomControls(true)</code>时去触摸屏幕，然后显示一个缩放控制图标，这图标几秒后会自动消失，这时去主动退出Activity，就会发生<code>ZoomButton</code>找不到依附Window导致异常使程序崩溃。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">super</span>.onDestroy();  <span class="hljs-comment">//手动进行隐藏，就不会导致崩溃了</span>  webView.setVisibility(View.GONE);&#125;</code></pre><h3 id="底部空白"><a href="#底部空白" class="headerlink" title="底部空白"></a>底部空白</h3><p>当WebView嵌套在ScrollView里的时候，如果WebView先加载了一个高度很高的网页，再加载一个高度很低的网页，就会造成WebView的高度无法自适应，导致底部出现大量空白的情况。</p><p>通过JS注入的方式，获取页面内容的高度，获取到后赋值到WebView的高度上。</p><pre><code class="hljs java">mWebView.setWebViewClient(<span class="hljs-keyword">new</span> WebViewClient() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageFinished</span><span class="hljs-params">(WebView view, String url)</span> </span>&#123;        mWebView.loadUrl(<span class="hljs-string">"javascript:App.resize(document.body.getBoundingClientRect().height)"</span>);        <span class="hljs-keyword">super</span>.onPageFinished(view, url);    &#125;&#125;);mWebView.addJavascriptInterface(<span class="hljs-keyword">this</span>, <span class="hljs-string">"App"</span>);<span class="hljs-meta">@JavascriptInterface</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> height)</span> </span>&#123;    getActivity().runOnUiThread(<span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">//Toast.makeText(getActivity(), height + "", Toast.LENGTH_LONG).show();</span>            <span class="hljs-comment">//此处的 layoutParmas 需要根据父控件类型进行区分，这里为了简单就不这么做了</span>                        mWebView.setLayoutParams(<span class="hljs-keyword">new</span> LinearLayout.LayoutParams(getResources().getDisplayMetrics().widthPixels, (<span class="hljs-keyword">int</span>) (height * getResources().getDisplayMetrics().density)));        &#125;    &#125;);&#125;</code></pre><h2 id="WebView独立进程"><a href="#WebView独立进程" class="headerlink" title="WebView独立进程"></a>WebView独立进程</h2><blockquote><p>WebView容易导致OOM问题，内存占用很大，还容易有内存泄漏的风险</p><p>由于Android版本的不同，4.0之前用的WebKit的内核，4.0之后就换了 chromium做内核了，内核的不同导致兼容性Crash</p><p>WebView和Native版本也不一致，导致Crash</p></blockquote><p>多进程的好处：</p><ul><li>Android每个应用的内存占用是有限制的，占用内存越大越容易被杀死。实现多进程时，可有效减少主进程内存占用</li><li>子进程的崩溃不会影响到主进程的使用</li><li>独立的进程的启动与退出不依赖于用户的使用，可以完全独立控制，主进程的退出不影响其使用</li></ul><p>//TODO 代码</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OkHttp简析</title>
    <link href="/2019/03/08/OkHttp%E7%AE%80%E6%9E%90/"/>
    <url>/2019/03/08/OkHttp%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>基于OkHttp 3.13版本进行分析</p></blockquote><p><img src="/images/OkHttp简析mind.png" srcset="/img/loading.gif" alt="OkHttp简析"></p><h2 id="OkHttp定义"><a href="#OkHttp定义" class="headerlink" title="OkHttp定义"></a>OkHttp定义</h2><p><code>OkHttp</code>现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。</p><p>所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。</p><p>OkHttp支持<code>SPDY协议</code>，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。</p><blockquote><p><code>SPDY协议</code>：Google提出的基于TCP的应用层协议，通过<code>压缩、多路复用、优先级</code>来缩短加载时间。</p></blockquote><h2 id="OkHttp使用示例"><a href="#OkHttp使用示例" class="headerlink" title="OkHttp使用示例"></a>OkHttp使用示例</h2><h3 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><pre><code class="hljs java">Request request = <span class="hljs-keyword">new</span> Request.Builder()     .url(url)     .build();</code></pre><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><pre><code class="hljs java">RequestBody body = RequestBody.create(JSON, json);Request request = <span class="hljs-keyword">new</span> Request.Builder()    .url(url)    .post(body)    .build();</code></pre><h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();Response response = client.newCall(request).execute();<span class="hljs-keyword">return</span> response.body().string();</code></pre><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();client.newCall(request).enqueue(<span class="hljs-keyword">new</span> Callback() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call call, okhttp3.Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    &#125;&#125;);</code></pre><h2 id="OkHttp源码分析"><a href="#OkHttp源码分析" class="headerlink" title="OkHttp源码分析"></a>OkHttp源码分析</h2><h3 id="构造OkHttpClient对象"><a href="#构造OkHttpClient对象" class="headerlink" title="构造OkHttpClient对象"></a>构造<code>OkHttpClient</code>对象</h3><p><img src="/images/OkHttp-构造OkHttpClient对象.png" srcset="/img/loading.gif" alt="构造OkHttpClient对象"></p><blockquote><p>需要先创建一个<code>OkHttpClient</code>用以执行后续请求。<strong>内部主要是相关参数配置。</strong></p><p>主要功能：通信的客户端，用以统一发起请求与解析返回值。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OkHttpClient</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> Builder());&#125;OkHttpClient(Builder builder) &#123;  <span class="hljs-comment">//用于调用网络请求 本质为 线程池</span>  <span class="hljs-keyword">this</span>.dispatcher = builder.dispatcher;  <span class="hljs-comment">//设置代理</span>  <span class="hljs-keyword">this</span>.proxy = builder.proxy;  <span class="hljs-comment">//设置协议</span>  <span class="hljs-keyword">this</span>.protocols = builder.protocols;  <span class="hljs-keyword">this</span>.connectionSpecs = builder.connectionSpecs;  <span class="hljs-comment">//设置拦截器</span>  <span class="hljs-keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);  <span class="hljs-comment">//设置网络拦截器</span>  <span class="hljs-keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);  <span class="hljs-comment">//回调监听</span>  <span class="hljs-keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;  <span class="hljs-keyword">this</span>.proxySelector = builder.proxySelector;  <span class="hljs-comment">//Cookie</span>  <span class="hljs-keyword">this</span>.cookieJar = builder.cookieJar;  <span class="hljs-comment">//缓存</span>  <span class="hljs-keyword">this</span>.cache = builder.cache;  <span class="hljs-keyword">this</span>.internalCache = builder.internalCache;  <span class="hljs-keyword">this</span>.socketFactory = builder.socketFactory;  <span class="hljs-keyword">boolean</span> isTLS = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;    isTLS = isTLS || spec.isTls();  &#125;  <span class="hljs-comment">//用于Https请求</span>  <span class="hljs-keyword">if</span> (builder.sslSocketFactory != <span class="hljs-keyword">null</span> || !isTLS) &#123;    <span class="hljs-keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;    <span class="hljs-keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;  &#125; <span class="hljs-keyword">else</span> &#123;    X509TrustManager trustManager = Util.platformTrustManager();    <span class="hljs-keyword">this</span>.sslSocketFactory = newSslSocketFactory(trustManager);    <span class="hljs-keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);  &#125;  <span class="hljs-keyword">if</span> (sslSocketFactory != <span class="hljs-keyword">null</span>) &#123;    Platform.get().configureSslSocketFactory(sslSocketFactory);  &#125;  <span class="hljs-keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;  <span class="hljs-keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(      certificateChainCleaner);  <span class="hljs-keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;  <span class="hljs-keyword">this</span>.authenticator = builder.authenticator;  <span class="hljs-keyword">this</span>.connectionPool = builder.connectionPool;  <span class="hljs-keyword">this</span>.dns = builder.dns;  <span class="hljs-keyword">this</span>.followSslRedirects = builder.followSslRedirects;  <span class="hljs-keyword">this</span>.followRedirects = builder.followRedirects;  <span class="hljs-comment">//是否需要重试</span>  <span class="hljs-keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;  <span class="hljs-keyword">this</span>.callTimeout = builder.callTimeout;  <span class="hljs-comment">//链接超时时长</span>  <span class="hljs-keyword">this</span>.connectTimeout = builder.connectTimeout;  <span class="hljs-comment">//读取超时时间</span>  <span class="hljs-keyword">this</span>.readTimeout = builder.readTimeout;  <span class="hljs-comment">//写入超时时间</span>  <span class="hljs-keyword">this</span>.writeTimeout = builder.writeTimeout;  <span class="hljs-keyword">this</span>.pingInterval = builder.pingInterval;  <span class="hljs-keyword">if</span> (interceptors.contains(<span class="hljs-keyword">null</span>)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Null interceptor: "</span> + interceptors);  &#125;  <span class="hljs-keyword">if</span> (networkInterceptors.contains(<span class="hljs-keyword">null</span>)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Null network interceptor: "</span> + networkInterceptors);  &#125;&#125;</code></pre><p><code>OkHttpClient</code>是应用<strong>建造者模式</strong>，通过<code>OkHttpClient.Builder</code>来构造一个<code>OkHttpClient</code>对象，支持数十种参数配置。</p><h3 id="构造Request请求对象"><a href="#构造Request请求对象" class="headerlink" title="构造Request请求对象"></a>构造<code>Request</code>请求对象</h3><p><img src="/images/OkHttp-构造Request请求对象.png" srcset="/img/loading.gif" alt="OkHttp-构造Request请求对象"></p><blockquote><p>创建一个<code>Request</code>对象用以包括请求的所有信息，内部包含了<strong>请求地址，请求头，请求内容</strong>。</p><p>主要功能：封装请求的具体信息。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;  Request(Builder builder) &#123;    <span class="hljs-comment">//请求地址</span>    <span class="hljs-keyword">this</span>.url = builder.url;    <span class="hljs-comment">//请求方法 例如：GET、POST、PUT、DELETE等</span>    <span class="hljs-keyword">this</span>.method = builder.method;    <span class="hljs-comment">//请求头信息</span>    <span class="hljs-keyword">this</span>.headers = builder.headers.build();    <span class="hljs-comment">//请求内容构造体</span>    <span class="hljs-keyword">this</span>.body = builder.body;    <span class="hljs-comment">//请求的标签  用于后续对指定标签可进行特殊处理</span>    <span class="hljs-keyword">this</span>.tags = Util.immutableMap(builder.tags);  &#125;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;    <span class="hljs-meta">@Nullable</span> HttpUrl url;    String method;    Headers.Builder headers;    <span class="hljs-meta">@Nullable</span> RequestBody body;    <span class="hljs-comment">/** A mutable map of tags, or an immutable empty map if we don't have any. */</span>    Map&lt;Class&lt;?&gt;, Object&gt; tags = Collections.emptyMap();        <span class="hljs-comment">//默认是GET方法，不带有请求体</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.method = <span class="hljs-string">"GET"</span>;      <span class="hljs-keyword">this</span>.headers = <span class="hljs-keyword">new</span> Headers.Builder();    &#125;    Builder(Request request) &#123;      <span class="hljs-keyword">this</span>.url = request.url;      <span class="hljs-keyword">this</span>.method = request.method;      <span class="hljs-keyword">this</span>.body = request.body;      <span class="hljs-keyword">this</span>.tags = request.tags.isEmpty()          ? Collections.emptyMap()          : <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(request.tags);      <span class="hljs-keyword">this</span>.headers = request.headers.newBuilder();    &#125;     ...   &#125;&#125;</code></pre><p><code>Request</code>使用的也是<strong>建造者模式</strong>，通过<code>Request.Builder</code>去构造对应<code>Request</code>。</p><h4 id="请求体RequestBody"><a href="#请求体RequestBody" class="headerlink" title="请求体RequestBody"></a>请求体<code>RequestBody</code></h4><blockquote><p>主要功能：用以提交<strong>流、表单等请求信息</strong>。</p></blockquote><h5 id="FormBody"><a href="#FormBody" class="headerlink" title="FormBody"></a>FormBody</h5><blockquote><p>支持提交键值对类型。例如<code>userId : 1</code></p></blockquote><p>使用方法</p><pre><code class="hljs java">FormBody.Builder formBodyBuilder = <span class="hljs-keyword">new</span> FormBody.Builder();Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;    formBodyBuilder.add(entry.getKey(), entry.getValue().toString());&#125;RequestBody body = formBodyBuilder.build();</code></pre><h5 id="MultipartBody"><a href="#MultipartBody" class="headerlink" title="MultipartBody"></a>MultipartBody</h5><blockquote><p>除了支持键值对，还有提交文件功能。</p></blockquote><p>使用方法</p><pre><code class="hljs java">MultipartBody.Builder multipartBuilder = <span class="hljs-keyword">new</span> MultipartBody.Builder().setType(MultipartBody.FORM);       Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();       <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;           multipartBuilder.addFormDataPart(entry.getKey(), entry.getValue().toString());       &#125;       <span class="hljs-comment">//可以针对文件新起一个 参数来进行传递</span>       <span class="hljs-keyword">for</span> (Map.Entry&lt;String, File&gt; entry : message.getFiles().entrySet()) &#123;           File f = entry.getValue();           <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)               <span class="hljs-keyword">continue</span>;           String name = f.getName();           String ext = name.substring(name.lastIndexOf(<span class="hljs-string">'.'</span>));           String imageFormat = <span class="hljs-string">"jpg"</span>;           <span class="hljs-keyword">if</span> (<span class="hljs-string">".png"</span>.equalsIgnoreCase(ext)) &#123;               imageFormat = <span class="hljs-string">"png"</span>;           &#125;           multipartBuilder.addFormDataPart(                   entry.getKey(),                   entry.getValue().getName(),                   RequestBody.create(MediaType.parse(<span class="hljs-string">"image/"</span> + imageFormat), entry.getValue())           );       &#125;       RequestBody body = multipartBuilder.build();</code></pre><h3 id="发送Request请求"><a href="#发送Request请求" class="headerlink" title="发送Request请求"></a>发送<code>Request</code>请求</h3><p><img src="/images/OkHttp-发送Request请求.png" srcset="/img/loading.gif" alt="OkHttp-发送Request请求"></p><p>通过<code>OkHttpClient.newCall()</code>发送出<code>Request</code>请求</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Call <span class="hljs-title">newCall</span><span class="hljs-params">(Request request)</span> </span>&#123;  <span class="hljs-keyword">return</span> RealCall.newRealCall(<span class="hljs-keyword">this</span>, request, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* for web socket */</span>);&#125;</code></pre><p>返回了一个<code>Call</code>对象，实现类为<code>RealCall</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Call</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cloneable</span> </span>&#123;  <span class="hljs-comment">//获取当前请求</span>  <span class="hljs-function">Request <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//执行当前请求 并返回结果</span>  <span class="hljs-function">Response <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;  <span class="hljs-comment">//异步请求</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Callback responseCallback)</span></span>;  <span class="hljs-comment">//取消请求</span>  <span class="hljs-comment">/** Cancels the request, if possible. Requests that are already complete cannot be canceled. */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//当前请求是否正在执行</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isExecuted</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//请求是否已取消</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCanceled</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//超时返回</span>  <span class="hljs-function">Timeout <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//克隆请求 用于重新调用</span>  <span class="hljs-function">Call <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>;  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-function">Call <span class="hljs-title">newCall</span><span class="hljs-params">(Request request)</span></span>;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Call</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RealCall</span><span class="hljs-params">(OkHttpClient client, Request originalRequest, <span class="hljs-keyword">boolean</span> forWebSocket)</span> </span>&#123;    <span class="hljs-comment">//前面先行创建的 OkHttpClient</span>    <span class="hljs-keyword">this</span>.client = client;        <span class="hljs-comment">//创建的请求对象</span>    <span class="hljs-keyword">this</span>.originalRequest = originalRequest;   <span class="hljs-comment">//用于建立长连接</span>    <span class="hljs-keyword">this</span>.forWebSocket = forWebSocket;  &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> RealCall <span class="hljs-title">newRealCall</span><span class="hljs-params">(OkHttpClient client, Request originalRequest, <span class="hljs-keyword">boolean</span> forWebSocket)</span> </span>&#123;    <span class="hljs-comment">// Safely publish the Call instance to the EventListener.</span>    RealCall call = <span class="hljs-keyword">new</span> RealCall(client, originalRequest, forWebSocket);        <span class="hljs-comment">//为这次请求设置了事件监听器，包括请求开始、结束、异常等监听</span>    call.transmitter = <span class="hljs-keyword">new</span> Transmitter(client, call);    <span class="hljs-keyword">return</span> call;  &#125;&#125;</code></pre><p>通过<code>newCall()</code>根据传递进来的<code>Request</code>创建一个<code>RealCall</code>实例去发送请求。</p><h4 id="同步请求——execute"><a href="#同步请求——execute" class="headerlink" title="同步请求——execute()"></a>同步请求——execute()</h4><blockquote><p>直接执行并返回请求结果</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already Executed"</span>);      executed = <span class="hljs-keyword">true</span>;    &#125;    transmitter.timeoutEnter();    <span class="hljs-comment">//请求开始</span>    transmitter.callStart();    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//加入 runningSuncCalls 队列中</span>      client.dispatcher().executed(<span class="hljs-keyword">this</span>);      <span class="hljs-comment">//返回响应结果</span>      <span class="hljs-keyword">return</span> getResponseWithInterceptorChain();    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-comment">//从队列中移除 避免重复执行</span>      client.dispatcher().finished(<span class="hljs-keyword">this</span>);    &#125;  &#125;</code></pre><blockquote><p>执行<code>execute()</code>时，监听到请求事件开始，就会加入到<code>Dispatcher.runningSyncCalls</code>中，里面记录的是当前正在进行同步请求的call，然后当call完成时或因异常结束时，再从<code>Dispatcher.runningSyncCalls</code>移除。</p></blockquote><h4 id="异步请求——enqueue-Callback-callback"><a href="#异步请求——enqueue-Callback-callback" class="headerlink" title="异步请求——enqueue(Callback callback)"></a>异步请求——enqueue(Callback callback)</h4><blockquote><p>构造一个异步执行队列，然后把请求加入队列中处理</p></blockquote><pre><code class="hljs java">  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Callback responseCallback)</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already Executed"</span>);      executed = <span class="hljs-keyword">true</span>;    &#125;    transmitter.callStart();    client.dispatcher().enqueue(<span class="hljs-keyword">new</span> AsyncCall(responseCallback));  &#125;<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamedRunnable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Callback responseCallback;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> AtomicInteger callsPerHost = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    AsyncCall(Callback responseCallback) &#123;      <span class="hljs-keyword">super</span>(<span class="hljs-string">"OkHttp %s"</span>, redactedUrl());      <span class="hljs-keyword">this</span>.responseCallback = responseCallback;    &#125;    <span class="hljs-function">AtomicInteger <span class="hljs-title">callsPerHost</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> callsPerHost;    &#125;    ...    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">executeOn</span><span class="hljs-params">(ExecutorService executorService)</span> </span>&#123;      <span class="hljs-keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));      <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">try</span> &#123;        executorService.execute(<span class="hljs-keyword">this</span>);        success = <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;        InterruptedIOException ioException = <span class="hljs-keyword">new</span> InterruptedIOException(<span class="hljs-string">"executor rejected"</span>);        ioException.initCause(e);        transmitter.noMoreExchanges(ioException);        responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, ioException);      &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (!success) &#123;          client.dispatcher().finished(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// This call is no longer running!</span>        &#125;      &#125;    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">boolean</span> signalledCallback = <span class="hljs-keyword">false</span>;      transmitter.timeoutEnter();      <span class="hljs-keyword">try</span> &#123;        Response response = getResponseWithInterceptorChain();        signalledCallback = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">//回调请求结果</span>        responseCallback.onResponse(RealCall.<span class="hljs-keyword">this</span>, response);      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        <span class="hljs-keyword">if</span> (signalledCallback) &#123;          <span class="hljs-comment">// Do not signal the callback twice!</span>          Platform.get().log(INFO, <span class="hljs-string">"Callback failure for "</span> + toLoggableString(), e);        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">//回调失败并返回异常</span>          responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, e);        &#125;      &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">//从队列中移除</span>        client.dispatcher().finished(<span class="hljs-keyword">this</span>);      &#125;    &#125;  &#125;</code></pre><blockquote><p><code>enqueue()</code>调用到<code>Dispatcher.enqueue()</code>传入的是一个<code>AsyncCall</code>对象，<code>AsyncCall</code>本质是一个<code>Runnable</code>对象，通过<code>Dispatcher</code>中的<code>ExecutorService</code>来执行<code>AsyncCall</code>。</p></blockquote><h3 id="执行Request请求"><a href="#执行Request请求" class="headerlink" title="执行Request请求"></a>执行<code>Request</code>请求</h3><blockquote><p>由<code>execute()</code>或<code>enqueue()</code>发送请求时，最后都是需要有<code>Dispatch</code>去执行请求。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dispatcher</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxRequests = <span class="hljs-number">64</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxRequestsPerHost = <span class="hljs-number">5</span>;      <span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> ExecutorService executorService;  <span class="hljs-comment">//正在准备执行的异步请求队列</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();  <span class="hljs-comment">//正在执行的异步请求队列</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();  <span class="hljs-comment">//正在执行的同步请求队列 </span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();      <span class="hljs-comment">//用以执行异步请求</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> ExecutorService <span class="hljs-title">executorService</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (executorService == <span class="hljs-keyword">null</span>) &#123;      executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60</span>, TimeUnit.SECONDS,          <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp Dispatcher"</span>, <span class="hljs-keyword">false</span>));    &#125;    <span class="hljs-keyword">return</span> executorService;  &#125;      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(AsyncCall call)</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;      <span class="hljs-comment">//加入正在执行的异步队列中</span>      readyAsyncCalls.add(call);      <span class="hljs-comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span>      <span class="hljs-comment">// the same host.</span>      <span class="hljs-keyword">if</span> (!call.get().forWebSocket) &#123;        AsyncCall existingCall = findExistingCallWithHost(call.host());        <span class="hljs-keyword">if</span> (existingCall != <span class="hljs-keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);      &#125;    &#125;    promoteAndExecute();  &#125;      <span class="hljs-comment">//加入正在执行的同步队列</span>  <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executed</span><span class="hljs-params">(RealCall call)</span> </span>&#123;    runningSyncCalls.add(call);  &#125;  <span class="hljs-comment">//从政在执行的异步队列中移除  </span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(AsyncCall call)</span> </span>&#123;    call.callsPerHost().decrementAndGet();    finished(runningAsyncCalls, call);  &#125;  <span class="hljs-comment">//执行完毕后  从正在执行的同步队列中移除</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(RealCall call)</span> </span>&#123;    finished(runningSyncCalls, call);  &#125;      <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;    Runnable idleCallback;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;      <span class="hljs-keyword">if</span> (!calls.remove(call)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">"Call wasn't in-flight!"</span>);      idleCallback = <span class="hljs-keyword">this</span>.idleCallback;    &#125;    <span class="hljs-keyword">boolean</span> isRunning = promoteAndExecute();    <span class="hljs-keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="hljs-keyword">null</span>) &#123;      idleCallback.run();    &#125;  &#125;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">promoteAndExecute</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//判定当前线程是否持有锁</span>    <span class="hljs-keyword">assert</span> (!Thread.holdsLock(<span class="hljs-keyword">this</span>));    List&lt;AsyncCall&gt; executableCalls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">boolean</span> isRunning;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;        AsyncCall asyncCall = i.next();        <span class="hljs-comment">//正在运行的异步请求不能超过 64个</span>        <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Max capacity.</span>        <span class="hljs-comment">//在同一个Host下的异步请求不能超过5个</span>        <span class="hljs-keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Host max capacity.</span>        i.remove();        <span class="hljs-comment">//CAS</span>        asyncCall.callsPerHost().incrementAndGet();        <span class="hljs-comment">//添加至异步执行队列</span>        executableCalls.add(asyncCall);        <span class="hljs-comment">//添加至正在执行异步请求队列</span>        runningAsyncCalls.add(asyncCall);      &#125;      isRunning = runningCallsCount() &gt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;      AsyncCall asyncCall = executableCalls.get(i);      <span class="hljs-comment">//执行异步请求</span>      asyncCall.executeOn(executorService());    &#125;    <span class="hljs-keyword">return</span> isRunning;  &#125;&#125;</code></pre><p><code>Dispatcher</code>是一个任务调度器，内部维护了三个双端队列：</p><ul><li><code>readyAsyncCalls</code>：准备执行的异步请求。<em>已经超过请求上限的异步请求就会放在该队列中。</em></li><li><code>runningAsyncCalls</code>：正在执行的异步请求。<em>不超过请求上限时，异步请求会加入到该队列中，超过时，依然放到<code>readyAsyncCalls</code>中。</em></li><li><code>runningSyncCalls</code>：正在执行的同步请求。<em>直接把同步请求添加到该队列中。</em></li></ul><p>通过<code>Dispatcher</code>中的<code>executorService</code>去执行对应请求。</p><h3 id="处理Request请求——通过拦截器"><a href="#处理Request请求——通过拦截器" class="headerlink" title="处理Request请求——通过拦截器"></a>处理<code>Request</code>请求——通过拦截器</h3><p><img src="/images/OkHttp-处理Request请求.png" srcset="/img/loading.gif" alt="OkHttp-处理Request请求"></p><blockquote><p>通过<code>Dispatcher</code>执行完请求后，返回回调结果前，需要通过<code>getResponseWithInterceptorChain()</code>通过层层责任链的执行来获得最终的请求结果。</p><p><strong>通过责任链模式将请求一层层的通过拦截器进行处理。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-function">Response <span class="hljs-title">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// Build a full stack of interceptors.</span>    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">//加入用户自定义的拦截器</span>    interceptors.addAll(client.interceptors());    <span class="hljs-comment">//重试和重定向拦截器</span>    interceptors.add(<span class="hljs-keyword">new</span> RetryAndFollowUpInterceptor(client));    <span class="hljs-comment">//转化用户请求为网络请求</span>    interceptors.add(<span class="hljs-keyword">new</span> BridgeInterceptor(client.cookieJar()));    <span class="hljs-comment">//负责读取缓存以及更新缓存</span>    interceptors.add(<span class="hljs-keyword">new</span> CacheInterceptor(client.internalCache()));    <span class="hljs-comment">//与服务器建立连接</span>    interceptors.add(<span class="hljs-keyword">new</span> ConnectInterceptor(client));    <span class="hljs-keyword">if</span> (!forWebSocket) &#123;       <span class="hljs-comment">//用户自定义的网络拦截器</span>      interceptors.addAll(client.networkInterceptors());    &#125;    <span class="hljs-comment">//从服务器读取响应的数据</span>    interceptors.add(<span class="hljs-keyword">new</span> CallServerInterceptor(forWebSocket));    Interceptor.Chain chain = <span class="hljs-keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>,        originalRequest, <span class="hljs-keyword">this</span>, client.connectTimeoutMillis(),        client.readTimeoutMillis(), client.writeTimeoutMillis());    <span class="hljs-keyword">boolean</span> calledNoMoreExchanges = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//链式调用拦截器，最终返回 Response</span>      Response response = chain.proceed(originalRequest);      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;        closeQuietly(response);        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);      &#125;      <span class="hljs-keyword">return</span> response;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;      calledNoMoreExchanges = <span class="hljs-keyword">true</span>;      <span class="hljs-keyword">throw</span> transmitter.noMoreExchanges(e);    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;        transmitter.noMoreExchanges(<span class="hljs-keyword">null</span>);      &#125;    &#125;  &#125;</code></pre><p>在获得响应结果之前，需要对用户设置的原始请求转换为实际的网络请求，然后通过一系列拦截器，直到最终得到结果，采用<strong>链式调用</strong>保证这些拦截器的执行顺序。</p><h4 id="OkHttp拦截器"><a href="#OkHttp拦截器" class="headerlink" title="OkHttp拦截器"></a>OkHttp拦截器</h4><blockquote><p>所有的拦截器都实现了<code>Interceptor</code>接口，支持用户去自定义拦截器，只要实现<code>Interceptor</code>接口即可。</p><p>拦截器可以 用来<em>监控、改写和重试HTTP访问</em>。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interceptor</span> </span>&#123;  <span class="hljs-comment">//主要实现该接口，控制返回结果</span>  <span class="hljs-function">Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException</span>;  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Chain</span> </span>&#123;        <span class="hljs-function">Request <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> IOException</span>;    <span class="hljs-comment">//返回Request执行后的返回结果</span>    <span class="hljs-meta">@Nullable</span> <span class="hljs-function">Connection <span class="hljs-title">connection</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Call <span class="hljs-title">call</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connectTimeoutMillis</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Chain <span class="hljs-title">withConnectTimeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout, TimeUnit unit)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">readTimeoutMillis</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Chain <span class="hljs-title">withReadTimeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout, TimeUnit unit)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">writeTimeoutMillis</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Chain <span class="hljs-title">withWriteTimeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout, TimeUnit unit)</span></span>;  &#125;&#125;</code></pre><h5 id="ApplicationInterceptor"><a href="#ApplicationInterceptor" class="headerlink" title="ApplicationInterceptor"></a><code>ApplicationInterceptor</code></h5><p><img src="/images/OkHttp-ApplicationInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-ApplicationInterceptor"></p><blockquote><p>该拦截器会被第一个执行，此处得到的<code>Request</code>为最原始状态。但是最终得到的<code>Response</code>是最终的结果。</p></blockquote><p>引用代码</p><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient.Builder()    .addInterceptor(<span class="hljs-keyword">new</span> LoggingInterceptor())    .build();</code></pre><blockquote><p><code>ApplicationInterceptor</code>适用于在请求前统一添加一些公共参数，例如<code>App的版本号，系统信息</code>等。</p><p>也可用于对返回的<code>Response</code>进行加工。</p></blockquote><p><code>ApplicationInterceptor</code>有以下特定：</p><ul><li>不需要关心后续拦截器进行的操作，因为是会被第一个执行的，只要关心返回结果即可。</li><li>只会被响应一次，即使强制缓存获取</li><li>可以对后续的拦截器调用进行拦截或者进行多次调用——<strong>通过<code>Chain.proceed()</code>进行控制</strong></li></ul><h5 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a><code>RetryAndFollowUpInterceptor</code></h5><p><img src="/images/OkHttp-RetryAndFollowUpInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-RetryAndFollowUpInterceptor"></p><blockquote><p>负责失败重试和重定向的拦截器。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetryAndFollowUpInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">//从自定义拦截器 那里传递下来的请求</span>    Request request = chain.request();    RealInterceptorChain realChain = (RealInterceptorChain) chain;    <span class="hljs-comment">//获取事件监听器</span>    Transmitter transmitter = realChain.transmitter();    <span class="hljs-comment">//初始化 重定向次数</span>    <span class="hljs-keyword">int</span> followUpCount = <span class="hljs-number">0</span>;    Response priorResponse = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//开启死循环 进行重试操作</span>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      transmitter.prepareToConnect(request);      <span class="hljs-comment">//请求取消</span>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);      &#125;      Response response;      <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//向下调用 下一个拦截器——BridgeInterceptor</span>        response = realChain.proceed(request, transmitter, <span class="hljs-keyword">null</span>);        success = <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">catch</span> (RouteException e) &#123;        <span class="hljs-comment">// 不需要重试 则抛出异常</span>        <span class="hljs-keyword">if</span> (!recover(e.getLastConnectException(), transmitter, <span class="hljs-keyword">false</span>, request)) &#123;          <span class="hljs-keyword">throw</span> e.getFirstConnectException();        &#125;        <span class="hljs-keyword">continue</span>;      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        <span class="hljs-comment">// 无法与服务端建立连接</span>        <span class="hljs-keyword">boolean</span> requestSendStarted = !(e <span class="hljs-keyword">instanceof</span> ConnectionShutdownException);        <span class="hljs-keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="hljs-keyword">throw</span> e;        <span class="hljs-keyword">continue</span>;      &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// The network call threw an exception. Release any resources.</span>        <span class="hljs-keyword">if</span> (!success) &#123;          <span class="hljs-comment">//释放资源</span>          transmitter.exchangeDoneDueToException();        &#125;      &#125;      <span class="hljs-comment">// Attach the prior response if it exists. Such responses never have a body.</span>      <span class="hljs-keyword">if</span> (priorResponse != <span class="hljs-keyword">null</span>) &#123;        response = response.newBuilder()            .priorResponse(priorResponse.newBuilder()                    .body(<span class="hljs-keyword">null</span>)                    .build())            .build();      &#125;      Exchange exchange = Internal.instance.exchange(response);      Route route = exchange != <span class="hljs-keyword">null</span> ? exchange.connection().route() : <span class="hljs-keyword">null</span>;      <span class="hljs-comment">//根据返回的 response的Code 判断是否需要进行重定向</span>      Request followUp = followUpRequest(response, route);      <span class="hljs-keyword">if</span> (followUp == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//释放资源</span>        <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span> &amp;&amp; exchange.isDuplex()) &#123;          transmitter.timeoutEarlyExit();        &#125;        <span class="hljs-keyword">return</span> response;      &#125;      RequestBody followUpBody = followUp.body();      <span class="hljs-keyword">if</span> (followUpBody != <span class="hljs-keyword">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;        <span class="hljs-keyword">return</span> response;      &#125;      closeQuietly(response.body());      <span class="hljs-keyword">if</span> (transmitter.hasExchange()) &#123;        exchange.detachWithViolence();      &#125;      <span class="hljs-comment">//超出重定向次数</span>      <span class="hljs-keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(<span class="hljs-string">"Too many follow-up requests: "</span> + followUpCount);      &#125;      <span class="hljs-comment">//获取重定向结果 赋予 request继续向下请求</span>      request = followUp;      priorResponse = response;    &#125;  &#125;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">recover</span><span class="hljs-params">(IOException e, Transmitter transmitter,      <span class="hljs-keyword">boolean</span> requestSendStarted, Request userRequest)</span> </span>&#123;    <span class="hljs-comment">// 未开启重试 retryOnConnectionFailure(false)</span>    <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 只允许发送一次 isOneShot()&#123;return true;&#125;</span>    <span class="hljs-keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 发生异常</span>    <span class="hljs-keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// 设置不允许重试</span>    <span class="hljs-keyword">if</span> (!transmitter.canRetry()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;&#125;</code></pre><blockquote><ol><li>尝试执行下一个拦截器，即<code>BridgeInterceptor</code></li><li>抛出异常，需要根据以下情况去判断是否需要重试：<ul><li>客户端是否开启  <code>retryOnConnectionFailure</code></li><li><code>RequestBody.isOneShot()</code>返回值</li><li>判断异常类型，除了<code>ConnectionShutdownException</code>被中断情况外的<code>IOException</code>的子类，都不会进行重试</li></ul></li><li>根据Response返回的响应码<code>code</code>进行处理</li></ol></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">followUpRequest</span><span class="hljs-params">(Response userResponse, @Nullable Route route)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">if</span> (userResponse == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();    <span class="hljs-keyword">int</span> responseCode = userResponse.code();    <span class="hljs-keyword">final</span> String method = userResponse.request().method();    <span class="hljs-keyword">switch</span> (responseCode) &#123;      <span class="hljs-comment">// 407 需要进行代理认证</span>      <span class="hljs-keyword">case</span> HTTP_PROXY_AUTH:        Proxy selectedProxy = route != <span class="hljs-keyword">null</span>            ? route.proxy()            : client.proxy();        <span class="hljs-keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(<span class="hljs-string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>);        &#125;        <span class="hljs-keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);      <span class="hljs-comment">// 401 未经认证</span>      <span class="hljs-keyword">case</span> HTTP_UNAUTHORIZED:        <span class="hljs-keyword">return</span> client.authenticator().authenticate(route, userResponse);      <span class="hljs-comment">// 307 永久重定向  308 临时重定向  只有GET、HEAD请求方法才有效</span>      <span class="hljs-keyword">case</span> HTTP_PERM_REDIRECT:      <span class="hljs-keyword">case</span> HTTP_TEMP_REDIRECT:        <span class="hljs-comment">// "If the 307 or 308 status code is received in response to a request other than GET</span>        <span class="hljs-comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span>        <span class="hljs-keyword">if</span> (!method.equals(<span class="hljs-string">"GET"</span>) &amp;&amp; !method.equals(<span class="hljs-string">"HEAD"</span>)) &#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// fall-through</span>            <span class="hljs-keyword">case</span> HTTP_MULT_CHOICE:<span class="hljs-comment">// 300  多个重定向地址</span>      <span class="hljs-keyword">case</span> HTTP_MOVED_PERM:<span class="hljs-comment">// 301 永久移除 指向了新的位置</span>      <span class="hljs-keyword">case</span> HTTP_MOVED_TEMP:<span class="hljs-comment">//302  临时移除</span>      <span class="hljs-keyword">case</span> HTTP_SEE_OTHER:<span class="hljs-comment">//303 查看其他位置</span>        <span class="hljs-comment">// 开发者是否允许重定向</span>        <span class="hljs-keyword">if</span> (!client.followRedirects()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//重定向后的实际地址</span>        String location = userResponse.header(<span class="hljs-string">"Location"</span>);        <span class="hljs-keyword">if</span> (location == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        HttpUrl url = userResponse.request().url().resolve(location);        <span class="hljs-comment">// Don't follow redirects to unsupported protocols.</span>        <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// If configured, don't follow redirects between SSL and non-SSL.</span>        <span class="hljs-keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());        <span class="hljs-keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// Most redirects don't include a request body.</span>        Request.Builder requestBuilder = userResponse.request().newBuilder();        <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;          <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);          <span class="hljs-keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;            requestBuilder.method(<span class="hljs-string">"GET"</span>, <span class="hljs-keyword">null</span>);          &#125; <span class="hljs-keyword">else</span> &#123;            RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="hljs-keyword">null</span>;            requestBuilder.method(method, requestBody);          &#125;          <span class="hljs-keyword">if</span> (!maintainBody) &#123;            requestBuilder.removeHeader(<span class="hljs-string">"Transfer-Encoding"</span>);            requestBuilder.removeHeader(<span class="hljs-string">"Content-Length"</span>);            requestBuilder.removeHeader(<span class="hljs-string">"Content-Type"</span>);          &#125;        &#125;        <span class="hljs-comment">// When redirecting across hosts, drop all authentication headers. This</span>        <span class="hljs-comment">// is potentially annoying to the application layer since they have no</span>        <span class="hljs-comment">// way to retain them.</span>        <span class="hljs-keyword">if</span> (!sameConnection(userResponse.request().url(), url)) &#123;          requestBuilder.removeHeader(<span class="hljs-string">"Authorization"</span>);        &#125;        <span class="hljs-keyword">return</span> requestBuilder.url(url).build();      <span class="hljs-comment">//408 超时</span>      <span class="hljs-keyword">case</span> HTTP_CLIENT_TIMEOUT:        <span class="hljs-comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span>        <span class="hljs-comment">// spec says that we may repeat the request without modifications. Modern browsers also</span>        <span class="hljs-comment">// repeat the request (even non-idempotent ones.)</span>        <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure()) &#123;          <span class="hljs-comment">// The application layer has directed us not to retry the request.</span>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        RequestBody requestBody = userResponse.request().body();        <span class="hljs-keyword">if</span> (requestBody != <span class="hljs-keyword">null</span> &amp;&amp; requestBody.isOneShot()) &#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (userResponse.priorResponse() != <span class="hljs-keyword">null</span>            &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;          <span class="hljs-comment">// We attempted to retry and got another timeout. Give up.</span>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (retryAfter(userResponse, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) &#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> userResponse.request();      <span class="hljs-comment">//503 服务端不可用</span>      <span class="hljs-keyword">case</span> HTTP_UNAVAILABLE:        <span class="hljs-keyword">if</span> (userResponse.priorResponse() != <span class="hljs-keyword">null</span>            &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;          <span class="hljs-comment">// We attempted to retry and got another timeout. Give up.</span>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">// specifically received an instruction to retry without delay</span>          <span class="hljs-keyword">return</span> userResponse.request();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;  &#125;</code></pre><p>通过<code>followUpRequest()</code>对<code>Response</code>返回的<code>code</code>进行对应操作，在触发到重定向相关的code<code>3XX</code>时，需要对应的转换<code>Request</code>使用获取到的重定向后地址进行请求。</p><blockquote><p>由源码可知，可以重试的最大次数为<strong>20</strong>次，可以通过<code>retryOnConnectionFailure(true)</code>设置支持重试。但是不支持自定义重试次数，若需要自定义重试次数，需要自定义拦截器去实现。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetryInterceptor</span></span>(<span class="hljs-keyword">var</span> maxRetry: <span class="hljs-built_in">Int</span><span class="hljs-comment">/*最大重试次数*/</span>) : Interceptor &#123;        <span class="hljs-comment">//当前重试次数</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> retryNum = <span class="hljs-number">0</span>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercept</span><span class="hljs-params">(chain: <span class="hljs-type">Interceptor</span>.<span class="hljs-type">Chain</span>)</span></span>: Response &#123;            <span class="hljs-keyword">val</span> request = chain.request()            <span class="hljs-keyword">var</span> response = chain.proceed(request)            <span class="hljs-keyword">while</span> (!response.isSuccessful &amp;&amp; retryNum &lt; maxRetry) &#123;                retryNum++                response = chain.proceed(request)            &#125;            <span class="hljs-keyword">return</span> response        &#125;    &#125;</code></pre><h5 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a><code>BridgeInterceptor</code></h5><p><img src="/images/OkHttp-BridgeInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-BridgeInterceptor"></p><blockquote><p>用以将用户的请求转换为向服务器的请求，之后再把服务器返回的数据转换成用户直观的数据。<strong>主要是对Header进行处理</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BridgeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    Request userRequest = chain.request();    Request.Builder requestBuilder = userRequest.newBuilder();    <span class="hljs-comment">//重构用户请求 为 服务器请求格式</span>    RequestBody body = userRequest.body();    <span class="hljs-comment">//如果存在Body</span>    <span class="hljs-keyword">if</span> (body != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">//对Header进行调整</span>      MediaType contentType = body.contentType();      <span class="hljs-keyword">if</span> (contentType != <span class="hljs-keyword">null</span>) &#123;        requestBuilder.header(<span class="hljs-string">"Content-Type"</span>, contentType.toString());      &#125;      <span class="hljs-keyword">long</span> contentLength = body.contentLength();      <span class="hljs-keyword">if</span> (contentLength != -<span class="hljs-number">1</span>) &#123;        requestBuilder.header(<span class="hljs-string">"Content-Length"</span>, Long.toString(contentLength));        requestBuilder.removeHeader(<span class="hljs-string">"Transfer-Encoding"</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        requestBuilder.header(<span class="hljs-string">"Transfer-Encoding"</span>, <span class="hljs-string">"chunked"</span>);        requestBuilder.removeHeader(<span class="hljs-string">"Content-Length"</span>);      &#125;    &#125;    <span class="hljs-comment">//设置Header中的 host</span>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Host"</span>) == <span class="hljs-keyword">null</span>) &#123;      requestBuilder.header(<span class="hljs-string">"Host"</span>, hostHeader(userRequest.url(), <span class="hljs-keyword">false</span>));    &#125;    <span class="hljs-comment">//设置 connection : Keep-Alive 保持长连接模式</span>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Connection"</span>) == <span class="hljs-keyword">null</span>) &#123;      requestBuilder.header(<span class="hljs-string">"Connection"</span>, <span class="hljs-string">"Keep-Alive"</span>);    &#125;    <span class="hljs-comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span>    <span class="hljs-comment">// the transfer stream.</span>    <span class="hljs-keyword">boolean</span> transparentGzip = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">//默认使用Gzip压缩</span>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Accept-Encoding"</span>) == <span class="hljs-keyword">null</span> &amp;&amp; userRequest.header(<span class="hljs-string">"Range"</span>) == <span class="hljs-keyword">null</span>) &#123;      transparentGzip = <span class="hljs-keyword">true</span>;      requestBuilder.header(<span class="hljs-string">"Accept-Encoding"</span>, <span class="hljs-string">"gzip"</span>);    &#125;    <span class="hljs-comment">//设置 Cookie信息</span>    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());    <span class="hljs-keyword">if</span> (!cookies.isEmpty()) &#123;      requestBuilder.header(<span class="hljs-string">"Cookie"</span>, cookieHeader(cookies));    &#125;    <span class="hljs-comment">//设置UA</span>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"User-Agent"</span>) == <span class="hljs-keyword">null</span>) &#123;      requestBuilder.header(<span class="hljs-string">"User-Agent"</span>, Version.userAgent());    &#125;    <span class="hljs-comment">//传递至下一个拦截器处理</span>    Response networkResponse = chain.proceed(requestBuilder.build());    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());    Response.Builder responseBuilder = networkResponse.newBuilder()        .request(userRequest);    <span class="hljs-comment">//如果服务器支持Gzip压缩，需要进行解压操作</span>    <span class="hljs-keyword">if</span> (transparentGzip        &amp;&amp; <span class="hljs-string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="hljs-string">"Content-Encoding"</span>))        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;      GzipSource responseBody = <span class="hljs-keyword">new</span> GzipSource(networkResponse.body().source());      Headers strippedHeaders = networkResponse.headers().newBuilder()          .removeAll(<span class="hljs-string">"Content-Encoding"</span>)          .removeAll(<span class="hljs-string">"Content-Length"</span>)          .build();      responseBuilder.headers(strippedHeaders);      String contentType = networkResponse.header(<span class="hljs-string">"Content-Type"</span>);      responseBuilder.body(<span class="hljs-keyword">new</span> RealResponseBody(contentType, -<span class="hljs-number">1L</span>, Okio.buffer(responseBody)));    &#125;    <span class="hljs-keyword">return</span> responseBuilder.build();  &#125;&#125;</code></pre><blockquote><p><code>GZip</code>：是一种压缩技术，可以改进Web应用的性能，将请求体明显的减少其大小，如果服务器也支持该格式，就会返回对应格式的内容，客户端需要进行解压操作，可以明显的减少流量消耗。</p></blockquote><p><code>BridgeInterceptor</code>主要执行了以下3步：</p><ul><li><p>用户请求转换为网络请求</p><p>在原来<code>Request</code>上添加了很多<code>Header</code>，例如<code>Content-Type(定义网络文件的类型和网页的编码)、Content-Length(请求体内容长度)、Transfer-Encoding(请求体的大小)与Content-Length互斥、Accept-Encoding(编码格式)</code>。</p><p>未设置<code>Accept-Encoding</code>默认为<code>gzip</code>。</p></li><li><p>执行转换后的网络请求</p><p><code>chain.proceed(requestBuilder.build())</code></p></li><li><p>服务器返回的响应结果转换为用户响应结果</p><p>根据上一步获得<code>Response</code>后，需要再次转化为用户直观格式。主要在于服务端返回的信息里是否设置了<code>Accept-Encoding:gzip</code>，设置了则需要进行解压过程，获取最终结果。</p></li></ul><h5 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a><code>CacheInterceptor</code></h5><p><img src="/images/OkHttp-CacheInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-CacheInterceptor"></p><blockquote><p>主要用于<strong>读取缓存以及更新缓存的</strong>，<strong>为了节省流量和提高响应速度</strong>。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">//根据请求的相关信息获取缓存</span>    Response cacheCandidate = cache != <span class="hljs-keyword">null</span>        ? cache.get(chain.request())        : <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">long</span> now = System.currentTimeMillis();    <span class="hljs-comment">//创建缓存策略</span>    CacheStrategy strategy = <span class="hljs-keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();①    Request networkRequest = strategy.networkRequest;    Response cacheResponse = strategy.cacheResponse;    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;      cache.trackResponse(strategy);    &#125;    <span class="hljs-comment">//缓存无法使用，关闭获得的Response</span>    <span class="hljs-keyword">if</span> (cacheCandidate != <span class="hljs-keyword">null</span> &amp;&amp; cacheResponse == <span class="hljs-keyword">null</span>) &#123;      closeQuietly(cacheCandidate.body()); <span class="hljs-comment">// The cache candidate wasn't applicable. Close it.</span>    &#125;    <span class="hljs-comment">// 根据策略，不使用网络且没有缓存的直接报错，返回504</span>    <span class="hljs-keyword">if</span> (networkRequest == <span class="hljs-keyword">null</span> &amp;&amp; cacheResponse == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response.Builder()          .request(chain.request())          .protocol(Protocol.HTTP_1_1)          .code(<span class="hljs-number">504</span>)          .message(<span class="hljs-string">"Unsatisfiable Request (only-if-cached)"</span>)          .body(Util.EMPTY_RESPONSE)          .sentRequestAtMillis(-<span class="hljs-number">1L</span>)          .receivedResponseAtMillis(System.currentTimeMillis())          .build();    &#125;    <span class="hljs-comment">// 直接返回缓存，不允许使用网络</span>    <span class="hljs-keyword">if</span> (networkRequest == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> cacheResponse.newBuilder()          .cacheResponse(stripBody(cacheResponse))          .build();    &#125;    Response networkResponse = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//请求向下传递</span>      networkResponse = chain.proceed(networkRequest);    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span>      <span class="hljs-keyword">if</span> (networkResponse == <span class="hljs-keyword">null</span> &amp;&amp; cacheCandidate != <span class="hljs-keyword">null</span>) &#123;        closeQuietly(cacheCandidate.body());      &#125;    &#125;    <span class="hljs-comment">// 接受到服务器返回数据，如果返回code为 304 直接使用缓存结果</span>    <span class="hljs-keyword">if</span> (cacheResponse != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;        Response response = cacheResponse.newBuilder()            .headers(combine(cacheResponse.headers(), networkResponse.headers()))            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())            .cacheResponse(stripBody(cacheResponse))            .networkResponse(stripBody(networkResponse))            .build();        networkResponse.body().close();        <span class="hljs-comment">// Update the cache after combining headers but before stripping the</span>        <span class="hljs-comment">// Content-Encoding header (as performed by initContentStream()).</span>        cache.trackConditionalCacheHit();        <span class="hljs-comment">//更新当前存储的缓存信息</span>        cache.update(cacheResponse, response);        <span class="hljs-keyword">return</span> response;      &#125; <span class="hljs-keyword">else</span> &#123;        closeQuietly(cacheResponse.body());      &#125;    &#125;    <span class="hljs-comment">//读取服务器返回结果</span>    Response response = networkResponse.newBuilder()        .cacheResponse(stripBody(cacheResponse))        .networkResponse(stripBody(networkResponse))        .build();    <span class="hljs-comment">//对数据进行缓存</span>    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;        <span class="hljs-comment">// Offer this request to the cache.</span>        CacheRequest cacheRequest = cache.put(response);        <span class="hljs-keyword">return</span> cacheWritingResponse(cacheRequest, response);      &#125;      <span class="hljs-keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;        <span class="hljs-keyword">try</span> &#123;          cache.remove(networkRequest);        &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;          <span class="hljs-comment">// The cache cannot be written.</span>        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> response;  &#125;&#125;</code></pre><p><code>CacheInterceptor</code>的执行流程如下所示：</p><ol><li>先行读取缓存数据</li><li>创建好对应的缓存策略：<code>强制缓存</code>、<code>对比缓存</code></li><li>根据缓存策略，不使用网络、也没有对应缓存，返回<code>504</code></li><li>根据缓存策略，不使用网络，存在缓存则直接返回</li><li>前面都没有返回结果，继续向下执行请求：<code>chain.proceed()</code></li><li>接受到对应网络结果，如果返回code为<code>304</code>，代表直接使用缓存并更新对应缓存信息</li><li>读取网络结果，对数据进行缓存</li><li>返回获取的网络结果</li></ol><p>具体的缓存策略请参考<a href="#OkHttp缓存机制">缓存策略</a></p><h5 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a><code>ConnectInterceptor</code></h5><p><img src="/images/OkHttp-ConnectInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-ConnectInterceptor"></p><blockquote><p>真正与服务端建立连接，底层是通过<code>Socket</code>进行连接。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> OkHttpClient client;  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    RealInterceptorChain realChain = (RealInterceptorChain) chain;    Request request = realChain.request();    Transmitter transmitter = realChain.transmitter();    <span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span>    <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="hljs-string">"GET"</span>);    <span class="hljs-comment">//建立连接</span>    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);    <span class="hljs-comment">//继续请求下一个拦截器</span>    <span class="hljs-keyword">return</span> realChain.proceed(request, transmitter, exchange);  &#125;&#125;</code></pre><p><code>ConnectInterceptor</code>主要功能是建立与服务器的连接关系，通过<code>Transmitter.newExchange()</code>建立连接，建立完成后继续向下执行请求。</p><p>具体的连接过程可以参考<a href="# OkHttp连接机制">连接机制</a></p><h5 id="NetworkInterceptor"><a href="#NetworkInterceptor" class="headerlink" title="NetworkInterceptor"></a><code>NetworkInterceptor</code></h5><p><img src="/images/OkHttp-NetworkInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-NetworkInterceptor"></p><blockquote><p>用户自定义的网络拦截器，处于第6个拦截器，前面经过了<code>RetryAndFolowUpInterceptor</code>的重定向过程以及<code>BridgeInterceptor</code>的请求头处理，在此处可以获取到更多的连接信息。</p></blockquote><p>引用代码</p><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient.Builder()    .addNetworkInterceptor(<span class="hljs-keyword">new</span> LoggingInterceptor())    .build();</code></pre><blockquote><p><code>NetworkInterceptor</code>可以获取到最终请求的<code>Request</code>，以及获取到真正进行过网络请求的得到的<code>Response</code>，从而可以针对<code>Response</code>进行修改然后再回传到上层拦截器。</p></blockquote><p><code>NetworkInterceptor</code>主要有以下特点：</p><ul><li>可以操作经过<code>重定向、重试</code>得到的<code>Response</code></li><li>无法响应缓存数据的请求，因为<code>CacheInterceptor</code>执行在它之前</li><li>得到最终进行请求的<code>Request</code></li><li>可以获得连接信息</li></ul><h5 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a><code>CallServerInterceptor</code></h5><p><img src="/images/OkHttp-CallServerInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-CallServerInterceptor"></p><blockquote><p>数据的写入过程，也就是客户端和服务端进行交互的过程，客户端发送数据，服务端返回数据。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallServerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    RealInterceptorChain realChain = (RealInterceptorChain) chain;    Exchange exchange = realChain.exchange();    Request request = realChain.request();    <span class="hljs-keyword">long</span> sentRequestMillis = System.currentTimeMillis();    <span class="hljs-comment">//写入请求头</span>    exchange.writeRequestHeaders(request);    <span class="hljs-keyword">boolean</span> responseHeadersStarted = <span class="hljs-keyword">false</span>;    Response.Builder responseBuilder = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//判断当前是否有 请求体body</span>    <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span>      <span class="hljs-comment">// Continue" response before transmitting the request body. If we don't get that, return</span>      <span class="hljs-comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span>      <span class="hljs-comment">//如果是1XX的话 表示当前需要等服务端响应 </span>      <span class="hljs-keyword">if</span> (<span class="hljs-string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="hljs-string">"Expect"</span>))) &#123;        exchange.flushRequest();        responseHeadersStarted = <span class="hljs-keyword">true</span>;        exchange.responseHeadersStart();        responseBuilder = exchange.readResponseHeaders(<span class="hljs-keyword">true</span>);      &#125;            <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//写入请求体</span>        <span class="hljs-keyword">if</span> (request.body().isDuplex()) &#123;          <span class="hljs-comment">// Prepare a duplex body so that the application can send a request body later.</span>          exchange.flushRequest();          BufferedSink bufferedRequestBody = Okio.buffer(              exchange.createRequestBody(request, <span class="hljs-keyword">true</span>));          request.body().writeTo(bufferedRequestBody);        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span>          BufferedSink bufferedRequestBody = Okio.buffer(              exchange.createRequestBody(request, <span class="hljs-keyword">false</span>));          request.body().writeTo(bufferedRequestBody);          bufferedRequestBody.close();        &#125;      &#125; <span class="hljs-keyword">else</span> &#123;        exchange.noRequestBody();        <span class="hljs-keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;          <span class="hljs-comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span>          <span class="hljs-comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span>          <span class="hljs-comment">// leave the connection in a consistent state.</span>          exchange.noNewExchangesOnConnection();        &#125;      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      exchange.noRequestBody();    &#125;    <span class="hljs-keyword">if</span> (request.body() == <span class="hljs-keyword">null</span> || !request.body().isDuplex()) &#123;        <span class="hljs-comment">//结束请求</span>      exchange.finishRequest();    &#125;    <span class="hljs-keyword">if</span> (!responseHeadersStarted) &#123;      exchange.responseHeadersStart();    &#125;    <span class="hljs-comment">//得到响应头</span>    <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-keyword">null</span>) &#123;      responseBuilder = exchange.readResponseHeaders(<span class="hljs-keyword">false</span>);    &#125;        Response response = responseBuilder        .request(request)        .handshake(exchange.connection().handshake())        .sentRequestAtMillis(sentRequestMillis)        .receivedResponseAtMillis(System.currentTimeMillis())        .build();    <span class="hljs-comment">//读取响应体内容</span>    <span class="hljs-keyword">int</span> code = response.code();    <span class="hljs-keyword">if</span> (code == <span class="hljs-number">100</span>) &#123;      <span class="hljs-comment">// server sent a 100-continue even though we did not request one.</span>      <span class="hljs-comment">// try again to read the actual response</span>      response = exchange.readResponseHeaders(<span class="hljs-keyword">false</span>)          .request(request)          .handshake(exchange.connection().handshake())          .sentRequestAtMillis(sentRequestMillis)          .receivedResponseAtMillis(System.currentTimeMillis())          .build();      code = response.code();    &#125;    exchange.responseHeadersEnd(response);    <span class="hljs-comment">//forWebSocket 表示为socket连接方式</span>    <span class="hljs-keyword">if</span> (forWebSocket &amp;&amp; code == <span class="hljs-number">101</span>) &#123;      <span class="hljs-comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span>      response = response.newBuilder()          .body(Util.EMPTY_RESPONSE)          .build();    &#125; <span class="hljs-keyword">else</span> &#123;      response = response.newBuilder()          .body(exchange.openResponseBody(response))          .build();    &#125;    <span class="hljs-comment">// close表示关闭连接</span>    <span class="hljs-keyword">if</span> (<span class="hljs-string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="hljs-string">"Connection"</span>))        || <span class="hljs-string">"close"</span>.equalsIgnoreCase(response.header(<span class="hljs-string">"Connection"</span>))) &#123;      exchange.noNewExchangesOnConnection();    &#125;    <span class="hljs-keyword">if</span> ((code == <span class="hljs-number">204</span> || code == <span class="hljs-number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(          <span class="hljs-string">"HTTP "</span> + code + <span class="hljs-string">" had non-zero Content-Length: "</span> + response.body().contentLength());    &#125;    <span class="hljs-keyword">return</span> response;  &#125;&#125;</code></pre><p><code>CallServerInterceptor</code>主要执行了以下过程：</p><ul><li>写入请求头</li><li>写入请求体(如果存在)</li><li>获取状态行及响应头</li><li>获取响应体</li></ul><p><code>CallServerInterceptor</code>已经是最后一个拦截器了，接下来就是向上回溯并返回自己获得的<code>Response</code>。</p><blockquote><p>HTTP报文结构：</p><p><strong>请求报文</strong>：</p><p>请求行：声明请求方法、主机域名及协议版本</p><p>请求头：声明客户端的部分报文信息</p><p>请求体：存放客户端发送给服务器的数据</p><p><strong>响应报文</strong></p><p>状态行：声明HTTP协议版本、状态码及描述</p><p>响应头：声明服务端的部分报文信息</p><p>响应体：服务端返回客户端的数据</p></blockquote><h4 id="责任链模式串联"><a href="#责任链模式串联" class="headerlink" title="责任链模式串联"></a>责任链模式串联</h4><p>介绍完上述的拦截器后，接下来就是分析如何将这些拦截器进行串联调用。</p><pre><code class="hljs java"><span class="hljs-function">Response <span class="hljs-title">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// Build a full stack of interceptors.</span>    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    ...    <span class="hljs-comment">//构建责任链</span>    Interceptor.Chain chain = <span class="hljs-keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>,        originalRequest, <span class="hljs-keyword">this</span>, client.connectTimeoutMillis(),        client.readTimeoutMillis(), client.writeTimeoutMillis());    <span class="hljs-keyword">boolean</span> calledNoMoreExchanges = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-comment">//开始从头链式调用拦截器</span>      Response response = chain.proceed(originalRequest);      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;        closeQuietly(response);        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);      &#125;      <span class="hljs-keyword">return</span> response;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;      calledNoMoreExchanges = <span class="hljs-keyword">true</span>;      <span class="hljs-keyword">throw</span> transmitter.noMoreExchanges(e);    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;        transmitter.noMoreExchanges(<span class="hljs-keyword">null</span>);      &#125;    &#125;  &#125;</code></pre><p>实际执行链式调用的是<code>RealInterceptorChain</code>，由他负责责任链的执行</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealInterceptorChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span>.<span class="hljs-title">Chain</span> </span>&#123;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">return</span> proceed(request, transmitter, exchange);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span>      <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">if</span> (index &gt;= interceptors.size()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();    calls++;    <span class="hljs-comment">// 存在已经在使用的流，直接进行复用</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.exchange != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"network interceptor "</span> + interceptors.get(index - <span class="hljs-number">1</span>)          + <span class="hljs-string">" must retain the same host and port"</span>);    &#125;    <span class="hljs-comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.exchange != <span class="hljs-keyword">null</span> &amp;&amp; calls &gt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"network interceptor "</span> + interceptors.get(index - <span class="hljs-number">1</span>)          + <span class="hljs-string">" must call proceed() exactly once"</span>);    &#125;    <span class="hljs-comment">// 调用该链中的下一个拦截器 实质为 用户自定义的拦截器，不存在则为 RetryAndFollowUpInterceptor</span>    RealInterceptorChain next = <span class="hljs-keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,        index + <span class="hljs-number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);    Interceptor interceptor = interceptors.get(index);    Response response = interceptor.intercept(next);    <span class="hljs-comment">// Confirm that the next interceptor made its required call to chain.proceed().</span>    <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span> &amp;&amp; index + <span class="hljs-number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"network interceptor "</span> + interceptor          + <span class="hljs-string">" must call proceed() exactly once"</span>);    &#125;    <span class="hljs-comment">// Confirm that the intercepted response isn't null.</span>    <span class="hljs-keyword">if</span> (response == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"interceptor "</span> + interceptor + <span class="hljs-string">" returned null"</span>);    &#125;    <span class="hljs-keyword">if</span> (response.body() == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(          <span class="hljs-string">"interceptor "</span> + interceptor + <span class="hljs-string">" returned a response with no body"</span>);    &#125;    <span class="hljs-keyword">return</span> response;  &#125;&#125;</code></pre><p><code>RealIntercrptor</code>为链式调用的起点，调用<code>proceed()</code>之后，继续调用下一层的拦截器，直到得到最终的Response。</p><p>后续的拦截器也是按照这个规则向下执行，内部都会调用到<code>chain.proceed()</code>直到没有调用为止。</p><p><strong>Request是按照定义的<code>interceptor</code>顺序向下执行，然后Response是逆向向上处理的。</strong></p><h3 id="获取请求结果Response"><a href="#获取请求结果Response" class="headerlink" title="获取请求结果Response"></a>获取请求结果<code>Response</code></h3><blockquote><p><code>Response</code>：返回HTTP请求响应结果，包含了状态码，响应正文等</p></blockquote><p>在<code>CallServerInterceptor</code>得到最初格式的<code>Response</code></p><pre><code class="hljs java"><span class="hljs-comment">//获得状态行及响应头  </span><span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> Response.<span class="hljs-function">Builder <span class="hljs-title">readResponseHeaders</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> expectContinue)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">try</span> &#123;      Response.Builder result = codec.readResponseHeaders(expectContinue);      <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;        Internal.instance.initExchange(result, <span class="hljs-keyword">this</span>);      &#125;      <span class="hljs-keyword">return</span> result;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;      eventListener.responseFailed(call, e);      trackFailure(e);      <span class="hljs-keyword">throw</span> e;    &#125;  &#125;<span class="hljs-comment">//获得响应正文</span><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseBody <span class="hljs-title">openResponseBody</span><span class="hljs-params">(Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">try</span> &#123;      eventListener.responseBodyStart(call);      String contentType = response.header(<span class="hljs-string">"Content-Type"</span>);      <span class="hljs-keyword">long</span> contentLength = codec.reportedContentLength(response);      Source rawSource = codec.openResponseBodySource(response);      ResponseBodySource source = <span class="hljs-keyword">new</span> ResponseBodySource(rawSource, contentLength);      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RealResponseBody(contentType, contentLength, Okio.buffer(source));    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;      eventListener.responseFailed(call, e);      trackFailure(e);      <span class="hljs-keyword">throw</span> e;    &#125;  &#125;</code></pre><p><img src="/images/OkHttp执行流程.png" srcset="/img/loading.gif" alt="OkHttp执行流程"></p><h2 id="OkHttp缓存机制"><a href="#OkHttp缓存机制" class="headerlink" title="OkHttp缓存机制"></a>OkHttp缓存机制</h2><h3 id="Http缓存"><a href="#Http缓存" class="headerlink" title="Http缓存"></a>Http缓存</h3><p><img src="/images/OkHttp-HTTP缓存机制.png" srcset="/img/loading.gif" alt="OkHttp-HTTP缓存机制"></p><blockquote><p>Http缓存是web性能优化的重要手段，缓存机制是依赖于<code>header</code>中的参数实现的，这些参数指定了缓存需要<em>从缓存中获取</em>还是<em>从服务端获取</em>。</p></blockquote><p>Http缓存有多种规则，根据是否需要重新向服务器发起请求来进行分类：</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><blockquote><p>当客户端第一次请求数据时，服务端在响应头会携带<strong>缓存规则信息</strong>，主要为两个字段：<strong>Expires</strong>、<strong>Cache-Control</strong></p><p>当再次请求数据时，如果符合缓存规则，则直接使用缓存数据，无需与服务端重新交互。</p></blockquote><p><img src="/images/强制缓存流程.png" srcset="/img/loading.gif" alt="强制缓存流程"></p><p>强制缓存在缓存未失效的情况下，可以直接使用缓存数据，接下来介绍<code>判断缓存数据是否失效</code>。<br>上文提到，强制缓存是根据两个Header字段进行判定的，这两个字段表示了<code>失效规则</code>。</p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><del>Expires</del></h5><blockquote><p>服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。<br><em>这参数是HTTP1.0的东西了，现在主流的是HTTP1.1。</em><br>可能由于客户端时间没有与服务端时间同步而导致缓存命中的误差。</p></blockquote><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><blockquote><p>在HTTP1.1中替代<code>Expires</code>，功能与其一致。<br><code>Cache-Control</code>常见的取值有如下几种：</p><ul><li><code>private</code>：客户端可以进行缓存</li><li><code>public</code>：客户端以及代理服务器都可以进行缓存</li><li><code>max-age= XX</code>：缓存数据在 XX秒后失效</li><li><code>no-cache</code>：需要使用到<code>对比缓存</code></li><li><code>no-store</code>：所有内容都不进行缓存</li><li><code>s-maxage = XX</code>：限定缓存可以在代理服务器中存放多久</li></ul></blockquote><h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><blockquote><p>需要进行比较判断来确定是否使用缓存，当客户端第一次请求数据时，服务端会返回<strong>缓存标识</strong>以及数据给客户端，客户端对两者都要进行备份到缓存，当再次请求数据时，客户端会带上<strong>缓存标识</strong>发送给服务端，服务端对标识进行判断，返回code值。返回若为<strong>304</strong>，则继续使用缓存。</p></blockquote><p><img src="/images/对比缓存流程.png" srcset="/img/loading.gif" alt="对比缓存流程"></p><p>在<strong>缓存标识</strong>未失效时，可以继续使用缓存数据，每次都需要与服务端进行交互去验证<strong>缓存标识</strong>。<br>对比缓存也是依据两个Header字段进行判定的，这两个字段表示了<code>缓存标识</code>。</p><h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p><code>Last-Modified</code>：服务端返回给客户端，表示资源的最后修改时间。<br><code>If-Modified-Since</code>：客户端发给服务端，表示服务端上次返回的资源最后修改时间。<br>服务端接收到<code>If-Modified-Since</code>后，与被请求资源的最后修改时间进行比对。</p><ul><li>若大于，返回最新资源并返回code为200，客户端需要重新进行缓存</li><li>否则，说明资源无修改并返回code为304，客户端继续使用缓存数据</li></ul><h5 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h5><p><code>ETag</code>：服务端返回给客户端，表示当前资源在服务器的唯一标识。<br><code>If-None-Match</code>：客户端发送给服务端，表示服务端上次返回的资源唯一标识。<br>服务端接收到<code>If-None-Match</code>后，与被请求资源的唯一标识进行比对</p><ul><li>标识不同，表示资源被改动过，返回最新资源及设置code为200，客户端需要重新进行缓存</li><li>标识相同，表示资源未被改动，返回code为304，客户端继续使用缓存数据</li></ul><p>其中<code>ETag/If-None-Match</code>的优先级是高于<code>Last-Modified/If-Modified-Since</code>的</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><ul><li>强制缓存的优先级是高于对比缓存的</li><li>对于<code>强制缓存</code>，服务端会给予一个过期时间，在有效期内再次请求都只会使用缓存，不会请求服务端。</li><li>超过有效期就使用<code>对比缓存</code>策略，将服务端返回的<code>ETag/Last-Modified</code>发还给服务端进行验证，有效则继续使用缓存数据(<em>返回code为304</em>)，无效则重新获取并进行缓存(<em>返回code为200</em>)。</li></ul></blockquote><h3 id="缓存存储"><a href="#缓存存储" class="headerlink" title="缓存存储"></a>缓存存储</h3><p><img src="/images/OkHttp缓存实现.png" srcset="/img/loading.gif" alt="OkHttp缓存实现"></p><p>介绍完毕Http的缓存机制后，接下来就是看<code>OkHttp</code>中的源码实现<br><pre><code class="hljs java">CacheStrategy(Request networkRequest, Response cacheResponse) &#123;  <span class="hljs-keyword">this</span>.networkRequest = networkRequest;  <span class="hljs-keyword">this</span>.cacheResponse = cacheResponse;&#125;</code></pre></p><p>缓存策略主要通过<code>CacheStrategy</code>类实现，关键参数为<code>networkRequest(网络请求)</code>、<code>cacheResponse(缓存的响应结果)</code>。<br><code>CacheStrategy</code>通过工厂模式进行构建的，最终通过调用<code>getCandidate()</code>来生成不同模式。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> CacheStrategy <span class="hljs-title">getCandidate</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">// 没缓存直接进行重新请求</span>      <span class="hljs-keyword">if</span> (cacheResponse == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);      &#125;      <span class="hljs-comment">// 如果是HTTPs且握手信息丢失进行重新请求</span>      <span class="hljs-keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);      &#125;      <span class="hljs-comment">//判断缓存已经失效 重新进行请求</span>      <span class="hljs-keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);      &#125;      <span class="hljs-comment">// </span>      CacheControl requestCaching = request.cacheControl();      <span class="hljs-keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);      &#125;      CacheControl responseCaching = cacheResponse.cacheControl();      <span class="hljs-comment">//</span>      <span class="hljs-keyword">long</span> ageMillis = cacheResponseAge();      <span class="hljs-keyword">long</span> freshMillis = computeFreshnessLifetime();      <span class="hljs-keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="hljs-number">1</span>) &#123;        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));      &#125;      <span class="hljs-keyword">long</span> minFreshMillis = <span class="hljs-number">0</span>;      <span class="hljs-keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="hljs-number">1</span>) &#123;        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());      &#125;      <span class="hljs-keyword">long</span> maxStaleMillis = <span class="hljs-number">0</span>;      <span class="hljs-keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="hljs-number">1</span>) &#123;        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());      &#125;      <span class="hljs-comment">//处于强制缓存状态，直接返回缓存数据</span>      <span class="hljs-keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;        Response.Builder builder = cacheResponse.newBuilder();        <span class="hljs-keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;          builder.addHeader(<span class="hljs-string">"Warning"</span>, <span class="hljs-string">"110 HttpURLConnection \"Response is stale\""</span>);        &#125;        <span class="hljs-keyword">long</span> oneDayMillis = <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000L</span>;        <span class="hljs-keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;          builder.addHeader(<span class="hljs-string">"Warning"</span>, <span class="hljs-string">"113 HttpURLConnection \"Heuristic expiration\""</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(<span class="hljs-keyword">null</span>, builder.build());      &#125;      <span class="hljs-comment">// Find a condition to add to the request. If the condition is satisfied, the response body</span>      <span class="hljs-comment">// will not be transmitted.</span>      String conditionName;      String conditionValue;      <span class="hljs-keyword">if</span> (etag != <span class="hljs-keyword">null</span>) &#123;        conditionName = <span class="hljs-string">"If-None-Match"</span>;        conditionValue = etag;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastModified != <span class="hljs-keyword">null</span>) &#123;        conditionName = <span class="hljs-string">"If-Modified-Since"</span>;        conditionValue = lastModifiedString;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (servedDate != <span class="hljs-keyword">null</span>) &#123;        conditionName = <span class="hljs-string">"If-Modified-Since"</span>;        conditionValue = servedDateString;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// No condition! Make a regular request.</span>      &#125;      <span class="hljs-comment">//交由服务端去进行判断</span>      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);      Request conditionalRequest = request.newBuilder()          .headers(conditionalRequestHeaders.build())          .build();      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);    &#125;</code></pre><p><code>CacheStrategy</code>根据之前的缓存结果以及要发送的<code>request的header</code>计算缓存策略</p><table><thead><tr><th>networkRequest</th><th>cacheResponse</th><th>CacheStrategy</th></tr></thead><tbody><tr><td>null</td><td>null</td><td>不进行网络请求且缓存不存在或过期<br>返回504错误</td></tr><tr><td>null</td><td>not null</td><td>不进行网络请求但是存在缓存且有效<br>直接返回缓存数据</td></tr><tr><td>not null</td><td>null</td><td>进行网络请求且缓存不存在或过期<br>直接进行网络请求获取数据</td></tr><tr><td>not null</td><td>not null</td><td>进行网络请求，请求头包含<code>ETag/Last-Modified</code>且缓存存在<br>根据网络请求结果判断<br>返回304，使用缓存<br>返回200，使用请求数据且更新缓存</td></tr></tbody></table><h2 id="OkHttp连接机制"><a href="#OkHttp连接机制" class="headerlink" title="OkHttp连接机制"></a>OkHttp连接机制</h2><p>在<code>ConnectInterceptor</code>中进行了与服务端的连接，通过<code>Exchange</code>类进行连接。<br><pre><code class="hljs java"><span class="hljs-function">Exchange <span class="hljs-title">newExchange</span><span class="hljs-params">(Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;  <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;    <span class="hljs-keyword">if</span> (noMoreExchanges) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"released"</span>);    <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"exchange != null"</span>);  &#125;  <span class="hljs-comment">//建立连接</span>  ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);  Exchange result = <span class="hljs-keyword">new</span> Exchange(<span class="hljs-keyword">this</span>, call, eventListener, exchangeFinder, codec);  <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;    <span class="hljs-keyword">this</span>.exchange = result;    <span class="hljs-keyword">this</span>.exchangeRequestDone = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">this</span>.exchangeResponseDone = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">return</span> result;  &#125;&#125;</code></pre></p><h3 id="通过Socket连接服务端"><a href="#通过Socket连接服务端" class="headerlink" title="通过Socket连接服务端"></a>通过Socket连接服务端</h3><p>通过<code>ExchangeCodec.find()</code>来设置连接或者复用<br><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ExchangeCodec <span class="hljs-title">find</span><span class="hljs-params">(      OkHttpClient client, Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;    <span class="hljs-keyword">int</span> connectTimeout = chain.connectTimeoutMillis();    <span class="hljs-keyword">int</span> readTimeout = chain.readTimeoutMillis();    <span class="hljs-keyword">int</span> writeTimeout = chain.writeTimeoutMillis();    <span class="hljs-keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();    <span class="hljs-keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();    <span class="hljs-keyword">try</span> &#123;      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);      <span class="hljs-keyword">return</span> resultConnection.newCodec(client, chain);    &#125; <span class="hljs-keyword">catch</span> (RouteException e) &#123;      trackFailure();      <span class="hljs-keyword">throw</span> e;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;      trackFailure();      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RouteException(e);    &#125;  &#125;  <span class="hljs-comment">//返回一个健康的连接 </span>  <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findHealthyConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout,      <span class="hljs-keyword">int</span> writeTimeout, <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled,      <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,          pingIntervalMillis, connectionRetryEnabled);      <span class="hljs-comment">// If this is a brand new connection, we can skip the extensive health checks.</span>      <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;        <span class="hljs-keyword">if</span> (candidate.successCount == <span class="hljs-number">0</span>) &#123;          <span class="hljs-keyword">return</span> candidate;        &#125;      &#125;      <span class="hljs-comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span>      <span class="hljs-comment">// isn't, take it out of the pool and start again.</span>      <span class="hljs-keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;        candidate.noNewExchanges();        <span class="hljs-keyword">continue</span>;      &#125;      <span class="hljs-keyword">return</span> candidate;    &#125;  &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout, <span class="hljs-keyword">int</span> writeTimeout,      <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">boolean</span> foundPooledConnection = <span class="hljs-keyword">false</span>;    RealConnection result = <span class="hljs-keyword">null</span>;    Route selectedRoute = <span class="hljs-keyword">null</span>;    RealConnection releasedConnection;    Socket toClose;    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);      hasStreamFailure = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// This is a fresh attempt.</span>            Route previousRoute = retryCurrentRoute()          ? transmitter.connection.route()          : <span class="hljs-keyword">null</span>;      <span class="hljs-comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span>      <span class="hljs-comment">// already-allocated connection may have been restricted from creating new exchanges.</span>      releasedConnection = transmitter.connection;      toClose = transmitter.connection != <span class="hljs-keyword">null</span> &amp;&amp; transmitter.connection.noNewExchanges          ? transmitter.releaseConnectionNoEvents()          : <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span> (transmitter.connection != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// We had an already-allocated connection and it's good.</span>        result = transmitter.connection;        releasedConnection = <span class="hljs-keyword">null</span>;      &#125;      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// Attempt to get a connection from the pool.</span>        <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>)) &#123;          foundPooledConnection = <span class="hljs-keyword">true</span>;          result = transmitter.connection;        &#125; <span class="hljs-keyword">else</span> &#123;          selectedRoute = previousRoute;        &#125;      &#125;    &#125;    closeQuietly(toClose);    <span class="hljs-keyword">if</span> (releasedConnection != <span class="hljs-keyword">null</span>) &#123;      eventListener.connectionReleased(call, releasedConnection);    &#125;    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;      eventListener.connectionAcquired(call, result);    &#125;    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// If we found an already-allocated or pooled connection, we're done.</span>      <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">// If we need a route selection, make one. This is a blocking operation.</span>    <span class="hljs-keyword">boolean</span> newRouteSelection = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span> &amp;&amp; (routeSelection == <span class="hljs-keyword">null</span> || !routeSelection.hasNext())) &#123;      newRouteSelection = <span class="hljs-keyword">true</span>;      routeSelection = routeSelector.next();    &#125;    List&lt;Route&gt; routes = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;        <span class="hljs-comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span>        <span class="hljs-comment">// the pool. This could match due to connection coalescing.</span>        routes = routeSelection.getAll();        <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(            address, transmitter, routes, <span class="hljs-keyword">false</span>)) &#123;          foundPooledConnection = <span class="hljs-keyword">true</span>;          result = transmitter.connection;        &#125;      &#125;      <span class="hljs-comment">//没有从连接池中获取到连接需要重新建立</span>      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span>) &#123;          selectedRoute = routeSelection.next();        &#125;        <span class="hljs-comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span>        <span class="hljs-comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span>        result = <span class="hljs-keyword">new</span> RealConnection(connectionPool, selectedRoute);        connectingConnection = result;      &#125;    &#125;    <span class="hljs-comment">// If we found a pooled connection on the 2nd time around, we're done.</span>    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;      eventListener.connectionAcquired(call, result);      <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">// Do TCP + TLS handshakes. This is a blocking operation.</span>    <span class="hljs-comment">// 开始TCP三次握手以及TLS操作，为阻塞操作</span>    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,        connectionRetryEnabled, call, eventListener);    connectionPool.routeDatabase.connected(result.route());    Socket socket = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;      connectingConnection = <span class="hljs-keyword">null</span>;      <span class="hljs-comment">// Last attempt at connection coalescing, which only occurs if we attempted multiple</span>      <span class="hljs-comment">// concurrent connections to the same host.</span>      <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="hljs-keyword">true</span>)) &#123;        <span class="hljs-comment">// We lost the race! Close the connection we created and return the pooled connection.</span>        result.noNewExchanges = <span class="hljs-keyword">true</span>;        socket = result.socket();        result = transmitter.connection;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//加入连接池 等待复用</span>        connectionPool.put(result);        transmitter.acquireConnectionNoEvents(result);      &#125;    &#125;    closeQuietly(socket);    eventListener.connectionAcquired(call, result);    <span class="hljs-keyword">return</span> result;  &#125;</code></pre></p><p>最终通过<code>Socket.connect()</code>进行连接。</p><h3 id="连接池-ConnectionPool"><a href="#连接池-ConnectionPool" class="headerlink" title="连接池(ConnectionPool)"></a>连接池(ConnectionPool)</h3><p><img src="/images/OkHttp-连接池 ConnectionPool.png" srcset="/img/loading.gif" alt="OkHttp-连接池 ConnectionPool"></p><blockquote><p>频繁的进行Socket连接(三次握手)和Socket断开(四次挥手)非常消耗网络资源以及时间。在HTTP1.1之后提供了<code>keep-alive</code>这个header，可以实现长连接，有效的降低了延迟并提升了处理速度。<br>连接池就是为了<strong>复用已存在连接</strong>，可以有效降低创建连接的开销。</p></blockquote><h4 id="连接池构造方法以及成员变量"><a href="#连接池构造方法以及成员变量" class="headerlink" title="连接池构造方法以及成员变量"></a>连接池构造方法以及成员变量</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123;  <span class="hljs-comment">//后台清理线程</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span> <span class="hljs-comment">/* corePoolSize */</span>,      Integer.MAX_VALUE <span class="hljs-comment">/* maximumPoolSize */</span>, <span class="hljs-number">60L</span> <span class="hljs-comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp ConnectionPool"</span>, <span class="hljs-keyword">true</span>));     <span class="hljs-comment">//最大的空闲连接数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxIdleConnections;    <span class="hljs-comment">//连接最大持续时间</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> keepAliveDurationNs;    <span class="hljs-comment">//存储连接的双向队列</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, TimeUnit.MINUTES);    &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxIdleConnections, <span class="hljs-keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;    <span class="hljs-keyword">this</span>.maxIdleConnections = maxIdleConnections;    <span class="hljs-keyword">this</span>.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);    <span class="hljs-comment">// Put a floor on the keep alive duration, otherwise cleanup will spin loop.</span>    <span class="hljs-keyword">if</span> (keepAliveDuration &lt;= <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"keepAliveDuration &lt;= 0: "</span> + keepAliveDuration);    &#125;  &#125;&#125;</code></pre><p><code>ConnectionPool</code>支持配置以下变量</p><ul><li><code>maxIdleConnections</code>：最大空闲连接数，默认<code>5</code></li><li><code>keepAliveDurationNs</code>：最大连接保持时间，默认<code>5min</code></li></ul><p><code>Connection</code>连接池中的<code>Connection</code>任一超出以上配置，就需要执行清理。</p><p>可以通过以下方法配置连接池</p><pre><code class="hljs java">OkHttpClient.Builder builder = <span class="hljs-keyword">new</span> OkHttpClient.Builder()        .connectionPool(<span class="hljs-keyword">new</span> ConnectionPool()); <span class="hljs-comment">//配置连接池</span></code></pre><h4 id="连接池加入连接"><a href="#连接池加入连接" class="headerlink" title="连接池加入连接"></a>连接池加入连接</h4><p><img src="/images/1345862-20200603214235374-1759578389.png" srcset="/img/loading.gif" alt="双端队列"></p><p>通过<code>connections</code>存储<code>Connection</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(RealConnection connection)</span> </span>&#123;  <span class="hljs-keyword">assert</span> (Thread.holdsLock(<span class="hljs-keyword">this</span>));  <span class="hljs-keyword">if</span> (!cleanupRunning) &#123;<span class="hljs-comment">//当前清理线程没有运行</span>    cleanupRunning = <span class="hljs-keyword">true</span>;    executor.execute(cleanupRunnable);<span class="hljs-comment">//开启清理过程</span>  &#125;  connections.add(connection);<span class="hljs-comment">//加入队列</span>&#125;</code></pre><p>在外部执行<code>put()</code>时，连接加入连接池，并且开启清理线程去清理那些超出配置的连接。</p><p>外部执行<code>put()</code>路径如下</p><pre><code class="hljs java"><span class="hljs-comment">// ConnectInterceptor 连接拦截器，其中执行连接过程</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    RealInterceptorChain realChain = (RealInterceptorChain) chain;    Request request = realChain.request();    StreamAllocation streamAllocation = realChain.streamAllocation();    <span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span>    <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="hljs-string">"GET"</span>);    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);<span class="hljs-comment">//建立新连接</span>    RealConnection connection = streamAllocation.connection();    <span class="hljs-keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);&#125;  <span class="hljs-comment">// StreamAllocation </span>   <span class="hljs-function"><span class="hljs-keyword">public</span> HttpCodec <span class="hljs-title">newStream</span><span class="hljs-params">(      OkHttpClient client, Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;       ...    <span class="hljs-keyword">try</span> &#123;      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);<span class="hljs-comment">//寻找可用的连接</span>      HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="hljs-keyword">this</span>);      <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;        codec = resultCodec;        <span class="hljs-keyword">return</span> resultCodec;      &#125;    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RouteException(e);    &#125;  &#125;     <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findHealthyConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout,      <span class="hljs-keyword">int</span> writeTimeout, <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled,      <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,          pingIntervalMillis, connectionRetryEnabled);      ...      <span class="hljs-keyword">return</span> candidate;    &#125;  &#125;     <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout, <span class="hljs-keyword">int</span> writeTimeout,      <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    ...     <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;      <span class="hljs-keyword">if</span> (released) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"released"</span>);      <span class="hljs-keyword">if</span> (codec != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"codec != null"</span>);      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);      <span class="hljs-comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span>      <span class="hljs-comment">// already-allocated connection may have been restricted from creating new streams.</span>      releasedConnection = <span class="hljs-keyword">this</span>.connection;      toClose = releaseIfNoNewStreams();      ...      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// Attempt to get a connection from the pool.</span>        Internal.instance.get(connectionPool, address, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);<span class="hljs-comment">//根据address从连接池中获取对应连接</span>        <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;          foundPooledConnection = <span class="hljs-keyword">true</span>;          result = connection;        &#125; <span class="hljs-keyword">else</span> &#123;          selectedRoute = route;        &#125;      &#125;    &#125;     ...    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// If we found an already-allocated or pooled connection, we're done.</span>      <span class="hljs-keyword">return</span> result;    &#125;            ...           <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;        <span class="hljs-comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span>        <span class="hljs-comment">// the pool. This could match due to connection coalescing.</span>        List&lt;Route&gt; routes = routeSelection.getAll();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = routes.size(); i &lt; size; i++) &#123;          Route route = routes.get(i);          Internal.instance.get(connectionPool, address, <span class="hljs-keyword">this</span>, route);          <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;            foundPooledConnection = <span class="hljs-keyword">true</span>;            result = connection;            <span class="hljs-keyword">this</span>.route = route;            <span class="hljs-keyword">break</span>;          &#125;        &#125;      &#125;      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span>) &#123;          selectedRoute = routeSelection.next();        &#125;        <span class="hljs-comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span>        <span class="hljs-comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span>        route = selectedRoute;        refusedStreamCount = <span class="hljs-number">0</span>;        result = <span class="hljs-keyword">new</span> RealConnection(connectionPool, selectedRoute);<span class="hljs-comment">//连接池未找到对应连接，建立新连接</span>        acquire(result, <span class="hljs-keyword">false</span>);      &#125;    &#125;          ...        <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;      reportedAcquired = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// Pool the connection.</span>      Internal.instance.put(connectionPool, result);<span class="hljs-comment">//将新建的连接加入到连接池内</span>      <span class="hljs-comment">// If another multiplexed connection to the same address was created concurrently, then</span>      <span class="hljs-comment">// release this connection and acquire that one.</span>      <span class="hljs-keyword">if</span> (result.isMultiplexed()) &#123;        socket = Internal.instance.deduplicate(connectionPool, address, <span class="hljs-keyword">this</span>);        result = connection;      &#125;    &#125;        &#125;    <span class="hljs-comment">//OkHttpClient</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Call</span>.<span class="hljs-title">Factory</span>, <span class="hljs-title">WebSocket</span>.<span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-keyword">static</span> &#123;      Internal.instance = <span class="hljs-keyword">new</span> Internal() &#123;       ...        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RealConnection <span class="hljs-title">get</span><span class="hljs-params">(ConnectionPool pool, Address address,          StreamAllocation streamAllocation, Route route)</span> </span>&#123;           <span class="hljs-keyword">return</span> pool.get(address, streamAllocation, route);<span class="hljs-comment">//从连接池获取连接</span>        &#125;                  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(ConnectionPool pool, RealConnection connection)</span> </span>&#123;          pool.put(connection);<span class="hljs-comment">//向连接池添加连接</span>        &#125;       ...      &#125;  &#125;</code></pre><p>通过<code>ConnectInterceptor.intercept()</code>去建立连接，向下调用到<code>StreamAllocation.newStream()</code></p><p>在<code>newStream()</code>中继续执行到<code>findConnection()</code>，其中主要执行了两步</p><ol><li>从<code>ConnectionPool</code>寻找是否存有当前<code>address</code>对应的连接，调用<code>ConnectionPool.get(XXX)</code>，存在就返回对应连接。</li><li>不存在对应连接，执行<code>new RealConnection()</code>新建连接，并调用<code>ConnectionPool.put()</code>存储新连接</li></ol><p>对应的<code>get()、put()</code>都是通过<code>Internal.instance</code>调用的，其中<code>Internal</code>是一个抽象类，具体实现类对应的就是<code>OkHttpClient</code>。</p><h4 id="连接池清理连接"><a href="#连接池清理连接" class="headerlink" title="连接池清理连接"></a>连接池清理连接</h4><p>在使用<code>连接池</code>时，初始化了一个<code>Executor</code>线程池，这个主要就是为了在清理无效连接时去开启清理线程用的</p><pre><code class="hljs java">  <span class="hljs-comment">/**   * Background threads are used to cleanup expired connections. There will be at most a single   * thread running per connection pool. The thread pool executor permits the pool itself to be   * garbage collected.   * 清理过期的连接，且保证最多只能运行一个清理线程。   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span> <span class="hljs-comment">/* corePoolSize */</span>,      Integer.MAX_VALUE <span class="hljs-comment">/* maximumPoolSize */</span>, <span class="hljs-number">60L</span> <span class="hljs-comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp ConnectionPool"</span>, <span class="hljs-keyword">true</span>));<span class="hljs-comment">//清理过期连接任务</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable cleanupRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-keyword">long</span> waitNanos = cleanup(System.nanoTime());<span class="hljs-comment">//返回下次需要清理连接的时间</span>        <span class="hljs-keyword">if</span> (waitNanos == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (waitNanos &gt; <span class="hljs-number">0</span>) &#123;          <span class="hljs-keyword">long</span> waitMillis = waitNanos / <span class="hljs-number">1000000L</span>;          waitNanos -= (waitMillis * <span class="hljs-number">1000000L</span>);          <span class="hljs-keyword">synchronized</span> (ConnectionPool.<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">try</span> &#123;              ConnectionPool.<span class="hljs-keyword">this</span>.wait(waitMillis, (<span class="hljs-keyword">int</span>) waitNanos);<span class="hljs-comment">//阻塞等待</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;            &#125;          &#125;        &#125;      &#125;    &#125;  &#125;;</code></pre><h5 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup()"></a>cleanup()</h5><p>内部主要执行的是<code>标记空闲连接</code>、<code>清理空闲连接</code>，<code>返回下次清理时间</code>这几步</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">cleanup</span><span class="hljs-params">(<span class="hljs-keyword">long</span> now)</span> </span>&#123;  <span class="hljs-keyword">int</span> inUseConnectionCount = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> idleConnectionCount = <span class="hljs-number">0</span>;  RealConnection longestIdleConnection = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;  <span class="hljs-comment">// Find either a connection to evict, or the time that the next eviction is due.</span>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;    <span class="hljs-keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;<span class="hljs-comment">//遍历连接储存队列</span>      RealConnection connection = i.next();      <span class="hljs-comment">// If the connection is in use, keep searching.</span>      <span class="hljs-keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//标记正在使用的活跃连接</span>        inUseConnectionCount++;        <span class="hljs-keyword">continue</span>;      &#125;      idleConnectionCount++;<span class="hljs-comment">//非活跃标记为空闲连接</span>      <span class="hljs-comment">// If the connection is ready to be evicted, we're done.</span>      <span class="hljs-keyword">long</span> idleDurationNs = now - connection.idleAtNanos;      <span class="hljs-keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;        longestIdleDurationNs = idleDurationNs;        longestIdleConnection = connection;<span class="hljs-comment">//得到最长空闲时间的连接</span>      &#125;    &#125;    <span class="hljs-keyword">if</span> (longestIdleDurationNs &gt;= <span class="hljs-keyword">this</span>.keepAliveDurationNs        || idleConnectionCount &gt; <span class="hljs-keyword">this</span>.maxIdleConnections) &#123;      <span class="hljs-comment">// We've found a connection to evict. Remove it from the list, then close it below (outside</span>      <span class="hljs-comment">// of the synchronized block).</span>      <span class="hljs-comment">// 空闲连接超过`maxIdleConnections`个或者空闲时间超过`keepAliveDurationNs`，需要清理该连接</span>      connections.remove(longestIdleConnection);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idleConnectionCount &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// A connection will be ready to evict soon.</span>      <span class="hljs-comment">// 返回最大空闲连接的到期时间，等待到达时间后进行清理</span>      <span class="hljs-keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inUseConnectionCount &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span>      <span class="hljs-comment">// 所有都是活跃连接，返回最大空闲连接时间，等待到达时间后清理</span>      <span class="hljs-keyword">return</span> keepAliveDurationNs;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// No connections, idle or in use.</span>      <span class="hljs-comment">// 当前不存在连接，直接返回 -1，不进行清理任务</span>      cleanupRunning = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;  &#125;<span class="hljs-comment">// 立即关闭过期连接</span>  closeQuietly(longestIdleConnection.socket());  <span class="hljs-comment">// Cleanup again immediately.</span>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>cleanup()</code>执行流程如下：</p><ul><li>遍历<code>ConnectionPool</code>的<code>connections</code>，通过<code>pruneAndGetAllocationCount()</code>判断<code>connection</code>是否空闲</li><li>遍历完毕后，找到最长时间的空闲连接(<code>longestIdleConnection</code>)</li><li>得到<code>longestIdleConnection</code>后，先是比较当前的<code>idleConnectionCount</code>是否大于<code>maxIdleConnections</code>或者<code>longestIdleDurarionNs</code>是否大于<code>keepAliveDurationNs</code>，两者满足其一，则清理掉<code>longestIdleConnection</code></li><li>不满足其上条件，继续判断<code>idleConnectionCount &gt; 0</code>，表示当前存在空闲连接，就返回距离最大空闲连接时间差<code>keepAliveDurationNs - longestIdleDurationNs</code>，等待到时清理</li><li>不满足其上条件，继续判断<code>inUseConnectionCount &gt; 0</code>，表示当前都是活跃连接，返回<code>keepAliveDurationNs</code>，等待达到时间清理</li><li>以上条件都不满足，表示当前没有连接，直接返回<code>-1</code></li><li>存在<code>longestIdleConnection</code>，即调用<code>longestIdleConnection.socket().close()</code>关闭连接即可</li></ul><h5 id="pruneAndGetAllocationCount-Connection"><a href="#pruneAndGetAllocationCount-Connection" class="headerlink" title="pruneAndGetAllocationCount(Connection)"></a>pruneAndGetAllocationCount(Connection)</h5><p>判断当前连接是否正在活跃，采用了<strong>引用计数法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pruneAndGetAllocationCount</span><span class="hljs-params">(RealConnection connection, <span class="hljs-keyword">long</span> now)</span> </span>&#123;  <span class="hljs-comment">//连接弱引用列表</span>  List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; references.size(); ) &#123;    <span class="hljs-comment">//获取引用连接</span>    Reference&lt;StreamAllocation&gt; reference = references.get(i);    <span class="hljs-comment">//不为null ，表示当前连接尚未回收</span>    <span class="hljs-keyword">if</span> (reference.get() != <span class="hljs-keyword">null</span>) &#123;      i++;      <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-comment">// We've discovered a leaked allocation. This is an application bug.</span>    StreamAllocation.StreamAllocationReference streamAllocRef =        (StreamAllocation.StreamAllocationReference) reference;    String message = <span class="hljs-string">"A connection to "</span> + connection.route().address().url()        + <span class="hljs-string">" was leaked. Did you forget to close a response body?"</span>;    Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);    <span class="hljs-comment">//移除引用</span>    references.remove(i);    connection.noNewStreams = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span>    <span class="hljs-comment">//所有引用都被移除，表示当前连接处于空闲</span>    <span class="hljs-keyword">if</span> (references.isEmpty()) &#123;      connection.idleAtNanos = now - keepAliveDurationNs;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> references.size();&#125;</code></pre><p><code>StreamAllocation</code>引用是在<code>StreamAllocation.acquire()</code>时加入的</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(RealConnection connection, <span class="hljs-keyword">boolean</span> reportedAcquired)</span> </span>&#123;  <span class="hljs-keyword">assert</span> (Thread.holdsLock(connectionPool));  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();  <span class="hljs-keyword">this</span>.connection = connection;  <span class="hljs-keyword">this</span>.reportedAcquired = reportedAcquired;  connection.allocations.add(<span class="hljs-keyword">new</span> StreamAllocationReference(<span class="hljs-keyword">this</span>, callStackTrace));&#125;</code></pre><p>通过这种<code>引用计数法</code>来判断当前是否为空闲连接</p><h2 id="OkHttp-DNS功能"><a href="#OkHttp-DNS功能" class="headerlink" title="OkHttp-DNS功能"></a>OkHttp-DNS功能</h2><h3 id="DNS介绍"><a href="#DNS介绍" class="headerlink" title="DNS介绍"></a>DNS介绍</h3><p><code>Domain Name System</code>：根据域名查出IP地址，是<code>HTTP协议</code>的前提，只有将域名正确的进行解析，得到IP地址后，才可以继续进行网络连接。</p><p>DNS服务器结构如下：</p><ul><li><code>根DNS服务器</code>：返回顶级DNS服务器的IP地址</li><li><code>顶级域DNS服务器</code>：返回权威DNS服务器的IP地址</li><li><code>权威DNS服务器</code>：返回对应主机的IP地址</li></ul><p><img src="/images/DNS服务器结构" srcset="/img/loading.gif" alt="img"></p><h4 id="LocalDNS"><a href="#LocalDNS" class="headerlink" title="LocalDNS"></a>LocalDNS</h4><p><img src="/images/OkHttp-LocalDNS.png" srcset="/img/loading.gif" alt="OkHttp-LocalDNS"></p><p><strong>运营商提供的DNS服务器</strong>，请求时优先查询<code>LocalDNS 缓存</code>，存在直接使用。不存在就需要从<code>根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威域名服务器</code>往上查询可用的<code>IP地址</code>。</p><p><img src="/images/DNS请求过程" srcset="/img/loading.gif" alt="img"></p><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ol><li><p>不稳定</p><blockquote><p>DNS劫持或者服务器故障，导致解析服务不可用</p></blockquote></li><li><p>不准确</p><blockquote><p><code>LocalDNS调度</code>不一定是<strong>就近原则</strong>。某些运营商会把解析请求转发到其他运营商的<code>LocalDNS</code>服务器。</p><p>就会导致解析出的IP不是就近服务器，致使访问变慢甚至无法访问。</p></blockquote></li><li><p>不及时</p><blockquote><p>运营商可能修改DNS的<code>TTL(Time-To-Live，DNS缓存时间)</code>，导致DNS解析结构发生修改，但是在当前请求条件下尚未生效。</p></blockquote></li></ol><p><img src="/images/640-2236080." srcset="/img/loading.gif" alt="img"></p><h4 id="HttpDNS"><a href="#HttpDNS" class="headerlink" title="HttpDNS"></a>HttpDNS</h4><p><img src="/images/OkHttp-HTTPDNS.png" srcset="/img/loading.gif" alt="OkHttp-HTTPDNS"></p><p><code>HTTPDNS</code>利用<code>HTTP协议</code>与DNS服务交互，绕开了运营商<code>LocalDNS</code>服务，有效防止了域名劫持以及提高了域名解析成功率。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img src="/images/HTTPDNS原理.jpeg" srcset="/img/loading.gif" alt="img"></p><ol><li>客户端直接访问<code>HttpDNS</code>接口，获取域名在<code>HTTPDNS服务器</code>上的最优IP(从容灾方面考虑，还需要保留<code>LocalDNS</code>请求)</li><li>客户端获取到<code>IP</code>后，直接向该<code>IP</code>发起HTTP请求</li></ol><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ol><li>降低了<code>UnknownHostException</code>异常发生</li><li>调度精准，根据用户IP，精准获取域名对应IP</li><li>扩展性强，可以自定义域名对应IP规则</li></ol><h3 id="OkHttp-HttpDNS实现"><a href="#OkHttp-HttpDNS实现" class="headerlink" title="OkHttp-HttpDNS实现"></a>OkHttp-HttpDNS实现</h3><p>OkHttp提供了<code>Dns接口</code>，可以进行自定义拓展替代本身的<code>LocalDNS</code>解析方式</p><pre><code class="hljs kotlin"><span class="hljs-comment">//自定义DNS</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptimizeLocalDNS</span> : <span class="hljs-type">Dns&#123;</span></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lookup</span><span class="hljs-params">(hostname: <span class="hljs-type">String</span>)</span></span>: List&lt;InetAddress&gt; &#123;        <span class="hljs-keyword">return</span> DNSLookUpUtil.loadLocalDNS(hostname)    &#125;&#125;<span class="hljs-comment">//设置LocalDNS超时取消</span>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadLocalDNS</span><span class="hljs-params">(hostname: <span class="hljs-type">String</span>, timeout: <span class="hljs-type">Long</span> = <span class="hljs-number">10</span>L)</span></span>: List&lt;InetAddress&gt; &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">val</span> task = FutureTask&lt;List&lt;InetAddress&gt;&gt;(Callable&lt;List&lt;InetAddress&gt;&gt; &#123;                    <span class="hljs-comment">//返回去重结果</span>                    InetAddress.getAllByName(hostname).toList().distinct()                &#125;)                Thread(task).start()                <span class="hljs-keyword">return</span> task.<span class="hljs-keyword">get</span>(timeout, TimeUnit.SECONDS)            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;            &#125;            <span class="hljs-keyword">return</span> listOf()        &#125;<span class="hljs-comment">//设置自定义DNS</span>mOkHttpClient = httpBuilder        .dns(OptimizeLocalDNS())        .build();</code></pre><h3 id="OkHttp-DNS原理"><a href="#OkHttp-DNS原理" class="headerlink" title="OkHttp-DNS原理"></a>OkHttp-DNS原理</h3><p>配置的<code>dns()</code>初始使用位于<code>RetryAndFollowUpInterceptor.intercept()</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetryAndFollowUpInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;  ...   <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    ...        StreamAllocation streamAllocation = <span class="hljs-keyword">new</span> StreamAllocation(client.connectionPool(),        createAddress(request.url()), call, eventListener, callStackTrace);   &#125;     <span class="hljs-function"><span class="hljs-keyword">private</span> Address <span class="hljs-title">createAddress</span><span class="hljs-params">(HttpUrl url)</span> </span>&#123;    ...    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Address(url.host(), url.port(), client.dns(), client.socketFactory(),        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());  &#125;   ...&#125;</code></pre><p>构造出一个<code>Address</code>对象，里面包含了<code>主机名(host)、端口(port)、DNS配置(DNS)、SSL配置(sslSocketFactory,certificatePinner)、代理设置</code></p><p>得到<code>Address</code>，通过<code>StreamAllocation</code>构造了<code>RouteSelector</code>对象</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StreamAllocation</span><span class="hljs-params">(ConnectionPool connectionPool, Address address, Call call,    EventListener eventListener, Object callStackTrace)</span> </span>&#123;  <span class="hljs-keyword">this</span>.connectionPool = connectionPool;  <span class="hljs-keyword">this</span>.address = address;  <span class="hljs-keyword">this</span>.call = call;  <span class="hljs-keyword">this</span>.eventListener = eventListener;  <span class="hljs-keyword">this</span>.routeSelector = <span class="hljs-keyword">new</span> RouteSelector(address, routeDatabase(), call, eventListener);  <span class="hljs-keyword">this</span>.callStackTrace = callStackTrace;&#125;</code></pre><p><code>RouteSelector</code>主要为了<strong>Select Route(选择路由)，返回一个可用的<code>Route</code>对象</strong>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetNextInetSocketAddress</span><span class="hljs-params">(Proxy proxy)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// Clear the addresses. Necessary if getAllByName() below throws!</span>    inetSocketAddresses = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    String socketHost;    <span class="hljs-keyword">int</span> socketPort;    <span class="hljs-keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;<span class="hljs-comment">//存在代理</span>      socketHost = address.url().host();      socketPort = address.url().port();    &#125; <span class="hljs-keyword">else</span> &#123;      SocketAddress proxyAddress = proxy.address();      <span class="hljs-keyword">if</span> (!(proxyAddress <span class="hljs-keyword">instanceof</span> InetSocketAddress)) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(            <span class="hljs-string">"Proxy.address() is not an "</span> + <span class="hljs-string">"InetSocketAddress: "</span> + proxyAddress.getClass());      &#125;      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;      socketHost = getHostString(proxySocketAddress);      socketPort = proxySocketAddress.getPort();    &#125;    <span class="hljs-keyword">if</span> (socketPort &lt; <span class="hljs-number">1</span> || socketPort &gt; <span class="hljs-number">65535</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SocketException(<span class="hljs-string">"No route to "</span> + socketHost + <span class="hljs-string">":"</span> + socketPort          + <span class="hljs-string">"; port is out of range"</span>);    &#125;    <span class="hljs-keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;<span class="hljs-comment">//解析的直接为代理地址</span>      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//dns开始解析监听</span>      eventListener.dnsStart(call, socketHost);      <span class="hljs-comment">// Try each address for best behavior in mixed IPv4/IPv6 environments.</span>      List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);<span class="hljs-comment">//通过配置的DNS去解析对应域名的IP列表</span>      <span class="hljs-keyword">if</span> (addresses.isEmpty()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownHostException(address.dns() + <span class="hljs-string">" returned no addresses for "</span> + socketHost);      &#125;      <span class="hljs-comment">//dns解析结束监听</span>      eventListener.dnsEnd(call, socketHost, addresses);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;        InetAddress inetAddress = addresses.get(i);        inetSocketAddresses.add(<span class="hljs-keyword">new</span> InetSocketAddress(inetAddress, socketPort));      &#125;    &#125;  &#125;</code></pre><p><code>resetNextInetSocketAddress()</code>返回<code>List&lt;InetSocketAddress&gt;</code>，区分了一下两种情况</p><ul><li>设置了<code>proxies</code>代理服务器，直接返回<code>InetSocketAddress(socketHost,socketPort)</code>代理服务器对应的地址和端口</li><li>未设置代理服务器，通过设置的<code>dns</code>去解析对应域名(<code>dns.lookup(host)</code>)得到<code>List&lt;InetAddress&gt;</code>对应的IP列表，在返回对应地址</li></ul><h2 id="OkHttp-HTTP2-0协议支持"><a href="#OkHttp-HTTP2-0协议支持" class="headerlink" title="OkHttp-HTTP2.0协议支持"></a>OkHttp-HTTP2.0协议支持</h2><p><img src="/images/OkHttp-HTTP2.0.png" srcset="/img/loading.gif" alt="OkHttp-HTTP2.0"></p><blockquote><p>基于<code>二进制分帧</code>、<code>首部压缩</code>和<code>服务端推送</code>进行分析</p></blockquote><p>//TODO</p><h2 id="OkHttp拓展"><a href="#OkHttp拓展" class="headerlink" title="OkHttp拓展"></a>OkHttp拓展</h2><h3 id="请求时间获取"><a href="#请求时间获取" class="headerlink" title="请求时间获取"></a>请求时间获取</h3><p><code>EventListener</code>是OkHttp提供的监听回调，可以通过实现这个抽象类监听到网络请求各阶段的时间点</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventListener</span> </span>&#123;   <span class="hljs-comment">//请求相关回调</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callStart</span><span class="hljs-params">(Call call)</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callEnd</span><span class="hljs-params">(Call call)</span> </span>&#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callFailed</span><span class="hljs-params">(Call call, IOException ioe)</span> </span>&#123;&#125;       <span class="hljs-comment">//dns解析回调</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsStart</span><span class="hljs-params">(Call call, String domainName)</span> </span>&#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsEnd</span><span class="hljs-params">(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList)</span> </span>&#123;&#125;     <span class="hljs-comment">//请求连接相关回调</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectStart</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy)</span></span>&#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectEnd</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,@Nullable Protocol protocol)</span> </span>&#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectFailed</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,      @Nullable Protocol protocol, IOException ioe)</span> </span>&#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectionAcquired</span><span class="hljs-params">(Call call, Connection connection)</span></span>&#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectionReleased</span><span class="hljs-params">(Call call, Connection connection)</span></span>&#123;&#125;     ...&#125;</code></pre><h4 id="DNS解析耗时"><a href="#DNS解析耗时" class="headerlink" title="DNS解析耗时"></a>DNS解析耗时</h4><p>只要监听<code>dnsStart()</code>和<code>dnsEnd()</code>之间的时间差即可</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> dnsStartTime;<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> dnsDuration = -<span class="hljs-number">1L</span>;    <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsStart</span><span class="hljs-params">(Call call, String domainName)</span> </span>&#123;    <span class="hljs-keyword">super</span>.dnsStart(call, domainName);    recordEventLog(<span class="hljs-string">"dnsStart"</span>);    dnsStartTime = System.nanoTime();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsEnd</span><span class="hljs-params">(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList)</span> </span>&#123;    <span class="hljs-keyword">super</span>.dnsEnd(call, domainName, inetAddressList);    recordEventLog(<span class="hljs-string">"dnsEnd"</span>);    dnsDuration = (System.nanoTime() - dnsStartTime) / <span class="hljs-number">1000000</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDnsDuration</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> dnsDuration;&#125;</code></pre><p><code>dnsDuration</code>即为DNS解析耗时</p><h4 id="请求连接耗时"><a href="#请求连接耗时" class="headerlink" title="请求连接耗时"></a>请求连接耗时</h4><p>初始连接耗时</p><blockquote><p>使用Socket建立TCP连接，初始连接表示的就是<code>Socket建立连接的过程</code></p></blockquote><p>只要监听<code>connectStart()</code>和<code>connectEnd()</code>之间的时间差。</p><p>复用连接耗时</p><blockquote><p>OkHttp设置<code>ConnectionPool</code>，可以复用已存在的连接</p></blockquote><p>需要监听<code>connectAcquired()</code>和<code>connectReleased()</code>之间的时间差</p><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5a704ed05188255a8817f4c9" target="_blank" rel="noopener">开源框架源码鉴赏：OkHttp</a><br><a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">彻底弄懂HTTP缓存机制及原理</a></p><p><a href="https://mp.weixin.qq.com/s/iaPtSF-twWz-AN66UJUBDg" target="_blank" rel="noopener">百度App网络深度优化系列《一》DNS优化</a></p><p><a href="https://juejin.im/post/6844903785232498696#heading-4" target="_blank" rel="noopener">HTTP2.0相关</a></p><p><a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener">HPACK算法</a></p><p><a href="https://sq.163yun.com/blog/article/188769987293102080" target="_blank" rel="noopener">HTTP/2首部压缩的OkHttp3实现</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit简析</title>
    <link href="/2019/03/08/Retrofit%E7%AE%80%E6%9E%90/"/>
    <url>/2019/03/08/Retrofit%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedHashMap简析</title>
    <link href="/2019/03/08/LinkedHashMap%E7%AE%80%E6%9E%90/"/>
    <url>/2019/03/08/LinkedHashMap%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ArrayMap简析</title>
    <link href="/2019/03/08/ArrayMap%E7%AE%80%E6%9E%90/"/>
    <url>/2019/03/08/ArrayMap%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JNI基础知识</title>
    <link href="/2019/03/02/JNI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2019/03/02/JNI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<!--注册方案--><h2 id="JNI基础概念"><a href="#JNI基础概念" class="headerlink" title="JNI基础概念"></a>JNI基础概念</h2><p>JNI本意为<code>Java Native Interface</code>，为了方便Java调用C、C++等本地代码所封装的一层接口。当出现一些无法用Java处理的任务时，就可以借用JNI技术去完成。<br>一般来说有以下几种情况需要用到JNI技术：</p><ul><li>需要调用Java语言不支持的依赖于操作系统平台特性的一些功能。例如：调用当前Android系统的底层功能，而Java无法实现，就需要用到JNI</li><li>为了提升应用部分功能的性能，必须采用其他语言实现。例如：OpenCV进行图像识别</li></ul><p>为了开发者方便使用JNI技术，Android提供了<strong>NDK</strong>这个工具集合，通过NDK可以在Android中更加方便的通过JNI访问Native代码。NDK还提供了交叉编译器，只要简单的修改<code>build.gradle</code>中的<code>cMake</code>配置就可以支持生成特定CPU的动态链接库。</p><p>NDK有如下优点：</p><ul><li>提高代码的安全性。由于so库反编译比较困难，提高了程序的安全性。</li><li>可以很方便的植入已有的C/C++库，例如FFmpeg、OpenCv等</li><li>提高程序在某些特定情况下的执行效率，但不能明显提升Android程序的性能。</li><li>易于代码复用和移植，用C/C++开发的代码也可以移植到其他平台上</li></ul><p>JNI目前有着非常广泛的应用场景，包括音视频开发、热修复、插件化等当前热门技术。</p><h2 id="源码中的JNI"><a href="#源码中的JNI" class="headerlink" title="源码中的JNI"></a>源码中的JNI</h2><h2 id="JNI基础使用"><a href="#JNI基础使用" class="headerlink" title="JNI基础使用"></a>JNI基础使用</h2><h2 id="JNI原理简略分析"><a href="#JNI原理简略分析" class="headerlink" title="JNI原理简略分析"></a>JNI原理简略分析</h2><h2 id="JNI参数相关"><a href="#JNI参数相关" class="headerlink" title="JNI参数相关"></a>JNI参数相关</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件化原理及实践</title>
    <link href="/2019/02/27/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/"/>
    <url>/2019/02/27/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<!--SPI实现、字节码注入实现、如何实现组件通信、平级调用数据--><h2 id="利用SPI机制实现组件化功能"><a href="#利用SPI机制实现组件化功能" class="headerlink" title="利用SPI机制实现组件化功能"></a>利用SPI机制实现组件化功能</h2><h2 id="利用字节码注入配合transform-api实现组件化功能"><a href="#利用字节码注入配合transform-api实现组件化功能" class="headerlink" title="利用字节码注入配合transform api实现组件化功能"></a>利用字节码注入配合transform api实现组件化功能</h2><h2 id="组件化间通信机制"><a href="#组件化间通信机制" class="headerlink" title="组件化间通信机制"></a>组件化间通信机制</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://baiqiantao.github.io/Java/aop/YzaiEf/" target="_blank" rel="noopener">AutoRegister</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>final关键字</title>
    <link href="/2019/02/26/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2019/02/26/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="Final特性"><a href="#Final特性" class="headerlink" title="Final特性"></a>Final特性</h2><p><code>final</code>代表了不可变，被<code>final</code>修饰的属性也是不可变状态，一旦被<code>final</code>修饰，将无法再改变这个引用。</p><p>另外<code>final</code>关键字还能保证线程间的同步，下面会基于JVM角度对这个特性进行分析。</p><h2 id="Final使用方法"><a href="#Final使用方法" class="headerlink" title="Final使用方法"></a>Final使用方法</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><blockquote><p>被<code>final</code>修饰的类不可以被继承，例如<code>String、Integer</code>，类中的方法也是默认被<code>final</code>修饰的。</p></blockquote><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><h2 id="Final在JVM中的体现"><a href="#Final在JVM中的体现" class="headerlink" title="Final在JVM中的体现"></a>Final在JVM中的体现</h2><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://www.jianshu.com/p/f68d6ef2dcf0" target="_blank" rel="noopener">Final of Java，这一篇差不多了</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>static关键字分析</title>
    <link href="/2019/02/25/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/"/>
    <url>/2019/02/25/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<!--涉及到内部类、静态内部类--><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/static关键字.png" srcset="/img/loading.gif" class="full-image" alt="static关键字" title="static关键字"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>一种表示<strong>静态属性</strong>的修饰符。用于<strong>为特定区域分配单一存储空间，不考虑要创建多少对象或者说根本就不创建任何对象</strong>，再就是<strong>想在没有创建对象的情况下也去调用方法</strong>。</p></blockquote><h2 id="static关键字作用"><a href="#static关键字作用" class="headerlink" title="static关键字作用"></a>static关键字作用</h2><ul><li>用来修饰类的成员<ul><li>修饰成员变量——<code>静态变量</code></li><li>修饰成员方法——<code>静态方法</code></li></ul></li><li>当类被加载时，会优先被加载</li><li>用来修饰代码块——<code>静态代码块</code>，先于类的构造方法之前执行且只会执行一次。用来对静态成员做初始化</li><li>静态修饰的成员被所有的对象共享</li><li>调用静态方法或对象时，可以直接通过<code>类名.成员方法/变量</code>来进行访问</li></ul><blockquote><p>能实现上述作用的原理在于：</p><ol><li>代码都是在编译时 由系统分配内存</li><li>静态变量编译时，所分配的内存会一直存在，直到程序退出时才会被释放</li><li>类加载时，静态变量会被放到<strong>方法区</strong>中，被所有的对象实例共用</li></ol></blockquote><h2 id="static关键字用法"><a href="#static关键字用法" class="headerlink" title="static关键字用法"></a>static关键字用法</h2><h3 id="修饰类——静态类"><a href="#修饰类——静态类" class="headerlink" title="修饰类——静态类"></a>修饰类——静态类</h3><blockquote><p><em>静态类又名<code>静态内部类</code>。</em>该类独立存在，形式上与外部类有内外关系，实际上没有任何关联，本质是为了 <strong>隐藏自身</strong>。可不依赖外部类进行实例化，只能访问外部类的静态成员变量及成员方法。</p><p><code>内部类</code>：定义在类中的另外一个类。隐藏在外部类中且封装性更强，不允许除外部类外的其他类对其进行访问。但可以直接访问到外部类的成员。</p><p><code>成员内部类</code>：可以直接使用外部类的所有成员和方法，即时是<code>private</code>修饰的。</p><p><code>局部内部类</code>：内部类定义在方法内，只能在该方法或条件的作用域才能使用，退出这作用域就无法引用。</p><p><code>匿名内部类</code>：只能使用一次，通过用来简化代码编写，还有个前提条件：<strong>必须继承一个父类或实现一个接口。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-comment">//静态内部类</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;            &#125;    <span class="hljs-comment">//普通内部类</span>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;            &#125;&#125;</code></pre><h3 id="修饰代码块——静态代码块"><a href="#修饰代码块——静态代码块" class="headerlink" title="修饰代码块——静态代码块"></a>修饰代码块——静态代码块</h3><blockquote><p>静态代码块用于初始化一个类的时候做操作用的，和静态变量、静态方法一样会随着类的加载一块执行，而且可以随意摆放位置。对应类加载过程的最后一步：<em>类初始化(执行<code>&lt;clinit&gt;</code>方法)</em>。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">//最终得到 为0</span>        i = <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><p>若存在多个 static代码块，JVM按照他们出现的先后顺序依次执行。<strong>静态代码块只能访问定义在它之前的变量，定义在其后的是不能访问的。</strong></p><h3 id="修饰方法——静态方法"><a href="#修饰方法——静态方法" class="headerlink" title="修饰方法——静态方法"></a>修饰方法——静态方法</h3><blockquote><p>使用<code>static</code>修饰成员方法。通过<code>ClassName.methodName()</code>直接访问，由于它在类加载时就存在了，不依赖于任何实例。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-comment">//静态方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;            &#125;&#125;</code></pre><p>只能访问所属类的静态成员变量和静态方法，不能使用this、super关键字</p><h3 id="修饰变量——静态变量"><a href="#修饰变量——静态变量" class="headerlink" title="修饰变量——静态变量"></a>修饰变量——静态变量</h3><blockquote><p>使用<code>static</code>修饰变量。通过<code>ClassName.propertyName</code>直接访问静态变量。</p><p>静态变量是 <strong>随着类加载时完成初始化的，在内存中仅有一份，且只分配一次内存</strong>。同时被所有的实例共享静态变量。</p><p><code>实例变量</code>：每创建一个实例，JVM就会为实例变量分配一次内存，它与创建它的实例同生共死。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-comment">//静态变量</span>&#125;可通过Test.a直接访问</code></pre><p>一般在这两种情况下使用<code>静态变量</code>：<strong>对象之间共享数据以及访问数据。</strong></p><h2 id="static关键字注意事项"><a href="#static关键字注意事项" class="headerlink" title="static关键字注意事项"></a>static关键字注意事项</h2><ul><li>静态方法不能被覆盖，方法覆盖是动态绑定的，静态方法时在编译时静态绑定的。</li><li>在静态方法、静态类中无法访问非static变量、方法</li><li>静态方法可以引用静态的变量或方法，由于 *<em>静态的这些都是在类加载时就加载好，都是可以互相调用到的。</em></li><li>非静态方法中也可以引用静态的变量或方法。</li></ul><h2 id="static关键字使用实例"><a href="#static关键字使用实例" class="headerlink" title="static关键字使用实例"></a>static关键字使用实例</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singletion INSTANCE = <span class="hljs-keyword">new</span> Singleton();    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;            &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;    &#125;&#125;</code></pre><blockquote><p>为何可以保证线程安全？<code>虚拟机可以保证一个类的类构造器</code><clinit>()`在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。<strong>同一个类加载器下，一个类型只会被初始化一次。</strong></clinit></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关及其拓展(八) — 静态分派&amp;动态分派</title>
    <link href="/2019/02/21/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%85%AB/"/>
    <url>/2019/02/21/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用不同于方法执行，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本(即调用哪一个方法)</strong>。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><blockquote><p>调用目标在代码程序写好、编译器进行编译时就必须确定下来。</p></blockquote><p>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括<code>静态方法</code>和<code>私有方法</code>两大类。前者与类型直接关联，后者在外部不可访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p><p>在解析阶段中可以唯一确定的调用版本，符合这个条件的有<code>静态方法、私有方法、实例构造器，父类方法</code>四种。</p><h2 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h2><p>Java具备面向对象的3个特性：<strong>继承、封装和多态</strong>。分派就体现了<em>多态</em>这一特征。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/方法分派.png" srcset="/img/loading.gif" class="full-image" alt="方法分派" title="方法分派"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="变量的静态-amp-动态类型"><a href="#变量的静态-amp-动态类型" class="headerlink" title="变量的静态&amp;动态类型"></a>变量的静态&amp;动态类型</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span></span>&#123;            &#125;        <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span></span>&#123;            &#125;        <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span></span>&#123;            &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Human man = <span class="hljs-keyword">new</span> Human();    &#125;&#125;</code></pre><p>在<code>Human man =  new Man()</code>中，<code>Human</code>对应的变量的静态类型——<strong>(引用类型)不会被改变，在编译期可知</strong>。<code>Man</code>对应着变量的动态类型——<strong>(实例对象类型)会发生变化，在运行期才可以确定</strong>。</p><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><blockquote><p><strong>根据变量的静态类型来定位方法执行版本的分派动作</strong>。静态分派发送在编译阶段，因此确定静态分派的动作实际上是不由虚拟机来执行的。</p></blockquote><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>方法重载(<code>Overload</code>)</p><h4 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStatic</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span></span>&#123;&#125;    <span class="hljs-keyword">static</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span></span>&#123;&#125;    <span class="hljs-keyword">static</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span></span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(Human human)</span></span>&#123;        System.err.println(<span class="hljs-string">"hello human"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(Man man)</span></span>&#123;        System.err.println(<span class="hljs-string">"hello man"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(Woman woman)</span></span>&#123;        System.err.println(<span class="hljs-string">"hello woman"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Human man = <span class="hljs-keyword">new</span> Man() ;        Man man1 = <span class="hljs-keyword">new</span> Man();        Woman woman = <span class="hljs-keyword">new</span> Woman();        Human human = <span class="hljs-keyword">new</span> Woman();        TestStatic testStatic = <span class="hljs-keyword">new</span> TestStatic();        testStatic.sayHello(man);        testStatic.sayHello(man1);        testStatic.sayHello(woman);        testStatic.sayHello(human);    &#125;&#125;</code></pre><p>得到的最终结果是：</p><pre><code class="hljs java">hello humanhello manhello womanhello human</code></pre><p>观察发现，最终得到的结果是根据变量的<code>静态类型</code>最终得出的。这是由于<em>编译器虽然能确定方法的重载版本，但是很多情况下重载方法并不唯一，最终仍需确认一个合适的版本，就选用到了 变量的静态类型作为 实际参数。</em></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="变量的静态类型发生变化"><a href="#变量的静态类型发生变化" class="headerlink" title="变量的静态类型发生变化"></a>变量的静态类型发生变化</h5><blockquote><p>通过<code>强制类型转换</code>改变变量的静态类型</p></blockquote><pre><code class="hljs Java">Human man = <span class="hljs-keyword">new</span> Man()   test.sayHello((Man)man)</code></pre><p>得到的最终结果就会变为<code>hello man</code>。</p><h5 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h5><blockquote><p>当程序中没有显示指定变量的静态类型时，程序需要根据<code>静态类型的优先级</code>确定<code>优先的静态类型</code>进行方法分配。</p></blockquote><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><blockquote><p><strong>根据变量的动态类型进行方法分派</strong>。动态分派发生在运行阶段。</p></blockquote><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>方法重写(<code>Override</code>)</p><h4 id="实例说明-1"><a href="#实例说明-1" class="headerlink" title="实例说明"></a>实例说明</h4><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"hello human"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.err.println(<span class="hljs-string">"hello man"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        System.err.println(<span class="hljs-string">"hello woman"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Human man = <span class="hljs-keyword">new</span> Man();        man.sayHello();                Human human = <span class="hljs-keyword">new</span> Human();        human.sayHello();                Woman woman = <span class="hljs-keyword">new</span> Woman();        woman.sayHello();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="hljs java">hello manhello humanhello woman</code></pre><p>观察发现，最终得出的结果是根据变量的<code>动态类型</code>最终得出的。利用<code>invokevirtual</code>指令来执行动态分派。执行步骤分为两步：</p><ol><li>确定接受者的动态类型</li><li>将 常量池中的 类方法符号引用 解析到不同的直接引用上。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java - 注解</title>
    <link href="/2019/02/19/Java-%E6%B3%A8%E8%A7%A3/"/>
    <url>/2019/02/19/Java-%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Java-注解.png" srcset="/img/loading.gif" class="full-image" alt="注解基础知识" title="注解基础知识"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><blockquote><p>元数据是关于数据的数据，元数据是添加到程序元素入方法、字段、类和包上的额外信息。对数据进行说明描述。</p></blockquote><p>元数据可用于以下场景：</p><ul><li><strong>编写文档</strong>：根据程序元素的注释创建文档</li><li><strong>代码分析</strong>：通过标识的元数据对代码进行分析(<em>例如声明方法重载</em>)</li><li><strong>编译检查</strong>：让编译器实现基本的编译检查，例如<em>@notNull——不为空</em></li></ul><p><strong>Java平台的元数据体现 就在于注解(Annotation)。</strong></p><h3 id="注解概念"><a href="#注解概念" class="headerlink" title="注解概念"></a>注解概念</h3><blockquote><p>与Java 5之后引入的一个特性，可以声明在<code>类、包、字段、方法、局部变量、方法参数等的前面</code>。多用于<strong>标识/解释代码</strong>。</p></blockquote><h3 id="注解作用"><a href="#注解作用" class="headerlink" title="注解作用"></a>注解作用</h3><ul><li><strong>标记作用</strong>   @Override 标记重写父类方法</li><li><strong>编译时动态处理，动态生成代码</strong>  @BindView(R.id.view) ButterKnife</li><li><strong>运行时动态处理，获取注解信息</strong>  @Post(“”) Retrofit </li></ul><h2 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><blockquote><p>Android系统内置的注解类型，负责注解其他注解的注解类型</p></blockquote><p>以下介绍4个常用的元注解</p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><blockquote><p>保留注解。表示注解被保留的时间长短</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Annotation_Retention&#123;  &#125;</code></pre><p>其中<code>RetentionPolicy</code>有三种类型，对应三种保留策略。</p><table><thead><tr><th>RetentionPolicy(安保留时长排序)</th><th>含义</th></tr></thead><tbody><tr><td>RetentionPolicy.SOURCE</td><td>注解只在源代码阶段保留，编译器编译时会被忽视</td></tr><tr><td>RetentionPolicy.CLASS(<strong>默认保留策略</strong>)</td><td>注解只保留在编译时<strong>编译时注解</strong></td></tr><tr><td>RetentionPolicy.RUNTIME</td><td>注解保留到程序运行时，并且会被加载到JVM中，程序运行时可以获取到他们<strong>运行时注解</strong></td></tr></tbody></table><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><blockquote><p>Java文档注解。可以将注解的元素包含到文档中</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Annotation_Documented&#123;  &#125;</code></pre><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><blockquote><p>表示该注解类型的适用程序元素类型。</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.METHOD)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Annotation_Target&#123;  &#125;</code></pre><p><em>如果未设置@Target类型，默认适用于所有8大元素。</em></p><p>其中<code>ElementType</code>有8种类型，对应8种限制范围。</p><table><thead><tr><th>ElementType</th><th>含义</th></tr></thead><tbody><tr><td>ANNOTATION_TYPE</td><td>注解类型声明</td></tr><tr><td>CONSTRUCTOR</td><td>构造方法声明</td></tr><tr><td>FIELD</td><td>字段声明</td></tr><tr><td>LOCAL_VARIABLE</td><td>局部变量声明</td></tr><tr><td>METHOD</td><td>方法声明</td></tr><tr><td>PACKAGE</td><td>包声明</td></tr><tr><td>PARAMETER</td><td>参数声明</td></tr><tr><td>TYPE</td><td>类、接口、枚举声明</td></tr></tbody></table><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><blockquote><p>继承注解。如果某个类使用了<code>@Inherited</code>修饰的注解，那么其子类也继承该注解。</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Inherited</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Annotation_Inherited&#123;  &#125;</code></pre><p>Java 8之后新增的元注解</p><h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><blockquote><p>可重复注解，被注解的对象可以取多个值。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//容器注解 用于存放其他注解对象</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Job &#123;    Person[] value();&#125;<span class="hljs-meta">@Repeatable</span>(Job<span class="hljs-class">.<span class="hljs-keyword">class</span>)<span class="hljs-title">pulic</span> @<span class="hljs-title">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">role</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;<span class="hljs-meta">@Person</span>(role=<span class="hljs-string">"1"</span>)<span class="hljs-meta">@Person</span>(role=<span class="hljs-string">"2"</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>()</span>&#123;  &#125;</code></pre><h3 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h3><blockquote><p> Java内部已经实现好的注解类型</p></blockquote><h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><blockquote><p>用于告知编译器，该方法需要被覆写。</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span></span>&#123;  &#125;</code></pre><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><blockquote><p>标记对象已经过时，不建议使用。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;  <span class="hljs-meta">@Deprecated</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;      &#125;&#125;Test test = <span class="hljs-keyword">new</span> Test();</code></pre><p>最终显示：test.<del>test()</del>;</p><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><blockquote><p>阻止警告注解，被该注解标记时，不会显示<code>warning</code></p></blockquote><h4 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h4><blockquote><p>Java8后引入，标记该对象可以实现函数式接口。</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><blockquote><p>由开发者自己实现注解功能，依赖上面系统提供的注解类型</p></blockquote><h4 id="运行时注解"><a href="#运行时注解" class="headerlink" title="运行时注解"></a>运行时注解</h4><blockquote><p>在代码中通过注解进行标记，在运行时通过反射寻找标价进行处理。<strong>由于反射导致运行低效。</strong></p></blockquote><h5 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h5><pre><code class="hljs java"><span class="hljs-comment">//定义 运行时注解</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-comment">//支持修饰的是 类、方法、接口等    变量                  方法</span><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)<span class="hljs-meta">@interface</span> CustomAnnotation &#123;    <span class="hljs-comment">//定义注解支持的类型</span>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;</code></pre><h5 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h5><p>主要要使用到以下的方法：</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>T   getAnnotation(Class annotationClass)</td><td>存在<code>annotationClass</code>对应的注解时，返回对应的注解对象</td></tr><tr><td>Annotation[]   getAnnotations()</td><td>返回该元素上的所有注解，包括继承于基类的注解</td></tr><tr><td>Annotation[]   getDeclaredAnnotations()</td><td>返回自身显式标明的所有注解</td></tr><tr><td>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td><td>存在<code>annotationClass</code>对应的注解时，返回true</td></tr></tbody></table><p>不同位置的注解需要使用不同的解析方式，主要分为3种：</p><h6 id="获取类的注解信息"><a href="#获取类的注解信息" class="headerlink" title="获取类的注解信息"></a>获取类的注解信息</h6><p>示例代码：</p><pre><code class="hljs java"><span class="hljs-meta">@CustomAnnotation</span>(value = <span class="hljs-string">"AnnotationClass"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;  &#125;</code></pre><p>解析代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAnnotationClass</span><span class="hljs-params">(Class clazz)</span> </span>&#123;       <span class="hljs-keyword">boolean</span> hasAnnotation = clazz.isAnnotationPresent(CustomAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;       <span class="hljs-keyword">if</span> (hasAnnotation) &#123;           CustomAnnotation contentView = clazz.getAnnotation(CustomAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;           System.err.println(<span class="hljs-string">"Class "</span> + contentView.value());       &#125;   &#125;</code></pre><h6 id="获取方法的注解信息"><a href="#获取方法的注解信息" class="headerlink" title="获取方法的注解信息"></a>获取方法的注解信息</h6><p>示例代码：</p><pre><code class="hljs java"><span class="hljs-meta">@CustomAnnotation</span>(value = <span class="hljs-string">"AnnotationMethod"</span>)<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre><p>解析代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAnnotationMethod</span><span class="hljs-params">(Class clazz, String methodName)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//利用反射获取clazz中的对应方法</span>            Method method = clazz.getDeclaredMethod(methodName);            <span class="hljs-keyword">if</span> (method != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//允许访问私有方法</span>                method.setAccessible(<span class="hljs-keyword">true</span>);                <span class="hljs-comment">//获取所有注解类</span>                Annotation[] ans = method.getDeclaredAnnotations();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.length; i++) &#123;                    <span class="hljs-comment">//存在相同类名的注解类</span>                    <span class="hljs-keyword">if</span> (ans[i].annotationType() == CustomAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                        CustomAnnotation contentView = method.getAnnotation(CustomAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                        System.err.println(<span class="hljs-string">"Method "</span> + contentView.value());                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre><h6 id="获取变量的注解信息"><a href="#获取变量的注解信息" class="headerlink" title="获取变量的注解信息"></a>获取变量的注解信息</h6><p>示例代码：</p><pre><code class="hljs java"><span class="hljs-meta">@CustomAnnotation</span>(value = <span class="hljs-string">"AnnotationVar"</span>)<span class="hljs-keyword">int</span> annotationVar = <span class="hljs-number">0</span>;</code></pre><p>解析代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAnnotationVar</span><span class="hljs-params">(Class clazz, String varName)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//根据变量名获取 变量</span>        Field field = clazz.getDeclaredField(varName);        field.setAccessible(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">//获取对应注解类</span>        CustomAnnotation contentView = field.getAnnotation(CustomAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">if</span> (contentView != <span class="hljs-keyword">null</span>) &#123;            System.err.println(<span class="hljs-string">"Field "</span> + contentView.value());        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><h4 id="编译时注解"><a href="#编译时注解" class="headerlink" title="编译时注解"></a>编译时注解</h4><blockquote><p>不会对性能产生任何影响，实质就是<strong>生成代码</strong>，在编译时对注解做处理，通过注解获取必要信息，在项目中生成代码，于运行时调用。</p></blockquote><h5 id="定义注解-1"><a href="#定义注解-1" class="headerlink" title="定义注解"></a>定义注解</h5><pre><code class="hljs java"><span class="hljs-meta">@Retention</span>(RetentionPolicy.CLASS)<span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;&#125;</code></pre><h5 id="注解解析-1"><a href="#注解解析-1" class="headerlink" title="注解解析"></a>注解解析</h5><p>关键点在于注解的解析器</p><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes</span>(<span class="hljs-string">"com.wxy.route.test.MyAnnotation"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;      <span class="hljs-comment">//在其中执行 解析注解</span>    &#125;&#125;</code></pre><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://www.jianshu.com/p/5c8d183533fb" target="_blank" rel="noopener">注解生成Java代码</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jetpack-Lifecycle简析</title>
    <link href="/2019/02/15/Jetpack-Lifecycle%E7%AE%80%E6%9E%90/"/>
    <url>/2019/02/15/Jetpack-Lifecycle%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Lifecycle简介"><a href="#Lifecycle简介" class="headerlink" title="Lifecycle简介"></a>Lifecycle简介</h2><p>Google官方提供的一个<strong>生命周期感知组件</strong>。可以由引用组件自己进行生命周期管理，从而减少内存泄露以及异常的可能性。</p><p><strong>让我们自己创建的对象也可以感知到Android组件的生命周期。</strong></p><h2 id="Lifecycle使用示例"><a href="#Lifecycle使用示例" class="headerlink" title="Lifecycle使用示例"></a>Lifecycle使用示例</h2><p>先构建需要监听生命周期的组件</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycleComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LifecycleObserver</span> </span>&#123;    <span class="hljs-meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_CREATE)    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span></span>&#123;    &#125;&#125;</code></pre><p>在Activity/Fragment中引用该组件并绑定生命周期</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;   <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        getLifecycle().addObserver(<span class="hljs-keyword">new</span> LifeCycleComponent());   &#125;&#125;</code></pre><p>更多使用示例可参考<a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle#codelabs" target="_blank" rel="noopener">官方Lifecycle示例</a></p><h2 id="Lifecycle源码解析"><a href="#Lifecycle源码解析" class="headerlink" title="Lifecycle源码解析"></a>Lifecycle源码解析</h2><h3 id="LifecycleObserver"><a href="#LifecycleObserver" class="headerlink" title="LifecycleObserver"></a>LifecycleObserver</h3><blockquote><p>属于观察者模式的<strong>观察者</strong>，负责接受生命周期事件。需要监听生命周期的组件都需要实现该接口。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/** * Marks a class as a LifecycleObserver. It does not have any methods, instead, relies on * &#123;<span class="hljs-doctag">@link</span> OnLifecycleEvent&#125; annotated methods. */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LifecycleObserver</span> </span>&#123;&#125;</code></pre><p>内部未提供任何方法，需要监听生命周期的话就采用<code>OnLifecycleEvent</code>去实现</p><pre><code class="hljs java"><span class="hljs-comment">//运行时注解</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-comment">//只支持注解方法</span><span class="hljs-meta">@Target</span>(ElementType.METHOD)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> OnLifecycleEvent &#123;    Lifecycle.<span class="hljs-function">Event <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>至此定义完成了需要取得监听结果的对象以及需要监听的生命周期</p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><blockquote><p>属于观察者模式中的<strong>被观察者</strong>，负责接受生命周期监听事件，并分发到观察者<code>LifecycleObserver</code>中。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lifecycle</span> </span>&#123;    <span class="hljs-comment">//添加观察者</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(@NonNull LifecycleObserver observer)</span></span>;    <span class="hljs-comment">//移除观察者</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(@NonNull LifecycleObserver observer)</span></span>;    <span class="hljs-comment">//获取当前生命周期状态</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-meta">@NonNull</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> State <span class="hljs-title">getCurrentState</span><span class="hljs-params">()</span></span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Event &#123;        <span class="hljs-comment">/**         * Constant for onCreate event of the &#123;<span class="hljs-doctag">@link</span> LifecycleOwner&#125;.         */</span>        ON_CREATE,        <span class="hljs-comment">/**         * Constant for onStart event of the &#123;<span class="hljs-doctag">@link</span> LifecycleOwner&#125;.         */</span>        ON_START,        <span class="hljs-comment">/**         * Constant for onResume event of the &#123;<span class="hljs-doctag">@link</span> LifecycleOwner&#125;.         */</span>        ON_RESUME,        <span class="hljs-comment">/**         * Constant for onPause event of the &#123;<span class="hljs-doctag">@link</span> LifecycleOwner&#125;.         */</span>        ON_PAUSE,        <span class="hljs-comment">/**         * Constant for onStop event of the &#123;<span class="hljs-doctag">@link</span> LifecycleOwner&#125;.         */</span>        ON_STOP,        <span class="hljs-comment">/**         * Constant for onDestroy event of the &#123;<span class="hljs-doctag">@link</span> LifecycleOwner&#125;.         */</span>        ON_DESTROY,        <span class="hljs-comment">/**         * An &#123;<span class="hljs-doctag">@link</span> Event Event&#125; constant that can be used to match all events.         */</span>        ON_ANY    &#125;    <span class="hljs-comment">/**     * Lifecycle states. You can consider the states as the nodes in a graph and     * &#123;<span class="hljs-doctag">@link</span> Event&#125;s as the edges between these nodes.     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> State &#123;        <span class="hljs-comment">/**         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch         * any more events. For instance, for an &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125;, this state is reached         * &lt;b&gt;right before&lt;/b&gt; Activity's &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onDestroy() onDestroy&#125; call.         */</span>        DESTROYED,        <span class="hljs-comment">/**         * Initialized state for a LifecycleOwner. For an &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125;, this is         * the state when it is constructed but has not received         * &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet.         */</span>        INITIALIZED,        <span class="hljs-comment">/**         * Created state for a LifecycleOwner. For an &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125;, this state         * is reached in two cases:         * &lt;ul&gt;         *     &lt;li&gt;after &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call;         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onStop() onStop&#125; call.         * &lt;/ul&gt;         */</span>        CREATED,        <span class="hljs-comment">/**         * Started state for a LifecycleOwner. For an &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125;, this state         * is reached in two cases:         * &lt;ul&gt;         *     &lt;li&gt;after &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onStart() onStart&#125; call;         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onPause() onPause&#125; call.         * &lt;/ul&gt;         */</span>        STARTED,        <span class="hljs-comment">/**         * Resumed state for a LifecycleOwner. For an &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125;, this state         * is reached after &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onResume() onResume&#125; is called.         */</span>        RESUMED;        <span class="hljs-comment">/**         * Compares if this State is greater or equal to the given &#123;<span class="hljs-doctag">@code</span> state&#125;.         *         * <span class="hljs-doctag">@param</span> state State to compare with         * <span class="hljs-doctag">@return</span> true if this State is greater or equal to the given &#123;<span class="hljs-doctag">@code</span> state&#125;         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAtLeast</span><span class="hljs-params">(@NonNull State state)</span> </span>&#123;            <span class="hljs-keyword">return</span> compareTo(state) &gt;= <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/lifecycle-states.png" srcset="/img/loading.gif" class="full-image" alt="Lifecycle的Event及State对应关系" title="Lifecycle的Event及State对应关系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h3><p>定义好自定义组件后就需要将其与Activity/Fragment进行绑定。此时就需要去获取其内部的<code>lifecycle</code>对象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LifecycleOwner</span> </span>&#123;    <span class="hljs-function">Lifecycle <span class="hljs-title">getLifecycle</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><code>LifecycleOwner</code>只提供一个<code>getLifecycle()</code>获取<code>lifecycle</code>对象。</p><p>在Activity/Fragment中，可以直接调用到<code>getLifecycle()</code>进行获取</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FragmentActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentActivity</span> <span class="hljs-keyword">implements</span>    <span class="hljs-title">ViewModelStoreOwner</span></span>&#123;    ...&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span>        <span class="hljs-keyword">implements</span> <span class="hljs-title">LifecycleOwner</span>, <span class="hljs-title">KeyEventDispatcher</span>.<span class="hljs-title">Component</span> </span>&#123;    ...    <span class="hljs-keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="hljs-keyword">new</span> LifecycleRegistry(<span class="hljs-keyword">this</span>);    ...    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Lifecycle <span class="hljs-title">getLifecycle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mLifecycleRegistry;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ComponentCallbacks</span>, <span class="hljs-title">OnCreateContextMenuListener</span>, <span class="hljs-title">LifecycleOwner</span>,<span class="hljs-title">ViewModelStoreOwner</span> </span>&#123;    ...    LifecycleRegistry mLifecycleRegistry = <span class="hljs-keyword">new</span> LifecycleRegistry(<span class="hljs-keyword">this</span>);    ...    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Lifecycle <span class="hljs-title">getLifecycle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mLifecycleRegistry;    &#125;&#125;</code></pre><p>在<code>FragmentActivity</code>及<code>Fragment</code>中都已默认实现了<code>LifecycleOwner</code>接口，就无需开发者自己实现。</p><h3 id="LifecycleRegistry"><a href="#LifecycleRegistry" class="headerlink" title="LifecycleRegistry"></a>LifecycleRegistry</h3><blockquote><p>Lifecycle抽象类的核心功能实现类，由它实现了生命周期绑定及添加/移除监听功能。</p></blockquote><p>先分析在Activity/Fragment中是如何使用<code>LifecycleRegistry</code>，后续分析功能实现。</p><h4 id="Fragment绑定"><a href="#Fragment绑定" class="headerlink" title="Fragment绑定"></a>Fragment绑定</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ComponentCallbacks</span>, <span class="hljs-title">OnCreateContextMenuListener</span>, <span class="hljs-title">LifecycleOwner</span>,        <span class="hljs-title">ViewModelStoreOwner</span> </span>&#123;    ...    LifecycleRegistry mLifecycleRegistry = <span class="hljs-keyword">new</span> LifecycleRegistry(<span class="hljs-keyword">this</span>);    ...    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Lifecycle <span class="hljs-title">getLifecycle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mLifecycleRegistry;    &#125;                ...    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mChildFragmentManager != <span class="hljs-keyword">null</span>) &#123;            mChildFragmentManager.noteStateNotSaved();        &#125;        <span class="hljs-comment">//标记当前Lifecycle.State为CREATED</span>        mState = CREATED;        mCalled = <span class="hljs-keyword">false</span>;        onCreate(savedInstanceState);        mIsCreated = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">//回调 ON_CREATE</span>        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);    &#125;                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performStart</span><span class="hljs-params">()</span> </span>&#123;        mState = STARTED;        mCalled = <span class="hljs-keyword">false</span>;        onStart();        <span class="hljs-keyword">if</span> (mChildFragmentManager != <span class="hljs-keyword">null</span>) &#123;            mChildFragmentManager.dispatchStart();        &#125;        <span class="hljs-comment">//回调ON_START</span>        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);        <span class="hljs-keyword">if</span> (mView != <span class="hljs-keyword">null</span>) &#123;            mViewLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);        &#125;    &#125;        &#125;</code></pre><p><code>Fragment</code>通过<code>LifecycleRegistry.handleLifecycleEvent()</code>进行了生命周期绑定。</p><h4 id="Activity绑定"><a href="#Activity绑定" class="headerlink" title="Activity绑定"></a>Activity绑定</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span>        <span class="hljs-keyword">implements</span> <span class="hljs-title">LifecycleOwner</span>, <span class="hljs-title">KeyEventDispatcher</span>.<span class="hljs-title">Component</span> </span>&#123;        ...    <span class="hljs-keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="hljs-keyword">new</span> LifecycleRegistry(<span class="hljs-keyword">this</span>);        <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"RestrictedApi"</span>)    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        ReportFragment.injectIfNeededIn(<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-meta">@CallSuper</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(Bundle outState)</span> </span>&#123;        mLifecycleRegistry.markState(Lifecycle.State.CREATED);        <span class="hljs-keyword">super</span>.onSaveInstanceState(outState);    &#125;    ...&#125;</code></pre><p>如果绑定在Activity上，就需要通过动态添加一个<code>ReportFragment</code>去绑定生命周期</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReportFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectIfNeededIn</span><span class="hljs-params">(Activity activity)</span> </span>&#123;        <span class="hljs-comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span>        <span class="hljs-comment">// FragmentActivity from support lib, so we use framework fragments for activities</span>        android.app.FragmentManager manager = activity.getFragmentManager();        <span class="hljs-comment">//创建自身并加入宿主Activity</span>        <span class="hljs-keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="hljs-keyword">null</span>) &#123;            manager.beginTransaction().add(<span class="hljs-keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();            <span class="hljs-comment">// Hopefully, we are the first to make a transaction.</span>            manager.executePendingTransactions();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> ReportFragment <span class="hljs-title">get</span><span class="hljs-params">(Activity activity)</span> </span>&#123;        <span class="hljs-comment">//获取自身实例</span>        <span class="hljs-keyword">return</span> (ReportFragment) activity.getFragmentManager().findFragmentByTag(                REPORT_FRAGMENT_TAG);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onActivityCreated(savedInstanceState);        dispatchCreate(mProcessListener);        <span class="hljs-comment">//分发ON_CREATE事件</span>        dispatch(Lifecycle.Event.ON_CREATE);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.onStart();        dispatchStart(mProcessListener);        <span class="hljs-comment">//分发ON_START事件</span>        dispatch(Lifecycle.Event.ON_START);    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(Lifecycle.Event event)</span> </span>&#123;        Activity activity = getActivity();        <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> LifecycleRegistryOwner) &#123;            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//指代了 ComponentActivity</span>        <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> LifecycleOwner) &#123;            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();            <span class="hljs-keyword">if</span> (lifecycle <span class="hljs-keyword">instanceof</span> LifecycleRegistry) &#123;                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);            &#125;        &#125;    &#125;&#125;</code></pre><p>Activity的生命周期监听需要依赖动态添加进的<code>ReportFragment</code>的生命周期进行回调。</p><h4 id="生命周期事件的分发"><a href="#生命周期事件的分发" class="headerlink" title="生命周期事件的分发"></a>生命周期事件的分发</h4><p>观察上述源码发现，每触发一个生命周期都会响应到<code>LifecycleRegistry.handleLifecycleEvent()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLifecycleEvent</span><span class="hljs-params">(@NonNull Lifecycle.Event event)</span> </span>&#123;    <span class="hljs-comment">//根据当前收到的生命周期状态获取事件发生后的后续状态</span>    State next = getStateAfter(event);    moveToState(next);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToState</span><span class="hljs-params">(State next)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mState == next) &#123;        <span class="hljs-keyword">return</span>;    &#125;    mState = next;    <span class="hljs-comment">//处于未同步状态则返回</span>    <span class="hljs-keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="hljs-number">0</span>) &#123;        mNewEventOccurred = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// we will figure out what to do on upper level.</span>        <span class="hljs-keyword">return</span>;    &#125;    mHandlingEvent = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//执行同步方法，把所有的State转成Event</span>    sync();    mHandlingEvent = <span class="hljs-keyword">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> State <span class="hljs-title">getStateAfter</span><span class="hljs-params">(Event event)</span> </span>&#123;    <span class="hljs-keyword">switch</span> (event) &#123;        <span class="hljs-keyword">case</span> ON_CREATE:        <span class="hljs-keyword">case</span> ON_STOP:            <span class="hljs-keyword">return</span> CREATED;        <span class="hljs-keyword">case</span> ON_START:        <span class="hljs-keyword">case</span> ON_PAUSE:            <span class="hljs-keyword">return</span> STARTED;        <span class="hljs-keyword">case</span> ON_RESUME:            <span class="hljs-keyword">return</span> RESUMED;        <span class="hljs-keyword">case</span> ON_DESTROY:            <span class="hljs-keyword">return</span> DESTROYED;        <span class="hljs-keyword">case</span> ON_ANY:            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unexpected event value "</span> + event);&#125;</code></pre><p>设置状态完毕后需要同步所有的状态(<code>Status</code>)。</p><pre><code class="hljs java"><span class="hljs-comment">//Lifecycle自定义的数据结构，类似HashMap</span><span class="hljs-keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =        <span class="hljs-keyword">new</span> FastSafeIterableMap&lt;&gt;();<span class="hljs-comment">// happens only on the top of stack (never in reentrance),</span><span class="hljs-comment">// so it doesn't have to take in account parents</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">()</span> </span>&#123;    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();    <span class="hljs-keyword">if</span> (lifecycleOwner == <span class="hljs-keyword">null</span>) &#123;        Log.w(LOG_TAG, <span class="hljs-string">"LifecycleOwner is garbage collected, you shouldn't try dispatch "</span>                + <span class="hljs-string">"new events from it."</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">while</span> (!isSynced()) &#123;        <span class="hljs-comment">// mNewEventOccurred 是为了在 observer 触发状态变化时让 backwardPass/forwardPass()</span>        <span class="hljs-comment">// 提前返回用的。我们刚准备调他们，这里设置为 false 即可。</span>        mNewEventOccurred = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// no need to check eldest for nullability, because isSynced does it for us.</span>        <span class="hljs-keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// mObserverMap 里的元素的状态是非递增排列的，也就是说，队头的 state 最大</span>            <span class="hljs-comment">// 如果 mState 小于队列里最大的那个，说明有元素需要更新状态</span>            <span class="hljs-comment">// 为了维持 mObserverMap 的 Invariant，这里我们需要从队尾往前更新元素的状态</span>            backwardPass(lifecycleOwner);        &#125;        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();        <span class="hljs-comment">// 如果 mNewEventOccurred，说明在上面调用 backwardPass() 时，客户触发了状态修改</span>        <span class="hljs-keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="hljs-keyword">null</span>                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="hljs-number">0</span>) &#123;            forwardPass(lifecycleOwner);        &#125;    &#125;    mNewEventOccurred = <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">// 如果所有的 observer 的状态都已经同步完，则返回 true</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSynced</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (mObserverMap.size() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//获取最大状态</span>    State eldestObserverState = mObserverMap.eldest().getValue().mState;    <span class="hljs-comment">//获取最小状态</span>    State newestObserverState = mObserverMap.newest().getValue().mState;    <span class="hljs-comment">// 因为我们保证队头的 state &gt;= 后面的元素的 state，所以只要判断头尾就够了</span>    <span class="hljs-keyword">return</span> eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;&#125;</code></pre><p><code>sync()</code>时发现状态不一致，就需要进行向前或向后的变化。</p><p>使用当前Lifecycle的<code>mState</code>和<code>mObserverMap</code>的最大值进行比较，如果当前<code>mState</code>较小，需要进行递减状态<code>backwardPass()</code></p><p>使用当前Lifecycle的<code>mState</code>和<code>mObserverMap</code>的最小值进行比较，如果当前<code>mState</code>较大，需要进行递增状态<code>forwardPass()</code></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> ArrayList&lt;State&gt; mParentStates = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forwardPass</span><span class="hljs-params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;        <span class="hljs-comment">// 从队头开始迭代</span>        Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =                mObserverMap.iteratorWithAdditions();        <span class="hljs-keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;            Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();            ObserverWithState observer = entry.getValue();            <span class="hljs-comment">//当前observer的state值小于mState，则需递增当前状态到mState</span>            <span class="hljs-keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="hljs-number">0</span> &amp;&amp; !mNewEventOccurred                    <span class="hljs-comment">// 可能在回调客户代码的时候，客户把自己移除了</span>                    &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;                pushParentState(observer.mState);                <span class="hljs-comment">//递增其状态</span>                observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));                popParentState();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backwardPass</span><span class="hljs-params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;        <span class="hljs-comment">// 从队尾开始迭代</span>        Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =                mObserverMap.descendingIterator();        <span class="hljs-keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;            Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();            ObserverWithState observer = entry.getValue();            <span class="hljs-comment">//当前observer的state值大于mState，则需递减当前状态到mState</span>            <span class="hljs-keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="hljs-number">0</span> &amp;&amp; !mNewEventOccurred                    &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;                <span class="hljs-comment">//递减其状态</span>                Event event = downEvent(observer.mState);                pushParentState(getStateAfter(event));                observer.dispatchEvent(lifecycleOwner, event);                popParentState();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">popParentState</span><span class="hljs-params">()</span> </span>&#123;        mParentStates.remove(mParentStates.size() - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushParentState</span><span class="hljs-params">(State state)</span> </span>&#123;        mParentStates.add(state);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Event <span class="hljs-title">downEvent</span><span class="hljs-params">(State state)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (state) &#123;            <span class="hljs-keyword">case</span> INITIALIZED:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();            <span class="hljs-keyword">case</span> CREATED:                <span class="hljs-keyword">return</span> ON_DESTROY;            <span class="hljs-keyword">case</span> STARTED:                <span class="hljs-keyword">return</span> ON_STOP;            <span class="hljs-keyword">case</span> RESUMED:                <span class="hljs-keyword">return</span> ON_PAUSE;            <span class="hljs-keyword">case</span> DESTROYED:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unexpected state value "</span> + state);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Event <span class="hljs-title">upEvent</span><span class="hljs-params">(State state)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (state) &#123;            <span class="hljs-keyword">case</span> INITIALIZED:            <span class="hljs-keyword">case</span> DESTROYED:                <span class="hljs-keyword">return</span> ON_CREATE;            <span class="hljs-keyword">case</span> CREATED:                <span class="hljs-keyword">return</span> ON_START;            <span class="hljs-keyword">case</span> STARTED:                <span class="hljs-keyword">return</span> ON_RESUME;            <span class="hljs-keyword">case</span> RESUMED:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unexpected state value "</span> + state);    &#125;</code></pre><p><code>forwardPass()</code>首先获取一个<code>mObserverMap</code>的迭代器，然后遍历每一子元素，递增其状态并通过<code>dispatchEvent()</code>分发事件，直到状态递增到<code>mState</code>为止。</p><p>假设<code>mObserverMap</code>中的所有都处于<code>CREATED</code>状态，当收到一个<code>ON_START</code>事件时，表示需要进入<code>STARTED</code>状态，由于<code>STARTED</code>较大，需要进行<code>forwardPass()</code>来递增<code>mObserverMap</code>中的状态，其内部调用到<code>upEvent()</code>升至了<code>STARTED</code>，再发送出去，外部接受到的就是<code>ON_START</code>事件。</p><h4 id="注册-注销观察者"><a href="#注册-注销观察者" class="headerlink" title="注册/注销观察者"></a>注册/注销观察者</h4><p>通过<code>addObserver()/removeObserver()</code>控制观察者的添加与移除</p><pre><code class="hljs java"> <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(@NonNull LifecycleObserver observer)</span> </span>&#123;        <span class="hljs-comment">//计算初始状态</span>        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;        ObserverWithState statefulObserver = <span class="hljs-keyword">new</span> ObserverWithState(observer, initialState);        <span class="hljs-comment">//从缓存中获取 observer这个key对应的值</span>        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);        <span class="hljs-comment">//防止重复加入</span>        <span class="hljs-keyword">if</span> (previous != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();        <span class="hljs-keyword">if</span> (lifecycleOwner == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// it is null we should be destroyed. Fallback quickly</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="hljs-number">0</span> || mHandlingEvent;        <span class="hljs-comment">//计算当前lifecycle的状态</span>        State targetState = calculateTargetState(observer);        mAddingObserverCounter++;        <span class="hljs-keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="hljs-number">0</span>                &amp;&amp; mObserverMap.contains(observer))) &#123;            pushParentState(statefulObserver.mState);            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));            popParentState();            <span class="hljs-comment">// 在回调时可能用户操作导致发生变化</span>            targetState = calculateTargetState(observer);        &#125;        <span class="hljs-keyword">if</span> (!isReentrance) &#123;            <span class="hljs-comment">// we do sync only on the top level.</span>            sync();        &#125;        mAddingObserverCounter--;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> State <span class="hljs-title">calculateTargetState</span><span class="hljs-params">(LifecycleObserver observer)</span> </span>&#123;        Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);        State siblingState = previous != <span class="hljs-keyword">null</span> ? previous.getValue().mState : <span class="hljs-keyword">null</span>;        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class="hljs-number">1</span>)                : <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 返回最小的 state</span>        <span class="hljs-keyword">return</span> min(min(mState, siblingState), parentState);    &#125;<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverWithState</span> </span>&#123;    <span class="hljs-comment">//保存当前Observer的状态</span>    State mState;    <span class="hljs-comment">//源Observer的包装类</span>    GenericLifecycleObserver mLifecycleObserver;    ObserverWithState(LifecycleObserver observer, State initialState) &#123;        <span class="hljs-comment">//生成一个原Observer的包装类</span>        mLifecycleObserver = Lifecycling.getCallback(observer);        mState = initialState;    &#125;    <span class="hljs-comment">//该方法将生命周期事件分发到LifecycleObserver中</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEvent</span><span class="hljs-params">(LifecycleOwner owner, Event event)</span> </span>&#123;        State newState = getStateAfter(event);        mState = min(mState, newState);        <span class="hljs-comment">//调用包装类的onStateChanged方法，传递生命周期事件到Observer中</span>        mLifecycleObserver.onStateChanged(owner, event);        mState = newState;    &#125;&#125;</code></pre><p>通过上述流程就完成了添加/移除功能</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><code>@OnLifecycleEvent</code>采用<strong>运行时注解</strong>方式，需要通过反射来执行逻辑。<code>Lifecycle</code>对于该注解采用了 <strong>一次查找后续从缓存中获取</strong>的形式，降低了反射时的性能消耗。详情可参考 <em>androidx.lifecycle.ClassInfoCache</em>内部有具体的逻辑实现。</p><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://jekton.github.io/2018/07/06/android-arch-lifecycle/" target="_blank" rel="noopener">Jekton-Lifecycle</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jetpack-ViewModel简析</title>
    <link href="/2019/02/15/Jetpack-ViewModel%E7%AE%80%E6%9E%90/"/>
    <url>/2019/02/15/Jetpack-ViewModel%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="ViewModel简介"><a href="#ViewModel简介" class="headerlink" title="ViewModel简介"></a>ViewModel简介</h2><blockquote><p>ViewModel是用来存储和管理Lifecycle创建数据的组件，在配置发生改变或者屏幕旋转时数据仍然不会丢失。<strong>ViewModel可以负责组件间的通信，可以高效解决Activity与Fragment的通信问题。</strong></p></blockquote><p>主要的功能还是在非手动关闭以及系统回收条件下进行 Activity/Fragment的数据保存。</p><h2 id="ViewModel使用示例"><a href="#ViewModel使用示例" class="headerlink" title="ViewModel使用示例"></a>ViewModel使用示例</h2><blockquote><p>代码中提供了<code>ViewModel</code>以及<code>AndroidViewModel</code>，这两者的区别在于<code>AndroidViewModel</code>多提供了<code>application</code>入参，可以调用它去获取资源或者其他信息。</p></blockquote><p>添加VIewModel的第三方引用</p><pre><code class="hljs groovy">dependencies &#123;   <span class="hljs-keyword">def</span> lifecycle_version = <span class="hljs-string">"2.0.0"</span>   implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version"</span>   implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-extensions:$lifecycle_version"</span>&#125;</code></pre><p>先创建一个类继承ViewModel<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span></span>&#123;   <span class="hljs-keyword">private</span> String text = <span class="hljs-string">"text"</span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getText</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> text;   &#125;&#125;</code></pre></p><p>创建完毕后，需要在Activity/Fragment中进行调用<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        <span class="hljs-comment">//获取自定义的ViewModel对象</span>        CustomViewModel vm = ViewModelProviders.of(<span class="hljs-keyword">this</span>)                .get(CustomViewModel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">//直接调用内部方法</span>        vm.getText();    &#125;&#125;</code></pre></p><p>上述为最简单的示例，更高级的可以参考<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel" target="_blank" rel="noopener">ViewModel 官方示例</a></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>根据上节的使用示例分析ViewModel中的源码实现。</p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>需要先新建ViewModel实例，等待调用<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span> </span>&#123;    <span class="hljs-comment">//当ViewModel实例被销毁时调用</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"WeakerAccess"</span>)    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//做清空操作</span>    &#125;&#125;</code></pre></p><p>还提供了AndroidViewModel，可以支持传入Application<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span> </span>&#123;    <span class="hljs-keyword">private</span> Application mApplication;    <span class="hljs-comment">//传入Application</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AndroidViewModel</span><span class="hljs-params">(@NonNull Application application)</span> </span>&#123;        mApplication = application;    &#125;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-keyword">public</span> &lt;T extends Application&gt; <span class="hljs-function">T <span class="hljs-title">getApplication</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (T) mApplication;    &#125;&#125;</code></pre></p><h3 id="ViewModelProvider"><a href="#ViewModelProvider" class="headerlink" title="ViewModelProvider"></a>ViewModelProvider</h3><p>创建实例完毕后，需要获取对应实例<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelProviders</span> </span>&#123;   ...    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ViewModelProvider <span class="hljs-title">of</span><span class="hljs-params">(@NonNull Fragment fragment)</span> </span>&#123;        <span class="hljs-keyword">return</span> of(fragment, <span class="hljs-keyword">null</span>);    &#125;        <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ViewModelProvider <span class="hljs-title">of</span><span class="hljs-params">(@NonNull FragmentActivity activity)</span> </span>&#123;        <span class="hljs-keyword">return</span> of(activity, <span class="hljs-keyword">null</span>);    &#125;        <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ViewModelProvider <span class="hljs-title">of</span><span class="hljs-params">(@NonNull Fragment fragment, @Nullable Factory factory)</span> </span>&#123;        Application application = checkApplication(checkActivity(fragment));        <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) &#123;            factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ViewModelProvider(ViewModelStores.of(fragment), factory);    &#125;        <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ViewModelProvider <span class="hljs-title">of</span><span class="hljs-params">(@NonNull FragmentActivity activity,            @Nullable Factory factory)</span> </span>&#123;        Application application = checkApplication(activity);        <span class="hljs-comment">//默认构造器为AndroidViewModel</span>        <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) &#123;            factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);    &#125;&#125;</code></pre></p><p><em>观察源码可知ViewModel支持的类型为<code>FragmentActivity</code>以及<code>support.Fragment。</code></em><br>经过<code>ViewModelProviders.of(FragmentActivity/Fragment)</code>最终得到一个<code>ViewModelProvider</code>实例。<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelProvider</span> </span>&#123;    <span class="hljs-comment">//获取对应ViewModle实例</span>    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-keyword">public</span> &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;        String canonicalName = modelClass.getCanonicalName();        <span class="hljs-keyword">if</span> (canonicalName == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Local and anonymous classes can not be ViewModels"</span>);        &#125;        <span class="hljs-keyword">return</span> get(DEFAULT_KEY + <span class="hljs-string">":"</span> + canonicalName, modelClass);    &#125;        <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-keyword">public</span> &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;        <span class="hljs-comment">//从ViewModelStore缓存中获取对应ViewModel实例</span>        ViewModel viewModel = mViewModelStore.get(key);        <span class="hljs-comment">//如果相同就直接返回缓存中实例</span>        <span class="hljs-keyword">if</span> (modelClass.isInstance(viewModel)) &#123;            <span class="hljs-keyword">return</span> (T) viewModel;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//noinspection StatementWithEmptyBody</span>            <span class="hljs-keyword">if</span> (viewModel != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> log a warning.</span>            &#125;        &#125;        <span class="hljs-comment">//不存在，则创建新实例</span>        viewModel = mFactory.create(modelClass);        <span class="hljs-comment">//创建完毕后放入缓存中</span>        mViewModelStore.put(key, viewModel);        <span class="hljs-keyword">return</span> (T) viewModel;    &#125;&#125;</code></pre></p><p><code>ViewModelStore</code>负责存放<code>ViewModel</code>的缓存数据，可以保证不会重复创建新实例。<br>源码中提供了两种Factory类：<code>AndroidViewModelFactory(默认使用)</code>及<code>NewInstanceFactory</code>。<br><pre><code class="hljs java"><span class="hljs-comment">//创建对应实例</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-meta">@NonNull</span>    &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(@NonNull Class&lt;T&gt; modelClass)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewInstanceFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"ClassNewInstance"</span>)    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//创建ViewModel新实例</span>            <span class="hljs-keyword">return</span> modelClass.newInstance();        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Cannot create an instance of "</span> + modelClass, e);        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Cannot create an instance of "</span> + modelClass, e);        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidViewModelFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModelProvider</span>.<span class="hljs-title">NewInstanceFactory</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AndroidViewModelFactory sInstance;    <span class="hljs-comment">//单例模式</span>    <span class="hljs-meta">@NonNull</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AndroidViewModelFactory <span class="hljs-title">getInstance</span><span class="hljs-params">(@NonNull Application application)</span> </span>&#123;        <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-keyword">null</span>) &#123;            sInstance = <span class="hljs-keyword">new</span> AndroidViewModelFactory(application);        &#125;        <span class="hljs-keyword">return</span> sInstance;    &#125;    <span class="hljs-keyword">private</span> Application mApplication;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AndroidViewModelFactory</span><span class="hljs-params">(@NonNull Application application)</span> </span>&#123;        mApplication = application;    &#125;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;        <span class="hljs-comment">//判断传入的ViewModel是否继承自AndroidViewModel</span>        <span class="hljs-keyword">if</span> (AndroidViewModel<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">modelClass</span>)) </span>&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//创建一个AndroidViewModel实例</span>                <span class="hljs-keyword">return</span> modelClass.getConstructor(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">newInstance</span>(<span class="hljs-title">mApplication</span>)</span>;            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Cannot create an instance of "</span> + modelClass, e);            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Cannot create an instance of "</span> + modelClass, e);            &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Cannot create an instance of "</span> + modelClass, e);            &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Cannot create an instance of "</span> + modelClass, e);            &#125;        &#125;        <span class="hljs-comment">//否则向上调用父类 NewInstanceFactory的创建方法</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.create(modelClass);    &#125;&#125;</code></pre></p><p>默认使用<code>AndroidViewModelFactory</code>，需要传入<code>Application</code>参数构建一个<code>ViewModel</code>类型，否则需要调用到<code>NewInstanceFactory</code>去构建，创造出一个无参构造的ViewModel类。</p><p>构建完成后，将其放到<code>ViewModelStore</code>中进行缓存，以便下次调用。</p><h3 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a>ViewModelStore</h3><p>通过<code>ViewModelStores.of()</code>获取到ViewModelStore这一缓存对象。<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelStores</span></span>&#123;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ViewModelStore <span class="hljs-title">of</span><span class="hljs-params">(@NonNull FragmentActivity activity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> ViewModelStoreOwner) &#123;            <span class="hljs-keyword">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();        &#125;        <span class="hljs-keyword">return</span> holderFragmentFor(activity).getViewModelStore();    &#125;        <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ViewModelStore <span class="hljs-title">of</span><span class="hljs-params">(@NonNull Fragment fragment)</span> </span>&#123;        <span class="hljs-keyword">if</span> (fragment <span class="hljs-keyword">instanceof</span> ViewModelStoreOwner) &#123;            <span class="hljs-keyword">return</span> ((ViewModelStoreOwner) fragment).getViewModelStore();        &#125;        <span class="hljs-keyword">return</span> holderFragmentFor(fragment).getViewModelStore();    &#125;&#125;</code></pre></p><blockquote><p>在这里有个注意点：<code>activity instanceof ViewModelStoreOwner</code>在support 27.1.0以上这个判断是成立的，因为<code>FragmentActivity以及Fragment</code>都已经实现了<code>ViewModelStoreOwner</code>接口，就直接调用系统内实现好的<code>ViewModelStore</code>即可。<br>在support 27.1.0以下的还未实现，依然需要开发者自己去实现，或者直接调用<code>HolderFragment</code>的系统实现。</p></blockquote><p>与<code>ViewModelProvides</code>类似，通过<code>of()</code>去获取到实例。<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelStore</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">//放入ViewModel实例</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, ViewModel viewModel)</span> </span>&#123;        ViewModel oldViewModel = mMap.put(key, viewModel);        <span class="hljs-keyword">if</span> (oldViewModel != <span class="hljs-keyword">null</span>) &#123;            oldViewModel.onCleared();        &#125;    &#125;    <span class="hljs-comment">//获取ViewModel实例</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> ViewModel <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> mMap.get(key);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (ViewModel vm : mMap.values()) &#123;            vm.onCleared();        &#125;        mMap.clear();    &#125;&#125;</code></pre></p><h3 id="HolderFragment"><a href="#HolderFragment" class="headerlink" title="HolderFragment"></a>HolderFragment</h3><p><code>HolderFragment</code>是一个Fragment组件，没有UI界面，唯一的作用就是<strong>存储数据(ViewModelStore)</strong>。<br>对于每一个使用了<code>ViewModel</code>的Activity/Fragment都会动态的为其添加一个<code>HolderFragment</code>，其实现了<code>ViewModelStoreOwner</code>接口，可以直接获取到内部存储的<code>ViewModelStore</code>数据。<br><code>HolderFragment</code>是整个ViewModel源码实现的核心，由它进行数据存储且保证发生屏幕旋转等配置改变时存储的数据不会丢失。<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HolderFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewModelStoreOwner</span> </span>&#123;    ...<span class="hljs-keyword">private</span> ViewModelStore mViewModelStore = <span class="hljs-keyword">new</span> ViewModelStore();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HolderFragment</span><span class="hljs-params">()</span> </span>&#123;        setRetainInstance(<span class="hljs-keyword">true</span>);①    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        sHolderFragmentManager.holderFragmentCreated(<span class="hljs-keyword">this</span>);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.onDestroy();        <span class="hljs-comment">//Fragment销毁时，清空自身存储的ViewModel</span>        mViewModelStore.clear();    &#125;         <span class="hljs-meta">@RestrictTo</span>(RestrictTo.Scope.LIBRARY_GROUP)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HolderFragment <span class="hljs-title">holderFragmentFor</span><span class="hljs-params">(FragmentActivity activity)</span> </span>&#123;        <span class="hljs-keyword">return</span> sHolderFragmentManager.holderFragmentFor(activity);    &#125;    <span class="hljs-meta">@RestrictTo</span>(RestrictTo.Scope.LIBRARY_GROUP)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HolderFragment <span class="hljs-title">holderFragmentFor</span><span class="hljs-params">(Fragment fragment)</span> </span>&#123;        <span class="hljs-keyword">return</span> sHolderFragmentManager.holderFragmentFor(fragment);    &#125;         <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HolderFragmentManager</span> </span>&#123;        <span class="hljs-comment">//储存那些已调用commit()但是还没有被添加进宿主Activity的HolderFragment，在真正创建完毕</span>        <span class="hljs-comment">//即调用到 onCreate()时才算添加进入。 </span>        <span class="hljs-keyword">private</span> Map&lt;Activity, HolderFragment&gt; mNotCommittedActivityHolders = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">private</span> Map&lt;Fragment, HolderFragment&gt; mNotCommittedFragmentHolders = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                          ...        <span class="hljs-comment">//HoldFragment添加至宿主Activity完毕</span>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">holderFragmentCreated</span><span class="hljs-params">(Fragment holderFragment)</span> </span>&#123;            Fragment parentFragment = holderFragment.getParentFragment();            <span class="hljs-keyword">if</span> (parentFragment != <span class="hljs-keyword">null</span>) &#123;                mNotCommittedFragmentHolders.remove(parentFragment);                parentFragment.getFragmentManager().unregisterFragmentLifecycleCallbacks(                        mParentDestroyedCallback);            &#125; <span class="hljs-keyword">else</span> &#123;                mNotCommittedActivityHolders.remove(holderFragment.getActivity());            &#125;        &#125;        <span class="hljs-comment">//根据HOLDER_TAG寻找对应的HolderFragment</span>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HolderFragment <span class="hljs-title">findHolderFragment</span><span class="hljs-params">(FragmentManager manager)</span> </span>&#123;            <span class="hljs-keyword">if</span> (manager.isDestroyed()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Can't access ViewModels from onDestroy"</span>);            &#125;            Fragment fragmentByTag = manager.findFragmentByTag(HOLDER_TAG);            <span class="hljs-keyword">if</span> (fragmentByTag != <span class="hljs-keyword">null</span> &amp;&amp; !(fragmentByTag <span class="hljs-keyword">instanceof</span> HolderFragment)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unexpected "</span>                        + <span class="hljs-string">"fragment instance was returned by HOLDER_TAG"</span>);            &#125;            <span class="hljs-keyword">return</span> (HolderFragment) fragmentByTag;        &#125;                 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HolderFragment <span class="hljs-title">createHolderFragment</span><span class="hljs-params">(FragmentManager fragmentManager)</span> </span>&#123;            HolderFragment holder = <span class="hljs-keyword">new</span> HolderFragment();            fragmentManager.beginTransaction().add(holder, HOLDER_TAG).commitAllowingStateLoss();            <span class="hljs-keyword">return</span> holder;        &#125;                  <span class="hljs-function">HolderFragment <span class="hljs-title">holderFragmentFor</span><span class="hljs-params">(FragmentActivity activity)</span> </span>&#123;            FragmentManager fm = activity.getSupportFragmentManager();            HolderFragment holder = findHolderFragment(fm);            <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> holder;                        <span class="hljs-comment">//获取对应HolderFragment实例</span>            holder = mNotCommittedActivityHolders.get(activity);            <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> holder;            &#125;            <span class="hljs-keyword">if</span> (!mActivityCallbacksIsAdded) &#123;                <span class="hljs-comment">//添加Activity生命周期监听</span>                mActivityCallbacksIsAdded = <span class="hljs-keyword">true</span>;                activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks);            &#125;            <span class="hljs-comment">//创建一个HolderFragment对象</span>            holder = createHolderFragment(fm);            mNotCommittedActivityHolders.put(activity, holder);            <span class="hljs-keyword">return</span> holder;        &#125;        <span class="hljs-function">HolderFragment <span class="hljs-title">holderFragmentFor</span><span class="hljs-params">(Fragment parentFragment)</span> </span>&#123;            FragmentManager fm = parentFragment.getChildFragmentManager();            HolderFragment holder = findHolderFragment(fm);            <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> holder;            &#125;                        holder = mNotCommittedFragmentHolders.get(parentFragment);            <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> holder;            &#125;            parentFragment.getFragmentManager()                    .registerFragmentLifecycleCallbacks(mParentDestroyedCallback, <span class="hljs-keyword">false</span>);            holder = createHolderFragment(fm);            mNotCommittedFragmentHolders.put(parentFragment, holder);            <span class="hljs-keyword">return</span> holder;        &#125;     &#125;&#125;</code></pre></p><p><code>HolderFragment</code>通过调用<code>HolderFragmentManager.holderFragmentFor()</code>获取最终的<code>HolderFragment</code>。</p><p>主要有以下几步：</p><ol><li>根据HOLDER_TAG，从宿主的<code>FragmentManager</code>中查询对应Tag的HolderFragment，找到则返回</li><li>再从<code>mNotCommitedActivityHolder</code>中查找<code>HolderFragment</code>实例，找到则返回</li><li>为宿主添加生命周期监听，可以在销毁时及时移除数据</li><li>使用HOLDER_TAG创建一个<code>HolderFragment</code>，并添加到宿主上</li><li>再添加至<code>mNotCommitedActivityHolder</code>缓存中，等待<code>HolderFragment.onCreate()</code>执行时移除。</li></ol><p>①<code>setRetainInstance(true)</code>：不会销毁Fragment实例</p><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>源码分析完毕后，对总流程进行总结：</p><ul><li><code>ViewModelProviders</code>创建对应的<code>ViewModelProvider</code>对象</li><li><code>ViewModelStores</code>获取<code>ViewModelStore</code>对象</li><li>创建<code>HolderFragment</code>添加至宿主Activity或Fragment上，并返回ViewModelStore对象</li><li><code>ViewModelProvider</code>创建<code>ViewModel</code>对象，并配合<code>ViewModelStore</code>进行缓存</li></ul><h2 id="ViewModel拓展知识"><a href="#ViewModel拓展知识" class="headerlink" title="ViewModel拓展知识"></a>ViewModel拓展知识</h2><h3 id="ViewModel与onSaveInstanceState-区别"><a href="#ViewModel与onSaveInstanceState-区别" class="headerlink" title="ViewModel与onSaveInstanceState()区别"></a>ViewModel与<code>onSaveInstanceState()</code>区别</h3><ul><li>两者都可以进行保存数据，但是<code>ViewModel</code>可以支持保存更多数据</li><li>当Activity因为系统内存紧张被回收时，<code>onSaveInstanceState()</code>可以恢复数据，而<code>ViewModel</code>因为<code>HolderFragment</code>被销毁数据也随之丢失。</li><li>两者都只是临时性存储</li></ul><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://blog.csdn.net/hyc1988107/article/details/81456460" target="_blank" rel="noopener">ViewModel源码分析</a></p><p><a href="https://jekton.github.io/2018/06/30/android-arch-ViewModel/" target="_blank" rel="noopener">Jekton-ViewModel</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jetpack-LiveData简析</title>
    <link href="/2019/02/15/Jetpack-LiveData%E7%AE%80%E6%9E%90/"/>
    <url>/2019/02/15/Jetpack-LiveData%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="LiveData简介"><a href="#LiveData简介" class="headerlink" title="LiveData简介"></a>LiveData简介</h2><p>本质上是一个观察者模式，在Activity/Fragment中实现观察者，LiveData是被观察者，在LiveData存储的数据变更时触发事件。</p><p>LiveData还具有<strong>生命周期感知</strong>能力，可以控制在应用可见时去更新UI，不可见时不执行操作，减少了内存泄露问题。</p><h2 id="LiveData示例"><a href="#LiveData示例" class="headerlink" title="LiveData示例"></a>LiveData示例</h2><p>一般情况下<code>LiveData</code>要配合着<code>ViewModel</code>一起使用，ViewModel负责触发数据更新，LiveData负责通知观察者数据更新。</p><p>引入LiveData三方库</p><pre><code class="hljs groovy">dependencies &#123;    <span class="hljs-keyword">def</span> lifecycle_version = <span class="hljs-string">"2.0.0"</span>    implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-livedata:$lifecycle_version"</span>    implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-runtime:$lifecycle_version"</span> &#125;</code></pre><p>新建ViewModel类并包含LiveData</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiveDataViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewModel</span> </span>&#123;    <span class="hljs-keyword">private</span> MutableLiveData&lt;String&gt; currentText;    <span class="hljs-function"><span class="hljs-keyword">public</span> MutableLiveData&lt;String&gt; <span class="hljs-title">getCurrentText</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (currentText == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MutableLiveData&lt;&gt;();        <span class="hljs-keyword">return</span> currentText;    &#125;&#125;</code></pre><p>在Activity/Fragment中添加监听</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-keyword">private</span> LiveDataViewModel viewModel;    <span class="hljs-keyword">private</span> TextView textView;    <span class="hljs-keyword">private</span> Button button;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        textView = findViewById(R.id.text);        button = findViewById(R.id.btn1);        viewModel = ViewModelProviders.of(NewActivity.<span class="hljs-keyword">this</span>).get(LiveDataViewModel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">final</span> Observer&lt;String&gt; testObserver = <span class="hljs-keyword">new</span> Observer&lt;String&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-comment">//监听回调</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(String s)</span> </span>&#123;                textView.setText(s);            &#125;        &#125;;        <span class="hljs-comment">//注册监听</span>        viewModel.getCurrentText().observe(<span class="hljs-keyword">this</span>, testObserver);        button.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;                viewModel.getCurrentText().setValue(<span class="hljs-string">"12"</span> + System.currentTimeMillis());            &#125;        &#125;);    &#125;&#125;</code></pre><p>这样即可以实现监听功能。</p><p>想了解更多实例可参考<a href="https://developer.android.google.cn/topic/libraries/architecture/livedata#java" target="_blank" rel="noopener">LiveData官方示例</a></p><h2 id="LiveData源码解析"><a href="#LiveData源码解析" class="headerlink" title="LiveData源码解析"></a>LiveData源码解析</h2><h3 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiveData</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    ...&#125;</code></pre><p><code>LiveData</code>是一个抽象类无法直接使用，一般都是应用其子类<code>MutableLiveData</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutableLiveData</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LiveData</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postValue</span><span class="hljs-params">(T value)</span> </span>&#123;        <span class="hljs-keyword">super</span>.postValue(value);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T value)</span> </span>&#123;        <span class="hljs-keyword">super</span>.setValue(value);    &#125;&#125;</code></pre><p><code>MutableLiveData</code>多了设置数据的方法，以便开发者对内容进行修改。若不想有人进行修改，可以返回<code>LiveData</code>保证安全。</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>构建LiveData完毕后，需要对其添加监听。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">/**     * Called when the data is changed.     * <span class="hljs-doctag">@param</span> t  The new data     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(T t)</span></span>;&#125;</code></pre><p><code>Observer</code>只提供数据变化的监听并返回修改后的结果。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> SafeIterableMap&lt;Observer&lt;? <span class="hljs-keyword">super</span> T&gt;, ObserverWrapper&gt; mObservers =            <span class="hljs-keyword">new</span> SafeIterableMap&lt;&gt;();   <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">observe</span><span class="hljs-params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;        <span class="hljs-comment">//监测是否在主线程操作</span>        assertMainThread(<span class="hljs-string">"observe"</span>);        <span class="hljs-comment">// Activity/Frgment已被销毁就无需添加监听</span>        <span class="hljs-keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;            <span class="hljs-comment">// ignore</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//关键点</span>        LifecycleBoundObserver wrapper = <span class="hljs-keyword">new</span> LifecycleBoundObserver(owner, observer);        <span class="hljs-comment">//取出对应的Observer</span>        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);        <span class="hljs-keyword">if</span> (existing != <span class="hljs-keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot add the same observer"</span>                    + <span class="hljs-string">" with different lifecycles"</span>);        &#125;        <span class="hljs-comment">//已存在就无需重复添加</span>        <span class="hljs-keyword">if</span> (existing != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//添加对应监听 而且只在UI可见时会有回调</span>        owner.getLifecycle().addObserver(wrapper);    &#125;    <span class="hljs-comment">//支持监听永久存在，不会因为Activity/Fragment销毁而消失</span>    <span class="hljs-meta">@MainThread</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">observeForever</span><span class="hljs-params">(@NonNull Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;        assertMainThread(<span class="hljs-string">"observeForever"</span>);        AlwaysActiveObserver wrapper = <span class="hljs-keyword">new</span> AlwaysActiveObserver(observer);        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);        <span class="hljs-keyword">if</span> (existing != <span class="hljs-keyword">null</span> &amp;&amp; existing <span class="hljs-keyword">instanceof</span> LiveData.LifecycleBoundObserver) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot add the same observer"</span>                    + <span class="hljs-string">" with different lifecycles"</span>);        &#125;        <span class="hljs-keyword">if</span> (existing != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//无需理会 宿主状态</span>        wrapper.activeStateChanged(<span class="hljs-keyword">true</span>);    &#125;</code></pre><ul><li>当宿主组件已经Destroy时，就无需添加监听</li><li>需要新建一个<code>LifecycleBoundObserver</code>保存<code>owner以及observer</code></li><li>从<code>mObservers.putIfAbsent()</code>中去获取或者插入对应observer</li><li>返回为null，则对<code>owner</code>添加该监听。</li></ul><h3 id="LifecycleBoundObserver"><a href="#LifecycleBoundObserver" class="headerlink" title="LifecycleBoundObserver"></a>LifecycleBoundObserver</h3><pre><code class="hljs java"><span class="hljs-comment">//LiveData激活时回掉</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActive</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//LiveData销毁时回掉</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInactive</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverWrapper</span> </span>&#123;    <span class="hljs-keyword">final</span> Observer&lt;? <span class="hljs-keyword">super</span> T&gt; mObserver;    <span class="hljs-keyword">boolean</span> mActive;    <span class="hljs-keyword">int</span> mLastVersion = START_VERSION;    ObserverWrapper(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer) &#123;        mObserver = observer;    &#125;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldBeActive</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAttachedTo</span><span class="hljs-params">(LifecycleOwner owner)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detachObserver</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">activeStateChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> newActive)</span> </span>&#123;        <span class="hljs-keyword">if</span> (newActive == mActive) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// immediately set active state, so we'd never dispatch anything to inactive</span>        <span class="hljs-comment">// owner</span>        mActive = newActive;        <span class="hljs-comment">//mActiveCount 表示当前处于active的observer数量</span>        <span class="hljs-keyword">boolean</span> wasInactive = LiveData.<span class="hljs-keyword">this</span>.mActiveCount == <span class="hljs-number">0</span>;        LiveData.<span class="hljs-keyword">this</span>.mActiveCount += mActive ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;            onActive();        &#125;        <span class="hljs-comment">//激活数量为0  说明都被销毁</span>        <span class="hljs-keyword">if</span> (LiveData.<span class="hljs-keyword">this</span>.mActiveCount == <span class="hljs-number">0</span> &amp;&amp; !mActive) &#123;            onInactive();        &#125;        <span class="hljs-keyword">if</span> (mActive) &#123;            <span class="hljs-comment">//分发数据</span>            dispatchingValue(<span class="hljs-keyword">this</span>);        &#125;    &#125;&#125;<span class="hljs-comment">//绑定了生命周期</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifecycleBoundObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ObserverWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GenericLifecycleObserver</span> </span>&#123;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-keyword">final</span> LifecycleOwner mOwner;    LifecycleBoundObserver(<span class="hljs-meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer) &#123;        <span class="hljs-keyword">super</span>(observer);        mOwner = owner;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldBeActive</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//至少是用户可见状态即 onStart() ~ onStop()</span>        <span class="hljs-keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;            <span class="hljs-comment">//处于销毁态时 及时移除监听防止内存泄露</span>            removeObserver(mObserver);            <span class="hljs-keyword">return</span>;        &#125;        activeStateChanged(shouldBeActive());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAttachedTo</span><span class="hljs-params">(LifecycleOwner owner)</span> </span>&#123;        <span class="hljs-keyword">return</span> mOwner == owner;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detachObserver</span><span class="hljs-params">()</span> </span>&#123;        mOwner.getLifecycle().removeObserver(<span class="hljs-keyword">this</span>);    &#125;&#125;</code></pre><h3 id="发布修改"><a href="#发布修改" class="headerlink" title="发布修改"></a>发布修改</h3><p>设置数据完毕后，需要通知到监听者进行响应</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiveData</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-comment">// 同步修改数据</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T value)</span></span>;    <span class="hljs-comment">// 会用 Handler post 一个 runnable，然后在 runnable 里面 setValue</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postValue</span><span class="hljs-params">(T value)</span></span>;&#125;</code></pre><p><code>postValue()及setValue()</code>都是<code>protected</code>只有本身及子类才可以调用，又由于<code>LiveData</code>为<code>abstract</code>不可用<code>new</code>即使用子类才可以修改数据。</p><h4 id="setValue-：同步调用"><a href="#setValue-：同步调用" class="headerlink" title="setValue()：同步调用"></a>setValue()：同步调用</h4><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Object mData = NOT_SET;    <span class="hljs-comment">//需要执行在主线程</span>   <span class="hljs-meta">@MainThread</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T value)</span> </span>&#123;       <span class="hljs-comment">//监测是否运行在主线程</span>       assertMainThread(<span class="hljs-string">"setValue"</span>);       <span class="hljs-comment">//每修改一次数据，就添加一次版本号</span>       mVersion++;       <span class="hljs-comment">//即将发送的数据</span>       mData = value;       dispatchingValue(<span class="hljs-keyword">null</span>);   &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchingValue</span><span class="hljs-params">(@Nullable ObserverWrapper initiator)</span> </span>&#123;       <span class="hljs-keyword">if</span> (mDispatchingValue) &#123;           <span class="hljs-comment">//在onChanged的回调中 再次调用 setValue()时触发</span>           <span class="hljs-comment">//final Observer&lt;String&gt; testObserver = new Observer&lt;String&gt;() &#123;</span>           <span class="hljs-comment">//@Override</span>           <span class="hljs-comment">//public void onChanged(String s) &#123;</span>           <span class="hljs-comment">//    textView.setText(s);</span>           <span class="hljs-comment">//    viewModel.getCurrentText().setValue("12" + System.currentTimeMillis());</span>           <span class="hljs-comment">//&#125;</span>           <span class="hljs-comment">//&#125;;</span>           mDispatchInvalidated = <span class="hljs-keyword">true</span>;           <span class="hljs-keyword">return</span>;       &#125;       <span class="hljs-comment">//为了防止循环调用</span>       mDispatchingValue = <span class="hljs-keyword">true</span>;       <span class="hljs-keyword">do</span> &#123;           mDispatchInvalidated = <span class="hljs-keyword">false</span>;           <span class="hljs-keyword">if</span> (initiator != <span class="hljs-keyword">null</span>) &#123;               considerNotify(initiator);               initiator = <span class="hljs-keyword">null</span>;           &#125; <span class="hljs-keyword">else</span> &#123;               <span class="hljs-keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="hljs-keyword">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =                       mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;                   <span class="hljs-comment">//回调到对应方法</span>                   considerNotify(iterator.next().getValue());                   <span class="hljs-keyword">if</span> (mDispatchInvalidated) &#123;                       <span class="hljs-keyword">break</span>;                   &#125;               &#125;           &#125;       &#125; <span class="hljs-keyword">while</span> (mDispatchInvalidated);       mDispatchingValue = <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-comment">//该方法可能在生命周期发送变更时被多次调用 但是数据却没有变化</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">considerNotify</span><span class="hljs-params">(ObserverWrapper observer)</span> </span>&#123;       <span class="hljs-keyword">if</span> (!observer.mActive) &#123;           <span class="hljs-keyword">return</span>;       &#125;       <span class="hljs-comment">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span>       <span class="hljs-comment">//</span>       <span class="hljs-comment">// we still first check observer.active to keep it as the entrance for events. So even if</span>       <span class="hljs-comment">// the observer moved to an active state, if we've not received that event, we better not</span>       <span class="hljs-comment">// notify for a more predictable notification order.</span>       <span class="hljs-keyword">if</span> (!observer.shouldBeActive()) &#123;           observer.activeStateChanged(<span class="hljs-keyword">false</span>);           <span class="hljs-keyword">return</span>;       &#125;       <span class="hljs-comment">//判定当前的分发是否有setValue()触发 利用mVersion </span>       <span class="hljs-keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;           <span class="hljs-keyword">return</span>;       &#125;       <span class="hljs-comment">//重置成当前记录的mVersion</span>       observer.mLastVersion = mVersion;       <span class="hljs-comment">//回调到设置的 onChanged()</span>       observer.mObserver.onChanged((T) mData);   &#125;</code></pre><h5 id="源码简述"><a href="#源码简述" class="headerlink" title="源码简述"></a>源码简述</h5><p>调用<code>setValue()</code>：</p><ul><li>先监测当前是否在主线程运行，否则抛出异常结束运行</li><li>设置当前存储的<code>mVersion+1</code>，以待后用</li><li>调用<code>dispatchValue()</code>进行数据分发</li><li>首先判断当前是否存在循环调用，在<code>dispatchValue()</code>中设置<code>mDispatchingValue</code>为true，操作结束完毕再设置false。还有一个<code>mDispatchInvalidated</code>标志位，如果该标志为true，表明已经发生了循环调用，需要重新开始。</li><li><code>considerNotify()</code>将消息发送到对应的观察者上，需要判定当前是否是因为调用<code>setValue()</code>导致的分发，因为在UI不可见时也不会调用分发，只有可见时才会调用，就可能导致重复分发，需要使用到<code>mVersion</code>来进行一次判定，如果小于记录的<code>mVersion</code>。即进行分发结束一次分发过程。</li></ul><blockquote><p>当Activity/Fragment挂在后台时，LiveData不会分发数据，<code>setValue()</code>的值就会被缓存到<code>mData</code>中，但是只能缓存一个值，所以当再次回到前台时，最终打到的就是最新的一次<code>setValue()</code>的数据。</p></blockquote><h4 id="postValue-：异步调用"><a href="#postValue-：异步调用" class="headerlink" title="postValue()：异步调用"></a>postValue()：异步调用</h4><pre><code class="hljs java"><span class="hljs-comment">// 使用volatile进行修饰，因为mPendingData 可能被其他线程进行修改</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Object mPendingData = NOT_SET;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable mPostValueRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        Object newValue;        <span class="hljs-keyword">synchronized</span> (mDataLock) &#123;            newValue = mPendingData;            mPendingData = NOT_SET;        &#125;        <span class="hljs-comment">//本质还是调用到了setValue()</span>        setValue((T) newValue);    &#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postValue</span><span class="hljs-params">(T value)</span> </span>&#123;    <span class="hljs-keyword">boolean</span> postTask;    <span class="hljs-keyword">synchronized</span> (mDataLock) &#123;        postTask = mPendingData == NOT_SET;        mPendingData = value;    &#125;    <span class="hljs-comment">//表明此时已有Runnable在执行，无需重复执行</span>    <span class="hljs-keyword">if</span> (!postTask) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//切换到主线程</span>    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);&#125;</code></pre><p><code>postValue()</code>利用<code>ArchTaskExecutor</code>将发送消息逻辑切换到主线程上，实质执行的还是<code>setValue()</code>。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArchTaskExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TaskExecutor</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> ArchTaskExecutor sInstance;        <span class="hljs-meta">@NonNull</span>    <span class="hljs-keyword">private</span> TaskExecutor mDefaultTaskExecutor;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ArchTaskExecutor</span><span class="hljs-params">()</span> </span>&#123;        mDefaultTaskExecutor = <span class="hljs-keyword">new</span> DefaultTaskExecutor();        mDelegate = mDefaultTaskExecutor;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postToMainThread</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;        mDelegate.postToMainThread(runnable);    &#125;&#125;</code></pre><p><code>archTaskExecutor</code>实质调用的是<code>DefaultTaskExecutor</code>去执行切换主线程任务</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postToMainThread</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mMainHandler == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            <span class="hljs-keyword">if</span> (mMainHandler == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//获取主线程Looper 并生成对应Handler</span>                mMainHandler = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());            &#125;        &#125;    &#125;    <span class="hljs-comment">//noinspection ConstantConditions</span>    mMainHandler.post(runnable);&#125;</code></pre><p>通过<code>Handler</code>进行了主线程切换。</p><h5 id="源码简述-1"><a href="#源码简述-1" class="headerlink" title="源码简述"></a>源码简述</h5><p><code>postValue()</code>调用过程：</p><ul><li>先根据<code>mPendingData</code>的值判定是否需要执行任务，当已有任务在执行时，不需要重复执行</li><li>调用<code>ArchArchTaskExecutor</code>实质调用了<code>DefaultTaskExecutor</code>去执行<code>postToMainThread()</code></li><li>本质通过<code>Handler</code>进行了线程切换任务</li><li>最后切换主线程完毕后，去调用<code>setValue()</code>发送数据</li></ul><h2 id="LiveData拓展"><a href="#LiveData拓展" class="headerlink" title="LiveData拓展"></a>LiveData拓展</h2><ol><li>根据源码分析，LiveData的数据接受的生命周期只在<code>onStart()</code>-&gt; <code>onPause()</code>中，其他时间无法分发消息，只有等到回到用户可见时重新开始分发过程。</li><li><code>LiveData</code>是通过<code>Lifecycle</code>与Activity/Fragment进行生命周期绑定的。</li><li>由于<code>LiveData</code>是与生命周期进行绑定的，即使宿主被销毁，也不会造成内存泄露。</li></ol><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://jekton.github.io/2018/07/14/android-arch-LiveData/" target="_blank" rel="noopener">Jekton-LiveData</a></p><p><a href="https://juejin.im/post/5baee5205188255c930dea8a" target="_blank" rel="noopener">LiveData的工作原理</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="/2019/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p></blockquote><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hook技术简析</title>
    <link href="/2019/02/06/Hook%E6%8A%80%E6%9C%AF%E7%AE%80%E6%9E%90/"/>
    <url>/2019/02/06/Hook%E6%8A%80%E6%9C%AF%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>说到Hook技术需要先提到逆向工程，主要目的是<strong>在不能轻易获得必要生产信息的情况下，直接从成品分析，推导出产品的设计原理</strong>。</p><p>逆向分析又分为</p><ul><li>静态分析：不执行程序的情况下对程序行为进行分析的技术</li><li>动态分析：在程序运行时对程序进行调试的技术。<em>Hook属于动态分析。</em></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><a href="/2018/04/09/动态代理模式原理及实现/" title="设计模式--静态代理模式和动态代理模式原理及实现">设计模式--静态代理模式和动态代理模式原理及实现</a><h2 id="Hook技术概述"><a href="#Hook技术概述" class="headerlink" title="Hook技术概述"></a>Hook技术概述</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/正常的调用与回调.png" srcset="/img/loading.gif" class="full-image" alt="正常的调用与回调" title="正常的调用与回调"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>对象A直接调用B，对象B结果直接回调给A。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Hook后的调用与回调.png" srcset="/img/loading.gif" class="full-image" alt="Hook后的调用与回调" title="Hook后的调用与回调"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>Hook可以是一个方法或者对象，它位于对象A和B之间，当对象A调用对象B时会在之前做一些处理。也可以用于应用进程调用系统进程时做一些处理，更改他们间的关系。</p><p>其中被Hook的对象B，称作<strong>Hook点</strong>。</p><p>整个Hook的过程分为三步：</p><ol><li><strong>寻找Hook点</strong>。原则上是静态变量或者单例对象(<strong>容易找到并且不易变化的对象</strong>)，尽量Hook Public的对象和方法，非Public不保证每个版本保持一致，可能需要适配。</li><li><strong>选择合适的代理方式</strong>。如果是接口可以使用动态代理方式，类的话多考虑使用静态模式。</li><li><strong>用代理对象替换原始对象。</strong></li></ol><h2 id="Hook实例简析"><a href="#Hook实例简析" class="headerlink" title="Hook实例简析"></a>Hook实例简析</h2><h3 id="Hook-startActivity"><a href="#Hook-startActivity" class="headerlink" title="Hook startActivity()"></a>Hook <code>startActivity()</code></h3><p>Activity的启动方式有两种</p><ul><li><p>一个Activity启动另一个Activity</p><pre><code class="hljs java">startActivity(<span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,XXActivity<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;</code></pre></li></ul><ul><li><p>通过Service或者其他非Activity类进行启动Activity(<em>必须设置 FLAG_NEW_TASK</em>)</p><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, XXActivity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);context.startActivity(intent);</code></pre></li></ul><h4 id="1-Hook-Activity-startActivity"><a href="#1-Hook-Activity-startActivity" class="headerlink" title="1.Hook Activity.startActivity()"></a>1.Hook <code>Activity.startActivity()</code></h4><p>从源码分析上需要从<code>startActivity()</code>开始</p><pre><code class="hljs java">   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent)</span> </span>&#123;       <span class="hljs-keyword">this</span>.startActivity(intent, <span class="hljs-keyword">null</span>);   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;       <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;           startActivityForResult(intent, -<span class="hljs-number">1</span>, options);       &#125; <span class="hljs-keyword">else</span> &#123;           startActivityForResult(intent, -<span class="hljs-number">1</span>);       &#125;   &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivityForResult</span><span class="hljs-params">(@RequiresPermission Intent intent, <span class="hljs-keyword">int</span> requestCode,           @Nullable Bundle options)</span> </span>&#123;       <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;           options = transferSpringboardActivityOptions(options);           Instrumentation.ActivityResult ar =               mInstrumentation.execStartActivity(                   <span class="hljs-keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="hljs-keyword">this</span>,                   intent, requestCode, options);         ...       &#125;&#125;</code></pre><p>最终调用到的是<code>Instrumentation.execStartActivity()</code>执行启动下一个Activity的逻辑。</p><p>按照Hook过程分析，需要先找到<code>Hook点</code>。由于要Hook的就是Activity的启动，所以我们可以设置<code>Instrumentation</code>为Hook点，然后使用静态代理模式生成代理对象，最后替换掉原始的<code>Instrumentation</code>继续执行启动逻辑。</p><blockquote><p>先创建<code>Instrumentation</code>代理对象<code>InstrumentationProxy</code></p></blockquote><pre><code class="hljs java">public class InstrumentationProxy extends Instrumentation &#123;    private static final String TAG = "InstrumentationProxy";    Instrumentation mInstrumentation;    public InstrumentationProxy(Instrumentation _instrumentation) &#123;        mInstrumentation = _instrumentation;    &#125;      //为了兼容9.0添加该方法    public Activity newActivity(ClassLoader cl, String className,                                Intent intent)            throws InstantiationException, IllegalAccessException,            ClassNotFoundException &#123;        return mInstrumentation.newActivity(cl, className, intent);    &#125;    public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,                                            Intent intent, int requestCode, Bundle options) &#123;        Log.e(TAG, "hook success" + who);        // 开始调用原始的方法, 调不调用随你,但是不调用的话, 所有的startActivity都失效了.        // 由于这个方法是隐藏的,因此需要使用反射调用;首先找到这个方法        try &#123;            @SuppressLint("PrivateApi") Method execStartActivity = Instrumentation.class.getDeclaredMethod(                    "execStartActivity",                    Context.class, IBinder.class, IBinder.class, Activity.class,                    Intent.class, int.class, Bundle.class);            execStartActivity.setAccessible(true);            return (ActivityResult) execStartActivity.invoke(mInstrumentation, who,                    contextThread, token, target, intent, requestCode, options);        &#125; catch (Exception e) &#123;            throw new RuntimeException("do not support!!! pls adapt it");        &#125;    &#125;&#125;</code></pre><blockquote><p>在需要使用的Activity中实现Hook方法</p></blockquote><pre><code class="hljs java">public class LoadActivity extends AppCompatActivity &#123;    @Override    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.act_load);        //Hook当前Activity使用的Instrumentation        replaceActivityInstrumentation(LoadActivity.this);        Button btn_jump = findViewById(R.id.btn_jump);        btn_jump.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                startActivity(new Intent(LoadActivity.this, MainActivity.class));            &#125;        &#125;);    &#125;    public void replaceActivityInstrumentation(Activity activity) &#123;        try &#123;            Field field = Activity.class.getDeclaredField("mInstrumentation");            field.setAccessible(true);            Instrumentation instrumentation = (Instrumentation) field.get(activity);            Instrumentation instrumentationProxy = new InstrumentationProxy(instrumentation);            field.set(activity, instrumentationProxy);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><blockquote><p>理论上来说<code>Hook操作</code>越早越好，<code>handleLaunchActivity()</code>内部开始执行启动流程，然后会调用到<code>Activity.attach()</code>内部继续执行。<code>attachBaseContext()</code>是最早执行的，但是其中无法去执行Hook操作</p><pre><code class="hljs java">&gt;  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context, ActivityThread aThread,&gt;             Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,&gt;             Application application, Intent intent, ActivityInfo info,&gt;             CharSequence title, Activity parent, String id,&gt;             NonConfigurationInstances lastNonConfigurationInstances,&gt;             Configuration config, String referrer, IVoiceInteractor voiceInteractor,&gt;             Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;&gt;         attachBaseContext(context);&gt;    ...&gt;       <span class="hljs-comment">//在这个方法后面又会继续执行赋值，则Hook失效</span>&gt;       mInstrumentation = instr;&gt;    ...&gt;  &#125;&gt;    &gt;</code></pre></blockquote><h4 id="2-Hook-Context-startActivity"><a href="#2-Hook-Context-startActivity" class="headerlink" title="2.Hook Context.startActivity()"></a>2.Hook <code>Context.startActivity()</code></h4><p><code>Context</code>的具体实现类为<code>ContextImpl</code>，<code>ContextImpl.startActivity()</code>如下所示</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent)</span> </span>&#123;    warnIfCallingFromSystemProcess();    startActivity(intent, <span class="hljs-keyword">null</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent, Bundle options)</span> </span>&#123;    warnIfCallingFromSystemProcess();    <span class="hljs-keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="hljs-number">0</span>            &amp;&amp; options != <span class="hljs-keyword">null</span> &amp;&amp; ActivityOptions.fromBundle(options).getLaunchTaskId() == -<span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AndroidRuntimeException(                <span class="hljs-string">"Calling startActivity() from outside of an Activity "</span>                + <span class="hljs-string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span>                + <span class="hljs-string">" Is this really what you want?"</span>);    &#125;    mMainThread.getInstrumentation().execStartActivity(            getOuterContext(), mMainThread.getApplicationThread(), <span class="hljs-keyword">null</span>,            (Activity) <span class="hljs-keyword">null</span>, intent, -<span class="hljs-number">1</span>, options);&#125;</code></pre><p><code>getInstrumentation()</code>去获取对应的<code>Instrumentation</code>不过这个是可以全局生效的，<code>ActivityThread</code>是主线程的管理类，<code>Instrumentation</code>是其成员变量，一个进程中只会存在一个<code>ActivityThread</code>，因此依然设置<code>Instrumentation</code>为Hook点。</p><p>可以在<code>Application</code>中或者<code>Activity</code>中去设置Hook方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attachBaseContext</span><span class="hljs-params">(Context base)</span> </span>&#123;        <span class="hljs-keyword">super</span>.attachBaseContext(base);        replaceContextInstrumentation();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceContextInstrumentation</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//获取ActivityThread类</span>            <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">"PrivateApi"</span>) Class&lt;?&gt; activityThreadClazz = Class.forName(<span class="hljs-string">"android.app.ActivityThread"</span>);            <span class="hljs-comment">//获取其中的静态变量 sCurrentActivityThread 它对应着当前的ActivityThread对象</span>            Field activityThreadField = activityThreadClazz.getDeclaredField(<span class="hljs-string">"sCurrentActivityThread"</span>);            activityThreadField.setAccessible(<span class="hljs-keyword">true</span>);            <span class="hljs-comment">//获取到 sCurrentActivityThread 对象</span>            Object currentActivityThread = activityThreadField.get(<span class="hljs-keyword">null</span>);            Field mInstrumentationField = activityThreadClazz.getDeclaredField(<span class="hljs-string">"mInstrumentation"</span>);            mInstrumentationField.setAccessible(<span class="hljs-keyword">true</span>);            Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(currentActivityThread);            Instrumentation instrumentationProxy = <span class="hljs-keyword">new</span> InstrumentationProxy(mInstrumentation);            <span class="hljs-comment">//执行替换操作</span>            mInstrumentationField.set(currentActivityThread, instrumentationProxy);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h4><ol><li><p>无法进行Hook操作</p><pre><code class="hljs xml">E/Instrumentation: Uninitialized ActivityThread, likely app-created Instrumentation, disabling AppComponentFactory</code></pre><p>出现上述提示，发生的情况是在Android P上运行应用时。</p><p>主要是因为在Android P的源代码中对<code>Instrumentation.newActivity()</code>进行了调整</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> ActivityThread mThread = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Activity <span class="hljs-title">newActivity</span><span class="hljs-params">(ClassLoader cl, String className,          Intent intent)</span>          <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException,                  ClassNotFoundException </span>&#123;              String pkg = intent != <span class="hljs-keyword">null</span> &amp;&amp; intent.getComponent() != <span class="hljs-keyword">null</span>                      ? intent.getComponent().getPackageName() : <span class="hljs-keyword">null</span>;              <span class="hljs-keyword">return</span> getFactory(pkg).instantiateActivity(cl, className, intent);          &#125;                 <span class="hljs-function"><span class="hljs-keyword">private</span> AppComponentFactory <span class="hljs-title">getFactory</span><span class="hljs-params">(String pkg)</span> </span>&#123;              <span class="hljs-keyword">if</span> (pkg == <span class="hljs-keyword">null</span>) &#123;                  Log.e(TAG, <span class="hljs-string">"No pkg specified, disabling AppComponentFactory"</span>);                  <span class="hljs-keyword">return</span> AppComponentFactory.DEFAULT;              &#125;                            <span class="hljs-keyword">if</span> (mThread == <span class="hljs-keyword">null</span>) &#123;                  Log.e(TAG, <span class="hljs-string">"Uninitialized ActivityThread, likely app-created Instrumentation,"</span>                          + <span class="hljs-string">" disabling AppComponentFactory"</span>, <span class="hljs-keyword">new</span> Throwable());                  <span class="hljs-keyword">return</span> AppComponentFactory.DEFAULT;              &#125;              LoadedApk apk = mThread.peekPackageInfo(pkg, <span class="hljs-keyword">true</span>);              <span class="hljs-comment">// This is in the case of starting up "android".</span>              <span class="hljs-keyword">if</span> (apk == <span class="hljs-keyword">null</span>) apk = mThread.getSystemContext().mPackageInfo;              <span class="hljs-keyword">return</span> apk.getAppFactory();          &#125;</code></pre><p>因为只是hook了<code>execStartActivity()</code>而<code>newActivity()</code>就会抛出如上异常，解决方案就是在我们自定义的<code>InstrumentationProxy</code>中去重写<code>newActivity()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Activity <span class="hljs-title">newActivity</span><span class="hljs-params">(ClassLoader cl, String className,                                Intent intent)</span>            <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException,            ClassNotFoundException </span>&#123;        <span class="hljs-keyword">return</span> mBase.newActivity(cl, className, intent);    &#125;</code></pre></li></ol><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/Instrumentation.java" target="_blank" rel="noopener">Android 9.0相关源码</a></p><p><a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/" target="_blank" rel="noopener">Android插件化原理解析</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插件化实现原理简析(基础概念)</title>
    <link href="/2019/02/05/%E6%8F%92%E4%BB%B6%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/"/>
    <url>/2019/02/05/%E6%8F%92%E4%BB%B6%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="动态加载技术"><a href="#动态加载技术" class="headerlink" title="动态加载技术"></a>动态加载技术</h2><blockquote><p>在应用程序运行时，动态的去加载一些程序中原本不存的可执行文件并运行这些文件里的代码逻辑。</p><p>可执行文件总的来说分为两种：</p><ul><li>一种是动态链接库so</li><li>一种是dex相关文件(<em>dex以及包含dex的jar/apk文件</em>)</li></ul></blockquote><p>随着应用开发技术和业务的逐步发展，动态加载技术派生出两个技术：<strong>热修复技术以及插件化技术。</strong></p><p>热修复技术主要用来<em>修复Bug</em>，插件化技术主要来解决<em>应用越来越庞大以及功能模块的解耦</em>。</p><h2 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h2><h3 id="插件化产生"><a href="#插件化产生" class="headerlink" title="插件化产生"></a>插件化产生</h3><p>在开发初期时，业务需求以及应用开发的复杂度都不是很高，在后续的开发过程中，容易出现以下情况：</p><ol><li><p>业务复杂，模块耦合</p><p>随着开发过程，应用的体积以及复杂度都会越来越大，模块的耦合也会越来越严重。</p></li><li><p>应用间的接入</p><p>一个应用不再是单独的应用，他可能还需要接入其他的应用来完善功能。</p></li><li><p>65535限制</p><p>代码量的增大，方法数也会增加，就很容易超出限制。</p></li></ol><h3 id="插件化定义"><a href="#插件化定义" class="headerlink" title="插件化定义"></a>插件化定义</h3><p>让我们不用<strong>像原来一样把所有的内容都放在一个apk中</strong>，把一些功能和逻辑单独的放到插件Apk中，由宿主Apk按需调用。方便减少Apk的体积，也可以简单实现热插拔，更加动态化。</p><p>插件化的客户端由宿主和插件两个部分组成，宿主多指安装好的Apk，插件就为经过处理的Apk、so的dex等文件。插件可以被宿主加载也可以单独运行。</p><h3 id="插件化基本原理"><a href="#插件化基本原理" class="headerlink" title="插件化基本原理"></a>插件化基本原理</h3><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p>Android中常用的有两种类加载器，<code>DexClassLoader</code>和<code>PathClassLoader</code>，它们都继承于<code>BaseDexClassLoader</code>。这两个加载器的区别是<code>DexClassLoader</code>多了一个<code>optimizedDirectory</code>参数，这个是用来缓存系统创建的Dex文件。在<code>PathClassLoader</code>中这个参数为null，所以只能去加载内部存储(<em>/data/data/XX</em>)中的Dex文件。</p><p>通过<strong>双亲委托机制</strong>可以保证类不会重复加载，通过<em>先查看该类是否已被加载，未加载时首先让父加载器先去尝试加载，无法加载再交由自身处理。</em></p><p><br></p><h4 id="单DexClassLoader与多DexClassLoader"><a href="#单DexClassLoader与多DexClassLoader" class="headerlink" title="单DexClassLoader与多DexClassLoader"></a>单DexClassLoader与多DexClassLoader</h4><p>通过给插件apk生成相应的<code>DexClassLoader</code>便可以去访问其中的类。这边又分成两种形式：</p><ul><li><p>单DexClassLoader</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/单ClassLoader结构.png" srcset="/img/loading.gif" class="full-image" alt="单ClassLoader结构" title="单ClassLoader结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>将插件Apk中的DexClassLoader的DexPathList都合并进宿主Apk中。可以在不同的插件及主工程间直接调用相关类和方法，也可以直接抽出共用模块供其他插件使用。</p></li><li><p>多DexClassLoader</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/多ClassLoader结构.png" srcset="/img/loading.gif" class="full-image" alt="多ClassLoader结构" title="多ClassLoader结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>每个插件都会去生成一个DexClassLoader，当加载该插件中的类需要通过各自的DexClassLoader去加载，这样不同插件的类就是相互隔离的。</p></li></ul><p>宿主和插件相互调用时需要注意以下几点：</p><ul><li><p>插件调用主工程：</p><p>构造插件的ClassLoader时直接传入主工程的ClassLoader作为父加载器，所以插件可以直接去引用主工程的类。</p></li><li><p>主工程调用插件：</p><ul><li><p>单ClassLoader结构</p><p>主工程可以通过类名直接去访问插件中的类。</p><blockquote><p>需要注意插件中引用了不同版本的相同库时，需要尽量避免。</p></blockquote></li><li><p>多ClassLoader结构</p><p>主工程引用插件中类需要先通过插件的ClassLoader加载该类再通过反射调用其方法。</p></li></ul></li></ul><h4 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h4><p>Android系统通过<code>Resource</code>加载资源，<code>Resource</code>又要依赖<code>AssetManager</code>去加载资源。</p><p>因此，只要将插件Apk的路径加入到<code>AssetManager</code>中，便能够实现对插件资源的访问。</p><p>资源的插件化方式主要有两种：</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>合并资源方案</td><td>插件和主工程可以直接相互访问资源</td><td>导致资源冲突</td></tr><tr><td>独立构建资源方案</td><td>资源隔离，不会造成冲突</td><td>资源共享比较麻烦</td></tr></tbody></table><h3 id="插件化实现实例"><a href="#插件化实现实例" class="headerlink" title="插件化实现实例"></a>插件化实现实例</h3><h4 id="Activity插件化"><a href="#Activity插件化" class="headerlink" title="Activity插件化"></a>Activity插件化</h4><p>Activity插件化主要有3种实现方式，分别是<code>反射实现、接口实现以及Hook技术实现</code>。</p><blockquote><p><code>反射实现</code>会对应用的性能造成影响。</p><p> <code>接口实现</code>可以阅读<code>dynamic-load-apk</code>源码，框架提供基础四大组件基类，由需要插件化的组件进行继承。</p><p><code>Hook技术实现</code>主流插件化的实现方案。</p></blockquote><p>我们从<a href="/2019/01/02/Activity启动过程/" title="Activity启动过程">Activity启动过程</a>了解到了Activity的启动过程。如果我们需要对Activity进行插件化，需要对这段过程有很好的了解。</p><p>通过<code>Hook方式</code>去实现Activity插件化，主要需要解决两个问题：</p><ul><li>插件中的Activity并没有在<code>AndroidManifest.xml</code>进行注册，如何绕过<code>AMS</code>校验</li><li>如何去构造Activity的实例，并同步生命周期</li></ul><h5 id="Hook-IActivityManager"><a href="#Hook-IActivityManager" class="headerlink" title="Hook IActivityManager"></a>Hook IActivityManager</h5><h6 id="1-注册占坑Activity"><a href="#1-注册占坑Activity" class="headerlink" title="1.注册占坑Activity"></a>1.注册占坑Activity</h6><blockquote><p>采用<strong>预先占坑</strong>的方式，即在<code>AndroidManifest.xml</code>中先注册一个占坑Activity来代表即将加入进来的插件Activity。</p></blockquote><pre><code class="hljs java">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"          xmlns:tools="http://schemas.android.com/tools" package="com.example.wxy.ipc"&gt;     &lt;application android:allowBackup="true"                 android:label="@string/app_name"                 android:name="com.example.wxy.ipc.App"                 android:icon="@mipmap/ic_launcher"                 android:roundIcon="@mipmap/ic_launcher_round"                 android:supportsRtl="true"                 android:theme="@style/AppTheme" tools:ignore="GoogleAppIndexingWarning"&gt;        &lt;activity android:name=".LoadActivity"                  android:launchMode="singleTop"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN"/&gt;                &lt;category android:name="android.intent.category.LAUNCHER"/&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;!--设置占位Activity--&gt;        &lt;activity android:name=".StubActivity"/&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><h6 id="2-使用占坑Activity绕过AMS验证"><a href="#2-使用占坑Activity绕过AMS验证" class="headerlink" title="2.使用占坑Activity绕过AMS验证"></a>2.使用占坑Activity绕过AMS验证</h6><p>分析Activity启动流程时，<code>Instrumentation.execStartActivity()</code>去启动Activity，内部实质是依靠远程调用<code>AMS.startActivity()</code>去执行启动流程。</p><p>在Android 8.0之前，依靠的是<code>ActivityManagerNative.getDefault()</code>执行远程调用</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title">execStartActivity</span><span class="hljs-params">(            Context who, IBinder contextThread, IBinder token, Activity target,            Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options)</span> </span>&#123; ...    <span class="hljs-keyword">int</span> result = ActivityManagerNative.getDefault()                .startActivity(whoThread, who.getBasePackageName(), intent,                        intent.resolveTypeIfNeeded(who.getContentResolver()),                        token, target != <span class="hljs-keyword">null</span> ? target.mEmbeddedID : <span class="hljs-keyword">null</span>,                        requestCode, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, options);&#125;<span class="hljs-comment">// ../android/app/ActivityManagerNative.java</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IActivityManager <span class="hljs-title">getDefault</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">return</span> gDefault.get();&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sigleton&lt;IActivityManager&gt; gDefault = <span class="hljs-keyword">new</span> Singleton&lt;IActivityManager&gt;()&#123;  <span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;    IBinder b = ServiceManager.getService(<span class="hljs-string">"activity"</span>);    IActivityManager am = asInterface(b);    <span class="hljs-keyword">return</span> am;  &#125;&#125;</code></pre><p>第一次调用到<code>getDefault()</code>时，就会调用到<code>IActivityManagerSingleton.get()</code>，由源码可知，该类是一个单例类。</p><p><br></p><p>在Android8.0时，依靠的是<code>ActivityManager.getService()</code>执行远程调用</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title">execStartActivity</span><span class="hljs-params">(            Context who, IBinder contextThread, IBinder token, Activity target,            Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options)</span> </span>&#123; ...    <span class="hljs-keyword">int</span> result = ActivityManager.getService()                .startActivity(whoThread, who.getBasePackageName(), intent,                        intent.resolveTypeIfNeeded(who.getContentResolver()),                        token, target != <span class="hljs-keyword">null</span> ? target.mEmbeddedID : <span class="hljs-keyword">null</span>,                        requestCode, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, options);&#125;<span class="hljs-comment">// ../android/app/ActivityManager.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityManager <span class="hljs-title">getService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> IActivityManagerSingleton.get();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =            <span class="hljs-keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);                    <span class="hljs-keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);                    <span class="hljs-keyword">return</span> am;                &#125;            &#125;;</code></pre><p>在其中先去获取名为<code>activity</code>的一个代理对象(<code>IBinder</code>)，后续实现利用了<code>AIDL</code>，根据<code>asInterface()</code>可以获得<code>IActivityManager</code>对象，他是<code>AMS</code>在本地的代理对象。然后就可以直接调用到<code>AMS</code>的<code>startActivity()</code>。</p><p>根据上述两段源码分析，最终都需要通过<code>IActivityManager</code>去远程调用到<code>AMS</code>，可以将其作为<code>Hook点</code>，由于又是接口类型，应该使用<code>动态代理方式</code>去生成代理对象。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IActivityManagerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Object mActivityManager;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"IActivityManagerProxy"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IActivityManagerProxy</span><span class="hljs-params">(Object _object)</span> </span>&#123;        mActivityManager = _object;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-string">"startActivity"</span>.equals(method.getName())) &#123;            Intent intent = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;                <span class="hljs-keyword">if</span> (args[i] <span class="hljs-keyword">instanceof</span> Intent) &#123;                    index = i;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            intent = (Intent) args[index];            Intent subIntent = <span class="hljs-keyword">new</span> Intent();            String packageName = <span class="hljs-string">"com.example.wxy.ipc"</span>;            <span class="hljs-comment">//这个地方配置的是设置好的占坑Activity</span>            subIntent.setClassName(packageName, packageName + <span class="hljs-string">".hook.StubActivity"</span>);            <span class="hljs-comment">//存储原先启动目标Activity的Intent，方便后续进行还原</span>            subIntent.putExtra(<span class="hljs-string">"target_intent"</span>, intent);            Log.d(TAG,<span class="hljs-string">"hook 成功"</span>);            <span class="hljs-comment">//把对目标Activity的请求指向到占坑Activity</span>            args[index] = subIntent;        &#125;        <span class="hljs-keyword">return</span> method.invoke(mActivityManager, args);    &#125;&#125;</code></pre><p>通过定义上述的代理对象后，跳转到其他Activity时都会被定位到<code>StubActivity</code>上，<strong>无论是否在<code>AndroidManifest.xml</code>进行过注册</strong>。</p><p>接下来要把设置好的代理对象Hook到原有的结构上。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HookHelper</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hookAMS</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Object defaultSingleton = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">26</span>) &#123;            Class&lt;?&gt; activityManagerClazz = Class.forName(<span class="hljs-string">"android.app.ActivityManager"</span>);            <span class="hljs-comment">//获取ActivityManager中的IActivityManagerSingleton字段</span>            defaultSingleton = FieldUtil.getField(activityManagerClazz, <span class="hljs-keyword">null</span>, <span class="hljs-string">"IActivityManagerSingleton"</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">"PrivateApi"</span>) Class&lt;?&gt; activityManagerNativeClazz = Class.forName(<span class="hljs-string">"android.app.ActivityManagerNative"</span>);            <span class="hljs-comment">//获取ActivityManager中的gDefault字段</span>            defaultSingleton = FieldUtil.getField(activityManagerNativeClazz, <span class="hljs-keyword">null</span>, <span class="hljs-string">"gDefault"</span>);        &#125;        Class&lt;?&gt; singletonClazz = Class.forName(<span class="hljs-string">"android.util.Singleton"</span>);        Field mInstanceField = FieldUtil.getField(singletonClazz, <span class="hljs-string">"mInstance"</span>);        <span class="hljs-comment">//获取mInstance字段 即单例类</span>        Object iActivityManager = mInstanceField.get(defaultSingleton);        Class&lt;?&gt; iActivityManagerClazz = Class.forName(<span class="hljs-string">"android.app.IActivityManager"</span>);        <span class="hljs-comment">//使用新建的IActivityManagerProxy替换掉原有的IActivityManager</span>        Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;iActivityManagerClazz&#125;,                <span class="hljs-keyword">new</span> IActivityManagerProxy((iActivityManager)));        mInstanceField.set(defaultSingleton, proxy);    &#125;&#125;</code></pre><p>在<code>Application</code>引用<code>HookHelper</code>类即可完成绕过验证操作</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span></span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attachBaseContext</span><span class="hljs-params">(Context base)</span></span>&#123;    <span class="hljs-keyword">super</span>.attachBaseContext(base);    <span class="hljs-keyword">try</span>&#123;      HookHelper.hookAMS();    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;      e.printStackTrace();    &#125;  &#125;&#125;</code></pre><p>在执行<code>startActivity()</code>跳转时，都会跳转到<code>StubActivity</code>界面。至此完成了<em>通过AMS验证步骤</em>。</p><h6 id="3-还原插件Activity"><a href="#3-还原插件Activity" class="headerlink" title="3.还原插件Activity"></a>3.还原插件Activity</h6><blockquote><p>使用占坑Activity通过<code>AMS</code>校验后，因为当前的情况就是把跳转的都指向到了<code>StubActivity</code>中，需要做的是还原原本要跳转的Activity，使用原本Activity对<code>StubActivity</code>进行替换。</p><p><strong>要实现替换功能，关键点在于找到真正开始绘制Activity的地方，然后实际绘制需要跳转的Activity。</strong></p></blockquote><p>在<a href="/2019/01/02/Activity启动过程/" title="Activity启动过程">Activity启动过程</a>这节中，了解到绘制Activity的流程是从<code>ActivityThread.handleLaunchActivity()</code>开始执行，并调用到<code>onCreate()</code>。那就可以在执行这个方法之前，替换掉即将启动的Activity，在上一节中启动的就是<code>StubActivity</code>，需要把这个再替换成原本的目标Activity。</p><p>控制Activity的一套流程都是通过<code>H</code>这个Handler类去执行的，在其中定义了很多code，来分发不同的流程。可以通过Hook这套流程拦截原本的启动Activity流程，替换成自定义的启动流程。</p><blockquote><p>使用Handler时如果想拦截原有的<code>handleMessage()</code>，就需要为Handler设置一个<code>Callback</code>，这样在分发消息(<code>dispatchMessage()</code>)的时候，就会去执行到<code>Callback.handlerMessage(msg)</code>而不执行原有处理。在此基础上，可以对<code>ActivityThread.H</code>设置一个<code>Callback</code>拦截启动Activity的事件。</p></blockquote><p>在此先自定义一个Callback</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Handler</span>.<span class="hljs-title">Callback</span> </span>&#123;    Handler mHandler;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HCallback</span><span class="hljs-params">(Handler _handler)</span> </span>&#123;        mHandler = _handler;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;        Object r = msg.obj;        <span class="hljs-keyword">switch</span> (msg.what) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>: <span class="hljs-comment">//LAUNCH_ACTIVITY</span>                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//得到消息中的Intent -- 启动StubActivity的Intent</span>                    Intent intent = (Intent) FieldUtil.getField(r.getClass(), r, <span class="hljs-string">"intent"</span>);                    <span class="hljs-comment">//从中取出原本要启动Activity的Intent</span>                    Intent target = intent.getParcelableExtra(<span class="hljs-string">"target_intent"</span>);                    <span class="hljs-comment">//将启动目标Activity的Intent替换掉启动StubActivity的Intent</span>                    intent.setComponent(target.getComponent());                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">159</span>: <span class="hljs-comment">//Android P 对应的启动条件</span>                <span class="hljs-comment">//在Android P中取消了Activity的相关Code，把他们封装成ClientTransacion类型对象，然后存储在其中的 mActivityCallbacks</span>                <span class="hljs-comment">//LaunchActivityItem  启动Activity</span>                <span class="hljs-comment">//DestoryActivityListItem 关闭Activity</span>                <span class="hljs-keyword">try</span> &#123;                    List&lt;Object&gt; mCallbacks = (List&lt;Object&gt;) FieldUtil.getField(r.getClass(), r, <span class="hljs-string">"mActivityCallbacks"</span>);                    <span class="hljs-keyword">if</span> (!mCallbacks.isEmpty()) &#123;                        <span class="hljs-comment">//找到启动Activity的消息</span>                        String className = <span class="hljs-string">"android.app.servertransaction.LaunchActivityItem"</span>;                        <span class="hljs-keyword">if</span> (mCallbacks.get(<span class="hljs-number">0</span>).getClass().getCanonicalName().equals(className)) &#123;                            Object object = mCallbacks.get(<span class="hljs-number">0</span>);                            Intent intent = (Intent) FieldUtil.getField(object.getClass(), object, <span class="hljs-string">"mIntent"</span>);                            Intent target = intent.getParcelableExtra(<span class="hljs-string">"target_intent"</span>);                            <span class="hljs-comment">//替换进去</span>                            intent.setComponent(target.getComponent());                        &#125;                    &#125;                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;                <span class="hljs-keyword">break</span>;        &#125;        mHandler.handleMessage(msg);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><p>实现了自定义Callback对象<code>HCallback</code>后，就需要把它设置到<code>ActivityThread.H</code>中使其拦截后续启动动作。</p><pre><code class="hljs java">public class HookHelper &#123;    public static void hookHandler() throws Exception &#123;        Class&lt;?&gt; activityThreadClass = Class.forName("android.app.ActivityThread");        //当前对应的ActivityThread对象        Object currentActivityThread = FieldUtil.getField(activityThreadClass, null, "sCurrentActivityThread");        //对应Handler对象        Field mHField = FieldUtil.getField(activityThreadClass, "mH");        Handler mH = (Handler) mHField.get(currentActivityThread);        //替换掉mh中的mCallback对象        FieldUtil.setField(Handler.class, mH, "mCallback", new HCallback(mH));    &#125;&#125;</code></pre><p>上述执行完毕后，启动的就会是目标Activity。</p><h6 id="4-插件Activity的生命周期"><a href="#4-插件Activity的生命周期" class="headerlink" title="4.插件Activity的生命周期"></a>4.插件Activity的生命周期</h6><p>上述三步执行完毕后，就可以打开插件Activity，但是这种操作下会不会影响到原有的生命周期，实际上还是依赖了<code>StubActivity</code>。</p><p>Activity生命周期的回调代码都是交由<code>Instrumentation.callActivityOnXX(ActivityClientRecord.activity)</code>执行对应的回调代码。其中<code>ActivityClientRecoed</code>用于描述应用进程中的Activity。我们只要分析<code>ActivityClientRecord.activity</code>对应的是否为目标Activity，是的话那么生命周期就没有问题。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;  ...     Activity activity = <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span> &#123;           java.lang.ClassLoader cl = appContext.getClassLoader();           <span class="hljs-comment">//加载Activity，其实这时加载的已经是目标Activity了</span>           activity = mInstrumentation.newActivity(                   cl, component.getClassName(), r.intent);           ...       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;           ...       &#125;       ...       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//创建Application对象</span>           Application app = r.packageInfo.makeApplication(<span class="hljs-keyword">false</span>, mInstrumentation);                      <span class="hljs-keyword">if</span> (activity != <span class="hljs-keyword">null</span>) &#123;             ...               <span class="hljs-comment">//Activity的初始化操作</span>               activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,                       r.ident, app, r.intent, r.activityInfo, title, r.parent,                       r.embeddedID, r.lastNonConfigurationInstances, config,                       r.referrer, r.voiceInteractor, window, r.configCallback);             ...             <span class="hljs-comment">//调用 onCreate() 回调方法</span>             <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;                   mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);               &#125; <span class="hljs-keyword">else</span> &#123;                   mInstrumentation.callActivityOnCreate(activity, r.state);               &#125;               <span class="hljs-comment">//设置ActivityClientRecord中的Activity为目标Activity</span>               r.activity = activity;             ...             mActivities.put(r.token,r);           &#125;       &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;          ...       &#125;&#125;</code></pre><p>从以上源码分析可知，<code>performLaunchActivity()</code>时会设置当前Activity为目标Activity，生命周期也会跟着当前Activity去执行，即生命周期是同步的。</p><h5 id="Hook-Instrumentation"><a href="#Hook-Instrumentation" class="headerlink" title="Hook Instrumentation"></a>Hook Instrumentation</h5><blockquote><p>该实现相对上面会简单很多，主要就是去操作<code>Instrumentation</code>，Hook掉其中的两个方法：</p><ul><li><code>newActivity()</code>：新建Activity <strong>用目标Activity替换掉StubActivity</strong></li><li><code>execStartActivity()</code>：启动Activity  <strong>拦截跳转到StubActivity上</strong></li></ul></blockquote><h6 id="1-注册占坑Activity-1"><a href="#1-注册占坑Activity-1" class="headerlink" title="1.注册占坑Activity"></a>1.注册占坑Activity</h6><p>方法同上</p><h6 id="2-设置Instrumentation代理对象"><a href="#2-设置Instrumentation代理对象" class="headerlink" title="2.设置Instrumentation代理对象"></a>2.设置Instrumentation代理对象</h6><pre><code class="hljs java">public class InstrumentationProxy extends Instrumentation &#123;    private static final String TAG = "InstrumentationProxy";    private Instrumentation mInstrumentation;    private PackageManager mPackageManager;    public InstrumentationProxy(Instrumentation _instrumentation, PackageManager _packageManager) &#123;        mInstrumentation = _instrumentation;        mPackageManager = _packageManager;    &#125;     public Activity newActivity(ClassLoader cl, String className,                                Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123;        String intentName = intent.getStringExtra("target_intent");        if (!TextUtils.isEmpty(intentName)) &#123;            return super.newActivity(cl, intentName, intent);        &#125;        return super.newActivity(cl, className, intent);    &#125;    public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,                                            Intent intent, int requestCode, Bundle options) &#123;        List&lt;ResolveInfo&gt; infos = mPackageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL);        //判断需要启动的Activity是否已被注册        if (infos.isEmpty()) &#123;            intent.putExtra("target_intent", intent.getComponent().getClassName());            //未注册则指向StubActivity            intent.setClassName(who, "com.example.wxy.ipc.hook.StubActivity");        &#125;        try &#123;            //反射调用 execStartActivity            @SuppressLint("PrivateApi") Method execStartActivity = Instrumentation.class.getDeclaredMethod(                    "execStartActivity",                    Context.class, IBinder.class, IBinder.class, Activity.class,                    Intent.class, int.class, Bundle.class);            execStartActivity.setAccessible(true);            return (ActivityResult) execStartActivity.invoke(mInstrumentation, who,                    contextThread, token, target, intent, requestCode, options);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;</code></pre><p>设置好代理对象后，需要把代理对象Hook到<code>ActivityThread</code>上，方便后续调用</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HookHelper</span> </span>&#123;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hookInstrumentation</span><span class="hljs-params">(Context context)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Class&lt;?&gt; activityThreadClass = Class.forName(<span class="hljs-string">"android.app.ActivityThread"</span>);        <span class="hljs-comment">//获取ActivityThread中的 sCurrentActivityThread 代指当前进程的ActivityThread</span>        Object activityThread = FieldUtil.getField(activityThreadClass,<span class="hljs-keyword">null</span>,<span class="hljs-string">"sCurrentActivityThread"</span>);        Field mInsrumentationField = FieldUtil.getField(activityThreadClass, <span class="hljs-string">"mInstrumentation"</span>);        <span class="hljs-comment">//获取到 mInstrumentation</span>        Object mInstrumentation = mInsrumentationField.get(activityThread);        <span class="hljs-comment">//使用InstrumentationProxy替换掉原先的mInstrumentation</span>        FieldUtil.setField(activityThreadClass, activityThread, <span class="hljs-string">"mInstrumentation"</span>,                <span class="hljs-keyword">new</span> InstrumentationProxy((Instrumentation) mInstrumentation, context.getPackageManager()));    &#125; &#125;</code></pre><p>在<code>Application</code>中的<code>attachBaseContext()</code>调用<code>HookHelper.hookInstrumentation()</code>即可完成插件Activity的加载。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WindowManagerService简析</title>
    <link href="/2019/01/30/WindowManagerService%E7%AE%80%E6%9E%90/"/>
    <url>/2019/01/30/WindowManagerService%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="WindowManagerService的职责"><a href="#WindowManagerService的职责" class="headerlink" title="WindowManagerService的职责"></a>WindowManagerService的职责</h2><blockquote><p> Window的相关操作都是借由<code>WindowManagerService</code>实现的，而且它是<code>WindowManager</code>的管理者。</p></blockquote><h3 id="1-窗口管理"><a href="#1-窗口管理" class="headerlink" title="1.窗口管理"></a>1.窗口管理</h3><p>负责窗口的启动、添加和删除。另外窗口的大小和层级也是交由WMS进行管理的。</p><p>核心成员：<code>DisplayContent、WindowToken，WindowState</code>。</p><h3 id="2-窗口动画"><a href="#2-窗口动画" class="headerlink" title="2.窗口动画"></a>2.窗口动画</h3><p>窗口间进行切换时，窗口动画由WMS的动画子系统来负责，动画子系统的管理者为<code>WindowAnimator</code>。</p><h3 id="3-输入系统的中转站"><a href="#3-输入系统的中转站" class="headerlink" title="3.输入系统的中转站"></a>3.输入系统的中转站</h3><h3 id="4-Surface管理"><a href="#4-Surface管理" class="headerlink" title="4.Surface管理"></a>4.Surface管理</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SparseArray简析</title>
    <link href="/2019/01/28/SparseArray%E5%88%86%E6%9E%90/"/>
    <url>/2019/01/28/SparseArray%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>HashMap在Android开发中是一种常用的数据结构类型，但是占用内存方面相对会比较大，而且复杂的机制导致运行效率也不高。所以Android系统提供了<code>SparseArray</code>以及<code>ArrayMap</code>来对其进行替代。这也是Android性能优化的一种手段。</p></blockquote><h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><blockquote><p><code>SparseArray</code>可以对key为<code>Integer</code>类型的HashMap进行替代。还有</p><ul><li><code>LongSparseArray</code>对key为<code>Long</code>型的HashMap</li><li><code>SparseIntArray</code>对key为<code>Integer</code>类型，value为<code>Integer</code>类型</li><li><code>SparseLongArray</code>对key为<code>Integer</code>类型，value为<code>Long</code>类型</li><li><code>SparseBooleanArray</code>对key为<code>Integer</code>类型，value为<code>Boolean</code>类型</li></ul><p>等这些类型。内部实现都是相似的，只是可支持的类型不同。</p><p><code>SparseArray</code>允许value为null，并且是<em>线程不安全的</em>。</p></blockquote><h3 id="SparseArray使用场景"><a href="#SparseArray使用场景" class="headerlink" title="SparseArray使用场景"></a>SparseArray使用场景</h3><ul><li>数据量不大</li><li>空间比时间重要</li><li>需要使用到Map型结构，且key为<code>int</code>类型</li></ul><h3 id="SparseArray重要参数分析"><a href="#SparseArray重要参数分析" class="headerlink" title="SparseArray重要参数分析"></a>SparseArray重要参数分析</h3><pre><code class="hljs java"><span class="hljs-comment">//需要删除的标记    </span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object DELETED = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//设置回收标记 实质执行了 删除后的index置为null，协助回收</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> mGarbage = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//保存每个Item的key</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] mKeys;<span class="hljs-comment">//保存每个Item的value，容量和mKeys一致</span>   <span class="hljs-keyword">private</span> Object[] mValues;   <span class="hljs-comment">//保存的数据容量</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mSize;</code></pre><h3 id="SparseArray源码解析"><a href="#SparseArray源码解析" class="headerlink" title="SparseArray源码解析"></a>SparseArray源码解析</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><pre><code class="hljs java"><span class="hljs-comment">//无初始值</span>SparseArray&lt;String&gt; stringSparseArray = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;();<span class="hljs-comment">//设置初始值</span>SparseArray&lt;String&gt; stringSparseArray = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;(<span class="hljs-number">5</span>);</code></pre><p>对应源码</p><pre><code class="hljs java">   <span class="hljs-comment">//默认构造器 初始化容量为10</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SparseArray</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);   &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SparseArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;       <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;           mKeys = EmptyArray.INT;           mValues = EmptyArray.OBJECT;       &#125; <span class="hljs-keyword">else</span> &#123;           <span class="hljs-comment">//初始化长度的数组</span>           mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);           mKeys = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mValues.length];       &#125;       mSize = <span class="hljs-number">0</span>;   &#125;</code></pre><p>存放的键值对分别放在两个数组<code>mKeys</code>、<code>mValues</code>，数据是一一对应的。</p><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><pre><code class="hljs java">stringSparseArray.put(<span class="hljs-number">1</span>,<span class="hljs-string">"android"</span>);</code></pre><p>对应源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, E value)</span> </span>&#123;        <span class="hljs-comment">//利用二分查找，找到key应该插入的位置</span>        <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//找到已存在的值  直接进行覆盖</span>            mValues[i] = value;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//返回负数  需要取反获取插入的位置</span>            i = ~i;            <span class="hljs-comment">//当前没有越界 且原先该位置的数据已被删除 可以进行复用</span>            <span class="hljs-keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;                mKeys[i] = key;                mValues[i] = value;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;                <span class="hljs-comment">//压缩空间</span>                gc();①                <span class="hljs-comment">// Search again because indices may have changed.</span>                <span class="hljs-comment">//</span>                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);            &#125;            <span class="hljs-comment">//插入数据，可能需要扩容</span>            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);②            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);            <span class="hljs-comment">//存储数据+1</span>            mSize++;        &#125;    &#125;</code></pre><p>①<code>gc()</code>：垃圾回收，对数组进行压缩</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gc</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> n = mSize;        <span class="hljs-keyword">int</span> o = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] keys = mKeys;        Object[] values = mValues;        <span class="hljs-comment">//遍历values</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            Object val = values[i];            <span class="hljs-comment">//对应值不为删除标记</span>            <span class="hljs-keyword">if</span> (val != DELETED) &#123;                <span class="hljs-keyword">if</span> (i != o) &#123;                    keys[o] = keys[i];                    values[o] = val;                    <span class="hljs-comment">//防止内存泄露，使用过后置空</span>                    values[i] = <span class="hljs-keyword">null</span>;                &#125;                <span class="hljs-comment">//重新统计数据量</span>                o++;            &#125;        &#125;        <span class="hljs-comment">//标识 GC结束</span>        mGarbage = <span class="hljs-keyword">false</span>;        mSize = o;    &#125;</code></pre><p><code>gc()</code>实质是内部一个for循环，将value不为<code>DELETED</code>的数据重新插入数组中，已实现<strong>对数组的压缩</strong>，同时重置GC标志。</p><p>②<code>GrowingArrayUtils.insert(mKeys, mSize, i, key)</code>：插入数据 可能需要扩容</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] insert(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> currentSize, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> element) &#123;    <span class="hljs-keyword">assert</span> currentSize &lt;= array.length;    <span class="hljs-comment">//不需要扩容</span>    <span class="hljs-keyword">if</span> (currentSize + <span class="hljs-number">1</span> &lt;= array.length) &#123;        <span class="hljs-comment">//将插入位置后的数据向后移一位</span>        System.arraycopy(array, index, array, index + <span class="hljs-number">1</span>, currentSize - index);        array[index] = element;        <span class="hljs-keyword">return</span> array;    &#125;    <span class="hljs-comment">//需要进行扩容操作</span>    <span class="hljs-keyword">int</span>[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize));    System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, index);    newArray[index] = element;    System.arraycopy(array, index, newArray, index + <span class="hljs-number">1</span>, array.length - index);    <span class="hljs-keyword">return</span> newArray;&#125;<span class="hljs-comment">//重新设置数组容量</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">growSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> currentSize)</span> </span>&#123;    <span class="hljs-keyword">return</span> currentSize &lt;= <span class="hljs-number">4</span> ? <span class="hljs-number">8</span> : currentSize * <span class="hljs-number">2</span>;&#125;</code></pre><p><code>insert()</code>内部执行了两段操作：</p><ul><li>不需要扩容：将需要插入位置的数据向后移一位，然后数据插入到对应位置。</li><li>需要扩容：扩容数据为原容量的2倍(<em>容量&lt;=4时，扩容至8，其他情况下为2倍。</em>)，然后将原数组对应位置前的数据以及之后的数据分别插入扩容后数组。</li></ul><blockquote><p><code>put()</code>需要通过<strong>二分查找法</strong>找到可以插入的位置，如果当前位置的key相同，则直接覆盖原数据。如果key不相同但是<code>value</code>为<code>DELETED</code>，可以拿新的数据直接覆盖；如果不是，需要先判断<code>mGarabge</code>为true，就需要执行<code>gc()</code>压缩数组空间(<em>有效的数据按照顺序重新排布</em>)，然后再去插入新数据，过程中可能需要扩容。</p></blockquote><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><pre><code class="hljs java"><span class="hljs-comment">//获取key对应的数据</span>stringSparseArray.get(<span class="hljs-number">1</span>)stringSparseArray.get(<span class="hljs-number">1</span>,<span class="hljs-string">"iOS"</span>)<span class="hljs-comment">//获取key对应的下标</span>stringSparseArray.indexOfKey(<span class="hljs-number">1</span>)  <span class="hljs-comment">//根据下标获取key</span>stringSparseArray.keyAt(<span class="hljs-number">0</span>)</code></pre><p>对应源码</p><h5 id="根据key获取value"><a href="#根据key获取value" class="headerlink" title="根据key获取value"></a>根据key获取value</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;       <span class="hljs-keyword">return</span> get(key, <span class="hljs-keyword">null</span>);   &#125;   <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, E valueIfKeyNotFound)</span> </span>&#123;       <span class="hljs-comment">//寻找key对应位置</span>       <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);       <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || mValues[i] == DELETED) &#123;           <span class="hljs-keyword">return</span> valueIfKeyNotFound;       &#125; <span class="hljs-keyword">else</span> &#123;           <span class="hljs-keyword">return</span> (E) mValues[i];       &#125;   &#125;</code></pre><h5 id="根据key获取index"><a href="#根据key获取index" class="headerlink" title="根据key获取index"></a>根据key获取index</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">keyAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-comment">//需要先判断是否GC</span>      <span class="hljs-keyword">if</span> (mGarbage) &#123;          gc();      &#125;      <span class="hljs-keyword">return</span> mKeys[index];  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">valueAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">if</span> (mGarbage) &#123;          gc();      &#125;      <span class="hljs-keyword">return</span> (E) mValues[index];  &#125;</code></pre><h5 id="根据index获取key"><a href="#根据index获取key" class="headerlink" title="根据index获取key"></a>根据index获取key</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOfKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;    <span class="hljs-comment">//查询下标时，也需要考虑是否先GC</span>       <span class="hljs-keyword">if</span> (mGarbage) &#123;           gc();       &#125;       <span class="hljs-comment">//二分查找返回 对应的下标 ,可能是负数</span>       <span class="hljs-keyword">return</span> ContainerHelpers.binarySearch(mKeys, mSize, key);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOfValue</span><span class="hljs-params">(E value)</span> </span>&#123;    <span class="hljs-comment">//查询下标时，也需要考虑是否先GC</span>       <span class="hljs-keyword">if</span> (mGarbage) &#123;           gc();       &#125;       <span class="hljs-comment">//不像key一样使用的二分查找。是直接线性遍历去比较，而且不像其他集合类使用equals比较，这里直接使用的 ==</span>       <span class="hljs-comment">//如果有多个key 对应同一个value，则这里只会返回一个更靠前的index</span>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mSize; i++)           <span class="hljs-keyword">if</span> (mValues[i] == value)               <span class="hljs-keyword">return</span> i;       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre><code class="hljs java"><span class="hljs-comment">//删除对应key的数据</span>stringSparseArray.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">//删除对应index的数据</span>stringSparseArray.removeAt(<span class="hljs-number">0</span>)；<span class="hljs-comment">//删除对应区间的数据</span>stringSparseArray.removeAtRange(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);</code></pre><p>对应源码</p><h5 id="根据key删除数据"><a href="#根据key删除数据" class="headerlink" title="根据key删除数据"></a>根据key删除数据</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        delete(key);    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;    <span class="hljs-comment">//二分查找到对应的index</span>        <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);        <span class="hljs-comment">//找到了对应位置</span>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (mValues[i] != DELETED) &#123;                <span class="hljs-comment">//打上已删除标记</span>                mValues[i] = DELETED;                <span class="hljs-comment">//标记需要执行 gc()</span>                mGarbage = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;</code></pre><h5 id="根据index删除数据"><a href="#根据index删除数据" class="headerlink" title="根据index删除数据"></a>根据index删除数据</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mValues[index] != DELETED) &#123;            mValues[index] = DELETED;            mGarbage = <span class="hljs-keyword">true</span>;        &#125;    &#125;</code></pre><h5 id="根据区间删除数据"><a href="#根据区间删除数据" class="headerlink" title="根据区间删除数据"></a>根据区间删除数据</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAtRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> size)</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end = Math.min(mSize, index + size);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; end; i++) &#123;        removeAt(i);    &#125;&#125;</code></pre><p><code>remove()</code>相关方法并不是直接删除数据，而是使用<code>DELETED</code>占据被删除数据的位置，同时设置<code>mGarabge=true</code>，等待调用<code>gc()</code>进行数据压缩。</p><blockquote><p>设置<code>DELETED</code>的目的：如果<code>put()</code>时也要用到该位置，就可以不用进行数据复制，而直接放入数据即可。</p></blockquote><h3 id="SparseArray拓展"><a href="#SparseArray拓展" class="headerlink" title="SparseArray拓展"></a>SparseArray拓展</h3><ul><li><code>SparseArray</code>的key是按照顺序从小到大排列的</li><li>由于压缩数组的原因，所以占用空间会比<code>HashMap</code>小，当数据量上来时，二分查找将会成为其性能瓶颈，所以适合数据量小的情况</li><li>key为<code>int</code>类型，省去<code>Integer</code>拆箱的性能消耗。</li><li>由于<code>SparseArray</code>没有实现<code>Serializable</code>接口，所以不支持序列化即无法进行传递。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bitmap分析</title>
    <link href="/2019/01/28/Bitmap%E5%88%86%E6%9E%90/"/>
    <url>/2019/01/28/Bitmap%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<!--Bitmap 压缩策略 Bitmap大小判断 bitmap的具体压缩过程 bitmap在缓存时的转码过程--><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Bitmap优化.png" srcset="/img/loading.gif" class="full-image" alt="Bitmap优化" title="Bitmap优化"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="Bitmap简介"><a href="#Bitmap简介" class="headerlink" title="Bitmap简介"></a>Bitmap简介</h2><p>位图文件(Bitmap)，扩展名可以是<code>.bmp或.dlb</code>。它将图像定义为由像素组成，每个点可以由多种色彩表示，包括2、4、8、16、24和32位色彩。</p><p>在安卓系统中bitmap图片一般是以<code>ARGB_8888</code>来进行存储的。</p><table><thead><tr><th>颜色格式</th><th>每个像素占用内存(byte)</th><th>每个像素占用内存(bit)</th></tr></thead><tbody><tr><td>ARGB_8888(<code>默认</code>)</td><td>4</td><td>32</td></tr><tr><td>ALPHA_8</td><td>1</td><td>8</td></tr><tr><td>ARGB_4444</td><td>2</td><td>16</td></tr><tr><td>RGB_565</td><td>2</td><td>16</td></tr></tbody></table><p><code>ARGB_8888</code>：分别代表<em>透明度，红色，绿色，蓝色</em>，每个值分别用8bit记录</p><p><code>ALPHA_8</code>：该像素只保存透明度</p><p><code>ARGB_4444</code>：每个值分别用4bit记录</p><p><code>RGB_565</code>：不存在透明度</p><p><strong>实际应用中建议使用ARGB_8888和RGB_565(<em>不需要存储透明度时使用</em>)。</strong></p><h2 id="Bitmap占用内存"><a href="#Bitmap占用内存" class="headerlink" title="Bitmap占用内存"></a>Bitmap占用内存</h2><p>bitmap占用内存：<strong>所有像素的内存占用总和</strong>。</p><p>Android系统提供了两个方法获取占用内存：<code>getByteCount()</code>和<code>getAllocationByteCount()</code>。</p><p><code>getByteCount()</code>：在API12中加入的，代表存储Bitmap需要的最少内存。</p><p><code>getAllocationByteCount()</code>：在API19中加入的，代表在内存中为Bitmap分配的内存大小</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAllocationByteCount</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">if</span>(mBuffer == <span class="hljs-keyword">null</span>)&#123;    <span class="hljs-keyword">return</span> getByteCount();  &#125;  <span class="hljs-keyword">return</span> mBuffer.length;&#125;</code></pre><p>两者的区别：</p><ul><li>一般情况下两者是相等的</li><li>如果通过Bitmap的复用去解码图片，那么被复用的Bitmap的内存比待分配内存的Bitmap大，即<code>getByteCount()</code>&lt;<code>getAllocationByteCount()</code>。<code>getByteCount()</code>表示新解码图片占用内存的大小(<em>并非实际占用内存大小</em>)，<code>getAllocationByteCount()</code>表示被复用的Bitmap占用的内存大小。</li></ul><p><br></p><p>一般情况下Bitmap占用的内存大小都为：<strong>图片长度 x 图片宽度 x 单位像素占用的字节数</strong>。</p><p><code>单位像素占用字节数</code>：指代的是上面描述的编码方式，常用的是<code>ARGB_8888</code>即用这个方式编码的Bitmap占用大小就为<em>图片长度 x 图片宽度 x 4</em>。</p><p><br></p><p>非一般情况下，例如从资源文件夹(<em>res/drawable/</em>)获取图片时，还需要额外考虑一个因素：<strong>Density</strong>。</p><p><code>Density</code>：可以理解为相对屏幕密度，一个DIP在160dpi的屏幕上大约为1px，以160dpi为基准线，density的值即为相对于160dpi的相对屏幕密度。</p><pre><code class="hljs java"><span class="hljs-comment">//从资源文件中读取 Bitmap </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">decodeResourceStream</span><span class="hljs-params">(@Nullable Resources res, @Nullable TypedValue value,            @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)</span> </span>&#123;        validate(opts);        <span class="hljs-keyword">if</span> (opts == <span class="hljs-keyword">null</span>) &#123;            opts = <span class="hljs-keyword">new</span> Options();        &#125;        <span class="hljs-keyword">if</span> (opts.inDensity == <span class="hljs-number">0</span> &amp;&amp; value != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> density = value.density;            <span class="hljs-keyword">if</span> (density == TypedValue.DENSITY_DEFAULT) &#123;                opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (density != TypedValue.DENSITY_NONE) &#123;                opts.inDensity = density;            &#125;        &#125;                <span class="hljs-keyword">if</span> (opts.inTargetDensity == <span class="hljs-number">0</span> &amp;&amp; res != <span class="hljs-keyword">null</span>) &#123;            opts.inTargetDensity = res.getDisplayMetrics().densityDpi;        &#125;                <span class="hljs-keyword">return</span> decodeStream(is, pad, opts);    &#125;</code></pre><p>从源码中可以看出：<strong>加载一张本地资源图片，那么它占用的内存 = 图片长度 x 图片宽度 x inTargetDensity/inDensity x inTargetDensity/inDensity x 单位像素占用字节数。</strong></p><p>其中 <code>inDensity</code>代表图片所在文件夹对应的密度；<code>inTargetDensity</code>代表了当前的系统密度。</p><p><em>可以通过设置 <code>Options</code>对inTargetDensity 、inDensity进行修改，避免自动计算。 </em></p><h2 id="Bitmap复用"><a href="#Bitmap复用" class="headerlink" title="Bitmap复用"></a>Bitmap复用</h2><h3 id="利用LruCache和DiskLruCache做内存和磁盘缓存"><a href="#利用LruCache和DiskLruCache做内存和磁盘缓存" class="headerlink" title="利用LruCache和DiskLruCache做内存和磁盘缓存"></a>利用<code>LruCache</code>和<code>DiskLruCache</code>做内存和磁盘缓存</h3><a href="/2018/12/14/LRUCache原理/" title="LruCache原理">LruCache原理</a><h3 id="使用Bitmap复用-多个Bitmap复用同一块内存"><a href="#使用Bitmap复用-多个Bitmap复用同一块内存" class="headerlink" title="使用Bitmap复用 -多个Bitmap复用同一块内存"></a>使用Bitmap复用 -多个Bitmap复用同一块内存</h3><pre><code class="hljs java">BitmapFactory.Options options = <span class="hljs-keyword">new</span> BitmapFactory.Options();<span class="hljs-comment">// 图片复用，这个属性必须设置；</span>options.inMutable = <span class="hljs-keyword">true</span>;<span class="hljs-comment">// 手动设置缩放比例，使其取整数，方便计算、观察数据；</span>options.inDensity = <span class="hljs-number">320</span>;options.inTargetDensity = <span class="hljs-number">320</span>;<span class="hljs-comment">//生成复用的Bitmap</span>Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.resbitmap, options);<span class="hljs-comment">// 使用inBitmap属性，这个属性必须设置；设置要复用的Bitmap</span>options.inBitmap = bitmap;options.inDensity = <span class="hljs-number">320</span>;<span class="hljs-comment">// 设置缩放宽高为原始宽高一半；</span>options.inTargetDensity = <span class="hljs-number">160</span>;options.inMutable = <span class="hljs-keyword">true</span>;Bitmap bitmapReuse = BitmapFactory.decodeResource(getResources(), R.drawable.resbitmap_reuse, options);</code></pre><p>使用<code>inBitmap</code>参数实现Bitmap的复用，但复用存在一些限制：<em>在Android4.4之前只能重用相同大小的Bitmap的内存，4.4之后的只要后来的Bitmap比之前的小即可。</em></p><h2 id="Bitmap高效加载"><a href="#Bitmap高效加载" class="headerlink" title="Bitmap高效加载"></a>Bitmap高效加载</h2><blockquote><p>核心思想：采用<code>BitmapFactory.Options</code>来加载所需尺寸的图片，使其按照一定的采样率将图片缩小后再进行加载。</p><p><strong>防止直接加载大容量的高清Bitmap导致OOM的出现。</strong></p></blockquote><h3 id="BitmapFactory"><a href="#BitmapFactory" class="headerlink" title="BitmapFactory"></a>BitmapFactory</h3><blockquote><p>提供方法生成Bitmap对象。</p></blockquote><ul><li><code>decodeFile()</code>：从文件中加载出一个Bitmap对象</li><li><code>decodeResource()</code>：从资源文件夹中加载出一个Bitmap对象</li><li><code>decodeStream()</code>：从输入流中加载出一个Bitmap对象</li><li><code>decodeByteArray()</code>：从字节数组中加载出一个Bitmap对象</li></ul><blockquote><p><code>decodeFile()</code>和<code>decodeResource()</code>间接调用到了<code>decodeStream()</code>，最终都是在Native层实现的。</p></blockquote><h3 id="BitmapFactory-Options"><a href="#BitmapFactory-Options" class="headerlink" title="BitmapFactory.Options"></a>BitmapFactory.Options</h3><blockquote><p>里面配置的参数可以实现高效的加载Bitmap。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Options</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Options</span><span class="hljs-params">()</span> </span>&#123;        inDither = <span class="hljs-keyword">false</span>;        inScaled = <span class="hljs-keyword">true</span>;        inPremultiplied = <span class="hljs-keyword">true</span>;    &#125;    ...         <span class="hljs-keyword">public</span> Bitmap inBitmap; <span class="hljs-comment">//用于实现Bitmap的复用，上文有介绍</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> inSampleSize;  <span class="hljs-comment">//采样率 </span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> inJustDecodeBounds; <span class="hljs-comment">//</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> inPremultiplied;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> inDither;  <span class="hljs-comment">//是否开启抖动</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> inDensity; <span class="hljs-comment">// 图片所属文件夹对应的dpi</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> inTargetDensity;  <span class="hljs-comment">// 目标设备屏幕的dpi           </span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> inScaled;    <span class="hljs-comment">//是否支持缩放</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> outWidth;   <span class="hljs-comment">//图片的原始宽度</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> outHeight;  <span class="hljs-comment">//图片的原始高度</span>   ...&#125;</code></pre><h4 id="inPreferredConfig"><a href="#inPreferredConfig" class="headerlink" title="inPreferredConfig"></a>inPreferredConfig</h4><blockquote><p>根据需求选择合适的解码方式，可以有效减小占用内存</p></blockquote><p><code>inPreferredConfig</code>指的就是上面描述到的<code>ARGB_8888、ARGB_4444、RGB_565、ALPHA_8</code>，默认用的是<code>ARGB_8888</code>。</p><h4 id="inScaled"><a href="#inScaled" class="headerlink" title="inScaled"></a>inScaled</h4><blockquote><p>表示是否支持缩放。<em>默认为true</em></p></blockquote><p>缩放系数的计算方法：<code>inDensity / inTargetDensity</code>计算得出。</p><pre><code class="hljs java">BitmapFactory.Options options = <span class="hljs-keyword">new</span> BitmapFactory.Options();options.inDensity = <span class="hljs-number">160</span>;options.inTargetDensity = <span class="hljs-number">320</span>;Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.size, options);<span class="hljs-keyword">int</span> size = bitmap.getByteCount();</code></pre><p>可以手动的设置<code>inDensity，inTargetDensity</code>控制缩放系数。</p><h4 id="inJustDecodeBounds"><a href="#inJustDecodeBounds" class="headerlink" title="inJustDecodeBounds"></a>inJustDecodeBounds</h4><blockquote><p>是否去加载图片</p></blockquote><p>当此参数设置为<code>true</code>：BitmapFactory只会加载图片的原始宽高信息，而不会真正的加载图片到内存。</p><p>设置为<code>false</code>：BitmapFactory加载图片至内存。</p><blockquote><p>BitmapFactory获取的图片宽高信息会和图片的位置以及程序运行的设备有关，会导致获取到不同结果。</p></blockquote><h4 id="inSampleSize"><a href="#inSampleSize" class="headerlink" title="inSampleSize"></a>inSampleSize</h4><blockquote><p>采样率，同时作用于宽/高。</p></blockquote><p>当<code>inSampleSize == 1</code>，采样后的图片和原来大小一样；为2时，采样后的图片宽高均变为原来的1/2，占用内存大小也就变成了1/4。</p><p><code>inSampleSize</code>的取值应该总是<strong>2的指数(2、4、8、16 …)</strong>，如果传递的<code>inSampleSize</code>不为2的指数，那么系统会向下取整并选择一个最接近于2的指数来代替。<em>传进来3，则对应为2</em>。</p><blockquote><p>注意：需要根据图片的宽高 <strong>实际大小和需要大小</strong>，去计算出需要的缩放比并尽可能取小，避免缩小的过多导致无法铺满控件被拉伸。</p></blockquote><h5 id="获取采样率"><a href="#获取采样率" class="headerlink" title="获取采样率"></a>获取采样率</h5><ol><li>设置<code>BitmapFactory.Options.inJustDecodeBounds = true</code>并加载图片</li><li>从<code>BitmapFactory.Options</code>获取图片的原始宽高信息，<code>outWidth和outHeight</code></li><li>根据原始宽高并结合目标View的大小得到合适的采样率<code>inSampleSize</code></li><li>重新设置<code>BitmapFactory.Options.inJustDecodeBounds = false</code>并重新加载图片</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">decodeSampledBitmapTromResource</span><span class="hljs-params">(Resource res,<span class="hljs-keyword">int</span> rresId,<span class="hljs-keyword">int</span> reqWidth,<span class="hljs-keyword">int</span> reqHeight)</span></span>&#123;  <span class="hljs-keyword">final</span> BitmapFactory.Options options = <span class="hljs-keyword">new</span> BitmapFactory.Options();  options.inJustDecodeBounds = <span class="hljs-keyword">true</span>;    BitmapFacory.decodeResource(res,resId,options);  options.inSampleSize = calculateInSampleSize(options,reqWidth,reqHeight);  options.inJustDecodeBounds = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">return</span> BitmapFactory.decodeResource(res,resId,options);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateInSampleSize</span><span class="hljs-params">(BitmapFactory.Options options,<span class="hljs-keyword">int</span> reqWidth,<span class="hljs-keyword">int</span> reqHeight)</span></span>&#123;  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = options.outHeight;  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = options.outWidth;  <span class="hljs-keyword">int</span> inSampleSize = <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(height &gt; reqHeight || width &gt; reqWidth)&#123;     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> halfWidth = width /<span class="hljs-number">2</span>;     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> halfHeight = height/<span class="hljs-number">2</span>;     <span class="hljs-keyword">while</span>((halfHeight / inSampleSize) &gt;= reqHeight            &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth)&#123;       inSampleSize = inSampleSize &lt;&lt; <span class="hljs-number">1</span>;     &#125;  &#125;  <span class="hljs-keyword">return</span> inSampleSize;&#125;<span class="hljs-comment">//使用示例</span>iv.setImageBitmap(decodeSampledBitmapTromResource(getResources(),R.drawable.bitmap,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>))</code></pre><h2 id="Bitmap压缩"><a href="#Bitmap压缩" class="headerlink" title="Bitmap压缩"></a>Bitmap压缩</h2><h3 id="质量压缩"><a href="#质量压缩" class="headerlink" title="质量压缩"></a>质量压缩</h3><blockquote><p>保持像素的前提下改变图片的位深以及透明度等，来达到压缩图片的目的，<strong>不会减少图片的像素，经过质量压缩的图片文件大小会变小，但是解码成Bitmap占用内存不变。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">compressImage</span><span class="hljs-params">(Bitmap image , <span class="hljs-keyword">long</span> maxSize)</span> </span>&#123;    ByteArrayOutputStream baos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();    Bitmap bitmap = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 质量压缩方法，options的值是0-100，这里100表示原来图片的质量，不压缩，把压缩后的数据存放到baos中</span>    image.compress(Bitmap.CompressFormat.JPEG, <span class="hljs-number">100</span>, baos);    <span class="hljs-keyword">int</span> options = <span class="hljs-number">90</span>;    <span class="hljs-comment">// 循环判断如果压缩后图片是否大于maxSize,大于继续压缩</span>    <span class="hljs-keyword">while</span> (baos.toByteArray().length  &gt; maxSize) &#123;        <span class="hljs-comment">// 重置baos即清空baos</span>        baos.reset();        <span class="hljs-comment">// 这里压缩options%，把压缩后的数据存放到baos中</span>        image.compress(Bitmap.CompressFormat.JPEG, options, baos);        <span class="hljs-comment">// 每次都减少10，当为1的时候停止，options&lt;10的时候，递减1</span>        <span class="hljs-keyword">if</span>(options == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">break</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options &lt;= <span class="hljs-number">10</span>) &#123;            options -= <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            options -= <span class="hljs-number">10</span>;        &#125;    &#125;    <span class="hljs-keyword">byte</span>[] bytes = baos.toByteArray();    <span class="hljs-keyword">if</span> (bytes.length != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 把压缩后的数据baos存放到bytes中</span>        bitmap = BitmapFactory.decodeByteArray(bytes, <span class="hljs-number">0</span>, bytes.length);    &#125;    <span class="hljs-keyword">return</span> bitmap;&#125;</code></pre><blockquote><p>对于Png而言，设置<code>quality</code>无效</p></blockquote><h3 id="采样率压缩"><a href="#采样率压缩" class="headerlink" title="采样率压缩"></a>采样率压缩</h3><p><a href="#inSampleSize">采样率</a></p><h3 id="缩放法压缩"><a href="#缩放法压缩" class="headerlink" title="缩放法压缩"></a>缩放法压缩</h3><blockquote><p>Android使用Matrix对图像进行缩放(<em>减少图片的像素</em>)、旋转、平移、斜切等变换。Mairix是一个3*3的矩阵</p></blockquote><table><thead><tr><th style="text-align:center">scaleX(控制缩放)</th><th style="text-align:center">skewX(控制斜切)</th><th style="text-align:center">translateX(控制位移)</th></tr></thead><tbody><tr><td style="text-align:center">skewY</td><td style="text-align:center">scaleY</td><td style="text-align:center">translateY</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">scale</td></tr></tbody></table><p>执行顺序是 ：  <code>preXXX() -&gt; setXXX() -&gt;postXXX()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Bitmap src, <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> scaleWidth, <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> scaleHeight, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> recycle)</span> </span>&#123;    <span class="hljs-keyword">if</span> (src == <span class="hljs-keyword">null</span> || src.getWidth() == <span class="hljs-number">0</span> || src.getHeight() == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    Matrix matrix = <span class="hljs-keyword">new</span> Matrix();    matrix.setScale(scaleWidth, scaleHeight);    Bitmap ret = Bitmap.createBitmap(src, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, src.getWidth(), src.getHeight(), matrix, <span class="hljs-keyword">true</span>);    <span class="hljs-keyword">if</span> (recycle &amp;&amp; !src.isRecycled()) &#123;        src.recycle();    &#125;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre><h2 id="Bitmap加载高清大图"><a href="#Bitmap加载高清大图" class="headerlink" title="Bitmap加载高清大图"></a>Bitmap加载高清大图</h2><p>在开发过程中如果需要加载超大图或长图，就无法使用上述方案去进行加载，可能会导致图片细节大量丢失，无法查看。</p><p>需要通过<code>BitmapReginDecoder</code>去进行加载，该类支持加载图片的部分区域，可以有效的显示具体细节</p><pre><code class="hljs java">BitmapRegionDecoder bitmapRegionDecoder = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    bitmapRegionDecoder = BitmapRegionDecoder.newInstance(getAssets().open(<span class="hljs-string">"world.jpg"</span>),                <span class="hljs-keyword">true</span>);&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    e.printStackTrace();&#125;<span class="hljs-keyword">int</span> screenWidth = getResources().getDisplayMetrics().widthPixels;<span class="hljs-keyword">int</span> screenHeight = getResources().getDisplayMetrics().heightPixels;<span class="hljs-comment">/*以手机屏幕宽高生成一个矩形区域*/</span>Rect rect = <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,screenWidth,screenHeight);BitmapFactory.Options options = <span class="hljs-keyword">new</span> BitmapFactory.Options();<span class="hljs-comment">/*设置RGB_565格式 取出透明的显示*/</span>options.inPreferredConfig = Bitmap.Config.RGB_565;<span class="hljs-comment">/*加载部分图片*/</span>Bitmap bitmap = bitmapRegionDecoder.decodeRegion(rect,options);imageView.setImageBitmap(bitmap);</code></pre><h2 id="Bitmap内存回收"><a href="#Bitmap内存回收" class="headerlink" title="Bitmap内存回收"></a>Bitmap内存回收</h2><blockquote><p>在Android2.3.3之前，Bitmap的像素数据存放在Native内存，Bitmap对象本身位于Dalvik Heap中。</p><p>Android3.0之后，Bitmap的像素数据也被放进了Dalvik Heap中。</p><p><code>Bitmap.recycle()</code>：释放与此位图关联的本地对象，并清除对像素数据的引用。这不会同步释放像素数据，只是允许它被垃圾收集，如果没有其他的情况。这个时候如果进行调用会抛出异常。</p><p>Android3.0之后就不需要手动调用<code>recycle()</code>进行释放，由系统进行控制。</p></blockquote><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5bfbd5406fb9a049be5d2a20#heading-0" target="_blank" rel="noopener">Bitmap优化详谈</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTU3OTQ1Mw==&amp;mid=2247483753&amp;idx=1&amp;sn=8b25e2915c72aacdf2e1cfa38aa1cb87&amp;chksm=eb44df3bdc33562d7784753776ba820361d71228b0081e66661c6070008c0038bbabf0558ab8&amp;mpshare=1&amp;scene=23&amp;srcid=0316pLW7Dlj2Y0bHTIUNHY2D%23rd" target="_blank" rel="noopener">Android性能优化（五）之细说Bitmap</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ANR分析</title>
    <link href="/2019/01/28/ANR%E5%88%86%E6%9E%90/"/>
    <url>/2019/01/28/ANR%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<!--简要解释一下 ANR？为什么会发生 ANR？如何避免发生 ANR？如何定位 ANR？ANR发生条件？如何分析ANR--><h2 id="ANR概述"><a href="#ANR概述" class="headerlink" title="ANR概述"></a>ANR概述</h2><blockquote><p>ANR：<code>Application Not Responding</code>应用程序未响应，Android会要求一些事件需要在规定时间内处理完成，如果超过预定事件内未能得到有效响应或者响应时间过长，就会造成ANR。</p></blockquote><p>ANR由<strong>消息处理机制</strong>保证，Android在系统层实现了发现ANR的机制，核心原理是<strong>消息调度和超时处理</strong>。</p><p>ANR本质是<strong>性能问题</strong>。实际上是对应用程序主线程的限制，要求主线程在限定时间内处理完一些最常见的操作(<em>启动服务，处理广播，处理输入</em>)，如果处理超时，则认为主线程已经失去了响应其他操作的能力。</p><h2 id="ANR发生场景"><a href="#ANR发生场景" class="headerlink" title="ANR发生场景"></a>ANR发生场景</h2><ul><li><strong>输入事件(按键和触摸事件)5s内未处理</strong>：Input event dispatching timed out</li><li><strong>BroadcastReceiver的<code>onReceive()</code>在规定时间内没处理完(<em>前台广播为10s，后台广播为60s</em>)</strong>：Timeout of broadcast BoradcastRecord</li><li><strong>Service在<em>前台20s后台200s</em>时间内为启动完成</strong>：Timeout executing service</li><li><strong>ContentProvider的<code>publish()</code>在10s内没有执行完成</strong>：Timeout publishing content providers</li></ul><h2 id="ANR机制"><a href="#ANR机制" class="headerlink" title="ANR机制"></a>ANR机制</h2><blockquote><p>ANR机制主要分为两部分：<strong>ANR监测机制</strong>，<strong>ANR报告机制</strong>。</p><ul><li>ANR监测机制：Android对于不同的ANR类型(<em>Broadcast,Service,InputEvent</em>)都有一套监测机制。</li><li>ANR报告机制：在监测到ANR后，需要显示ANR对话框，输出日志等</li></ul></blockquote><h3 id="输入事件超时监测"><a href="#输入事件超时监测" class="headerlink" title="输入事件超时监测"></a>输入事件超时监测</h3><h4 id="输入系统简介"><a href="#输入系统简介" class="headerlink" title="输入系统简介"></a>输入系统简介</h4><p>内核将原始事件写入到设备节点中，<code>InputReader</code>在期限错循环不断的从<code>EventHub</code>中抽取原始输入事件，进行加工处理后将加工所得的事件放入<code>InputDispatcher</code>的派发队列中。<code>InputDispatcher</code>在其线程循环中将派发队列中的事件取出，查找合适的窗口，将事件写入到窗口的事件接收管道中。</p><h4 id="超时监测"><a href="#超时监测" class="headerlink" title="超时监测"></a>超时监测</h4><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/输入事件超时监测.webp" srcset="/img/loading.gif" class="full-image" alt="输入事件超时监测" title="输入事件超时监测"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>InputDispaycher::dispatchOnceInnerLocked()</code>：根据事件类型选择不同事件的处理方法</p><p><code>InputDispaycher::findFocusedWindowTargetsLocked()</code>：内部调用<code>checkWindowReadyForMoreInputLocked()</code>检查窗口是否有新能力在接受新的输入事件。</p><p><code>InputDispatcher::handleTargetsNotReadyLocked()</code>：进行判断事件5s之内是否分发完毕</p><p>当应用主线程被卡住时，再点击其他组件也是无响应，因为事件派发是串行的，上一事件未处理完毕，下一事件不会向下执行。</p><p>在<code>Activity.onCreate()</code>执行耗时操作，不管用户如何操作都不会发生ANR，因为输入事件相关监听机制尚未建立起来。</p><p>输入事件由<code>InputDispatcher</code>调度，待处理的输入输出事件都会进入队列中等待，设计了一个等待超时的判断。</p><h3 id="Service超时监测"><a href="#Service超时监测" class="headerlink" title="Service超时监测"></a>Service超时监测</h3><p>本身有分析过<code>Service的启动流程</code>，在其中了解到<code>ActiveServices.realStartServiceLocked()</code>是真正的Service启动流程。</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActiveServices.java  </span><span class="hljs-comment">// How long we wait for a service to finish executing.</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERVICE_TIMEOUT = <span class="hljs-number">20</span>*<span class="hljs-number">1000</span>;    <span class="hljs-comment">// How long we wait for a service to finish executing.</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * <span class="hljs-number">10</span>;<span class="hljs-comment">//真正启动Service</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">realStartServiceLocked</span><span class="hljs-params">(ServiceRecord r,            ProcessRecord app, <span class="hljs-keyword">boolean</span> execInFg)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;        ...        <span class="hljs-comment">// 主要是为了设置ANR超时，可以看出在正式启动Service之前开始ANR监测；</span>        bumpServiceExecutingLocked(r, execInFg, <span class="hljs-string">"create"</span>);       <span class="hljs-comment">// 启动过程调用scheduleCreateService方法,最终会调用Service.onCreate方法；</span>        app.thread.scheduleCreateService(r, r.serviceInfo,        <span class="hljs-comment">// 绑定过程中，这个方法中会调用app.thread.scheduleBindService方法</span>        requestServiceBindingsLocked(r, execInFg);        <span class="hljs-comment">// 调动Service的其他方法，如onStartCommand，也是IPC通讯</span>        sendServiceArgsLocked(r, execInFg, <span class="hljs-keyword">true</span>);    &#125;<span class="hljs-comment">//设置超时监测                                         </span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleServiceTimeoutLocked</span><span class="hljs-params">(ProcessRecord proc)</span> </span>&#123;        <span class="hljs-keyword">if</span> (proc.executingServices.size() == <span class="hljs-number">0</span> || proc.thread == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        Message msg = mAm.mHandler.obtainMessage(                ActivityManagerService.SERVICE_TIMEOUT_MSG);        msg.obj = proc;        <span class="hljs-comment">// 在serviceDoneExecutingLocked中会remove该SERVICE_TIMEOUT_MSG消息，</span>        <span class="hljs-comment">// 当超时后仍没有remove SERVICE_TIMEOUT_MSG消息，则执行ActiveServices. serviceTimeout()方法；</span>        mAm.mHandler.sendMessageDelayed(msg,                proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);        <span class="hljs-comment">// 前台进程中执行Service，SERVICE_TIMEOUT=20s；后台进程中执行Service，SERVICE_BACKGROUND_TIMEOUT=200s</span>    &#125;<span class="hljs-comment">//在AMS中收到了  SERVICE_TIMEOUT_MSG Message就会触发该方法                                       </span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serviceTimeout</span><span class="hljs-params">(ProcessRecord proc)</span> </span>&#123;    ...    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> maxTime =  now -              (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);    ...    <span class="hljs-comment">// 寻找运行超时的Service</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=proc.executingServices.size()-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;        ServiceRecord sr = proc.executingServices.valueAt(i);        <span class="hljs-keyword">if</span> (sr.executingStart &lt; maxTime) &#123;            timeout = sr;            <span class="hljs-keyword">break</span>;        &#125;       ...    &#125;    ...    <span class="hljs-comment">// 判断执行Service超时的进程是否在最近运行进程列表，如果不在，则忽略这个ANR</span>    <span class="hljs-keyword">if</span> (timeout != <span class="hljs-keyword">null</span> &amp;&amp; mAm.mLruProcesses.contains(proc)) &#123;        anrMessage = <span class="hljs-string">"executing service "</span> + timeout.shortName;    &#125;    ...    <span class="hljs-keyword">if</span> (anrMessage != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 当存在timeout的service，则执行appNotResponding，报告ANR</span>        mAm.appNotResponding(proc, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, anrMessage);    &#125;&#125;</code></pre><p>Service启动前会先启动超时监测，如果在指定时间内(<em>前台20s后台200s</em>)没有启动完毕，就会调用到<code>ActiveServices.serviceTimeout()</code>报告ANR；如果执行完毕，会调用到<code>ActiveServices.serviceDoneExecutingLocked()</code>在其中<code>removeMessages(SERVICE_TIMEOUT_MSG)</code>移除超时消息。</p><h3 id="ANR报告机制"><a href="#ANR报告机制" class="headerlink" title="ANR报告机制"></a>ANR报告机制</h3><p>无论哪种类型的ANR发生后，最终都会调用到<code>AppErrors.appNotResponding()</code>。这个方法主要的功能就是<strong>向用户或开发者报告ANR发生了。</strong>最终的表现就是弹出一个对话框，告诉用户当前程序无法响应；并且会输出ANR日志，以供开发者分析。</p><ul><li><strong>event log</strong>：通过检索”am_anr”关键字，可以找到发生ANR的应用</li><li><strong>main log</strong>：通过检索”ANR in”关键字，可以找到ANR的信息，日志的上下文会包含CPU的使用情况</li><li><strong>dropbox</strong>：通过检索”anr”类型，可以找到ANR的信息</li><li><strong>traces</strong>：发生ANR时，各进程的函数调用栈信息 (<em>可以通过<code>adb pull data.anr/traces.txt</code>导出trace文件</em>)</li></ul><p>ANR报告相关内容主要为以上四种，后续如果需要分析ANR问题，分析ANR往往是从<code>main log中的CPU使用情况和导出的traces.txt文件</code>进行分析。</p><h2 id="ANR分析"><a href="#ANR分析" class="headerlink" title="ANR分析"></a>ANR分析</h2><p>ANR问题的产生是由于主线程的任务无法在规定事件内无法完成。造成这种情况的原因大致会有以下几点：</p><ul><li>主线程在做一些耗时的工作</li><li>主线程被其他线程锁</li><li>cpu被其他线程占用，导致该进程没有被分配到足够的CPU资源</li></ul><p>分析思路主要是:</p><ol><li><code>从log中找到ANR发生的信息</code>：在log中搜索<code>am_anr或ANR in</code>找到ANR发生的log，包含了ANR发生的时间，进程，ANRtype。</li><li><code>继续分析CPU usage的信息</code>：表明了CPU在ANR前后的用量，从各种CPU usage信息中可以分析几点：<ul><li>如果其他进程占用CPU较多，而发生ANR的进程占用较低，可以认为是 因为CPU资源未分配足够，导致的ANR</li><li>如果ANR进程占用CPU较多，可以怀疑是内部一些不合理的代码导致CPU资源大量消耗，如出现了死循环或者后台有大量线程在执行任务，或者存在频繁的文件读写(<em>iowait</em>)</li><li>CPU总用量都不高，该进程和其他线程的占用过高，可能是由于主线程的操作耗时过长，或者主线程被锁导致。</li></ul></li><li><code>向下继续分析 trace文件</code>：trace文件记录了发生ANR前后该进程中各个线程的stack。对我们分析ANR问题最有价值的就是主线程的stack(<code>main</code>)。一般主线程trace中可能有如下几种情况：<ul><li>主线程是<code>running或native</code>而对应的栈对应了我们应用中的函数，则很有可能是执行该函数发生了超时</li><li>主线程是<code>block</code>，主线程被锁，可以考虑进行优化代码，解除掉锁的状态。如果是死锁问题，需要及时处理</li></ul></li></ol><h2 id="ANR避免和检测"><a href="#ANR避免和检测" class="headerlink" title="ANR避免和检测"></a>ANR避免和检测</h2><p>默认情况下，Android应用程序通常在单线程上运行——<strong>主线程</strong>。ANR的发生场景主要是在主线程中进行了耗时操作。</p><blockquote><p>哪些算作UI主线程？</p><ul><li>Activity的所有生命周期回调都是执行在主线程的</li><li>Service默认执行在主线程</li><li>BoradcastReceiver的<code>onReceive()</code>回调在主线程</li><li>没有使用子线程的Looper的Handler实现的<code>handleMessage()</code></li><li>AsyncTask除了<code>doInBackground()</code>执行在主线程</li><li>View的<code>post(runnable)</code>执行在主线程</li></ul></blockquote><p><strong>主要原则是不要在主线程中做耗时操作。</strong></p><p>检测可以利用BlockCanary – 基本原理是利用主线程的消息队列处理机制，通过对比消息分发开始和结束的时间点来判断是否超过设定的时间，超过则判断为线程卡顿。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--CopyOnWriteArrayList实现原理及简析</title>
    <link href="/2019/01/18/Java-CopyOnWriteArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E6%9E%90/"/>
    <url>/2019/01/18/Java-CopyOnWriteArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/CopyOnWriteArrayList简析.png" srcset="/img/loading.gif" class="full-image" alt="CopyOnWriteArrayList简析" title="CopyOnWriteArrayList简析"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="CopyOnWriteArrayList定义"><a href="#CopyOnWriteArrayList定义" class="headerlink" title="CopyOnWriteArrayList定义"></a>CopyOnWriteArrayList定义</h2><blockquote><p>ArrayList本身不是线程安全的，在读线程读取ArrayList的数据时，此时在去写入数据，就会触发<code>fast-fail</code>机制，抛出<code>ConcurrentModificationException</code>异常。也可以使用<code>Vector</code>去代替<code>ArrayList</code>使用，或者使用<code>Collections.synchronizeList()</code>包裹ArrayList。但他们都是使用<code>synchronized</code>进行修饰，执行效率不高。</p><p>针对运行效率情况，有了<code>CopyOnWriteArrayList</code>。</p><p>适用场景：<strong>读多写少</strong>。</p></blockquote><h2 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h2><p><code>CopyOnWrite</code>容器即<code>写时复制</code>的容器。<em>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行copy，复制出一个新的容器，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新的容器。</em></p><p>对<code>CopyOnWrite容器</code>进行并发读的时候，不需要加锁，因为当前容器不会添加任何元素。所以<code>CopyOnWrite容器</code>也是一种<strong>读写分离</strong>的思想，读和写采用不同的容器。<em>放弃了数据实时性。</em></p><h2 id="CopyOnWriteArrayList源码解析"><a href="#CopyOnWriteArrayList源码解析" class="headerlink" title="CopyOnWriteArrayList源码解析"></a>CopyOnWriteArrayList源码解析</h2><h3 id="重要参数分析"><a href="#重要参数分析" class="headerlink" title="重要参数分析"></a>重要参数分析</h3><pre><code class="hljs java"><span class="hljs-comment">//利用Lock实现读写分离</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//设置初始化数组引用</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CopyOnWriteArrayList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//设置空数组</span>    setArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]);&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CopyOnWriteArrayList</span><span class="hljs-params">(E[] toCopyIn)</span> </span>&#123;    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CopyOnWriteArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    Object[] elements;    <span class="hljs-keyword">if</span> (c.getClass() == CopyOnWriteArrayList<span class="hljs-class">.<span class="hljs-keyword">class</span>)        <span class="hljs-title">elements</span> </span>= ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();    <span class="hljs-keyword">else</span> &#123;        elements = c.toArray();        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>        <span class="hljs-keyword">if</span> (elements.getClass() != Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)            <span class="hljs-title">elements</span> </span>= Arrays.copyOf(elements, elements.length, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;    setArray(elements);&#125;</code></pre><h3 id="插入数据-add-E-e"><a href="#插入数据-add-E-e" class="headerlink" title="插入数据 - add(E e)"></a>插入数据 - add(E e)</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;       <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;       <span class="hljs-comment">//锁住写线程，保证同一时刻只有一个线程可以操作</span>       lock.lock();       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//获取旧数组引用</span>           Object[] elements = getArray();           <span class="hljs-keyword">int</span> len = elements.length;           <span class="hljs-comment">//复制旧数组数据到新数组中</span>           Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);           <span class="hljs-comment">//添加新的数据</span>           newElements[len] = e;           <span class="hljs-comment">//设置新数据的引用到旧数组上</span>           setArray(newElements);           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;       &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-comment">//操作完成 解锁</span>           lock.unlock();       &#125;   &#125;</code></pre><ol><li>采用<code>ReentrantLock</code>，保证同一时刻只有一个线程正在进行数组的复制，否则的话内存中会有多份被复制的数据。</li><li><code>volatile</code>修饰的数组引用，在调用<code>setArray()</code>时，线程对数组引用的修改是对其他线程可见的。</li><li>插入数据时插到新的数组中的，可以保证读和写操作在两个数组中执行，不会影响数据。</li></ol><p><strong>和ArrayList相比，效率比较低，每次插入一个数组 都需要进行数组复制操作，随着元素的增加，修改代价会越来越大。</strong></p><h3 id="获取数据-get-int-index"><a href="#获取数据-get-int-index" class="headerlink" title="获取数据 - get(int index)"></a>获取数据 - get(int index)</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;  <span class="hljs-comment">//获取index对应数据</span>  <span class="hljs-keyword">return</span> get(getArray(), index);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">get</span><span class="hljs-params">(Object[] a, <span class="hljs-keyword">int</span> index)</span> </span>&#123;  <span class="hljs-keyword">return</span> (E) a[index];&#125;</code></pre><p><code>get()</code>没有添加线程安全控制，也没有加锁。因为<strong>get()操作的是旧数组，也不会发生修改操作。</strong></p><h3 id="移除数据-remove-int-index"><a href="#移除数据-remove-int-index" class="headerlink" title="移除数据 - remove(int index)"></a>移除数据 - remove(int index)</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        Object[] elements = getArray();        <span class="hljs-keyword">int</span> len = elements.length;        E oldValue = get(elements, index);        <span class="hljs-keyword">int</span> numMoved = len - index - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)            <span class="hljs-comment">//移除了最后一位 只要复制前面的数据即可</span>            setArray(Arrays.copyOf(elements, len - <span class="hljs-number">1</span>));        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//生成一个新数组</span>            Object[] newElements = <span class="hljs-keyword">new</span> Object[len - <span class="hljs-number">1</span>];            System.arraycopy(elements, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);            System.arraycopy(elements, index + <span class="hljs-number">1</span>, newElements, index,                             numMoved);            setArray(newElements);        &#125;        <span class="hljs-keyword">return</span> oldValue;    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h4 id="CopyOnWriteArrayList的缺点"><a href="#CopyOnWriteArrayList的缺点" class="headerlink" title="CopyOnWriteArrayList的缺点"></a>CopyOnWriteArrayList的缺点</h4><ul><li><p><strong>内存占用问题</strong>：在进行写操作时，内存里会有两份数组对象的内存，旧对象和新写入的对象。<em>可以通过压缩容器中元素的方法来减少大对象的内存消耗。</em></p></li><li><p><strong>数据一致性问题</strong>：只能保证最终数据的一致性，不能保证实时一致性。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--ConcurrentHashMap原理及解析</title>
    <link href="/2019/01/16/Java-ConcurrentHashMap%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <url>/2019/01/16/Java-ConcurrentHashMap%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<!--主要是对HashMap，ArrayMap，ConcurrentHashmap--><!-- HashMap和HashTable的区别 , HashMap和ConcurrentHashMap的区别，HashMap的底层源码,HashMap的原理,ConcurrentHashMap，ArrayMap,SparseArray,hashmap线程不安全，请问为什么线程不安全？答，并发时会成环。什么时候成环？比如我有两个数据要装入hashmap。hashset和hashmap的区别，写代码使用hashmap实现一个简单的hashset。--><!-- https://juejin.im/post/59e86f9351882521ad0f4147, https://juejin.im/post/5a7592f4f265da4e8d42ded2 --><!-- hashmap实现的数据结构，数组、桶等。hashmap的哈希冲突解决方法：拉链法等。拉链法的优缺点。hashmap的参数及影响性能的关键参数：加载因子和初始容量。Resize操作的过程。hashmap容量为2次幂的原因。hashtable线程安全、synchronized加锁。hashtable和hashmap异同。为什么hashtable被弃用？--><!--关于HashMap扩容，1.8之前，如果不发生Hash冲突不会触发扩容，1.8之后，只要HashMap中的元素个数大于阈值，就发生扩容。（欢迎纠正）expectedSize / 0.75F + 1.0F  equals 和 hashcode 关系,HashMap遍历原理--><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ConcurrentHashMap结构.png" srcset="/img/loading.gif" class="full-image" alt="ConcurrentHashMap结构" title="ConcurrentHashMap结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>HashMap本身不是线程安全的，通常在多线程情况下可以去使用<code>HashTable</code>替代<code>HashMap</code>使用，该类中基本所有的操作方法都采用<code>synchronized</code>进行修饰，所以在高并发的情况下，每次只能有一个线程获取<code>对象监视器锁</code>，并发性能太低。</p><p>针对上述情况，就产生了<code>ConcurrentHashMap</code>这个类去解决上述问题，提高效率。</p></blockquote><h2 id="ConcurrentHashMap重要参数分析"><a href="#ConcurrentHashMap重要参数分析" class="headerlink" title="ConcurrentHashMap重要参数分析"></a>ConcurrentHashMap重要参数分析</h2><p><code>table</code>：默认为<code>null</code>，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方</p><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;</code></pre><p><br></p><p><code>nextTable</code>：默认为null，扩容时使用，大小为原数组的2倍。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</code></pre><p><br></p><p><code>sizeCtl</code>：该属性用来控制<code>table</code>的初始化和扩容操作。</p><ul><li><strong>-1</strong>：表示当前数组正在初始化</li><li><strong>-N</strong>：表示当前争优<code>N-1</code>个线程进行扩容操作</li><li><strong>0</strong>：数组还未初始化</li><li><strong>N</strong>：1. table未初始化，表示table需要初始化的大小；2. table初始化完成，表示扩容阈值。<strong>源码观察可知该值始终是 table容量的0.75倍</strong>。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> sizeCtl;<span class="hljs-comment">// sizeCtl = n - (n&gt;&gt;&gt;2)</span></code></pre><p><br></p><p><code>sun.misc.Unsage U</code>：利用该类实现<code>CAS算法</code>，实现一种乐观锁的操作。</p><p><br></p><p><code>Node</code>：主要存放 key-value对，并且具有next域。可以保存<code>key、value、hash值</code>的数据结构。</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;    <span class="hljs-keyword">final</span> K key;    <span class="hljs-comment">//使用 volatile进行修饰 保证可见性</span>    <span class="hljs-keyword">volatile</span> V val;    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next; ... &#125;</code></pre><p><br></p><p><code>ForwardingNode</code>：一个特殊的节点，<code>key、value、hash值</code>均为<code>null</code>，存储着对<code>nextTable</code>的引用</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardingNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;        <span class="hljs-keyword">super</span>(MOVED, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">this</span>.nextTable = tab;    &#125;  ...&#125;</code></pre><p>只有table发生扩容的时候，<code>ForwardingNode</code>才有作用，作为一个占位符放在<code>table</code>中表示当前节点为<code>null</code>或者已经被移动。</p><p><br></p><h2 id="ConcurrentMap源码解析"><a href="#ConcurrentMap源码解析" class="headerlink" title="ConcurrentMap源码解析"></a>ConcurrentMap源码解析</h2><h3 id="ConcurrentHashMap初始化"><a href="#ConcurrentHashMap初始化" class="headerlink" title="ConcurrentHashMap初始化"></a>ConcurrentHashMap初始化</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title">ConcurrentMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-comment">//构造一个空的map ，初始容量为默认值 16</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">()</span> </span>&#123;        &#125;    <span class="hljs-comment">//设定map的初始容量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;        <span class="hljs-comment">//小于0 直接抛出异常</span>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        <span class="hljs-comment">//计算过程类比于 1.5 * initialCapacity + 1</span>        <span class="hljs-keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ?                   MAXIMUM_CAPACITY :                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>));        <span class="hljs-comment">//计算出的最终容量进行赋值</span>        <span class="hljs-keyword">this</span>.sizeCtl = cap;    &#125;    <span class="hljs-comment">//插入一个map</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;        <span class="hljs-keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;        putAll(m);    &#125;        <span class="hljs-comment">//设定map的初始容量及加载因子</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;        <span class="hljs-keyword">this</span>(initialCapacity, loadFactor, <span class="hljs-number">1</span>);    &#125;            <span class="hljs-comment">//设定map的初始容量，加载因子以及并发度 - 预计同事可操作数据的线程数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity,                             <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">int</span> concurrencyLevel)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0.0f</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        <span class="hljs-comment">//容量会根据并发度进行调整</span>        <span class="hljs-keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="hljs-comment">// Use at least as many bins</span>            initialCapacity = concurrencyLevel;   <span class="hljs-comment">// as estimated threads</span>        <span class="hljs-keyword">long</span> size = (<span class="hljs-keyword">long</span>)(<span class="hljs-number">1.0</span> + (<span class="hljs-keyword">long</span>)initialCapacity / loadFactor);        <span class="hljs-keyword">int</span> cap = (size &gt;= (<span class="hljs-keyword">long</span>)MAXIMUM_CAPACITY) ?            MAXIMUM_CAPACITY : tableSizeFor((<span class="hljs-keyword">int</span>)size);        <span class="hljs-keyword">this</span>.sizeCtl = cap;    &#125;        <span class="hljs-comment">/**    * 对传入的初始容量进行操作，向上取整 得到最接近初始值的 符合2的幂次    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = c - <span class="hljs-number">1</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;        <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;    &#125;  ...    &#125;</code></pre><p>此时ConcurrentHashMap的初始化只是初始化了 table的容量，还未直接初始化<code>table</code>。需要等到第一次调用<code>put()</code>后执行。</p><h3 id="ConcurrentHashMap插入数据-put"><a href="#ConcurrentHashMap插入数据-put" class="headerlink" title="ConcurrentHashMap插入数据 - put()"></a>ConcurrentHashMap插入数据 - put()</h3><blockquote><p>向ConcurrentHashMap中插入数据</p></blockquote><pre><code class="hljs java">ConcurrentHashMap concurrentHashMap = <span class="hljs-keyword">new</span> ConcurrentHashMap();concurrentHashMap.put(<span class="hljs-string">"Android"</span>,<span class="hljs-string">"best"</span>);</code></pre><blockquote><p><code>put()</code>源码</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;    <span class="hljs-comment">//如果key或者value为null 直接抛出异常</span>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">//计算出key对应的hash值</span>    <span class="hljs-keyword">int</span> hash = spread(key.hashCode());①    <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;        <span class="hljs-comment">//当前table没有初始化</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)            <span class="hljs-comment">//table开始初始化</span>            tab = initTable();②        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;③            <span class="hljs-comment">//利用CAS方式 直接插入值</span>            <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,<span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))④                <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span>        &#125;        <span class="hljs-comment">//表示当前正在扩容</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);⑤        <span class="hljs-keyword">else</span> &#123;            V oldVal = <span class="hljs-keyword">null</span>;            <span class="hljs-comment">//获取头节点的监视器锁</span>            <span class="hljs-keyword">synchronized</span> (f) &#123;                <span class="hljs-comment">//在节点插入之前，在进行判断，防止被其他线程修改</span>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                    <span class="hljs-comment">//当前为链表，在链表中插入新的键值对</span>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                        <span class="hljs-comment">//记录链表长度</span>                        binCount = <span class="hljs-number">1</span>;                        <span class="hljs-comment">//开始遍历链表</span>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            K ek;                            <span class="hljs-comment">//如果找到了相等的key</span>                            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;((ek = e.key) == key ||                                 (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;                                <span class="hljs-comment">//直接覆盖旧值</span>                                oldVal = e.val;                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                                             e.val = value;                                <span class="hljs-keyword">break</span>;                            &#125;                            <span class="hljs-comment">//到了链表末端，直接数据插到链表末端</span>                            Node&lt;K,V&gt; pred = e;                            <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;                                pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>);                                <span class="hljs-keyword">break</span>;                            &#125;                        &#125;                    &#125;                    <span class="hljs-comment">//当前数据结构为 红黑树</span>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;                        Node&lt;K,V&gt; p;                        binCount = <span class="hljs-number">2</span>;                        <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="hljs-keyword">null</span>) &#123;                            oldVal = p.val;                            <span class="hljs-keyword">if</span> (!onlyIfAbsent)                                p.val = value;                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-comment">//插入数据后再根据实际大小判断是否需要转换成红黑树</span>            <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                    <span class="hljs-comment">//这个方法中不一定会进行红黑树的变换，如果当前数据的长度小于64 (MIN_TREEIFY_CAPACITY)</span>                    <span class="hljs-comment">//就会执行扩容操作，而不是进行红黑树转化。</span>                    treeifyBin(tab, i);⑥                <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)                    <span class="hljs-keyword">return</span> oldVal;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//对当前数组容量进行检查，超过了临界值，就需要扩容</span>    addCount(<span class="hljs-number">1L</span>, binCount);⑦    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p><code>put()</code>操作主要包括以下几项：</p><p>①<code>int hash = spread(key.hashCode());</code>：计算Hash值</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">spread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;    <span class="hljs-keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)) &amp; HASH_BITS;&#125;</code></pre><p>②<code>tab = initTable();</code>：如果table尚未初始化，就需要进行初始化操作</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;    Node&lt;K,V&gt;[] tab; <span class="hljs-keyword">int</span> sc;    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 当一个线程发现sizeCtl&lt;0即正在初始化时，意味着另外的线程正在执行初始化操作，其他线程只能让出CPU等待table初始化完成</span>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)            Thread.yield();        <span class="hljs-comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁 </span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">// DEFAULT_CAPACITY 默认初始容量是 16</span>                    <span class="hljs-keyword">int</span> n = (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;                    <span class="hljs-comment">// 初始化数组，长度为 16 或初始化时提供的长度</span>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];                    <span class="hljs-comment">// 将这个数组赋值给 table，table 是 volatile 的</span>                    table = tab = nt;                    <span class="hljs-comment">// 如果 n 为 16 的话，那么这里 sc = 12</span>                    <span class="hljs-comment">// 其实就是 0.75 * n</span>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">// 设置 sizeCtl 为 sc</span>                sizeCtl = sc;            &#125;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> tab;&#125;</code></pre><p><em>table初始化的操作有且只有一个线程能够操作，其他线程通过<code>Thread.yield()</code>让出CPU时间片等待初始化完成。</em></p><p>③<code>f = tabAt(tab, i = (n - 1) &amp; hash))</code>：获取hash值转换后得到的存储位置的头节点<code>f</code>。<em>无论链表头节点还是红黑树的根节点都是在数组上的。</em></p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);&#125;</code></pre><p>在<code>JMM</code>中，每个线程都有他自己的工作内存，里面存储着数据的副本，虽然<code>table</code>是<code>volatile</code>修饰的，但不能绝对保证拿到的就是最新的数据，利用<code>U.getObjectVolatile</code>是直接取得指定内存的数据，可以保证每次拿到的都是最新的。</p><p>④<code>casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null))</code>：由于发现存储位置上没有元素，则利用CAS直接插入新节点</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i,Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;    <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;</code></pre><p>利用<code>CAS操作</code>直接将节点放入table对应位置中。但是如果CAS插入失败，意味着是一个并发操作，直接向下继续执行。</p><p>⑤<code>helpTransfer()</code>：帮助数据迁移</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;    Node&lt;K,V&gt;[] nextTab; <span class="hljs-keyword">int</span> sc;    <span class="hljs-keyword">if</span> (tab != <span class="hljs-keyword">null</span> &amp;&amp; (f <span class="hljs-keyword">instanceof</span> ForwardingNode) &amp;&amp;        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">int</span> rs = resizeStamp(tab.length);        <span class="hljs-keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;               (sc = sizeCtl) &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="hljs-number">0</span>)                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>)) &#123;                transfer(tab, nextTab);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> nextTab;    &#125;    <span class="hljs-keyword">return</span> table;&#125;</code></pre><p>⑥<code>treeifyBin()</code>：当完成数据新节点插入后，会进一步对当前链表大小进行调整。当链表长度大于<code>TREEIFY_THRESHOLD</code>阈值，默认8，会进行链表转换红黑树，也可能是仅仅做数组扩容。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> index)</span> </span>&#123;    Node&lt;K,V&gt; b; <span class="hljs-keyword">int</span> n, sc;    <span class="hljs-keyword">if</span> (tab != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// MIN_TREEIFY_CAPACITY 为 64</span>        <span class="hljs-comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span>        <span class="hljs-keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)            <span class="hljs-comment">//扩容</span>            tryPresize(n &lt;&lt; <span class="hljs-number">1</span>);        <span class="hljs-comment">// b 是头结点</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((b = tabAt(tab, index)) != <span class="hljs-keyword">null</span> &amp;&amp; b.hash &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 加锁</span>            <span class="hljs-keyword">synchronized</span> (b) &#123;                <span class="hljs-keyword">if</span> (tabAt(tab, index) == b) &#123;                    <span class="hljs-comment">// 下面就是遍历链表，建立一颗红黑树</span>                    TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;                    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;                       <span class="hljs-comment">//链表节点转换树节点</span>                        TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                        <span class="hljs-keyword">if</span> ((p.prev = tl) == <span class="hljs-keyword">null</span>)                            hd = p;                        <span class="hljs-keyword">else</span>                            tl.next = p;                        tl = p;                    &#125;                    <span class="hljs-comment">// 将红黑树设置到数组相应位置中</span>                    setTabAt(tab, index, <span class="hljs-keyword">new</span> TreeBin&lt;K,V&gt;(hd));                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>⑦<code>addCount(1L, binCount)</code>：table存储键值对数量增加，然后需要判断是否超过扩容阈值，若超过需要进行扩容操作。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x, <span class="hljs-keyword">int</span> check)</span> </span>&#123;        CounterCell[] as; <span class="hljs-keyword">long</span> b, s;        <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-keyword">null</span> ||            !U.compareAndSwapLong(<span class="hljs-keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;            CounterCell a; <span class="hljs-keyword">long</span> v; <span class="hljs-keyword">int</span> m;            <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||                !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;                fullAddCount(x, uncontended);                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">if</span> (check &lt;= <span class="hljs-number">1</span>)                <span class="hljs-keyword">return</span>;            s = sumCount();        &#125;        <span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;            Node&lt;K,V&gt;[] tab, nt; <span class="hljs-keyword">int</span> n, sc;            <span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-keyword">null</span> &amp;&amp;                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;                <span class="hljs-keyword">int</span> rs = resizeStamp(n);                <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-keyword">null</span> ||                        transferIndex &lt;= <span class="hljs-number">0</span>)                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))                        transfer(tab, nt);                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))                    transfer(tab, <span class="hljs-keyword">null</span>);                s = sumCount();            &#125;        &#125;    &#125;</code></pre><h3 id="ConcurrentHashMap扩容操作-tryPresize"><a href="#ConcurrentHashMap扩容操作-tryPresize" class="headerlink" title="ConcurrentHashMap扩容操作 - tryPresize()"></a>ConcurrentHashMap扩容操作 - tryPresize()</h3><blockquote><p>由上述源码可知，触发扩容动作的情况有两个：</p><ol><li>新增节点后，链表长度达到了8，就会调用<code>treeifyBin()</code>对其进行转换，但是如果此时存储的键值对数量如果未到64(<code>最小树形化阈值</code>)，就会触发<code>tryPresize()</code>扩大数组长度至原来的两倍，并调用<code>transfer()</code>进行数据迁移。</li><li>新增节点后，会调用<code>addCount()</code>使存储数量 +1 ，还会去检测是否达到扩容阈值，达到时会触发<code>transfer()</code>，重新调整节点的位置。</li></ol></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryPresize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;    <span class="hljs-comment">// c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span>    <span class="hljs-keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ? MAXIMUM_CAPACITY :        tableSizeFor(size + (size &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> sc;    <span class="hljs-comment">//跳出循环的判断 需要依赖 transfer的操作结束</span>    <span class="hljs-keyword">while</span> ((sc = sizeCtl) &gt;= <span class="hljs-number">0</span>) &#123;        Node&lt;K,V&gt;[] tab = table; <span class="hljs-keyword">int</span> n;        <span class="hljs-comment">// 初始化数组</span>        <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) &#123;            n = (sc &gt; c) ? sc : c; <span class="hljs-comment">//取大值</span>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">if</span> (table == tab) &#123;                        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n];                        table = nt;                        sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// 0.75 * n</span>                    &#125;                &#125; <span class="hljs-keyword">finally</span> &#123;                    sizeCtl = sc;                &#125;            &#125;        &#125;        <span class="hljs-comment">//已经超过最大上限 就不需要扩容了</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tab == table) &#123;            <span class="hljs-keyword">int</span> rs = resizeStamp(n);            <span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;                Node&lt;K,V&gt;[] nt;                <span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> ||                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-keyword">null</span> ||                    transferIndex &lt;= <span class="hljs-number">0</span>)                    <span class="hljs-keyword">break</span>;                <span class="hljs-comment">// 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span>                <span class="hljs-comment">//    此时 nextTab 不为 null</span>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))                    transfer(tab, nt);            &#125;            <span class="hljs-comment">// 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span>            <span class="hljs-comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))                transfer(tab, <span class="hljs-keyword">null</span>);        &#125;    &#125;&#125;</code></pre><h4 id="ConcurrentHashMap迁移数据-transfer-重要"><a href="#ConcurrentHashMap迁移数据-transfer-重要" class="headerlink" title="ConcurrentHashMap迁移数据 - transfer() 重要"></a>ConcurrentHashMap迁移数据 - transfer() <strong>重要</strong></h4><blockquote><p>将原来旧表的数据迁移至新表中。</p></blockquote><p>迁移过程涉及并发操作。原数组长度为n，所以会出现n个迁移任务，让每个线程单独去负责每一个迁移任务，每做完一个任务在检测是否有其他没做完的任务。</p><p><code>transfer()</code>中利用了一个<code>stride(步长)</code>，每个线程负责迁移一部分。</p><p>再调用到<code>transfer()</code>的函数中观察到<code>transfer(tab, null)</code>在一次调用过程中只会存在一次，然后其他调用的时候<code>nextTable</code>已经初始化完毕，就不会在调用到空。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;       <span class="hljs-keyword">int</span> n = tab.length, stride;       <span class="hljs-comment">//设置任务执行区域 NCPU代指CPU核数</span>       <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)           stride = MIN_TRANSFER_STRIDEC;  <span class="hljs-comment">//最小长度为 16</span>       <span class="hljs-comment">//先进行一次 nextTable初始化 </span>       <span class="hljs-comment">//这个过程只会发生一次</span>       <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-keyword">null</span>) &#123;                       <span class="hljs-keyword">try</span> &#123;               <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)               <span class="hljs-comment">//容量翻倍</span>               Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];               <span class="hljs-comment">//进行赋值 即 nextTable长度为旧表的两倍</span>               nextTab = nt;           &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span>               sizeCtl = Integer.MAX_VALUE;               <span class="hljs-keyword">return</span>;           &#125;           nextTable = nextTab;           <span class="hljs-comment">//用于控制迁移的位置</span>           transferIndex = n;       &#125;              <span class="hljs-keyword">int</span> nextn = nextTab.length;       <span class="hljs-comment">//初始化 ForwardNode 代表正在被迁移的Node hash值 = MOVED</span>       ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);       <span class="hljs-comment">//表明该位置的迁移工作已经完成</span>       <span class="hljs-keyword">boolean</span> advance = <span class="hljs-keyword">true</span>;       <span class="hljs-comment">//所有迁移工作中是否完成</span>       <span class="hljs-keyword">boolean</span> finishing = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span>       <span class="hljs-comment">// i 代表当前处理的槽位序号  bound 代表要处理的槽位边界 是从后向前的循环方式</span>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;           Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> fh;           <span class="hljs-keyword">while</span> (advance) &#123;               <span class="hljs-keyword">int</span> nextIndex, nextBound;               <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)                   advance = <span class="hljs-keyword">false</span>;               <span class="hljs-comment">//表明原数组的所有位置都有相应的线程进行处理</span>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;                   i = -<span class="hljs-number">1</span>;                   advance = <span class="hljs-keyword">false</span>;               &#125;               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt                        (<span class="hljs-keyword">this</span>, TRANSFERINDEX, nextIndex,                         nextBound = (nextIndex &gt; stride ?                                      nextIndex - stride : <span class="hljs-number">0</span>))) &#123;                   <span class="hljs-comment">//nextBound代表这次迁移任务的边界，当为0时，代表已经在处理了</span>                   bound = nextBound;                   i = nextIndex - <span class="hljs-number">1</span>;                   advance = <span class="hljs-keyword">false</span>;               &#125;           &#125;           <span class="hljs-comment">//表明迁移任务已经结束</span>           <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;               <span class="hljs-keyword">int</span> sc;               <span class="hljs-comment">// 表明迁移任务结束</span>               <span class="hljs-keyword">if</span> (finishing) &#123;                   nextTable = <span class="hljs-keyword">null</span>;                   table = nextTab;                   <span class="hljs-comment">//重新调整 sizeCtl 为新数组长度 0.75倍</span>                   sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);                   <span class="hljs-keyword">return</span>;               &#125;               <span class="hljs-comment">// 迁移任务开始前 sizeCtl 会被设置为 rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span>               <span class="hljs-comment">// 每有一个线程参与迁移任务 sizeCtl + 1</span>               <span class="hljs-comment">// CAS对其进行 -1操作</span>               <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;                   <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                       <span class="hljs-keyword">return</span>;                   <span class="hljs-comment">//当sizeCtl 与初始值相同时 意味着所有的迁移已经完毕</span>                   finishing = advance = <span class="hljs-keyword">true</span>;                   i = n; <span class="hljs-comment">// recheck before commit</span>               &#125;           &#125;           <span class="hljs-comment">//位置 i 没有元素存在，那么直接放入初始化好的 ForwardingNode , 然后告知其他线程该位置已经迁移完毕</span>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-keyword">null</span>)               advance = casTabAt(tab, i, <span class="hljs-keyword">null</span>, fwd);           <span class="hljs-comment">//位置 i 上是 ForwardingNode 代表该位置已经迁移完毕</span>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)               advance = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// already processed</span>           <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">//需要对该位置节点操作加锁</span>               <span class="hljs-keyword">synchronized</span> (f) &#123;                   <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;                       Node&lt;K,V&gt; ln, hn;                       <span class="hljs-comment">//代表当前结构是链表结构</span>                       <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;                           <span class="hljs-comment">//将该位置的链表一分为二 按照</span>                           <span class="hljs-keyword">int</span> runBit = fh &amp; n;                           Node&lt;K,V&gt; lastRun = f;                           <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="hljs-keyword">null</span>; p = p.next) &#123;                               <span class="hljs-keyword">int</span> b = p.hash &amp; n;                               <span class="hljs-keyword">if</span> (b != runBit) &#123;                                   runBit = b;                                   lastRun = p;                               &#125;                           &#125;                           <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;                               ln = lastRun;                               hn = <span class="hljs-keyword">null</span>;                           &#125;                           <span class="hljs-keyword">else</span> &#123;                               hn = lastRun;                               ln = <span class="hljs-keyword">null</span>;                           &#125;                           <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;                               <span class="hljs-keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;                               <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>)                                   ln = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);                               <span class="hljs-keyword">else</span>                                   hn = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);                           &#125;                           <span class="hljs-comment">//将 ln 放在新数组的 i(即在旧数组的原位置) 上</span>                           setTabAt(nextTab, i, ln);                           <span class="hljs-comment">//将 hn 放在新数组的 i+oldCap 上</span>                           setTabAt(nextTab, i + n, hn);                           <span class="hljs-comment">//设置原数组上该位置的点为 ForwardingNode 代表该位置已经迁移完毕</span>                           setTabAt(tab, i, fwd);                           <span class="hljs-comment">//标记迁移完毕</span>                           advance = <span class="hljs-keyword">true</span>;                       &#125;                       <span class="hljs-comment">//结构为 红黑树</span>                       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;                           TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                           TreeNode&lt;K,V&gt; lo = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;                           TreeNode&lt;K,V&gt; hi = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;                           <span class="hljs-keyword">int</span> lc = <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;                           <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;                               <span class="hljs-keyword">int</span> h = e.hash;                               TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> TreeNode&lt;K,V&gt;                                   (h, e.key, e.val, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                               <span class="hljs-keyword">if</span> ((h &amp; n) == <span class="hljs-number">0</span>) &#123;                                   <span class="hljs-keyword">if</span> ((p.prev = loTail) == <span class="hljs-keyword">null</span>)                                       lo = p;                                   <span class="hljs-keyword">else</span>                                       loTail.next = p;                                   loTail = p;                                   ++lc;                               &#125;                               <span class="hljs-keyword">else</span> &#123;                                   <span class="hljs-keyword">if</span> ((p.prev = hiTail) == <span class="hljs-keyword">null</span>)                                       hi = p;                                   <span class="hljs-keyword">else</span>                                       hiTail.next = p;                                   hiTail = p;                                   ++hc;                               &#125;                           &#125;                           <span class="hljs-comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span>                           ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                               (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;                           hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                               (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;                           setTabAt(nextTab, i, ln);                           setTabAt(nextTab, i + n, hn);                           setTabAt(tab, i, fwd);                           advance = <span class="hljs-keyword">true</span>;                       &#125;                   &#125;               &#125;           &#125;       &#125;   &#125;</code></pre><p>总结流程：</p><ul><li>构建一个<code>nextTable</code>，它的容量是原来的两倍，这个操作只会执行一次。</li><li>根据hash值 计算对应的存储位置，然后根据<code>tabAt(i)</code>获得对应位置的头节点。</li><li>如果头节点为null，就在原table[i]放入<code>ForwardingNode</code>，代表当前位置已经迁移完毕。</li><li>如果头节点为链表节点，就构造一个反序链表，把他们分别放在<code>nextTable</code>中的<code>i和i+oldCap</code>位置上。放入成功后，在table[i]放入<code>ForwardingNode</code>，代表迁移完毕。</li><li>如果头节点为树节点，也做一个反序操作，并且判断是否需要重新转换成链表，再把处理后的结果分别放到<code>nextTable</code>中的<code>i和i+oldCap</code>位置上。放入成功后，在table[i]放入<code>ForwardingNode</code>，代表迁移完毕</li><li>遍历所有的节点就完成了数据迁移工作，让nextTable替代ConcurrentHashMap中的table，并更新<code>sizeCtl</code>为新数据容量的0.75倍，完成扩容。</li></ul><h3 id="ConcurrentHashMap获取数据-get"><a href="#ConcurrentHashMap获取数据-get" class="headerlink" title="ConcurrentHashMap获取数据 - get()"></a>ConcurrentHashMap获取数据 - get()</h3><blockquote><p>concurrentHashMap.get(“Android”);</p></blockquote><p>源码解析：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword">int</span> n, eh; K ek;    <span class="hljs-comment">//计算 hash值</span>    <span class="hljs-keyword">int</span> h = spread(key.hashCode());    <span class="hljs-comment">//当前数组不能为空</span>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 判断头结点是否就是我们需要的节点</span>        <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;            <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))                <span class="hljs-keyword">return</span> e.val;        &#125;        <span class="hljs-comment">// 如果头结点的 hash 小于 0，说明 正在扩容 -1 ，或者该位置是红黑树</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)            <span class="hljs-comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span>            <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-keyword">null</span> ? p.val : <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 遍历链表</span>        <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;                ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek))))                <span class="hljs-keyword">return</span> e.val;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>总结流程：</p><ul><li>首先计算key对应的<code>Hash值</code>，定为到<code>table</code>上的对应位置，如果直接是头节点就返回</li><li>此时需要判断头节点的<code>hash值</code><ul><li><code>hash值等于-1</code>：说明该节点为<code>ForwardingNode</code>，表明此时正在执行扩容操作，调用其<code>find()</code>从<code>nextTable</code>寻找对应值</li><li><code>hash值等于-2</code>：说明该节点是一个树节点，调用<code>TreeBin.find()</code>去寻找对应值,<strong>内部存在着读写锁，可能红黑树正在旋转变色。</strong></li><li><code>hash值大于等于0</code>：说明该节点是一个链表节点，直接进行链表遍历寻找对应值即可。</li></ul></li><li>如果都没有找到，就返回null</li></ul><blockquote><p>为什么<code>get()</code>不需要加锁？</p><p>关键点在于<code>table</code>是由<code>volatile</code>进行修饰的，这个关键字可以保证可见性以及有序性。如果对其声明的变量进行了写操作，JVM就会向处理器发送一条指令，将这个变量所在的缓存行数据写回到主内存。基于<strong>缓存一致性协议</strong>，其他线程去读取时，就要强制从主内存中读取。<strong>在数组进行扩容时可以保证可见性。</strong></p><p>对存储的节点<code>Node</code>的<code>元素val</code>以及<code>指针next</code>也是用<code>volatile</code>进行修饰的，再、在多线程环境下对他们进行改变对其他线程也是可见的。</p></blockquote><h2 id="引用参考"><a href="#引用参考" class="headerlink" title="引用参考"></a>引用参考</h2><p><a href="https://javadoop.com/post/hashmap#put%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener"><strong>Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</strong></a></p><p><a href="https://www.jianshu.com/p/c0642afe03e0" target="_blank" rel="noopener">深入浅出ConcurrentHashMap1.8</a></p><p><a href="https://juejin.im/post/5df8d7346fb9a015ff64eaf9" target="_blank" rel="noopener">ConcurrentHashMap&amp;HashTable</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--ArrayList实现原理及简析</title>
    <link href="/2019/01/15/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E6%9E%90/"/>
    <url>/2019/01/15/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ArrayList结构.png" srcset="/img/loading.gif" class="full-image" alt="ArrayList结构" title="ArrayList结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="ArrayList定义"><a href="#ArrayList定义" class="headerlink" title="ArrayList定义"></a>ArrayList定义</h2><p>ArrayList是基于<code>List</code>接口实现的大小可变的数组，元素允许为任意属性包括<code>null</code>。同时非有序，非同步(线程不安全)。主要用于装载数据。</p><p><code>ArrayList</code>底层实现是<strong>数组</strong>。</p><h2 id="ArrayList的重要参数分析"><a href="#ArrayList的重要参数分析" class="headerlink" title="ArrayList的重要参数分析"></a>ArrayList的重要参数分析</h2><pre><code class="hljs java"><span class="hljs-comment">//ArrayList 默认容量为10</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;<span class="hljs-comment">//用于ArrayList 空实例时的共享空数组</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="hljs-comment">//用于默认大小 共享空数组实例</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA=&#123;&#125;;<span class="hljs-comment">//存储ArrayList元素的数据缓冲区，ArrayList的容量是此数据缓冲区的长度</span><span class="hljs-keyword">transient</span> Object[] elementData();<span class="hljs-comment">//ArrayList包含的元素个数</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;</code></pre><h2 id="ArrayList初始化"><a href="#ArrayList初始化" class="headerlink" title="ArrayList初始化"></a>ArrayList初始化</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">//创建初始容量为 initialCapacity 的数组</span>        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// 初始容量为0  引用空数组实例s</span>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+                                           initialCapacity);    &#125;&#125;<span class="hljs-comment">//构造一个默认10位的数组</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//初始默认 空数组</span>    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    elementData = c.toArray();    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//将要插入到集合的元素 复制到数组中</span>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)            <span class="hljs-title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// replace with empty array.         </span>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><p>在<code>ArrayList</code>初始化中，如果不是设置了初始容量，那么数据并不会进行初始化，等到第一次<code>add()</code>时进行初始化。</p><h2 id="ArrayList插入数据-add"><a href="#ArrayList插入数据-add" class="headerlink" title="ArrayList插入数据 - add()"></a>ArrayList插入数据 - add()</h2><pre><code class="hljs java">ArrayList&lt;String&gt; list =<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="hljs-string">"Android"</span>);</code></pre><p><code>add(E e)</code>源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>    <span class="hljs-comment">//在数组对应位置 放入数据</span>    elementData[size++] = e;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p><code>ensureCapacitInternal()</code>用来判定是否需要扩充来存储数据</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;     ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125;<span class="hljs-comment">//未初始化则 返回10  初始化完成 则是传递进来的值</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;     <span class="hljs-comment">//此时用的是默认构造器 构造的ArrayList</span>     <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;         <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);     &#125;     <span class="hljs-keyword">return</span> minCapacity; &#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">//修改数量 +1 </span>     modCount++;     <span class="hljs-comment">// 确保数组的容量，如果不够需要进行扩容 未初始化时 elementData.length == 0</span>     <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)         grow(minCapacity); &#125;</code></pre><p><code>grow()</code>用来进行数组扩容</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// 当前数组的容量</span>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;    <span class="hljs-comment">//新数组扩容至原来的1.5倍</span>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">//未初始化 min为10</span>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;    <span class="hljs-comment">//超出上限 则长度变为 Integer.MAX_VALUE</span>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="hljs-comment">// 复制元素到新的数组中</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index,E element)"></a><code>add(int index,E element)</code></h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;    <span class="hljs-comment">// 判断 index 有没有超出索引的范围</span>    rangeCheckForAdd(index);    <span class="hljs-comment">// 和之前的操作是一样的，都是保证数组的容量足够</span>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>    <span class="hljs-comment">// 将指定位置及其后面数据向后移动一位</span>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,size - index);    <span class="hljs-comment">// 将该元素添加到指定的数组位置</span>    elementData[index] = element;    <span class="hljs-comment">// ArrayList 的大小改变</span>    size++;&#125;</code></pre><p><code>rangeCheckForAdd()</code> 判断要插入数据的index是否超过当前存储数据的上限<code>size</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ArrayList-add过程.png" srcset="/img/loading.gif" class="full-image" alt="ArrayList-add过程" title="ArrayList-add过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="ArrayList获取数据-get"><a href="#ArrayList获取数据-get" class="headerlink" title="ArrayList获取数据 - get()"></a>ArrayList获取数据 - get()</h2><pre><code class="hljs java">list.get(<span class="hljs-number">0</span>);</code></pre><p><code>get()</code>源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">//判定index位置是否在范围内</span>    rangeCheck(index);    <span class="hljs-keyword">return</span> elementData(index);&#125;</code></pre><h2 id="ArrayList删除数据-remove"><a href="#ArrayList删除数据-remove" class="headerlink" title="ArrayList删除数据 - remove()"></a>ArrayList删除数据 - remove()</h2><pre><code class="hljs java">list.remove(<span class="hljs-number">0</span>);<span class="hljs-comment">//删除内容</span>list.remove(<span class="hljs-string">"Android"</span>)</code></pre><p><code>remove(int index)</code>源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-comment">//检查index有没有超出范围</span>    rangeCheck(index);    modCount++;    <span class="hljs-comment">//保存需要删除的数据 可以返回旧值</span>    E oldValue = elementData(index);    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)        <span class="hljs-comment">//把删除的位置后一位数据 向前移</span>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);    <span class="hljs-comment">//设置原位置元素为null  方便释放内存</span>    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>    <span class="hljs-keyword">return</span> oldValue;&#125;</code></pre><p><code>remove(Object o)</code>源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;                fastRemove(index);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果有元素值 == o 找到对应的位置 并移除</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;                fastRemove(index);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    modCount++;    <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,                         numMoved);    elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>&#125;</code></pre><h2 id="ArrayList清空数据-clear"><a href="#ArrayList清空数据-clear" class="headerlink" title="ArrayList清空数据 - clear()"></a>ArrayList清空数据 - clear()</h2><pre><code class="hljs java">list.clear()</code></pre><p><code>clear()</code>源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    modCount++;    <span class="hljs-comment">// 数组内所有元素置null</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)        elementData[i] = <span class="hljs-keyword">null</span>;    size = <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别?"></a>ArrayList和LinkedList的区别?</h4><blockquote><p>ArrayList</p><ul><li>基于<strong>数组</strong>实现，可以用索引实现快速查找。是动态数组，相比于数组容量可以实现动态增长。</li><li>ArrayList可以插入<code>null</code>。</li><li>ArrayList初始容量为10，以1.5倍大小进行扩容。</li><li>ArrayList不是线程安全。如果想线程安全可以通过<code>Collections.synchronizeList()</code>包裹ArrayList，实质上是对ArrayList的所有操作加了锁。推荐使用<code>CopyOnWriteArrayList</code>。</li><li>在顺序添加数据以及查找和访问数据上有优势，再删除和插入数据上 需要进行数组复制操作。</li></ul></blockquote><p><br></p><blockquote><p>LinkdedList</p><ul><li>基于<strong>链表</strong>实现，是双向链表，增删速度快。是一个双向循环链表，也可以被当做堆栈、队列使用。</li><li>LinkedList比ArrayList更占内存，由于节点存储了数据以及前后两节点的引用</li><li>LinkedList是线程不安全，也可以通过<code>Collections.synchronizeList()</code>包括LinkedList，推荐使用<code>ConcurrentLinkedQueue</code></li><li>在数据的删除和插入上有优势</li></ul></blockquote><h4 id="ArrayList及LinkedList在插入数据上的比较"><a href="#ArrayList及LinkedList在插入数据上的比较" class="headerlink" title="ArrayList及LinkedList在插入数据上的比较"></a>ArrayList及LinkedList在插入数据上的比较</h4><ul><li>在头部插入数据：<code>ArrayList</code>需要进行一次数组复制(<code>System.arrayCopy</code>)而<code>LinkedList</code>只要遍历找到头部为止即可。所以<code>LinkedList</code>高效。</li><li>在中部插入数据<ul><li>插入位置越靠前：<code>LinkedList</code>效率越高</li><li>插入位置靠中间：<code>LinkedList</code>的遍历是从两边开始的，往中靠效率越低。</li><li>插入位置越靠后：<code>ArrayList</code>效率越高</li></ul></li><li>在尾部插入数据：<code>ArrayList</code>可能需要触发扩容操作，导致速度不如<code>LinkedList</code>。当数据量大时，<code>ArrayList</code>不会去频繁的进行扩容，效率就会高于<code>LinkedList</code>。</li></ul><h4 id="ArrayList的序列化"><a href="#ArrayList的序列化" class="headerlink" title="ArrayList的序列化"></a>ArrayList的序列化</h4><blockquote><p><code>transient</code>可以关闭被修饰字段的序列化。</p></blockquote><p><code>elementData</code>是通过<code>transient</code>修饰的，那么内部的<code>elementData</code>是无法被序列化的。所以ArrayList内部实现了序列化及反序列化的一系列工作。</p><pre><code class="hljs java"><span class="hljs-comment">//保存ArrayList中的实例状态到序列中</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span>    <span class="hljs-keyword">throws</span> java.io.IOException</span>&#123;    <span class="hljs-comment">// Write out element count, and any hidden stuff</span>    <span class="hljs-keyword">int</span> expectedModCount = modCount;    s.defaultWriteObject();    <span class="hljs-comment">// Write out size as capacity for behavioural compatibility with clone()</span>    s.writeInt(size);    <span class="hljs-comment">// Write out all elements in the proper order.</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;        s.writeObject(elementData[i]);    &#125;    <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span>    <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;    elementData = EMPTY_ELEMENTDATA;    <span class="hljs-comment">// Read in size, and any hidden stuff</span>    s.defaultReadObject();    <span class="hljs-comment">// Read in capacity</span>    s.readInt(); <span class="hljs-comment">// ignored</span>    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// be like clone(), allocate array based upon size not capacity</span>        <span class="hljs-keyword">int</span> capacity = calculateCapacity(elementData, size);        SharedSecrets.getJavaOISAccess().checkArray(s, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">capacity</span>)</span>;        ensureCapacityInternal(size);        Object[] a = elementData;        <span class="hljs-comment">// Read in all elements in the proper order.</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;            a[i] = s.readObject();        &#125;    &#125;&#125;</code></pre><p>观察源码可知，只是序列化了<code>ArrayList中已存在的元素，而非整个数组</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SharedPreferences简析</title>
    <link href="/2019/01/13/SharesPreference%E7%AE%80%E6%9E%90/"/>
    <url>/2019/01/13/SharesPreference%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/SharedPreferences解析.png" srcset="/img/loading.gif" class="full-image" alt="SharedPreferences解析" title="SharedPreferences解析"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="SharedPreferences基本概念"><a href="#SharedPreferences基本概念" class="headerlink" title="SharedPreferences基本概念"></a>SharedPreferences基本概念</h2><p>Android系统提供的一种简易数据持久化的手段，适合<strong>单进程、小批量</strong>的数据存储与访问。最终会在手机的<code>/data/data/package_name/shared_prefs/</code>目录(<em>私有目录外部无法直接访问</em>)下生成一个xml文件。</p><p>SharedPreferences是基于单个xml文件实现的，并且所有持久化的数据都是一次性加载到内存中，如果数据过大，容易导致内存问题。</p><h2 id="SharedPreferences源码解析"><a href="#SharedPreferences源码解析" class="headerlink" title="SharedPreferences源码解析"></a>SharedPreferences源码解析</h2><h3 id="获取SharedPreferences对象"><a href="#获取SharedPreferences对象" class="headerlink" title="获取SharedPreferences对象"></a>获取SharedPreferences对象</h3><pre><code class="hljs java">SharedPreferences sharedPreferences= getSharedPreferences(<span class="hljs-string">"test"</span>,Activity.MODE_PRIVATE);</code></pre><p><code>test</code>：表明了生成xml文件名为 test.xml</p><p><code>Activity.MODE_PRIVATE</code>：该参数表明了文件的访问权限以及数据的写入方式。</p><table><thead><tr><th>权限控制格式</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>Activity.MODE_PRIVATE</td><td><strong>代表该文件是私有数据，只能被当前应用访问。</strong><br>写入的内容会覆盖源文件的内容。</td><td>默认操作模式</td></tr><tr><td>Activity.MODE_WORLD_READABLE</td><td>表示当前文件可以被其他应用读取</td><td></td></tr><tr><td>Activity.MODE_WORLE_WRITEABLE</td><td>表示当前文件可以被其他应用写入</td><td></td></tr><tr><td>Activity.MODE_APPEND</td><td>会检查当前是否有文件存在？<br>在在后面追加内容<br>不存在则去创建新文件</td></tr></tbody></table><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>在使用<code>SharedPreferences</code>时，需要获取到SharedPreferences对象。</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> SharedPreferences <span class="hljs-title">getSharedPreferences</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> mode)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;                Build.VERSION_CODES.KITKAT) &#123;            <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) &#123;                name = <span class="hljs-string">"null"</span>;            &#125;        &#125;        File file;       <span class="hljs-comment">//创建SharedPreferences对象时 锁住当前 Context对象</span>        <span class="hljs-keyword">synchronized</span> (ContextImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;            <span class="hljs-keyword">if</span> (mSharedPrefsPaths == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//ArrayMap 类似HashMap的使用方式，适用于少量数据</span>                mSharedPrefsPaths = <span class="hljs-keyword">new</span> ArrayMap&lt;&gt;();            &#125;            file = mSharedPrefsPaths.get(name);            <span class="hljs-keyword">if</span> (file == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//新建xml文件</span>                file = getSharedPreferencesPath(name);                mSharedPrefsPaths.put(name, file);            &#125;        &#125;        <span class="hljs-keyword">return</span> getSharedPreferences(file, mode);    &#125;    <span class="hljs-comment">//放入对应的shared_prefs文件夹</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> File <span class="hljs-title">getSharedPreferencesPath</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> makeFilename(getPreferencesDir(), name + <span class="hljs-string">".xml"</span>);    &#125;<span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SharedPreferences <span class="hljs-title">getSharedPreferences</span><span class="hljs-params">(File file, <span class="hljs-keyword">int</span> mode)</span> </span>&#123;        checkMode(mode);        <span class="hljs-keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.O) &#123;            <span class="hljs-keyword">if</span> (isCredentialProtectedStorage()                    &amp;&amp; !getSystemService(StorageManager<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isUserKeyUnlocked</span>(                            <span class="hljs-title">UserHandle</span>.<span class="hljs-title">myUserId</span>())                    &amp;&amp; !<span class="hljs-title">isBuggy</span>()) </span>&#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"SharedPreferences in credential encrypted "</span>                        + <span class="hljs-string">"storage are not available until after user is unlocked"</span>);            &#125;        &#125;        SharedPreferencesImpl sp;        <span class="hljs-comment">//保证创建 SharedPreferencesImpl 是线程安全的</span>        <span class="hljs-keyword">synchronized</span> (ContextImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;            <span class="hljs-keyword">final</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();            <span class="hljs-comment">//获取缓存文件</span>            sp = cache.get(file);            <span class="hljs-comment">//当前不存在缓存文件 则新建</span>            <span class="hljs-keyword">if</span> (sp == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//构建 SharedPreferencesImpl 对象</span>                sp = <span class="hljs-keyword">new</span> SharedPreferencesImpl(file, mode);                <span class="hljs-comment">//放入缓存中</span>                cache.put(file, sp);                <span class="hljs-keyword">return</span> sp;            &#125;        &#125;        <span class="hljs-keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="hljs-number">0</span> ||            getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;            <span class="hljs-comment">//重新加载 xml文件</span>            sp.startReloadIfChangedUnexpectedly();        &#125;        <span class="hljs-keyword">return</span> sp;    &#125;</code></pre><blockquote><ol><li>根据传入的<code>name</code>在<code>shared_prefs</code>生成对应name的xml文件，并存入<code>mSharedPrefsPaths</code>中以做缓存。</li><li>创建文件完毕后，再去创建对应的<code>SharedPreferencesImpl</code>对象，创建完毕后一存入<code>ArrayMap&lt;File,SharedPreferencesImpl&gt;</code>中作为缓存</li><li>再次调用相同的参数时，由于缓存的存在，不会重新走一遍上述流程，而是从对应缓存中直接取出结果即可。<strong>缓存机制的存在，不会对性能造成过大影响。</strong></li><li>当<code>mode == Context.MODE_MULTI_PROCESS</code>或者 <code>SDK版本小于 2.3</code>会去判断是否有进程对xml文件进行过修改，然后去重新加载xml文件。</li></ol></blockquote><h4 id="SharedPreferencesImpl对象的构建"><a href="#SharedPreferencesImpl对象的构建" class="headerlink" title="SharedPreferencesImpl对象的构建"></a><code>SharedPreferencesImpl</code>对象的构建</h4><blockquote><p>最终得到的<code>SharedPreferences</code>都是由<code>SharedPreferencesImpl</code>创建的。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//基本构造方法    </span>SharedPreferencesImpl(File file, <span class="hljs-keyword">int</span> mode) &#123;        mFile = file;        <span class="hljs-comment">//创建备份文件 当用户写入失败时，会从备份文件中恢复</span>        mBackupFile = makeBackupFile(file);        mMode = mode;        <span class="hljs-comment">//表示数据是否加载完毕</span>        mLoaded = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//存放xml文件数据</span>        mMap = <span class="hljs-keyword">null</span>;        startLoadFromDisk();    &#125;<span class="hljs-comment">//从xml文件读取信息</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startLoadFromDisk</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            mLoaded = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">//开启异步线程读取数据，防止阻塞主线程</span>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"SharedPreferencesImpl-load"</span>) &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                loadFromDisk();            &#125;        &#125;.start();    &#125;    <span class="hljs-comment">//从xml文件读取信息</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadFromDisk</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            <span class="hljs-keyword">if</span> (mLoaded) &#123;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">//回滚源文件</span>            <span class="hljs-keyword">if</span> (mBackupFile.exists()) &#123;                mFile.delete();                mBackupFile.renameTo(mFile);            &#125;        &#125;        <span class="hljs-comment">// Debugging</span>        <span class="hljs-keyword">if</span> (mFile.exists() &amp;&amp; !mFile.canRead()) &#123;            Log.w(TAG, <span class="hljs-string">"Attempt to read preferences file "</span> + mFile + <span class="hljs-string">" without permission"</span>);        &#125;        Map map = <span class="hljs-keyword">null</span>;        StructStat stat = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            stat = Os.stat(mFile.getPath());            <span class="hljs-keyword">if</span> (mFile.canRead()) &#123;                BufferedInputStream str = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">try</span> &#123;                    str = <span class="hljs-keyword">new</span> BufferedInputStream(                            <span class="hljs-keyword">new</span> FileInputStream(mFile), <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>);                    map = XmlUtils.readMapXml(str);                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    Log.w(TAG, <span class="hljs-string">"Cannot read "</span> + mFile.getAbsolutePath(), e);                &#125; <span class="hljs-keyword">finally</span> &#123;                    IoUtils.closeQuietly(str);                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (ErrnoException e) &#123;            <span class="hljs-comment">/* ignore */</span>        &#125;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            <span class="hljs-comment">//加载解析数据成功 设置为true</span>            mLoaded = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;                mMap = map;                mStatTimestamp = stat.st_mtime;                mStatSize = stat.st_size;            &#125; <span class="hljs-keyword">else</span> &#123;                mMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();            &#125;            <span class="hljs-comment">//唤醒等待数据加载完毕的线程</span>            mLock.notifyAll();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> File <span class="hljs-title">makeBackupFile</span><span class="hljs-params">(File prefsFile)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> File(prefsFile.getPath() + <span class="hljs-string">".bak"</span>);    &#125;</code></pre><blockquote><ol><li>加载xml文件是新开启了一个异步线程操作，根据<code>mLoaded</code>判断是否加载完毕</li><li>解析xml文件得到的结果都会放到<code>mMap</code>中，是HashMap类型</li><li>存储文件的修改时间<code>mStatTimestamp</code>以及文件大小<code>mStatSize</code>是为了判断该文件是否被其他进程所修改，若修改则需重载xml文件</li><li>数据加载完毕后，释放锁通知其他线程可以使用<code>SharedPreferences</code>对象</li></ol></blockquote><h3 id="插入数据——putXX"><a href="#插入数据——putXX" class="headerlink" title="插入数据——putXX()"></a>插入数据——<code>putXX()</code></h3><pre><code class="hljs java">SharedPreferences.Editor mEditor = sharedPreferences.edit();<span class="hljs-comment">//插入数据</span>mEditor.putString(<span class="hljs-string">"android"</span>,<span class="hljs-string">"first"</span>);<span class="hljs-comment">//更新数据</span>mEditor.apply();<span class="hljs-comment">//mEditor.commit();</span></code></pre><h4 id="获取Editor对象"><a href="#获取Editor对象" class="headerlink" title="获取Editor对象"></a>获取<code>Editor</code>对象</h4><blockquote><p>写操作都是基于<code>Editor</code>这个对象进行操作的</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Editor</span> </span>&#123;    <span class="hljs-comment">//放入String对象</span>    <span class="hljs-function">Editor <span class="hljs-title">putString</span><span class="hljs-params">(String key, @Nullable String value)</span></span>;    <span class="hljs-comment">//放入int对象</span>    <span class="hljs-function">Editor <span class="hljs-title">putInt</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> value)</span></span>;    ...    <span class="hljs-comment">//提交数据修改</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span></span>;     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">()</span>&#125;</span></code></pre><p><code>Editor</code>是一个接口，具体实现类在于<code>EditorImpl</code>类。</p><h4 id="写入不同类型数据"><a href="#写入不同类型数据" class="headerlink" title="写入不同类型数据"></a>写入不同类型数据</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Editor</span></span>&#123;    <span class="hljs-comment">//临时修改的数据存放于此 等到调用 commit()/apply()时合并数据</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; mModified = Maps.newHashMap();        <span class="hljs-comment">//实现接口中对应方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Editor <span class="hljs-title">putString</span><span class="hljs-params">(String key, @Nullable String value)</span> </span>&#123;            <span class="hljs-keyword">synchronized</span> (mLock) &#123;                <span class="hljs-comment">//放入临时文件中</span>                mModified.put(key, value);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;            &#125;        &#125;&#125;</code></pre><p><code>mModified</code>用于存放用户新增的数据，调用如<code>putString()</code>后，<code>mModified</code>就会记录修改后的数据，等到调用到<code>commit()/apply()</code>才会写入到磁盘中。</p><p><em>所有的putXX()操作都由<code>synchronized</code>修饰，保证线程安全。</em></p><h4 id="提交数据更新"><a href="#提交数据更新" class="headerlink" title="提交数据更新"></a>提交数据更新</h4><p>提交的方法有两种<code>commit()</code>、<code>apply()</code>，需要了解他们之间的区别。</p><h5 id="commit-：同步写入数据"><a href="#commit-：同步写入数据" class="headerlink" title="commit()：同步写入数据"></a>commit()：同步写入数据</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">long</span> startTime = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (DEBUG) &#123;        startTime = System.currentTimeMillis();    &#125;    MemoryCommitResult mcr = commitToMemory();①    SharedPreferencesImpl.<span class="hljs-keyword">this</span>.enqueueDiskWrite( mcr, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* sync write on this thread okay */</span>);②    <span class="hljs-keyword">try</span> &#123;        mcr.writtenToDiskLatch.await();    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (DEBUG) &#123;            Log.d(TAG, mFile.getName() + <span class="hljs-string">":"</span> + mcr.memoryStateGeneration                    + <span class="hljs-string">" committed after "</span> + (System.currentTimeMillis() - startTime)                    + <span class="hljs-string">" ms"</span>);        &#125;    &#125;    notifyListeners(mcr);    <span class="hljs-keyword">return</span> mcr.writeToDiskResult;&#125;</code></pre><p><code>commitToMemory()</code>：将缓存文件写入内存</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> MemoryCommitResult <span class="hljs-title">commitToMemory</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">long</span> memoryStateGeneration;            List&lt;String&gt; keysModified = <span class="hljs-keyword">null</span>;            Set&lt;OnSharedPreferenceChangeListener&gt; listeners = <span class="hljs-keyword">null</span>;            Map&lt;String, Object&gt; mapToWriteToDisk;        <span class="hljs-comment">//保证线程安全</span>    <span class="hljs-keyword">synchronized</span> (SharedPreferencesImpl.<span class="hljs-keyword">this</span>.mLock) &#123;        <span class="hljs-comment">//当前正在写入磁盘</span>        <span class="hljs-keyword">if</span> (mDiskWritesInFlight &gt; <span class="hljs-number">0</span>) &#123;                    mMap = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;(mMap);                &#125;        mapToWriteToDisk = mMap;        mDiskWritesInFlight++;    &#125;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;                    <span class="hljs-keyword">boolean</span> changesMade = <span class="hljs-keyword">false</span>;                    <span class="hljs-comment">//只有调用 clear() mClear为true</span>                    <span class="hljs-keyword">if</span> (mClear) &#123;                        <span class="hljs-keyword">if</span> (!mMap.isEmpty()) &#123;                            changesMade = <span class="hljs-keyword">true</span>;                            mMap.clear();                        &#125;                        mClear = <span class="hljs-keyword">false</span>;                    &#125;                    <span class="hljs-comment">//遍历mModified数据 写入到mMap中</span>                    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;                        String k = e.getKey();                        Object v = e.getValue();                        <span class="hljs-keyword">if</span> (v == <span class="hljs-keyword">this</span> || v == <span class="hljs-keyword">null</span>) &#123;                            <span class="hljs-comment">//更新数据</span>                            <span class="hljs-keyword">if</span> (!mMap.containsKey(k)) &#123;                                <span class="hljs-keyword">continue</span>;                            &#125;                            mMap.remove(k);                        &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (mMap.containsKey(k)) &#123;                                Object existingValue = mMap.get(k);                                <span class="hljs-keyword">if</span> (existingValue != <span class="hljs-keyword">null</span> &amp;&amp; existingValue.equals(v)) &#123;                                    <span class="hljs-keyword">continue</span>;                                &#125;                            &#125;                            <span class="hljs-comment">//写入数据</span>                            mMap.put(k, v);                        &#125;                        changesMade = <span class="hljs-keyword">true</span>;                        <span class="hljs-keyword">if</span> (hasListeners) &#123;                            keysModified.add(k);                        &#125;                    &#125;                    mModified.clear();                    <span class="hljs-keyword">if</span> (changesMade) &#123;                        mCurrentMemoryStateGeneration++;                    &#125;                    memoryStateGeneration = mCurrentMemoryStateGeneration;                &#125;&#125;</code></pre><p>将<code>mModified</code>数据写入到<code>mMap</code>中，然后清空<code>mModified</code>数据，免得下次使用出现重复数据。最后得到一个<code>MemoryCommitResult</code>对象。</p><blockquote><p>调用<code>clear()</code>方法只是清理了<code>mMap</code>里的数据，不影响<code>mModified</code>中的数据。</p></blockquote><p><code>enqueueDiskWrite()</code>：将数据写入到磁盘**.xml文件中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueueDiskWrite</span><span class="hljs-params">(<span class="hljs-keyword">final</span> MemoryCommitResult mcr,                                  <span class="hljs-keyword">final</span> Runnable postWriteRunnable)</span> </span>&#123;        <span class="hljs-comment">//对于commit()而言 isFromSyncCommit = true</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="hljs-keyword">null</span>);        <span class="hljs-comment">//负责将数据写入硬盘的xml文件中</span>        <span class="hljs-keyword">final</span> Runnable writeToDiskRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">synchronized</span> (mWritingToDiskLock) &#123;                        <span class="hljs-comment">/*                        *  写入数据到磁盘中                        *  把已存在的文件进行重命名 添加.bak后缀，作为备份文件存在。删除源文件                        *  新建 源文件，重新写入所有数据，同时记录写入时间                        *  如果写入文件失败，删除新建的文件，并返回失败                        *  如果写入文件成功，删除备份文件，返回成功                        */</span>                        writeToFile(mcr, isFromSyncCommit);                    &#125;                    <span class="hljs-keyword">synchronized</span> (mLock) &#123;                        mDiskWritesInFlight--;                    &#125;                    <span class="hljs-keyword">if</span> (postWriteRunnable != <span class="hljs-keyword">null</span>) &#123;                        postWriteRunnable.run();                    &#125;                &#125;            &#125;;        <span class="hljs-comment">//commit()执行方法</span>        <span class="hljs-keyword">if</span> (isFromSyncCommit) &#123;            <span class="hljs-keyword">boolean</span> wasEmpty = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">synchronized</span> (mLock) &#123;                <span class="hljs-comment">//当前如果只有一个写入硬盘的需求</span>                wasEmpty = mDiskWritesInFlight == <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">if</span> (wasEmpty) &#123;                <span class="hljs-comment">//直接在当前线程开始写入磁盘操作</span>                writeToDiskRunnable.run();                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-comment">//开启线程池执行写入任务</span>        QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);    &#125;</code></pre><p><code>commit()</code>先后调用了<code>commitToMemory()/*写入数据到mMap中，等待写入磁盘*/</code>、<code>enqueueDiskWrite()/*将数据写入到磁盘中*/</code>，通过<code>writeToFile()</code>写入到磁盘中并会返回对应写入结果。</p><p><strong><code>commit()</code>执行都是同步的，而且每次都是写入全量的数据，会导致主线程阻塞。</strong></p><h5 id="apply-：异步写入数据"><a href="#apply-：异步写入数据" class="headerlink" title="apply()：异步写入数据"></a>apply()：异步写入数据</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();    <span class="hljs-comment">//将数据写入到内存中</span>    <span class="hljs-keyword">final</span> MemoryCommitResult mcr = commitToMemory();    <span class="hljs-keyword">final</span> Runnable awaitCommit = <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    mcr.writtenToDiskLatch.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;                &#125;                <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; mcr.wasWritten) &#123;                    Log.d(TAG, mFile.getName() + <span class="hljs-string">":"</span> + mcr.memoryStateGeneration                            + <span class="hljs-string">" applied after "</span> + (System.currentTimeMillis() - startTime)                            + <span class="hljs-string">" ms"</span>);                &#125;            &#125;        &#125;;    QueuedWork.addFinisher(awaitCommit);    Runnable postWriteRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                awaitCommit.run();                QueuedWork.removeFinisher(awaitCommit);            &#125;        &#125;;    <span class="hljs-comment">//开启一个异步线程去执行写入任务</span>    SharedPreferencesImpl.<span class="hljs-keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);    <span class="hljs-comment">//通知数据写入完成</span>    notifyListeners(mcr);&#125;</code></pre><p><code>apply()</code>也先调用<code>commitToMemory()</code>将更改提交到内存，之后调用<code>enqueueDiskWriter()</code>开启写入磁盘任务。</p><p>根据上节观察<code>commit()</code>如果当前没有线程在写入文件时，就会直接在当前线程开启写入磁盘任务，导致主线程阻塞(<em>可能发生ANR</em>)，等待线程执行完毕。</p><p><code>apply()</code>是提交任务到线程池后，就直接通知写入成功，不需要等待线程执行完成。</p><blockquote><p><code>apply()</code>也不是绝对安全的，可能在某些情况下也会导致ANR情况发生。</p><p>例如频繁调用<code>apply()</code>也会导致线程堆积，消耗大量资源。</p></blockquote><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><pre><code class="hljs java">sharedPreferences.getString(<span class="hljs-string">"android"</span>,<span class="hljs-string">""</span>);</code></pre><pre><code class="hljs java"> <span class="hljs-meta">@Nullable</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getString</span><span class="hljs-params">(String key, @Nullable String defValue)</span> </span>&#123;         <span class="hljs-keyword">synchronized</span> (mLock) &#123;         <span class="hljs-comment">//等待数据加载完毕才可以读取数据</span>         awaitLoadedLocked();         <span class="hljs-comment">//从mMap中读取对应key数据</span>         String v = (String)mMap.get(key);         <span class="hljs-comment">//为空则返回 默认值</span>         <span class="hljs-keyword">return</span> v != <span class="hljs-keyword">null</span> ? v : defValue;     &#125; &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">awaitLoadedLocked</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">if</span> (!mLoaded) &#123;         <span class="hljs-comment">// Raise an explicit StrictMode onReadFromDisk for this</span>         <span class="hljs-comment">// thread, since the real read will be in a different</span>         <span class="hljs-comment">// thread and otherwise ignored by StrictMode.</span>         BlockGuard.getThreadPolicy().onReadFromDisk();     &#125;     <span class="hljs-comment">//mLoaded 表示数据是否加载完毕</span>     <span class="hljs-keyword">while</span> (!mLoaded) &#123;         <span class="hljs-keyword">try</span> &#123;             mLock.wait();         &#125; <span class="hljs-keyword">catch</span> (InterruptedException unused) &#123;         &#125;     &#125; &#125;</code></pre><blockquote><p><code>getXX()</code>是线程安全的，内部使用了<code>synchronized</code>进行保证</p><p><code>getXX()</code>是直接去读取<code>mMap</code>，所以<code>apply()</code>写入内存之后就可以直接获取到对应数据</p><p><code>getXX()</code>可能由于<code>awaitLoadedLocked()</code>发生阻塞，需要等到<code>loadFromDisk()</code>执行完毕置<code>mLoaded = true</code>时，调用<code>notifyAll()</code>解除阻塞。</p></blockquote><h2 id="SharedPreferences注意事项"><a href="#SharedPreferences注意事项" class="headerlink" title="SharedPreferences注意事项"></a>SharedPreferences注意事项</h2><p>根据上述源码分析，在使用<code>SharedPreferences</code>时需要注意以下几项来提高使用效率：</p><ul><li><code>SharedPreferences</code>中的文件读取都是一次性加载入内存的，最好不要写入大量的数据以及可以多建几个文件按需加载，减少内存压力以及提高响应时间。</li><li><code>SharedPreferences</code>的数据写入是全量写入的，每次写入都需要删除原文件后新建文件写入，所以不要频繁调用<code>commit()/apply()</code>，最好是批量写入。</li><li>需要读取<code>SharedPreferences</code>的数据时，需要等待数据加载完毕才可以使用，造成等待，可以提前去加载<code>SharedPreferences</code>对象，减少后续操作等待时间。</li><li><code>commit()</code>是同步执行写入任务的，如果当前只有一个<code>SharedPreferences</code>需要操作，就会在主线程执行写入磁盘操作，导致阻塞；<code>apply()</code>是异步执行写入任务，等待写入内存操作完成(<em>赋值mMap</em>)就直接返回结果。</li><li><code>MODE_MULTI_PROCESS</code>是在每次<code>getSharedPreferences</code>时检查磁盘上配置文件上次修改时间和文件大小，一旦所有修改则会重新从磁盘加载文件，所以并不能保证多进程数据的实时同步。</li></ul><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5c361469f265da61776c29d0" target="_blank" rel="noopener">Android SharedPreferences最佳实践</a></p><p><a href="https://juejin.im/post/5c34615bf265da614171bf8a#heading-3" target="_blank" rel="noopener">一眼看穿 SharedPreferences</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式--装饰模式</title>
    <link href="/2019/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更加灵活。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/装饰模式UML.png" srcset="/img/loading.gif" class="full-image" alt="装饰模式UML" title="装饰模式UML"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="装饰模式-组成"><a href="#装饰模式-组成" class="headerlink" title="装饰模式-组成"></a>装饰模式-组成</h3><p><code>Component抽象构件</code></p><blockquote><p>component是一个接口或者抽象类，定义了我们最核心的对象，也就是最原始的对象。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span></span>&#123;  <span class="hljs-comment">//抽象方法</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operate</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><code>ConcreteComponent具体构件</code></p><blockquote><p><code>ConcreteComponent</code>是最核心、最初始，最基本的接口或者抽象类的实现，需要装饰的就是这个对象。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operate</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-comment">// do somethins</span>  &#125;&#125;</code></pre><p><code>Decorator装饰角色</code></p><blockquote><p>一般为一个抽象类，<code>用于实现一个接口或者抽象方法</code>。在它的属性里面必然有一个<code>private</code>变量指向<code>Component</code>。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;  <span class="hljs-keyword">private</span> Component component = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//构造带有修饰者的函数</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Decorator</span><span class="hljs-params">(Component _component)</span></span>&#123;    <span class="hljs-keyword">this</span>.component= _component;  &#125;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operate</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">this</span>.component.operate();  &#125;&#125;</code></pre><p><code>ConcreteDecorator具体装饰角色</code></p><blockquote><p>具体的装饰类。需要把核心的东西装饰成其他东西。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteDecorator</span> <span class="hljs-params">(Component _component)</span></span>&#123;    <span class="hljs-keyword">super</span>(_component);  &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 为Component拓展方法</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operate</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">this</span>.method();    <span class="hljs-keyword">super</span>.operate();  &#125;&#125;</code></pre><p>实际调用场景</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    Component component = <span class="hljs-keyword">new</span> ConcreteComponent();    <span class="hljs-comment">//进行装饰</span>    component = <span class="hljs-keyword">new</span> ConcreteDecorator(component);    <span class="hljs-comment">//调用修饰后对象方法</span>    component.operate();  &#125;&#125;</code></pre><h3 id="装饰模式-优点"><a href="#装饰模式-优点" class="headerlink" title="装饰模式-优点"></a>装饰模式-优点</h3><ul><li>装饰类和被被装饰类可以独立发展，而不会相互耦合。</li><li>装饰模式是继承关系的一个替代方案。实现<code>is-a关系(类的父子继承关系)</code></li><li>装饰模式可以动态地拓展一个实现类的功能。<strong>符合 开闭原则。</strong></li></ul><h3 id="装饰模式-缺点"><a href="#装饰模式-缺点" class="headerlink" title="装饰模式-缺点"></a>装饰模式-缺点</h3><p><strong>多层的装饰是比较复杂的。</strong>需要减少装饰类的数量，以便降低系统的复杂度。</p><h3 id="装饰模式-使用场景"><a href="#装饰模式-使用场景" class="headerlink" title="装饰模式-使用场景"></a>装饰模式-使用场景</h3><ul><li>需要扩展一个类的功能，或者给一个类增加附加功能</li><li>需要动态地给一个对象增加功能，这些功能也可以动态的进行撤销</li><li>需要为一批兄弟类进行改装或加装功能</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式--责任链模式</title>
    <link href="/2019/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链路传递，直到有对象处理请求为止。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/责任链模式UML.png" srcset="/img/loading.gif" class="full-image" alt="责任链模式UML" title="责任链模式UML"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="责任链模式-定义"><a href="#责任链模式-定义" class="headerlink" title="责任链模式-定义"></a>责任链模式-定义</h3><p><code>Handler</code>：<em>抽象处理者</em> 该角色对请求进行抽象，并定义一个方法来设定和返回对下一个处理者的引用。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span></span>&#123;  <span class="hljs-keyword">private</span> Handler nextHandler;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Handler <span class="hljs-title">getNextHandler</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nextHandler;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">seNextHandler</span><span class="hljs-params">(Handler _handler)</span></span>&#123;    <span class="hljs-keyword">this</span>.nextHandler= _nextHandler;  &#125;&#125;</code></pre><p>抽象处理者实现两个职责：</p><ul><li>定义一个请求的处理方法<code>handleRequest()</code></li><li>定义一个责任链的编排方法<code>setNextHandler()</code>，设置下一个处理者</li></ul><p><code>ConcreteHandler</code>：*具体处理器者 该角色接到请求后，可以选择将请求处理掉，或者将请求传给下一个处理者。<code>由于具体矗立着持有对下一个处理者的引用，因此，如果需要，处理者可以访问下一个访问者</code>。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span></span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-keyword">this</span>.toString()+<span class="hljs-string">"处理器已处理"</span>);    <span class="hljs-keyword">if</span>(getNextHandler()!=<span class="hljs-keyword">null</span>)&#123;      <span class="hljs-comment">//转移到下一个处理器处理</span>      getNextHandler().handleRequest();    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">//如果没有下一个则本身处理请求</span>      ...    &#125;  &#125;&#125;</code></pre><p>具体处理者负责处理请求<code>handleRequest()</code>如果存在下一节点可以向下传递。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    Handler h1 = <span class="hljs-keyword">new</span> ConcreteHandler();    Handler h2 = <span class="hljs-keyword">new</span> ConcreteHandler();    h1.setNextHandler(h2);    h1.handleRequest();  &#125;&#125;</code></pre><h3 id="责任链模式-优点"><a href="#责任链模式-优点" class="headerlink" title="责任链模式-优点"></a>责任链模式-优点</h3><ul><li>责任链模式将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌。<strong>提高系统灵活性。</strong></li></ul><h3 id="责任链模式-缺点"><a href="#责任链模式-缺点" class="headerlink" title="责任链模式-缺点"></a>责任链模式-缺点</h3><ul><li><strong>性能降低。</strong>每个请求都是从链头遍历到链尾，特别是在链比较长的时候。</li><li><strong>不易于调试。</strong>链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试时会比较复杂。</li></ul><h3 id="责任链模式-使用注意事项"><a href="#责任链模式-使用注意事项" class="headerlink" title="责任链模式-使用注意事项"></a>责任链模式-使用注意事项</h3><p><strong>链中节点数量需要控制，避免超长链的情况。</strong></p><p>一般做法是在<code>Handler(抽象处理者)</code>中设置一个最大节点数量，在<code>setNextHandler()</code>中判断是否已经超过最大值，超过则拒绝建立链，避免过量节点。</p><h3 id="责任链模式-应用场景"><a href="#责任链模式-应用场景" class="headerlink" title="责任链模式-应用场景"></a>责任链模式-应用场景</h3><ul><li>一个请求需要一系列的处理工作。</li><li>业务流的处理，例如文件审批。</li><li>对系统进行拓展扩充。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava 使用及解析</title>
    <link href="/2019/01/10/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <url>/2019/01/10/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<!--dispose做了啥 flatMap和Map有什么区别 如何进行线程切换--><h2 id="RxJava基本知识"><a href="#RxJava基本知识" class="headerlink" title="RxJava基本知识"></a>RxJava基本知识</h2><blockquote><p>RxJava是一个在JVM上使用可观测的序列来组成异步的、基于事件的程序的库。</p></blockquote><p>通常情况下使用<code>Handler、AsyncTask</code>完成异步任务操作，当任务比较多的时候，使用这种方式就会变得相当繁琐，尤其是嵌套式的执行任务(需要上一项先完成)。</p><p>RxJava可以实现异步任务执行的前提下保持代码的清晰。通过创建一个<code>Observable</code>来完成异步任务，然后组合各种操作符实现不同的链式操作，最终将任务直执行结果发射到<code>Observer</code>进行处理。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RxJava基础流程图.png" srcset="/img/loading.gif" class="full-image" alt="RxJava基础流程图" title="RxJava基础流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><pre><code class="hljs java"> Observable&lt;Integer&gt; observable = Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                emitter.onNext(<span class="hljs-number">1</span>);                emitter.onNext(<span class="hljs-number">2</span>);                emitter.onComplete();            &#125;        &#125;);        observable.subscribe(<span class="hljs-keyword">new</span> Observer&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable d)</span> </span>&#123;                System.err.println(<span class="hljs-string">"onSubscribe"</span>);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Integer integer)</span> </span>&#123;                System.out.println(<span class="hljs-string">"onNext()"</span>+integer);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;                System.err.println(<span class="hljs-string">"onError"</span>);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;                System.err.println(<span class="hljs-string">"onComplete"</span>);            &#125;        &#125;);输出结果：onSubscribeonNext1onNext2onComplete</code></pre><p><code>Observable</code>发射出一个事件，通过<code>subscribe()</code>建立与<code>Observer</code>的关联，然后回调到具体事件内(<code>onNext()、onError()、onComplete()</code>)。</p><p>除了<code>Observable</code>外，还提供了适用其他场景的基础类：</p><ul><li><p><code>Flowable</code>：多个流，响应式流和背压</p></li><li><p><code>Single</code>：只能发射一条单一的数据，或者一条异常通知，无法发射完成通知。<em>数据与通知只能发射一个。</em></p><pre><code class="hljs java">Single&lt;Integer&gt; single = Single.create(<span class="hljs-keyword">new</span> SingleOnSubscribe&lt;Integer&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(SingleEmitter&lt;Integer&gt; singleEmitter)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">//发射数据</span>            singleEmitter.onSuccess(<span class="hljs-number">111</span>);            <span class="hljs-comment">//发射异常通知</span>            singleEmitter.onError(<span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"qwe"</span>));        &#125;    &#125;);    single.subscribe(<span class="hljs-keyword">new</span> SingleObserver&lt;Integer&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable disposable)</span> </span>&#123;          &#125;          <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(Integer integer)</span> </span>&#123;          &#125;          <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;          &#125;    &#125;);</code></pre></li></ul><ul><li><p><code>Completeable</code>：只发射一条完成通知，或者一条异常通知，不能发射数据。<em>完成通知与异常通知只能发射一个。</em></p><pre><code class="hljs java">Completable completable = Completable.create(<span class="hljs-keyword">new</span> CompletableOnSubscribe() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(CompletableEmitter completableEmitter)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-comment">//发射完成通知</span>            completableEmitter.onComplete();            <span class="hljs-comment">//发射错误通知</span>            completableEmitter.onError(<span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"qwe"</span>));        &#125;    &#125;);    completable.subscribe(<span class="hljs-keyword">new</span> CompletableObserver() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable disposable)</span> </span>&#123;                    &#125;          <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;          &#125;          <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;          &#125;    &#125;);</code></pre></li></ul><ul><li><p><code>Maybe</code>：可发射一条单一的数据，以及一条完成通知，或者一条异常通知.<em>完成通知和异常通知只能发射一个，且发射数据必须在发射通知之前。</em></p><pre><code class="hljs undefined">Maybe&lt;Integer&gt; maybe = Maybe.create(new MaybeOnSubscribe&lt;Integer&gt;() &#123;    @Override    public void subscribe(MaybeEmitter&lt;Integer&gt; maybeEmitter) throws Exception &#123;        //发射数据        maybeEmitter.onSuccess(11);        //发射完成通知        maybeEmitter.onComplete();        //发射错误通知        maybeEmitter.onError(new IllegalArgumentException(&quot;qwe&quot;));    &#125;&#125;);maybe.subscribe(new MaybeObserver&lt;Integer&gt;() &#123;    @Override    public void onSubscribe(Disposable disposable) &#123;            &#125;    @Override    public void onSuccess(Integer integer) &#123;    &#125;    @Override    public void onError(Throwable throwable) &#123;    &#125;    @Override    public void onComplete() &#123;    &#125;&#125;);</code></pre></li></ul><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p><code>Observable</code>是通过<code>ObservableEmitter</code>来发射事件的，可以发出的事件类型有三种：<code>onNext()、onError()，onComplete()</code>。</p><h4 id="onNext"><a href="#onNext" class="headerlink" title="onNext()"></a>onNext()</h4><blockquote><p>对应<code>Observer.onNext()</code>，用于发射数据</p></blockquote><h4 id="onComplete"><a href="#onComplete" class="headerlink" title="onComplete()"></a>onComplete()</h4><blockquote><p>对应<code>Observer.onComplete()</code>，用于发射完成通知</p></blockquote><h4 id="onError"><a href="#onError" class="headerlink" title="onError()"></a>onError()</h4><blockquote><p>对应<code>Observer.onError()</code>，用于发射异常通知</p></blockquote><p>他们三者之间满足一定的规则：</p><ul><li><code>ObservableEmitter</code>可以发射无数的<code>onNext()</code>事件，<code>Observer</code>也可以处理无数<code>onNext()</code>事件</li><li>当<code>ObservableEmitter</code>发射出<code>onComplete()</code>事件，<code>Observer</code>接收到这个事件后，<strong>不会再继续接收后续事件</strong>。</li><li>当<code>ObservableEmitter</code>发射出<code>onError()</code>事件，<code>Observer</code>接收到这个事件后，<strong>不会再继续接收后续事件</strong>。</li><li><code>onComplete()</code>与<code>onError()</code>是<strong>唯一且互斥</strong>的。不能发射分多个<code>onComplete()</code>或<code>onError()</code>，也不能发射<code>onComplete()</code>后再跟上<code>onError()</code>。</li></ul><h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>通过<code>Disposable</code>实现，在<code>Observer</code>的<code>onSubsccribe()</code>中返回对象，他有两个方法<code>isDisposed()</code>——判断是否停止了观察指定的流，<code>dispose()</code>——放弃观察指定的流。</p><p>执行<code>Disposeable.dispose()</code>后，并不会影响<code>ObservableEmitter</code>继续发送事件，但是<code>Observer</code>中不会继续接收事件，相当于切断了两者的联系。</p><h2 id="RxJava操作符"><a href="#RxJava操作符" class="headerlink" title="RxJava操作符"></a>RxJava操作符</h2><p>如上节示例所示，通过<code>Observable.create()</code>就可以创建出一个<code>Observable</code>对象，除了<code>create</code>外，还有其他的操作符方便我们完成链式操作，下面详解介绍这些操作符。</p><h3 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h3><blockquote><p>用于创建Observable对象，并填充数据</p></blockquote><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><blockquote><p>用于从头到尾创建一个Observable对象，发射器内部会调用<code>onNext()、onComplete()，onError()</code>方法</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(ObservableOnSubscribe&lt;T&gt; source)</span>    Observable&lt;Integer&gt; observable </span>= Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;              emitter.onNext(<span class="hljs-number">1</span>);              emitter.onNext(<span class="hljs-number">2</span>);              emitter.onComplete();          &#125;      &#125;);</code></pre><p><em>不推荐使用，使用较为繁琐且不方便操作。</em></p><h4 id="from系列"><a href="#from系列" class="headerlink" title="from系列"></a>from系列</h4><blockquote><p>从指定的数据源中获取一个Observable对象</p></blockquote><ul><li><code>fromArray(T... items)</code>：从数组中获取</li><li><code>fromCallable(Callable&lt;? extends T&gt; supplier)</code>：从Callable对象中获取</li><li><code>fromFuture(Future&lt;? extends T&gt; future)</code>：从Future对象中获取</li><li><code>fromIterable(Iterable&lt;? extends T&gt; source)</code>：从Iterable中获取</li><li><code>formPublisher(Publisher&lt;? extends T&gt; publisher)</code>：从Publisher中获取</li></ul><pre><code class="hljs java">Observable&lt;Integer&gt; observable = Observable.fromArray(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);</code></pre><h4 id="just"><a href="#just" class="headerlink" title="just"></a>just</h4><blockquote><p>支持发送不同格式的参数，个数从1~10个</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">just</span><span class="hljs-params">(T item)</span>  Observable&lt;Integer&gt; observable </span>= Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);</code></pre><h4 id="interval-amp-intervalRange"><a href="#interval-amp-intervalRange" class="headerlink" title="interval&amp;intervalRange"></a>interval&amp;intervalRange</h4><blockquote><p>每隔指定时间就发射一个Observable对象</p></blockquote><p><code>interval</code></p><pre><code class="hljs java"><span class="hljs-comment">/*** initialDelay 发射第一个对象之前的停顿时间* period 表示每个发射之间停顿多少时间* unit 时间单位* scheduler 指定数据发射的线程*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">interval</span><span class="hljs-params">(<span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> period, TimeUnit unit, Scheduler scheduler)</span>其他重载方法：<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">interval</span><span class="hljs-params">(<span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> period, TimeUnit unit)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">interval</span><span class="hljs-params">(<span class="hljs-keyword">long</span> period, TimeUnit unit)</span>     Observable observable </span>= Observable.interval(<span class="hljs-number">1</span>, TimeUnit.SECONDS);</code></pre><p><code>intervalRange</code>：控制发射的序列在一个范围之内，发射最后一位时停止</p><pre><code class="hljs java"><span class="hljs-comment">/*** start 发射数据的起始值* count 需要发射的总个数，且为递增*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">intervalRange</span><span class="hljs-params">(<span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> count, <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> period, TimeUnit unit, Scheduler scheduler)</span>  Observable&lt;Long&gt; observable </span>=Observable.intervalRange(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, TimeUnit.SECONDS, Schedulers.trampoline());</code></pre><h4 id="range-amp-rangeLong"><a href="#range-amp-rangeLong" class="headerlink" title="range&amp;rangeLong"></a>range&amp;rangeLong</h4><blockquote><p>发射指定范围内的连续整数的Observable对象</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/*** start 指定生成序列的开始值* count 指定生成序列包含的个数*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Integer&gt; <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count)</span>Observable&lt;Integer&gt; observable </span>= Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">rangeLong</span><span class="hljs-params">(<span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> count)</span> Observable&lt;Long&gt; observable </span>= Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);</code></pre><p><code>range</code>与<code>rangeLong</code>的区别在于：前者返回int，后者返回long</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><blockquote><p>直到有观察者订阅是才创建的<code>Observable</code>对象，并未每一个订阅者都创建一个新的<code>Observable</code>对象。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">defer</span><span class="hljs-params">(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)</span>   Observable&lt;Long&gt; deferObservable </span>= Observable.defer(() -&gt; Observable.just(<span class="hljs-number">11L</span>));</code></pre><p><strong>可以使用<code>defer</code>封装需要被多次执行的函数</strong></p><h4 id="empty-amp-never-amp-error"><a href="#empty-amp-never-amp-error" class="headerlink" title="empty &amp; never &amp; error"></a>empty &amp; never &amp; error</h4><p><code>empty</code>：创建一个不发射任何数据但是能正常终止的<code>Observable</code>对象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">empty</span><span class="hljs-params">()</span>  Observable&lt;Integer&gt; observable </span>= Observable.empty();</code></pre><p><code>error</code>：创建一个不发射任何数据但是能发出错误的<code>Observable</code>对象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">error</span><span class="hljs-params">(Callable&lt;? extends Throwable&gt; errorSupplier)</span>  Observable&lt;Integer&gt; observable </span>= Observable.error(<span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"qwe"</span>));</code></pre><p><code>never</code>：创建一个不发射任何数据也不能终止的<code>Observable</code>对象</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">never</span><span class="hljs-params">()</span>  Observable&lt;Integer&gt; observable </span>= Observable.never()</code></pre><h4 id="repeat-amp-repeatWhen"><a href="#repeat-amp-repeatWhen" class="headerlink" title="repeat&amp;repeatWhen"></a>repeat&amp;repeatWhen</h4><blockquote><p>并不是创建一个<code>Observable</code>对象，而是重复发射原始的<code>Observable</code>数据序列，可能是无限的，如果设置<code>repeat(n)</code>可以限制重复次数</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//不限次数 </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">repeat</span><span class="hljs-params">()</span><span class="hljs-comment">//限制发射 times 次   </span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">repeat</span><span class="hljs-params">(<span class="hljs-keyword">long</span> times)</span>  Observable&lt;Integer&gt; observable </span>= Observable.just(<span class="hljs-number">1</span>).repeat(<span class="hljs-number">3</span>);</code></pre><p><code>repeatWhen</code>：重复执行同一操作</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">repeatWhen</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Function&lt;? <span class="hljs-keyword">super</span> Observable&lt;Object&gt;, ? extends ObservableSource&lt;?&gt;&gt; handler)</span>Observable&lt;Long&gt; observable </span>= Observable.just(<span class="hljs-number">1L</span>).repeatWhen(objectObservable -&gt; Observable.just(<span class="hljs-number">1</span>).repeat(<span class="hljs-number">3</span>));</code></pre><h4 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h4><blockquote><p>创建一个在制定延迟时间后发射一条数据的<code>Observable</code>对象</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/*** delay 设置延时时长*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Observable&lt;Long&gt; <span class="hljs-title">timer</span><span class="hljs-params">(<span class="hljs-keyword">long</span> delay, TimeUnit unit)</span>   Observable&lt;Long&gt; observable </span>= Observable.timer(<span class="hljs-number">3</span>,TimeUnit.SECOND);</code></pre><h3 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><blockquote><p>将发射的原始<code>Observable</code>对象转成一个新的<code>Observable</code>对象。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/*** 泛型T 指代原始数据类型* 泛型R 指代要转换的数据类型*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; <span class="hljs-function">Observable&lt;R&gt; <span class="hljs-title">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends R&gt; mapper)</span> Observable&lt;String&gt; observable </span>= Observable.just(<span class="hljs-number">1L</span>)<span class="hljs-comment">/*这时发射出的是Long型*/</span>.map(aLong -&gt; aLong.toString()<span class="hljs-comment">/*转化为String型*/</span>);</code></pre><p><em>在定义的<code>Function()</code>中进行数据类型转换</em></p><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><blockquote><p>将一个发送事件的原始<code>Observable</code>变换为多个发送事件的<code>Observables</code>，然后把这些合并到一个单独的<code>Observable</code>里。<strong><code>flatMap</code>并不保证事件的顺序，实现的是一对多的转化</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; <span class="hljs-function">Observable&lt;R&gt; <span class="hljs-title">flatMap</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)</span> Observable&lt;String&gt; observable </span>= Observable.just(<span class="hljs-number">1L</span>,<span class="hljs-number">2L</span>,<span class="hljs-number">3L</span>,<span class="hljs-number">4L</span>,<span class="hljs-number">5L</span>)              .flatMap((Function&lt;Long, ObservableSource&lt;String&gt;&gt;) aLong -&gt;                       Observable.just(<span class="hljs-string">"flatMap"</span>+aLong.toString()));</code></pre><h4 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap"></a>concatMap</h4><blockquote><p>将一个发送事件的原始<code>Observable</code>变换为多个发送事件的<code>Observables</code>，然后把这些合并到一个单独的<code>Observable</code>里。<strong>concatMap可以保证事件的顺序，实现的是一对多的转化</strong></p></blockquote><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; <span class="hljs-function">Observable&lt;R&gt; <span class="hljs-title">concatMap</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, <span class="hljs-keyword">int</span> prefetch)</span>   Observable&lt;String&gt; observable </span>= Observable.just(<span class="hljs-number">1L</span>,<span class="hljs-number">2L</span>,<span class="hljs-number">3L</span>,<span class="hljs-number">4L</span>,<span class="hljs-number">5L</span>)              .concatMap((Function&lt;Long, ObservableSource&lt;String&gt;&gt;) aLong -&gt;                       Observable.just(<span class="hljs-string">"flatMap"</span>+aLong.toString()));</code></pre><p>在使用<code>concatMap</code>的时候，内部会新建一个队列对象，会把先发射的数据放入队列中，内部是利用了<code>AtomicInteger</code>实现自增，然后输出数据的时候就可以按照顺序。</p><h4 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h4><blockquote><p>将原始的<code>Observable</code>对象中的所有数据都强制转换为一个指定的类型(<strong>多态，只能由父类对象转为子类对象</strong>)，然后发射数据</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;U&gt; <span class="hljs-function">Observable&lt;U&gt; <span class="hljs-title">cast</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;U&gt; clazz)</span>   Observable&lt;String&gt; observable </span>= Observable.just(<span class="hljs-number">1L</span>).cast(String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">//这样子的转换方式就会抛出异常</span></code></pre><h4 id="flatMapIterable"><a href="#flatMapIterable" class="headerlink" title="flatMapIterable"></a>flatMapIterable</h4><blockquote><p>将原始的任意一个元素转换成一个<code>Iterable</code>对象，直接在内部以<code>Iterable</code>接口接收数据。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;U&gt; <span class="hljs-function">Observable&lt;U&gt; <span class="hljs-title">flatMapIterable</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Function&lt;? <span class="hljs-keyword">super</span> T, ? extends Iterable&lt;? extends U&gt;&gt; mapper)</span>Observable&lt;String&gt; observable </span>= Observable.just(<span class="hljs-number">1L</span>,<span class="hljs-number">2L</span>,<span class="hljs-number">3L</span>,<span class="hljs-number">4L</span>,<span class="hljs-number">5L</span>)          .flatMapIterable(<span class="hljs-keyword">new</span> Function&lt;Long, Iterable&lt;? extends String&gt;&gt;() &#123;              <span class="hljs-meta">@Override</span>              <span class="hljs-keyword">public</span> Iterable&lt;? extends String&gt; apply(Long aLong) <span class="hljs-keyword">throws</span> Exception &#123;                  ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                  list.add(aLong.toString());                  <span class="hljs-keyword">return</span> list;              &#125;          &#125;);</code></pre><h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><blockquote><p> 对整个流进行分组，将原先的<code>Observable</code>对象转换为一个新的<code>Observable</code>对象，每次发生一组值，而不是原先的一个个发送。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/*** count 成组的个数* skip 隔几个输出一次 比如 1，2，3 设置skip=1,count=3 输出则为 [1,2,3],[2,3],[3]*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;List&lt;T&gt;&gt; buffer(<span class="hljs-keyword">int</span> count, <span class="hljs-keyword">int</span> skip)<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;List&lt;T&gt;&gt; buffer(<span class="hljs-keyword">int</span> count)<span class="hljs-comment">//skip = count</span>  Observable&lt;String&gt; observable = Observable.range(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>)                .buffer(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)                .map(<span class="hljs-keyword">new</span> Function&lt;List&lt;Integer&gt;, String&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(List&lt;Integer&gt; lists)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-keyword">return</span> lists.toString();                    &#125;                &#125;);</code></pre><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><blockquote><p>与<code>buffer</code>功能类似，但它发射出的是<code>Observable</code>，这些<code>Observable</code>在单独发射数据，都发送完毕后，发出<code>onComplete()</code>通知。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;Observable&lt;T&gt;&gt; window(<span class="hljs-keyword">long</span> count)  Observable.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).window(<span class="hljs-number">3</span>).subscribe(        observable -&gt; observable.subscribe(integer -&gt; System.out.println(observable.hashCode() + <span class="hljs-string">" : "</span> + integer)));</code></pre><h3 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><blockquote><p>根据指定规则对发送数据进行过滤</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span> Observable.<span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)</span>.<span class="hljs-title">filter</span><span class="hljs-params">(new Predicate&lt;Integer&gt;()</span> </span>&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Integer integer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-comment">//只输出大于5的值</span>                <span class="hljs-keyword">return</span> integer&gt;<span class="hljs-number">5</span>;            &#125;        &#125;)</code></pre><h4 id="elementAt-amp-firstElement-amp-lastElement"><a href="#elementAt-amp-firstElement-amp-lastElement" class="headerlink" title="elementAt&amp;firstElement&amp;lastElement"></a>elementAt&amp;firstElement&amp;lastElement</h4><blockquote><p><code>elementAt</code>：用于获取数据源中的指定位置的数据</p><p><code>firstElement</code>：用于获取数据源中的第一个元素</p><p><code>lastElement</code>：用于获取数据源中的最后一个元素</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Maybe&lt;T&gt; <span class="hljs-title">elementAt</span><span class="hljs-params">(<span class="hljs-keyword">long</span> index)</span>Observable.<span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)</span>.<span class="hljs-title">elementAt</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;</code></pre><h4 id="distinct-amp-distinctUntilChanged"><a href="#distinct-amp-distinctUntilChanged" class="headerlink" title="distinct&amp;distinctUntilChanged"></a>distinct&amp;distinctUntilChanged</h4><blockquote><p><code>distinct</code>：对数据源中的重复数据进行过滤</p><p><code>distinctUntilChanged</code>：只会过滤相邻的两个相同元素</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">distinct</span><span class="hljs-params">()</span>  Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">distinct</span><span class="hljs-params">()</span> </span>=&gt; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>  Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>).distinctUntilChanged() =&gt; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span></code></pre><h4 id="skip-amp-skipLast"><a href="#skip-amp-skipLast" class="headerlink" title="skip&amp;skipLast"></a>skip&amp;skipLast</h4><blockquote><p><code>skip</code>：对数据源中的前几项进行过滤</p><p><code>skipLast</code>：对数据源中的后几项进行过滤，以及最后的一段时间不发射数据。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-keyword">long</span> count)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span> </span>=&gt; <span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>  <span class="hljs-comment">//隔一段时间后，开始输出数据  </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-number">1</span>,TimeUnit.SECONDS)</span> </span>=&gt; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">skipLast</span><span class="hljs-params">(<span class="hljs-keyword">long</span> count)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">skipLast</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span> </span>=&gt; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span></code></pre><h4 id="take-amp-takeLast"><a href="#take-amp-takeLast" class="headerlink" title="take&amp;takeLast"></a>take&amp;takeLast</h4><blockquote><p><code>take</code>：取出数据源的前几项数据</p><p><code>takeLast</code>：取出数据源的后几项数据</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">take</span><span class="hljs-params">(<span class="hljs-keyword">long</span> count)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">take</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span> </span>=&gt;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span class="hljs-comment">//取出前time秒中输出的数据</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">take</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">repeat</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>.<span class="hljs-title">take</span><span class="hljs-params">(<span class="hljs-number">100</span>,TimeUnit.MILLISECONDS)</span> </span>=&gt; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">takeLast</span><span class="hljs-params">(<span class="hljs-keyword">long</span> count)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">takeLast</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span></code></pre><h4 id="ignoreElements"><a href="#ignoreElements" class="headerlink" title="ignoreElements"></a>ignoreElements</h4><blockquote><p>过滤所有Observable对象发射的数据，只允许<code>onError()</code>或<code>onComplete()</code>发送</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Completable <span class="hljs-title">ignoreElements</span><span class="hljs-params">()</span>  Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">ignoreElements</span><span class="hljs-params">()</span>.<span class="hljs-title">subscribe</span><span class="hljs-params">(new CompletableObserver()</span> </span>&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable disposable)</span> </span>&#123; &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123; &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123; &#125;        &#125;);</code></pre><h4 id="throttleFirst-amp-throttleLast-amp-throttleLatest"><a href="#throttleFirst-amp-throttleLast-amp-throttleLatest" class="headerlink" title="throttleFirst &amp; throttleLast&amp;throttleLatest"></a>throttleFirst &amp; throttleLast&amp;throttleLatest</h4><blockquote><p><code>throttleFirst</code>：对输出的数据进行限制，按照指定的参数对时间进行分片，然后选择每个时间片中的第一条数据</p><p><code>throttleLast</code>：对输出的数据进行限制，按照指定的参数对时间进行分片，然后选择每个时间片中的最后一条数据</p><p><code>throttleLatest</code>：读书处的数据进行限制，按照指定的参数对时间进行分片，然后选择每个时间片中的最近数据</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">throttleFirst</span><span class="hljs-params">(<span class="hljs-keyword">long</span> skipDuration, TimeUnit unit, Scheduler scheduler)</span> Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-number">50</span>,TimeUnit.MILLISECONDS,Schedulers.trampoline()</span>).                <span class="hljs-title">throttleFirst</span><span class="hljs-params">(<span class="hljs-number">100</span>,TimeUnit.MILLISECONDS)</span> </span>=&gt; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">throttleLast</span><span class="hljs-params">(<span class="hljs-keyword">long</span> skipDuration, TimeUnit unit, Scheduler scheduler)</span>   Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-number">50</span>,TimeUnit.MILLISECONDS,Schedulers.trampoline()</span>).                <span class="hljs-title">throttleLast</span><span class="hljs-params">(<span class="hljs-number">100</span>,TimeUnit.MILLISECONDS)</span> </span>=&gt; <span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">throttleLatest</span><span class="hljs-params">(<span class="hljs-keyword">long</span> skipDuration, TimeUnit unit, Scheduler scheduler)</span>   Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-number">50</span>,TimeUnit.MILLISECONDS,Schedulers.trampoline()</span>).                <span class="hljs-title">throttleLatest</span><span class="hljs-params">(<span class="hljs-number">100</span>,TimeUnit.MILLISECONDS)</span> </span>=&gt; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span></code></pre><h4 id="throttleWithTomeOut"><a href="#throttleWithTomeOut" class="headerlink" title="throttleWithTomeOut"></a>throttleWithTomeOut</h4><blockquote><p>数据源发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时才进行发射 </p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">throttleWithTimeout</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit, Scheduler scheduler)</span> Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>)</span>.<span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-number">120</span>,TimeUnit.MILLISECONDS,Schedulers.trampoline()</span>).                <span class="hljs-title">throttleWithTimeout</span><span class="hljs-params">(<span class="hljs-number">200</span>,TimeUnit.MILLISECONDS)</span> </span>=&gt; <span class="hljs-number">5</span></code></pre><h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><blockquote><p>限制发射频率过快的，它仅在过了一段指定的时间还没发射数据时才发射一个数据。功能与<code>throttleWithTimeout</code>相似</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">throttleWithTimeout</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;        <span class="hljs-keyword">return</span> debounce(timeout, unit);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">debounce</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;        <span class="hljs-keyword">return</span> debounce(timeout, unit, Schedulers.computation());    &#125;</code></pre><h3 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h3><h4 id="startWith-amp-startWithArray"><a href="#startWith-amp-startWithArray" class="headerlink" title="startWith&amp;startWithArray"></a>startWith&amp;startWithArray</h4><blockquote><p><code>startWith</code>：在指定数据源之前插入数据</p><p><code>startWithArray</code>：在指定数据之前插入数组</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//插入单个数据</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">startWith</span><span class="hljs-params">(T item)</span><span class="hljs-comment">//插入实现Iterable接口的对象</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">startWith</span><span class="hljs-params">(Iterable&lt;? extends T&gt; items)</span>  Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span>.<span class="hljs-title">startWith</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span> </span>=&gt; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span><span class="hljs-comment">//插入多个数据</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">startWithArray</span><span class="hljs-params">(T... items)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span>.<span class="hljs-title">startWithArray</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span> </span>=&gt; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span></code></pre><h4 id="merge-amp-mergeArray"><a href="#merge-amp-mergeArray" class="headerlink" title="merge&amp;mergeArray"></a>merge&amp;mergeArray</h4><blockquote><p><code>merge</code>：可以将多个数据源的数据合并起来进行发射，可能导致合并后的数据交错发射。</p><p><code>mergeArray</code>：插入的是一个<code>Observable</code>数组</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">merge</span><span class="hljs-params">(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources)</span>    Observable&lt;String &gt; ob1 </span>= Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);Observable&lt;String &gt; ob2 = Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);Observable.mergeArray(ob1,ob2)</code></pre><p><code>mergeError</code>是一个特殊示例，会等到所有数据发射完毕，才抛出<code>onError</code>事件</p><h4 id="concat-amp-concatArray"><a href="#concat-amp-concatArray" class="headerlink" title="concat&amp;concatArray"></a>concat&amp;concatArray</h4><blockquote><p>会将多个<code>Observable</code>对象合并到一个<code>Observable</code>对象中进行发送且<strong>严格按照顺序发射</strong>。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RxJava-concat.webp" srcset="/img/loading.gif" class="full-image" alt="conact操作符" title="conact操作符"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><pre><code class="hljs java">Observable&lt;String &gt; ob1 = Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);Observable&lt;String &gt; ob2 = Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);Observable.concatArray(ob1,ob2)</code></pre><h4 id="zip-amp-zipArray-amp-zipIterable"><a href="#zip-amp-zipArray-amp-zipIterable" class="headerlink" title="zip&amp;zipArray&amp;zipIterable"></a>zip&amp;zipArray&amp;zipIterable</h4><blockquote><p>按顺序结合两个或多个<code>Observable</code>对象，然后返回结果。<strong>严格按照顺序进行发射，他的总发射数与数据项最少的<code>Observable</code>对象数据相同。</strong></p></blockquote><pre><code class="hljs java">Observable.zip(Observable.range(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>), Observable.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>),(integer, integer2) -&gt; integer*integer2).subscribe(o -&gt; System.err.println(o));<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">25</span></code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RxJava-zip.webp" srcset="/img/loading.gif" class="full-image" alt="zip操作符" title="zip操作符"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="combineLastest"><a href="#combineLastest" class="headerlink" title="combineLastest"></a>combineLastest</h4><blockquote><p>当两个Observable中的任何一个发送了数据时，使用一个函数结合每个<code>Observable</code>的最近数据项，并且基于这个结果发送数据。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RxJava-combineLatest.png" srcset="/img/loading.gif" class="full-image" alt="combineLatest操作符" title="combineLatest操作符"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><pre><code class="hljs java">Observable.combineLatest(Observable.range(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>),Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>),(integer, integer2) -&gt; integer*integer2).subscribe(o -&gt; System.err.println(o));<span class="hljs-comment">//此时第一个Observable输出完毕，最终得到6，在与后续的增加数据相乘</span><span class="hljs-number">6</span>,<span class="hljs-number">12</span>,<span class="hljs-number">18</span>,<span class="hljs-number">24</span>,<span class="hljs-number">32</span></code></pre><h3 id="辅助操作符"><a href="#辅助操作符" class="headerlink" title="辅助操作符"></a>辅助操作符</h3><h4 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h4><blockquote><p>设置数据发射前的停顿时间</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-keyword">long</span> delay, TimeUnit unit)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span>.<span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-number">200</span>,TimeUnit.MILLISECONDS)</span></span></code></pre><h4 id="do系列"><a href="#do系列" class="headerlink" title="do系列"></a>do系列</h4><blockquote><p>用于监听数据回调</p></blockquote><ul><li><code>doAfterNext</code>：在<code>onNext()</code>之后回调</li><li><code>doOnNext</code>：调用<code>onNext()</code>时回调</li><li><code>doOnSubscribe</code>：观察者订阅时触发</li><li><code>doOnError</code>：调用<code>onError()</code>时触发</li><li><code>doOnComplete</code>：调用<code>onComplete()</code>时触发</li><li><code>doOnTerminate</code>：Observable终止前触发</li><li><code>doOnEach</code>：每次调用<code>onNext()</code>时触发</li><li><code>doOnDispose</code>：调用<code>Disposable.dispose()</code>时触发</li><li><code>doFinally</code>：调用<code>onError()</code>或<code>onComplete()</code>时触发</li><li><code>doAfterTerminate</code>：Observable终止后触发</li></ul><h4 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h4><blockquote><p>指定发射器所在的线程，即<code>Observable.onScuscribe</code>的所处线程，或者叫做事件产生的线程</p></blockquote><pre><code class="hljs java">Observable.just(<span class="hljs-number">1</span>).subscribeOn(Schedules.io)</code></pre><h4 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn"></a>observeOn</h4><blockquote><p>指定Subscriber所在线程，或者叫做事件消费的线程。</p></blockquote><pre><code class="hljs java">Observable.just(<span class="hljs-number">1</span>).subscribeOn(Schedules.io).obServerOn(AndroidSchedulers.mainThread())</code></pre><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h4><blockquote><p>用来设置一个超时时间，如果在指定时间内没有任何数据被发送出来，就会执行指定的数据项。</p></blockquote><pre><code class="hljs java">Observable.just(<span class="hljs-number">1L</span>,<span class="hljs-number">2L</span>,<span class="hljs-number">3L</span>)      .timeout(<span class="hljs-number">500</span>, TimeUnit.MILLISECONDS, Observable.rangeLong(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>))      .subscribe(System.out::print);输出结果：<span class="hljs-number">123</span>Thread.sleep(<span class="hljs-number">2000</span>);输出结果：<span class="hljs-number">12345</span></code></pre><h3 id="错误处理操作符"><a href="#错误处理操作符" class="headerlink" title="错误处理操作符"></a>错误处理操作符</h3><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><blockquote><p>拦截原始的<code>onError</code>通知，把它进行替换为其他的Observable对象，使原来的可以正常终止甚至不终止。</p></blockquote><ul><li><p><code>onErrorReturn</code>：在触发<code>onError</code>时，调用用户自定义的返回请求，实质上就是在调用一次<code>onNext</code>之后结束请求。</p><pre><code class="hljs java">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Object&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;Object&gt; observableEmitter)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                observableEmitter.onNext(<span class="hljs-number">1</span>);                observableEmitter.onNext(<span class="hljs-number">2</span>);                observableEmitter.onError(<span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"11"</span>));                observableEmitter.onNext(<span class="hljs-number">1</span>);            &#125;        &#125;).onErrorReturn(<span class="hljs-keyword">new</span> Function&lt;Throwable, Object&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(Throwable throwable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;            &#125;        &#125;)  输出结果：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">123</span></code></pre></li></ul><ul><li><p><code>onErrorResumeNext</code>：在触发<code>onError</code>时，立即停止原Observable的数据发射，并采用新的Observable对象进行新的数据发射</p><pre><code class="hljs java">        Observable.create(observableEmitter -&gt; &#123;            observableEmitter.onNext(<span class="hljs-number">1</span>);            observableEmitter.onNext(<span class="hljs-number">2</span>);            observableEmitter.onError(<span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"11"</span>));            observableEmitter.onNext(<span class="hljs-number">1</span>);        &#125;).onErrorResumeNext(Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))          输出结果： <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre></li></ul><ul><li><p><code>onExceptionResumeNext</code>：如果<code>onError</code>触发时收到的不是<code>Exception</code>，就会将错误正确传递下去，而不是用用户自定义的Observable对象</p><pre><code class="hljs java">Observable.create(observableEmitter -&gt; &#123;           observableEmitter.onNext(<span class="hljs-number">1</span>);           observableEmitter.onNext(<span class="hljs-number">2</span>);           <span class="hljs-comment">//observableEmitter.onError(new IllegalArgumentException("11"));</span>           <span class="hljs-comment">// 输出结果为 抛出异常</span>           observableEmitter.onError(<span class="hljs-keyword">new</span> NoSuchMethodError(<span class="hljs-string">"11"</span>));           <span class="hljs-comment">//输出结果为 1 2 1 2 3</span>           observableEmitter.onNext(<span class="hljs-number">1</span>);       &#125;).onExceptionResumeNext(Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))</code></pre></li></ul><h4 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h4><blockquote><p>实现了一种错误重试机制，再出现错误的时候进行重试，可以通过参数指定重试的条件。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RxJava-retry.webp" srcset="/img/loading.gif" class="full-image" alt="retry操作符" title="retry操作符"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><p><code>retry()</code>：无限次重试</p></li><li><p><code>retry(long times)</code>：指定次数的重试</p><pre><code class="hljs java"> Observable.create(observableEmitter -&gt; &#123;            observableEmitter.onNext(<span class="hljs-number">1</span>);            observableEmitter.onNext(<span class="hljs-number">2</span>);            observableEmitter.onError(<span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"11"</span>));            observableEmitter.onNext(<span class="hljs-number">123</span>);        &#125;).retry(<span class="hljs-number">2</span>);输出结果： <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> 抛出异常</code></pre></li></ul><ul><li><p><code>retry(BiPredicate&lt;? super Integer, ? super Throwable&gt; predicate)</code>：指定一定规则进行重试</p><pre><code class="hljs java">Observable.create(observableEmitter -&gt; &#123;           observableEmitter.onNext(<span class="hljs-number">1</span>);           observableEmitter.onNext(<span class="hljs-number">2</span>);           observableEmitter.onError(<span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"11"</span>));           observableEmitter.onNext(<span class="hljs-number">123</span>);       &#125;).retry(<span class="hljs-keyword">new</span> BiPredicate&lt;Integer, Throwable&gt;() &#123;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Integer integer, Throwable throwable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;               <span class="hljs-comment">//integer 为重试次数 return true代表继续重试 false 代表抛出异常</span>               <span class="hljs-keyword">return</span> integer&lt;<span class="hljs-number">2</span>;           &#125;       &#125;)</code></pre></li></ul><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><h4 id="all-amp-any"><a href="#all-amp-any" class="headerlink" title="all&amp;any"></a>all&amp;any</h4><blockquote><p><code>all</code>：判断数据源中是否所有数据都满足指定要求，可以使用一个函数表示</p><p><code>any</code>：判断数据源中是否存在满足要求的数据</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;Boolean&gt; <span class="hljs-title">all</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span>.<span class="hljs-title">all</span><span class="hljs-params">(integer -&gt; integer &lt; <span class="hljs-number">5</span>)</span> </span>=&gt; <span class="hljs-function"><span class="hljs-keyword">true</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;Boolean&gt; <span class="hljs-title">any</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span>.<span class="hljs-title">all</span><span class="hljs-params">(integer -&gt; integer &lt; <span class="hljs-number">2</span>)</span> </span>=&gt; <span class="hljs-keyword">true</span></code></pre><h4 id="contains-amp-isEmpty"><a href="#contains-amp-isEmpty" class="headerlink" title="contains&amp;isEmpty"></a>contains&amp;isEmpty</h4><blockquote><p><code>contains</code>：判断数据源中是否包含指定项</p><p><code>isEmpty</code>：数据源是否为空</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;Boolean&gt; <span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object element)</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span>.<span class="hljs-title">contains</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span> </span>=&gt; <span class="hljs-function"><span class="hljs-keyword">true</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;Boolean&gt; <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span>Observable.<span class="hljs-title">just</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span>.<span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>=&gt; <span class="hljs-keyword">false</span></code></pre><h4 id="sequenceEqual"><a href="#sequenceEqual" class="headerlink" title="sequenceEqual"></a>sequenceEqual</h4><blockquote><p>用来判断两个Observable对象的发射序列是否相等(<em>包含数据，发射顺序，终止状态等</em>)</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Single&lt;Boolean&gt; <span class="hljs-title">sequenceEqual</span><span class="hljs-params">(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2)</span> Observable.<span class="hljs-title">sequenceEqual</span><span class="hljs-params">(Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)</span>,                Observable.<span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)</span>)                .<span class="hljs-title">subscribe</span><span class="hljs-params">(new Consumer&lt;Boolean&gt;()</span> </span>&#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Boolean aBoolean)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        System.err.println(aBoolean);                    &#125;                &#125;);输出结果：<span class="hljs-keyword">false</span></code></pre><h4 id="amb"><a href="#amb" class="headerlink" title="amb"></a>amb</h4><blockquote><p>作用于两个或多个<code>Observable</code>对象，但是只会发射最初的Observable对象数据。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RxJava-amb.webp" srcset="/img/loading.gif" class="full-image" alt="amb操作符" title="amb操作符"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><pre><code class="hljs java">Observable.amb(Arrays.asList(Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>),                Observable.range(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)))   输出结果： <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span></code></pre><h4 id="defaultIfEmpty"><a href="#defaultIfEmpty" class="headerlink" title="defaultIfEmpty"></a>defaultIfEmpty</h4><blockquote><p>当数据源的数据为空时指定发送一个数据</p></blockquote><pre><code class="hljs java">Observable.create(observableEmitter -&gt; &#123;    observableEmitter.onComplete();  &#125;).defaultIfEmpty(<span class="hljs-number">777</span>)   输出结果： <span class="hljs-number">777</span></code></pre><h3 id="转换操作符"><a href="#转换操作符" class="headerlink" title="转换操作符"></a>转换操作符</h3><h4 id="toList-amp-toSortedList"><a href="#toList-amp-toSortedList" class="headerlink" title="toList&amp;toSortedList"></a>toList&amp;toSortedList</h4><blockquote><p>将数据发射序列转成列表，<code>toSortedList</code>转成升序列表</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;List&lt;T&gt;&gt; toList()Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>).toList() =&gt; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;List&lt;T&gt;&gt; toSortedList()Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>).toSortedList() =&gt; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span><span class="hljs-comment">//支持自定义比较规则</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Single&lt;List&lt;T&gt;&gt; toSortedList(<span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator)Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>).toSortedList(Comparator.comparingInt(value -&gt; -value)) =&gt; <span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span></code></pre><h4 id="toMap-amp-toMultiMap"><a href="#toMap-amp-toMultiMap" class="headerlink" title="toMap&amp;toMultiMap"></a>toMap&amp;toMultiMap</h4><blockquote><p>将发射的数据转换成另一个类型的值，转换过程是针对每一个数据项的。<strong>源Observable的每一项数据作为value，然后用户自定义生成key的函数，最终得到Map型的结果。</strong></p><p><code>toMultiMap</code>可以转换成一个集合对象</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RxJava-toMap.webp" srcset="/img/loading.gif" class="full-image" alt="toMap操作符" title="toMap操作符"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><pre><code class="hljs java">Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>)        .toMap(<span class="hljs-keyword">new</span> Function&lt;Integer, Object&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(Integer integer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">return</span> integer + <span class="hljs-number">1</span>;            &#125;        &#125;)  输出结果：[<span class="hljs-number">2</span>=<span class="hljs-number">1</span>，<span class="hljs-number">3</span>=<span class="hljs-number">2</span>，<span class="hljs-number">6</span>=<span class="hljs-number">5</span>]Observable.just(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)               .toMultimap(<span class="hljs-keyword">new</span> Function&lt;Integer, Object&gt;() &#123;                   <span class="hljs-meta">@Override</span>                   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(Integer integer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                       <span class="hljs-keyword">return</span> integer+<span class="hljs-number">1</span>;                   &#125;               &#125;)  输出结果：&#123;<span class="hljs-number">2</span>=[<span class="hljs-number">1</span>], <span class="hljs-number">3</span>=[<span class="hljs-number">2</span>], <span class="hljs-number">4</span>=[<span class="hljs-number">3</span>]&#125;</code></pre><h4 id="toFlowable"><a href="#toFlowable" class="headerlink" title="toFlowable"></a>toFlowable</h4><blockquote><p>用于讲一个<code>Observable</code>对象转成<code>Flowable</code>对象。</p></blockquote><h4 id="to"><a href="#to" class="headerlink" title="to"></a>to</h4><blockquote><p>可以将一个<code>Observable</code>对象转成任意类型</p></blockquote><h2 id="RxJava线程类型"><a href="#RxJava线程类型" class="headerlink" title="RxJava线程类型"></a>RxJava线程类型</h2><p>RxJava的线程控制是通过<code>subscribeOn</code>以及<code>observeOn</code>来进行控制的。接下来列举一下RxJava中提供的线程调度器以及<code>RxAndroid</code>提供的主线程调度器。</p><ul><li><code>Schedulers.io()</code>：适用于io操作(<em>在Android中指代子线程</em>)，增长或缩减来自适应的线程池，通常用于访问网络，读写文件等操作。采用的线程池是<code>CachedThreadPool</code>，是无限制的，但是大量创建线程就会影响性能。</li><li><code>Schedulers.computation()</code>：计算工作默认的调度器，与I/O操作无关</li><li><code>Schedulers.newThread()</code>：代表常规的一个新线程</li><li><code>Schedulers.immdiate()</code>：允许你立即在当前线程执行任务</li><li><code>Schedulers.trampoline()</code>：当我们想执行一个任务时，并非立即执行，使用<code>trampoline()</code>执行入队。<em>将会处理它的队列并且按序运行队列中每一个任务</em></li><li><code>AndroidSchedulers.mainThread()</code>：指代Android系统中的主线程</li></ul><h2 id="RxJava基本流程分析"><a href="#RxJava基本流程分析" class="headerlink" title="RxJava基本流程分析"></a>RxJava基本流程分析</h2><pre><code class="hljs java">Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;Integer&gt; observableEmitter)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;               observableEmitter.onNext(<span class="hljs-number">123</span>);               observableEmitter.onComplete();           &#125;       &#125;).subscribeOn(AndroidSchedulers.mainThread())  .observerOn(Schedulers.io())  .subscribe(<span class="hljs-keyword">new</span> Observer&lt;Integer&gt;() &#123;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable disposable)</span> </span>&#123;           &#125;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(Integer integer)</span> </span>&#123;               System.err.println(integer);           &#125;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;           &#125;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;           &#125;       &#125;);</code></pre><p>以上是最基础的RxJava使用流程，从这段代码中进行原理分析。</p><h3 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h3><p>从<code>Observable.create()</code>开始</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;    ObjectHelper.requireNonNull(source, <span class="hljs-string">"source is null"</span>);    <span class="hljs-comment">//大致流程就是 新建了一个ObservableCreate对象</span>    <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> ObservableCreate&lt;T&gt;(source));&#125;</code></pre><ol><li>Observable先调用<code>create()</code></li><li><code>create()</code>中传入<code>ObservableOnSubscribe</code>对象</li><li>通过<code>new ObservableCreate()</code>得到最终Observable对象</li></ol><pre><code class="hljs java"><span class="hljs-comment">//外部传进来的 ObservableOnSubscribe实例 </span><span class="hljs-keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObservableCreate</span><span class="hljs-params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;     <span class="hljs-keyword">this</span>.source = source; &#125; <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;     CreateEmitter&lt;T&gt; parent = <span class="hljs-keyword">new</span> CreateEmitter&lt;T&gt;(observer);     observer.onSubscribe(parent);     <span class="hljs-keyword">try</span> &#123;         source.subscribe(parent);     &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;         Exceptions.throwIfFatal(ex);         parent.onError(ex);     &#125; &#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Observable创建流程.png" srcset="/img/loading.gif" class="full-image" alt="Observable创建流程" title="Observable创建流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="Observable订阅"><a href="#Observable订阅" class="headerlink" title="Observable订阅"></a>Observable订阅</h3><p>通过<code>Observable.subscribe()</code>执行订阅流程</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;        ObjectHelper.requireNonNull(observer, <span class="hljs-string">"observer is null"</span>);        <span class="hljs-keyword">try</span> &#123;            observer = RxJavaPlugins.onSubscribe(<span class="hljs-keyword">this</span>, observer);            ObjectHelper.requireNonNull(observer, <span class="hljs-string">"The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"</span>);            subscribeActual(observer);①        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123; <span class="hljs-comment">// NOPMD</span>            <span class="hljs-keyword">throw</span> e;        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;            Exceptions.throwIfFatal(e);            RxJavaPlugins.onError(e);            NullPointerException npe = <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"Actually not, but can't throw other exceptions due to RS"</span>);            npe.initCause(e);            <span class="hljs-keyword">throw</span> npe;        &#125;    &#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span></span>;<span class="hljs-comment">//ObservableCreate.java 子类实现该方法</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;        CreateEmitter&lt;T&gt; parent = <span class="hljs-keyword">new</span> CreateEmitter&lt;T&gt;(observer);        <span class="hljs-comment">//执行Observer的onSubscribe()进行事件分发</span>        observer.onSubscribe(parent);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//向上调用上层的Observer的subscribe()</span>            source.subscribe(parent);        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;            Exceptions.throwIfFatal(ex);            parent.onError(ex);        &#125;    &#125;</code></pre><p>在<code>subscribe()</code>中会调用到抽象方法<code>subscribeActual()</code>，就拿上节的<code>ObservableCreate</code>来说，他的内部就实现了<code>subscribeActual()</code>。</p><p>在<code>subscribe()</code>传入的参数为<code>Observer</code>类型即观察者。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Observable订阅流程.png" srcset="/img/loading.gif" class="full-image" alt="Observable订阅流程" title="Observable订阅流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p><code>Observable.subscribe()</code>调用到<code>Observable.subscribeActual()</code>，由子类进行覆盖重写(<strong>多态</strong>)，在其中执行的代码主要分为两部分：</p><p><code>Observerable.subscribe</code>：真正的订阅流程从这里开始</p><p><code>Observer.onSubscribe</code>：在其中进行事件分发</p></blockquote><h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>RxJava通过<code>subscribeOn()</code>和<code>observerOn()</code>来进行线程的切换。如果未去设置线程切换相关参数，那么执行的线程都会为当前线程。</p><h4 id="Observable-observeOn"><a href="#Observable-observeOn" class="headerlink" title="Observable.observeOn"></a>Observable.observeOn</h4><blockquote><p>切换<code>subscribe()</code>的运行线程</p></blockquote><p>从<code>Observable.observeOn()</code>开始进行分析</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">observeOn</span><span class="hljs-params">(Scheduler scheduler)</span> </span>&#123;        <span class="hljs-keyword">return</span> observeOn(scheduler, <span class="hljs-keyword">false</span>, bufferSize());    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">observeOn</span><span class="hljs-params">(Scheduler scheduler, <span class="hljs-keyword">boolean</span> delayError, <span class="hljs-keyword">int</span> bufferSize)</span> </span>&#123;        ObjectHelper.requireNonNull(scheduler, <span class="hljs-string">"scheduler is null"</span>);        ObjectHelper.verifyPositive(bufferSize, <span class="hljs-string">"bufferSize"</span>);        <span class="hljs-comment">//this 指代了当前的Observable对象， scheduler就是指我们设置的 切换线程</span>        <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler, delayError, bufferSize));    &#125;</code></pre><p>通过<code>Observable.observeOn()</code>运行之后得到了<code>ObservableObserveOn</code>对象。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;    <span class="hljs-keyword">if</span> (scheduler <span class="hljs-keyword">instanceof</span> TrampolineScheduler) &#123;        <span class="hljs-comment">//无需执行任何线程操作</span>        source.subscribe(observer);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//scheduler指代传进来的线程调度对象</span>        Scheduler.Worker w = scheduler.createWorker();        source.subscribe(<span class="hljs-keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));    &#125;&#125;</code></pre><p>调用<code>ObservableObserveOn.subscribeActual()</code>后，会生成<code>ObserveOnObserver</code>对象，由该对象对<code>ObserveableObserveOn</code>进行监听</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(T t)</span> </span>&#123;          <span class="hljs-keyword">if</span> (done) &#123;              <span class="hljs-keyword">return</span>;          &#125;          <span class="hljs-keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;              <span class="hljs-comment">//添加当前事件到队列中</span>              queue.offer(t);          &#125;          <span class="hljs-comment">//执行线程切换</span>          schedule();      &#125;      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-keyword">if</span> (getAndIncrement() == <span class="hljs-number">0</span>) &#123;              worker.schedule(<span class="hljs-keyword">this</span>);          &#125;      &#125;</code></pre><p>例如发送一个<code>onNext()</code>事件，就会执行到<code>schedule()</code>进行线程切换(如果设置)。<code>worker</code>对应新建<code>ObserveOnObserve</code>对象时的传入参数——用户自定义的<code>Schedulers</code>。此处拿<code>IoScheduler</code>举例，用于子线程执行操作。</p><pre><code class="hljs java"><span class="hljs-comment">//Scheduler.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Disposable</span>        @<span class="hljs-title">NonNull</span>        <span class="hljs-title">public</span> <span class="hljs-title">Disposable</span> <span class="hljs-title">schedule</span>(@<span class="hljs-title">NonNull</span> <span class="hljs-title">Runnable</span> <span class="hljs-title">run</span>) </span>&#123;            <span class="hljs-keyword">return</span> schedule(run, <span class="hljs-number">0L</span>, TimeUnit.NANOSECONDS);        &#125;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLoopWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Scheduler</span>.<span class="hljs-title">Worker</span></span>&#123;<span class="hljs-meta">@NonNull</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedule</span><span class="hljs-params">(@NonNull Runnable action, <span class="hljs-keyword">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;            <span class="hljs-keyword">if</span> (tasks.isDisposed()) &#123;                <span class="hljs-comment">// don't schedule, we are unsubscribed</span>                <span class="hljs-keyword">return</span> EmptyDisposable.INSTANCE;            &#125;            <span class="hljs-keyword">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);        &#125;&#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NewThreadWorker</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> expirationTime;        ThreadWorker(ThreadFactory threadFactory) &#123;            <span class="hljs-keyword">super</span>(threadFactory);            <span class="hljs-keyword">this</span>.expirationTime = <span class="hljs-number">0L</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getExpirationTime</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> expirationTime;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExpirationTime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> expirationTime)</span> </span>&#123;            <span class="hljs-keyword">this</span>.expirationTime = expirationTime;        &#125;    &#125;</code></pre><p>假设设置子线程执行即<code>Schedulers.io()</code>，那么会优先调用到<code>Schedulers.schedule()</code>由于子类没有实现该方法，所以上溯到父类中的实现。</p><p>调用到<code>schedule()</code>之后，，就会调用到<code>IoScheduler.schedule()</code>中，再切换到了<code>NewThreadWorker.scheduleActual()</code>中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ScheduledRunnable <span class="hljs-title">scheduleActual</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable run, <span class="hljs-keyword">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;    Runnable decoratedRun = RxJavaPlugins.onSchedule(run);    ScheduledRunnable sr = <span class="hljs-keyword">new</span> ScheduledRunnable(decoratedRun, parent);    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (!parent.add(sr)) &#123;            <span class="hljs-keyword">return</span> sr;        &#125;    &#125;    Future&lt;?&gt; f;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (delayTime &lt;= <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">//executor 指代一个线程池对象</span>            f = executor.submit((Callable&lt;Object&gt;)sr);        &#125; <span class="hljs-keyword">else</span> &#123;            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);        &#125;        sr.setFuture(f);    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;            parent.remove(sr);        &#125;        RxJavaPlugins.onError(ex);    &#125;    <span class="hljs-keyword">return</span> sr;&#125;</code></pre><p>在<code>NewThreadWorker.scheduleActual()</code>主要执行的是使用线程池调用<code>submit()</code>或<code>execute()</code>去启动线程。经过层层传递最后调用到<code>ObserveableObserveOn.run()</code></p><pre><code class="hljs java">        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">if</span> (outputFused) &#123;                drainFused();            &#125; <span class="hljs-keyword">else</span> &#123;                drainNormal();            &#125;        &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drainNormal</span><span class="hljs-params">()</span> </span>&#123;           ...            <span class="hljs-keyword">for</span> (;;) &#123;                <span class="hljs-keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;                    <span class="hljs-keyword">return</span>;                &#125;                <span class="hljs-keyword">for</span> (;;) &#123;                    <span class="hljs-keyword">boolean</span> d = done;                  ...                    a.onNext(v);                &#125;             ...            &#125;        &#125;</code></pre><p>层层回调到<code>run()</code>后，在其中会继续执行<code>onNext()</code>此时线程已经切换成功。</p><p><strong>最终实现的是将目标Observe中的<code>onNext()，onError(),onComplete()</code>置于指定线程中运行。</strong></p><p>//TODO 流程图</p><h4 id="Observable-subscribeOn"><a href="#Observable-subscribeOn" class="headerlink" title="Observable.subscribeOn"></a>Observable.subscribeOn</h4><blockquote><p>切换<code>Observable</code>的运行线程</p></blockquote><p>同上，先从<code>Observable.subscribeOn()</code>开始分析</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">subscribeOn</span><span class="hljs-params">(Scheduler scheduler)</span> </span>&#123;    ObjectHelper.requireNonNull(scheduler, <span class="hljs-string">"scheduler is null"</span>);    <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler));&#125;</code></pre><p>操作的对象为<code>ObservableSubscribeOn</code></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;    <span class="hljs-keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="hljs-keyword">new</span> SubscribeOnObserver&lt;T&gt;(observer);    <span class="hljs-comment">//调用 onSubscribe() 回调</span>    observer.onSubscribe(parent);    <span class="hljs-comment">//此处调用线程切换</span>    parent.setDisposable(scheduler.scheduleDirect(<span class="hljs-keyword">new</span> SubscribeTask(parent)));&#125;</code></pre><p>这里我们假设使用的是<code>IoScheduler</code>，就调用到<code>IoScheduler.scheduleDirect()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">scheduleDirect</span><span class="hljs-params">(@NonNull Runnable run)</span> </span>&#123;        <span class="hljs-keyword">return</span> scheduleDirect(run, <span class="hljs-number">0L</span>, TimeUnit.NANOSECONDS);    &#125;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">scheduleDirect</span><span class="hljs-params">(@NonNull Runnable run, <span class="hljs-keyword">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;        <span class="hljs-keyword">final</span> Worker w = createWorker();        <span class="hljs-keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);        DisposeTask task = <span class="hljs-keyword">new</span> DisposeTask(decoratedRun, w);        w.schedule(task, delay, unit);        <span class="hljs-keyword">return</span> task;    &#125;</code></pre><p>最后调用到<code>DisposeTask.run()</code>方法去执行切换</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisposeTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Disposable</span>, <span class="hljs-title">Runnable</span>, <span class="hljs-title">SchedulerRunnableIntrospection</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            runner = Thread.currentThread();            <span class="hljs-keyword">try</span> &#123;                decoratedRun.run();            &#125; <span class="hljs-keyword">finally</span> &#123;                dispose();                runner = <span class="hljs-keyword">null</span>;            &#125;        &#125;&#125;</code></pre><p><code>decoratedRun</code>指的就是上面传进来的<code>SubscribeTask</code>，有执行到了它的<code>run()</code></p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubscribeTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;        <span class="hljs-keyword">this</span>.parent = parent;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        source.subscribe(parent);    &#125;&#125;</code></pre><p>此时线程已经完成了切换工作。</p><blockquote><p>第一次有效。</p></blockquote><h4 id="AndroidSchedulers-mainThread"><a href="#AndroidSchedulers-mainThread" class="headerlink" title="AndroidSchedulers.mainThread()"></a><code>AndroidSchedulers.mainThread()</code></h4><p>由RxAndroid提供的Android主线程切换器</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainHolder</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Scheduler DEFAULT        = <span class="hljs-keyword">new</span> HandlerScheduler(<span class="hljs-keyword">new</span> Handler(Looper.getMainLooper()), <span class="hljs-keyword">false</span>);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(        <span class="hljs-keyword">new</span> Callable&lt;Scheduler&gt;() &#123;            <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Scheduler <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">return</span> MainHolder.DEFAULT;            &#125;        &#125;);<span class="hljs-comment">/** A &#123;<span class="hljs-doctag">@link</span> Scheduler&#125; which executes actions on the Android main thread. */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Scheduler <span class="hljs-title">mainThread</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);&#125;<span class="hljs-comment">/** A &#123;<span class="hljs-doctag">@link</span> Scheduler&#125; which executes actions on &#123;<span class="hljs-doctag">@code</span> looper&#125;. */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Scheduler <span class="hljs-title">from</span><span class="hljs-params">(Looper looper)</span> </span>&#123;    <span class="hljs-keyword">return</span> from(looper, <span class="hljs-keyword">false</span>);&#125;</code></pre><p><code>mainThread()</code>里面新建了一个<code>Handler</code>对象用来切换至主线程，还支持通过<code>from()</code>设置自定义Looper来切换到其他线程。</p><p>RXJava设置线程切换时，需要通过<code>Scheduler.createWorker()</code>来生成对应线程切换器</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerScheduler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Scheduler</span></span>&#123;   <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">"NewApi"</span>) <span class="hljs-comment">// Async will only be true when the API is available to call.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">scheduleDirect</span><span class="hljs-params">(Runnable run, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;        <span class="hljs-keyword">if</span> (run == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"run == null"</span>);        <span class="hljs-keyword">if</span> (unit == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"unit == null"</span>);        run = RxJavaPlugins.onSchedule(run);        ScheduledRunnable scheduled = <span class="hljs-keyword">new</span> ScheduledRunnable(handler, run);        Message message = Message.obtain(handler, scheduled);        <span class="hljs-keyword">if</span> (async) &#123;            message.setAsynchronous(<span class="hljs-keyword">true</span>);        &#125;        handler.sendMessageDelayed(message, unit.toMillis(delay));        <span class="hljs-keyword">return</span> scheduled;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Worker <span class="hljs-title">createWorker</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HandlerWorker(handler, async);    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Worker</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedule</span><span class="hljs-params">(Runnable run, <span class="hljs-keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;            ScheduledRunnable scheduled = <span class="hljs-keyword">new</span> ScheduledRunnable(handler, run);            Message message = Message.obtain(handler, scheduled);            message.obj = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// Used as token for batch disposal of this worker's runnables.</span>            <span class="hljs-keyword">if</span> (async) &#123;                message.setAsynchronous(<span class="hljs-keyword">true</span>);            &#125;            handler.sendMessageDelayed(message, unit.toMillis(delay));            <span class="hljs-keyword">if</span> (disposed) &#123;                handler.removeCallbacks(scheduled);                <span class="hljs-keyword">return</span> Disposables.disposed();            &#125;   &#125;           <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>&#123;            disposed = <span class="hljs-keyword">true</span>;            handler.removeCallbacksAndMessages(<span class="hljs-keyword">this</span> <span class="hljs-comment">/* token */</span>);        &#125;&#125;</code></pre><p>在<code>dispose()</code>时通过移除对应的消息来取消订阅</p><h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><h3 id="取消订阅-1"><a href="#取消订阅-1" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>通过<code>Disposable.dispose()</code>可以取消相关订阅</p><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://www.jianshu.com/p/a9ebf730cd08" target="_blank" rel="noopener">RxJava1</a></p><p><a href="https://juejin.im/post/5a248206f265da432153ddbc#heading-9" target="_blank" rel="noopener">RxJava2</a></p><p><a href="https://juejin.im/post/5b72f76551882561354462dd#heading-9" target="_blank" rel="noopener">RxJava3</a></p><p><a href="https://www.cherylgood.cn/?keyword=Rxjava" target="_blank" rel="noopener">RxJava4</a></p><p><a href="https://www.jianshu.com/p/88aa273d37be" target="_blank" rel="noopener">RxJava5</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247490701&amp;idx=1&amp;sn=a7cef1ae9c59c3c60af2b15f7939799d&amp;chksm=96cdbdc0a1ba34d605cad73ba1dd0d81059ced9fc1c067b9593403a283414db07cca4d7459fe&amp;mpshare=1&amp;scene=23&amp;srcid=1015rFqxIvHGW6R8HsZQpPwj%23rd" target="_blank" rel="noopener">RxJava6</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android - Drawable相关</title>
    <link href="/2019/01/10/Android-Drawable%E7%9B%B8%E5%85%B3/"/>
    <url>/2019/01/10/Android-Drawable%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="Drawable简介"><a href="#Drawable简介" class="headerlink" title="Drawable简介"></a>Drawable简介</h2><blockquote><p>Drawable是一种 可以在Canvas上进行绘制的对象，即<strong>可绘制物</strong>。</p></blockquote><p>在实际开发中，Drawable通常被用作View的背景，一般通过XML进行定义，也支持通过代码去实现(<em>例如动画样式的Drawable</em>)。</p><p>Drawable是一个抽象类，是所有Drawable的基类。例如常用的<code>ShapeDrawable、BitmapDrawable，LayerDrawable</code>等。</p><!--Drawable绘制流程与View有什么区别？实现动画有什么区别？View为什么还要Drawable--><h3 id="Drawable使用方式"><a href="#Drawable使用方式" class="headerlink" title="Drawable使用方式"></a>Drawable使用方式</h3><ul><li><p><code>XML引入</code>：创建所需Drawable根节点的<code>XML</code>，再通过调用<code>@drawable/xx</code>引入页面布局中</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:shape</span>=<span class="hljs-string">"oval"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">solid</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">"#fff3c3"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">size</span>        <span class="hljs-attr">android:width</span>=<span class="hljs-string">"@dimen/x16"</span>        <span class="hljs-attr">android:height</span>=<span class="hljs-string">"@dimen/x16"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span>android:background = "@drawable/xx"</code></pre></li><li><p><code>Java代码</code>：new一个所需Drawable并设置相关属性，最后设置到布局中。</p><pre><code class="hljs java">//自定义一个 Drawable对象 ，需要继承 Drawable基类class HomeWaterRippleDrawable(private val context: Context) : Drawable()//动态为布局设置 Drawable属性lav_camera.setImageDrawable(HomeWaterRippleDrawable(mActivity))</code></pre></li></ul><h4 id="Drawable宽高"><a href="#Drawable宽高" class="headerlink" title="Drawable宽高"></a>Drawable宽高</h4><p>Drawable可以通过<code>getIntrinsicWidth()和getIntrinsicHeight()</code>获取内部宽高。<em>其实在View工作原理的<code>measure</code>过程中有用到这个方法，就是为了View设置背景时可以精确的确定其宽高</em>。</p><blockquote><p>不是所有的Drawable都有宽高</p><ul><li>图片所形成的Drawable内部宽高就是图片的宽高</li><li>颜色所形成的Drawable没有内部宽高的概念</li></ul></blockquote><p>Drawable没有大小的概念，当用作View的背景时，Drawable会被拉伸至View的同等大小。</p><h4 id="Drawable使用范围"><a href="#Drawable使用范围" class="headerlink" title="Drawable使用范围"></a>Drawable使用范围</h4><ul><li>作为ImageView的图像显示</li><li>作为View的背景</li></ul><h2 id="Drawable的种类"><a href="#Drawable的种类" class="headerlink" title="Drawable的种类"></a>Drawable的种类</h2><h4 id="1-BitmapDrawable"><a href="#1-BitmapDrawable" class="headerlink" title="1.BitmapDrawable"></a>1.BitmapDrawable</h4><blockquote><p>表示一张图片</p></blockquote><p>根节点为<code>bitmap</code>。在使用过程中，我们可以直接引用原始图片即可，也可以通过XML的方式来描述他。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bitmap</span>    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>   <span class="hljs-attr">android:src</span>=<span class="hljs-string">""</span>   <span class="hljs-attr">android:antialias</span>=<span class="hljs-string">"[true | false]"</span>   <span class="hljs-attr">android:dither</span>=<span class="hljs-string">"[true | false]"</span>   <span class="hljs-attr">android:filter</span>=<span class="hljs-string">"[true | false]"</span>   <span class="hljs-attr">android:tileMode</span>=<span class="hljs-string">"[disabled | clamp | repeat | mirror]"</span>   <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"[top | bottom | left | right | center_vertical |                    |fill_vertical | center_horizontal | fill_horizontal |                    |center | fill | clip_vertical | clip_horizontal]"</span>   &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bitmap</span>&gt;</span></code></pre><p>下面是各个属性的含义：</p><p><code>android:src</code>：图片的资源id</p><p><code>android:antialias</code>：是否开启抗锯。，开启会让图片变得平滑。<em>可能导致图片清晰度下降，基本可以忽略，应该开启。</em></p><p><code>android:dither</code>：是否开启抖动效果。可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果，是图片显示不过于失真。<em>应该开启。</em></p><p><code>android:filter</code>：是否开启过滤效果。当图片被拉伸或者压缩时，开启可以保持较好的显示效果。<em>应该开启</em>。</p><p><code>android:tileMode</code>：平铺模式。开启平铺模式时，<code>gravity</code>属性会被忽略。</p><table><thead><tr><th style="text-align:center">可选项</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">disabled</td><td style="text-align:center">关闭平铺模式<em>默认值</em></td></tr><tr><td style="text-align:center">clamp</td><td style="text-align:center">图片四周的像素会拓展到周围区域<em>就是边缘像素拉伸</em></td></tr><tr><td style="text-align:center">repeat</td><td style="text-align:center">水平和竖直方向平铺</td></tr><tr><td style="text-align:center">mirror</td><td style="text-align:center">水平和竖直方向镜像显示</td></tr></tbody></table><p><code>android:gravity</code>：对图片位置进行定位。可以通过”|”进行组合使用。</p><table><thead><tr><th style="text-align:center">可选项</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">top</td><td style="text-align:center">不改变大小，置于容器顶部</td></tr><tr><td style="text-align:center">bottom</td><td style="text-align:center">不改变大小，置于容器底部</td></tr><tr><td style="text-align:center">left</td><td style="text-align:center">不改变大小，置于容器左部</td></tr><tr><td style="text-align:center">right</td><td style="text-align:center">不改变大小，置于容器右部</td></tr><tr><td style="text-align:center">center_vertical</td><td style="text-align:center">不改变大小，置于容器竖直居中</td></tr><tr><td style="text-align:center">fill_vertical</td><td style="text-align:center">图片竖直拉伸填满容器</td></tr><tr><td style="text-align:center">center_horizontal</td><td style="text-align:center">不改变大小，置于容器水平居中</td></tr><tr><td style="text-align:center">fill_horizontal</td><td style="text-align:center">图片水平拉伸填满容器</td></tr><tr><td style="text-align:center">center</td><td style="text-align:center">不改变大小，置于容器水平和竖直居中</td></tr><tr><td style="text-align:center">fill</td><td style="text-align:center">水平竖直方向拉伸填满容器<em>默认值</em></td></tr><tr><td style="text-align:center">clip_vertical</td><td style="text-align:center">竖直方向进行裁剪</td></tr><tr><td style="text-align:center">clip_horizontal</td><td style="text-align:center">水平方向进行裁剪</td></tr></tbody></table><h5 id="应用代码"><a href="#应用代码" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml">//repeat_bitmap.xml<span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bitmap</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:dither</span>=<span class="hljs-string">"true"</span>    <span class="hljs-attr">android:src</span>=<span class="hljs-string">"@mipmap/ic_launcher"</span>    <span class="hljs-attr">android:tileMode</span>=<span class="hljs-string">"repeat"</span>    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bitmap</span>&gt;</span>//布局文件引用android:background="@drawable/repeat_bitmap"</code></pre><pre><code class="hljs java">Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher);BitmapDrawable bitDrawable = <span class="hljs-keyword">new</span> BitmapDrawable(bitmap);bitDrawable.setDither(<span class="hljs-keyword">true</span>);bitDrawable.setTileModeXY(Shader.TileMode.REPEAT, Shader.TileMode.REPEAT);view.setBackground(bitmapDrawable);</code></pre><h4 id="2-NinePatchDrawable"><a href="#2-NinePatchDrawable" class="headerlink" title="2.NinePatchDrawable"></a>2.NinePatchDrawable</h4><blockquote><p>表示一张.9格式的图片</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">nine-patch</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:dither</span>=<span class="hljs-string">"[true|false]"</span>    <span class="hljs-attr">android:src</span>=<span class="hljs-string">""</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nine-patch</span>&gt;</span></code></pre><p><code>android:src</code>：图片的资源id</p><p><code>android:dither</code>：是否开启抖动效果。可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果，是图片显示不过于失真。<em>应该开启。</em></p><h5 id="应用代码-1"><a href="#应用代码-1" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml">//对应 ninepatch.9.png   ninepatch.xml<span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">nine-patch</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:dither</span>=<span class="hljs-string">"true"</span>    <span class="hljs-attr">android:src</span>=<span class="hljs-string">"@drawable/ninepatch"</span>    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nine-patch</span>&gt;</span>//布局文件引用android:background="@drawable/ninepatch"</code></pre><h4 id="3-ShapeDrawable-—-实际为GradientDrawable"><a href="#3-ShapeDrawable-—-实际为GradientDrawable" class="headerlink" title="3.ShapeDrawable — 实际为GradientDrawable"></a>3.ShapeDrawable — 实际为<code>GradientDrawable</code></h4><blockquote><p>可表示纯色，有渐变效果的基础几何图形(例如矩形，圆形等)</p></blockquote><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">shape</span>    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:shape</span>=<span class="hljs-string">"[rectangle | oval | line | ring]"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">corners</span>        <span class="hljs-attr">android:radius</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:topLeftRaidus</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:topRightRaidus</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:bottomLeftRaidus</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:bottomRightRaidus</span>=<span class="hljs-string">"integer"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">gradient</span>        <span class="hljs-attr">android:angle</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:centerX</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:centerY</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:centerColor</span>=<span class="hljs-string">"color"</span>        <span class="hljs-attr">android:endColor</span>=<span class="hljs-string">"color"</span>        <span class="hljs-attr">android:gradientRadius</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:startColor</span>=<span class="hljs-string">"color"</span>        <span class="hljs-attr">android:type</span>=<span class="hljs-string">"[linear | radial | sweep]"</span>        <span class="hljs-attr">android:useLevel</span>=<span class="hljs-string">"[true | false]"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">padding</span>        <span class="hljs-attr">android:left</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:top</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:right</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:bottom</span>=<span class="hljs-string">"integer"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">size</span>        <span class="hljs-attr">android:width</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:height</span>=<span class="hljs-string">"integer"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">solid</span>        <span class="hljs-attr">android:color</span>=<span class="hljs-string">"color"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span>        <span class="hljs-attr">android:width</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:color</span>=<span class="hljs-string">"color"</span>        <span class="hljs-attr">android:dashWidth</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:dashGap</span>=<span class="hljs-string">"integer"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span></code></pre><p><code>android:shape</code>：图形的形状。</p><ul><li><code>rectabgle</code>：矩形</li><li><code>oval</code>：椭圆</li><li><code>line</code>：横线。必须设置<code>&lt;stroke&gt;</code>属性指定直线宽度及颜色</li><li><code>ring</code>：圆环。必须设置<code>&lt;stroke&gt;</code>属性指定圆环宽度及颜色</li></ul><p><code>&lt;corners&gt;</code>：表示四个圆角的角度，只适合矩形。<code>android:radius</code>这个属性的设置优先级低于单独设置各个圆角角度。</p><p><code>&lt;gradient&gt;</code>：可以设置渐变效果</p><ul><li><code>android:angle</code>：设置渐变角度。默认为0，且要求值必须为45的倍数，<em>0表示从左到右，90表示从下到上</em></li><li><code>android:centerX</code>：渐变的中心点的X坐标。</li><li><code>android:centerY</code>：渐变的中心点的Y坐标。</li><li><code>android:startColor</code>：渐变的起始色。</li><li><code>android:centerColor</code>：渐变的中间色。</li><li><code>android:endColor</code>：渐变的结束色。</li><li><code>android:gradient</code>：渐变半径。仅当<strong>android:type=”radial”</strong>时有效。</li><li><code>android:type</code>：渐变的类型<ul><li>linear：线性渐变</li><li>radial：径向渐变。类似扩散效果</li><li>sweep：扫描线渐变。类似雷达效果。</li></ul></li></ul><p><code>&lt;padding&gt;</code>：设置四周空白距离</p><p><code>&lt;size&gt;</code>：设置图形的固有大小，但不是最终的大小。<em>作为View背景时，大小还是跟着View走的</em></p><p><code>&lt;solid&gt;</code>：设置纯色填充</p><p><code>&lt;stroke&gt;</code>：设置描边</p><table><thead><tr><th style="text-align:left">stroke属性</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:left">android:width</td><td>描边的宽度，越大边缘越明显</td></tr><tr><td style="text-align:left">android:color</td><td>描边的颜色</td></tr><tr><td style="text-align:left">android:dashwidth</td><td>虚线的宽度</td></tr><tr><td style="text-align:left">android:dashGap</td><td>虚线的空隙间隔</td></tr></tbody></table><p><em>如果android:dashWidth或android:dashGap</em>有任何一个为0，则虚线效果无法生效。</p><h5 id="应用代码-2"><a href="#应用代码-2" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml">//shpae.xml<span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:shape</span>=<span class="hljs-string">"rectangle"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">solid</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">"#ffffff"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">padding</span>        <span class="hljs-attr">android:bottom</span>=<span class="hljs-string">"7dp"</span>        <span class="hljs-attr">android:left</span>=<span class="hljs-string">"7dp"</span>        <span class="hljs-attr">android:right</span>=<span class="hljs-string">"7dp"</span>        <span class="hljs-attr">android:top</span>=<span class="hljs-string">"7dp"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span>        <span class="hljs-attr">android:width</span>=<span class="hljs-string">"3dp"</span>        <span class="hljs-attr">android:color</span>=<span class="hljs-string">"#FFFF00"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">corners</span>        <span class="hljs-attr">android:radius</span>=<span class="hljs-string">"3dp"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span>android:background="@drawable/shape"</code></pre><h4 id="4-LayerDrawable"><a href="#4-LayerDrawable" class="headerlink" title="4.LayerDrawable"></a>4.LayerDrawable</h4><blockquote><p>表示一种层次性的Drawable集合，通过将不同的Drawable放置在不同的层上面从而达到一种叠加的效果。</p></blockquote><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">layer-list</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    &gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">item</span>        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">""</span>        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id"</span>        <span class="hljs-attr">android:left</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:right</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:top</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:bottom</span>=<span class="hljs-string">"integer"</span> &gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layer-list</span>&gt;</span></code></pre><p><code>android:drawable</code>：引用的背景资源</p><p><code>android:id</code>：层id</p><p><code>android:top</code>：layer相对于容器的上边距</p><p><code>android:bottom</code>：layer相对于容器的下边距</p><p><code>android:left</code>：layer相对于容器的左边距</p><p><code>android:right</code>：layer相对于容器的右边距</p><p><em>Layer-list有层次的概念，下面的item会覆盖上面的item</em>。</p><h5 id="应用代码-3"><a href="#应用代码-3" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">layer-list</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bitmap</span>            <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>            <span class="hljs-attr">android:src</span>=<span class="hljs-string">"@mipmap/ic_launcher"</span>             /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span>        <span class="hljs-attr">android:left</span>=<span class="hljs-string">"20dp"</span>        <span class="hljs-attr">android:bottom</span>=<span class="hljs-string">"30dp"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bitmap</span>            <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span>            <span class="hljs-attr">android:src</span>=<span class="hljs-string">"@mipmap/ic_launcher"</span>             /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layer-list</span>&gt;</span></code></pre><h4 id="5-StateListDrawable"><a href="#5-StateListDrawable" class="headerlink" title="5.StateListDrawable"></a>5.StateListDrawable</h4><blockquote><p>对应着<code>&lt;selector&gt;</code>标签，也表示Drawable集合，每个Drawable对应着View的一种状态。</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>          <span class="hljs-attr">android:constantSize</span>=<span class="hljs-string">"[true | false]"</span>          <span class="hljs-attr">android:dither</span>=<span class="hljs-string">"[true|false]"</span>          <span class="hljs-attr">android:variablePadding</span>=<span class="hljs-string">"[true|false]"</span>          &gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">item</span>         <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">""</span>        <span class="hljs-attr">android:state_pressed</span>=<span class="hljs-string">"[true | false]"</span>        <span class="hljs-attr">android:state_focused</span>=<span class="hljs-string">"[true | false]"</span>        <span class="hljs-attr">android:state_selected</span>=<span class="hljs-string">"[true | false]"</span>        <span class="hljs-attr">android:state_hovered</span>=<span class="hljs-string">"[true | false]"</span>        <span class="hljs-attr">android:state_checked</span>=<span class="hljs-string">"[true | false]"</span>        <span class="hljs-attr">android:state_checkable</span>=<span class="hljs-string">"[true | false]"</span>        <span class="hljs-attr">android:state_enabled</span>=<span class="hljs-string">"[true | false]"</span>        <span class="hljs-attr">android:state_activated</span>=<span class="hljs-string">"[true | false]"</span>        <span class="hljs-attr">android:state_window_focused</span>=<span class="hljs-string">"[true | false]"</span>        &gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span></code></pre><p><code>android:constantSize</code>：固有大小是否不随着其状态的改变而改变。由于状态改变会导致<code>StateListDrawable</code>切换到对应的Drawable，导致大小发生变化。</p><ul><li>设置为 true  固有大小是固定值，就是所有item中的最大值</li><li>设置为 false  固有大小跟着切换的item发生变化  <em>默认值</em></li></ul><p><code>android:variblePadding</code>：<code>padding</code>是否随着状态改变而改变</p><ul><li>true <code>padding</code>随着状态改变而改变</li><li>false  <code>padding</code>是固定值，取内部所有item中padding的最大值   <em>默认值</em></li></ul><p><code>&lt;item&gt;</code></p><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>android:state_pressed</td><td>表示手指按下的状态</td></tr><tr><td>android:state_focused</td><td>表示获取焦点的状态</td></tr><tr><td>android:state_selected</td><td>表示选中的状态</td></tr><tr><td>android:state_checked</td><td>表示选中的状态。一般用与<code>CheckBox</code></td></tr><tr><td>android:state_enabled</td><td>表示当前可用的状态</td></tr></tbody></table><h5 id="应用代码-4"><a href="#应用代码-4" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_pressed</span>=<span class="hljs-string">"true"</span>        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/state_pressed"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_focused</span>=<span class="hljs-string">"true"</span>        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/state_focused"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/state_normal"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span></code></pre><h4 id="6-LevelListDrawable"><a href="#6-LevelListDrawable" class="headerlink" title="6.LevelListDrawable"></a>6.LevelListDrawable</h4><blockquote><p>表示一个Drawable集合，集合中的每一个Drawable都有<strong>等级</strong>的概念。</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">level-list</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">""</span>          <span class="hljs-attr">android:maxLevel</span>=<span class="hljs-string">"integer"</span>          <span class="hljs-attr">android:minLevel</span>=<span class="hljs-string">"integer"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">level-list</span>&gt;</span></code></pre><p><code>android:maxLevel</code>：对应的最大值，取值范围为0~10000，默认0 <em>常用该属性</em></p><p><code>android:minLevel</code>：对应的最小值，取值范围为0~10000，默认0</p><p>使用方法：无论是用xml还是代码实现</p><ul><li>作为View背景：都需要在Java代码中调用<code>setLevel()</code></li><li>作为图片前景：需要调用<code>setImageLevel()</code></li></ul><h5 id="应用代码-5"><a href="#应用代码-5" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml">//level.xml<span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">level-list</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:maxLevel</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/image1"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:maxLevel</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/image2"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">level-list</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@drawable/level"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span> <span class="hljs-attr">android:src</span>=<span class="hljs-string">"@drawable/level"</span>/&gt;</span>// 设置View背景view.setLevel(1)//设置ImageViewimageView.setImageLevel(1);</code></pre><blockquote><p>拓展：ImageView的<code>android:setBackground</code>和<code>android:src</code>有什么区别？</p><p><code>android:setBackground</code>：会根据ImageView控件的宽高去拉伸图片</p><p><code>android:src</code>：保持原图大小</p></blockquote><h4 id="7-TransitionDrawable"><a href="#7-TransitionDrawable" class="headerlink" title="7.TransitionDrawable"></a>7.TransitionDrawable</h4><blockquote><p>表示两个Drawable之间的淡入淡出效果</p></blockquote><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">item</span>        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">""</span>        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id"</span>        <span class="hljs-attr">android:left</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:right</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:top</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:bottom</span>=<span class="hljs-string">"integer"</span>        &gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span></code></pre><h5 id="应用代码-6"><a href="#应用代码-6" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml">// transition.xml<span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/bg1"</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/bg2"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@drawable/transition"</span>/&gt;</span></code></pre><pre><code class="hljs java">TransitionDrawable drawable = (TransitionDrawable)view.getBackground();drawable.startTransition(<span class="hljs-number">1000</span>); <span class="hljs-comment">//正向调用</span><span class="hljs-comment">// drawable.reverseTransition(1000);  反向调用</span></code></pre><h4 id="8-InsetDrawable"><a href="#8-InsetDrawable" class="headerlink" title="8.InsetDrawable"></a>8.InsetDrawable</h4><blockquote><p>表示把一个Drawable嵌入到另一个Drawable的内部，并在四周留一些间距</p></blockquote><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">""</span>        <span class="hljs-attr">android:visible</span>=<span class="hljs-string">"[true | false]"</span>        <span class="hljs-attr">android:insertLeft</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:insertRight</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:insertTop</span>=<span class="hljs-string">"integer"</span>        <span class="hljs-attr">android:insertBottom</span>=<span class="hljs-string">"integer"</span>        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span></code></pre><p><code>android:visible</code>：是否保留边距。默认保留</p><h5 id="应用代码-7"><a href="#应用代码-7" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">inset</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/image"</span>    <span class="hljs-attr">android:insetBottom</span>=<span class="hljs-string">"20dp"</span>    <span class="hljs-attr">android:insetLeft</span>=<span class="hljs-string">"20dp"</span>    <span class="hljs-attr">android:insetRight</span>=<span class="hljs-string">"20dp"</span>    <span class="hljs-attr">android:insetTop</span>=<span class="hljs-string">"20dp"</span>    <span class="hljs-attr">android:visible</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">inset</span>&gt;</span></code></pre><h4 id="9-ScaleDrawable"><a href="#9-ScaleDrawable" class="headerlink" title="9.ScaleDrawable"></a>9.ScaleDrawable</h4><blockquote><p>表示将Drawable缩放到一定比例</p></blockquote><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scale</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">""</span>        <span class="hljs-attr">android:scaleWidth</span>=<span class="hljs-string">"percentage"</span>        <span class="hljs-attr">android:scaleHeight</span>=<span class="hljs-string">"percentage"</span>        <span class="hljs-attr">android:scaleGravity</span>=<span class="hljs-string">"[top | bottom | left | right |        center_vertical | center_horizontal | center |        fill_vertical | fill_horizontal | fill |        clip_vertical | clip_horizontal]"</span>        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scale</span>&gt;</span></code></pre><p><code>android:scaleGravity</code>：效果同<code>android:gravity</code></p><p><code>android:scaleWidth/android:scaleHeight</code>：指定宽/高缩放比例。以百分比形式展示(<code>25%</code>)。</p><h5 id="应用代码-8"><a href="#应用代码-8" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml">// scale.xml<span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scale</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/drawable_test"</span>    <span class="hljs-attr">android:scaleGravity</span>=<span class="hljs-string">"center"</span>    <span class="hljs-attr">android:scaleHeight</span>=<span class="hljs-string">"70%"</span>    <span class="hljs-attr">android:scaleWidth</span>=<span class="hljs-string">"70%"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@drawable/scale"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ImageView</span>&gt;</span></code></pre><pre><code class="hljs java">ScaleDrawable scaleDrawable = (ScaleDrawable) imageView.getDrawable();scaleDrawable.setLevel(<span class="hljs-number">1</span>);</code></pre><p><code>setLevel</code>填值不可以为0，取值范围为<code>0~10000</code>，0表示不可见。</p><h4 id="10-ClipDrawable"><a href="#10-ClipDrawable" class="headerlink" title="10.ClipDrawable"></a>10.ClipDrawable</h4><blockquote><p>表示裁剪一个Drawable</p></blockquote><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">clip</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">""</span>        <span class="hljs-attr">android:clipOrientation</span>=<span class="hljs-string">"[horizonal | vertical]"</span>        <span class="hljs-attr">android:scaleGravity</span>=<span class="hljs-string">"[top | bottom | left | right |        center_vertical | center_horizontal | center |        fill_vertical | fill_horizontal | fill |        clip_vertical | clip_horizontal]"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">clip</span>&gt;</span></code></pre><p><code>android:clipOrientation</code>：表示裁剪方向 可选值为 <code>horizonal 水平</code>，<code>vertical 竖直</code></p><p><code>android:gravity</code>：表示对齐方式<br>|      可选项       |                             含义                             |<br>| :—————: | :———————————————————-: |<br>|        top        | 放在容器的顶部，不改变大小<br>若为竖直裁剪，则从底部开始裁剪 |<br>|      bottom       | 放在容器的底部，不改变大小<br>若为竖直裁剪，则从顶部开始裁剪 |<br>|       left        | 放在容器的左边，不改变大小<br>若为水平裁剪，则从右部开始裁剪 |<br>|       right       | 放在容器的右边，不改变大小<br>若为水平裁剪，则从左边开始裁剪 |<br>|  center_vertical  | 放在容器的竖直居中，不改变大小<br>若为竖直裁剪，则从上下开始裁剪 |<br>|   fill_vertical   |  竖直方向填充容器<br>若为竖直裁剪，仅当level为0才开始裁剪   |<br>| center_horizontal | 放在容器的水平居中，不改变大小<br>若为水平裁剪，则从左右同时开始裁剪 |<br>|  fill_horizontal  |  水平方向填充容器<br>若为水平裁剪，仅当level为0才开始裁剪   |<br>|      center       | 放在容器的中心，不改变大小<br>若为竖直裁剪，则从上下开始裁剪<br>若为水平裁剪，则从左右开始裁剪 |<br>|       fill        | 放在容器的顶部，不改变大小<br>若为竖直裁剪，则从底部开始裁剪* |<br>|   clip_vertical   |                       竖直方向进行裁剪                       |<br>|  clip_horizontal  |                       水平方向进行裁剪                       |</p><h5 id="应用代码-9"><a href="#应用代码-9" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml">// clip.xml<span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">clip</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>        <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/bg1"</span>        <span class="hljs-attr">android:clipOrientation</span>=<span class="hljs-string">"vertical"</span>        <span class="hljs-attr">android:scaleGravity</span>=<span class="hljs-string">"bottom"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">clip</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span>            <span class="hljs-attr">android:backgrounf</span>=<span class="hljs-string">"@drawable/clip"</span>/&gt;</span></code></pre><pre><code class="hljs java">ClipDrawable clipDrawable = (ClipDrawable) imageView.getDrawable();clipDrawable.setLevel(<span class="hljs-number">5000</span>)</code></pre><p><code>setLevel()</code>数值范围为<code>0~10000</code>，0代表完全裁剪，8000代表裁剪20%</p><h4 id="11-RotateDrawable"><a href="#11-RotateDrawable" class="headerlink" title="11.RotateDrawable"></a>11.RotateDrawable</h4><blockquote><p>表示旋转Drawable</p></blockquote><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rotate</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">""</span>    <span class="hljs-attr">android:fromDegrees</span>=<span class="hljs-string">"integer"</span>    <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">"percentage"</span>    <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">"percentage"</span>    <span class="hljs-attr">android:toDegrees</span>=<span class="hljs-string">"integer"</span>    <span class="hljs-attr">android:visible</span>=<span class="hljs-string">"[true | false]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rotate</span>&gt;</span></code></pre><p><code>android:fromDegrees</code> RotateDrawable实例起始角度,大于0是顺时针旋转,小于0是逆时针旋转;<br><code>android:toDegrees</code> RotateDrawable实例最终角度,大于0是顺时针旋转,小于0是逆时针旋转;<br><code>android:pivotX</code> RotateDrawable实例旋转中心点X轴坐标相对自身位置;<br><code>android:pivotY</code> RotateDrawable实例旋转中心点Y轴坐标相对自身位置;</p><h5 id="应用代码-10"><a href="#应用代码-10" class="headerlink" title="应用代码"></a>应用代码</h5><pre><code class="hljs xml">//rotate.xml<span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">rotate</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@mipmap/rotate_round"</span>    <span class="hljs-attr">android:fromDegrees</span>=<span class="hljs-string">"0"</span>    <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">"50%"</span>    <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">"50%"</span>    <span class="hljs-attr">android:toDegrees</span>=<span class="hljs-string">"360"</span>    <span class="hljs-attr">android:visible</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rotate</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@drawable/rotate"</span></span></code></pre><pre><code class="hljs java">RotateDrawable rotateDrawable = (RotateDrawable) view.getDrawable();rotateDrawable.setLevel(<span class="hljs-number">5000</span>) <span class="hljs-comment">//设置旋转角度 0~10000  ==  0~360</span></code></pre><h3 id="自定义Drawable"><a href="#自定义Drawable" class="headerlink" title="自定义Drawable"></a>自定义Drawable</h3><blockquote><p>需要去复合实现 Drawable 效果。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//自定义Drawable</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomDrawable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Drawable</span> </span>&#123;       <span class="hljs-keyword">private</span> Paint mPaint;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomDrawable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> color)</span> </span>&#123;        mPaint = <span class="hljs-keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);        mPaint.setColor(color);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;        <span class="hljs-keyword">final</span> Rect rect =  getBounds();        <span class="hljs-keyword">float</span> cx = rect.exactCenterX();        <span class="hljs-keyword">float</span> cy = rect.exactCenterY();        canvas.drawCircle(cx, cy, Math.min(cx, cy), mPaint);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAlpha</span><span class="hljs-params">(<span class="hljs-keyword">int</span> alpha)</span> </span>&#123;        mPaint.setAlpha(alpha);        invalidateSelf();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setColorFilter</span><span class="hljs-params">(ColorFilter colorFilter)</span> </span>&#123;        mPaint.setColorFilter(colorFilter);        invalidateSelf();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOpacity</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> PixelFormat.TRANSLUCENT;    &#125;&#125;</code></pre><p>需要实现自定义Drawable的话，就必须要实现<code>draw(),setAlpha(),setColorFilter(),getOpacity()</code>这几个方法。</p><p>如果自定义的Drawable设置了固有大小，最好重写<code>getInstrinsicWidrh()和getInstrinsicHeight()</code>，因为会影响到<code>wrap_content</code>属性。</p><h3 id="Drawable相关"><a href="#Drawable相关" class="headerlink" title="Drawable相关"></a>Drawable相关</h3><ol><li><p>android中的dp、px、dip、sp，dpi相关概念</p><p><code>px</code>：就是像素单位，例如手机分辨率<code>1080*1920</code>单位就是px</p><p><code>dp</code>：设备独立像素，不同的设备有不同的效果，在不同的像素密度的设备上会自动适配</p><p><code>dpi</code>：每英寸像素树，有设备决定是固定的。计算方法：<code>横向分辨率/横向英寸数</code></p><p><code>sp</code>：同dp相似，<em>会根据用户的字体大小偏好进行缩放</em></p></li><li><p>Drawable文件过多如何整理</p><ul><li><p>自定义View，实现常用的Drawable属性</p></li><li><p><a href="https://github.com/JavaNoober/BackgroundLibrary" target="_blank" rel="noopener">参考该库</a> </p><p>给LayoutInflater添加了一个LayoutInflater.Factory类。而Android的Activity在创建过程（也就是<code>setContentView</code>）中实际上是通过把xml转换成View的对象。而LayoutInflater.Factory相当于这中间的一个后门，它是xml解析创建成View的必经方法，google中的v7support包里很多内容就是通过LayoutInflater.Factory来实现向下兼容的。，加入一个自定义的LayoutInflater.Factory，去解析添加的自定义属性，</p></li></ul></li></ol><h2 id="Drawable原理"><a href="#Drawable原理" class="headerlink" title="Drawable原理"></a>Drawable原理</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Service工作过程</title>
    <link href="/2019/01/10/Service%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/01/10/Service%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Service基础知识"><a href="#Service基础知识" class="headerlink" title="Service基础知识"></a>Service基础知识</h2><a href="/2018/03/18/Android-Study-Plan-II/" title="Android Study Plan II - Service">Android Study Plan II - Service</a><h2 id="Service工作过程"><a href="#Service工作过程" class="headerlink" title="Service工作过程"></a>Service工作过程</h2><p>Service分为两种工作状态，一种是<code>启动状态</code>，主要用于执行后台计算；另一种是<code>绑定状态</code>，主要用于其他组件和Service的交互。</p><p>Service的这两种状态是可以共存的，即Service既可以处于启动状态也可以同时处于绑定状态。</p><pre><code class="hljs java"><span class="hljs-comment">//启动Service</span>Intent intent= <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;startService(intent);<span class="hljs-comment">//绑定Service</span>Intent intent= <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,MyService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;bindService(intent,mServiceConnection,BIND_AUTO_CREATE);</code></pre><h3 id="Service启动过程-startService"><a href="#Service启动过程-startService" class="headerlink" title="Service启动过程 - startService"></a>Service启动过程 - startService</h3><p>Service的启动过程从<code>ContextWrapper.startService()</code>开始</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/content/ContextWrapper.java</span>    Context mBase;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ComponentName <span class="hljs-title">startService</span><span class="hljs-params">(Intent service)</span> </span>&#123;        <span class="hljs-keyword">return</span> mBase.startService(service);    &#125;</code></pre><p>在Activity启动的时候<code>performLaunActivity</code>时，会创建上下文对象<code>Context</code>，然后在<code>Activity.attach()</code>调用了<code>attachBaseContext()</code>将得到的contenxt进行赋值。最终操作的就是<code>ContextImpl</code>。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ContextImpl.jsvs</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ComponentName <span class="hljs-title">startService</span><span class="hljs-params">(Intent service)</span> </span>&#123;        warnIfCallingFromSystemProcess();        <span class="hljs-keyword">return</span> startServiceCommon(service, <span class="hljs-keyword">false</span>, mUser);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ComponentName <span class="hljs-title">startServiceCommon</span><span class="hljs-params">(Intent service, <span class="hljs-keyword">boolean</span> requireForeground,            UserHandle user)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            validateServiceIntent(service);            service.prepareToLeaveProcess(<span class="hljs-keyword">this</span>);            <span class="hljs-comment">//启动Service</span>            ComponentName cn = ActivityManager.getService().startService(                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(                            getContentResolver()), requireForeground,                            getOpPackageName(), user.getIdentifier());            <span class="hljs-keyword">if</span> (cn != <span class="hljs-keyword">null</span>) &#123;                 ...            &#125;            <span class="hljs-keyword">return</span> cn;        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;            <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();        &#125;    &#125;</code></pre><p><code>ActivityManager.getService()</code>在Activity启动过程中有介绍它是得到<code>IActiivtyManager</code>实际就是指向<code>AMS</code>的一个Binder对象，调用到的就是<code>AMS.startService()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityManagerService.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ComponentName <span class="hljs-title">startService</span><span class="hljs-params">(IApplicationThread caller, Intent service,            String resolvedType, <span class="hljs-keyword">boolean</span> requireForeground, String callingPackage, <span class="hljs-keyword">int</span> userId)</span>            <span class="hljs-keyword">throws</span> TransactionTooLargeException </span>&#123;        enforceNotIsolatedCaller(<span class="hljs-string">"startService"</span>);        <span class="hljs-comment">// Refuse possible leaked file descriptors</span>        <span class="hljs-keyword">if</span> (service != <span class="hljs-keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"File descriptors passed in Intent"</span>);        &#125;        <span class="hljs-keyword">if</span> (callingPackage == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"callingPackage cannot be null"</span>);        &#125;        <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,                <span class="hljs-string">"*** startService: "</span> + service + <span class="hljs-string">" type="</span> + resolvedType + <span class="hljs-string">" fg="</span> + requireForeground);        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> callingPid = Binder.getCallingPid();            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> callingUid = Binder.getCallingUid();            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> origId = Binder.clearCallingIdentity();            ComponentName res;            <span class="hljs-keyword">try</span> &#123;                res = mServices.startServiceLocked(caller, service,                        resolvedType, callingPid, callingUid,                        requireForeground, callingPackage, userId);            &#125; <span class="hljs-keyword">finally</span> &#123;                Binder.restoreCallingIdentity(origId);            &#125;            <span class="hljs-keyword">return</span> res;        &#125;    &#125;</code></pre><p><code>mServices</code>的类型是<code>ActiveServices</code>.<em><code>ActiveServices</code>是一个辅助<code>AMS</code>进行Service管理的类，其中包括Service的启动，绑定和停止等功能。</em></p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActiveServices.java</span><span class="hljs-function">ComponentName <span class="hljs-title">startServiceLocked</span><span class="hljs-params">(IApplicationThread caller, Intent service, String resolvedType,            <span class="hljs-keyword">int</span> callingPid, <span class="hljs-keyword">int</span> callingUid, <span class="hljs-keyword">boolean</span> fgRequired, String callingPackage, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> userId)</span>            <span class="hljs-keyword">throws</span> TransactionTooLargeException </span>&#123;   ...        <span class="hljs-comment">//去查找是否有与参数 service 对应的ServiceRecord。</span>        ServiceLookupResult res =            retrieveServiceLocked(service, resolvedType, callingPackage,                    callingPid, callingUid, userId, <span class="hljs-keyword">true</span>, callerFg, <span class="hljs-keyword">false</span>);        <span class="hljs-keyword">if</span> (res == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (res.record == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ComponentName(<span class="hljs-string">"!"</span>, res.permission != <span class="hljs-keyword">null</span>                    ? res.permission : <span class="hljs-string">"private to package"</span>);        &#125;        <span class="hljs-comment">//封装一个ServiceRecord对象</span>        ServiceRecord r = res.record;   ...          ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting); &#125;</code></pre><p><code>ServiceRecord</code>描述的是一个Service记录，一直贯穿着整个Service的启动过程。</p><pre><code class="hljs java"><span class="hljs-function">ComponentName <span class="hljs-title">startServiceInnerLocked</span><span class="hljs-params">(ServiceMap smap, Intent service, ServiceRecord r,        <span class="hljs-keyword">boolean</span> callerFg, <span class="hljs-keyword">boolean</span> addToStarting)</span> <span class="hljs-keyword">throws</span> TransactionTooLargeException </span>&#123;    ...    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);    <span class="hljs-keyword">if</span> (error != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ComponentName(<span class="hljs-string">"!!"</span>, error);    &#125;    ...    <span class="hljs-keyword">return</span> r.name;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">bringUpServiceLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-keyword">int</span> intentFlags, <span class="hljs-keyword">boolean</span> execInFg,        <span class="hljs-keyword">boolean</span> whileRestarting, <span class="hljs-keyword">boolean</span> permissionsReviewRequired)</span>        <span class="hljs-keyword">throws</span> TransactionTooLargeException </span>&#123;  ...    <span class="hljs-comment">//获取Service想在那个进程中运行  process</span>    <span class="hljs-keyword">final</span> String procName = r.processName;    String hostingType = <span class="hljs-string">"service"</span>;    ProcessRecord app;    <span class="hljs-comment">//当前不止一个进程</span>    <span class="hljs-keyword">if</span> (!isolated) &#123;        <span class="hljs-comment">//查询是否存在一个 与Service类型对应的ProcessRecord对象的app进程</span>        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="hljs-keyword">false</span>);        <span class="hljs-keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="hljs-string">"bringUpServiceLocked: appInfo.uid="</span> + r.appInfo.uid                    + <span class="hljs-string">" app="</span> + app);        <span class="hljs-comment">//Service的运行进程已经存在</span>        <span class="hljs-keyword">if</span> (app != <span class="hljs-keyword">null</span> &amp;&amp; app.thread != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);                <span class="hljs-comment">//启动service</span>                realStartServiceLocked(r, app, execInFg);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125; <span class="hljs-keyword">catch</span> (TransactionTooLargeException e) &#123;                <span class="hljs-keyword">throw</span> e;            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                Slog.w(TAG, <span class="hljs-string">"Exception when starting service "</span> + r.shortName, e);            &#125;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        app = r.isolatedProc;        <span class="hljs-keyword">if</span> (WebViewZygote.isMultiprocessEnabled()                &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123;            hostingType = <span class="hljs-string">"webview_service"</span>;        &#125;    &#125;    <span class="hljs-comment">//没有对应的运行进程启动</span>    <span class="hljs-keyword">if</span> (app == <span class="hljs-keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123;        <span class="hljs-comment">//需要新启动一个应用进程 承载Service</span>        <span class="hljs-keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="hljs-keyword">true</span>, intentFlags,                hostingType, r.name, <span class="hljs-keyword">false</span>, isolated, <span class="hljs-keyword">false</span>)) == <span class="hljs-keyword">null</span>) &#123;            String msg = <span class="hljs-string">"Unable to launch app "</span>                    + r.appInfo.packageName + <span class="hljs-string">"/"</span>                    + r.appInfo.uid + <span class="hljs-string">" for service "</span>                    + r.intent.getIntent() + <span class="hljs-string">": process is bad"</span>;            Slog.w(TAG, msg);            bringDownServiceLocked(r);            <span class="hljs-keyword">return</span> msg;        &#125;        <span class="hljs-keyword">if</span> (isolated) &#123;            r.isolatedProc = app;        &#125;    &#125;  ...&#125;</code></pre><p>在<code>bringUpServiceLocked()</code>中，优先获取<code>Service需要的运行进程--通过android:process设置</code>，然后去判断当前进程中是否存在符合要求的</p><ul><li>不存在，调用<code>AMS.startProcessLocked()</code>去新建对应应用进程，这个函数在Activity启动过程中有讲解</li><li>存在，直接调用<code>realStartServiceLocked()</code>去启动Service，<em>命名方法类似Activity启动过程中的<code>realStartActivityLocked()</code></em></li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">realStartServiceLocked</span><span class="hljs-params">(ServiceRecord r,        ProcessRecord app, <span class="hljs-keyword">boolean</span> execInFg)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;  ...    <span class="hljs-keyword">boolean</span> created = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">try</span> &#123;      ...        app.thread.scheduleCreateService(r, r.serviceInfo,                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),                app.repProcState);        r.postNotification();        created = <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">catch</span> (DeadObjectException e) &#123;        Slog.w(TAG, <span class="hljs-string">"Application dead when creating service "</span> + r);        mAm.appDiedLocked(app);        <span class="hljs-keyword">throw</span> e;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (!created) &#123;            <span class="hljs-comment">// Keep the executeNesting count accurate.</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);            serviceDoneExecutingLocked(r, inDestroying, inDestroying);            <span class="hljs-comment">// Cleanup.</span>            <span class="hljs-keyword">if</span> (newService) &#123;                app.services.remove(r);                r.app = <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-comment">// Retry.</span>            <span class="hljs-keyword">if</span> (!inDestroying) &#123;                scheduleServiceRestartLocked(r, <span class="hljs-keyword">false</span>);            &#125;        &#125;    &#125;    ...    <span class="hljs-comment">//由于 必须startRequested 参数为true</span>    <span class="hljs-keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="hljs-number">0</span>) &#123;        r.pendingStarts.add(<span class="hljs-keyword">new</span> ServiceRecord.StartItem(r, <span class="hljs-keyword">false</span>, r.makeNextStartId(),                <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>));    &#125;    <span class="hljs-comment">//调用Service中的其他方法，例如 onStartCommand</span>    sendServiceArgsLocked(r, execInFg, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendServiceArgsLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-keyword">boolean</span> execInFg,        <span class="hljs-keyword">boolean</span> oomAdjusted)</span> <span class="hljs-keyword">throws</span> TransactionTooLargeException </span>&#123;  ...    <span class="hljs-comment">//通知ActivityThread初始化已经完成，然后调用后续方法</span>    r.app.thread.scheduleServiceArgs(r, slice);  ...&#125;</code></pre><p><code>app.thread</code>是<code>IApplicationThread</code>类型的，实际上是一个Binder对象，它的实现是<code>ApplicationThread</code>，用于和<code>ActivityThread</code>进行通信。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java       </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleCreateService</span><span class="hljs-params">(IBinder token,                ServiceInfo info, CompatibilityInfo compatInfo, <span class="hljs-keyword">int</span> processState)</span> </span>&#123;            updateProcessState(processState, <span class="hljs-keyword">false</span>);            CreateServiceData s = <span class="hljs-keyword">new</span> CreateServiceData();            s.token = token;            s.info = info;            s.compatInfo = compatInfo;            sendMessage(H.CREATE_SERVICE, s);        &#125;</code></pre><p>这里与<code>Activity启动过程</code>是一致的，通过<code>ActivityThread.H</code>这个Handler对象发送消息，切换到主线程去处理消息。这个发送的是<code>CREATE_SERVICE</code>，最后调用到了<code>ActivityThread.handleCreateService()</code>去启动Service</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> ArrayMap&lt;IBinder, Service&gt; mServices = <span class="hljs-keyword">new</span> ArrayMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleCreateService</span><span class="hljs-params">(CreateServiceData data)</span> </span>&#123;        <span class="hljs-comment">// If we are getting ready to gc after going to the background, well</span>        <span class="hljs-comment">// we are back active so skip it.</span>        unscheduleGcIdler();        <span class="hljs-comment">//获取LoaderApk对象 是一个Apk文件的描述器</span>        LoadedApk packageInfo = getPackageInfoNoCheck(                data.info.applicationInfo, data.compatInfo);        Service service = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            java.lang.ClassLoader cl = packageInfo.getClassLoader();            service = (Service) cl.loadClass(data.info.name).newInstance();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                    <span class="hljs-string">"Unable to instantiate service "</span> + data.info.name                    + <span class="hljs-string">": "</span> + e.toString(), e);            &#125;        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">"Creating service "</span> + data.info.name);            <span class="hljs-comment">//创建Service的ContextImpl对象</span>            ContextImpl context = ContextImpl.createAppContext(<span class="hljs-keyword">this</span>, packageInfo);            context.setOuterContext(service);            Application app = packageInfo.makeApplication(<span class="hljs-keyword">false</span>, mInstrumentation);            <span class="hljs-comment">//初始化Service</span>            service.attach(context, <span class="hljs-keyword">this</span>, data.info.name, data.token, app,                    ActivityManager.getService());            <span class="hljs-comment">//调用 onCreate 生命周期</span>            service.onCreate();            mServices.put(data.token, service);            <span class="hljs-keyword">try</span> &#123;                ActivityManager.getService().serviceDoneExecuting(                        data.token, SERVICE_DONE_EXECUTING_ANON, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                    <span class="hljs-string">"Unable to create service "</span> + data.info.name                    + <span class="hljs-string">": "</span> + e.toString(), e);            &#125;        &#125;    &#125;</code></pre><p><code>handleCreateService()</code>执行了以下的几件事：</p><ul><li>通过类加载器创建<code>Service</code>实例，<em>Actiivty启动过程是利用了 Instrumention.newActivity() 执行相同创建实例</em></li><li><code>makeApplication()</code>创建<code>Application</code>对象并调用其<code>onCreate</code></li><li>创建<code>ContextImpl</code>对象并调用<code>Service.attach()</code>建立关系</li><li>最后调用<code>Service.onCreate()</code>开始创建过程，并存储至<code>ArrayMap&lt;IBinder,Service&gt;</code>中，在下一节会介绍这里存储数据的作用</li><li>调用<code>onCreate()</code>之后，Service也已经启动了。</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Service启动过程.png" srcset="/img/loading.gif" class="full-image" alt="Service启动过程" title="Service启动过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="Service绑定过程-bindService"><a href="#Service绑定过程-bindService" class="headerlink" title="Service绑定过程 - bindService"></a>Service绑定过程 - bindService</h3><p>和Service的启动过程一样，Service的绑定过程也是从<code>ContextWrapper</code>开始</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/content/ContextWrapper.java    </span><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">bindService</span><span class="hljs-params">(Intent service, ServiceConnection conn,            <span class="hljs-keyword">int</span> flags)</span> </span>&#123;        <span class="hljs-keyword">return</span> mBase.bindService(service, conn, flags);    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ContextImpl.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">bindService</span><span class="hljs-params">(Intent service, ServiceConnection conn,            <span class="hljs-keyword">int</span> flags)</span> </span>&#123;        warnIfCallingFromSystemProcess();        <span class="hljs-keyword">return</span> bindServiceCommon(service, conn, flags, mMainThread.getHandler(),                Process.myUserHandle());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">bindServiceCommon</span><span class="hljs-params">(Intent service, ServiceConnection conn, <span class="hljs-keyword">int</span> flags, Handler            handler, UserHandle user)</span> </span>&#123;        IServiceConnection sd;        <span class="hljs-keyword">if</span> (conn == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"connection is null"</span>);        &#125;        <span class="hljs-keyword">if</span> (mPackageInfo != <span class="hljs-keyword">null</span>) &#123;            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Not supported in system context"</span>);        &#125;        validateServiceIntent(service);        <span class="hljs-keyword">try</span> &#123;           ...            service.prepareToLeaveProcess(<span class="hljs-keyword">this</span>);            <span class="hljs-keyword">int</span> res = ActivityManager.getService().bindService(                mMainThread.getApplicationThread(), getActivityToken(), service,                service.resolveTypeIfNeeded(getContentResolver()),                sd, flags, getOpPackageName(), user.getIdentifier());            <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(                        <span class="hljs-string">"Not allowed to bind to service "</span> + service);            &#125;            <span class="hljs-keyword">return</span> res != <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;            <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();        &#125;    &#125;</code></pre><p>在<code>bindServiceCommon()</code>主要做了两件事情：</p><ul><li><p><code>getServiceDispatcher()</code> 将传进来的<code>ServiceConnection</code>转化成<code>IServiceConnection</code>，通过Binder对象进行通信。使得Service的绑定支持跨进程调用。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/LoaderApk.java    </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> IServiceConnection <span class="hljs-title">getServiceDispatcher</span><span class="hljs-params">(ServiceConnection c,            Context context, Handler handler, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (mServices) &#123;            LoadedApk.ServiceDispatcher sd = <span class="hljs-keyword">null</span>;            ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);            <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (DEBUG) Slog.d(TAG, <span class="hljs-string">"Returning existing dispatcher "</span> + sd + <span class="hljs-string">" for conn "</span> + c);                sd = map.get(c);            &#125;            <span class="hljs-keyword">if</span> (sd == <span class="hljs-keyword">null</span>) &#123;                sd = <span class="hljs-keyword">new</span> ServiceDispatcher(c, context, handler, flags);                <span class="hljs-keyword">if</span> (DEBUG) Slog.d(TAG, <span class="hljs-string">"Creating new dispatcher "</span> + sd + <span class="hljs-string">" for conn "</span> + c);                <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span>) &#123;                    map = <span class="hljs-keyword">new</span> ArrayMap&lt;&gt;();                    mServices.put(context, map);                &#125;                map.put(c, sd);            &#125; <span class="hljs-keyword">else</span> &#123;                sd.validate(context, handler);            &#125;            <span class="hljs-keyword">return</span> sd.getIServiceConnection();        &#125;    &#125;</code></pre><p><code>mServices</code>存储了一个应用当前活动的<code>ServiceConnection和ServiceDispatcher</code>的映射关系。<code>ServiceDispatcher</code>的作用是<em>连接ServiceConnection和IServiceConnection。</em></p></li><li><p><code>bindService()</code>开始Service的绑定流程</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityManagerService.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bindService</span><span class="hljs-params">(IApplicationThread caller, IBinder token, Intent service,            String resolvedType, IServiceConnection connection, <span class="hljs-keyword">int</span> flags, String callingPackage,            <span class="hljs-keyword">int</span> userId)</span> <span class="hljs-keyword">throws</span> TransactionTooLargeException </span>&#123;        enforceNotIsolatedCaller(<span class="hljs-string">"bindService"</span>);        <span class="hljs-comment">// Refuse possible leaked file descriptors</span>        <span class="hljs-keyword">if</span> (service != <span class="hljs-keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"File descriptors passed in Intent"</span>);        &#125;        <span class="hljs-keyword">if</span> (callingPackage == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"callingPackage cannot be null"</span>);        &#125;        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">return</span> mServices.bindServiceLocked(caller, token, service,                    resolvedType, connection, flags, callingPackage, userId);        &#125;    &#125;</code></pre></li></ul><p>存储好对应的<code>ServiceConnection</code>和<code>ServiceDispatcher</code>映射的关系，之后开始继续绑定流程</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActiveServices.java</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bindServiceLocked</span><span class="hljs-params">(IApplicationThread caller, IBinder token, Intent service,            String resolvedType, <span class="hljs-keyword">final</span> IServiceConnection connection, <span class="hljs-keyword">int</span> flags,            String callingPackage, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> userId)</span> <span class="hljs-keyword">throws</span> TransactionTooLargeException </span>&#123;        <span class="hljs-comment">// 获取应用进程信息  </span>        <span class="hljs-keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);        <span class="hljs-keyword">if</span> (callerApp == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(                    <span class="hljs-string">"Unable to find app for caller "</span> + caller                    + <span class="hljs-string">" (pid="</span> + Binder.getCallingPid()                    + <span class="hljs-string">") when binding service "</span> + service);        &#125;        <span class="hljs-comment">//获取绑定Activity信息</span>        ActivityRecord activity = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (token != <span class="hljs-keyword">null</span>) &#123;            activity = ActivityRecord.isInStackLocked(token);            <span class="hljs-keyword">if</span> (activity == <span class="hljs-keyword">null</span>) &#123;                Slog.w(TAG, <span class="hljs-string">"Binding with unknown activity: "</span> + token);                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-comment">//获取Service相关信息</span>        ServiceRecord s = res.record;        <span class="hljs-comment">//启动Activity成功后 ，再启动Service</span>        <span class="hljs-keyword">if</span> (mAm.mPermissionReviewRequired) &#123;            <span class="hljs-keyword">if</span> (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(                    s.packageName, s.userId)) &#123;              RemoteCallback callback = <span class="hljs-keyword">new</span> RemoteCallback(                        <span class="hljs-keyword">new</span> RemoteCallback.OnResultListener() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResult</span><span class="hljs-params">(Bundle result)</span> </span>&#123;                        <span class="hljs-keyword">synchronized</span>(mAm) &#123;                            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> identity = Binder.clearCallingIdentity();                            <span class="hljs-keyword">try</span> &#123;                                ...                                <span class="hljs-keyword">if</span> (...) &#123;                                    <span class="hljs-keyword">try</span> &#123;                                        <span class="hljs-comment">// 启动 Service</span>                                        bringUpServiceLocked(...);                                    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                                        <span class="hljs-comment">/* ignore - local call */</span>                                    &#125;                                &#125; <span class="hljs-keyword">else</span> &#123;                                    ...                                &#125;                            &#125; <span class="hljs-keyword">finally</span> &#123;                                ...                            &#125;                        &#125;                    &#125;                &#125;);                <span class="hljs-keyword">final</span> Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_REVIEW_PERMISSIONS);                <span class="hljs-comment">// 注意 callback</span>                intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback);                                <span class="hljs-comment">// 启动 Activity，成功启动后回调 callback </span>                mAm.mHandler.post(<span class="hljs-keyword">new</span> Runnable() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                        mAm.mContext.startActivityAsUser(intent, <span class="hljs-keyword">new</span> UserHandle(userId));                    &#125;                &#125;);            &#125;        &#125;      <span class="hljs-keyword">try</span>&#123;        <span class="hljs-comment">// 如果设置了绑定后自动启动</span>        <span class="hljs-keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="hljs-number">0</span>) &#123;                 s.lastActivity = SystemClock.uptimeMillis();                <span class="hljs-comment">// 启动 Service</span>                <span class="hljs-keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="hljs-keyword">false</span>,                        permissionsReviewRequired) != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                &#125;           &#125;            <span class="hljs-comment">// Service 已经在运行中，直接回调 onServiceConnected 即可</span>            <span class="hljs-keyword">if</span> (s.app != <span class="hljs-keyword">null</span> &amp;&amp; b.intent.received) &#123;                 <span class="hljs-comment">// Service is already running, so we can immediately</span>                <span class="hljs-comment">// publish the connection.</span>                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 回调 onServiceConnected</span>                    c.conn.connected(s.name, b.intent.binder, <span class="hljs-keyword">false</span>);                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    ...                &#125;                <span class="hljs-comment">//</span>                <span class="hljs-keyword">if</span> (b.intent.apps.size() == <span class="hljs-number">1</span> &amp;&amp; b.intent.doRebind) &#123;                    requestServiceBindingLocked(s, b.intent, callerFg, <span class="hljs-keyword">true</span>);                &#125;                ...                  <span class="hljs-comment">//没有进行过绑定Service请求</span>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!b.intent.requested) &#123;                 <span class="hljs-comment">// 回调 onBind，内部调用了 scheduleBindService</span>                requestServiceBindingLocked(s, b.intent, callerFg, <span class="hljs-keyword">false</span>);            &#125;        ...      &#125; <span class="hljs-keyword">finally</span> &#123;         Binder.restoreCallingIdentity(origId);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;</code></pre><blockquote><p>介绍几个与Service有关的对象类型：</p><ul><li>ServiceRecord：描述一个Service</li><li>ProcessREcord：描述一个进程的信息</li><li>ConnectionRecord：描述应用程序进程和Service建立的一次通信。</li><li>AppBindRecord：维护Srvice与应用程序进程之间的关联。</li><li>IntentBindRecord：描述绑定Service的Intent</li></ul></blockquote><p><code>bindServiceLocked()</code>内部会通过<code>bringUpServiceLocked()</code>自动启动Service。然后向下走<code>启动Service流程</code>。</p><p>还会多调用一个<code>requestServiceBindingLocked()</code>请求绑定过程</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActiveServices.java</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">requestServiceBindingLocked</span><span class="hljs-params">(ServiceRecord r, IntentBindRecord i,            <span class="hljs-keyword">boolean</span> execInFg, <span class="hljs-keyword">boolean</span> rebind<span class="hljs-comment">/*是否重新绑定*/</span>)</span> <span class="hljs-keyword">throws</span> TransactionTooLargeException </span>&#123;        <span class="hljs-keyword">if</span> (r.app == <span class="hljs-keyword">null</span> || r.app.thread == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// If service is not currently running, can't yet bind.</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.d(TAG_SERVICE, <span class="hljs-string">"requestBind "</span> + i + <span class="hljs-string">": requested="</span> + i.requested                + <span class="hljs-string">" rebind="</span> + rebind);        <span class="hljs-comment">//是否发送过 绑定Service的请求 </span>        <span class="hljs-keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                bumpServiceExecutingLocked(r, execInFg, <span class="hljs-string">"bind"</span>);                r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,                        r.app.repProcState);                <span class="hljs-keyword">if</span> (!rebind) &#123;                    i.requested = <span class="hljs-keyword">true</span>;                &#125;                i.hasBound = <span class="hljs-keyword">true</span>;                i.doRebind = <span class="hljs-keyword">false</span>;            &#125; <span class="hljs-keyword">catch</span> (... ) &#123;<span class="hljs-comment">//最大通常限制为1M.</span>               ...            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><p><code>app.thread</code>把逻辑切换到了 <code>ActivityThread</code>中了</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java       </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleBindService</span><span class="hljs-params">(IBinder token, Intent intent,                <span class="hljs-keyword">boolean</span> rebind, <span class="hljs-keyword">int</span> processState)</span> </span>&#123;            updateProcessState(processState, <span class="hljs-keyword">false</span>);            BindServiceData s = <span class="hljs-keyword">new</span> BindServiceData();            s.token = token;            s.intent = intent;            s.rebind = rebind;            <span class="hljs-keyword">if</span> (DEBUG_SERVICE)                Slog.v(TAG, <span class="hljs-string">"scheduleBindService token="</span> + token + <span class="hljs-string">" intent="</span> + intent + <span class="hljs-string">" uid="</span>                        + Binder.getCallingUid() + <span class="hljs-string">" pid="</span> + Binder.getCallingPid());            sendMessage(H.BIND_SERVICE, s);        &#125;<span class="hljs-comment">// 处理绑定Service流程</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleBindService</span><span class="hljs-params">(BindServiceData data)</span> </span>&#123;        <span class="hljs-comment">//获取要绑定的Service对象</span>        Service s = mServices.get(data.token);        <span class="hljs-keyword">if</span> (DEBUG_SERVICE)            Slog.v(TAG, <span class="hljs-string">"handleBindService s="</span> + s + <span class="hljs-string">" rebind="</span> + data.rebind);        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                data.intent.setExtrasClassLoader(s.getClassLoader());                data.intent.prepareToEnterProcess();                <span class="hljs-keyword">try</span> &#123;                   <span class="hljs-comment">//绑定Service</span>                    <span class="hljs-keyword">if</span> (!data.rebind) &#123;                        <span class="hljs-comment">//调用 onBind 方法，此时已绑定Service</span>                        IBinder binder = s.onBind(data.intent);                        <span class="hljs-comment">//通知绑定成功</span>                        ActivityManager.getService().publishService(                                data.token, data.intent, binder);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">//执行重新绑定流程</span>                        s.onRebind(data.intent);                        ActivityManager.getService().serviceDoneExecuting(                                data.token, SERVICE_DONE_EXECUTING_ANON, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);                    &#125;                    ensureJitEnabled();                &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;                    <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                            <span class="hljs-string">"Unable to bind to service "</span> + s                            + <span class="hljs-string">" with "</span> + data.intent + <span class="hljs-string">": "</span> + e.toString(), e);                &#125;            &#125;        &#125;    &#125;</code></pre><blockquote><p><code>Service.onRebind()</code>执行条件为：使用Service的流程是，先<code>startService()</code>然后<code>bindService()</code>，在Activity退出的时候，Service并不会停止，再进入Activity重新进行<code>bindService()</code>，会触发<code>onRebind()</code>方法。<strong>但是先前Activity退出时调用的<code>onUnbind()</code>返回为<code>true</code>，直接写死返回结果。</strong></p><p><strong>当多次绑定同一个Service时，<code>onBind()</code>只会执行一次，除非Service被终止。</strong></p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Service绑定过程.png" srcset="/img/loading.gif" class="full-image" alt="Service绑定过程" title="Service绑定过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="Service绑定通知"><a href="#Service绑定通知" class="headerlink" title="Service绑定通知"></a>Service绑定通知</h4><p>发现Service未绑定时，就会调用到<code>onBind()</code>，Service就处于绑定状态，但是客户端无法感知到Service已经连接成功，所以需要<code>AMS</code>进行通知。</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityManagerService.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishService</span><span class="hljs-params">(IBinder token, Intent intent, IBinder service)</span> </span>&#123;        <span class="hljs-comment">// Refuse possible leaked file descriptors</span>        <span class="hljs-keyword">if</span> (intent != <span class="hljs-keyword">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"File descriptors passed in Intent"</span>);        &#125;        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">if</span> (!(token <span class="hljs-keyword">instanceof</span> ServiceRecord)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Invalid service token"</span>);            &#125;            mServices.publishServiceLocked((ServiceRecord)token, intent, service);        &#125;    &#125;</code></pre><p><code>mServices</code>就是<code>ActiveServices</code>对象，调用其内部的<code>publishServiceLocked()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActiveServices.java</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">publishServiceLocked</span><span class="hljs-params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> origId = Binder.clearCallingIdentity();        <span class="hljs-keyword">try</span> &#123;             ...                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> conni=r.connections.size()-<span class="hljs-number">1</span>; conni&gt;=<span class="hljs-number">0</span>; conni--) &#123;                        ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;clist.size(); i++) &#123;                            ConnectionRecord c = clist.get(i);                            <span class="hljs-keyword">try</span> &#123;                                c.conn.connected(r.name, service, <span class="hljs-keyword">false</span>);                            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                                Slog.w(TAG, <span class="hljs-string">"Failure sending service "</span> + r.name +                                      <span class="hljs-string">" to connection "</span> + c.conn.asBinder() +                                      <span class="hljs-string">" (in "</span> + c.binding.client.processName + <span class="hljs-string">")"</span>, e);                            &#125;                        &#125;                    &#125;                &#125;                serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="hljs-keyword">false</span>);            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            Binder.restoreCallingIdentity(origId);        &#125;    &#125;</code></pre><p><code>c.conn</code>指向<code>IServiceConnection</code>，他是<code>ServiceConnection</code>在本地的代理对象，用于解决当前应用程序进程和Service跨进程通信的问题。</p><p>他的具体实现为<code>ServiceDispatcher.InnerConnection</code>。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/LoaderApk.java</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceDispatcher</span> </span>&#123; ...        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerConnection</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IServiceConnection</span>.<span class="hljs-title">Stub</span> </span>&#123;            <span class="hljs-keyword">final</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;            InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;                mDispatcher = <span class="hljs-keyword">new</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);            &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connected</span><span class="hljs-params">(ComponentName name, IBinder service, <span class="hljs-keyword">boolean</span> dead)</span>                    <span class="hljs-keyword">throws</span> RemoteException </span>&#123;                LoadedApk.ServiceDispatcher sd = mDispatcher.get();                <span class="hljs-keyword">if</span> (sd != <span class="hljs-keyword">null</span>) &#123;                    sd.connected(name, service, dead);                &#125;            &#125;        &#125;          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connected</span><span class="hljs-params">(ComponentName name, IBinder service, <span class="hljs-keyword">boolean</span> dead)</span> </span>&#123;            <span class="hljs-keyword">if</span> (mActivityThread != <span class="hljs-keyword">null</span>) &#123;                mActivityThread.post(<span class="hljs-keyword">new</span> RunConnection(name, service, <span class="hljs-number">0</span>, dead));            &#125; <span class="hljs-keyword">else</span> &#123;                doConnected(name, service, dead);            &#125;        &#125;    ...&#125;</code></pre><p><code>mActivityThread</code>是一个Handler对象，指向的就是<code>ActivityThread.H</code>。因此可以通过调用<code>post()</code>直接发送<code>RunConnection</code>对象的内容运行在主线程中。<strong>mActivityThread不可能为空。</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;            RunConnection(ComponentName name, IBinder service, <span class="hljs-keyword">int</span> command, <span class="hljs-keyword">boolean</span> dead) &#123;                mName = name;                mService = service;                mCommand = command;                mDead = dead;            &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">if</span> (mCommand == <span class="hljs-number">0</span>) &#123;                    doConnected(mName, mService, mDead);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCommand == <span class="hljs-number">1</span>) &#123;                    doDeath(mName, mService);                &#125;            &#125;            <span class="hljs-keyword">final</span> ComponentName mName;            <span class="hljs-keyword">final</span> IBinder mService;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mCommand;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> mDead;        &#125;</code></pre><p>调用了<code>RunConnection</code>实际上还是调用了<code>doConnected()</code></p><pre><code class="hljs java">ServiceConnection mConnection;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doConnected</span><span class="hljs-params">(ComponentName name, IBinder service, <span class="hljs-keyword">boolean</span> dead)</span> </span>&#123;            ServiceDispatcher.ConnectionInfo old;            ServiceDispatcher.ConnectionInfo info;            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            ...            <span class="hljs-comment">// 如果存在老Service 会优先断掉连接</span>            <span class="hljs-keyword">if</span> (old != <span class="hljs-keyword">null</span>) &#123;                mConnection.onServiceDisconnected(name);            &#125;            <span class="hljs-comment">// Service已消失 死亡回调</span>            <span class="hljs-keyword">if</span> (dead) &#123;                mConnection.onBindingDied(name);            &#125;            <span class="hljs-comment">// 全新的Service 通知绑定成功</span>            <span class="hljs-keyword">if</span> (service != <span class="hljs-keyword">null</span>) &#123;                mConnection.onServiceConnected(name, service);            &#125;        &#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//使用场景 </span><span class="hljs-keyword">private</span> ServiceConnection mConnection = <span class="hljs-keyword">new</span> ServiceConnection() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> </span>&#123;           <span class="hljs-comment">//绑定成功回调</span>        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> </span>&#123;                    &#125;    &#125;;</code></pre><!-- 为什么bindservice不会触发onStartCommanad--><h3 id="Service解绑过程-unbindService"><a href="#Service解绑过程-unbindService" class="headerlink" title="Service解绑过程 - unbindService()"></a>Service解绑过程 - unbindService()</h3><p>Service的解绑过程也是从<code>ContextWrapper</code>开始</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unbindService</span><span class="hljs-params">(ServiceConnection conn)</span> </span>&#123;    mBase.unbindService(conn);&#125;</code></pre><p>实际调用的是<code>ContextImpl.unbindService()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ContextImpl.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unbindService</span><span class="hljs-params">(ServiceConnection conn)</span> </span>&#123;        <span class="hljs-keyword">if</span> (conn == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"connection is null"</span>);        &#125;        <span class="hljs-keyword">if</span> (mPackageInfo != <span class="hljs-keyword">null</span>) &#123;            IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(                    getOuterContext(), conn);            <span class="hljs-keyword">try</span> &#123;                ActivityManager.getService().unbindService(sd);            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Not supported in system context"</span>);        &#125;    &#125;</code></pre><p>这里主要分为两部分：</p><ul><li><p><code>LoadedApk.forgetServiceDispatcher()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/LoaderApk.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> IServiceConnection <span class="hljs-title">forgetServiceDispatcher</span><span class="hljs-params">(Context context,            ServiceConnection c)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (mServices) &#123;            <span class="hljs-comment">//获取当前存储的ServiceConnection</span>            ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map                    = mServices.get(context);            LoadedApk.ServiceDispatcher sd = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//获取对应的ServiceDispatcher</span>                sd = map.get(c);                <span class="hljs-keyword">if</span> (sd != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">if</span> (DEBUG) Slog.d(TAG, <span class="hljs-string">"Removing dispatcher "</span> + sd + <span class="hljs-string">" for conn "</span> + c);                    map.remove(c);                    sd.doForget();                    <span class="hljs-keyword">if</span> (map.size() == <span class="hljs-number">0</span>) &#123;                        mServices.remove(context);                    &#125;                    <span class="hljs-keyword">if</span> ((sd.getFlags()&amp;Context.BIND_DEBUG_UNBIND) != <span class="hljs-number">0</span>) &#123;                        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; holder                                = mUnboundServices.get(context);                        <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;                            holder = <span class="hljs-keyword">new</span> ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();                            mUnboundServices.put(context, holder);                        &#125;                        RuntimeException ex = <span class="hljs-keyword">new</span> IllegalArgumentException(                                <span class="hljs-string">"Originally unbound here:"</span>);                        ex.fillInStackTrace();                        sd.setUnbindLocation(ex);                        holder.put(c, sd);                    &#125;                    <span class="hljs-keyword">return</span> sd.getIServiceConnection();                &#125;            &#125;        ...              &#125;</code></pre><p>在这个函数中移除掉存储的映射关系</p></li><li><p><code>AMS.unbindService()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/android/com/server/am/ActivityManagerService.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unbindService</span><span class="hljs-params">(IServiceConnection connection)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">return</span> mServices.unbindServiceLocked(connection);        &#125;    &#125;</code></pre></li></ul><p>调用到<code>ActiveServices.unbindServiceLocked()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/android/com/server/am/ActiveServices.java</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">unbindServiceLocked</span><span class="hljs-params">(IServiceConnection connection)</span> </span>&#123;        IBinder binder = connection.asBinder();        <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="hljs-string">"unbindService: conn="</span> + binder);        ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);        <span class="hljs-keyword">if</span> (clist == <span class="hljs-keyword">null</span>) &#123;            Slog.w(TAG, <span class="hljs-string">"Unbind failed: could not find connection for "</span>                  + connection.asBinder());            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> origId = Binder.clearCallingIdentity();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">while</span> (clist.size() &gt; <span class="hljs-number">0</span>) &#123;                ConnectionRecord r = clist.get(<span class="hljs-number">0</span>);                <span class="hljs-comment">//移除掉对应Service的绑定</span>                removeConnectionLocked(r, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                                ...                <span class="hljs-comment">//从映射表中移除对应的ServiceConnection</span>                          &#125;            mAm.updateOomAdjLocked();        &#125; <span class="hljs-keyword">finally</span> &#123;            Binder.restoreCallingIdentity(origId);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeConnectionLocked</span><span class="hljs-params">(        ConnectionRecord c, ProcessRecord skipApp, ActivityRecord skipAct)</span> </span>&#123;        IBinder binder = c.conn.asBinder();        AppBindRecord b = c.binding;        ServiceRecord s = b.service;        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);        <span class="hljs-keyword">if</span> (clist != <span class="hljs-keyword">null</span>) &#123;            clist.remove(c);            <span class="hljs-keyword">if</span> (clist.size() == <span class="hljs-number">0</span>) &#123;                s.connections.remove(binder);            &#125;        &#125;        b.connections.remove(c);        ...        <span class="hljs-keyword">if</span> (!c.serviceDead) &#123;            <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="hljs-string">"Disconnecting binding "</span> + b.intent                    + <span class="hljs-string">": shouldUnbind="</span> + b.intent.hasBound);            <span class="hljs-keyword">if</span> (s.app != <span class="hljs-keyword">null</span> &amp;&amp; s.app.thread != <span class="hljs-keyword">null</span> &amp;&amp; b.intent.apps.size() == <span class="hljs-number">0</span>                    &amp;&amp; b.intent.hasBound) &#123;                <span class="hljs-keyword">try</span> &#123;                    bumpServiceExecutingLocked(s, <span class="hljs-keyword">false</span>, <span class="hljs-string">"unbind"</span>);                    <span class="hljs-keyword">if</span> (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="hljs-number">0</span>                            &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_RECEIVER) &#123;                        <span class="hljs-comment">// If this service's process is not already in the cached list,</span>                        <span class="hljs-comment">// then update it in the LRU list here because this may be causing</span>                        <span class="hljs-comment">// it to go down there and we want it to start out near the top.</span>                        mAm.updateLruProcessLocked(s.app, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);                    &#125;                    mAm.updateOomAdjLocked(s.app, <span class="hljs-keyword">true</span>);                    b.intent.hasBound = <span class="hljs-keyword">false</span>;                    <span class="hljs-comment">// Assume the client doesn't want to know about a rebind;</span>                    <span class="hljs-comment">// we will deal with that later if it asks for one.</span>                    b.intent.doRebind = <span class="hljs-keyword">false</span>;                    s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    Slog.w(TAG, <span class="hljs-string">"Exception when unbinding service "</span> + s.shortName, e);                    serviceProcessGoneLocked(s);                &#125;            &#125;          ...          <span class="hljs-comment">//如果是利用 BIND_AUTO_CREATE的flag就会向下调用</span>          <span class="hljs-keyword">if</span> ((c.flags&amp;Context.BIND_AUTO_CREATE) != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">boolean</span> hasAutoCreate = s.hasAutoCreateConnections();                <span class="hljs-keyword">if</span> (!hasAutoCreate) &#123;                    <span class="hljs-keyword">if</span> (s.tracker != <span class="hljs-keyword">null</span>) &#123;                        s.tracker.setBound(<span class="hljs-keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),                                SystemClock.uptimeMillis());                    &#125;                &#125;                <span class="hljs-comment">//这里走的是stopService的流程</span>                bringDownServiceIfNeededLocked(s, <span class="hljs-keyword">true</span>, hasAutoCreate);            &#125;        &#125;    &#125;</code></pre><p>又看到了熟悉的<code>app.thread</code>就知道切换回到了<code>ActivityThread</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleUnbindService</span><span class="hljs-params">(IBinder token, Intent intent)</span> </span>&#123;            BindServiceData s = <span class="hljs-keyword">new</span> BindServiceData();            s.token = token;            s.intent = intent;            sendMessage(H.UNBIND_SERVICE, s);        &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleUnbindService</span><span class="hljs-params">(BindServiceData data)</span> </span>&#123;        Service s = mServices.get(data.token);        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                data.intent.setExtrasClassLoader(s.getClassLoader());                data.intent.prepareToEnterProcess();                <span class="hljs-comment">//调用到 onUnbind() 生命周期</span>                <span class="hljs-keyword">boolean</span> doRebind = s.onUnbind(data.intent);                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">if</span> (doRebind) &#123;                        <span class="hljs-comment">//需要重新绑定</span>                        ActivityManager.getService().unbindFinished(                                data.token, data.intent, doRebind);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">//取消绑定</span>                        ActivityManager.getService().serviceDoneExecuting(                                data.token, SERVICE_DONE_EXECUTING_ANON, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);                    &#125;                &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;                    <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                ...            &#125;        &#125;    &#125;</code></pre><p>当Service调用<code>onUnbind()</code>之后，还需要做一件事情，如果是靠<code>bindService()</code>并配置<code>flag</code>为<code>BIND_AUTO_CREATE</code>。那么后续还会执行到<code>stopService()</code>中的流程，即会调用到<code>Service.onDestroy()</code>。</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/android/com/server/am/ActiveServices.java</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeConnectionLocked</span><span class="hljs-params">(//如果是利用 BIND_AUTO_CREATE的flag就会向下调用          <span class="hljs-keyword">if</span> ((c.flags&amp;Context.BIND_AUTO_CREATE)</span> !</span>= <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">boolean</span> hasAutoCreate = s.hasAutoCreateConnections();                <span class="hljs-keyword">if</span> (!hasAutoCreate) &#123;                    <span class="hljs-keyword">if</span> (s.tracker != <span class="hljs-keyword">null</span>) &#123;                        s.tracker.setBound(<span class="hljs-keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),                                SystemClock.uptimeMillis());                    &#125;                &#125;                <span class="hljs-comment">//这里走的是stopService的流程</span>                bringDownServiceIfNeededLocked(s, <span class="hljs-keyword">true</span>, hasAutoCreate); <span class="hljs-comment">//true true</span>            &#125;   &#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bringDownServiceIfNeededLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-keyword">boolean</span> knowConn,            <span class="hljs-keyword">boolean</span> hasConn)</span> </span>&#123;        <span class="hljs-comment">//由于bindService过程中的Service不是由startService()进行启动的，所有这里可以向下执行</span>        <span class="hljs-keyword">if</span> (isServiceNeededLocked(r, knowConn, hasConn)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// Are we in the process of launching?</span>        <span class="hljs-keyword">if</span> (mPendingServices.contains(r)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        bringDownServiceLocked(r);    &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isServiceNeededLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-keyword">boolean</span> knowConn,            <span class="hljs-keyword">boolean</span> hasConn)</span> </span>&#123;        <span class="hljs-comment">// 是否由startService()执行</span>        <span class="hljs-keyword">if</span> (r.startRequested) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// Is someone still bound to us keeping us running?</span>        <span class="hljs-keyword">if</span> (!knowConn) &#123;            hasConn = r.hasAutoCreateConnections();        &#125;        <span class="hljs-keyword">if</span> (hasConn) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Service解绑过程.png" srcset="/img/loading.gif" class="full-image" alt="Service解绑过程" title="Service解绑过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="Service停止过程-stopService"><a href="#Service停止过程-stopService" class="headerlink" title="Service停止过程 - stopService()"></a>Service停止过程 - stopService()</h3><p>还是由<code>ContextWrapper.stopService()</code>开始执行</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">stopService</span><span class="hljs-params">(Intent name)</span> </span>&#123;    <span class="hljs-keyword">return</span> mBase.stopService(name);&#125;</code></pre><p>向下执行到<code>ContextImpl.stopService()</code>中</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">stopService</span><span class="hljs-params">(Intent service)</span> </span>&#123;    warnIfCallingFromSystemProcess();    <span class="hljs-keyword">return</span> stopServiceCommon(service, mUser);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">stopServiceCommon</span><span class="hljs-params">(Intent service, UserHandle user)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        validateServiceIntent(service);        service.prepareToLeaveProcess(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">int</span> res = ActivityManager.getService().stopService(            mMainThread.getApplicationThread(), service,            service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());        <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(                    <span class="hljs-string">"Not allowed to stop service "</span> + service);        &#125;        <span class="hljs-keyword">return</span> res != <span class="hljs-number">0</span>;    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;        <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();    &#125;&#125;</code></pre><p><code>ActivityManager.getService()</code>实际就是指向<code>ActivityManagerService</code>的一个Binder对象</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/android/com/server/am/ActivityManagerService.java   </span><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">stopService</span><span class="hljs-params">(IApplicationThread caller, Intent service,            String resolvedType, <span class="hljs-keyword">int</span> userId)</span> </span>&#123;        enforceNotIsolatedCaller(<span class="hljs-string">"stopService"</span>);        <span class="hljs-comment">// Refuse possible leaked file descriptors</span>        <span class="hljs-keyword">if</span> (service != <span class="hljs-keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"File descriptors passed in Intent"</span>);        &#125;        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">return</span> mServices.stopServiceLocked(caller, service, resolvedType, userId);        &#125;    &#125;</code></pre><p><code>mServices</code>是<code>ActiveServices</code>的一个实际对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stopServiceLocked</span><span class="hljs-params">(IApplicationThread caller, Intent service,            String resolvedType, <span class="hljs-keyword">int</span> userId)</span> </span>&#123;        ...        <span class="hljs-comment">// If this service is active, make sure it is stopped.</span>        ServiceLookupResult r = retrieveServiceLocked(service, resolvedType, <span class="hljs-keyword">null</span>,                Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);        <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (r.record != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> origId = Binder.clearCallingIdentity();                <span class="hljs-keyword">try</span> &#123;                    stopServiceLocked(r.record);                &#125; <span class="hljs-keyword">finally</span> &#123;                    Binder.restoreCallingIdentity(origId);                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopServiceLocked</span><span class="hljs-params">(ServiceRecord service)</span> </span>&#123;        ...        service.startRequested = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (service.tracker != <span class="hljs-keyword">null</span>) &#123;            service.tracker.setStarted(<span class="hljs-keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),                    SystemClock.uptimeMillis());        &#125;        service.callStart = <span class="hljs-keyword">false</span>;        bringDownServiceIfNeededLocked(service, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isServiceNeededLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-keyword">boolean</span> knowConn,            <span class="hljs-keyword">boolean</span> hasConn)</span> </span>&#123;        <span class="hljs-comment">// Are we still explicitly being asked to run?</span>        <span class="hljs-keyword">if</span> (r.startRequested) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span> (!knowConn) &#123;            hasConn = r.hasAutoCreateConnections();        &#125;        <span class="hljs-keyword">if</span> (hasConn) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bringDownServiceIfNeededLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-keyword">boolean</span> knowConn,            <span class="hljs-keyword">boolean</span> hasConn)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isServiceNeededLocked(r, knowConn, hasConn)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (mPendingServices.contains(r)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        bringDownServiceLocked(r);    &#125;</code></pre><p>最后调用到了<code>bringDownServiceLocked()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bringDownServiceLocked</span><span class="hljs-params">(ServiceRecord r)</span> </span>&#123;      ...     <span class="hljs-keyword">if</span> (r.app != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;                r.stats.stopLaunchedLocked();            &#125;            r.app.services.remove(r);            <span class="hljs-keyword">if</span> (r.whitelistManager) &#123;                updateWhitelistManagerLocked(r.app);            &#125;            <span class="hljs-keyword">if</span> (r.app.thread != <span class="hljs-keyword">null</span>) &#123;                updateServiceForegroundLocked(r.app, <span class="hljs-keyword">false</span>);                <span class="hljs-keyword">try</span> &#123;                    bumpServiceExecutingLocked(r, <span class="hljs-keyword">false</span>, <span class="hljs-string">"destroy"</span>);                    mDestroyingServices.add(r);                    r.destroying = <span class="hljs-keyword">true</span>;                    mAm.updateOomAdjLocked(r.app, <span class="hljs-keyword">true</span>);                    r.app.thread.scheduleStopService(r);                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    Slog.w(TAG, <span class="hljs-string">"Exception when destroying service "</span>                            + r.shortName, e);                    serviceProcessGoneLocked(r);                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.v(                    TAG_SERVICE, <span class="hljs-string">"Removed service that has no process: "</span> + r);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.v(                TAG_SERVICE, <span class="hljs-string">"Removed service that is not running: "</span> + r);        &#125;  ...&#125;</code></pre><p><code>app.thread</code>切换到<code>ApplicaitonThread</code>继续执行流程</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleStopService</span><span class="hljs-params">(IBinder token)</span> </span>&#123;            sendMessage(H.STOP_SERVICE, token);        &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleStopService</span><span class="hljs-params">(IBinder token)</span> </span>&#123;        Service s = mServices.remove(token);        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">"Destroying service "</span> + s);                s.onDestroy();                s.detachAndCleanUp();                Context context = s.getBaseContext();                <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> ContextImpl) &#123;                    <span class="hljs-keyword">final</span> String who = s.getClassName();                    ((ContextImpl) context).scheduleFinalCleanup(who, <span class="hljs-string">"Service"</span>);                &#125;                QueuedWork.waitToFinish();                <span class="hljs-keyword">try</span> &#123;                    ActivityManager.getService().serviceDoneExecuting(                            token, SERVICE_DONE_EXECUTING_STOP, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                    <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                ...            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;           ...        &#125;          &#125;</code></pre><p>最后执行到<code>Service.onDestroy</code>完成停止流程。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Service停止流程.png" srcset="/img/loading.gif" class="full-image" alt="Service停止流程" title="Service停止流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>为什么Activity退出时<code>bindService()</code>的Service会一并销毁？</p><p>观察源码发现，<code>bindService()</code>也会去启动Service，但为什么没有回调到<code>onStartCommand()</code>？</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解Window及WindowManager</title>
    <link href="/2019/01/10/%E7%90%86%E8%A7%A3Window%E5%8F%8AWindowManager/"/>
    <url>/2019/01/10/%E7%90%86%E8%A7%A3Window%E5%8F%8AWindowManager/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/WindowWindowManager.png" srcset="/img/loading.gif" class="full-image" alt="Window&WindowManager" title="Window&WindowManager"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p><code>Window</code>：他是一个抽象类，具体的实现类为<code>PhoneWindow</code>，它对View进行管理。每个Window都会对应一个<code>View</code>和一个<code>ViewRootImpl</code>，Window通过<code>ViewRootImpl</code>与View建立联系。</p><p><code>WindowManager</code>：是一个接口类，继承<code>ViewManager</code>，主要用于管理Window，具体实现类为<code>WindowManagerImpl</code>。实际使用中无法直接访问Window，需要通过<code>WindowManager</code>进行操作。</p><p><code>WindowManagerService</code>：<code>WindowManager</code>的具体工作都会通过<code>WindowManagerService</code>进行处理，他们之间通过<code>Binder</code>进行跨进程通信，<code>WindowManager</code>无法直接调用WMS中的API。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Window&WindowManager&WMS.png" srcset="/img/loading.gif" class="full-image" alt="Window&WindowManager&WMS" title="Window&WindowManager&WMS"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="2-Window的属性"><a href="#2-Window的属性" class="headerlink" title="2.Window的属性"></a>2.Window的属性</h2><h3 id="Window的类型-Type"><a href="#Window的类型-Type" class="headerlink" title="Window的类型(Type)"></a>Window的类型(<em>Type</em>)</h3><p>Window有三种类型：</p><ul><li><p><strong>Application Window(应用窗口)</strong>：对应一个Activity  <code>层级范围为1~99</code></p></li><li><p><strong>Sub Window(子窗口)</strong>：不能独立存在，需要附着在其他窗口上才行，例如<em>Dialog,PopupWindow</em>   <code>层级范围为1000~1999</code></p></li><li><strong>System Window(系统窗口)</strong>：需要声明权限才能创建的Window，例如<em>Toast</em>   <code>层级范围为2000~2999</code></li></ul><p>Window是分层的，层级大的Window会覆盖在层级小的Window上面，上面描述的层级范围对应的是<code>WindowManager.LayoutParams的type参数</code>。</p><p>通过<code>layoutParams.type = LayoutParams.TYPE_XXX</code>可以设置层级。<strong>同时需要声明<code>&lt;user-permission android:name=&quot;android:permission.SYSTEM_ALERT_WINDOW&quot;&gt;</code></strong>就可以设置系统窗口的type。</p><h3 id="Window的标志-Flag"><a href="#Window的标志-Flag" class="headerlink" title="Window的标志(Flag)"></a>Window的标志(<em>Flag</em>)</h3><p>Window的标志用于控制Window的显示，同时被定义在<code>WindowManager.LayoutParams</code>中，以下列举比较常用的：</p><table><thead><tr><th>FLAG</th><th>描述</th></tr></thead><tbody><tr><td>FLAG_NOT_FOCUSABLE</td><td>表示Window不需要获取焦点，也不需要接收各种输入事件，同时会设置<code>FLAG_NOT_TOUCH_MODAL</code>标记，最终事件会传递到下层具有焦点的Window</td></tr><tr><td>FLAG_NOT_TOUCH_MODAL</td><td>系统会将当前区域以外的触摸事件向下传递，Window以内的事件自己处理。<em>一般需要开启，否则其他Window无法接受时间。</em></td></tr><tr><td>FLAG_SHOW_WHEN_LOCKED</td><td>表示Window可显示在锁屏界面。(<em>例如XX助手</em>)</td></tr><tr><td>FLAG_KEEP_SCREEN_ON</td><td>只要窗口可见，屏幕就会一直亮着</td></tr><tr><td>FLAG_FULLSCREEN</td><td>隐藏所有的屏幕装饰窗口，进入全屏显示</td></tr></tbody></table><p>设置Windwo的Flag有三种方法：</p><ol><li><p>通过Window的<code>addFlags()</code></p><pre><code class="hljs java">Window mWindow = getWindow();window.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);</code></pre></li><li><p>通过Window的<code>setFlags()</code></p><pre><code class="hljs java">Window mWindow = getWindow();window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);</code></pre><blockquote><p><code>addFlags()</code>内部实现调用的还是<code>setFlags()</code>，两者区别不大。</p></blockquote></li><li><p>设置<code>LayoutParams.flags=XX</code>，并通过<code>addView()</code>添加进Window</p><pre><code class="hljs java">WindowManager.LayoutParams mLayoutParams = <span class="hljs-keyword">new</span> WindowManager.LayoutParams();mLayoutParams.flags = WindowManager.LayoutParams.FLAG_FULLSCREEN;WindowManager mWindowManager = (WindowManager)getSystemService(Context.WINDOW_SERVICE);TextView tv = <span class="hljs-keyword">new</span> TextView(<span class="hljs-keyword">this</span>);mWindowManager.addView(tv,mLayoutParams);</code></pre></li></ol><h3 id="Window的位置-Gravity"><a href="#Window的位置-Gravity" class="headerlink" title="Window的位置(Gravity)"></a>Window的位置(<em>Gravity</em>)</h3><p>默认位于屏幕中间</p><pre><code class="hljs java">mLayoutParams.gravity = Gravity.LEFT | Gravity.TOP;<span class="hljs-comment">//配置gravity 居于左上位置</span>mLayoutParams.x = <span class="hljs-number">100</span>;<span class="hljs-comment">//相对于gravity 居左100</span>mLayoutParams.y = <span class="hljs-number">300</span>;<span class="hljs-comment">//相对于gravity 居上300</span></code></pre><p>设置的<code>x、y</code>是相对于gravity的位置</p><h3 id="Window软键盘相关模式"><a href="#Window软键盘相关模式" class="headerlink" title="Window软键盘相关模式"></a>Window软键盘相关模式</h3><p>窗口之间的叠加是常见的场景，如果弹出窗口为软键盘的话，可能会有显示问题，默认弹出软键盘会覆盖用户的输入框。<code>WindowManager.LayoutParams</code>中定义了相关的软键盘弹出模式，下面列举常用的几个：</p><table><thead><tr><th>SoftInputMode</th><th>描述</th></tr></thead><tbody><tr><td>SOFT_INPUT_STATE_UNSPECIFIED</td><td>没有指定状态，系统会自动选择一个</td></tr><tr><td>SOFT_INPUT_STATE_UNCHANGED</td><td>不会改变软键盘状态</td></tr><tr><td>SOFT_INPUT_STATE_HIDDEN</td><td>用户进入窗口，软键盘默认隐藏</td></tr><tr><td>SOFT_INPUT_STATE_ALWAYS_HIDDEN</td><td>窗口获取焦点时，软键盘总是隐藏</td></tr><tr><td>SOFT_INPUT_ADJUST_RESIZE</td><td>软键盘弹出时，窗口会调整大小</td></tr><tr><td>SOFT_INPUT_ADJUST_PAN</td><td>软键盘弹出时，窗口不需要调整大小，确保输入焦点是可见</td></tr></tbody></table><pre><code class="hljs java">getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN)</code></pre><p>或者设置在<code>AndroidManifest.xml</code>中</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>          <span class="hljs-attr">android:windowSoftInputMode</span>=<span class="hljs-string">"SOFT_INPUT_ADJUST_PAN"</span>          /&gt;</span></code></pre><h2 id="3-Window的操作"><a href="#3-Window的操作" class="headerlink" title="3.Window的操作"></a>3.Window的操作</h2><p>对Window的访问必须通过<code>WindowManager</code>，主要有三大操作：<strong>添加、更新、删除</strong>。这三个方法主要定义在<code>ViewManger</code>中</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ViewManager</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewLayout</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeView</span><span class="hljs-params">(View view)</span></span>;&#125;</code></pre><p><code>WindowManager</code>也是一个接口继承自<code>ViewManager</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WindowManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewManager</span></span></code></pre><p><code>WindowManagerImpl</code>就是<code>WindowManager</code>的具体实现类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowManagerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WindowManager</span> </span>&#123; ...    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;        applyDefaultToken(params);        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewLayout</span><span class="hljs-params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;        applyDefaultToken(params);        mGlobal.updateViewLayout(view, params);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeView</span><span class="hljs-params">(View view)</span> </span>&#123;        mGlobal.removeView(view, <span class="hljs-keyword">false</span>);    &#125;  ...&#125;</code></pre><p>最终<code>WindowManagerImpl</code>对View的操作交由<code>WindowManagerGlobal</code>去实现。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/WindowManager关系.png" srcset="/img/loading.gif" class="full-image" alt="WindowManager关系" title="WindowManager关系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>WindowManagerGlobal</code>通过<code>ViewRootImpl</code>操作Window，<code>ViewRootImpl</code>通过<code>IWindowSession</code>这个Binder对象与<code>WindowManagerService</code>进程间通信去操作Window。</p><a href="/2019/01/30/WindowManagerService简析/" title="WindowManagerService简析">WindowManagerService简析</a><h3 id="Window添加"><a href="#Window添加" class="headerlink" title="Window添加"></a>Window添加</h3><blockquote><p>添加过程需要通过<code>WindowManager.addView()</code>来实现，它的真正实现需要通过<code>WindowManagerGlobal</code></p></blockquote><pre><code class="hljs java">    <span class="hljs-comment">//存储所有Window对应的View</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="hljs-keyword">new</span> ArrayList&lt;View&gt;();    <span class="hljs-comment">//所有Window对应的ViewRootImpl</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="hljs-keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();    <span class="hljs-comment">//所有Window对应的布局参数 LayoutParams</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =            <span class="hljs-keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();    <span class="hljs-comment">//存储那些正在被删除的对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="hljs-keyword">new</span> ArraySet&lt;View&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,            Display display, Window parentWindow)</span> </span>&#123;        <span class="hljs-comment">//检测参数是否合法</span>        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"view must not be null"</span>);        &#125;        <span class="hljs-keyword">if</span> (display == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"display must not be null"</span>);        &#125;        <span class="hljs-keyword">if</span> (!(params <span class="hljs-keyword">instanceof</span> WindowManager.LayoutParams)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Params must be WindowManager.LayoutParams"</span>);        &#125;               <span class="hljs-keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;        <span class="hljs-comment">//如果是子Window还需要调整参数</span>        <span class="hljs-keyword">if</span> (parentWindow != <span class="hljs-keyword">null</span>) &#123;            parentWindow.adjustLayoutParamsForSubWindow(wparams);        &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">final</span> Context context = view.getContext();            <span class="hljs-keyword">if</span> (context != <span class="hljs-keyword">null</span>                    &amp;&amp; (context.getApplicationInfo().flags                            &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="hljs-number">0</span>) &#123;                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;            &#125;        &#125;            ...        <span class="hljs-comment">//创建ViewRootImpl</span>        root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);        view.setLayoutParams(wparams);        <span class="hljs-comment">//保存当前界面的参数</span>        mViews.add(view);        mRoots.add(root);        mParams.add(wparams);      ...        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//调用 ViewRootImpl.setView() 更新界面并完成Window的添加过程</span>                root.setView(view, wparams, panelParentView);            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;                <span class="hljs-comment">// BadTokenException or InvalidDisplayException, clean up.</span>                <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;                    removeViewLocked(index, <span class="hljs-keyword">true</span>);                &#125;                <span class="hljs-keyword">throw</span> e;            &#125;    &#125;</code></pre><p>在<code>WindowManagerGlobal.addView()</code>主要完成了以下三步：</p><ul><li>检查参数是否合法，如果是子Window，还需要调整参数</li><li>创建ViewRootImpl，然后保存当前界面参数</li><li>调用<code>ViewRootImpl.setView()</code>继续完成Window的添加过程</li></ul><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewRootImpl.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;    ...      <span class="hljs-comment">//刷新当前界面</span>      requestLayout();    ...       <span class="hljs-keyword">try</span> &#123;                    mOrigWindowType = mWindowAttributes.type;                    mAttachInfo.mRecomputeGlobalAttributes = <span class="hljs-keyword">true</span>;                    collectViewAttributes();                    <span class="hljs-comment">//最终添加Window实现过程</span>                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,                            getHostVisibility(), mDisplay.getDisplayId(),                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                            mAttachInfo.mOutsets, mInputChannel);                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                    mAdded = <span class="hljs-keyword">false</span>;                    mView = <span class="hljs-keyword">null</span>;                    mAttachInfo.mRootView = <span class="hljs-keyword">null</span>;                    mInputChannel = <span class="hljs-keyword">null</span>;                    mFallbackEventHandler.setView(<span class="hljs-keyword">null</span>);                    unscheduleTraversals();                    setAccessibilityFocus(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Adding window failed"</span>, e);                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-keyword">if</span> (restore) &#123;                        attrs.restore();                    &#125;                &#125;  &#125;&#125;</code></pre><p><code>mWindowSession</code>的类型是<code>IWindowSession</code>是一个Binder对象，用于进行进程间通信，它是<code>Session</code>代理对象。</p><p>添加完成后，需要通过返回值<code>res</code>来判断是否添加成功。若是<code>WindowManagerGlobal.ADD_PKAY</code>说明添加成功。</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/wm/Session.java</span>    <span class="hljs-keyword">final</span> WindowManagerService mService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addToDisplay</span><span class="hljs-params">(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,            <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,            Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;        <span class="hljs-keyword">return</span> mService.addWindow(<span class="hljs-keyword">this</span>, window, seq, attrs, viewVisibility, displayId,                outContentInsets, outStableInsets, outOutsets, outInputChannel);    &#125;</code></pre><p><code>addToDisplay()</code>最终调用到<code>WindowManagerService.addWindow()</code>实现Window添加过程。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Window添加过程.png" srcset="/img/loading.gif" class="full-image" alt="Window添加过程" title="Window添加过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="Window更新"><a href="#Window更新" class="headerlink" title="Window更新"></a>Window更新</h3><blockquote><p>更新过程需要通过<code>WindowManager.updateViewLayout()</code>，它的真正实现需要通过<code>WindowManagerGlobal</code></p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/WindowManagerGlobal.java   </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewLayout</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"view must not be null"</span>);        &#125;        <span class="hljs-keyword">if</span> (!(params <span class="hljs-keyword">instanceof</span> WindowManager.LayoutParams)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Params must be WindowManager.LayoutParams"</span>);        &#125;        <span class="hljs-keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;        <span class="hljs-comment">//更新View的LayoutParams</span>        view.setLayoutParams(wparams);        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            <span class="hljs-keyword">int</span> index = findViewLocked(view, <span class="hljs-keyword">true</span>);            ViewRootImpl root = mRoots.get(index);            mParams.remove(index);            mParams.add(index, wparams);            root.setLayoutParams(wparams, <span class="hljs-keyword">false</span>);        &#125;    &#125;</code></pre><p>更新View的LayoutParams之后，还需要更新<code>ViewRootImpl.setLayoutParams()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewRootImpl.java</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLayoutParams</span><span class="hljs-params">(WindowManager.LayoutParams attrs, <span class="hljs-keyword">boolean</span> newView)</span> </span>&#123;  <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;    ...            <span class="hljs-keyword">if</span> (newView) &#123;                mSoftInputMode = attrs.softInputMode;                requestLayout();            &#125;            <span class="hljs-keyword">if</span> ((attrs.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)                    == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) &#123;                mWindowAttributes.softInputMode = (mWindowAttributes.softInputMode                        &amp; ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)                        | (oldSoftInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST);            &#125;            mWindowAttributesChanged = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">//开始View的测量，布局，绘制流程</span>            scheduleTraversals();  &#125;&#125;</code></pre><p>在<code>scheduleTraversals()</code>调用到<code>performTraversals()</code>继续执行更新过程</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;  ...    relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);  ...    <span class="hljs-keyword">if</span>(!mStopped)&#123;      <span class="hljs-keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);      <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);       <span class="hljs-comment">//开始测量过程</span>      performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);    &#125;    ...    <span class="hljs-comment">//layoutRequested 是否需要重新执行布局过程</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);    <span class="hljs-keyword">if</span>(didLayout)&#123;      <span class="hljs-comment">//开始布局过程</span>      performLayout(lp, mWidth, mHeight);    &#125;    ...    <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;            <span class="hljs-keyword">if</span> (mPendingTransitions != <span class="hljs-keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;                    mPendingTransitions.get(i).startChangingAnimations();                &#125;                mPendingTransitions.clear();            &#125;            <span class="hljs-comment">//开始绘制过程</span>            performDraw();        &#125;   ...  &#125;</code></pre><p><code>performTraversals()</code>内部实现了Window更新以及View的整个工作过程(<em>测量-布局-绘制</em>)。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">relayoutWindow</span><span class="hljs-params">(WindowManager.LayoutParams params, <span class="hljs-keyword">int</span> viewVisibility,        <span class="hljs-keyword">boolean</span> insetsPending)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;  ...     <span class="hljs-keyword">int</span> relayoutResult = mWindowSession.relayout(            mWindow, mSeq, params,            (<span class="hljs-keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="hljs-number">0.5f</span>),            (<span class="hljs-keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="hljs-number">0.5f</span>),            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="hljs-number">0</span>,            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame,            mPendingMergedConfiguration, mSurface);  ...&#125;</code></pre><p><code>mWindowSession</code>的类型是<code>IWindowSession</code>是一个Binder对象，用于进行进程间通信，它是<code>Session</code>代理对象。</p><p><code>mWindow</code>即<code>W extends IWindow.Stub</code>发送给WindowManagerService，用来接受WMS信息。</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/wm/Session.java</span>    <span class="hljs-keyword">final</span> WindowManagerService mService;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">relayout</span><span class="hljs-params">(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,            <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">int</span> viewFlags,            <span class="hljs-keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,            Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,            MergedConfiguration mergedConfiguration, Surface outSurface)</span> </span>&#123;        <span class="hljs-keyword">int</span> res = mService.relayoutWindow(<span class="hljs-keyword">this</span>, window, seq, attrs,                requestedWidth, requestedHeight, viewFlags, flags,                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,                outStableInsets, outsets, outBackdropFrame, mergedConfiguration, outSurface);        <span class="hljs-keyword">return</span> res;    &#125;</code></pre><p><code>relayout()</code>最终调用到<code>WindowManagerService.relayoutWindow()</code>实现Window更新过程。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Window更新过程.png" srcset="/img/loading.gif" class="full-image" alt="Window更新过程" title="Window更新过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="Window删除"><a href="#Window删除" class="headerlink" title="Window删除"></a>Window删除</h3><blockquote><p>删除过程需要通过<code>WindowManager.removeView()</code>来实现，它的真正实现需要通过<code>WindowManagerGlobal</code></p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/WindowManagerGlobal.java   </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeView</span><span class="hljs-params">(View view, <span class="hljs-keyword">boolean</span> immediate)</span> </span>&#123;        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"view must not be null"</span>);        &#125;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            <span class="hljs-comment">//找到需要删除的View索引</span>            <span class="hljs-keyword">int</span> index = findViewLocked(view, <span class="hljs-keyword">true</span>);            View curView = mRoots.get(index).getView();            removeViewLocked(index, immediate);            <span class="hljs-keyword">if</span> (curView == view) &#123;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Calling with view "</span> + view                    + <span class="hljs-string">" but the ViewAncestor is attached to "</span> + curView);        &#125;    &#125;</code></pre><p>实际调用<code>removeViewLocked()</code>执行删除Window操作，内部实现还是依赖了<code>ViewRootImpl</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeViewLocked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">boolean</span> immediate)</span> </span>&#123;       <span class="hljs-comment">//从Window添加过程中保存的 ViewRootImpl数组中获取对应的ViewRootImpl对象</span>       ViewRootImpl root = mRoots.get(index);       View view = root.getView();       <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;           InputMethodManager imm = InputMethodManager.getInstance();           <span class="hljs-keyword">if</span> (imm != <span class="hljs-keyword">null</span>) &#123;               imm.windowDismissed(mViews.get(index).getWindowToken());           &#125;       &#125;       <span class="hljs-comment">//在die 中执行删除Window操作</span>       <span class="hljs-keyword">boolean</span> deferred = root.die(immediate);       <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;           view.assignParent(<span class="hljs-keyword">null</span>);           <span class="hljs-keyword">if</span> (deferred) &#123;               <span class="hljs-comment">//存储即将删除的View</span>               mDyingViews.add(view);           &#125;       &#125;   &#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">die</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> immediate<span class="hljs-comment">/*是否同步执行删除*/</span>)</span> </span>&#123;    <span class="hljs-comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span>    <span class="hljs-comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span>    <span class="hljs-keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;        <span class="hljs-comment">//删除对应Window</span>        doDie();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (!mIsDrawing) &#123;        destroyHardwareRenderer();    &#125; <span class="hljs-keyword">else</span> &#123;        Log.e(mTag, <span class="hljs-string">"Attempting to destroy the window while drawing!\n"</span> +                <span class="hljs-string">"  window="</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">", title="</span> + mWindowAttributes.getTitle());    &#125;    mHandler.sendEmptyMessage(MSG_DIE);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p><code>die()</code>中分为两种移除Window方式：<em>同步执行、异步执行(通过Handler)</em>。最终都会执行到<code>doDie()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doDie</span><span class="hljs-params">()</span> </span>&#123;    checkThread();    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;        <span class="hljs-keyword">if</span> (mRemoved) &#123;            <span class="hljs-keyword">return</span>;        &#125;        mRemoved = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (mAdded) &#123;            <span class="hljs-comment">//已经添加成功的，需要进行删除</span>            dispatchDetachedFromWindow();        &#125;        ...        mAdded = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">//从保存的那些参数中 移除该View的所有引用</span>    WindowManagerGlobal.getInstance().doRemoveView(<span class="hljs-keyword">this</span>);&#125;</code></pre><p><code>doDie()</code>主要实现了两个功能：</p><ul><li><code>dispatchDetachedFromWindow()</code>：移除Window</li><li><code>doRemoveView()</code>：移除Window所对应的引用</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDetachedFromWindow</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//触发View的 onDetachedFromWindow()</span>       <span class="hljs-keyword">if</span> (mView != <span class="hljs-keyword">null</span> &amp;&amp; mView.mAttachInfo != <span class="hljs-keyword">null</span>) &#123;           mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="hljs-keyword">false</span>);           mView.dispatchDetachedFromWindow();       &#125;   ...       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//依靠Session去移除Window</span>           mWindowSession.remove(mWindow);       &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;       &#125;   ...       unscheduleTraversals();&#125;</code></pre><p><code>mWindowSession</code>的类型是<code>IWindowSession</code>是一个Binder对象，用于进行进程间通信，它是<code>Session</code>代理对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(IWindow window)</span> </span>&#123;    mService.removeWindow(<span class="hljs-keyword">this</span>, window);&#125;</code></pre><p><code>remove()</code>最终通过<code>WindowManagerService.removeView()</code>实现Window删除逻辑。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Window删除过程.png" srcset="/img/loading.gif" class="full-image" alt="Window删除过程" title="Window删除过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>上述Window的三大操作(<em>添加、更新和删除</em>)都会通过一个IPC过程调用<code>WindowManagerService</code>去实现具体逻辑。</p><p>三大操作过程也都需要通过<code>ViewRootImpl</code>来关联起Window和View，<code>ViewRootImpl</code>可以控制内部VIew的<em>测量、布局与绘制</em>。</p><p><strong>在上述三大操作中，虽然说是由<code>WindowManagerGlobal</code>去实现，但内部是依靠的<code>ViewRootImpl</code>，实际执行的是<code>WindowManagerService</code>。</strong><a href="/2019/01/30/WindowManagerService简析/" title="WindowManagerService简析">WindowManagerService简析</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Binder系列-Binder</title>
    <link href="/2019/01/06/Binder%E7%B3%BB%E5%88%97-Binder/"/>
    <url>/2019/01/06/Binder%E7%B3%BB%E5%88%97-Binder/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-Binder机制相关以及AIDL介绍"><a href="#Android-Binder机制相关以及AIDL介绍" class="headerlink" title="Android Binder机制相关以及AIDL介绍"></a>Android Binder机制相关以及AIDL介绍</h1><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Android-Binder机制.png" srcset="/img/loading.gif" class="full-image" alt="Android-Binder机制" title="Android-Binder机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>在Linux中，为了避免一个进程对其他进程的干扰，进程之间是相互独立的。</p><p>Android的进程间通信采用了Binder基于<strong>性能,稳定和安全</strong>方面的考虑：。</p><p>性能：在移动设备上对性能的要求是比较严苛的，在Linux上通信方式例如管道，Socket都需要复制两次数据，Binder只需一次。</p><p><code>对于消息队列、Socket和管道而言，数据先从发送方的缓存区拷贝到内核开辟的缓存区中，再从内核缓存区拷贝至接收方缓存区，需要两次拷贝过程；Binder是从发送方缓存区到内核的缓存区，而接受方的缓存区与内核缓存区映射在同一块物理地址上，节省了一次数据拷贝的过程。</code></p><p>安全：传统的Linux通信是不包含通信双方的身份验证的，Binder自带身份验证，提高了安全性。</p><p><code>Android提供了UID机制，可以有效的鉴别用户身份。</code></p><p>稳定：Binder基于C/S架构，Client有什么需求就丢给Server去完成，职责明确又独立，稳定性更好。</p></blockquote><p>概念：</p><ul><li>直观来说，Binder是Android中的一个类，实现了IBinder接口。</li><li>IPC角度来说，Binder是Android中的一种跨进程通信方式。</li><li>Android Framework角度来说，Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁。</li><li>应用层来说，Binder是客户端和服务端进行通信的媒介。</li></ul><h2 id="1-Linux下传统的进程间通信原理"><a href="#1-Linux下传统的进程间通信原理" class="headerlink" title="1.Linux下传统的进程间通信原理"></a>1.Linux下传统的进程间通信原理</h2><blockquote><p>Binder通信原理也是基于Linux 下的IPC机制实现的。</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Linux-IPC-Basics.png" srcset="/img/loading.gif" class="full-image" alt="Linux进程结构" title="Linux进程结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>上图展示的结构中涉及了一些基础概念：</p><h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><blockquote><p>保护系统中进程互不干扰而设计的。在操作系统中，进程与进程间的内存是不共享的，进程1是无法直接访问进程2的数据，来保证数据的安全性。</p><p>进程隔离的条件下，进程之间传递数据就要依靠<code>IPC机制</code>进行进程间通信。</p></blockquote><p>进程隔离的实现是利用了<code>虚拟地址空间</code>。</p><h4 id="进程空间划分"><a href="#进程空间划分" class="headerlink" title="进程空间划分"></a>进程空间划分</h4><p>为了保护用户进程不能直接操作内核，保证内核的安全性，所以操作系统从逻辑上将虚拟空间划分为 <em>内核空间</em>，<em>用户空间</em>。</p><ul><li><p><strong>内核空间</strong> 一般占1GB</p><p>系统内核运行的空间，</p></li><li><p><strong>用户空间</strong> 一般占3GB</p><p>用于用户程序执行的空间</p></li></ul><p><em>用户空间在不同进程之间是不能共享的，内核空间是各个进程之间共享的</em>。</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>由于用户空间的权限低于内核空间，但当用户空间需要访问内核资源时(文件操作，访问网络等)，就需要其他方式实现。</p><p><strong>唯一的方式就是通过操作系统提供的<code>系统调用</code>接口</strong>。可以做到所有的资源访问都是在内核的控制下进行的，避免用户程序对系统资源的越权访问，提升系统安全和稳定性。</p><p>当一个进程执行<code>系统调用</code>使用内核代码时，该进程就进入了<strong>内核态</strong>，此时处理器处于特权最高的<strong>0级</strong>内核代码中执行。</p><p>当进程执行用户自己的代码时，进程就处于<strong>用户态</strong>。此时处理器处于<strong>3级</strong>用户代码中执行。</p><h4 id="传统IPC通信实现"><a href="#传统IPC通信实现" class="headerlink" title="传统IPC通信实现"></a>传统IPC通信实现</h4><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Linux-IPC.png" srcset="/img/loading.gif" class="full-image" alt="Linux IPC" title="Linux IPC"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据上述流程，传统IPC机制基本是以下两步：</p><ul><li>发送方通过<code>系统调用 copy_from_user</code>把要发送的数据拷贝到<code>内核缓存区</code>中</li><li>接收方需要开辟一块内存空间，内核通过<code>系统调用 copy_to_user</code>将内核缓存区的数据拷贝至接收方开辟的空间中。</li></ul><p>以上流程有两个明显的缺点：</p><ol><li>性能低下，因为数据需要经历<code>发送方内存缓存区 -&gt; 内核缓存区 -&gt; 接收方内存缓存区</code>，就需要两次拷贝过程。</li><li>接收方需要开辟一块空间用于存储数据，但并不知道要开辟多大的空间存储数据。因此只能开辟尽量大的空间或者先行获取数据的大小，可能存在时间和空间上的浪费。</li></ol><h4 id="Linux中的进程通信手段"><a href="#Linux中的进程通信手段" class="headerlink" title="Linux中的进程通信手段"></a>Linux中的进程通信手段</h4><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><blockquote><p>在创建时分配一个page大小的内存，缓存区大小比较有限</p></blockquote><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><blockquote><p>信息需要复制两次，带来额外的CPU消耗；不适合频繁或信息量大的通信</p></blockquote><h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><blockquote><p>无需复制，共享缓冲区直接附加到进程的虚拟地址空间，速度快；<strong>但是无法解决进程间同步问题</strong>。</p></blockquote><h5 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字(Socket)"></a>套接字(Socket)</h5><blockquote><p>接口通用但是传输效率低，主要用于不同机器之间的通信。</p></blockquote><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><blockquote><p>常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。<strong>主要作为进程间以及不同线程线程间的数据同步手段。</strong></p></blockquote><h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><blockquote><p>不适用于信息交换，更适用于进程中断控制，比如非法内存访问。</p></blockquote><h2 id="2-Binder基本原理"><a href="#2-Binder基本原理" class="headerlink" title="2.Binder基本原理"></a>2.Binder基本原理</h2><h3 id="Binder底层原理"><a href="#Binder底层原理" class="headerlink" title="Binder底层原理"></a>Binder底层原理</h3><h4 id="动态内核可加载模块和内存映射-mmap"><a href="#动态内核可加载模块和内存映射-mmap" class="headerlink" title="动态内核可加载模块和内存映射(mmap())"></a>动态内核可加载模块和内存映射(<code>mmap()</code>)</h4><p>传统的IPC机制例如<code>管道、Socket</code>都是内核的一部分，天生就是支持通过内核来实现进程间通信。Binder机制并不是内核中的一部分，这就依赖于<code>动态内核可加载模块</code>机制。</p><p><em>由于模块是具有独立功能的程序，他可以被单独编译但无法独立运行。所以可以利用该机制，动态的将一个内核模块添加至内核空间内，用户进程之间就可以通过这个内核模块实现通信。</em></p><blockquote><p>在Android系统中，加载进内核空间的模块就是 <strong>Binder驱动</strong>。</p></blockquote><p>Binder机制是如何利用这个模块<code>Binder驱动</code>进行进程间通信的呢？</p><p>这个时候就涉及到了另一个概念：<strong>内存映射</strong>。</p><p><code>内存映射</code>是通过<code>mmap()</code>来实现的，<code>mmap()</code>是操作系统中的一种内存映射的方法。<code>内存映射</code>就是将用户空间内的一块内存区域映射进内核空间。当映射关系建立完成后，用户对这块区域的修改可以直接反映到内核空间，而内核空间对映射区域的修改也可以直接反馈至用户空间。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>Binder借助了内存映射的方法，建立内存映射后，发送方发过来的数据拷贝到内核缓存区数据后，对应用户空间的映射区域也能接收到传递的数据，相当于少了一次拷贝过程。</code></p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Binder-IPC.png" srcset="/img/loading.gif" class="full-image" alt="Binder IPC" title="Binder IPC"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据流程图分析：</p><ol><li><code>Binder驱动</code>首先会在内核空间创建一个<code>数据接收缓存区</code></li><li>内核空间中有一块<code>内核缓存区</code>，利用<code>内存映射</code>将<code>内核缓存区</code>与<code>数据接收缓存区</code>建立映射关系，以及建立与<code>接收方用户空间</code>的映射关系。</li><li>发送进程将调用<code>系统调用 copy_from_user</code>将数据<code>copy</code>到<code>内核缓存区</code>，由于已经建立了映射关系，相当于数据直接<code>copy</code>进接收进程的用户空间。</li></ol><h2 id="3-Binder通信模型"><a href="#3-Binder通信模型" class="headerlink" title="3.Binder通信模型"></a>3.Binder通信模型</h2><p>Binder通信采用了<strong>C/S架构</strong>。在Android系统的Binder机制中，由一系列系统组件组成，分别是</p><ul><li><code>Client</code> 需要自己实现，客户端进程</li><li><code>Server</code> 需要自己实现，服务端进程</li><li><code>Service Manager</code> 由系统提供，将字符形式的Binder名字转化为Client中对该Binder的引用，使得Client可以通过Binder名字获得Server中Binder实体的引用。</li><li><code>Binder 驱动</code> 由系统提供，负责建立进程间的Binder连接，将Client请求转发到具体的Server中执行，并将Server返回值传回给Client。还有进程间的数据交互等底层操作</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/IPC-Binder.jpg" srcset="/img/loading.gif" class="full-image" alt="Binder架构图" title="Binder架构图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>Client,Server,Service Manager处于用户空间，Binder驱动位于内核空间。</p><p>下面介绍四个组成部分的作用：</p><ul><li><p><strong>Service Manager：</strong>服务的管理者，指代的是Native层的ServiceManager(C++)，是整个Binder通信机制的大管家，是Android进程间通信机制的守护进程。将Binder的名字转换为Client中对该Binder的引用，使得Client可以通过Binder名字来获取Service中的引用。</p><p><code>ServiceManager</code>其实就是一个进程，里面维护了一张表，表里存储的是向它注册过的进程信息。</p></li><li><p><strong>Binder驱动：</strong>主要是驱动设备的<strong>初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)</strong>。</p><p>和硬件设备没有任何关系。它工作于内核态，以misc设备注册在设备目录/dev下，用户可以通过/dev/binder访问它。负责进程之间binder通信的建立、传递、计数管理和数据的传递交互等底层支持。主要功能由<code>ioctl()/*主要负责在两个进程间收发IPC和IPC reply数据，常用命令为BINDER_WRITE_READ*/</code>实现。</p></li><li><p><strong>Client&amp;Service：</strong>在Binder驱动和Service Manager提供的基础设施上进行C-S之间的通信。<code>Server进程启动时，将在本进程内运行的Service注册到Service Manager中，并且启动一个Binder线程池，用来接收Client请求。然后Client进程向Service Manager查询所需要的Service，并获得一个Binder代理对象，通过该代理对象向Service发出请求。</code></p></li></ul><p>四大组件彼此之间不是直接交互的，都是通过Binder驱动进行交互，从而实现IPC通信方式。<strong>系统需要启动了Service Manager之后，Client端和Server端需要现获取了Service Manager接口后，才可以开始通信服务。</strong></p><h2 id="4-Binder通信过程"><a href="#4-Binder通信过程" class="headerlink" title="4.Binder通信过程"></a>4.Binder通信过程</h2><ol><li>一个进程通过<code>BINDER_SET_CONTEXT_MGR</code>命令将自己注册成<code>ServiceManager</code>，<code>Binder驱动</code>就会给他创建一个Binder实体</li><li><code>Server</code>通过<code>Binder驱动</code>向<code>ServiceManager</code>中注册Binder实体及其名字，声明可以对外提供服务。<code>Binder驱动</code>会为这个Binder创建位于内核中的实体节点以及<code>ServiceManager</code>中对实体的引用，将名字以及新建的引用打包给<code>ServiceManager</code>,<code>ServiceManager</code>将其填入查找表。</li><li><code>Server</code>向<code>ServiceManager</code>中注册了Binder实体以及名字后，<code>Client</code>就可以通过<code>Binder驱动</code>请求<code>ServiceManager</code>根据名字获得<code>Server</code>的Binder引用。</li><li>获得<code>Server</code>的Binder引用后，<code>Client</code>就可以通过<code>Binder驱动</code>直接和对应的Server通信。</li><li><code>Server</code>接收请求后，需要通过<code>Binder驱动</code>将请求结果返回到<code>Client</code>中。</li></ol><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Binder通信过程.png" srcset="/img/loading.gif" class="full-image" alt="Binder通信过程" title="Binder通信过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="5-Binder代理机制"><a href="#5-Binder代理机制" class="headerlink" title="5.Binder代理机制"></a>5.Binder代理机制</h2><p><code>Client</code>通过<code>ServiceManager</code>拿到<code>Server</code>的Binder引用后，<code>Client</code>就可以向<code>Server</code>发起请求。</p><p>在这一步骤中，<code>Client</code>得到的<code>Server</code>的Binder引用，其实是一个<code>Object</code>，在这个<code>Object</code>实现了一些方法；<code>Client</code>拿到这个<code>Object</code>后就可以直接调用内部的方法了。</p><p>实际上，<code>Client</code>拿到的并不是<code>Server</code>在<code>ServiceManager</code>注册的Binder实体，由于经过了<code>Binder驱动</code>，在其中做了一次<strong>对象转换</strong>，将Binde实体包装成了一个代理对象(<code>ProxyObject</code>)，<code>ProxyObject</code>有着和<code>Object</code>一样的方法，但是这些方法的内部实现都是<strong>空方法，唯一能做的就是把<code>Client</code>的请求参数交给<code>Binder驱动</code>。</strong></p><p><code>Binder驱动</code>收到<code>ProxyObject</code>传递的方法以及参数后，会在<code>ServiceManager</code>中查询是否存在该方法，如果存在<em><code>Binder驱动</code>就会把代理对象(<code>ProxyObject</code>)转换成实际<code>Server</code>对象(<code>Object</code>)</em>。然后调用对应的方法，经由<code>Binder驱动</code>把返回结果发回给<code>Client</code>。</p><p>上述流程就是<code>Binder的代理机制</code>。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Binder代理机制.png" srcset="/img/loading.gif" class="full-image" alt="Binder代理机制" title="Binder代理机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="6-Binder完整定义"><a href="#6-Binder完整定义" class="headerlink" title="6.Binder完整定义"></a>6.Binder完整定义</h2><p>根据上述流程，可以对<code>Binder</code>进行一个简单的总结：<em>Binder是基于C/S结构的一种面向对象的IPC机制。包含<code>Client、Server、Binder驱动和ServiceManager</code>四大组成部分。</em></p><p>在不同场景下，Binder有着不同的含义：</p><ul><li>通常意义上来说，<code>Binder</code>指的就是Android的进程间通信机制</li><li>对于<code>Server</code>来说，Binder是提供具体实现的本地对象，在<code>ServiceManager</code>注册得到</li><li>对于<code>Client</code>来说，Binder是<code>Server</code>本地对象的一个引用，这个引用实际是是有<code>Binder驱动</code>进行<code>对象转换</code>得到的一个代理对象<code>ProxyObject</code>，<code>Client</code>通过<code>ProxyObject</code>访问<code>Server</code>的本地对象。</li><li>对于传输过程来说，Binder就是一个可以跨进程传输的对象。</li></ul><h2 id="7-Binder工作机制"><a href="#7-Binder工作机制" class="headerlink" title="7.Binder工作机制"></a>7.Binder工作机制</h2><blockquote><p>需要配合客户端的实现分析，主要实现方式就是利用AIDL</p></blockquote><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><blockquote><p><strong>Android接口定义语言 – Android Interface Definition Language</strong></p><p>在Messenger中讲到它是基于AIDL的，但是只能处理串行的消息，如果有大量的消息同时发送进来，也只能一个个处理，而且不支持跨进程调用服务端的方法，就需要用到AIDL来处理上述情况。</p><p><strong>AIDL默认是同步调用的，若需要异步调用–可以添加一个异步回调接口执行结果异步回调给调用方，需要使用RemoteCallbackList</strong></p><p><strong>AIDL本质上就是系统为我们提供了一种快速实现Binder的工具，我们可以不依赖于AIDL，自己去完全实现一个Binder。</strong></p></blockquote><h4 id="1-AIDL支持的数据类型"><a href="#1-AIDL支持的数据类型" class="headerlink" title="1.AIDL支持的数据类型"></a>1.AIDL支持的数据类型</h4><ul><li>基本数据类型：<code>byte、int、long、float、double、boolean，char</code></li><li>String 和 CharSequence</li><li>ArrayList，HashMap(<strong>包括key，每个元素必须可以被AIDL支持</strong>)</li><li>实现了Parcelabe接口的对象 <strong>必须要显示Import进来</strong></li><li>所有AIDL接口本身也会被调用<strong>必须要显示Import进来</strong></li></ul><h4 id="2-定向tag"><a href="#2-定向tag" class="headerlink" title="2.定向tag"></a>2.定向tag</h4><blockquote><p>除了基本数据类型，其他类型的参数必须加上方向 <strong>in,out,inout</strong>，用于表示在跨进程通信中的数据流向。</p></blockquote><ul><li><code>in</code>：表示数据只能由客户端流向服务端。服务端会收到这个对象的完整数据，<strong>但在服务端对对象进行修改不会对客户端传递进来的对象造成影响。</strong></li><li><code>out</code>：表示数据只能由服务端传递到客户端。服务端会接受到这个对象的空对象，<strong>但在服务端接收到的空对象有任何修改之后客户端会同步发生变化。</strong></li><li><code>inout</code>：表示数据可以在服务端和客户端之间双向流通。服务端会收到这个对象的完整数据，<strong>且客户端会同步服务端对该对象的任何改动。</strong></li></ul><h4 id="3-关键类和方法"><a href="#3-关键类和方法" class="headerlink" title="3.关键类和方法"></a>3.关键类和方法</h4><blockquote><p>添加完AIDL文件后，会自动帮我们生成对应的Java文件。本质上是为我们提供了一种快速实现Binder的工具而已。</p></blockquote><ol><li><p>定义一个AIDL文件</p><pre><code class="hljs java"><span class="hljs-comment">//Book.aidl</span><span class="hljs-comment">//书的实体类</span>parcelable Book;<span class="hljs-comment">//IOnNewBookArrivedListener.aidl</span><span class="hljs-comment">//监听新增书本事件</span><span class="hljs-keyword">import</span> com.example.wxy.ipc.Book;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IOnNewBookArrivedListener</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNewBookArrived</span><span class="hljs-params">(in Book newBook)</span></span>;&#125;<span class="hljs-comment">//IBookManager.aidl</span><span class="hljs-comment">//书籍管理类</span><span class="hljs-keyword">import</span> com.example.wxy.ipc.Book;<span class="hljs-keyword">import</span> com.example.wxy.ipc.IOnNewBookArrivedListener;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IBookManager</span> </span>&#123;    <span class="hljs-comment">//获取书本总数</span>    <span class="hljs-function">List&lt;Book&gt; <span class="hljs-title">getBookList</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//插入新书</span>    <span class="hljs-function">Book <span class="hljs-title">addBook</span><span class="hljs-params">(in Book book)</span></span>;    <span class="hljs-comment">//注册监听</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerListener</span><span class="hljs-params">(IOnNewBookArrivedListener listener)</span></span>;    <span class="hljs-comment">//解注册监听</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unregisterListener</span><span class="hljs-params">(IOnNewBookArrivedListener listener)</span></span>;&#125;</code></pre><p>根据上述代码发现，aidl文件中引用到的AIDL接口或者Model对象，无论是否在同一个Package目录下，都必须<strong>显示引用</strong>。</p></li><li><p>AIDL文件定义完成后，会自动生成对应的Java文件，里面自动完成了Binder的逻辑。接下来进行结构分析</p><p><code>IBookManage</code> 主要声明了Client可以调用的Server方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IBookManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IInterafce</span></span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String DESCRIPTOR = <span class="hljs-string">"com.example.wxy.ipc.IBookManager"</span>;    <span class="hljs-keyword">public</span> java.util.List&lt;com.example.wxy.ipc.Book&gt; getBookList() <span class="hljs-keyword">throws</span> android.os.RemoteException;  <span class="hljs-keyword">public</span> com.example.wxy.ipc.<span class="hljs-function">Book <span class="hljs-title">addBook</span><span class="hljs-params">(com.example.wxy.ipc.Book book)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerListener</span><span class="hljs-params">(com.example.wxy.ipc.IOnNewBookArrivedListener listener)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unregisterListener</span><span class="hljs-params">(com.example.wxy.ipc.IOnNewBookArrivedListener listener)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">0</span>);  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">1</span>);  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRANSACTION_registerListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">2</span>);  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRANSACTION_unregisterListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">3</span>);&#125;</code></pre><p><code>Iinterface</code>代表的是Server进程需要具备什么功能，对应的就是 <code>Client</code>进程可以调用的方法</p><p><code>IBookManager.Stub</code> 实现一个跨进程调用对象<code>Stub</code>。<code>Stub</code>继承自<code>Binder</code>，说明它是一个<code>Server进程</code>的Binder本地对象。需要实现<code>Server进程</code>提供的能力。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">example</span>.<span class="hljs-title">wxy</span>.<span class="hljs-title">ipc</span>.<span class="hljs-title">IBookManager</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stub</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">this</span>.attachInterface(<span class="hljs-keyword">this</span>, DESCRIPTOR);  &#125;     <span class="hljs-comment">//返回当前Binder对象</span>   <span class="hljs-comment">// IBinder 这个代表了一种跨进程通信的能力。只要实现了这个接口，这个对象就可以跨进程传输。Client和Server进程都要实现该接口。</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> android.os.<span class="hljs-function">IBinder <span class="hljs-title">asBinder</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;   &#125;   &#125;</code></pre><p>关键方法: </p><ol><li><p><code>asInterface()</code> 通常用在Client <code>bindService()</code>成功后即在<code>onServiceConnected()</code>中调用该方法，可以把返回的IBinder对象转换为具体的<code>IIntergace</code>接口，就可以直接调用<code>Server</code>提供的对用方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.example.wxy.ipc.<span class="hljs-function">IBookManager <span class="hljs-title">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span> </span>&#123;            <span class="hljs-keyword">if</span> ((obj == <span class="hljs-keyword">null</span>)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);            <span class="hljs-keyword">if</span> (((iin != <span class="hljs-keyword">null</span>) &amp;&amp; (iin <span class="hljs-keyword">instanceof</span> com.example.wxy.ipc.IBookManager))) &#123;                <span class="hljs-keyword">return</span> ((com.example.wxy.ipc.IBookManager) iin);            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> com.example.wxy.ipc.IBookManager.Stub.Proxy(obj);   &#125;</code></pre><p>生成的代码中调用到了<code>queryLocalInterface()</code>去查找本地的Binder对象，</p><ul><li>如果找到了就证明<code>Client和Server</code>当前在统一进程内，直接就返回Binder对象。</li><li>如果没找到意味<code>Client和Server</code>不在统一进程内，就会返回一个Binder代理对象，即<code>ProxyObject</code>。</li></ul><p>当<code>Client</code>端在创建与服务端之间的连接时，调用<code>bindService()</code>需要创建一个<code>ServiceConnection</code>对象作为入参。在对应方法的回调<code>onServiceConnected()</code>需要调用<code>asInterface()</code>获取到对应对象。</p><pre><code class="hljs java"><span class="hljs-comment">// Client端实现 对应Android中的Activity</span>    <span class="hljs-keyword">private</span> ServiceConnection mConnection = <span class="hljs-keyword">new</span> ServiceConnection() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> </span>&#123;            <span class="hljs-comment">//获取到对应的BookManager对象</span>            mBookManager = IBookManager.Stub.asInterface(service);            <span class="hljs-keyword">try</span> &#123;                List&lt;Book&gt; list = mBookManager.getBookList();                mBookManager.registerListener(onNewBookArrivedListener);            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> </span>&#123;            Log.e(<span class="hljs-string">"Client"</span>, <span class="hljs-string">"绑定失败"</span>);        &#125;    &#125;;</code></pre></li><li><p><code>onTransact()</code> 运行在服务器端的Binder线程池中，客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法处理。参数介绍：</p><ul><li><code>code</code>：可以确定客户端所请求的方法是哪个</li><li><code>data</code>：取出目标方法所需参数</li><li><code>reply</code>：里面填写请求的返回值</li><li><code>flags</code>：设置进行IPC的模式，0双向流通 1单向流通 **AIDL生成的.java文件均设置0</li></ul><pre><code class="hljs java"><span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTransact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="hljs-keyword">int</span> flags)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException </span>&#123;        <span class="hljs-keyword">switch</span> (code) &#123;                <span class="hljs-keyword">case</span> INTERFACE_TRANSACTION: &#123;                    reply.writeString(descriptor);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;                <span class="hljs-keyword">case</span> TRANSACTION_getBookList: &#123;                    data.enforceInterface(descriptor);                    java.util.List&lt;com.example.wxy.ipc.Book&gt; _result = <span class="hljs-keyword">this</span>.getBookList();                    reply.writeNoException();                    reply.writeTypedList(_result);                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;                <span class="hljs-keyword">case</span> TRANSACTION_addBook: &#123;                    data.enforceInterface(descriptor);                    com.example.wxy.ipc.Book _arg0;                    <span class="hljs-keyword">if</span> ((<span class="hljs-number">0</span> != data.readInt())) &#123;                        _arg0 = com.example.wxy.ipc.Book.CREATOR.createFromParcel(data);                    &#125; <span class="hljs-keyword">else</span> &#123;                        _arg0 = <span class="hljs-keyword">null</span>;                    &#125;                    <span class="hljs-comment">//实际内部实现 就交由 Stub类的 子类实现</span>                    com.example.wxy.ipc.Book _result = <span class="hljs-keyword">this</span>.addBook(_arg0);                    reply.writeNoException();                    <span class="hljs-keyword">if</span> ((_result != <span class="hljs-keyword">null</span>)) &#123;                        reply.writeInt(<span class="hljs-number">1</span>);                        _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);                    &#125; <span class="hljs-keyword">else</span> &#123;                        reply.writeInt(<span class="hljs-number">0</span>);                    &#125;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;          ...   &#125;</code></pre><p>处理完由客户端调用的<code>transcat()</code>传递进来的<code>_data</code>，再将处理完的数据写入到<code>_reply</code>中。</p><p>工作流程为：</p><ol><li>获取由<code>transcat()</code>传入的数据，根据对应的<code>code</code>执行相应方法</li><li>执行方法后，解析对应传递过来的数据<code>_data</code></li><li>将需要回传的数据写入<code>_reply</code>中，传回给客户端</li></ol></li></ol></li></ol><pre><code>生成代码中 有调用到对应生成的`addBook()`等定义方法。这些方法的实际实现都要在`Server`端中实现。<pre><code class="hljs java"><span class="hljs-comment">// Server端  对应Android中的Service</span><span class="hljs-comment">//需要注意并发处理</span> <span class="hljs-keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;(); <span class="hljs-keyword">private</span> Binder mBinder = <span class="hljs-keyword">new</span> IBookManager.Stub() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title">getBookList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;            <span class="hljs-keyword">return</span> mBookList;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">addBook</span><span class="hljs-params">(Book book)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;            book.setName(<span class="hljs-string">"new Name in"</span>);            <span class="hljs-comment">//实现了对应的 addBook方法</span>            mBookList.add(book);            <span class="hljs-keyword">return</span> book;        &#125;           <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerListener</span><span class="hljs-params">(IOnNewBookArrivedListener listener)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;            mListenList.register(listener);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unregisterListener</span><span class="hljs-params">(IOnNewBookArrivedListener listener)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;            mListenList.unregister(listener);        &#125;    &#125;;</code></pre></code></pre><p>   <code>IBookManager.Stub.Proxy</code> 它并没有继承自Binder，而是包含了一个IBinder对象，这个对象其实是BinderProxy，说明它是Server在Client中的本地代理对象(<code>ProxyObject</code>)。这个类运行在<code>Client</code>，<code>Client</code>调用这个类来调用服务端的代码(涉及到了<strong>代理模式</strong>)</p>   <pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">example</span>.<span class="hljs-title">wxy</span>.<span class="hljs-title">ipc</span>.<span class="hljs-title">IBookManager</span> </span>&#123;           <span class="hljs-keyword">private</span> android.os.IBinder mRemote;              Proxy(android.os.IBinder remote) &#123;               mRemote = remote;           &#125;              <span class="hljs-meta">@Override</span>           <span class="hljs-keyword">public</span> android.os.<span class="hljs-function">IBinder <span class="hljs-title">asBinder</span><span class="hljs-params">()</span> </span>&#123;               <span class="hljs-keyword">return</span> mRemote;           &#125;              <span class="hljs-keyword">public</span> java.lang.<span class="hljs-function">String <span class="hljs-title">getInterfaceDescriptor</span><span class="hljs-params">()</span> </span>&#123;               <span class="hljs-keyword">return</span> DESCRIPTOR;           &#125;              <span class="hljs-comment">/**            * Demonstrates some basic types that you can use as parameters            * and return values in AIDL.            */</span>           <span class="hljs-meta">@Override</span>           <span class="hljs-keyword">public</span> java.util.List&lt;com.example.wxy.ipc.Book&gt; getBookList() <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;               android.os.Parcel _data = android.os.Parcel.obtain();               android.os.Parcel _reply = android.os.Parcel.obtain();               java.util.List&lt;com.example.wxy.ipc.Book&gt; _result;               <span class="hljs-keyword">try</span> &#123;                   _data.writeInterfaceToken(DESCRIPTOR);                   mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="hljs-number">0</span>);                   _reply.readException();                   _result = _reply.createTypedArrayList(com.example.wxy.ipc.Book.CREATOR);               &#125; <span class="hljs-keyword">finally</span> &#123;                   _reply.recycle();                   _data.recycle();               &#125;               <span class="hljs-keyword">return</span> _result;           &#125;              <span class="hljs-meta">@Override</span>           <span class="hljs-keyword">public</span> com.example.wxy.ipc.<span class="hljs-function">Book <span class="hljs-title">addBookIn</span><span class="hljs-params">(com.example.wxy.ipc.Book book)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException </span>&#123;               android.os.Parcel _data = android.os.Parcel.obtain();               android.os.Parcel _reply = android.os.Parcel.obtain();               com.example.wxy.ipc.Book _result;               <span class="hljs-keyword">try</span> &#123;                   _data.writeInterfaceToken(DESCRIPTOR);                   <span class="hljs-keyword">if</span> ((book != <span class="hljs-keyword">null</span>)) &#123;                       _data.writeInt(<span class="hljs-number">1</span>);                       book.writeToParcel(_data, <span class="hljs-number">0</span>);                   &#125; <span class="hljs-keyword">else</span> &#123;                       _data.writeInt(<span class="hljs-number">0</span>);                   &#125;                   mRemote.transact(Stub.TRANSACTION_addBookIn, _data, _reply, <span class="hljs-number">0</span>);                   _reply.readException();                   <span class="hljs-keyword">if</span> ((<span class="hljs-number">0</span> != _reply.readInt())) &#123;                       _result = com.example.wxy.ipc.Book.CREATOR.createFromParcel(_reply);                   &#125; <span class="hljs-keyword">else</span> &#123;                       _result = <span class="hljs-keyword">null</span>;                   &#125;               &#125; <span class="hljs-keyword">finally</span> &#123;                   _reply.recycle();                   _data.recycle();               &#125;               <span class="hljs-keyword">return</span> _result;           &#125;  ...    &#125;</code></pre><p>   分析上述生成的代码：</p><ul><li><code>_data _reply</code>：<code>_data</code>存储传参的数据，<code>_reply</code>存储方法的返回值数据</li><li><p><code>transcat(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags)</code>：客户端和服务端通信的核心方法。调用后会挂起当前线程，等候服务端执行任务完成通知并接受返回的<code>_reply</code>数据。</p><ul><li><code>code</code>：分配的方法ID是自动生成的</li></ul><p>工作流程为：</p></li></ul><ol><li>生成<code>_data</code> 和<code>_reply</code>数据，在<code>_data</code>中存入客户端数据</li><li>调用<code>transcat()</code>传递数据至服务端，并调用服务端中<code>onTranscat()</code>的指定方法</li><li>接收<code>_reply</code>数据，取出服务端返回的数据使用</li></ol><p>结构拆分明确后，可以大概的理解内部的工作机制。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Binder-workflow.png" srcset="/img/loading.gif" class="full-image" alt="Binder工作机制" title="Binder工作机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><p><strong>Client调用远程Binder代理对象，Client线程挂起，等待Server响应数据</strong></p><p>客户端要访问Binder的远程服务，就要获取远程服务的Binder对象在Binder驱动中的<code>mRemote</code>引用，获取到引用后既可以调用相关方法。</p></li><li><p><strong>Binder代理对象将请求发送给<code>Binder驱动</code></strong></p><p>在服务端成功Binder对象后，Binder驱动会创建一个<code>mRemote</code>对象，客户端可以借助它调用<code>transcat()</code>向服务端发送消息</p></li><li><p><strong><code>Binder驱动</code>将请求派发给Server端</strong></p><p>在Server端创建好一个Binder对象后，内部就会开启一个线程用于接收Binder驱动发送的消息，收到消息后就会执行<code>onTransact()</code>,然后按照参数执行不同的服务端代码。</p></li><li><p><strong>唤醒Client线程，返回结果</strong></p><p><code>onTranscat()</code>处理完成后，将结果写入<code>_reply</code>中并返回至<code>Binder驱动</code>，唤醒被挂起的Client线程。</p></li></ul><h4 id="4-可能产生的问题"><a href="#4-可能产生的问题" class="headerlink" title="4.可能产生的问题"></a>4.可能产生的问题</h4><ol><li><p>可能会产生ANR</p><p>由于客户端在调用远程服务方法时，客户端线程会被挂起，如果服务端的方法执行比较耗时，就会导致客户端ANR，或者在<code>onServiceConnected</code>和<code>onServiceDisconnected</code>中调用了服务端的耗时方法也会导致ANR。</p><p>当服务端调用客户端的listener方法时，该方法会运行在客户端的<code>binder线程池中</code>，若调用了耗时方法，也会导致ANR。</p><p><strong>客户端调用放在非UI线程</strong></p></li><li><p>AIDL解注册失败</p><blockquote><p>服务端无法找到注册时使用的listener而导致解注册失败。<strong>因为Binder客户端会把传递过来的对象重新转化并生成一个新的对象，而且对象是不能跨进程传输的，对象跨进程传输的本质就是序列化和反序列化的过程。</strong></p></blockquote><p>这时需要用到<code>RemoteCallBackList</code>，是系统专门提供用于删除跨进程的listener的接口，而且内部实现了线程同步的功能<strong>(内部使用了<code>synchronized</code>)</strong>。使用注意事项:<strong><code>beginBroadcast</code>和<code>finishBroadcast</code>必须要配对使用。</strong></p></li><li><p>性能损耗较大</p><blockquote><p>客户端频繁调用服务端方法，就需要实现一个<strong>观察者模式</strong>，当客户端的数据发生变化时再去通知服务端操作，减少频繁查询。</p></blockquote></li></ol><h4 id="5-拓展"><a href="#5-拓展" class="headerlink" title="5.拓展"></a>5.拓展</h4><ol><li><p>权限验证</p><blockquote><p>默认情况下，远程服务所有人都可以进行连接并调用，所以应该需要加入权限验证系统来保证安全。</p></blockquote><pre><code class="hljs xml">//在AndroidManifest.xml中定义该权限    <span class="hljs-tag">&lt;<span class="hljs-name">permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.example.wxy.permission.checkBook"</span>                <span class="hljs-attr">android:protectionLevel</span>=<span class="hljs-string">"normal"</span>/&gt;</span>//如果注册了该权限，则可以绑定成功 否则失败<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.example.wxy.permission.checkBook"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">service</span>    <span class="hljs-attr">android:name</span>=<span class="hljs-string">".service.AIDLService"</span>    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"true"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.example.wxy"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.DEFAULT"</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span></code></pre></li></ol><h2 id="8-Binder连接池"><a href="#8-Binder连接池" class="headerlink" title="8.Binder连接池"></a>8.Binder连接池</h2><blockquote><p>首先回顾一下AIDL的使用方式：①创建一个Service和AIDL接口②创建一个类继承自AIDL接口中的Stub类并实现Stub中的抽象方法③在Service的onBind中返回这个类的对象④客户端绑定Service后就可以直接访问服务端的方法。</p><p>当业务需求越来越多时，上述的创建方式就会产生很多Service类，导致系统资源耗费颜值、应用过度重量级的问题。所以产生了<code>Binder连接池</code>的概念。</p></blockquote><blockquote><p>主要作用为 <strong>将每个业务模块的Binder请求统一转发到远程Service上去执行，从而避免重复创建Service</strong>。   </p></blockquote><p>工作原理：</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/BinderPool.png" srcset="/img/loading.gif" class="full-image" alt="BinderPool工作原理" title="BinderPool工作原理"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>每个业务模块创建自己的AIDL接口并实现，然后向服务端传递自己的<strong>唯一标识(BinderCode)及对应的Binder对象</strong>。服务端只要一个Service，然后实现<code>queryBinder()</code>接口，根据唯一标识返回对应的Binder对象。</p><p>实现方式：</p><ul><li>创建对应的AIDL文件并有具体实现</li><li>创建BinderPool.java以及IBinderPool.aidl文件</li><li>实现远程服务BinderPoolService，并在onBind()中返回实例化的BinderPool对象</li><li>实现BinderPool方法，并在<code>queryBinder()</code>中做好对应处理</li><li>客户端调用BinderPoolService</li></ul><h2 id="9-Binder跨进程传输大文件"><a href="#9-Binder跨进程传输大文件" class="headerlink" title="9.Binder跨进程传输大文件"></a>9.Binder跨进程传输大文件</h2><p>Intent传递数据是有大小限制的，</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/ea4fc6aefaa8" target="_blank" rel="noopener">一次Binder通信最多可以传输多大的数据</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity的生命周期和启动模式</title>
    <link href="/2019/01/04/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/01/04/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity的生命周期和启动模式"><a href="#Activity的生命周期和启动模式" class="headerlink" title="Activity的生命周期和启动模式"></a>Activity的生命周期和启动模式</h1><!--standard，singleTop，singleTask，singleInstance  什么时候会用到singleTask？Activity之间的通信方式 横竖屏切换的时候，Activity 各种情况下的生命周期 Activity上有Dialog的时候按Home键时的生命周期 两个Activity 之间跳转时必然会执行的是哪几个方法？activity栈 下拉状态栏是不是影响activity的生命周期，如果在onStop的时候做了网络请求，onResume的时候怎么恢复--><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Activity生命周期和启动模式.png" srcset="/img/loading.gif" class="full-image" alt="Activity生命周期和启动模式" title="Activity生命周期和启动模式"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><a id="more"></a><h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/activity_lifecycle.jpeg" srcset="/img/loading.gif" class="full-image" alt="Activity生命周期" title="Activity生命周期"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="正常情况下的Activity生命周期"><a href="#正常情况下的Activity生命周期" class="headerlink" title="正常情况下的Activity生命周期"></a>正常情况下的Activity生命周期</h3><p>正常情况下，Activity会经历如下生命周期</p><h4 id="onCreate-Bundle-savedInstanceState-–创建"><a href="#onCreate-Bundle-savedInstanceState-–创建" class="headerlink" title="onCreate(Bundle savedInstanceState) –创建"></a>onCreate(Bundle savedInstanceState) –创建</h4><blockquote><p><strong>表示Activity正在被创建，是生命周期的第一个方法</strong></p><p>可以做一些初始化工作，调用<code>setContentView()</code>加载布局，初始化Activity需要的数据</p><p><em>onCreate 入参的 savedInstanceState其实就是 由于Activity异常销毁存储下来的数据</em></p></blockquote><h4 id="onRestart-–-重启"><a href="#onRestart-–-重启" class="headerlink" title="onRestart() – 重启"></a>onRestart() – 重启</h4><blockquote><p><strong>表示Activity正在重新启动，当当前Activity从不可见切换到可见时，就会触发</strong></p><p>随后就会调用到<code>onStart()</code>方法</p></blockquote><h4 id="onStart-–-可见"><a href="#onStart-–-可见" class="headerlink" title="onStart() – 可见"></a>onStart() – 可见</h4><blockquote><p><strong>表示Activity正在启动，这时Activity已经可见了，但没有出现在前台无法与用户交互</strong></p></blockquote><h4 id="onResume-–可交互"><a href="#onResume-–可交互" class="headerlink" title="onResume() –可交互"></a>onResume() –可交互</h4><blockquote><p><strong>表示Activity已经可见了，并且出现在前台且可以与用户交互。</strong></p></blockquote><h4 id="onPause-–-不可交互"><a href="#onPause-–-不可交互" class="headerlink" title="onPause() – 不可交互"></a>onPause() – 不可交互</h4><blockquote><p><strong>表示Activity正在停止，此时可以做一些<code>存储数据、停止动画</code>等操作</strong></p><p><em><code>onPause</code> 中不能执行过于耗时操作，会影响到下一个新Activity的显示。旧Activity必须执行完<code>onPause()</code>后，新Activity的<code>onResume()</code>才可以执行。</em></p></blockquote><h4 id="onStop-–-不可见"><a href="#onStop-–-不可见" class="headerlink" title="onStop() – 不可见"></a>onStop() – 不可见</h4><blockquote><p><strong>表示Activity即将停止，此时Activity已经不可见，可以做一些稍微重量级的回收工作(<code>取消网络连接，注销广播监听器等</code>)，同样不能太耗时。</strong></p><p><em>当新Activity为透明主题即旧Activity依然可见，或者弹出一个框，都不会执行旧Activity的<code>onStop()</code></em></p></blockquote><h4 id="onDestroy-–-销毁"><a href="#onDestroy-–-销毁" class="headerlink" title="onDestroy() – 销毁"></a>onDestroy() – 销毁</h4><blockquote><p><strong>表示Activity即将被销毁，这时可以做一些回收工作以及资源的释放。</strong></p></blockquote><p>拓展</p><p><em>Activity在处于<code>onPause(),onStop(),onDestroy()</code>状态下，进程优先级较低，容易被回收，所以需要保存一些数据时，<font color="red">必须在onPause中存储</font>，其他两个周期不一定能调用到。</em></p><h3 id="Activity生命周期的阶段"><a href="#Activity生命周期的阶段" class="headerlink" title="Activity生命周期的阶段"></a>Activity生命周期的阶段</h3><p>可以分为以下3个阶段：</p><ul><li><p>完整生命周期</p><blockquote><p>从<code>onCreate() 初始化</code>开始直到<code>onDestroy() 释放资源</code>结束</p></blockquote></li><li><p>可见生命周期</p><blockquote><p>从<code>onStart() 可见</code>到<code>onStop() 不可见</code>结束</p></blockquote></li><li><p>前台生命周期</p><blockquote><p>从<code>onResume() 可交互</code>到<code>onPause() 无法交互</code>结束</p></blockquote></li></ul><h3 id="Activity生命周期的切换过程"><a href="#Activity生命周期的切换过程" class="headerlink" title="Activity生命周期的切换过程"></a>Activity生命周期的切换过程</h3><ul><li><p>启动Activity</p><p><code>onCreate() -&gt; onStart() -&gt; onResume()</code></p></li><li><p>打开新的Activity</p><p><code>旧Activity.onPause() -&gt; Activity.onCreate() -&gt; Activity.onStart() -&gt; Activity.onResume()-&gt; 旧Activity.onStop()</code></p></li><li><p>返回上一个Activity</p><p><code>新Activity.onPause() -&gt; 旧Activity.onRestart() -&gt; 旧Activity.onStart() -&gt; 旧Activity.onResume() -&gt; 新Activity.onStop() -&gt; 新Activity.onDestroy()</code></p></li><li><p>弹出对话框</p><ul><li>自身调用弹出  <code>不会有生命周期变化</code></li><li>外部调用弹出  <code>当前Activity.onPause()</code></li></ul></li><li><p>关闭屏幕/按Home键</p><ul><li><code>onPause() -&gt; onStop()</code></li><li>新Activity显示，旧Activity依然可见 <code>新Activity.onPause() -&gt; 新Activity.onStop() -&gt; 旧Activity.onStop()</code></li></ul></li><li><p>点亮屏幕/回到应用</p><ul><li><code>onRestart() -&gt; onStart() -&gt; onResume()</code></li><li>新Activity显示，旧Activity依然可见 <code>新Activity.onRestart() -&gt; 新Acticvity.onStart() -&gt; 旧Activity.onRestart() -&gt;旧Activity.onStart() -&gt; 新Activity.onResume()</code></li></ul></li><li><p>销毁Activity</p><ul><li><code>onPause() -&gt; onStop() -&gt; onDestroy()</code></li><li>新Activity显示，旧Activity依然可见，销毁新Acticvity <code>新Activity.onPause() -&gt; 旧Activity.onResume() -&gt; 旧Activity.onStop() -&gt; 旧Activity.onDestroy()</code></li></ul></li><li><p>弹出对话框样式的Activity</p><p><code>旧Activity.onPause() -&gt; 新Activity.onCreate() -&gt; 新Activity.onStart() -&gt; 新Activity.onResume()</code></p></li><li><p>状态栏下拉</p><p><code>不会有生命周期变化,如果需要监听可以 使用 onWindowFocusChanged()</code></p></li><li><p>横竖屏切换下的生命周期</p><p>这是一个 销毁重建的过程</p><p><code>onPause() -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onResume()</code></p></li></ul><h3 id="异常情况下的生命周期分析"><a href="#异常情况下的生命周期分析" class="headerlink" title="异常情况下的生命周期分析"></a>异常情况下的生命周期分析</h3><blockquote><p>Activity除了上述正常情况下执行的生命周期调度，还会有一些异常情况会导致Activity被杀死。</p><p>例如在执行到<code>onPause()</code>或<code>onStop()</code>时，Activity进入了Finish状态，表示被异常终止。</p></blockquote><h4 id="由于资源相关的系统配置发生改变导致Activity被杀死并重新构建"><a href="#由于资源相关的系统配置发生改变导致Activity被杀死并重新构建" class="headerlink" title="由于资源相关的系统配置发生改变导致Activity被杀死并重新构建"></a>由于资源相关的系统配置发生改变导致Activity被杀死并重新构建</h4><p>例如：当Activity发生横竖屏切换时，发了系统配置的改变，在默认情况下Activity就会被销毁并重建。</p><blockquote><p>如何避免配置改变导致Activity重新创建？</p><p>可以在<code>AndroidManifest.xml</code>中指定对应的系统属性，这样在触发对应改变时，不会再杀死并重建，会调用到<code>onConfigurationChanged()</code>，只需重写该方法即可。</p><p>例如配置了<code>android:configChanges=&quot;orientation&quot;</code>，横竖屏切换时就不会触发重建。</p></blockquote><h4 id="由于系统资源不足，导致优先级低的Activity被杀死"><a href="#由于系统资源不足，导致优先级低的Activity被杀死" class="headerlink" title="由于系统资源不足，导致优先级低的Activity被杀死"></a>由于系统资源不足，导致优先级低的Activity被杀死</h4><p>这里需要先了解Activity的优先级情况。按照从高到低分为以下三种：</p><ol><li><strong>前台Activity</strong>：正在和用户交互的Activity</li><li><strong>可见但非前台Activity</strong>：前台的Activity弹出一个Dialog，导致无法交互</li><li><strong>后台Activity</strong>：已经被暂停的Activity，比如切到后台或者切换应用</li></ol><p><strong>当系统内存不足时，系统就会按照上述描述的优先级去杀死目标Activity所在进程。</strong></p><p>如果一个进程中没有四大组件在执行，进程很快被系统杀死。</p><p>当上述两种情况发生时，Activity的生命周期会发生如下变化：</p><ul><li><p>Activity被杀死：<code>onPause() -&gt; onSaveInstanceState() -&gt; onStop() -&gt; onDestroy()</code></p><p>系统异常终止时，调用<code>onSaveInstanceState()</code>保存数据。该方法调用在<code>onStop()</code>之前。</p><p>保存数据过程是利用一种<code>委托</code>的思想，上层委托下层。</p></li><li><p>Activity重建：<code>onCreate() -&gt; onStart() -&gt; onRestoreInstanceState() -&gt; onResume()</code></p><p>重新创建时，调用<code>onRestoreInstanceState()</code>，调用在<code>onStart()</code>之后，该方法会把<code>onSaveInstanceState()</code>存储的Bundle对象拿出来解析。</p><p><em><code>onCreate和onRestoreInstanceState</code>都可以获取存储的对象，推荐使用<code>onRestoreInstanceState</code>不需要额外的去判断是否为空。</em></p></li></ul><p><strong>系统只有在异常终止的情况下才会调用<code>onSaveInstanceState和onRestoreInstanceState</code>进行存储和恢复数据。</strong></p><p>拓展：</p><ol><li>还有一些会在Activity运行过程中的触发方法，这里简单的提及一下：<ul><li><code>onPostCreate()</code>：在<code>onCreate()</code>执行完毕后回调</li><li><code>onUserInteraction()</code>：所有Activity上的触摸事件 优先调用该方法</li><li><code>onUserLeaveHint()</code>：用户主动离开Activity调用该方法，例如点击Home</li><li><code>onContentChanged()</code>：Activity 调用<code>setContentView()</code>完成后调用</li></ul></li></ol><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><h3 id="Activity的任务栈"><a href="#Activity的任务栈" class="headerlink" title="Activity的任务栈"></a>Activity的任务栈</h3><blockquote><p>当我们多次启动一个Activity的时候，系统会创建多个实例并放入任务栈中，当我们触发<code>finish</code>时，Activity会一一回退。<strong>任务栈是一种先进后出的栈结构。</strong></p><p>任务栈又分为<code>前台任务栈</code>和<code>后台任务栈</code>。<code>后台任务栈</code>中的Activity位于暂停状态.</p></blockquote><ul><li>程序在创建时就会创建一个Activity任务栈，存储当前程序的Activity</li><li>任务栈是Activity的集合，只有位于栈顶的Activity可以和用户交互</li><li>任务栈可以移动到后台并保留了Activity的状态</li><li>退出应用程序时，任务栈会被清空，然后会被系统回收。</li></ul><p>利用<code>adb shell dumpsys activity</code>查看当前任务栈</p><h3 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h3><blockquote><p>LaunchMode为了减少Activity实例的创建优化</p></blockquote><p>使用方法：</p><ul><li>在<code>AndroidManifest.xml</code>中给对应Activity配置属性 <code>android:launchMode=&quot;standard | singltTop | singleTask | singleInstance&quot;</code></li><li><code>startActivity</code>时添加<code>intent.addFlags(FLAG)</code></li></ul><h4 id="standard-标准模式-默认这个"><a href="#standard-标准模式-默认这个" class="headerlink" title="standard 标准模式(默认这个)"></a>standard 标准模式(默认这个)</h4><blockquote><p>每次启动一个新的Activity都会创建一个新的Activity实例。</p><p><em>若启动Activity的是除了Activity之外的context对象就需要指定<code>FLAG_ACTIVITY_NEW_TASK</code>标记位，创建一个新的任务栈。因为standard默认进入启动方的任务栈，由于他们是没有自身的任务栈，所以需要新建。</em></p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/launchmode_standard.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="Standard"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="singleTop-栈顶复用模式"><a href="#singleTop-栈顶复用模式" class="headerlink" title="singleTop 栈顶复用模式"></a>singleTop 栈顶复用模式</h4><blockquote><p>如果要启动的Activity位于栈顶，就不会重新创建，并且调用<code>onNewIntent(Intent intent)</code>取出当前请求的信息。</p><p><em>还会调用<code>onPause()以及onResume()</code>。</em></p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/launchmode_singletop.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="SingleTop"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>A位于栈顶，B位于栈底。如果A的启动模式为<code>singleTop</code>，再次启动A，栈内情况不会发生变化，依然为AB</p><p>如果启动B，则会创建新的实例，不论是否为<code>singleTop</code>。</p><h4 id="singleTask-栈内复用模式"><a href="#singleTask-栈内复用模式" class="headerlink" title="singleTask 栈内复用模式"></a>singleTask 栈内复用模式</h4><blockquote><p>栈内只要存在Activity实例，再次启动都不会重新创建实例，只会回调<code>onNewIntent()</code>，并从栈内弹出该实例上的所有Activity。</p><p>适合作为应用主入口，因为只会启动一次。</p></blockquote><p>列举3个实例加深理解：</p><ul><li><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/launchmode_singletask3.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="SingleTask"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>目前S1中由ABC三个实例，这时D以<code>singleTask</code>模式请求启动且所需任务栈为<code>S2</code>，由于<code>S2</code>和<code>D</code>实例均不存在，所以系统会创建<code>S2</code>任务栈并把实例<code>D</code>入栈到<code>S2</code>。</p></li><li><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/launchmode_singletask1.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="SingleTask"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>目前S1中由ABC三个实例，这时D以<code>singleTask</code>模式请求启动且所需任务栈为<code>S1</code>，由于<code>S1</code>已经存在，所以直接入栈并置于栈顶。</p></li><li><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/launchmode_singletask2.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="SingleTask"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>目前S1中由ABCD四个实例，这时B以<code>singleTask</code>模式请求启动且所需任务栈为<code>S1</code>，此时B不会重新创建，将直接回调<code>onNewIntent()</code>并置于栈顶。<em>原先位于B实例上的CD都被清除，因为默认具有clear_top 效果，最终就变成了AB</em></p></li></ul><h4 id="singleInstance-单实例模式"><a href="#singleInstance-单实例模式" class="headerlink" title="singleInstance 单实例模式"></a>singleInstance 单实例模式</h4><blockquote><p>加强的singleTask模式，除了singleTask拥有的特性外，还加强了一点。使用了这个模式启动的Activity只能单独的位于一个任务栈中。启动时会新开一个任务栈并直接创建实例压入栈中。</p><p><em>即使设置了相同的任务栈名，也不能放在一个栈中。</em></p></blockquote><h4 id="TaskAffinity-–-栈亲和性"><a href="#TaskAffinity-–-栈亲和性" class="headerlink" title="TaskAffinity – 栈亲和性"></a>TaskAffinity – 栈亲和性</h4><blockquote><p>taskAffinity：标识了一个Activity所需要任务栈的名字，默认情况下，所有Activity所需的任务栈名字为应用的包名。我们也可以为每个Activity指定任务栈，利用<code>android:taskAffinity</code>属性标记。</p></blockquote><ul><li><p>配合<code>singleTask</code>使用</p><p>新Activity启动时默认被加载进启动该Activity的对象所在任务栈中。如果给启动的Activity设置<code>FLAG_ACTIVITY_NEW_TASK</code>标记或者设置<code>singleTask</code>启动模式，再配合<code>taskAffinity</code>设置任务栈名字，该实例就会被加载进相同名字的任务栈中，如果不存在相同就创建新的任务栈并压入实例。</p></li><li><p>配合<code>allowTaskReparenting</code>使用</p><blockquote><p>allowTaskReparenting 作用是 是否允许Activity更换从属任务。true表示可以更换，默认为false</p></blockquote><p>简单描述： 有两个APP，A和B，此时应用A去启动应用B中的一个Activity，并且该Activity设置<code>allowTaskReparenting = true</code>，此时这个Activity的任务栈就会位于应用A中，当去启动B时，会优先展示已被启动的Activity，由于设置了<code>allowTaskReparenting</code>该Activity的任务栈又回到了B中。</p><!--？？？ allowTaskReparenting = true 且两个Activity的TaskAffinity 相同会如何--></li></ul><blockquote><p>拓展知识：</p></blockquote><h3 id="Activity的行为标志和属性"><a href="#Activity的行为标志和属性" class="headerlink" title="Activity的行为标志和属性"></a>Activity的行为标志和属性</h3><h4 id="Activity的Flag"><a href="#Activity的Flag" class="headerlink" title="Activity的Flag"></a>Activity的Flag</h4><blockquote><p>有些标记位可以设置启动模式，还有的可以影响Activity的运行状态。</p></blockquote><h5 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h5><blockquote><p>作用等同 <code>singleTask</code>启动模式</p></blockquote><h5 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h5><blockquote><p>作用等同<code>singleTop</code>启动模式</p></blockquote><h5 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h5><blockquote><p>当用这个标记启动对应Activity时，在同一个任务栈中的且位于它上面的Activity实例都会被消除。一般配合<code>singleTask</code>使用</p></blockquote><h5 id="FLAG-ACTIVITY-EXCLUDE-FROM-RECENTS"><a href="#FLAG-ACTIVITY-EXCLUDE-FROM-RECENTS" class="headerlink" title="FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS"></a>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</h5><blockquote><p>对应的配置为在<code>AndroidManifest.xml</code>中使用<code>android:excludeFromRecents=&quot;true&quot;</code></p><p>具有这个标记的Activity不会出现在后台任务列表中</p></blockquote><h4 id="IntenFilter的匹配规则"><a href="#IntenFilter的匹配规则" class="headerlink" title="IntenFilter的匹配规则"></a>IntenFilter的匹配规则</h4><blockquote><p>启动Activity方法分为两种：<code>显式调用(可以清楚指出被启动组件的信息，例如类名)</code>，<code>隐式调用(没有明确的指出组件信息，通过IntentFilter找到符合要求的组件)</code>。</p></blockquote><p>匹配规则：</p><ol><li>一个intent只有同时匹配某个Activity定义的<code>&lt;intent-filter&gt;</code>中定义的<code>action,category,data</code>才可以完全匹配，打开对应的Activity</li><li>一个Activity可以定义多个<intent-filter>，只要匹配任意一组就可以启动该Activity</intent-filter></li></ol><h5 id="action匹配规则"><a href="#action匹配规则" class="headerlink" title="action匹配规则"></a>action匹配规则</h5><blockquote><p>只要传递过来的Intent中定义的<code>action</code>可以匹配<code>&lt;intent-filter&gt;</code>定义的任一<code>action</code>，必须要完全相同且区分大小写。</p></blockquote><h5 id="category匹配规则"><a href="#category匹配规则" class="headerlink" title="category匹配规则"></a>category匹配规则</h5><blockquote><p>传递过来的Intent中不包含<code>categroy</code>，那么就会启用默认的<code>categroy</code>，由于系统在启动Activity的时候默认会加上<code>android.intent.categroy.DEFAULT</code>属性</p><p>如果包含<code>categroy</code>，那必须匹配<code>&lt;intent-filter&gt;</code>定义的任一<code>categroy</code></p></blockquote><h5 id="data匹配规则"><a href="#data匹配规则" class="headerlink" title="data匹配规则"></a>data匹配规则</h5><blockquote><p>传递过来的Intent定义的<code>data</code>可以匹配<code>&lt;intent-filter&gt;</code>定义的任一<code>data</code></p></blockquote><p>data主要分为两部分：</p><ul><li><code>mimeType</code>：媒体类型，例如<code>text/plain</code>这类，还包括图片，视频类型</li><li><code>URL</code>：地址 包含了<code>host(主机名)，scheme(模式)，port(端口号)，path(路径信息)</code>等</li></ul><p><em>隐式启动时，如果无法找到要启动的组件，就会抛出异常。我们就可以利用<code>PackageManager.resolveActivity()</code>或者<code>Intent.resolveActivity()</code>避免异常出现。</em></p><h4 id="清理任务栈"><a href="#清理任务栈" class="headerlink" title="清理任务栈"></a>清理任务栈</h4><blockquote><p>当用户离开一个任务时间很长时，系统将会清除除了根Activity之外的所有Activity，当用户重新回到应用时，只能看到根Activity。</p></blockquote><p>系统提供了几种机制来调整这个规则：</p><ul><li><p><code>android:alwaysRetainTaskState</code></p><p>标记应用的Task是否保持原来的状态，若为<code>true</code>，系统尝试保留所有Activity</p></li><li><p><code>android:clearTaskOnLaunch</code></p><p>标记是否从Task清除所有Activity除了根Activity，用户每次重新打开只会看到根Activity</p></li><li><p><code>android:finishOnTaskLaunch</code></p><p>只作用于单个Activity，若设置true，用户离开后回来就会消失</p></li></ul><h3 id="启动模式源码分析"><a href="#启动模式源码分析" class="headerlink" title="启动模式源码分析"></a>启动模式源码分析</h3><blockquote><p>关键节点在 <code>ActivityStarter.java</code>类下</p></blockquote><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ol><li><p>何时会调用<code>onNewIntent()</code>?</p><ul><li>LaunchMode设置为<code>singleTop</code>，且要启动的Activity已经处于栈顶</li><li>LaunchMode设置为<code>singleTask</code>或者<code>singleInstance</code>，且实例已存在</li></ul><p>需要注意的是：<em>当调用到<code>onNewIntent(intent)</code>的时候，需要在内部调用<code>setNewIntent(intent)</code>赋值给当前Activity的Intent，否则后续的getIntent()得到的都是老Intent</em></p></li><li><p>监控应用回到桌面或者应用退出</p><pre><code class="hljs java">registerActivityLifecycleCallbacks(<span class="hljs-keyword">new</span> ActivityLifecycleCallbacks() &#123;           <span class="hljs-keyword">int</span> createdActivityCount = <span class="hljs-number">0</span>;           <span class="hljs-keyword">int</span> startedActivityCount = <span class="hljs-number">0</span>;              <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;               createdActivityCount++;           &#125;              <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityStarted</span><span class="hljs-params">(Activity activity)</span> </span>&#123;               startedActivityCount++;           &#125;              <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResumed</span><span class="hljs-params">(Activity activity)</span> </span>&#123;              &#125;              <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityPaused</span><span class="hljs-params">(Activity activity)</span> </span>&#123;              &#125;              <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityStopped</span><span class="hljs-params">(Activity activity)</span> </span>&#123;               startedActivityCount--;               <span class="hljs-comment">// isChangingConfigurations 避免因为应用配置变化导致的退出使统计失误</span>               <span class="hljs-keyword">if</span> (startedActivityCount == <span class="hljs-number">0</span> &amp;&amp; !activity.isChangingConfigurations() &amp;&amp; !activity.isFinishing()) &#123;                   Log.e(<span class="hljs-string">"Home"</span>, <span class="hljs-string">"回到桌面"</span>);               &#125;           &#125;              <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivitySaveInstanceState</span><span class="hljs-params">(Activity activity, Bundle outState)</span> </span>&#123;              &#125;              <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(Activity activity)</span> </span>&#123;               createdActivityCount--;               <span class="hljs-keyword">if</span> (createdActivityCount == <span class="hljs-number">0</span> &amp;&amp; !activity.isChangingConfigurations()) &#123;                   Log.e(<span class="hljs-string">"Exit"</span>, <span class="hljs-string">"应用退出"</span>);               &#125;           &#125;       &#125;);</code></pre></li></ol><ol start="3"><li>s</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ListView简析</title>
    <link href="/2019/01/04/ListView%E7%AE%80%E6%9E%90/"/>
    <url>/2019/01/04/ListView%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ListView机制.png" srcset="/img/loading.gif" class="full-image" alt="ListView机制" title="ListView机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="ListView定义"><a href="#ListView定义" class="headerlink" title="ListView定义"></a>ListView定义</h2><blockquote><p>专门用于处理那种内容元素很多，手机屏幕无法展示出所有的内容的情况。可以使用列表的形式来展示内容，超出屏幕部分的内容只需要通过手指滑动就可以移到屏幕内了。</p></blockquote><p>ListView相比RecyclerView，有一些优点：</p><ul><li><code>addHeaderVew()</code>，<code>addFooterView()</code>添加头尾视图</li><li><code>android:divider</code>设置自定义分割线</li><li><code>setOnItemClickListener</code>设置点击事件</li></ul><p>上述功能没有直接在RecyclerView直接提供，要自己实现。<em>如果只是简单的展示内容，使用ListView相对更简单。</em></p><h2 id="ListView用法"><a href="#ListView用法" class="headerlink" title="ListView用法"></a>ListView用法</h2><ul><li><p>创建Adapter：在ListView和数据源之间起到了一个桥梁的作用，ListView借用Adapter和数据去打交道。</p><blockquote><p>常见的Adapter有以下几类：</p><ul><li><code>BaseAdapter</code>：基础数据适配器。</li><li><code>SimpleAdapter</code>：简单适配器，系统自定义了一些方法。</li><li><code>ArrayAdapter</code>：数据和UI一对一。</li><li><code>SimpleCursorAdapter</code>：用于游标类型的数据源适配。</li></ul></blockquote><p>一般都会去继承<code>BaseAdapter</code>自定义实现功能</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListViewAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseAdapter</span> </span>&#123;    Context context;    List&lt;String&gt; data;    LayoutInflater mInflater;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListViewAdapter</span><span class="hljs-params">(Context _context, List&lt;String&gt; _data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.context = _context;        <span class="hljs-keyword">this</span>.data = _data;        mInflater = LayoutInflater.from(context);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> data == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : data.size();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getItem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getItemId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-keyword">return</span> position;    &#125;        <span class="hljs-comment">//在其中完善 Item的创建以及数据绑定流程</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;        ViewHolder viewHolder;        <span class="hljs-keyword">if</span> (convertView == <span class="hljs-keyword">null</span>) &#123;            convertView = mInflater.inflate(R.layout.item_demo, <span class="hljs-keyword">null</span>);            viewHolder = <span class="hljs-keyword">new</span> ViewHolder();            viewHolder.title = convertView.findViewById(R.id.title);            convertView.setTag(viewHolder);        &#125; <span class="hljs-keyword">else</span> &#123;            viewHolder = (ViewHolder) convertView.getTag();        &#125;        viewHolder.title.setText(data.get(position));        <span class="hljs-keyword">return</span> convertView;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewHolder</span> </span>&#123;        TextView title;    &#125;&#125;</code></pre></li><li><p>ListView绑定Adapter</p><pre><code class="hljs java">listView.addHeaderView(headerView);listView.addFooterView(footerView);listView.setAdapter(<span class="hljs-keyword">new</span> ListViewAdapter(Activity.<span class="hljs-keyword">this</span>,datas));<span class="hljs-comment">//设置ListView 的 item点击事件</span>listView.setOnItemClickListener(<span class="hljs-keyword">new</span> AdapterView.OnItemClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemClick</span><span class="hljs-params">(AdapterView&lt;?&gt; parent, View view, <span class="hljs-keyword">int</span> position, <span class="hljs-keyword">long</span> id)</span> </span>&#123;                            &#125;        &#125;);</code></pre></li></ul><h2 id="ListView源码解析"><a href="#ListView源码解析" class="headerlink" title="ListView源码解析"></a>ListView源码解析</h2><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><blockquote><p>ListView是以<code>View</code>作为单位进行回收。<code>RecycleBin</code>是ListView缓存机制的实现类。</p></blockquote><p>RecycleBin实现的是<strong>二级缓存</strong>。</p><ul><li><code>View[] mActiveViews</code>：缓存屏幕上的View，在该缓存中的View不需要调用<code>getView()</code></li><li><code>ArrayList&lt;View&gt;[] mScrapViews</code>：对应了每个<code>ItemType</code>，缓存由于滚动而消失的View，此处的View如果被复用，会以参数的形式传给<code>getView()</code>。</li></ul><p>ListView通过调用<code>layoutChildren()</code>对子Item进行布局，一般发生在滑动时刻。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layoutChildren</span><span class="hljs-params">()</span> </span>&#123;  ...    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> firstPosition = mFirstPosition;    <span class="hljs-keyword">final</span> RecycleBin recycleBin = mRecycler;    <span class="hljs-comment">//如果数据源发生了改变，就将所有的itemView都回收至scrapView</span>    <span class="hljs-keyword">if</span> (dataChanged) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;            recycleBin.addScrapView(getChildAt(i), firstPosition+i);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//没有发生改变 ，缓存至mActiveViews</span>        recycleBin.fillActiveViews(childCount, firstPosition);    &#125;    <span class="hljs-comment">//清空所有View 防止第二次layout过程产生一份重复数据</span>    detachAllViewsFromParent();    <span class="hljs-comment">//填充子Item</span>    <span class="hljs-keyword">switch</span> (mLayoutMode) &#123;           <span class="hljs-keyword">case</span> LAYOUT_SET_SELECTION:                <span class="hljs-keyword">if</span> (newSel != <span class="hljs-keyword">null</span>) &#123;                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);                &#125; <span class="hljs-keyword">else</span> &#123;                    sel = fillFromMiddle(childrenTop, childrenBottom);                &#125;                <span class="hljs-keyword">break</span>;           ...    &#125;    <span class="hljs-comment">//回收多余的ActiveView</span>    recycleBin.scrapActiveViews();&#125;</code></pre><p><code>layoutChildren()</code>调用<code>fillXX()</code>在不同位置填充item。其中的主要实现方法是<code>makeAndAddView()</code>实现填充View逻辑。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> View <span class="hljs-title">makeAndAddView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">boolean</span> flow, <span class="hljs-keyword">int</span> childrenLeft,        <span class="hljs-keyword">boolean</span> selected)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!mDataChanged) &#123;        <span class="hljs-comment">// 获取缓存在 mActiveViews中的view</span>        <span class="hljs-keyword">final</span> View activeView = mRecycler.getActiveView(position);        <span class="hljs-keyword">if</span> (activeView != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//重新布局子View</span>            setupChild(activeView, position, y, flow, childrenLeft, selected, <span class="hljs-keyword">true</span>);            <span class="hljs-keyword">return</span> activeView;        &#125;    &#125;    <span class="hljs-comment">//从 mCraspViews中去获取或者 重新生成一个View</span>    <span class="hljs-keyword">final</span> View child = obtainView(position, mIsScrap);    <span class="hljs-comment">// This needs to be positioned and measured.</span>    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">return</span> child;&#125;</code></pre><p>如果从<code>mActiveViews</code>中获取到了对应的View，就直接取出来，然后调用<code>setUpChild()</code>把子View重新attach到ListView上。</p><p>如果没有找到合适的View，就需要调用到<code>obtainView()</code>，重新执行<code>getView()</code>流程生成对应布局，影响加载效率。</p><pre><code class="hljs java"><span class="hljs-function">View <span class="hljs-title">obtainView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">boolean</span>[] outMetadata)</span> </span>&#123;  ...     <span class="hljs-comment">//获取刚刚因为滑动而消失的View</span>     <span class="hljs-keyword">final</span> View transientView = mRecycler.getTransientStateView(position);        <span class="hljs-keyword">if</span> (transientView != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> LayoutParams params = (LayoutParams) transientView.getLayoutParams();            <span class="hljs-comment">// If the view type hasn't changed, attempt to re-bind the data.</span>            <span class="hljs-keyword">if</span> (params.viewType == mAdapter.getItemViewType(position)) &#123;                <span class="hljs-keyword">final</span> View updatedView = mAdapter.getView(position, transientView, <span class="hljs-keyword">this</span>);                <span class="hljs-comment">// If we failed to re-bind the data, scrap the obtained view.</span>                <span class="hljs-keyword">if</span> (updatedView != transientView) &#123;                    setItemViewLayoutParams(updatedView, position);                    mRecycler.addScrapView(updatedView, position);                &#125;            &#125;            outMetadata[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">// Finish the temporary detach started in addScrapView().</span>            transientView.dispatchFinishTemporaryDetach();            <span class="hljs-keyword">return</span> transientView;        &#125;           <span class="hljs-comment">//从RecycleBin获取可复用的View</span>     <span class="hljs-keyword">final</span> View scrapView = mRecycler.getScrapView(position);        <span class="hljs-comment">//实质调用 我们自定义的getView事件 scrapView 对应的 就是 convertView ,如果为null ，就需要重新 inflate重新加载布局</span>        <span class="hljs-keyword">final</span> View child = mAdapter.getView(position, scrapView, <span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> (scrapView != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (child != scrapView) &#123;                <span class="hljs-comment">// 生成了一个新的View  要重新插入缓存中</span>                mRecycler.addScrapView(scrapView, position);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.isTemporarilyDetached()) &#123;                outMetadata[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;                <span class="hljs-comment">// Finish the temporary detach started in addScrapView().</span>                child.dispatchFinishTemporaryDetach();            &#125;        &#125;  ...&#125;</code></pre><p>接下来介绍<code>getScrapView(position)</code>的实现，该方法通过<code>position</code>得到<code>ItemType</code>，然后根据<code>ItemType</code>从<code>mScrapViews</code>获取可复用的View，如果获取不到，则返回null，</p><pre><code class="hljs java">       <span class="hljs-function">View <span class="hljs-title">getScrapView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> whichScrap = mAdapter.getItemViewType(position);           <span class="hljs-keyword">if</span> (whichScrap &lt; <span class="hljs-number">0</span>) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;           &#125;           <span class="hljs-keyword">if</span> (mViewTypeCount == <span class="hljs-number">1</span>) &#123;               <span class="hljs-keyword">return</span> retrieveFromScrap(mCurrentScrap, position);           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (whichScrap &lt; mScrapViews.length) &#123;               <span class="hljs-keyword">return</span> retrieveFromScrap(mScrapViews[whichScrap], position);           &#125;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;       &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> View <span class="hljs-title">retrieveFromScrap</span><span class="hljs-params">(ArrayList&lt;View&gt; scrapViews, <span class="hljs-keyword">int</span> position)</span> </span>&#123;           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = scrapViews.size();           <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;               <span class="hljs-comment">// See if we still have a view for this position or ID.</span>               <span class="hljs-comment">// Traverse backwards to find the most recently used scrap view</span>               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                   <span class="hljs-keyword">final</span> View view = scrapViews.get(i);                   <span class="hljs-keyword">final</span> AbsListView.LayoutParams params =                           (AbsListView.LayoutParams) view.getLayoutParams();                   <span class="hljs-keyword">if</span> (mAdapterHasStableIds) &#123;                       <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> id = mAdapter.getItemId(position);                       <span class="hljs-keyword">if</span> (id == params.itemId) &#123;                           <span class="hljs-keyword">return</span> scrapViews.remove(i);                       &#125;                   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (params.scrappedFromPosition == position) &#123;                       <span class="hljs-keyword">final</span> View scrap = scrapViews.remove(i);                       clearScrapForRebind(scrap);                       <span class="hljs-keyword">return</span> scrap;                   &#125;               &#125;               <span class="hljs-comment">//取出缓存列表的最后一条数据进行复用</span>               <span class="hljs-keyword">final</span> View scrap = scrapViews.remove(size - <span class="hljs-number">1</span>);               clearScrapForRebind(scrap);               <span class="hljs-keyword">return</span> scrap;           &#125; <span class="hljs-keyword">else</span> &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;           &#125;       &#125;</code></pre><p>得到需要显示的View后，再调用<code>setUpChild()</code>显示在界面上</p><pre><code class="hljs java"><span class="hljs-comment">//fromActiveView  isAttachedToWindow为true</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setupChild</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">boolean</span> flowDown, <span class="hljs-keyword">int</span> childrenLeft,            <span class="hljs-keyword">boolean</span> selected, <span class="hljs-keyword">boolean</span> isAttachedToWindow<span class="hljs-comment">/*这个View当前是否已显示*/</span>)</span> </span>&#123;    ...          <span class="hljs-keyword">if</span> ((isAttachedToWindow &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter                &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;            attachViewToParent(child, flowDown ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>, p);            <span class="hljs-keyword">if</span> (isAttachedToWindow                    &amp;&amp; (((AbsListView.LayoutParams) child.getLayoutParams()).scrappedFromPosition)                            != position) &#123;                child.jumpDrawablesToCurrentState();            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            p.forceAdd = <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">if</span> (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;                p.recycledHeaderFooter = <span class="hljs-keyword">true</span>;            &#125;            addViewInLayout(child, flowDown ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>, p, <span class="hljs-keyword">true</span>);            <span class="hljs-comment">// add view in layout will reset the RTL properties. We have to re-resolve them</span>            child.resolveRtlPropertiesIfNeeded();        &#125;    &#125;</code></pre><p>观察上述源码可知，缓存机制简单分为以下几步：</p><ul><li>ListView滑动时，会调用到<code>layoutChildren()</code>对子View进行重新布局，如果数据源没有发生改变，需要把当前屏幕上存在的View缓存至<code>mActiveViews</code>中；发生了改变的话，就都缓存至<code>mScrapViews</code>中。</li><li>清除掉ListView的所有子View</li><li>开始进行数据填充，主要实现逻辑是<code>makeAndAddView()</code>。这里分为两部分：如果可以从<code>mActiveViews</code>获取到View，就直接插入该View；没有获取到合适的View，需要调用<code>obtainView()</code>从<code>mScrapViews</code>获取可复用的View，然后重新走加载布局(<code>getView()</code>)的流程。</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ListView缓存过程.png" srcset="/img/loading.gif" class="full-image" alt="ListView缓存过程" title="ListView缓存过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="ListView优化"><a href="#ListView优化" class="headerlink" title="ListView优化"></a>ListView优化</h2><ul><li><code>ConverView重用机制</code>：在<code>getView()</code>中使用<code>convertView</code>，就不需要每次都去inflate一个View出来，减少内存损耗。</li><li><code>ViewHolder</code>：使用ViewHolder，避免在<code>getView()</code>频繁调用使用<code>findViewById()</code>，节省内存</li><li><code>滑动时不载入图片</code>：给ListView设置<code>setOnScrollListener()</code>，在其中<code>onScrollStateChanged()</code>判断是否为滑动状态，是的话就停止加载图片。</li><li><code>getView()不执行耗时操作</code>：<code>getView()</code>是执行在主线程的，需要减少耗时操作。</li><li><code>设置scrollingCache和animateCache为false</code>：默认都是开启的，会消耗大量内存。</li><li><code>降低Item的层级</code></li></ul><h2 id="ListView拓展"><a href="#ListView拓展" class="headerlink" title="ListView拓展"></a>ListView拓展</h2><h3 id="ListView局部刷新"><a href="#ListView局部刷新" class="headerlink" title="ListView局部刷新"></a>ListView局部刷新</h3><blockquote><p>平常用到ListView的时候，如果需要对单个Item进行刷新，我们就会调用到<code>notifyDataSetChanged()</code>去进行全量刷新，效率很低。</p></blockquote><p>ListView局部刷新有3种方案可以实现：</p><ol><li><p>更新对应View内容</p><blockquote><p>通过<code>listView.getChildAt(pos)</code>拿到需要更新的item布局，然后通过<code>findViewById()</code>去找到对应的控件进行设置</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateItemView</span><span class="hljs-params">(ListView listView,<span class="hljs-keyword">int</span> pos,Data data<span class="hljs-comment">/*需要更新的内容*/</span>)</span></span>&#123;  <span class="hljs-keyword">int</span> firstVisiblePosition = listView.getFirstVisiblePosition();  <span class="hljs-keyword">int</span> lastVisiblePosition = listView.getLastVisiblePosition();    <span class="hljs-keyword">if</span>(pos&gt;=firstVisiblePosition &amp;&amp; pos&lt;= lastVisiblePosition)&#123;    View view = listView.getChildAt(pos-firstVisiblePosition);    TextView textView= view.findViewById(R.id.textView);    textView.setText(data.getXX());  &#125;&#125;</code></pre></li><li><p>通过ViewHolder去设置</p><blockquote><p>通过Item找到对应ViewHolder，通过ViewHolder设置数据</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateItemView</span><span class="hljs-params">(ListView listView,<span class="hljs-keyword">int</span> pos,Data data<span class="hljs-comment">/*需要更新的内容*/</span>)</span></span>&#123;  <span class="hljs-keyword">int</span> firstVisiblePosition = listView.getFirstVisiblePosition();  <span class="hljs-keyword">int</span> lastVisiblePosition = listView.getLastVisiblePosition();    <span class="hljs-keyword">if</span>(pos&gt;=firstVisiblePosition &amp;&amp; pos&lt;= lastVisiblePosition)&#123;    View view = listView.getChildAt(pos-firstVisiblePosition);    ViewHolder viewHolder = (ViewHolder)view.getTag();    TextView textView= iewHolder.textView;    textView.setText(data.getXX());  &#125;&#125;</code></pre></li><li><p>再调用一次<code>getView()</code></p><blockquote><p>调用Adapter的<code>getView()</code>，对内部的View进行刷新。<em>Google官方推荐做法。</em></p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//外部对数据源进行变化，内部自动去更新</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateItemView</span><span class="hljs-params">(ListView listView,<span class="hljs-keyword">int</span> pos,Data data<span class="hljs-comment">/*需要更新的内容*/</span>)</span></span>&#123;  <span class="hljs-keyword">int</span> firstVisiblePosition = listView.getFirstVisiblePosition();  <span class="hljs-keyword">int</span> lastVisiblePosition = listView.getLastVisiblePosition();    <span class="hljs-keyword">if</span>(pos&gt;=firstVisiblePosition &amp;&amp; pos&lt;= lastVisiblePosition)&#123;    View view = listView.getChildAt(pos-firstVisiblePosition);    listViewAdapter.getView(pos,view,listView)  &#125;&#125;</code></pre></li></ol><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA?" target="_blank" rel="noopener">RecyclerView必知必会</a></p><p><a href="https://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">Android ListView工作原理完全解析，带你从源码的角度彻底理解</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>include、merge及ViewStub相关</title>
    <link href="/2019/01/03/include%E3%80%81merge-ViewStub%E7%9B%B8%E5%85%B3/"/>
    <url>/2019/01/03/include%E3%80%81merge-ViewStub%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="主要解析include、merge及ViewStub"><a href="#主要解析include、merge及ViewStub" class="headerlink" title="主要解析include、merge及ViewStub"></a>主要解析include、merge及ViewStub</h1><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/布局优化之xml方面.png" srcset="/img/loading.gif" class="full-image" alt="布局优化之xml方面" title="布局优化之xml方面"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><blockquote><p>主要为了解决重复定义相同布局的问题。把一套布局封装起来，需要使用时使用<include>标签引入。提高代码复用性</include></p><p>使用注意事项：</p><ol><li>如若我们在<include>中设置了android:id属性，这个id会覆盖原先`<include>中layout设置的布局id，所以在引用该id时需要注意</include></include></li><li>如果需要在<include>中需要使用andrdoid:**属性，必须要设置layout_width以及layout_height属性</include></li></ol></blockquote><p>源码分析：</p><p>从Activity创建开始，调用<code>setContentView()</code>传入对应xml文件，然后开始解析并绘制。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/Activity.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> layoutResID)</span></span>&#123;  <span class="hljs-comment">//getWindow() 对应的就是PhoneWindow </span>  getWindow().setContentView(layoutResID);  initWindowDecorActionBar();&#125;<span class="hljs-comment">// ../com/android/internal/policy/PhoneWindow.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;        <span class="hljs-comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span>        <span class="hljs-comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span>        <span class="hljs-comment">// before this happens.</span>        <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//初始化 DecorView</span>            installDecor();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;            mContentParent.removeAllViews();        &#125;        <span class="hljs-keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;            <span class="hljs-keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,                    getContext());            transitionTo(newScene);        &#125; <span class="hljs-keyword">else</span> &#123;           <span class="hljs-comment">//渲染传进来的xml</span>            mLayoutInflater.inflate(layoutResID, mContentParent);        &#125;        mContentParent.requestApplyInsets();        <span class="hljs-keyword">final</span> Callback cb = getCallback();        <span class="hljs-keyword">if</span> (cb != <span class="hljs-keyword">null</span> &amp;&amp; !isDestroyed()) &#123;            cb.onContentChanged();        &#125;        mContentParentExplicitlySet = <span class="hljs-keyword">true</span>;    &#125;<span class="hljs-comment">// ../android/view/LayoutInflater.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(XmlPullParser parser, @Nullable ViewGroup root)</span> </span>&#123;        <span class="hljs-keyword">return</span> inflate(parser, root, root != <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> resource, @Nullable ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span> </span>&#123;        <span class="hljs-keyword">final</span> Resources res = getContext().getResources();        <span class="hljs-keyword">final</span> XmlResourceParser parser = res.getLayout(resource);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> inflate(parser, root, attachToRoot);        &#125; <span class="hljs-keyword">finally</span> &#123;            parser.close();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (mConstructorArgs) &#123;          ...            <span class="hljs-keyword">final</span> String name = parser.getName();            <span class="hljs-comment">//如果是merge标签</span>            <span class="hljs-keyword">if</span> (TAG_MERGE.equals(name)) &#123;                    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !attachToRoot) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"&lt;merge /&gt; can be used only with a valid "</span>                                + <span class="hljs-string">"ViewGroup root and attachToRoot=true"</span>);                    &#125;                    rInflate(parser, root, inflaterContext, attrs, <span class="hljs-keyword">false</span>);            &#125; <span class="hljs-keyword">else</span> &#123;              ...                    rInflateChildren(parser, temp, attrs, <span class="hljs-keyword">true</span>);            &#125;          ...        &#125;    &#125;<span class="hljs-comment">//解析所有子控件</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rInflateChildren</span><span class="hljs-params">(XmlPullParser parser, View parent, AttributeSet attrs,            <span class="hljs-keyword">boolean</span> finishInflate)</span> <span class="hljs-keyword">throws</span> XmlPullParserException, IOException </span>&#123;        rInflate(parser, parent, parent.getContext(), attrs, finishInflate);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rInflate</span><span class="hljs-params">(XmlPullParser parser, View parent, Context context,            AttributeSet attrs, <span class="hljs-keyword">boolean</span> finishInflate)</span> <span class="hljs-keyword">throws</span> XmlPullParserException, IOException </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> depth = parser.getDepth();        <span class="hljs-keyword">int</span> type;        <span class="hljs-keyword">boolean</span> pendingRequestFocus = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||                parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;            <span class="hljs-keyword">if</span> (type != XmlPullParser.START_TAG) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">final</span> String name = parser.getName();                        <span class="hljs-keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;                pendingRequestFocus = <span class="hljs-keyword">true</span>;                consumeChildElements(parser);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_TAG.equals(name)) &#123;                parseViewTag(parser, parent, attrs);              <span class="hljs-comment">//解析到&lt;include&gt;标签</span>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;                <span class="hljs-keyword">if</span> (parser.getDepth() == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"&lt;include /&gt; cannot be the root element"</span>);                &#125;               <span class="hljs-comment">//解析include中包含的布局</span>                parseInclude(parser, context, parent, attrs);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_MERGE.equals(name)) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"&lt;merge /&gt; must be the root element"</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">final</span> View view = createViewFromTag(parent, name, context, attrs);                <span class="hljs-keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;                <span class="hljs-keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);                rInflateChildren(parser, view, attrs, <span class="hljs-keyword">true</span>);                viewGroup.addView(view, params);            &#125;        &#125;        <span class="hljs-keyword">if</span> (pendingRequestFocus) &#123;            parent.restoreDefaultFocus();        &#125;      <span class="hljs-comment">//当系统解析完View之后调用</span>        <span class="hljs-keyword">if</span> (finishInflate) &#123;            parent.onFinishInflate();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseInclude</span><span class="hljs-params">(XmlPullParser parser, Context context, View parent,            AttributeSet attrs)</span> <span class="hljs-keyword">throws</span> XmlPullParserException, IOException </span>&#123;      <span class="hljs-comment">// include标签必须在ViewGroup中使用</span>      <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> ViewGroup) &#123;         ...           <span class="hljs-comment">//解析android:layout 属性</span>           <span class="hljs-keyword">int</span> layout = attrs.getAttributeResourceValue(<span class="hljs-keyword">null</span>, ATTR_LAYOUT, <span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (layout == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">final</span> String value = attrs.getAttributeValue(<span class="hljs-keyword">null</span>, ATTR_LAYOUT);                <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span> || value.length() &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"You must specify a layout in the"</span>                            + <span class="hljs-string">" include tag: &lt;include layout=\"@layout/layoutID\" /&gt;"</span>);                &#125;                layout = context.getResources().getIdentifier(                        value.substring(<span class="hljs-number">1</span>), <span class="hljs-string">"attr"</span>, context.getPackageName());            &#125;                <span class="hljs-keyword">if</span> (layout == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">final</span> String value = attrs.getAttributeValue(<span class="hljs-keyword">null</span>, ATTR_LAYOUT);            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"You must specify a valid layout "</span>                        + <span class="hljs-string">"reference. The layout ID "</span> + value + <span class="hljs-string">" is not valid."</span>);            &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">if</span> (TAG_MERGE.equals(childName)) &#123;              rInflate(childParser, parent, context, childAttrs, <span class="hljs-keyword">false</span>);          &#125; <span class="hljs-keyword">else</span> &#123;             <span class="hljs-comment">//继续渲染子布局</span>              rInflateChildren(childParser, view, childAttrs, <span class="hljs-keyword">true</span>);              <span class="hljs-comment">//覆盖原有id</span>              <span class="hljs-keyword">if</span> (id != View.NO_ID) &#123;                      view.setId(id);              &#125;           &#125;          ...          group.addView(view);        &#125;      &#125;    &#125;</code></pre><p>若存在<code>&lt;include&gt;</code>标签，会去解析<code>&lt;include&gt;</code>标签中的layout，解析完成后，会把解析得到的View加回到原有布局中。</p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><blockquote><p>减少层级布局，可以将<merge>标签下的子View直接添加到<merge>标签的parent中，可以减少不必要的层级。添加的子View遵循父布局的布局方式。</merge></merge></p><p><code>&lt;merge&gt;</code>标签一般和<code>&lt;include&gt;</code>标签搭配使用，<code>&lt;merge&gt;</code>标签不支持设置<code>android:**</code>属性，因为它不是View，只是声明了一些View。</p><p><em>使用<code>LayoutInflate.inflate(resId,viewroot,attachToRoot)</code>渲染时，第二个viewroot必须设置，且第三个参数必须为true。</em></p><p><strong><merge>标签最好是替代FlameLayout或者与父布局方向一致的LinearLayout</merge></strong></p></blockquote><p>上述源码中，<code>inflate()</code>执行时判断<code>name</code>为<code>TAG_MERGE</code>时就会直接调用<code>rInflate()</code></p><pre><code class="hljs java">在普通xml中引用merge布局都是 通过include引用的  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseInclude</span><span class="hljs-params">(XmlPullParser parser, Context context, View parent,            AttributeSet attrs)</span> <span class="hljs-keyword">throws</span> XmlPullParserException, IOException </span>&#123;  ...               <span class="hljs-keyword">final</span> View view = createViewFromTag(parent, name, attrs);                 <span class="hljs-comment">// 获取merge标签的parent  </span>               <span class="hljs-keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;                 <span class="hljs-comment">// 获取布局参数  </span>               <span class="hljs-keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);                 <span class="hljs-comment">// 递归解析每个子元素  </span>               rInflate(parser, view, attrs, <span class="hljs-keyword">true</span>);                 <span class="hljs-comment">// 将子元素直接添加到merge标签的parent view中  </span>               viewGroup.addView(view, params);    ...&#125;</code></pre><p>从上述源码分析中可得 <merge>标签对应的View会直接添加至父容器中，减少一层布局。</merge></p><p>拓展：</p><ol><li>如果Activity布局的根节点为<code>FlameLayout</code>，可以直接替换为<code>&lt;merge&gt;</code>标签，执行<code>setContentView()</code>后可以减少一层布局</li><li>自定义View如果继承<code>LinearLayout</code>，可以把自定义View的布局文件根节点设置为<code>&lt;merge&gt;</code></li></ol><h2 id="ViewStub"><a href="#ViewStub" class="headerlink" title="ViewStub"></a>ViewStub</h2><blockquote><p>ViewStub继承了View，非常轻量级且宽高都为0，因为本身不参与任何的布局和绘制过程。主要用于 一些不常出现的界面可以按需加载，提高加载效率。</p></blockquote><p>源码分析：</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewStub.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewStub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">View</span> </span>&#123;          <span class="hljs-comment">//初始化ViewStub</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ViewStub</span><span class="hljs-params">(Context context, AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr, <span class="hljs-keyword">int</span> defStyleRes)</span> </span>&#123;        <span class="hljs-keyword">super</span>(context);        <span class="hljs-keyword">final</span> TypedArray a = context.obtainStyledAttributes(attrs,                R.styleable.ViewStub, defStyleAttr, defStyleRes);        mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID);        mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, <span class="hljs-number">0</span>);        mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID);        a.recycle();        <span class="hljs-comment">//默认隐藏</span>        setVisibility(GONE);        <span class="hljs-comment">//阻止View的绘制</span>        setWillNotDraw(<span class="hljs-keyword">true</span>);    &#125;    ...    <span class="hljs-comment">//设置宽高为0</span>      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;        setMeasuredDimension(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    &#125;  <span class="hljs-comment">//空实现 不会绘制任何内容</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;    &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVisibility</span><span class="hljs-params">(<span class="hljs-keyword">int</span> visibility)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mInflatedViewRef != <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-comment">//如果已经渲染完成 与普通View逻辑相同</span>            View view = mInflatedViewRef.get();            <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;                view.setVisibility(visibility);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"setVisibility called on un-referenced view"</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">super</span>.setVisibility(visibility);            <span class="hljs-keyword">if</span> (visibility == VISIBLE || visibility == INVISIBLE) &#123;                <span class="hljs-comment">//需要渲染View</span>                inflate();            &#125;        &#125;    &#125;    <span class="hljs-comment">//渲染代码</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> ViewParent viewParent = getParent();        <span class="hljs-keyword">if</span> (viewParent != <span class="hljs-keyword">null</span> &amp;&amp; viewParent <span class="hljs-keyword">instanceof</span> ViewGroup) &#123;            <span class="hljs-keyword">if</span> (mLayoutResource != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">final</span> ViewGroup parent = (ViewGroup) viewParent;                <span class="hljs-comment">//添加并渲染View</span>                <span class="hljs-keyword">final</span> View view = inflateViewNoAdd(parent);                <span class="hljs-comment">//移除原来定义的ViewStub 替换渲染的View上去</span>                replaceSelfWithView(view, parent);                mInflatedViewRef = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(view);                <span class="hljs-keyword">if</span> (mInflateListener != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">//监听渲染完成</span>                    mInflateListener.onInflate(<span class="hljs-keyword">this</span>, view);                &#125;                <span class="hljs-keyword">return</span> view;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"ViewStub must have a valid layoutResource"</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"ViewStub must have a non-null ViewGroup viewParent"</span>);        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> View <span class="hljs-title">inflateViewNoAdd</span><span class="hljs-params">(ViewGroup parent)</span> </span>&#123;        <span class="hljs-keyword">final</span> LayoutInflater factory;        <span class="hljs-keyword">if</span> (mInflater != <span class="hljs-keyword">null</span>) &#123;            factory = mInflater;        &#125; <span class="hljs-keyword">else</span> &#123;            factory = LayoutInflater.from(mContext);        &#125;        <span class="hljs-comment">//渲染View</span>        <span class="hljs-keyword">final</span> View view = factory.inflate(mLayoutResource, parent, <span class="hljs-keyword">false</span>);        <span class="hljs-keyword">if</span> (mInflatedId != NO_ID) &#123;          <span class="hljs-comment">//赋值设置的id到ViewStub渲染的View上</span>            view.setId(mInflatedId);        &#125;        <span class="hljs-keyword">return</span> view;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceSelfWithView</span><span class="hljs-params">(View view, ViewGroup parent)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = parent.indexOfChild(<span class="hljs-keyword">this</span>);        <span class="hljs-comment">//移除本身存在的ViewStub</span>        parent.removeViewInLayout(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">final</span> ViewGroup.LayoutParams layoutParams = getLayoutParams();        <span class="hljs-comment">//以ViewStub自身设置的 LayoutParams为准 </span>        <span class="hljs-keyword">if</span> (layoutParams != <span class="hljs-keyword">null</span>) &#123;            parent.addView(view, index, layoutParams);        &#125; <span class="hljs-keyword">else</span> &#123;            parent.addView(view, index);        &#125;    &#125;&#125;</code></pre><p>根据上述源码发现，<code>inflate()</code>只可以调用一次，否则会因移除ViewStub出错。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>布局优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity启动过程</title>
    <link href="/2019/01/02/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/01/02/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<!--ams是怎么找到启动的那个activity 从framework的角度讲activity的启动流程(冷启动) Application attach之前干了些什么？APP启动进程的时候，会处理些什么？ onResume的时候，已经是第一帧绘制了吗？如果不是，那什么时候是呢？--><blockquote><p>下列源码分析是基于 Android 8.0源码</p></blockquote><p>Activity的启动过程分为两种：</p><ul><li><strong>根Activity的启动过程</strong>  -  指代根Actiivty的启动过程也可以认为是应用程序的启动过程</li><li><strong>普通Activity的启动过程</strong>  -  除启动应用程序启动的第一个Activity之外Activity的启动过程</li></ul><h2 id="根Activity启动过程"><a href="#根Activity启动过程" class="headerlink" title="根Activity启动过程"></a>根Activity启动过程</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/根Activity启动过程.png" srcset="/img/loading.gif" class="full-image" alt="根Activity启动过程-冷启动" title="根Activity启动过程-冷启动"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>点击桌面的应用程序图标就是启动根Activity的入口，当我们点击某个应用程序图标时，就会通过Launcher请求AMS来启动该应用程序。</p><p>其中涉及了三个进程间的通信：<code>Launcher组件</code>，<code>AMS</code>，<code>Activity组件</code>。</p></blockquote><h3 id="Launcher请求AMS过程"><a href="#Launcher请求AMS过程" class="headerlink" title="Launcher请求AMS过程"></a>Launcher请求AMS过程</h3><p>当我们在应用程序启动器Launcher上点击一个应用的图标时，Launcher组件就会调用<code>startActivitySafely()</code>启动该App的根Activity。</p><p>配置根Activity，需要在AndroidManifest.xml中配置 相关属性</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>           <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MainActivity"</span>           <span class="hljs-attr">android:label</span>=<span class="hljs-string">"@string/app_name"</span>           <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@style/AppTheme.NoActionBar"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span></code></pre><p>Launcher组件中<code>startActivitySafely()</code>相关操作</p><pre><code class="hljs java"><span class="hljs-comment">// packages/apps/Launcher3/src/com/android/Launcher3/Launcher.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startActivitySafely</span><span class="hljs-params">(View v,Intent intent,ItemInfo item)</span></span>&#123;  ...    intent.addFlags(Intent.FFLAG_ACTIVITY_NEW_TASK);  <span class="hljs-keyword">try</span>&#123;    <span class="hljs-keyword">if</span>(Utilities.ATLEAST_MARSHMELLOW      &amp;&amp;(item <span class="hljs-keyword">instanceof</span> ShortcutInfo)      &amp;&amp;(item.itemType == Favorites.ITEM_TYPE_SHORTCUT      ||item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT)       &amp;&amp; !((ShortcutInfo)item).isPromise())&#123;      startShortcutIntentSafely(intent,optsBundle,item);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(user ==<span class="hljs-keyword">null</span> || user.equals(Process.myUserHandle()))&#123;      startActivity(intent,optsBundle);    &#125; <span class="hljs-keyword">else</span>&#123;      LauncherAppsCompat.getInstance(<span class="hljs-keyword">this</span>).startActivityForProfile(intent.getComponent(),                                    user,intent.getSourceBounds(),optsBundle)；    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;<span class="hljs-keyword">catch</span>(ActivityNotFoundException|SecurityException e)&#123;    ...  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><p>设置启动Acticvity为<code>FLAG_ACTIVITY_NEW_TASK</code>保证根Activity在一个新任务栈中启动。<code>Launcher.java</code>继承了<code>Activity</code>接下来就到了<code>Acticvity.startActivity()</code>中</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/Activity.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;        <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;            startActivityForResult(intent, -<span class="hljs-number">1</span>, options);        &#125; <span class="hljs-keyword">else</span> &#123;            startActivityForResult(intent, -<span class="hljs-number">1</span>);        &#125;    &#125;</code></pre><p>接下来会走到<code>startActivityFroResult()</code>，第二个参数设为<code>-1</code>表明<em>Launcher不需要知道返回结果</em></p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/Activity.java</span> Activity mParent; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivityForResult</span><span class="hljs-params">(@RequiresPermission Intent intent, <span class="hljs-keyword">int</span> requestCode,            @Nullable Bundle options)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;            options = transferSpringboardActivityOptions(options);            Instrumentation.ActivityResult ar =                mInstrumentation.execStartActivity(                    <span class="hljs-keyword">this</span>,               mMainThread.getApplicationThread(), <span class="hljs-comment">/*ApplicationThread*/</span>              mToken,               <span class="hljs-keyword">this</span>,                    intent, requestCode, options);          ...        &#125;<span class="hljs-keyword">else</span>&#123;          ...        &#125;   ... &#125;</code></pre><p><code>mParent</code>代表当前Activity的父类，由于<code>根Activity</code>还未创建出来，所以<code>mParent==null</code>成立。后续向下走就会调用到<code>Instrumentation.execStartActivity()</code>去继续启动Activity组件。</p><blockquote><p>Instrumentation用于监控应用程序和系统间的交互。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/    .java</span><span class="hljs-function"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title">execStartActivity</span><span class="hljs-params">(            Context who, IBinder contextThread, IBinder token, Activity target,            Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options)</span> </span>&#123;        ...        <span class="hljs-keyword">try</span> &#123;            intent.migrateExtraStreamToClipData();            intent.prepareToLeaveProcess(who);            <span class="hljs-keyword">int</span> result = ActivityManager.getService()                .startActivity(whoThread, who.getBasePackageName(), intent,                        intent.resolveTypeIfNeeded(who.getContentResolver()),                        token, target != <span class="hljs-keyword">null</span> ? target.mEmbeddedID : <span class="hljs-keyword">null</span>,                        requestCode, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, options);            <span class="hljs-comment">//检查启动Activity是否存在</span>            checkStartActivityResult(result, intent);        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Failure from system"</span>, e);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;</code></pre><!--`contenxtThread`是一个`IBinder对象`，实际指向的是`ApplicationThread`，用于进程间通信的Binder对象，可以--><p><code>ActivityManager.getService()</code>用于获取<code>AMS</code>的代理对象。实质上是把启动过程转移到了<code>AMS</code>上去执行</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityManager.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityManager <span class="hljs-title">getService</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> IActivityManagerSingleton.get();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =            <span class="hljs-keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;                    <span class="hljs-keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);                    <span class="hljs-keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);                    <span class="hljs-keyword">return</span> am;                &#125;            &#125;;<span class="hljs-comment">//../android/util/Singleton.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> T mInstance;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) &#123;                mInstance = create();            &#125;            <span class="hljs-keyword">return</span> mInstance;        &#125;    &#125;&#125;</code></pre><p>第一次调用到<code>getService()</code>时，就会调用到<code>IActivityManagerSingleton.get()</code>，由源码可知，该类是一个单例类。</p><p>在其中先去获取名为<code>activity</code>的一个代理对象(<code>IBinder</code>)，后续实现利用了<code>AIDL</code>，根据<code>asInterface()</code>可以获得<code>IActivityManager</code>对象，他是AMS在本地的代理对象。然后就可以直接调用到<code>AMS</code>的<code>startActivity()</code>。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Launcher请求AMS时序图.png" srcset="/img/loading.gif" class="full-image" alt="Launcher请求AMS时序图" title="Launcher请求AMS时序图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>总结：</p><ul><li>用户点击桌面图标触发<code>startActivitySafely()</code>开始调用打开根Activity流程。</li><li><code>Launcher组件</code>会调用到<code>Activity.startActivity()</code>后调用到<code>Activity.startActivityForResult()</code></li><li>由于从Launcher启动，根Activity尚未建立，就会走到<code>Instrumentation.execStartActivity()</code>中</li><li>在<code>Instrumentation.execStartActivity()</code>中，实际调用的是<code>ActivityManager.getService()</code>去继续启动Activity</li><li>跟踪到<code>ActivityManager.getService()</code>实际返回的是一个<code>AMS</code>的本地代理对象<code>IActivityManager</code>，由前面学到的Binder机制中，这个代理对象是可以直接调用到<code>AMS</code>中的方法，所以<code>execStartActivity()</code>最终指向的是<code>AMS.startActivity()</code></li></ul><h3 id="AMS到ApplicationThread的调用过程"><a href="#AMS到ApplicationThread的调用过程" class="headerlink" title="AMS到ApplicationThread的调用过程"></a>AMS到ApplicationThread的调用过程</h3><p>Launcher请求到AMS后，后续逻辑由AMS继续执行。继续执行的是<code>AMS.startActivity()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityManagerService.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,            <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;        <span class="hljs-keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,                resultWho, requestCode, startFlags, profilerInfo, bOptions,                UserHandle.getCallingUserId()<span class="hljs-comment">/*获取调用者的UserId*/</span>);    &#125;    <span class="hljs-comment">//检测调用是否合法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityAsUser</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,            <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="hljs-keyword">int</span> userId)</span> </span>&#123;        <span class="hljs-comment">//判断调用者进程是否被隔离</span>        enforceNotIsolatedCaller(<span class="hljs-string">"startActivity"</span>);        <span class="hljs-comment">//检测调用者权限</span>        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),                userId, <span class="hljs-keyword">false</span>, ALLOW_FULL_ONLY, <span class="hljs-string">"startActivity"</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Switch to user app stacks here.</span>        <span class="hljs-keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="hljs-number">1</span>, callingPackage, intent,                resolvedType, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, resultTo, resultWho, requestCode, startFlags,                profilerInfo, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, bOptions, <span class="hljs-keyword">false</span>, userId, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>,                <span class="hljs-string">"startActivityAsUser"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enforceNotIsolatedCaller</span><span class="hljs-params">(String caller)</span> </span>&#123;        <span class="hljs-keyword">if</span> (UserHandle.isIsolated(Binder.getCallingUid())) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<span class="hljs-string">"Isolated process not allowed to call "</span> + caller);        &#125;    &#125;</code></pre><p>进入到<code>AMS.startActivity()</code>中，会调用到<code>startActivityAsUser()</code>，在这个方法中需要去判断调用是否合法。需要先<code>检测调用者进程是否被隔离</code>以及<code>调用者权限是否正确</code>。</p><p>前面都通过的话，就会调用到<code>ActivityStarter.startActivityMayWait()</code>。没有通过校验的话就会抛出<code>SecurityException</code>异常。</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityStarter.java</span> <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityMayWait</span><span class="hljs-params">(IApplicationThread caller, <span class="hljs-keyword">int</span> callingUid,            String callingPackage, Intent intent, String resolvedType,            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,            IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> startFlags,            ProfilerInfo profilerInfo, WaitResult outResult,            Configuration globalConfig, Bundle bOptions, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">int</span> userId,            IActivityContainer iContainer, TaskRecord inTask<span class="hljs-comment">/*Activity所在任务栈*/</span>, String reason<span class="hljs-comment">/*启动理由*/</span>)</span> </span>&#123;   ...                 <span class="hljs-comment">//指向 startActivityLocked 方法</span>                 <span class="hljs-keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,                    aInfo, rInfo, voiceSession, voiceInteractor,                    resultTo, resultWho, requestCode, callingPid,                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,                    options, ignoreTargetSecurity, componentSpecified, outRecord, container,                    inTask, reason);   ...    &#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">startActivityLocked</span><span class="hljs-params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,            IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> callingPid, <span class="hljs-keyword">int</span> callingUid,            String callingPackage, <span class="hljs-keyword">int</span> realCallingPid, <span class="hljs-keyword">int</span> realCallingUid, <span class="hljs-keyword">int</span> startFlags,            ActivityOptions options, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">boolean</span> componentSpecified,            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,            TaskRecord inTask, String reason)</span> </span>&#123;        <span class="hljs-comment">//判断启动理由不可为空</span>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(reason)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Need to specify a reason."</span>);        &#125;        mLastStartReason = reason;        mLastStartActivityTimeMs = System.currentTimeMillis();        mLastStartActivityRecord[<span class="hljs-number">0</span>] = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//指向 startActivity 方法</span>        mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,                container, inTask);        <span class="hljs-keyword">if</span> (outActivity != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// mLastStartActivityRecord[0] is set in the call to startActivity above.</span>            outActivity[<span class="hljs-number">0</span>] = mLastStartActivityRecord[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">return</span> mLastStartActivityResult;    &#125;</code></pre><p><code>ActivityStarter</code>是Android7.0新加入的类，他是加载Activity的控制类，会收集所有的逻辑来决定如何将<code>Intent和Flags</code>转换为Activity，并将Activity和Task以及Stark相关联。</p><p>调用<code>startActivityLocked()</code>之后继续走向<code>ActivityStarter.startActivity()</code>过程</p><pre><code class="hljs java"><span class="hljs-comment">/** DO NOT call this method directly. Use &#123;<span class="hljs-doctag">@link</span> #startActivityLocked&#125; instead. */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,        IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> callingPid, <span class="hljs-keyword">int</span> callingUid,        String callingPackage, <span class="hljs-keyword">int</span> realCallingPid, <span class="hljs-keyword">int</span> realCallingUid, <span class="hljs-keyword">int</span> startFlags,        ActivityOptions options, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">boolean</span> componentSpecified,        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,        TaskRecord inTask)</span> </span>&#123;    <span class="hljs-keyword">int</span> err = ActivityManager.START_SUCCESS;    <span class="hljs-comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span>    <span class="hljs-keyword">final</span> Bundle verificationBundle            = options != <span class="hljs-keyword">null</span> ? options.popAppVerificationBundle() : <span class="hljs-keyword">null</span>;    ProcessRecord callerApp = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//这个caller是一直从Launcher启动时就传下来的</span>    <span class="hljs-keyword">if</span> (caller != <span class="hljs-keyword">null</span>) &#123;        callerApp = mService.getRecordForAppLocked(caller);        <span class="hljs-keyword">if</span> (callerApp != <span class="hljs-keyword">null</span>) &#123;            callingPid = callerApp.pid;            callingUid = callerApp.info.uid;        &#125; <span class="hljs-keyword">else</span> &#123;            Slog.w(TAG, <span class="hljs-string">"Unable to find app for caller "</span> + caller                    + <span class="hljs-string">" (pid="</span> + callingPid + <span class="hljs-string">") when starting: "</span>                    + intent.toString());            err = ActivityManager.START_PERMISSION_DENIED;        &#125;     &#125;...        ActivityRecord r = <span class="hljs-keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,            callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),            resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="hljs-keyword">null</span>,            mSupervisor, container, options, sourceRecord);    <span class="hljs-keyword">if</span> (outActivity != <span class="hljs-keyword">null</span>) &#123;        outActivity[<span class="hljs-number">0</span>] = r;    &#125;...    doPendingActivityLaunchesLocked(<span class="hljs-keyword">false</span>);    <span class="hljs-keyword">return</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, <span class="hljs-keyword">true</span>,            options, inTask, outActivity);&#125;</code></pre><p>第16行代码 <code>caller!=null</code> 这个<code>caller</code>对象是从Launcher启动时就一直传递下来的，指向的是<code>Launcher所在的应用程序进程的ApplicationThread对象</code>。</p><p>第17行代码 <code>mService.getRecordForAppLocked(caller)</code> 得到的就是一个<code>ProgreeRecord</code>对象(<code>用于描述一个应用程序进程</code>)。该对象指的就是 <em>Launcher组件所运行的应用程序进程</em>。</p><p>第30行代码 <code>new ActivityRecord()</code> <code>ActivityRecord用来记录一个Activity的所有信息。</code>在这里<code>ActivityRecord</code>指的就是将要启动的Activity即根Activity。</p><p>第39行代码 继续调用<code>startActivity()</code>并传递当前记录的Activity信息。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,        <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,        ActivityRecord[] outActivity)</span> </span>&#123;    <span class="hljs-keyword">int</span> result = START_CANCELED;    <span class="hljs-keyword">try</span> &#123;        mService.mWindowManager.deferSurfaceLayout();        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,                startFlags, doResume, options, inTask, outActivity);    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (!ActivityManager.isStartResultSuccessful(result)                &amp;&amp; mStartActivity.getTask() != <span class="hljs-keyword">null</span>) &#123;            mStartActivity.getTask().removeActivity(mStartActivity);        &#125;        mService.mWindowManager.continueSurfaceLayout();    &#125;           postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId,  mSourceRecord,            mTargetStack);    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityUnchecked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,        <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,        ActivityRecord[] outActivity)</span> </span>&#123;  ...    <span class="hljs-keyword">if</span> (mStartActivity.resultTo == <span class="hljs-keyword">null</span> &amp;&amp; mInTask == <span class="hljs-keyword">null</span> &amp;&amp; !mAddingToTask            &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果是使用 singleTask模式启动 会新建一个任务栈用来存储Activity</span>        newTask = <span class="hljs-keyword">true</span>;        result = setTaskFromReuseOrCreateNewTask(                taskToAffiliate, preferredLaunchStackId, topStack);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mSourceRecord != <span class="hljs-keyword">null</span>) &#123;        result = setTaskFromSourceRecord();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mInTask != <span class="hljs-keyword">null</span>) &#123;        result = setTaskFromInTask();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// This not being started from an existing activity, and not part of a new task...</span>        <span class="hljs-comment">// just put it in the top task, though these days this case should never happen.</span>        setTaskToCurrentTopOrCreateNewTask();    &#125;    <span class="hljs-keyword">if</span> (result != START_SUCCESS) &#123;        <span class="hljs-keyword">return</span> result;    &#125;      ...     <span class="hljs-keyword">if</span> (mDoResume) &#123;        <span class="hljs-keyword">final</span> ActivityRecord topTaskActivity =                mStartActivity.getTask().topRunningActivityLocked();        <span class="hljs-keyword">if</span> (!mTargetStack.isFocusable()                || (topTaskActivity != <span class="hljs-keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay                &amp;&amp; mStartActivity != topTaskActivity)) &#123;            mTargetStack.ensureActivitiesVisibleLocked(<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, !PRESERVE_WINDOWS);            mWindowManager.executeAppTransition();        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;                mTargetStack.moveToFront(<span class="hljs-string">"startActivityUnchecked"</span>);            &#125;            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,                    mOptions);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        mTargetStack.addRecentActivityLocked(mStartActivity);    &#125;  ...&#125;</code></pre><p>第30行代码 由于我们从Launcher启动根Activity时，设置启动标志为<code>FLAG_ACTIVITY_NEW_TASK</code>，所以就会走到<code>setTaskFromReuseOrCreateNewTask()</code>，这个方法主要是<em>管理任务栈，如果没有就会创建一个新的任务栈。</em></p><p>第62代码 最终调用<code>ActivityStackSupervisor.resumeDocusedStackTopActivityLocked()</code>继续启动Activity的流程。</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityStackSupervisor.java</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeFocusedStackTopActivityLocked</span><span class="hljs-params">(            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;        <span class="hljs-comment">//判断当前的任务栈是否相同</span>        <span class="hljs-keyword">if</span> (targetStack != <span class="hljs-keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;            <span class="hljs-keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);        &#125;        <span class="hljs-comment">//获取要启动Activity的所在栈的栈顶Activity且不处于停止状态</span>        <span class="hljs-keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();        <span class="hljs-comment">//由于Activity尚未启动 满足要求</span>        <span class="hljs-keyword">if</span> (r == <span class="hljs-keyword">null</span> || r.state != RESUMED) &#123;            mFocusedStack.resumeTopActivityUncheckedLocked(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.state == RESUMED) &#123;            <span class="hljs-comment">// Kick off any lingering app transitions form the MoveTaskToFront operation.</span>            mFocusedStack.executeAppTransition(targetOptions);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre><p>由于要启动的Activity尚未启动，所以会继续调用<code>ActivityStack.resumeTopActivityUncheckedLocked()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityStack.java</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityUncheckedLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;            <span class="hljs-comment">// Don't even start recursing.</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// Protect against recursion.</span>            mStackSupervisor.inResumeTopActivity = <span class="hljs-keyword">true</span>;            result = resumeTopActivityInnerLocked(prev, options);        &#125; <span class="hljs-keyword">finally</span> &#123;            mStackSupervisor.inResumeTopActivity = <span class="hljs-keyword">false</span>;        &#125;        mStackSupervisor.checkReadyForSleepLocked();        <span class="hljs-keyword">return</span> result;    &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityInnerLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;     ...       <span class="hljs-comment">//需要启动Activity</span>       mStackSupervisor.startSpecificActivityLocked(next, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);     ...     <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityStackSupervisor.java</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startSpecificActivityLocked</span><span class="hljs-params">(ActivityRecord r,            <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> </span>&#123;        <span class="hljs-comment">// 获取即将启动Activity所在的应用程序进程</span>        ProcessRecord app = mService.getProcessRecordLocked(r.processName,                r.info.applicationInfo.uid, <span class="hljs-keyword">true</span>);        r.getStack().setLaunchTime(r);        <span class="hljs-keyword">if</span> (app != <span class="hljs-keyword">null</span> &amp;&amp; app.thread != <span class="hljs-keyword">null</span>) &#123;           <span class="hljs-comment">//进程已经启动</span>            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="hljs-number">0</span>                        || !<span class="hljs-string">"android"</span>.equals(r.info.packageName)) &#123;                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,                            mService.mProcessStats);                &#125;                realStartActivityLocked(r, app, andResume, checkConfig);                <span class="hljs-keyword">return</span>;            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                Slog.w(TAG, <span class="hljs-string">"Exception when starting activity "</span>                        + r.intent.getComponent().flattenToShortString(), e);            &#125;        &#125;        <span class="hljs-comment">//启动应用进程</span>        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>,                <span class="hljs-string">"activity"</span>, r.intent.getComponent(), <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);    &#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/AMS-应用程序进程通信.png" srcset="/img/loading.gif" class="full-image" alt="AMS-应用程序进程通信" title="AMS-应用程序进程通信"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>这一节主要是从<code>ActivityManagerService</code>经过层层调用到达<code>ApplicationThread</code>的Activity启动方法。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/AMS-ApplicationThread调用过程.png" srcset="/img/loading.gif" class="full-image" alt="AMS-ApplicationThread调用过程" title="AMS-ApplicationThread调用过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>ActivityStack</code>:Activity的任务栈，从中获取需要进行操作的<code>ActivityRecord</code>进行操作。<em>在启动过程中，它的作用是检测当前栈顶Activity是否为要启动的Activity,不是就启动新Activity，是的话就重启，在这之前需要标记一下前Activity处于Pause状态。</em></p><p><code>ActivityStackSupervisor</code>:管理整个手机任务栈，管理着所有的<code>ActivityStack</code>。<em>在启动过程，它负责检查是否已有对应的应用进程在运行，如果有就直接启动Actiivty，没有的话则需新建一个应用进程。</em></p><p>总结：</p><ul><li>调用<code>AMS.startActivity()</code>实质调用其内部的<code>startActivityAsUser()</code>并在方法内部进行验证，判定<em>调用者进程是否隔离以及调用者权限是否正确</em></li><li>通过验证后，就到了<code>ActivityStarter.startActivityMayWait()</code>,并设置启动理由为<code>startActivityAsUser</code></li><li>向下调用到了<code>startActivityLocked()</code>，方法内部会去判定<code>reason</code>是否为空</li><li>不为空则走到<code>startActivity()</code>，该方法中主要<em>caller(<code>指向Launcher组件所运行的进程的ApplicationThread对象</code>)</em>，<em>callerApp(<code>指向Launcher组件所允许的应用程序进程</code>)</em>，基于<code>callerApp</code>生成对应的<code>ActivityRecord(记录即将要启动的Activity)</code>并存入<code>Activityrecord[]</code>中备用。</li><li>对应参数传入<code>startActivity()</code>的重载函数中，向下继续调用<code>startActivityUnchecked()</code></li><li><code>startActivityUnchecked()</code>主要是 创建新的<code>TaskRecord(记录任务栈信息)</code></li><li>向下切换到<code>ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()</code>，这个方法主要实现的是<code>寻找需要回复的栈顶Activity</code></li><li>内部实现由<code>ActivityStack.resumeTopActivityUncheckedLocked()</code>实现，这里又继续调用到<code>resumeTopActivityInnerLocked()</code></li><li>后续又切换回到<code>ActivityStackSupervisor.startSpecificActivityLocked()</code>，在该方法中<code>获取即将启动的Activity所在应用程序进程</code>，已启动的话调用<code>realStartActivityLocked()</code>，未启动的话就调用<code>startProcessLocked()</code>去启动进程</li></ul><h3 id="AMS启动应用进程"><a href="#AMS启动应用进程" class="headerlink" title="AMS启动应用进程"></a>AMS启动应用进程</h3><p>由于启动是根Activity，这时应用进程尚未启动，需要通过<code>AMS.startProcessLocked()</code>创建一个应用程序进程</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityManagerService.java</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(String processName,            ApplicationInfo info, <span class="hljs-keyword">boolean</span> knownToBeDead, <span class="hljs-keyword">int</span> intentFlags,            String hostingType, ComponentName hostingName, <span class="hljs-keyword">boolean</span> allowWhileBooting,            <span class="hljs-keyword">boolean</span> isolated, <span class="hljs-keyword">boolean</span> keepIfLarge)</span> </span>&#123;        <span class="hljs-keyword">return</span> startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,                hostingName, allowWhileBooting, isolated, <span class="hljs-number">0</span> <span class="hljs-comment">/* isolatedUid */</span>, keepIfLarge,                <span class="hljs-keyword">null</span> <span class="hljs-comment">/* ABI override */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* entryPoint */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* entryPointArgs */</span>,                <span class="hljs-keyword">null</span> <span class="hljs-comment">/* crashHandler */</span>);    &#125;      <span class="hljs-function"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(String processName, ApplicationInfo info,            <span class="hljs-keyword">boolean</span> knownToBeDead, <span class="hljs-keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,            <span class="hljs-keyword">boolean</span> allowWhileBooting, <span class="hljs-keyword">boolean</span> isolated, <span class="hljs-keyword">int</span> isolatedUid, <span class="hljs-keyword">boolean</span> keepIfLarge,            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;        <span class="hljs-keyword">long</span> startTime = SystemClock.elapsedRealtime();        ProcessRecord app;        ...        startProcessLocked(             app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(ProcessRecord app, String hostingType,            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;      ...        <span class="hljs-comment">//</span>        <span class="hljs-keyword">boolean</span> isActivityProcess = (entryPoint == <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">if</span> (entryPoint == <span class="hljs-keyword">null</span>) entryPoint = <span class="hljs-string">"android.app.ActivityThread"</span>;                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"Start proc: "</span> +                    app.processName);            checkTime(startTime, <span class="hljs-string">"startProcess: asking zygote to start proc"</span>);            ProcessStartResult startResult;            <span class="hljs-keyword">if</span> (hostingType.equals(<span class="hljs-string">"webview_service"</span>)) &#123;                startResult = startWebView(entryPoint,                        app.processName, uid, uid, gids, debugFlags, mountExternal,                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,                        app.info.dataDir, <span class="hljs-keyword">null</span>, entryPointArgs);            &#125; <span class="hljs-keyword">else</span> &#123;                startResult = Process.start(entryPoint,                        app.processName, uid, uid, gids, debugFlags, mountExternal,                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,                        app.info.dataDir, invokeWith, entryPointArgs);            &#125;      ...    &#125;</code></pre><p>调用到<code>Process</code>的静态成员函数<code>start()</code>启动一个新的应用进程，指定了该进程的入口函数为<code>ActivityThread.main()</code>；因此创建应用进程结束时，逻辑就转移到了<code>ActivityThread.main()</code>上。</p><pre><code class="hljs java">Process.start() =&gt; ZygoteProcess.start() == LocalSocket连接 =&gt; ZygoteServer.runSelectLoop() =&gt; ZygoteConnection.processOneCommand() =&gt; <span class="hljs-comment">// 源码路径：java/com/android/internal/os/ZygoteConnection.java</span><span class="hljs-function">Runnable <span class="hljs-title">processOneCommand</span><span class="hljs-params">(ZygoteServer zygoteServer)</span> </span>&#123;...  <span class="hljs-comment">//从Zygote孵化一个新进程并赋予 pid</span>          pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,                parsedArgs.instructionSet, parsedArgs.appDataDir);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// in child</span>                zygoteServer.setForkChild();                zygoteServer.closeServerSocket();                IoUtils.closeQuietly(serverPipeFd);                serverPipeFd = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,                        parsedArgs.startChildZygote);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// In the parent. A pid &lt; 0 indicates a failure and will be handled in</span>                <span class="hljs-comment">// handleParentProc.</span>                IoUtils.closeQuietly(childPipeFd);                childPipeFd = <span class="hljs-keyword">null</span>;                handleParentProc(pid, descriptors, serverPipeFd);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            IoUtils.closeQuietly(childPipeFd);            IoUtils.closeQuietly(serverPipeFd);        &#125;&#125;  =&gt; ZygoteConnection.handleChildProc()  <span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">handleChildProc</span><span class="hljs-params">(Arguments parsedArgs, FileDescriptor[] descriptors,            FileDescriptor pipeFd, <span class="hljs-keyword">boolean</span> isZygote)</span> </span>&#123;  ...             <span class="hljs-keyword">if</span> (!isZygote) &#123;                <span class="hljs-keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,                        <span class="hljs-keyword">null</span> <span class="hljs-comment">/* classLoader */</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,                        parsedArgs.remainingArgs, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* classLoader */</span>);            &#125;&#125;=&gt; ZygoteInit.zygoteInit()      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Runnable <span class="hljs-title">zygoteInit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;        <span class="hljs-keyword">if</span> (RuntimeInit.DEBUG) &#123;            Slog.d(RuntimeInit.TAG, <span class="hljs-string">"RuntimeInit: Starting application from zygote"</span>);        &#125;        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"ZygoteInit"</span>);        RuntimeInit.redirectLogStreams();        RuntimeInit.commonInit();        ZygoteInit.nativeZygoteInit();                <span class="hljs-keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);    &#125;=&gt; RuntimeInit.applicationInit()   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">applicationInit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetSdkVersion, String[] argv,            ClassLoader classLoader)</span> </span>&#123; ...           <span class="hljs-comment">// Remaining arguments are passed to the start class's static main</span>        <span class="hljs-keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);&#125;=&gt; RuntimeInit.findStaticMain()<span class="hljs-comment">//此时完成了对   android.app.ActivityThread.main()的反射调用</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">findStaticMain</span><span class="hljs-params">(String className, String[] argv,            ClassLoader classLoader)</span> </span>&#123;        Class&lt;?&gt; cl;        <span class="hljs-keyword">try</span> &#123;            cl = Class.forName(className, <span class="hljs-keyword">true</span>, classLoader);        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                    <span class="hljs-string">"Missing class when invoking static main "</span> + className,                    ex);        &#125;        Method m;        <span class="hljs-keyword">try</span> &#123;            m = cl.getMethod(<span class="hljs-string">"main"</span>, <span class="hljs-keyword">new</span> Class[] &#123; String[]<span class="hljs-class">.<span class="hljs-keyword">class</span> &#125;)</span>;        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                    <span class="hljs-string">"Missing static main on "</span> + className, ex);        &#125; <span class="hljs-keyword">catch</span> (SecurityException ex) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                    <span class="hljs-string">"Problem getting static main on "</span> + className, ex);        &#125;  ...&#125;</code></pre><p>拓展：为什么不用Binder而是采用Socket进行 ZygoteProcess与AMS间的通信。</p><ol><li><code>Socket</code>的调用是root,group是system，相对是安全的</li><li><code>fork()</code>不支持多线程，可能导致binder调用的时候，多个service发起fork请求，导致部分service创建失败</li></ol><blockquote><p>Zygote进程孵化出新的应用进程后，通过反射执行<code>ActivityThread.main()</code>，在该方法中会事先准备好<code>Looper以及MessageQueue</code>，继续调用<code>attach()</code>用进程绑定到<code>AMS</code>，然后开始消息循环，不断读取队列消息，并分发消息。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//准备主线程Looper 以便Handler调用</span>        Looper.prepareMainLooper();        <span class="hljs-comment">//创建主进程的 ActivityThread</span>        ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();        <span class="hljs-comment">//将该进程进行绑定</span>        thread.attach(<span class="hljs-keyword">false</span>);        <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//保存进程对应的主线程Handler</span>            sMainThreadHandler = thread.getHandler();        &#125;        <span class="hljs-comment">// End of event ActivityThreadMain.</span>        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        <span class="hljs-comment">//主线程开始消息循环</span>        Looper.loop();      &#125;  <span class="hljs-keyword">final</span> ApplicationThread mAppThread = <span class="hljs-keyword">new</span> ApplicationThread();  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> system)</span> </span>&#123;      ...        <span class="hljs-keyword">if</span> (!system) &#123;          ...            <span class="hljs-keyword">final</span> IActivityManager mgr = ActivityManager.getService();            <span class="hljs-keyword">try</span> &#123;                mgr.attachApplication(mAppThread);            &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;                <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;          ...        &#125;      ...  &#125;</code></pre><p><code>AMS</code>attach的是<code>ActivityThread</code>的代理对象<code>ApplicationThread</code>，然后<code>AMS</code>就可以通过代理对象对主线程进行操作。</p><p><strong>至此，应用进程创建完毕，并且已建立主线程完毕并开启了消息循环。</strong></p><h3 id="创建并绑定Application"><a href="#创建并绑定Application" class="headerlink" title="创建并绑定Application"></a>创建并绑定Application</h3><p>这时应用进程以及主线程已经创造完毕，接下来就是要创建<code>Application</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityManagerService.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attachApplication</span><span class="hljs-params">(IApplicationThread thread)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">//获取当前进程的id</span>            <span class="hljs-keyword">int</span> callingPid = Binder.getCallingPid();            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> origId = Binder.clearCallingIdentity();            attachApplicationLocked(thread, callingPid);            Binder.restoreCallingIdentity(origId);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">attachApplicationLocked</span><span class="hljs-params">(IApplicationThread thread,            <span class="hljs-keyword">int</span> pid)</span> </span>&#123;                ProcessRecord app;        <span class="hljs-keyword">long</span> startTime = SystemClock.uptimeMillis();        <span class="hljs-keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">synchronized</span> (mPidsSelfLocked) &#123;                app = mPidsSelfLocked.get(pid);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            app = <span class="hljs-keyword">null</span>;        &#125;       <span class="hljs-comment">// 如果获取进程信息为空 直接杀死进程并退出</span>       <span class="hljs-keyword">if</span> (app == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span> &amp;&amp; pid != MY_PID) &#123;                killProcessQuiet(pid);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">try</span> &#123;                    thread.scheduleExit();                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    <span class="hljs-comment">// Ignore exceptions.</span>                &#125;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">//创建死亡代理，被kill后可以通知AMS</span>        <span class="hljs-keyword">try</span> &#123;            AppDeathRecipient adr = <span class="hljs-keyword">new</span> AppDeathRecipient(                    app, pid, thread);            thread.asBinder().linkToDeath(adr, <span class="hljs-number">0</span>);            app.deathRecipient = adr;        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;            app.resetPackageList(mProcessStats);            startProcessLocked(app, <span class="hljs-string">"link fail"</span>, processName);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;              <span class="hljs-keyword">try</span> &#123;         ...           <span class="hljs-keyword">if</span> (app.instr != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//绑定Application</span>                thread.bindApplication(processName, appInfo, providers,                        app.instr.mClass,                        profilerInfo, app.instr.mArguments,                        app.instr.mWatcher,                        app.instr.mUiAutomationConnection, testMode,                        mBinderTransactionTrackingEnabled, enableTrackAllocation,                        isRestrictedBackupMode || !normalMode, app.persistent,                        <span class="hljs-keyword">new</span> Configuration(getGlobalConfiguration()), app.compat,                        getCommonServicesLocked(app.isolated),                        mCoreSettingsObserver.getCoreSettingsLocked(),                        buildSerial);            &#125; <span class="hljs-keyword">else</span> &#123;                thread.bindApplication(processName, appInfo, providers, <span class="hljs-keyword">null</span>, profilerInfo,                        <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, testMode,                        mBinderTransactionTrackingEnabled, enableTrackAllocation,                        isRestrictedBackupMode || !normalMode, app.persistent,                        <span class="hljs-keyword">new</span> Configuration(getGlobalConfiguration()), app.compat,                        getCommonServicesLocked(app.isolated),                        mCoreSettingsObserver.getCoreSettingsLocked(),                        buildSerial);            &#125;        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;          ...          <span class="hljs-comment">//启动失败 重启当前进程</span>          startProcessLocked(app, <span class="hljs-string">"bind fail"</span>, processName);          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">//准备启动根Activity</span>         <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;                    didSomething = <span class="hljs-keyword">true</span>;                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                Slog.wtf(TAG, <span class="hljs-string">"Exception thrown launching activities in "</span> + app, e);                badApp = <span class="hljs-keyword">true</span>;         &#125;             <span class="hljs-comment">//绑定Service以及BroadCast的Application</span>       ...       <span class="hljs-keyword">if</span> (badApp) &#123;            <span class="hljs-comment">//如果以上组件启动出错，则需要杀死进程并移除记录</span>            app.kill(<span class="hljs-string">"error during init"</span>, <span class="hljs-keyword">true</span>);            handleAppDiedLocked(app, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">//如果以上没有启动任何组件，那么didSomething为false</span>        <span class="hljs-keyword">if</span> (!didSomething) &#123;            <span class="hljs-comment">//调整进程的oom_adj值， oom_adj相当于一种优先级</span>            <span class="hljs-comment">//如果应用进程没有运行任何组件，那么当内存出现不足时，该进程是最先被系统“杀死”</span>            updateOomAdjLocked();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><p>在<code>AMS.attachApplicationLocked()</code>主要做了两步：</p><ul><li><p><code>thread.bindApplication()</code>：绑定Application到ActivityThread上</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindApplication</span><span class="hljs-params">(String processName, ApplicationInfo appInfo,                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,                ProfilerInfo profilerInfo, Bundle instrumentationArgs,                IInstrumentationWatcher instrumentationWatcher,                IUiAutomationConnection instrumentationUiConnection, <span class="hljs-keyword">int</span> debugMode,                <span class="hljs-keyword">boolean</span> enableBinderTracking, <span class="hljs-keyword">boolean</span> trackAllocation,                <span class="hljs-keyword">boolean</span> isRestrictedBackupMode, <span class="hljs-keyword">boolean</span> persistent, Configuration config,                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,                String buildSerial)</span> </span>&#123;            <span class="hljs-keyword">if</span> (services != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// Setup the service cache in the ServiceManager</span>                ServiceManager.initServiceCache(services);            &#125;            setCoreSettings(coreSettings);            AppBindData data = <span class="hljs-keyword">new</span> AppBindData();            <span class="hljs-comment">//设置Data参数</span>            ...            sendMessage(H.BIND_APPLICATION, data);        &#125;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BIND_APPLICATION         = <span class="hljs-number">110</span>;  ...    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;            <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));            <span class="hljs-keyword">switch</span> (msg.what) &#123;                 <span class="hljs-keyword">case</span> BIND_APPLICATION:                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"bindApplication"</span>);                    AppBindData data = (AppBindData)msg.obj;                    handleBindApplication(data);                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);                    <span class="hljs-keyword">break</span>;                ...            &#125;    ...&#125;</code></pre><blockquote><p><code>H</code>相当于<code>ApplcationThread</code>与<code>ActivityThread</code>的中间人，其中<code>AMS与ActivityThread通信靠 ApplicationThread，ActivityThread与ApplicationThread通信靠Handler</code>。</p><p>这里涉及的就是<strong><code>Android的主线程消息循环模型</code></strong>。</p></blockquote><p>在<code>ApplicationThread</code>发送<code>BIND_APPLICATION</code>标识的消息时，<code>H</code>接收到消息，调用<code>handleBindApplication()</code></p><pre><code class="hljs java">Instrumentation mInstrumentation;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleBindApplication</span><span class="hljs-params">(AppBindData data)</span> </span>&#123;  ...  <span class="hljs-comment">//获取LoaderApk对象</span>  data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);  <span class="hljs-comment">//创建进程对应的Android运行环境ContextImpl</span>  <span class="hljs-keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="hljs-keyword">this</span>, data.info);    <span class="hljs-keyword">final</span> InstrumentationInfo ii;   <span class="hljs-keyword">if</span> (ii != <span class="hljs-keyword">null</span>) &#123;     ...   &#125;<span class="hljs-keyword">else</span>&#123;     <span class="hljs-comment">//Activity中所有的生命周期方法都会被Instrumentation监控</span>     <span class="hljs-comment">//只要是执行Activity生命周期的相关方法前后一定会调用Instrumentation相关方法</span>     mInstrumentation = <span class="hljs-keyword">new</span> Instrumentation();   &#125;    <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//准备创建Application对象</span>            Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);            mInitialApplication = app;            ...             <span class="hljs-comment">//加载对应进程中的ContentProvider</span>            installContentProviders(app, data.providers);            <span class="hljs-keyword">try</span> &#123;                mInstrumentation.onCreate(data.instrumentationArgs);            &#125;            <span class="hljs-keyword">catch</span> (Exception e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                    <span class="hljs-string">"Exception thrown in onCreate() of "</span>                    + data.instrumentationName + <span class="hljs-string">": "</span> + e.toString(), e);            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//调用Application的onCreate方法</span>                mInstrumentation.callApplicationOnCreate(app);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                        <span class="hljs-string">"Unable to create application "</span> + app.getClass().getName()                        + <span class="hljs-string">": "</span> + e.toString(), e);                &#125;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            StrictMode.setThreadPolicy(savedPolicy);        &#125;&#125;</code></pre><p><code>handleBindApplicaiton()</code>主要是<strong>为了让一个Java的进程可以加入到Android中</strong>。</p><p>主要执行步骤有以下几步：</p><ol><li>设置进程的基本参数，例如进程名，时区等，配置资源以及兼容性设计。</li><li>创建进程对应的<code>ContextImpl、LoaderApk以及Application</code>对象，并初始化<code>ContentProvide以及Application</code>。</li><li>创建<code>Instrumentation</code>监听Activity的生命周期。(<strong>一个进程对应一个Instrumentation实例</strong>)</li></ol></li><li><p><code>mStackSuperVisor.attachApplicationLocked()</code>：启动根Activity</p><p>在该方法中<code>Application</code>已经绑定到进程上，接下来就是启动根Activity</p><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityStackSupervisor.java</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">attachApplicationLocked</span><span class="hljs-params">(ProcessRecord app)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;        <span class="hljs-keyword">final</span> String processName = app.processName;        <span class="hljs-keyword">boolean</span> didSomething = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//ActivityStackSupervisor里面 维护者所有ActiivtyStack</span>        <span class="hljs-comment">//通过循环 找到前台任务栈顶端的Activity</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> displayNdx = mActivityDisplays.size() - <span class="hljs-number">1</span>; displayNdx &gt;= <span class="hljs-number">0</span>; --displayNdx) &#123;            ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> stackNdx = stacks.size() - <span class="hljs-number">1</span>; stackNdx &gt;= <span class="hljs-number">0</span>; --stackNdx) &#123;                <span class="hljs-keyword">final</span> ActivityStack stack = stacks.get(stackNdx);                <span class="hljs-keyword">if</span> (!isFocusedStack(stack)) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                ActivityRecord hr = stack.topRunningActivityLocked();                <span class="hljs-keyword">if</span> (hr != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">//前台待启动的Activity与当前新建的进程一致时，启动这个Actiivty</span>                    <span class="hljs-keyword">if</span> (hr.app == <span class="hljs-keyword">null</span> &amp;&amp; app.uid == hr.info.applicationInfo.uid                            &amp;&amp; processName.equals(hr.processName)) &#123;                        <span class="hljs-keyword">try</span> &#123;                            <span class="hljs-keyword">if</span> (realStartActivityLocked(hr, app, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>)) &#123;                                didSomething = <span class="hljs-keyword">true</span>;                            &#125;                        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                            <span class="hljs-keyword">throw</span> e;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (!didSomething) &#123;            ensureActivitiesVisibleLocked(<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, !PRESERVE_WINDOWS);        &#125;        <span class="hljs-keyword">return</span> didSomething;    &#125;</code></pre><p>需要启动的Activity所在进程已经启动时，开始准备启动根Activity <code>realStartActivityLocked()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">realStartActivityLocked</span><span class="hljs-params">(ActivityRecord r, ProcessRecord app,            <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;      ...app.thread.scheduleLaunchActivity(<span class="hljs-keyword">new</span> Intent(r.intent), r.appToken,                    System.identityHashCode(r), r.info,                    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Have this take the merged configuration instead of separate global and</span>                    <span class="hljs-comment">// override configs.</span>                    mergedConfiguration.getGlobalConfiguration(),                    mergedConfiguration.getOverrideConfiguration(), r.compat,                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,                    r.persistentState, results, newIntents, !andResume,                    mService.isNextTransitionForward(), profilerInfo);  ...&#125;</code></pre><p>这里的<code>app.thread</code>的类型为<code>IApplicationThread</code>，它的实现是<code>ActivityThread</code>的内部类<code>ApplicationThread</code>。<code>app</code>指代的是要启动的Acttvity所在的应用进程。因此这段代码指的就是要在目标应用程序进程中启动Activity。</p></li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/AMS启动进程并绑定Application.png" srcset="/img/loading.gif" class="full-image" alt="AMS启动进程并绑定Application" title="AMS启动进程并绑定Application"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="ActivityThread启动Activity过程"><a href="#ActivityThread启动Activity过程" class="headerlink" title="ActivityThread启动Activity过程"></a>ActivityThread启动Activity过程</h3><p>这时Activity的启动过程从<code>AMS</code>切换到了<code>ApplicationThread</code>中，最后是调用到了<code>ApplicationThread.scheduleLaunchActivity()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java        </span><span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleLaunchActivity</span><span class="hljs-params">(Intent intent, IBinder token, <span class="hljs-keyword">int</span> ident,                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,                <span class="hljs-keyword">int</span> procState, Bundle state, PersistableBundle persistentState,                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,                <span class="hljs-keyword">boolean</span> notResumed, <span class="hljs-keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;            updateProcessState(procState, <span class="hljs-keyword">false</span>);            ActivityClientRecord r = <span class="hljs-keyword">new</span> ActivityClientRecord();            r.token = token;            r.ident = ident;            r.intent = intent;            r.referrer = referrer;            r.voiceInteractor = voiceInteractor;            r.activityInfo = info;            r.compatInfo = compatInfo;            r.state = state;            r.persistentState = persistentState;            r.pendingResults = pendingResults;            r.pendingIntents = pendingNewIntents;            r.startsNotResumed = notResumed;            r.isForward = isForward;            r.profilerInfo = profilerInfo;            r.overrideConfig = overrideConfig;            updatePendingConfiguration(curConfig);            sendMessage(H.LAUNCH_ACTIVITY, r);        &#125;</code></pre><p>将需要启动Activity的参数封装成<code>ActivityClientRecord</code>，在调用<code>sendMessage()</code>设置类型为<code>LAUNCH_ACTIVITY</code>，并将<code>ActivityClientRecord</code>传递过去。</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> H mh = <span class="hljs-keyword">new</span> H();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what, Object obj, <span class="hljs-keyword">int</span> arg1, <span class="hljs-keyword">int</span> arg2, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;        <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(            TAG, <span class="hljs-string">"SCHEDULE "</span> + what + <span class="hljs-string">" "</span> + mH.codeToString(what)            + <span class="hljs-string">": "</span> + arg1 + <span class="hljs-string">" / "</span> + obj);        Message msg = Message.obtain();        msg.what = what;        msg.obj = obj;        msg.arg1 = arg1;        msg.arg2 = arg2;        <span class="hljs-keyword">if</span> (async) &#123;            msg.setAsynchronous(<span class="hljs-keyword">true</span>);        &#125;        mH.sendMessage(msg);    &#125;</code></pre><p>这里的<code>mh</code>指的就是<code>H</code>，这个<code>H</code>是<code>ActivityThread</code>的内部类并继承自<code>Handler</code>，是主线程的消息管理类。因为<code>ApplicationThread</code>是一个Binder，它的调用逻辑是在<code>Binder线程池</code>中。所以这里就要把执行逻辑切换到主线程中，就使用了<code>Handler</code>。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LAUNCH_ACTIVITY         = <span class="hljs-number">100</span>;  ...    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;            <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));            <span class="hljs-keyword">switch</span> (msg.what) &#123;                <span class="hljs-keyword">case</span> LAUNCH_ACTIVITY: &#123;                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"activityStart"</span>);                    <span class="hljs-comment">//将传递过来的msg.obj转化为ActivityClientRecord</span>                    <span class="hljs-keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;                    <span class="hljs-comment">// 获得LoaderApk类型的对象并赋值到ActivityClientRecoed中</span>                    r.packageInfo = getPackageInfoNoCheck(                            r.activityInfo.applicationInfo, r.compatInfo);                    handleLaunchActivity(r, <span class="hljs-keyword">null</span>, <span class="hljs-string">"LAUNCH_ACTIVITY"</span>);                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);                &#125; <span class="hljs-keyword">break</span>;                ...            &#125;    ...&#125;</code></pre><blockquote><p>每一个Android程序都是打包在一个Apk文件中的，一个Apk文件包含了一个Android程序中的所有资源。应用程序进程在启动一个Activity组件时，需要将它所属的Apk文件加载进来，以便访问内部资源。<code>ActivityThread</code>内部使用<code>LoaderApk</code>描述一个已加载的Apk文件。</p></blockquote><p>继续向下调用到<code>handleLauncheActivity()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;...  <span class="hljs-comment">//Window开始初始化</span>  WindowManagerGlobal.initialize();  <span class="hljs-comment">//准备启动Activity</span>  Activity a = performLaunchActivity(r, customIntent);  <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>) &#123;           r.createdConfig = <span class="hljs-keyword">new</span> Configuration(mConfiguration);           reportSizeConfigurations(r);           Bundle oldState = r.state;           <span class="hljs-comment">//将要启动的Activity状态设为 Resumed 标记待激活</span>           handleResumeActivity(r.token, <span class="hljs-keyword">false</span>, r.isForward,                   !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);           <span class="hljs-keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;               performPauseActivityIfNeeded(r, reason);               <span class="hljs-keyword">if</span> (r.isPreHoneycomb()) &#123;                   r.state = oldState;               &#125;           &#125;       &#125; <span class="hljs-keyword">else</span> &#123;           <span class="hljs-comment">// If there was an error, for any reason, tell the activity manager to stop us.</span>           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">//停止Activity启动</span>               ActivityManager.getService()                   .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="hljs-keyword">null</span>,                           Activity.DONT_FINISH_TASK_WITH_ACTIVITY);           &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;               <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();           &#125;       &#125;   &#125;</code></pre><p>首先调用<code>performLaunchActivity()</code>开始准备启动Activity，内部会调用Activity的<code>Oncreate(),onStart(),onRestoreInstaceState()</code></p><p><code>performResumeActivity()</code>对应生命周期的<code>onResume()</code>，之后开始调用View的绘制，Activity的内容开始渲染到Window上面，直到我们看见绘制结果。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;  ...&#125;</code></pre><p><code>performLaunchActivity()</code>主要完成了如下几件事：</p><ol><li><p>从<code>ActivityClientRecord</code>中获取待启动的Activity的组件信息</p><pre><code class="hljs java">ActivityInfo aInfo = r.activityInfo;       <span class="hljs-keyword">if</span> (r.packageInfo == <span class="hljs-keyword">null</span>) &#123;           <span class="hljs-comment">//获取LoadedApk对象</span>           r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,                   Context.CONTEXT_INCLUDE_CODE);       &#125;       <span class="hljs-comment">//获取组件信息</span>       ComponentName component = r.intent.getComponent();       <span class="hljs-keyword">if</span> (component == <span class="hljs-keyword">null</span>) &#123;           component = r.intent.resolveActivity(               mInitialApplication.getPackageManager());           r.intent.setComponent(component);       &#125;          <span class="hljs-keyword">if</span> (r.activityInfo.targetActivity != <span class="hljs-keyword">null</span>) &#123;           component = <span class="hljs-keyword">new</span> ComponentName(r.activityInfo.packageName,                   r.activityInfo.targetActivity);       &#125;</code></pre><p><code>ComponentName</code>包含了<code>Activity组件的包名及类名。</code></p></li><li><p>通过<code>Instrumentation.newActivity()</code>使用类加载器创建Activity对象</p><pre><code class="hljs java">Activity activity = <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span> &#123;           java.lang.ClassLoader cl = appContext.getClassLoader();           <span class="hljs-comment">//用类加载器创建该Activity的实例</span>           activity = mInstrumentation.newActivity(                   cl, component.getClassName(), r.intent);           StrictMode.incrementExpectedActivityCount(activity.getClass());           r.intent.setExtrasClassLoader(cl);           r.intent.prepareToEnterProcess();           <span class="hljs-keyword">if</span> (r.state != <span class="hljs-keyword">null</span>) &#123;               r.state.setClassLoader(cl);           &#125;       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;         ...       &#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/Instrumentation.java   </span><span class="hljs-function"><span class="hljs-keyword">public</span> Activity <span class="hljs-title">newActivity</span><span class="hljs-params">(ClassLoader cl, String className,            Intent intent)</span>            <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException,            ClassNotFoundException </span>&#123;        <span class="hljs-keyword">return</span> (Activity)cl.loadClass(className).newInstance();    &#125;</code></pre></li><li><p>通过<code>LoadedApk.makeApplication()</code>创建Application对象（<em>实际是判空</em>）</p><pre><code class="hljs java">Application app = r.packageInfo.makeApplication(<span class="hljs-keyword">false</span>, mInstrumentation);<span class="hljs-comment">// ../android/app/LoaderApk.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Application <span class="hljs-title">makeApplication</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceDefaultAppClass,            Instrumentation instrumentation)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mApplication != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> mApplication;        &#125;            <span class="hljs-comment">//新建Application</span>      <span class="hljs-keyword">try</span> &#123;            java.lang.ClassLoader cl = getClassLoader();            <span class="hljs-keyword">if</span> (!mPackageName.equals(<span class="hljs-string">"android"</span>)) &#123;                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,                        <span class="hljs-string">"initializeJavaContextClassLoader"</span>);                initializeJavaContextClassLoader();                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);            &#125;            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="hljs-keyword">this</span>);            app = mActivityThread.mInstrumentation.newApplication(                    cl, appClass, appContext);            appContext.setOuterContext(app);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">if</span> (!mActivityThread.mInstrumentation.onException(app, e)) &#123;                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                    <span class="hljs-string">"Unable to instantiate application "</span> + appClass                    + <span class="hljs-string">": "</span> + e.toString(), e);            &#125;        &#125;        mActivityThread.mAllApplications.add(app);        mApplication = app;    &#125;</code></pre><p>由于在前面<code>创建并绑定Application</code>过程中的<code>bindApplication()</code>就已经创建好了<code>Application</code>，所以这一步只是起到了预防作用，并且不会重复创建。</p></li><li><p>创建<code>ContextImpl</code>对象，并通过<code>Activity.attach()</code>完成一些重要数据的初始化</p><pre><code class="hljs java">ContextImpl appContext = createBaseContextForActivity(r);appContext.setOuterContext(activity);                activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,                        r.ident, app, r.intent, r.activityInfo, title, r.parent,                        r.embeddedID, r.lastNonConfigurationInstances, config,                        r.referrer, r.voiceInteractor, window, r.configCallback);</code></pre><blockquote><p><code>ContextImpl</code>是一个很重要的数据结构，它是<code>Context</code>的具体实现，Context中大部分逻辑都是由<code>ContextImpl</code>完成的。<code>ContextImpl</code>是通过<code>Activity.attach()</code>与Activity进行关联的。除此之外，在<code>attach()</code>中，<strong>Activity还会完成Window的创建并建立关联</strong>，这样当Window接收到外部输入事件以后就可以将事件传递给Activity。</p></blockquote></li><li><p>调用<code>Activity.oncreate()</code>加载用户界面</p><pre><code class="hljs java">mInstrumentation.callActivityOnCreate(activity, r.state);mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,                                    r.persistentState);mInstrumentation.callActivityOnPostCreate(activity, r.state,                                r.persistentState);<span class="hljs-comment">// ../android/app/Instrumentation.java  </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callActivityOnCreate</span><span class="hljs-params">(Activity activity, Bundle icicle)</span> </span>&#123;        prePerformCreate(activity);        activity.performCreate(icicle);        postPerformCreate(activity);    &#125;<span class="hljs-comment">// ../android/app/Activity.java</span><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performCreate</span><span class="hljs-params">(Bundle icicle)</span> </span>&#123;        restoreHasCurrentPermissionRequest(icicle);        onCreate(icicle);        mActivityTransitionState.readState(icicle);        performCreateCommon();    &#125;</code></pre><p>最终调用到<code>Activity.performCreate()</code>后续调用到<code>Activity.onCreate()</code>这时根Activity就启动了，完成了整个启动流程。</p></li></ol><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ActivityThread启动Activity过程.png" srcset="/img/loading.gif" class="full-image" alt="ActivityThread启动Activity过程" title="ActivityThread启动Activity过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="根Activity启动过程中涉及的进程"><a href="#根Activity启动过程中涉及的进程" class="headerlink" title="根Activity启动过程中涉及的进程"></a>根Activity启动过程中涉及的进程</h3><p>根Activity启动过程中涉及四个进程：<strong>Zygote进程、Launcher进程、AMS所在进程（System Server进程），应用程序进程。</strong></p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/根启动Activity过程中的进程切换.png" srcset="/img/loading.gif" class="full-image" alt="根启动Activity过程中的进程切换" title="根启动Activity过程中的进程切换"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>首先<code>Launcher进程</code>会向<code>AMS</code>发起<code>创建根Activity请求</code>，<code>AMS</code>会判断根Activity所需的应用程序进程是否存在并处于启动状态</p><ul><li><code>未启动</code>：请求<code>Zygote进程</code>创建应用程序进程</li><li><code>已启动</code>：<code>AMS</code>直接启动Activity</li></ul></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上述章节的描述，可以基本厘清<code>根Activity的启动过程</code></p><blockquote><p>当我们按下桌面上的应用程序快捷启动方式时，<code>Launcher</code>会调用<code>Activity.startActivity()</code>并设置启动FLAG为<code>FLAG_ACTIVITY_NEW_TASK</code>给根Activity设置任务栈，实质上是调用<code>Instrumentation.execStartActivity()</code>尝试启动Activity，这是一个跨进程的过程，利用<code>IActivityManager</code>与<code>AMS</code>进行通信。</p><p><code>AMS</code>就会记录下要启动的Activity信息，并且跨进程通知Launcher进入<code>pause</code>状态，<code>Launcher</code>进入<code>pause</code>状态后，跨进程通知<code>AMS</code>自己已被<code>pause</code>。<code>AMS</code>会回调用自身的<code>startActivty()</code>去继续启动根Activity，这一步需要校验(调用者是否有权限调用)，检验通过后，发现此时应用进程尚未启动，<code>AMS</code>就会启动新的进程，并且在新进程中创建<code>ActivityThread</code>对象并执行<code>main()</code>进程初始化。</p><p>应用进程启动完毕后，<code>AMS</code>通知主线程绑定<code>Application</code>并启动根Activity。这时<code>AMS</code>会通过<code>ApplicationThread</code>回调到我们的进程，这一步也是一个跨进程的过程，利用<code>ApplicationThread</code>这个Binder对象。由于回调逻辑是在<code>Binder线程池</code>中进行的，所以需要通过<code>Handler H</code>将其切回主线程，发出的消息是<code>LAUNCH_ACTIVITY</code>，对应调用<code>handleLaunchActivity</code>，在这个方法中完成了根Activity的创建以及启动。接着在<code>handleResumeActivity()</code>中开始Activity的内容绘制，直到绘制完成被我们看见。</p></blockquote><h2 id="普通Activity启动过程"><a href="#普通Activity启动过程" class="headerlink" title="普通Activity启动过程"></a>普通Activity启动过程</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/普通Activity启动过程.png" srcset="/img/loading.gif" class="full-image" alt="普通Activity启动过程" title="普通Activity启动过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>普通Activity启动过程相比于根Activity启动过程，只保留了两步：<code>AMS到Application的调用过程</code>,<code>ActivityThread启动Activity过程</code>。</p><p>涉及的进程也只剩：<code>AMS所在进程(System Server进程)，应用程序进程</code>。</p></blockquote><h3 id="相同进程的启动过程"><a href="#相同进程的启动过程" class="headerlink" title="相同进程的启动过程"></a>相同进程的启动过程</h3><blockquote><p>例如LoadingActivity -&gt; MainActivity</p></blockquote><ol><li>LoadingActivity组件会向<code>AMS</code>发送一个启动MainActivity的请求，其实就是内部通过<code>Instrumentation</code>尝试启动Activity(<code>execStartActivity</code>)，这是一个跨进程过程，会调用<code>AMS</code>的<code>startActivity()</code></li><li><code>AMS</code>会保存下来<code>MainActivity</code>的组件信息，然后向<code>LoadingActivity</code>发送一个进入中止状态的进程间通信请求。<em>这也就是为什么老Activity的<code>onPause()</code>会执行在新Activity的启动之前的原因。</em></li><li><code>LoadingActivity</code>进入中止状态后会通知到<code>AMS</code>继续向下执行<code>MainActivity</code>的启动，由于发现应用进程已经存在，所以<code>AMS</code>直接通过<code>ApplicationThread</code>回调到应用进程，这也是一个跨进程过程。</li><li>由于<code>ApplicationThread</code>是一个Binder对象，回调逻辑在<code>Binder线程池</code>中完成，需要通过<code>Handler H</code>切回到主线程，并发出<code>LAUNCH_ACTIVITY</code>消息，对应调用<code>handleLaunchActivity</code>。</li><li>继续向下完成<code>MainActivity</code>的创建和启动，然后在<code>handleResumeActivity()</code>中完成View的绘制，直到绘制完成展示在用户面前结束。</li></ol><h3 id="新进程的启动过程"><a href="#新进程的启动过程" class="headerlink" title="新进程的启动过程"></a>新进程的启动过程</h3><blockquote><p>例如LoadingActivity -&gt; MainActivity设置了<code>android:process=&quot;:remote&quot;</code></p><p>类似根Activity的启动过程，不过起始点是从<code>LoadingActivity</code>开始</p></blockquote><ol><li>LoadingActivity组件会向<code>AMS</code>发送一个启动MainActivity的请求，其实就是内部通过<code>Instrumentation</code>尝试启动Activity(<code>execStartActivity</code>)，这是一个跨进程过程，会调用<code>AMS</code>的<code>startActivity()</code></li><li><code>AMS</code>会保存下来<code>MainActivity</code>的组件信息，然后向<code>LoadingActivity</code>发送一个进入中止状态的进程间通信请求。<em>这也就是为什么老Activity的<code>onPause()</code>会执行在新Activity的启动之前的原因。</em></li><li><code>LoadingActivity</code>进入中止状态后会通知到<code>AMS</code>继续向下执行<code>MainActivity</code>的启动，此时发现用来运行的<code>:remote</code>进程不存在，就会调用<code>AMS</code>去启动新的应用进程，并且在新进程中创建<code>ActrivityThread(*主进程*)</code>并执行<code>main()</code>进行初始化。</li><li>应用进程启动完毕之后，向<code>AMS</code>发送一个启动完成的请求，<code>AMS</code>就会通知主线程<code>ActivityThread</code>去创建并绑定<code>Application</code>，绑定完成后，通知<code>AMS</code>绑定完成。<code>AMS</code>直接通过<code>ApplicationThread</code>回调到应用进程，这也是一个跨进程过程。</li><li>由于<code>ApplicationThread</code>是一个Binder对象，回调逻辑在<code>Binder线程池</code>中完成，需要通过<code>Handler H</code>切回到主线程，并发出<code>LAUNCH_ACTIVITY</code>消息，对应调用<code>handleLaunchActivity</code>。</li><li><!--App启动优化，如何检测启动耗时 --></li></ol><p>临时记录：</p><p>Andorid 9.0 源码添加了Sleeping状态，功能类似Stop</p><p>handleSleeping() 可能导致 onSaveInstanceState()存储异常</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java - 泛型</title>
    <link href="/2019/01/02/Java-%E6%B3%9B%E5%9E%8B/"/>
    <url>/2019/01/02/Java-%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/泛型.png" srcset="/img/loading.gif" class="full-image" alt="泛型" title="泛型"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="泛型基本概念"><a href="#泛型基本概念" class="headerlink" title="泛型基本概念"></a>泛型基本概念</h2><blockquote><p>Java泛型是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数(<code>type parameter</code>)。声明的类型参数在使用时用具体的类型来替换。</p><p><strong>本质上是编译器为了提供更好的可读性而提供的一种方式，JVM中是不存在泛型的概念的。</strong></p></blockquote><p>泛型的出现在很大程度上是为了方便集合的使用，使其能够记住元素的数据类型。泛型是对Java语言类型系统的一种拓展，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符。</p><h3 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h3><ol><li><strong>类型安全</strong>。类型错误可以在编译期直接被捕获到，而不是在运行时抛出<code>ClassCastException(类型转换错误)</code>，有助于开发者方便找到错误，提高可靠性。</li><li><strong>减少代码中的强制类型转换</strong>。增强代码可读性</li></ol><h2 id="泛型的类型通配符"><a href="#泛型的类型通配符" class="headerlink" title="泛型的类型通配符"></a>泛型的类型通配符</h2><blockquote><p>匹配任意类型的类型实参。<strong>通配符往往用于方法的形参中，不允许在定义和调用中使用。</strong></p></blockquote><h3 id="无界通配符-非限定通配符-——"><a href="#无界通配符-非限定通配符-——" class="headerlink" title="无界通配符(非限定通配符)——?"></a>无界通配符(非限定通配符)——<code>?</code></h3><p>通配任意一种类型，可以用任意类型进行替代。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        List&lt;? extends Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        test(list);    &#125;    <span class="hljs-comment">//可以传入任意类型的List</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;?&gt; list)</span></span>&#123;        <span class="hljs-keyword">for</span> (Object o : list) &#123;            System.err.println(o);        &#125;    &#125;&#125;</code></pre><h3 id="带限通配符-限定通配符"><a href="#带限通配符-限定通配符" class="headerlink" title="带限通配符(限定通配符)"></a>带限通配符(限定通配符)</h3><blockquote><p>限制泛型的类型参数的类型，使其满足条件，限制在一些类中。</p></blockquote><h4 id="上限通配符——-extends-T"><a href="#上限通配符——-extends-T" class="headerlink" title="上限通配符——? extends T"></a>上限通配符——<code>? extends T</code></h4><blockquote><p>确保泛型类型必须是T的子类来设定类型的上界。<strong>使用<code>extends</code>关键字制定这个类型必须是继承某个类或者实现某个接口，也可以是这个类或者接口本身。</strong></p><p>使用时</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        List&lt;Integer&gt; upList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        upTest(upList);    &#125;    <span class="hljs-comment">//设定集合中的所有元素必须是Number的子类，例如Integer</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upTest</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span></span>&#123;        <span class="hljs-keyword">for</span> (Number number : list) &#123;            System.err.println(number);        &#125;    &#125;&#125;</code></pre><blockquote><p>在Java中父类型可以持有子类型。如果一个父类的容器可以持有子类的容器，那么就称之为<strong>协变</strong>。</p><p>可以利用<code>上限通配符</code>实现<code>协变</code>。</p></blockquote><h4 id="下限通配符——-super-T"><a href="#下限通配符——-super-T" class="headerlink" title="下限通配符——? super T"></a>下限通配符——<code>? super T</code></h4><blockquote><p>确保泛型类型必须是T的父类来设定类型的下界。<strong>使用<code>super</code>关键字指定这个类型必须是某个类的父类或者某个接口的父接口，也可以是这个类或者接口本身。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        List&lt;Number&gt; downList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        downTest(downList);    &#125;    <span class="hljs-comment">//设定集合中的所有元素必须是Integer的父类，例如Number</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downTest</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> Integer&gt; list)</span></span>&#123;        <span class="hljs-keyword">for</span> (Object o : list) &#123;            System.err.println(o);        &#125;    &#125;&#125;</code></pre><blockquote><p>如果一个类的父类型容器可以持有该类的子类型的容器，那么称之为<strong>逆变</strong>。</p><p>可以利用<code>下限通配符</code>实现<code>逆变</code>。</p></blockquote><h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><blockquote><p><strong>Producter Extends ，Consumer Super</strong>。</p></blockquote><p><code>Producter Extends</code>：如果你只需要一个只读List，那么使用<code>? extends T</code>。</p><blockquote><p>无法确定写入类型，所以禁止写入会编译错误。只能对外提供数据。</p></blockquote><p><code>Consumer Super</code>：如果你只需要一个只写List，那么使用<code>? super T</code></p><blockquote><p>写入类型都是其父类，是可以确定的。但是无论怎样取出的值都会是<code>Object</code>型，是无意义的。</p></blockquote><p><strong>如果需要同时读取以及写入，就不能使用通配符。</strong></p><h3 id="通配符的只读性"><a href="#通配符的只读性" class="headerlink" title="通配符的只读性"></a>通配符的只读性</h3><p>通配符代表了不确定的类型，无法了解到这个容器中放的是什么类型的数据，所有只有只读性，不能往里面去添加元素。</p><h2 id="泛型的类型擦除"><a href="#泛型的类型擦除" class="headerlink" title="泛型的类型擦除"></a>泛型的类型擦除</h2><blockquote><p>泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息。成功编译过后的Class文件是不会包含任何泛型信息的，泛型信息不会进入到运行时阶段。</p><p>例如<code>List&lt;String&gt;</code>在运行时用<code>List</code>表示，为了确保Java 5之前的版本可以进行兼容。</p></blockquote><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">typeErasure</span><span class="hljs-params">()</span></span>&#123;        Class c1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;().getClass();        Class c2 = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;().getClass();        System.err.println(c1 == c2);    &#125;运行结果：<span class="hljs-keyword">true</span></code></pre><p>反编译即观察得到的.class</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">typeErasure</span><span class="hljs-params">()</span> </span>&#123;        Class c1 = (<span class="hljs-keyword">new</span> ArrayList()).getClass();        Class c2 = (<span class="hljs-keyword">new</span> ArrayList()).getClass();        System.err.println(c1 == c2);    &#125;都被转成为ArrayList的类型，原先的泛型都被擦除。</code></pre><h3 id="类型擦除基本过程"><a href="#类型擦除基本过程" class="headerlink" title="类型擦除基本过程"></a>类型擦除基本过程</h3><ol><li><p>找到用来替换类型参数的具体类，一般都是<code>Object</code>。如果指定类类型参数的上界话，就会采用上界。</p><pre><code class="hljs java">未设置上界：List&lt;Integer&gt;  --&gt;  List&lt;Object&gt;设置上界：List&lt;T extends Number&gt; --&gt; List&lt;Number&gt;</code></pre><blockquote><p>设置边界：重用了 <code>extends</code>关键字。可以将类型参数的范围限制到一个子集中。</p><p>设置边界时有两个注意事项：</p><ul><li>类必须写在接口之前</li><li>只能设置一个类做边界，其他只能是接口</li></ul></blockquote></li><li><p>把代码中的类型参数都替换成具体的类，同时去掉出现的类型声明，即去掉<code>&lt;&gt;</code>内容。</p><pre><code class="hljs java">List&lt;Integer&gt; --&gt; List</code></pre></li><li><p>再生成一些桥接方法。这是由于擦除了类型之后的类可能缺少某些必须方法。</p></li></ol><h3 id="类型擦除基本原理"><a href="#类型擦除基本原理" class="headerlink" title="类型擦除基本原理"></a>类型擦除基本原理</h3><p>在编译过程中，类型变量的信息是可以拿到的。所以在<code>set()</code>中编译器可以做类型检查，非法类型无法通过编译。对于<code>get()</code>，由于擦除机制，得到的大部分都为<code>Object</code>，编译器会在<code>get()</code>之后做一个类型转换，转成对应的类型。</p><h3 id="类型擦除缺陷"><a href="#类型擦除缺陷" class="headerlink" title="类型擦除缺陷"></a>类型擦除缺陷</h3><h4 id="无法创建泛型数组"><a href="#无法创建泛型数组" class="headerlink" title="无法创建泛型数组"></a>无法创建泛型数组</h4><blockquote><p>Array无法提供编译期的类型安全保障，由于运行期就把泛型擦除了，编译器无法判断类型。</p></blockquote><p>一般是无法创建的，推荐使用<code>ArrayList</code>来实现数组。如果硬要创建，就需要用到反射去实现。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericArrayWithType</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    T[] array;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenericArrayWithType</span><span class="hljs-params">(Class&lt;T&gt; type, <span class="hljs-keyword">int</span> size)</span> </span>&#123;        <span class="hljs-comment">//使用反射中的Array类型 newInstance创建实例对象</span>        array = (T[]) Array.newInstance(type, size);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, T item)</span> </span>&#123;        array[index] = item;    &#125;&#125;GenericArrayWithType&lt;Integer&gt; genericArrayWithType = <span class="hljs-keyword">new</span> GenericArrayWithType&lt;&gt;(Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>, 10)</span>;genericArrayWithType.put(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);</code></pre><h4 id="泛型不能显式地运用在运行时类型的操作当中，例如instanceOf、new"><a href="#泛型不能显式地运用在运行时类型的操作当中，例如instanceOf、new" class="headerlink" title="泛型不能显式地运用在运行时类型的操作当中，例如instanceOf、new"></a>泛型不能显式地运用在运行时类型的操作当中，例如<code>instanceOf、new</code></h4><blockquote><p>由于系统中并不会真正生成泛型类，而且在运行时，所有参数的类型信息都已经被擦除。</p></blockquote><p>可以使用显式工厂模式，避免上述问题。</p><h4 id="泛型的类型参数不能用在catch中"><a href="#泛型的类型参数不能用在catch中" class="headerlink" title="泛型的类型参数不能用在catch中"></a>泛型的类型参数不能用在<code>catch</code>中</h4><blockquote><p>异常处理是由JVM在运行时刻进行的。由于类型擦除，JVM无法区分异常类型。对于JVM来说他们是没有区别的，也就无法正常执行对应的<code>catch</code>语句。</p></blockquote><h2 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h2><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><blockquote><p>基本格式 ： </p><p><strong>访问修饰符 class 类名&lt;限定类型变量名&gt;</strong></p><p>例如 ： <code>public class Box&lt;T&gt;</code></p></blockquote><p>首先定义一个简单的Box类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span></span>&#123;  <span class="hljs-keyword">private</span> String object;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(String object)</span></span>&#123;<span class="hljs-keyword">this</span>.object = object;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> object;&#125;&#125;</code></pre><p>这时的Box类内部只能接收<code>String</code>型参数，如果需要其他类型就需要重写另外一个，这时就可以用泛型类解决这个问题。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;  <span class="hljs-keyword">private</span> T t;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T t)</span></span>&#123;<span class="hljs-keyword">this</span>.t=t;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> t;&#125;&#125;</code></pre><p>这时的Box类便可以支持其他类型参数，可以把<code>T</code>折换成任意类型</p><pre><code class="hljs java">Box&lt;Integer&gt; integerBox = <span class="hljs-keyword">new</span> Box&lt;Integer&gt;();Box&lt;String&gt; stringBox = <span class="hljs-keyword">new</span> Box&lt;String&gt;();</code></pre><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><blockquote><p>基本格式 ： </p><p><strong>访问修饰符 interface 接口名&lt;限定类型变量名&gt;</strong></p><p>例如 ： <code>public interface Box&lt;T&gt;</code></p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;    <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><blockquote><p>基本格式 ： </p><p><strong>访问修饰符 &lt;T,S&gt; 返回值类型 方法名 (形参列表)</strong></p><p>例如 ： <code>public &lt;T&gt; void showBox(T t)</code></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(T t)</span> </span>&#123;    System.err.println(t);&#125;<span class="hljs-comment">//支持返回泛型类型</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">show</span><span class="hljs-params">(T t)</span> </span>&#123;    System.err.println(t);  <span class="hljs-keyword">return</span> t;&#125;</code></pre><p>泛型方法中定义的形参只能在该方法中使用，但是接口、类中定义的形参可以在这个接口、类中使用。</p><h4 id="泛型构造器"><a href="#泛型构造器" class="headerlink" title="泛型构造器"></a>泛型构造器</h4><blockquote><p>基本格式 ： </p><p><strong>访问修饰符 class 类名 {</strong></p><p>  <strong>访问修饰符 <t> 类名 (形参列表){}</t></strong> </p><p><strong>}</strong></p><p>例如 ： <code>public class Box{</code></p><p><code>public &lt;T&gt; Box (T t){}</code></p><p><code>}</code></p></blockquote><p>使用泛型构造器有两种方式：</p><ol><li><p>显式指定泛型参数</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> &lt;String&gt;Box(<span class="hljs-string">"a"</span>)</code></pre></li><li><p>隐式推断</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> Box(<span class="hljs-string">"a"</span>)</code></pre></li></ol><h3 id="泛型注意事项"><a href="#泛型注意事项" class="headerlink" title="泛型注意事项"></a>泛型注意事项</h3><ul><li><p><strong>任何基本类型都不能作为类型参数</strong></p></li><li><p><strong>无法进行重载</strong></p><blockquote><p>由于擦除的原因，重载方法将产生相同的类型签名。避免这种问题的方法就是换个方法名</p></blockquote></li></ul><h3 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h3><p><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener">Java泛型详解</a></p><p><a href="https://www.jianshu.com/p/4caf2567f91d" target="_blank" rel="noopener">Java泛型进阶</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义ViewGroup实践</title>
    <link href="/2019/01/02/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E5%AE%9E%E8%B7%B5/"/>
    <url>/2019/01/02/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="自定义ViewGrouop-FlowLayout"><a href="#自定义ViewGrouop-FlowLayout" class="headerlink" title="自定义ViewGrouop - FlowLayout"></a>自定义ViewGrouop - FlowLayout</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li><p>继承特定ViewGroup，例如<code>LinearLayout</code></p><blockquote><p>比较常见，效果类似于一堆View的组合。</p><p><strong>实现比较简单，无需自己处理测量与布局的过程。</strong></p></blockquote></li><li><p>继承<code>ViewGroup</code>派生特殊layout</p><blockquote><p>主要用于实现自定义的布局，按照自身需求制定不同的显示方法。</p><p><strong>实现稍微复杂，还需要对ViewGroup进行处理，主要是自身的<code>onMeasure()、onLayout()</code>以及子View的<code>measure</code>过程</strong></p></blockquote></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>注意<code>wrap_content</code>的影响</li><li>注意<code>margin、pandding</code>的实现</li></ul><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="创建ViewGroup"><a href="#创建ViewGroup" class="headerlink" title="创建ViewGroup"></a>创建ViewGroup</h3><h5 id="继承ViewGroup"><a href="#继承ViewGroup" class="headerlink" title="继承ViewGroup"></a>继承ViewGroup</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewGroup</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlowLayout</span><span class="hljs-params">(Context context)</span> </span>&#123;        <span class="hljs-keyword">this</span>(context,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlowLayout</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> </span>&#123;        <span class="hljs-keyword">super</span>(context, attrs);    &#125;&#125;</code></pre><h4 id="处理ViewGroup布局"><a href="#处理ViewGroup布局" class="headerlink" title="处理ViewGroup布局"></a>处理ViewGroup布局</h4><h5 id="测量ViewGroup大小"><a href="#测量ViewGroup大小" class="headerlink" title="测量ViewGroup大小"></a>测量ViewGroup大小</h5><p>通过<code>onMeasure()</code>进行ViewGroup的测量，其中需要先对子View进行测量，然后根据子View的结果确认最终ViewGroup的大小。</p><pre><code class="hljs java"></code></pre><h5 id="确定ViewGroup位置"><a href="#确定ViewGroup位置" class="headerlink" title="确定ViewGroup位置"></a>确定ViewGroup位置</h5>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义View实践</title>
    <link href="/2019/01/02/%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E8%B7%B5/"/>
    <url>/2019/01/02/%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<!--实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展--><blockquote><p>Android系统默认提供大量的View，但是会因为需求的改动导致原生View不能符合需求，就需要进行自定义控件去使用。</p></blockquote><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li><p>继承特定View</p><blockquote><p>拓展某种已有View的功能就可以在原有View的基础上增加新功能，而且这种实现方式就不需要自己去处理那些注意事项，例如<code>wrap_content、pandding</code>等属性。</p></blockquote></li><li><p>继承View并重写<code>onDraw()</code></p><blockquote><p>当需要实现一些不规则的效果，比如绘制一些图案，按照不同的需求需要实现更多的功能。这种实现方式就需要注意以下事项：</p><ul><li>需要自己支持<code>wrap_content、padding</code></li><li>注意<code>onDraw()</code>绘制的性能问题</li></ul></blockquote></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在实现过程中会有详细的实现介绍</p><ul><li><p>自定义View支持<code>wrap_content</code></p><blockquote><p>在自定View中使用<code>wrap_content</code>在显示结果上总是和<code>match_parent</code>效果一致，原因在于源码中对View的实现有一种默认处理。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDefaultSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> measureSpec)</span> </span>&#123;        <span class="hljs-keyword">int</span> result = size;        <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);        <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);        <span class="hljs-keyword">switch</span> (specMode) &#123;        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:            result = size;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:        <span class="hljs-comment">//这段代码中可以分析得出 一个直接继承View的自定义View 定义为wrap_content和match_parent大小都是一致的.</span>            result = specSize;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;</code></pre></li><li><p>有必要需要支持<code>padding、margin</code>属性</p><blockquote><p><code>android:padding</code>该属性控制View内部边距，<code>android:margin</code>属性控制与父布局的边距。</p><p>都需要在<code>onDraw()</code>过程中去进行特殊处理。</p></blockquote></li><li><p>尽量不要在View中使用Handler</p><blockquote><p>View内部提供了<code>post()</code>可以发送事件，完全替代Handler作用，使用还方便。</p></blockquote></li><li><p>自定义View如果有线程或动画，需要及时停止</p><blockquote><p>当View中使用了<code>线程或动画</code>时，可能因为忘记及时释放，使他们持有了View，从而导致Activity出现内存泄漏问题。</p></blockquote></li><li><p>需要注意滑动冲突</p><blockquote><p>View中使用了滑动时，需要注意滑动冲突问题。</p></blockquote><p>解决滑动冲突两种方案：<code>外部拦截法</code>、<code>内部拦截法</code>。</p></li></ul><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="创建View"><a href="#创建View" class="headerlink" title="创建View"></a>创建View</h3><h4 id="继承View"><a href="#继承View" class="headerlink" title="继承View"></a>继承View</h4><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">View</span></span>&#123;    <span class="hljs-comment">/**    * 自动调用——用于在Java代码new使用的    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span><span class="hljs-params">(Context context)</span></span>&#123;        <span class="hljs-keyword">super</span>(context);    &#125;    <span class="hljs-comment">/**    * 自动调用——用于View在xml里使用时调用的    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span><span class="hljs-params">(Context context,AttributeSet attrs<span class="hljs-comment">/*xml中传进来的属性*/</span>)</span></span>&#123;        <span class="hljs-keyword">super</span>(context,attrs);    &#125;    <span class="hljs-comment">/**    * 非自动调用——用于View设置看style属性时，大部分情况下都是调用的双参数函数    * defStyleAttr 指的时当前Application或Activity所用Theme的默认style    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span><span class="hljs-params">(Context context,AttributeSet attrs,<span class="hljs-keyword">int</span> defStyleAttr)</span></span>&#123;        <span class="hljs-keyword">super</span>(context,attrs,defStyleAttr);    &#125;    <span class="hljs-comment">/**    * 在API21 以上时添加的函数    * 非自动调用    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span><span class="hljs-params">(Context context,AttributeSet attrs,<span class="hljs-keyword">int</span> defStyleAttr,<span class="hljs-keyword">int</span> defStyleRes)</span></span>&#123;        <span class="hljs-keyword">super</span>(context,attrs,defStyleAttr,defStyleRes)    &#125;&#125;</code></pre><p>继承View之后，系统提供了4个构造函数，每个函数的参数也不尽相同。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span><span class="hljs-params">(Context context)</span></span></code></pre><p>在Activity中进行调用时<code>CustomView view= new CustomView(this)</code></p><p><br></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span><span class="hljs-params">(Context context,AttributeSet attrs<span class="hljs-comment">/*xml中传进来的属性*/</span>)</span></span></code></pre><p>在xml中调用时触发</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomView</span>    <span class="hljs-attr">android:layout_width</span>"<span class="hljs-attr">wrap_content</span>"  <span class="hljs-attr">android:layout_height</span>"<span class="hljs-attr">wrap_content</span>"/&gt;</span></code></pre><p><br></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span><span class="hljs-params">(Context context,AttributeSet attrs,<span class="hljs-keyword">int</span> defStyleAttr)</span></span></code></pre><p>这个方法需要第二个构造函数进行显式调用方可生效，传入自定义的Theme</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span><span class="hljs-params">(Context context,AttributeSet attrs<span class="hljs-comment">/*xml中传进来的属性*/</span>)</span></span>&#123;    <span class="hljs-keyword">this</span>(context,attrs,R.style.theme)&#125;</code></pre><blockquote><p>该构造函数的作用：<strong>为View的子类提供该类的基础样式</strong>。</p></blockquote><p><br></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomView</span><span class="hljs-params">(Context context,AttributeSet attrs,<span class="hljs-keyword">int</span> defStyleAttr,<span class="hljs-keyword">int</span> defStyleRes)</span></span></code></pre><h4 id="定义自定义属性"><a href="#定义自定义属性" class="headerlink" title="定义自定义属性"></a>定义自定义属性</h4><blockquote><p>自定义View中通常需要支持更多的设置，例如背景颜色，文字内容等属性，设置完毕后就可以对应的显示出来。</p></blockquote><p>通常将所需的自定义属性配置到<code>res/values/attrs.xml</code>中，等待自定义View进行引用。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CustomView"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"color_attr"</span> <span class="hljs-attr">format</span>=<span class="hljs-string">"color"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"boolean_attr"</span> <span class="hljs-attr">format</span>=<span class="hljs-string">"boolean"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"string_attr"</span> <span class="hljs-attr">format</span>=<span class="hljs-string">"string"</span>/&gt;</span>    <span class="hljs-comment">&lt;!--自定义属性支持组合使用--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"reference_attr"</span> <span class="hljs-attr">format</span>=<span class="hljs-string">"color | reference"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span></code></pre><p>主要介绍常用的几种属性：</p><table><thead><tr><th>format</th><th>作用</th><th>使用方法</th></tr></thead><tbody><tr><td>color</td><td>设置颜色值例如 <code>#ffffff</code></td><td>app:color_attr=”#ffffff”</td></tr><tr><td>boolean</td><td>布尔值</td><td>app:boolean_attr = “true”</td></tr><tr><td>string</td><td>字符串</td><td>app:string_attr=”android”</td></tr><tr><td>dimension</td><td>尺寸值</td><td>app:dimension_attr=”36dp”</td></tr><tr><td>float</td><td>浮点值</td><td>app:float_attr=”1.0”</td></tr><tr><td>integer</td><td>整型值</td><td>app:intege_attr=”100”</td></tr><tr><td>fraction</td><td>百分数</td><td>app:fraction_attr=”100%”</td></tr><tr><td>reference</td><td>获取某一资源ID</td><td>app:reference_attr=”@drawable/ic_launcher”</td></tr><tr><td>enum</td><td>枚举值</td><td>app:enum_attr=”enum_1”</td></tr></tbody></table><p>其中<code>enum</code>的实现比较特殊：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enum_attr"</span> &gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enum_1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0"</span>/&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"enum_2"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span></code></pre><p>声明自定义属性完毕后，需要在xml中进行引用</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomView</span>      <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>      <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>      <span class="hljs-attr">app:color_attr</span>=<span class="hljs-string">"#ffffff"</span>      <span class="hljs-attr">app:float_attr</span>=<span class="hljs-string">"12f"</span>      <span class="hljs-attr">app:enum_attr</span>=<span class="hljs-string">"enum_1"</span>      <span class="hljs-attr">app:integer_attr</span>=<span class="hljs-string">"10"</span>      <span class="hljs-attr">app:reference_attr</span>=<span class="hljs-string">"@color/colorAccent"</span>      <span class="hljs-attr">app:dimension_attr</span>=<span class="hljs-string">"36dp"</span>      <span class="hljs-attr">app:boolean_attr</span>=<span class="hljs-string">"true"</span>      <span class="hljs-attr">app:string_attr</span>=<span class="hljs-string">"android"</span>/&gt;</span></code></pre><h4 id="获取自定义属性"><a href="#获取自定义属性" class="headerlink" title="获取自定义属性"></a>获取自定义属性</h4><p>在xml中设置自定义属性完毕后，就需要在自定义View中去获取对应属性的值。</p><pre><code class="hljs java"><span class="hljs-comment">//加载自定义属性集合</span>TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CustomView);...  获取具体属性值<span class="hljs-comment">// 使用完毕需要进行回收</span>typedArray.recycle();</code></pre><p>根据上节中定义的自定义属性，获取方式也不尽相同。</p><table><thead><tr><th>format</th><th>如何获取</th></tr></thead><tbody><tr><td>color</td><td>typedArray.getColor(R.styleable.CustomView_color_attr, Color.RED);</td></tr><tr><td>boolean</td><td>typedArray.getBoolean(R.styleable.CustomView_boolean_attr, true);</td></tr><tr><td>string</td><td>typedArray.getString(R.styleable.CustomView_string_attr);</td></tr><tr><td>dimension</td><td>floar dimension = typedArray.getDimension(R.styleable.CustomView_dimension_attr,20);<em>完整结果</em><br>int dimension = typedArray.getDimensionPixelOffset(R.styleable.CustomView_dimension_attr,20);<em>舍弃末尾小数</em><br>int dimension = typedArray.getDimensionPixelSize(R.styleable.CustomView_dimension_attr,20);<em>四舍五入</em></td></tr><tr><td>float</td><td>typedArray.getFloat(R.styleable.CustomView_float_attr, 1f);</td></tr><tr><td>integer</td><td>typedArray.getInteger(R.styleable.CustomView_integer_attr, 1);</td></tr><tr><td>fraction</td><td>typedArray.getFraction(R.styleable.CustomView_fraction_attr,4,5,1);</td></tr><tr><td>reference</td><td>typedArray.getResourceId(R.styleable.CustomView_reference_attr, R.drawable.ic_launcher_background);</td></tr><tr><td>enum</td><td>typedArray.getInt(R.styleable.CustomView_enum_attr, 0);</td></tr></tbody></table><h4 id="添加设置属性事件"><a href="#添加设置属性事件" class="headerlink" title="添加设置属性事件"></a>添加设置属性事件</h4><p>上述自定义的属性只能在View初始化时可以获取并在xml中进行设置，如果后续想修改对应属性，就需要针对设置属性事件来进行修改和获取。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getBooleanAttr</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> boolean_attr;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBooleanAttr</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> boolean_attr)</span></span>&#123;    <span class="hljs-keyword">this</span>.boolean_attr= boolean_attr;    <span class="hljs-comment">//根据不同的需求去选择刷新界面方法。</span>    <span class="hljs-comment">//postInvalidate(); 重新进行绘制</span>    <span class="hljs-comment">//invalidate(); 重新进行绘制</span>    <span class="hljs-comment">//requestLayout() 对整个布局进行测量-布局-绘制过程</span>&#125;</code></pre><h3 id="处理View的布局"><a href="#处理View的布局" class="headerlink" title="处理View的布局"></a>处理View的布局</h3><h4 id="测量View大小"><a href="#测量View大小" class="headerlink" title="测量View大小"></a>测量View大小</h4><blockquote><p>为了让自定义View可以根据不同的情况以合适的宽高进行展示</p></blockquote><p>这里要做的就是对<code>onMeasure()</code>进行重写，View是通过该方法确定对应宽高。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;    <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);        <span class="hljs-keyword">int</span> widthMeasureSpecSize = MeasureSpec.getSize(widthMeasureSpec);      <span class="hljs-comment">//取出宽度的确切数值 后30bit</span>        <span class="hljs-keyword">int</span> widthMeasureSpecMode = MeasureSpec.getMode(widthMeasureSpec);      <span class="hljs-comment">//取出宽度的测量模式 前2bit</span>        <span class="hljs-keyword">int</span> heightMeasureSpecSize = MeasureSpec.getSize(heightMeasureSpec);    <span class="hljs-comment">//取出高度的确切数值 后30bit</span>        <span class="hljs-keyword">int</span> heightMeasureSpecMode = MeasureSpec.getMode(heightMeasureSpec);    <span class="hljs-comment">//取出高度的测量模式 前2bit</span>        <span class="hljs-keyword">if</span> (widthMeasureSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightMeasureSpecMode == MeasureSpec.AT_MOST) &#123;            setMeasuredDimension(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (widthMeasureSpecMode == MeasureSpec.AT_MOST) &#123;            setMeasuredDimension(<span class="hljs-number">400</span>, heightMeasureSpecSize);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heightMeasureSpecMode == MeasureSpec.AT_MOST) &#123;            setMeasuredDimension(widthMeasureSpecSize, <span class="hljs-number">400</span>);        &#125;&#125;</code></pre><p>代码中<code>widthMode/heightMode</code>对应的有3类，代表的是<strong>测量模式</strong></p><table><thead><tr><th>测量模式</th><th>定义</th></tr></thead><tbody><tr><td>UNSPECIFIED</td><td>当前控件没有限制，想多大就多大，一般在系统中使用的</td></tr><tr><td>EXACTLY</td><td>表示父控件指定了一个确切的大小，一般定义为<code>具体大小(20dp)</code>或<code>match_parent(父布局大小)</code></td></tr><tr><td>AT_MOST</td><td>表示没有具体的大小限制，不过指定了上限，一般为父布局大小，一般定义为<code>wrap_content</code></td></tr></tbody></table><p>代码中<code>widthSize/heightSize</code>指代的就是 <strong>父布局期望的子View大小</strong>。</p><p>代码中针对<code>AT_MOST</code>进行了特殊的处理，针对的情况就是使用了<code>wrap_content</code>，在Android源码中，系统的处理方案是<code>AT_MOST和EXACTLY</code>得到结果是一致的，而导致<code>wrap_content</code>属性失效。</p><blockquote><p>如果后续也对View的宽高进行修改，就调用<code>setMeasureDimension()</code>执行修改。</p></blockquote><h4 id="确定View大小"><a href="#确定View大小" class="headerlink" title="确定View大小"></a>确定View大小</h4><blockquote><p>View的大小不仅由自身控制，父布局也会有影响，因此获取View大小时最好通过<code>onSizeChanged()</code>获取。</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSizeChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> oldw, <span class="hljs-keyword">int</span> oldh)</span> </span>&#123;    <span class="hljs-keyword">super</span>.onSizeChanged(w, h, oldw, oldh);&#125;</code></pre><p>其中<code>w、h</code>就是最终的宽、高。</p><h3 id="绘制View"><a href="#绘制View" class="headerlink" title="绘制View"></a>绘制View</h3><blockquote><p>尺寸确定完毕后，接下来就要去绘制View所需的内容，直接把我们相要绘制的内容放在<code>canvas</code>上即可</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;    <span class="hljs-keyword">super</span>.onDraw(canvas);    <span class="hljs-comment">//这个应该放在init()时进行初始化 ，此处只为举例说明</span>    Paint paint = <span class="hljs-keyword">new</span> Paint();    paint.setColor(Color.GREEN);    <span class="hljs-comment">//开始绘制 画一个圆</span>    canvas.drawCircle(centerX, centerY, r, paint);&#125;</code></pre><p>其中涉及了两个对象：</p><ul><li><strong>Canvas</strong>：画布对象，决定了要去画什么</li><li><strong>Paint</strong>：画笔对象，决定了怎么画，比如颜色，粗细等</li></ul><p>在注意事项中，还需要注意的是<code>padding</code>属性的处理，这部分处理就在<code>onDraw()</code>中执行。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;       <span class="hljs-keyword">super</span>.onDraw(canvas);       <span class="hljs-comment">//获取xml中设置的padding属性值</span>       <span class="hljs-keyword">int</span> paddingTop = getPaddingTop();       <span class="hljs-keyword">int</span> paddingBottom = getPaddingBottom();       <span class="hljs-keyword">int</span> paddingStart = getPaddingStart();       <span class="hljs-keyword">int</span> paddingEnd = getPaddingEnd();       <span class="hljs-comment">//得到的结果就是 该View实际可用的绘制大小</span>       <span class="hljs-keyword">int</span> width = getWidth() - paddingStart - paddingEnd;       <span class="hljs-keyword">int</span> height = getHeight() - paddingTop - paddingBottom;   &#125;</code></pre><blockquote><p>在实现<code>onDraw()</code>过程中需要注意，最好不要去生成任何的局部对象，由于View的绘制过程是发生最频繁的，可能由于生成大量临时对象导致频繁GC，影响性能。</p></blockquote><h3 id="与用户进行交互"><a href="#与用户进行交互" class="headerlink" title="与用户进行交互"></a>与用户进行交互</h3><blockquote><p>如果需要额外的对用户的触摸或者滑动事件去进行支持，这时就需要去实现一些触摸方法。</p></blockquote><p>通过实现<code>onTouchEvent()</code>来实现触摸事件响应，实现<code>GestureDetector</code>相关接口去实现滑动功能。</p><p><strong>此时需要注意滑动冲突上的处理。</strong></p><h3 id="优化自定义View"><a href="#优化自定义View" class="headerlink" title="优化自定义View"></a>优化自定义View</h3><p>上述流程实现完毕后，就需要针对实现的自定义View去做一些优化处理，减少问题。</p><ol><li><p>避免不必要的代码</p></li><li><p>在<code>onDraw()</code>中不要出现创建对象的方法</p></li><li><p>尽可能减少<code>onDraw()</code>调用，提升绘制效率。</p></li><li><p>如果设置了线程或者动画需要及时清理</p><blockquote><p>不处理可能导致内存泄漏的发生</p><p>此时可以在<code>onAttachedToWindow()</code>时去进行线程或动画初始化等工作</p><p>最后在<code>onDetachedFromWindow()</code>时去清理掉他们。</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2018/12/27/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2018/12/27/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>View的事件体系</title>
    <link href="/2018/12/25/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
    <url>/2018/12/25/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<!--MeasureSpec是什么？有什么作用？，自定义View/ViewGroup需要注意什么？invalidate()和postInvalidate()的区别？,invalidate和postInvalidate的区别及使用 Requestlayout，onlayout，onDraw，DrawChild区别与联系 View刷新机制 View绘制流程 计算一个view的嵌套层级 onMeasure的具体过程，先measure子view还是自己 onDraw的具体过程，先draw子view还是自己 实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展 view的工作原理及measure、layout、draw流程。哪一个流程可以放在子线程中去执行？draw方法中需要注意的问题？Invalidate、postInvalidate、requestLayout应用场景--><p><img src="/images/View的事件体系.png" srcset="/img/loading.gif" alt="View的事件体系"></p><blockquote><p>在Android中任何一个与用户交互或者展示内容的控件都是由View拓展实现的。</p></blockquote><h2 id="View的基础知识"><a href="#View的基础知识" class="headerlink" title="View的基础知识"></a>View的基础知识</h2><p>View是Android中所有控件的基类，也包括ViewGroup。ViewGroup可以理解为View的组合，内部可以包含很多View以及ViewGroup，通过这种关系就形成了一个View树。</p><p><img src="/images/View-Tree.png" srcset="/img/loading.gif" alt="ViewTree"></p><p>上层的控件主要负责测量与绘制下层的控件，并传递交互事件。</p><h3 id="1-View的位置参数"><a href="#1-View的位置参数" class="headerlink" title="1. View的位置参数"></a>1. View的位置参数</h3><h4 id="1-Android坐标系"><a href="#1-Android坐标系" class="headerlink" title="1.Android坐标系"></a>1.Android坐标系</h4><blockquote><p>在Android中，将屏幕左上角的顶点作为坐标原点，向右为X轴增大方向，向下为Y轴增大方向</p></blockquote><p><img src="/images/Android-Position.png" srcset="/img/loading.gif" alt="ViewTree"></p><h4 id="2-View坐标系"><a href="#2-View坐标系" class="headerlink" title="2.View坐标系"></a>2.View坐标系</h4><blockquote><p>View的位置由它的四个顶点决定，分别对应View的4个属性：<code>left(左上角横坐标)、top(左上角纵坐标)、right(右下角横坐标)，bottom(右下角纵坐标)</code>。</p><p><strong>这些坐标都是相对于View的父容器决定的。</strong></p></blockquote><p><img src="/images/View-Position.png" srcset="/img/loading.gif" alt></p><pre><code class="hljs java">Left = getLeft();Right = getRight();Top = getTop();Bottom = getBottom();width = Right - Left;height = Bottom - Top;</code></pre><p>在Android3.0之后添加了几个新参数<code>x,y,translationX,translationY</code>。</p><pre><code class="hljs java"><span class="hljs-comment">//X对应左上角横坐标 translationX指代x轴偏移量</span>x = left + translationX;<span class="hljs-comment">//y对应左上角纵坐标 translationY指代y轴偏移量</span>y = top + translationY;</code></pre><p><code>left是View的初始坐标，不会改变的；x是View偏移后的坐标，偏移后就会发生变化</code></p><p>Android系统也提供了相应的方法可以直接获取对应参数。但是，不能在初始时就去获取，由于那时View还没有开始绘制，获取的都是0；</p><p>如何获取可以参考这个 <a href="/2018/03/18/Android-Study-Plan-V/" title="Android Study Plan V">Android Study Plan V</a></p><h3 id="2-View触控"><a href="#2-View触控" class="headerlink" title="2.View触控"></a>2.View触控</h3><h4 id="1-MotionEvent"><a href="#1-MotionEvent" class="headerlink" title="1.MotionEvent"></a>1.MotionEvent</h4><p><code>MotionEvent</code>：提供点击事件的事件行为以及事件发生的x,y坐标，典型事件由：</p><ul><li><strong>ACTION_DOWN</strong>：监听用户手指按下的操作，一次按下标志触摸事件的开始。</li><li><strong>ACTION_MOVE</strong>：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。</li><li><strong>ACTION_UP</strong>：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。</li><li><strong>ACTION_CANCEL</strong>：当用户保持按下操作，并把手指移动到了控件外部局域时且父View处理事件触发。</li></ul><blockquote><p>事件列：从手指接触屏幕到离开屏幕，产生的一系列事件。</p><p>任何事件列都是<strong>从ACTION_DOWN开始到ACTION_UP结束，中间会穿插着ACTION_MOVE事件</strong></p></blockquote><p><img src="/images/View-Touch-Position.png" srcset="/img/loading.gif" alt="View-Touch-Position"></p><pre><code class="hljs java">getX 以及 getY 返回当前触摸点距离View左上角的x，y坐标 -- 相对坐标getRawX 以及 getRawY 返回当前触摸点距离整个屏幕的x,y坐标 -- 绝对坐标</code></pre><h4 id="2-TouchSlop"><a href="#2-TouchSlop" class="headerlink" title="2.TouchSlop"></a>2.TouchSlop</h4><p><code>TouchSlop</code>：系统所能识别的被人误是<strong>滑动的最小距离</strong>。当手指在屏幕上滑动时，如果滑动的距离小于这个值，就不会认为在进行滑动操作。</p><p>利用<code>ViewConfiguration.get(getContext()).getScaledTouchSlop()</code>获取该常亮</p><h4 id="3-VelocityTracker"><a href="#3-VelocityTracker" class="headerlink" title="3.VelocityTracker"></a>3.VelocityTracker</h4><p><code>VelocityTracker</code>：速度追踪，用于追踪在手指滑动过程中的速度，包括水平和垂直方向的速度</p><p>样例演示:</p><pre><code class="hljs java"><span class="hljs-comment">//创建速度追踪对象</span>VelocityTracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event);<span class="hljs-comment">//计算速度</span>velocityTracker.computeCurrentVelocity(<span class="hljs-number">1000</span>);<span class="hljs-comment">//获取水平速度</span><span class="hljs-keyword">float</span> xVelocity = velocityTracker.getXVelocity();<span class="hljs-comment">//获取垂直速度</span><span class="hljs-keyword">float</span> yVelocity = velocityTracker.getYVelocity();<span class="hljs-comment">//重置并回收内存</span>velocityTracker.clear();velocityTracker.recycle();</code></pre><h4 id="4-GestureDetector"><a href="#4-GestureDetector" class="headerlink" title="4.GestureDetector"></a>4.GestureDetector</h4><p><code>GestureDetector</code>：手势检测，用于辅助检测用户的单击、滑动、长按，双击等行为。</p><p>样例演示：</p><pre><code class="hljs java">GestureDetector mGestureDetector = <span class="hljs-keyword">new</span> GestureDetector(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//实例化一个GestureDetector对象</span>mGestureDetector.setIsLongpressEnabled(<span class="hljs-keyword">false</span>);<span class="hljs-comment">// 解决长按屏幕后无法拖动的现象</span><span class="hljs-comment">//接管目标View的onTouchEvent事件</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span></span>&#123;    ...    <span class="hljs-keyword">boolean</span> consume = mGestureDetector.onTouchEvent(event);    <span class="hljs-keyword">return</span> consume&#125;</code></pre><h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><blockquote><p>Android由于手机屏幕比较小，为了呈现更多的内容就需要滑动来展示。</p></blockquote><h3 id="1-使用scrollTo-scrollBy"><a href="#1-使用scrollTo-scrollBy" class="headerlink" title="1.使用scrollTo()/scrollBy()"></a>1.使用scrollTo()/scrollBy()</h3><blockquote><p><code>scrollTo()</code>以及<code>scrollBy()</code>是由View本身提供的滑动方法。<strong>只对View的内容进行滑动，而不能使View本身滑动。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scrollTo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mScrollX != x || mScrollY != y) &#123;        <span class="hljs-keyword">int</span> oldX = mScrollX;        <span class="hljs-keyword">int</span> oldY = mScrollY;        mScrollX = x;        mScrollY = y;        invalidateParentCaches();        onScrollChanged(mScrollX, mScrollY, oldX, oldY);        <span class="hljs-keyword">if</span> (!awakenScrollBars()) &#123;            postInvalidateOnAnimation();        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scrollBy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    scrollTo(mScrollX + x, mScrollY + y);&#125;</code></pre><p><code>scrollTo(x,y)</code>表示移动到一个具体的坐标点 绝对滑动</p><p><code>scrollBy(x,y)</code>表示移动的增量为x,y，即在原有位置上移动x,y的距离 相对滑动</p><p><code>mScrollX和mScrollY分别表示View在X,Y方向的滚动距离。</code></p><p><code>mScrollX</code>：View的左边缘减去View的内容的左边缘  <strong>从右向左为正，反之为负</strong></p><p><code>mScrollY</code>：View的上边缘减去View的内容的上边缘  <strong>从下向上为正，反之为负</strong> </p><h3 id="2-使用动画"><a href="#2-使用动画" class="headerlink" title="2.使用动画"></a>2.使用动画</h3><blockquote><p>通过动画给View增加平移效果。通过改变View自身的<code>translationX</code>和<code>translationY</code>属性达到滑动效果。</p></blockquote><p>普通动画：新建<code>translate.xml</code>动画文件，定义好tranlate属性即可实现滑动动画。</p><p>普通动画并不能修改View的位置参数，只是执行了一个动画，实际位置还是初始地方。</p><p>属性动画：<code>ObjectAnimator.ofFloat(view,&quot;translationX&quot;,0,300).setDuration(1000).start();</code>即可实现动画</p><p>属性动画真正对View的位置参数进行修改，所以对应时间都是跟随的。</p><h3 id="3-改变布局参数"><a href="#3-改变布局参数" class="headerlink" title="3.改变布局参数"></a>3.改变布局参数</h3><blockquote><p>改变View的<code>LayoutParams</code>使得View重新布局。</p></blockquote><p>滑动时，可以对<code>LaqyoutParams</code>的<code>margin</code>相关参数进行加减就可以实现滑动。</p><h3 id="4-弹性滑动"><a href="#4-弹性滑动" class="headerlink" title="4.*弹性滑动"></a>4.*弹性滑动</h3><blockquote><p>上述提到的方案除了动画，滑动都是很生硬的，就是闪烁过去的。所以需要实现弹性滑动(渐进式滑动)。</p></blockquote><h4 id="1-Scroller"><a href="#1-Scroller" class="headerlink" title="1. *Scroller"></a>1. *<code>Scroller</code></h4><p>使用实例：</p><pre><code class="hljs java">Scroller scroller = <span class="hljs-keyword">new</span> Scroller(mContext); <span class="hljs-comment">//实例化一个Scroller对象</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">smoothScrollTo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dstX, <span class="hljs-keyword">int</span> dstY)</span> </span>&#123;  <span class="hljs-keyword">int</span> scrollX = getScrollX();<span class="hljs-comment">//View的左边缘到其内容左边缘的距离</span>  <span class="hljs-keyword">int</span> scrollY = getScrollY();<span class="hljs-comment">//View的上边缘到其内容上边缘的距离</span>  <span class="hljs-keyword">int</span> deltaX = dstX - scrollX;<span class="hljs-comment">//x方向滑动的位移量</span>  <span class="hljs-keyword">int</span> deltaY = dstY - scrollY;<span class="hljs-comment">//y方向滑动的位移量</span>  scroller.startScroll(scrollX, scrollY, deltaX, deltaY, <span class="hljs-number">1000</span>); <span class="hljs-comment">//开始滑动</span>  invalidate(); <span class="hljs-comment">//刷新界面</span>&#125;<span class="hljs-meta">@Override</span><span class="hljs-comment">//计算一段时间间隔内偏移的距离，并返回是否滚动结束的标记</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeScroll</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (scroller.computeScrollOffset()) &#123;     scrollTo(scroller.getCurrX(), scroller.getCurY());    postInvalidate();<span class="hljs-comment">//通过不断的重绘不断的调用computeScroll方法</span>  &#125;&#125;</code></pre><p>工作原理：</p><p>构造<code>Scroller</code>对象时，内部没有做什么，只是保存了我们传递的参数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Scroller</span><span class="hljs-params">(Context context)</span> </span>&#123;        <span class="hljs-keyword">this</span>(context, <span class="hljs-keyword">null</span>);    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Scroller</span><span class="hljs-params">(Context context, Interpolator interpolator)</span> </span>&#123;        <span class="hljs-keyword">this</span>(context, interpolator,                context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB);    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Scroller</span><span class="hljs-params">(Context context, Interpolator interpolator, <span class="hljs-keyword">boolean</span> flywheel)</span> </span>&#123;        mFinished = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (interpolator == <span class="hljs-keyword">null</span>) &#123;            mInterpolator = <span class="hljs-keyword">new</span> ViscousFluidInterpolator();        &#125; <span class="hljs-keyword">else</span> &#123;            mInterpolator = interpolator;        &#125;        mPpi = context.getResources().getDisplayMetrics().density * <span class="hljs-number">160.0f</span>;        mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction());        mFlywheel = flywheel;        mPhysicalCoeff = computeDeceleration(<span class="hljs-number">0.84f</span>); <span class="hljs-comment">// look and feel tuning</span>    &#125;</code></pre><p>保存完参数后，就需要调用<code>Scroller</code>的<code>startScroll()</code>方法，传入对应参数进行滑动</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startScroll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startX, <span class="hljs-keyword">int</span> startY, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy, <span class="hljs-keyword">int</span> duration)</span> </span>&#123;        mMode = SCROLL_MODE;        mFinished = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//滑动持续时间</span>        mDuration = duration;        <span class="hljs-comment">//滑动开始时间</span>        mStartTime = AnimationUtils.currentAnimationTimeMillis();        <span class="hljs-comment">//滑动起点</span>        mStartX = startX;        mStartY = startY;        <span class="hljs-comment">//滑动终点</span>        mFinalX = startX + dx;        mFinalY = startY + dy;        <span class="hljs-comment">//滑动距离</span>        mDeltaX = dx;        mDeltaY = dy;        mDurationReciprocal = <span class="hljs-number">1.0f</span> / (<span class="hljs-keyword">float</span>) mDuration;    &#125;</code></pre><p>调用<code>startScroll()</code>后，我们调用了<code>invalidate()</code>导致View进行了重绘，重绘过程中调用了<code>draw()</code>方法，<code>draw()</code>中调用了对应的<code>computeScroll()</code>方法。<code>computeScroll()</code>中又调用了<code>Scroller</code>的<code>computeScrollOffset()</code>方法，使<code>Scroller</code>对应的<code>mCurrX以及mCurrY</code>发生变化，配合View自身的<code>scrollTo()</code>产生滑动事件。后续继续调用了<code>postInvalidate()</code>使View重绘，按照上述流程继续执行，直到动画完成为止。</p><p><strong>关键方法为<code>startScroll()</code>及<code>computeScroll()</code></strong></p><p><img src="/images/Scroller-Process.png" srcset="/img/loading.gif" alt="Scroller-Process.png"></p><p>总结一下原理：<strong>Scroller并不能使View进行滑动，他需要配合View的computeScroll()方法才能完成滑动效果。在computeScroll()中不断让View进行重绘，每次重绘需要计算滑动持续的时间，根据这个时间计算出应该滑动到的位置，然后调用了View本身的scrollTo()配合位置进行滑动，多次的短距离滑动形成了弹性滑动的效果。</strong></p><h4 id="2-动画"><a href="#2-动画" class="headerlink" title="2. 动画"></a>2. 动画</h4><p><a href="#2-使用动画">动画</a></p><h4 id="3-延时策略"><a href="#3-延时策略" class="headerlink" title="3. 延时策略"></a>3. 延时策略</h4><blockquote><p>通过发生一系列延时消息而达到一种渐进式的效果，具体可以使用<code>Handler,View.postDelayed()或者Thread.sleep()</code>实现</p></blockquote><p><em>如果要求精确的话，不建议使用延时策略实现。</em></p><h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><a href="/2020/10/21/Android事件分发/" title="Android事件分发">Android事件分发</a><h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2><h3 id="滑动冲突场景"><a href="#滑动冲突场景" class="headerlink" title="滑动冲突场景"></a>滑动冲突场景</h3><h4 id="外部滑动和内部滑动方向不一致"><a href="#外部滑动和内部滑动方向不一致" class="headerlink" title="外部滑动和内部滑动方向不一致"></a>外部滑动和内部滑动方向不一致</h4><p><em>外层ViewGroup是可以横向滑动的，内层View是可以竖向滑动的。</em>例如：ViewPager嵌套ListView</p><h4 id="外部滑动和内部滑动方向一致"><a href="#外部滑动和内部滑动方向一致" class="headerlink" title="外部滑动和内部滑动方向一致"></a>外部滑动和内部滑动方向一致</h4><p><em>外层ViewGroup是可以竖向滑动的，内层View是也可以竖向滑动的。</em>例如：ScrollView嵌套ListView</p><h4 id="两种情况的嵌套"><a href="#两种情况的嵌套" class="headerlink" title="两种情况的嵌套"></a>两种情况的嵌套</h4><h3 id="滑动冲突处理规则"><a href="#滑动冲突处理规则" class="headerlink" title="滑动冲突处理规则"></a>滑动冲突处理规则</h3><h4 id="内外滑动方向不一致-处理规则"><a href="#内外滑动方向不一致-处理规则" class="headerlink" title="内外滑动方向不一致 处理规则"></a>内外滑动方向不一致 处理规则</h4><p><strong>根据滑动是水平滑动还是竖直滑动来判断由谁来拦截事件。</strong>可以得到滑动过程中两个点的坐标，依据滑动路径与水平方向形成的夹角(<code>斜率</code>)判断，或者水平和竖直方向滑动的距离差进行判断。<em>在ViewPager中当斜率小于0.5时判断为水平滑动。</em></p><h4 id="内外滑动方向一致-处理规则"><a href="#内外滑动方向一致-处理规则" class="headerlink" title="内外滑动方向一致 处理规则"></a>内外滑动方向一致 处理规则</h4><p>一般从业务上找突破点。根据业务需求，规定何时让外部View拦截事件何时由内部View拦截事件。</p><h4 id="嵌套滑动-处理规则"><a href="#嵌套滑动-处理规则" class="headerlink" title="嵌套滑动 处理规则"></a>嵌套滑动 处理规则</h4><p>滑动规则更复杂，所以还是要从业务代码上下手。</p><h3 id="滑动冲突解决方案"><a href="#滑动冲突解决方案" class="headerlink" title="滑动冲突解决方案"></a>滑动冲突解决方案</h3><h4 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h4><blockquote><p>点击事件都先经过<strong>父容器的拦截处理</strong>，如果父容器需要此事件就拦截，不需要就放行</p></blockquote><p>需要重写父容器的<code>onInterceptTouchEvent()</code>，在方法内部做相应的拦截。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span></span>&#123;    <span class="hljs-keyword">boolean</span> intercepted = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">int</span> x = (<span class="hljs-keyword">int</span>)ev.getX();    <span class="hljs-keyword">int</span> y = (<span class="hljs-keyword">int</span>)ev.getY();        <span class="hljs-keyword">switch</span>(ev.getAction())&#123;        <span class="hljs-comment">//ACTION_DOWN必须返回false，否则后续事件无法向下传递</span>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:        intercepted = <span class="hljs-keyword">false</span>;          <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:        <span class="hljs-keyword">if</span>(父容器需要处理该事件)&#123;            intercepted = <span class="hljs-keyword">true</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            intercepted = <span class="hljs-keyword">false</span>;        &#125;          <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//ACTION_UP事件必须返回false，否则子容器无法相应 onClick事件</span>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:        intercepted = <span class="hljs-keyword">false</span>;          <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:          <span class="hljs-keyword">break</span>;    &#125;        <span class="hljs-keyword">return</span> intercepted;&#125;</code></pre><p>是否拦截需要在<code>ACTION_MOVE</code>中进行判断，父容器需要拦截事件返回true，反之返回false。</p><h4 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h4><blockquote><p>父容器不拦截任何事件，所有事件交由子容器进行处理，如果子容器需要就消耗事件，不需要就返给父容器处理。</p></blockquote><p>需要同时重写父容器的<code>onInterceptTouchEvent()</code>以及子容器的<code>dispatchTouchEvent()</code>。需要配合<strong><code>requestDisallowInterceptTouchEvent</code></strong></p><pre><code class="hljs java"><span class="hljs-comment">//子View</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span></span>&#123;    <span class="hljs-keyword">int</span> x= (<span class="hljs-keyword">int</span>)ev.getX();    <span class="hljs-keyword">int</span> y= (<span class="hljs-keyword">int</span>)ev.getY();    <span class="hljs-keyword">switch</span>(ev.getAction())&#123;        <span class="hljs-comment">//ACTION_DOWN必须返回false，否则后续事件无法向下传递</span>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:            <span class="hljs-comment">//使父布局跳过所有拦截事件</span>        parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword">true</span>);         <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:          <span class="hljs-keyword">int</span> deltaX = x - mLastX;            <span class="hljs-keyword">int</span> deltaY = y- mLastY ;    <span class="hljs-keyword">if</span>(父容器需要处理事件)&#123;        parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword">false</span>);            &#125;          <span class="hljs-keyword">break</span>;        <span class="hljs-comment">//ACTION_UP事件必须返回false，否则子容器无法相应 onClick事件</span>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:        intercepted = <span class="hljs-keyword">false</span>;           <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:         <span class="hljs-keyword">break</span>;    &#125;    mLastX = x;    mLastY = y;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(ev);&#125;<span class="hljs-comment">//父容器</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span></span>&#123;    <span class="hljs-keyword">int</span> action = event.getAction();    <span class="hljs-keyword">if</span>(action == MotionEvent.ACTION_DOWN)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><p>两种方法相比较而言，<code>外部拦截法</code>相比<code>内部拦截法</code>实现起来更加简单，而且符合View的事件分发，推荐使用<code>外部拦截法</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-简单实现Router功能</title>
    <link href="/2018/12/24/Android-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0Router%E5%8A%9F%E8%83%BD/"/>
    <url>/2018/12/24/Android-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0Router%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-BockingQueue阻塞队列</title>
    <link href="/2018/12/24/Java-BockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <url>/2018/12/24/Java-BockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/BlockingQueue 阻塞队列xmind.png" srcset="/img/loading.gif" alt="BlockingQueue阻塞队列"></p><h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p><code>Queue队列</code>的特征是<code>FIFO——先进先出</code>。只有队尾可以进行插入操作，只有队头可以进行删除操作。</p><p><img src="/images/822721-20200318104019498-382557009.png" srcset="/img/loading.gif" alt="img"></p><p>Java中的<code>Queue</code>继承了<code>Collection</code>接口，并额外实现了以下方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span></span>;  <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">E <span class="hljs-title">element</span><span class="hljs-params">()</span></span>;  <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h3 id="队列插入数据操作-add-offer"><a href="#队列插入数据操作-add-offer" class="headerlink" title="队列插入数据操作(add/offer)"></a>队列插入数据操作(<code>add/offer</code>)</h3><blockquote><p>将新数据插入队尾</p></blockquote><p><code>add</code>：如果队列满时，插入队尾数据，就会抛出<code>IllegalStateExecption</code></p><p><code>offer</code>：如果队列满时，插入队尾数据，不会抛出异常，会返回<code>false</code></p><h3 id="队列删除数据操作-remove-poll"><a href="#队列删除数据操作-remove-poll" class="headerlink" title="队列删除数据操作(remove/poll)"></a>队列删除数据操作(<code>remove/poll</code>)</h3><blockquote><p>获取队头元素并删除</p></blockquote><p><code>remove</code>：当队列为空时，删除元素时，会抛出<code>NoSuchElementException</code></p><p><code>poll</code>：当队列为空时，删除元素时，不会抛出异常，只会返回<code>null</code></p><h3 id="队列检查数据操作-element-peek"><a href="#队列检查数据操作-element-peek" class="headerlink" title="队列检查数据操作(element/peek)"></a>队列检查数据操作(<code>element/peek</code>)</h3><blockquote><p>获取队头元素但并不删除</p></blockquote><p><code>element</code>：当队列为空时，获取队头元素，会抛出<code>NoSuchElementException</code></p><p><code>peek</code>：当队列为空时，获取队头元素，不会抛出异常，只会返回<code>null</code></p><table><thead><tr><th></th><th>抛出异常</th><th>特殊值</th></tr></thead><tbody><tr><td>插入</td><td><code>add()</code></td><td><code>offer()</code> 返回 <code>false</code></td></tr><tr><td>删除</td><td><code>remove()</code></td><td><code>poll()</code> 返回<code>null</code></td></tr><tr><td>获取数据(检查)</td><td><code>element()</code></td><td><code>peek()</code> 返回<code>null</code></td></tr></tbody></table><h2 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h2><p><strong>系统提供的用于多线程环境下存、取共享变量的一种容器。</strong></p><p><code>BlockingQueue阻塞队列</code>实现了<code>Queue接口</code>，相比于<code>Queue</code>提供了额外的功能：</p><ul><li>获取队头元素时，如果队列为空，执行线程会处于阻塞状态，直到队列非空——<code>对应删除和检查操作</code></li><li>添加队尾元素时，如果队列已满，执行线程会处于阻塞状态，直到队列不满——<code>对应插入操作</code></li></ul><p>当触发上述两种情况的出现时，按照不同的设置方式，提供了以下几种处理方案：</p><ul><li>抛出异常</li><li>返回特殊值(返回<code>null</code>或<code>false</code>)</li><li>阻塞当前线程直到可以执行</li><li>阻塞线程设置最大超时时间，若超过该时间，线程就会继续执行，放弃当次操作</li></ul><h3 id="阻塞队列插入数据操作-put-offer-time"><a href="#阻塞队列插入数据操作-put-offer-time" class="headerlink" title="阻塞队列插入数据操作(put/offer(time))"></a>阻塞队列插入数据操作(<code>put/offer(time)</code>)</h3><blockquote><p>对应阻塞队列在队列已满插入数据时的<code>阻塞</code>或者<code>超时处理</code></p></blockquote><p><code>put</code>：如果队列满时，插入队尾数据，会阻塞当前线程<code>直到队列非满</code></p><p><code>offer(time)</code>：如果队列满时，插入队尾数据，会阻塞当前线程<code>直到队列非满或者达到了超时时间</code>,达到超时时间则返回<code>false</code></p><h3 id="阻塞队列删除数据操作-take-poll-time"><a href="#阻塞队列删除数据操作-take-poll-time" class="headerlink" title="阻塞队列删除数据操作(take()/poll(time))"></a>阻塞队列删除数据操作(<code>take()/poll(time)</code>)</h3><blockquote><p>对应阻塞队列在队列为空时获取数据时的<code>阻塞</code>或<code>超时处理</code></p></blockquote><p><code>take()</code>：当队列为空时，删除元素时，会阻塞当前线程<code>直到队列非空</code></p><p><code>poll(time)</code>：当队列为空时，删除元素时，会阻塞当前线程<code>直到队列非空或者达到了超时时间</code>，达到超时时间返回<code>null</code></p><h3 id="阻塞队列检查数据操作"><a href="#阻塞队列检查数据操作" class="headerlink" title="阻塞队列检查数据操作"></a><del>阻塞队列检查数据操作</del></h3><table><thead><tr><th></th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td><code>add()</code></td><td><code>offer()</code> 返回 <code>false</code></td><td><code>put()</code></td><td><code>offer(time)</code>返回<code>false</code></td></tr><tr><td>删除</td><td><code>remove()</code></td><td><code>poll()</code> 返回<code>null</code></td><td><code>take()</code></td><td><code>poll(time)</code>返回<code>null</code></td></tr><tr><td>获取数据(检查)</td><td><code>element()</code></td><td><code>peek()</code> 返回<code>null</code></td><td>/</td><td>/</td></tr></tbody></table><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>阻塞队列无法插入<code>null</code>，否则抛出空指针异常</li><li>可以访问阻塞队列中的任意元素，尽量避免使用<code>remove(object)</code>移除对象</li></ol><h2 id="BlockingQueue实现类"><a href="#BlockingQueue实现类" class="headerlink" title="BlockingQueue实现类"></a><code>BlockingQueue</code>实现类</h2><p>在<a href="/2019/09/13/Java-线程池/" title="Java-线程池">Java-线程池</a>中的<code>workQueue</code>设置的就是<code>BlockingQueue</code>接口的实现类，</p><p>例如</p><ul><li><code>ArrayBlockingQueue</code>：数组构成的有界阻塞队列</li><li><code>LinkedBlockingQueue</code>：链表构成的有界阻塞队列，如果不设置大小的话，近似<code>无界阻塞队列</code></li><li><code>SynchronousQueue</code>：不存储任何元素的阻塞队列</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列</li></ul><h2 id="BlockingQueue原理"><a href="#BlockingQueue原理" class="headerlink" title="BlockingQueue原理"></a><code>BlockingQueue</code>原理</h2><p><code>BlockingQueue</code>只是一个接口，真正的实现都是在<code>XXBloxckingQueue</code>中的，想要分析对应的原理就需要从实现类进行分析</p><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a><code>ArrayBlockingQueue</code></h4><blockquote><p>由数组实现的有界阻塞队列，大小一旦确定就无法改变队列的长度。</p></blockquote><h5 id="关键成员变量"><a href="#关键成员变量" class="headerlink" title="关键成员变量"></a>关键成员变量</h5><pre><code class="hljs java"><span class="hljs-comment">/** The queued items 维护队列元素的数组*/</span><span class="hljs-keyword">final</span> Object[] items; <span class="hljs-comment">/** items index for next take, poll, peek or remove 移除数据的数组下标*/</span><span class="hljs-keyword">int</span> takeIndex;<span class="hljs-comment">/** items index for next put, offer, or add 插入数据的数组下标*/</span><span class="hljs-keyword">int</span> putIndex;<span class="hljs-comment">/** Number of elements in the queue 数组长度*/</span><span class="hljs-keyword">int</span> count;<span class="hljs-comment">/** Main lock guarding all access 数据并发控制类*/</span><span class="hljs-keyword">final</span> ReentrantLock lock;<span class="hljs-comment">/** Condition for waiting takes 控制take操作是否让线程等待*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<span class="hljs-comment">/** Condition for waiting puts 控制put操作是否让线程等待*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;</code></pre><p><code>ArrayBlockingQueue</code>阻塞功能的实现就是依赖了<code>ReentrantLock</code>以及<code>Condition</code>实现了<code>等待机制</code>。</p><p>具体可参考</p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        <span class="hljs-keyword">this</span>(capacity, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;        <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> Object[capacity];        lock = <span class="hljs-keyword">new</span> ReentrantLock(fair);        notEmpty = lock.newCondition();        notFull =  lock.newCondition();    &#125;</code></pre><p><code>capacity</code>：设置阻塞队列的数组容量</p><p><code>fair</code>：设置线程并发是否公平(<code>默认配置非公平锁</code>)</p><blockquote><p>当前锁被一个线程持有时，其他线程会被挂起等待锁的释放，等待时加入等待队列。</p><p><code>公平锁</code>：当锁释放时，等待队列的前端线程会优先获取锁</p><p><code>非公平锁</code>：当锁释放时，等待队列中的所有线程都会去尝试获取锁</p></blockquote><p>在<code>ArrayBlockingQueue</code>初始化时，构造<code>ReentrantLock</code>锁以及两个<code>Condition</code>对象控制数据插入、删除时的阻塞。</p><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p><code>offer()</code> 非阻塞添加数据</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;        Objects.requireNonNull(e);<span class="hljs-comment">//检查将要添加的数据是否为null</span>        <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;        lock.lock();<span class="hljs-comment">//上锁</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (count == items.length)<span class="hljs-comment">//队列已满</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-keyword">else</span> &#123;                enqueue(e);<span class="hljs-comment">//数据加入队列</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();<span class="hljs-comment">//解锁</span>        &#125;    &#125;<span class="hljs-comment">//数据入队</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E x)</span> </span>&#123;        <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span>        <span class="hljs-comment">// assert items[putIndex] == null;</span>        <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;        items[putIndex] = x;<span class="hljs-comment">//数组赋值</span>        <span class="hljs-comment">//如果此时放入的是最后一个下标的数据，重置下标为0，下一次从第一个开始放元素</span>        <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;        count++;        notEmpty.signal();<span class="hljs-comment">//通知 数组非空 </span>    &#125;</code></pre><p><code>offer()</code>添加数据时，将当前线程上锁。</p><ul><li>在当前队列已满时，直接返回<code>false</code></li><li>当前队列未满时，调用<code>enqueue()</code>添加数据，<code>putIndex</code>设置对应数据且<code>putIndex++</code>。 然后通知阻塞的消费线程<code>notEmpty</code></li></ul><p><code>poll()</code> 非阻塞取出数据</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> (count == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">null</span> : dequeue();<span class="hljs-comment">//当前队列非空 取出数据</span>    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// assert lock.getHoldCount() == 1;</span>    <span class="hljs-comment">// assert items[takeIndex] != null;</span>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    E x = (E) items[takeIndex];    items[takeIndex] = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//如果此时取出的是最后一个下标的数据，重置下标为0，下一次从第一个开始取出元素</span>    <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="hljs-number">0</span>;    count--;    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-keyword">null</span>)        itrs.elementDequeued();<span class="hljs-comment">//数据迭代减少，保证遍历线程安全</span>    notFull.signal();<span class="hljs-comment">//通知 数组不满</span>    <span class="hljs-keyword">return</span> x;&#125;</code></pre><p><code>poll()</code>取出数据时，将当前线程上锁</p><ul><li>当前队列为空的时候，直接返回null</li><li>当前队列非空的时候，调用<code>dequeue()</code>将<code>takeIndex</code>元素出队，设置<code>takeIndex</code>处元素为<code>null</code>且<code>takeIndex--</code>。然后通知阻塞的生产线程<code>notFull</code></li></ul><p><code>offer(time)</code>不超时阻塞添加数据</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span>    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Objects.requireNonNull(e);    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lockInterruptibly();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (count == items.length) &#123;            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            nanos = notFull.awaitNanos(nanos);        &#125;        enqueue(e);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><p><code>offer(time)</code>添加数据时，将当前线程上锁</p><ul><li>在当前队列已满时，阻塞生产线程<code>notFull</code>，超过<code>time</code>后，队列还是满的话，直接返回<code>false</code></li><li>当前队列未满时，调用<code>enqueue()</code>添加数据，<code>putIndex</code>设置对应数据且<code>putIndex++</code>。 然后通知阻塞的消费者<code>notEmpty</code></li></ul><p><code>poll(time)</code>不超时阻塞取出数据</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lockInterruptibly();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            nanos = notEmpty.awaitNanos(nanos);        &#125;        <span class="hljs-keyword">return</span> dequeue();    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><p><code>poll(time)</code>取出数据时，将当前线程上锁</p><ul><li>当前队列为空的时候，阻塞消费线程<code>notEmpty</code>，超过<code>time</code>后，队列还是空的话，直接返回<code>null</code></li><li>当前队列非空的时候，调用<code>dequeue()</code>将<code>takeIndex</code>元素出队，设置<code>takeIndex</code>处元素为<code>null</code>且<code>takeIndex--</code>。然后通知阻塞的生产者<code>notFull</code></li></ul><h6 id="put-阻塞添加数据"><a href="#put-阻塞添加数据" class="headerlink" title="put()阻塞添加数据"></a><code>put()</code>阻塞添加数据</h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Objects.requireNonNull(e);    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lockInterruptibly();<span class="hljs-comment">//生产者线程上锁</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (count == items.length)            notFull.await();<span class="hljs-comment">//等待消费者线程通知</span>        enqueue(e);    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><p><code>put()</code>添加数据时</p><ul><li>当前队列已满时，阻塞当前线程，等待<code>notFull</code>通知(<code>队列未满</code>)</li><li>当前队列未满时，调用<code>enqueue()</code>添加数据，<code>putIndex</code>设置对应数据且<code>putIndex++</code>。 然后通知阻塞的消费者<code>notEmpty</code></li></ul><h6 id="take-阻塞获取数据"><a href="#take-阻塞获取数据" class="headerlink" title="take()阻塞获取数据"></a><code>take()</code>阻塞获取数据</h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;    lock.lockInterruptibly();<span class="hljs-comment">//消费者线程上锁</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)            notEmpty.await();<span class="hljs-comment">//等待生产者线程通知</span>        <span class="hljs-keyword">return</span> dequeue();    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><p><code>take()</code>获取数据时</p><ul><li>当前队列为空时，阻塞当前线程，等待<code>notEmpty</code>通知(<code>队列新增数据</code>)</li><li>当前队列非空的时候，调用<code>dequeue()</code>将<code>takeIndex</code>元素出队，设置<code>takeIndex</code>处元素为<code>null</code>且<code>takeIndex--</code>。然后通知阻塞的生产者<code>notFull</code></li></ul><p>其中<code>Condition</code>的<code>await/signal</code>类似于<code>Object</code>的<code>wait/notify</code>实现等待与通知的功能。</p><p>在分析<code>enqueue()</code>和<code>dequeue()</code>时，发现底层数组不会进行扩容，而是在到达边缘时，重置<code>index</code>为0，重复利用数组。</p><p><img src="/images/ArrayBlockingQueue循环数组.jpg" srcset="/img/loading.gif" alt="ArrayBlockingQueue循环数组"></p><p>从上述源码对<code>ArrayBlockingQueue</code>进行总结：</p><p><strong>底层数据结构是一个 数组，生产者和消费者由同一个锁(<code>ReetrantLock</code>)控制，生产和消费效率低。</strong></p><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><blockquote><p>由链表实现的阻塞队列，默认最大长度为<code>Integer.MAX</code>。</p></blockquote><h5 id="关键成员变量-1"><a href="#关键成员变量-1" class="headerlink" title="关键成员变量"></a>关键成员变量</h5><pre><code class="hljs java"><span class="hljs-comment">/** The capacity bound, or Integer.MAX_VALUE if none 链表最大长度*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;<span class="hljs-comment">/** Current number of elements 当前元素个数*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger();<span class="hljs-comment">/** * Head of linked list. * Invariant: head.item == null * 链表头节点 */</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; head;<span class="hljs-comment">/** * Tail of linked list. * Invariant: last.next == null * 链表尾节点 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<span class="hljs-comment">/** Lock held by take, poll, etc 控制消费并发*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">/** Wait queue for waiting takes 控制take线程等待 非空条件*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty = takeLock.newCondition();<span class="hljs-comment">/** Lock held by put, offer, etc 控制生产并发*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">/** Wait queue for waiting puts 控制put线程等待 非满条件*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull = putLock.newCondition();</code></pre><p><code>LinkedBlockingQueue</code>采用了两把锁<code>putLock、takeLock</code>，分别进行控制，提高了并发性能。</p><h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedBlockingQueue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>(Integer.MAX_VALUE);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-keyword">this</span>.capacity = capacity;    last = head = <span class="hljs-keyword">new</span> Node&lt;E&gt;(<span class="hljs-keyword">null</span>);&#125;</code></pre><p><code>capacity</code>：设置单链表长度上限，若不设置该值，默认为<code>Integer.MAX</code></p><p>构造函数初始化了底层的链表结构。</p><h5 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h5><p><code>offer()</code>非阻塞添加数据</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;    <span class="hljs-keyword">if</span> (count.get() == capacity) <span class="hljs-comment">//达到上限直接返回false</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;    putLock.lock();<span class="hljs-comment">//线程上锁</span>    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (count.get() &lt; capacity) &#123;            enqueue(node);<span class="hljs-comment">//插入链表</span>            c = count.getAndIncrement();            <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)                notFull.signal();<span class="hljs-comment">//唤醒 等待的入队线程</span>        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        putLock.unlock();    &#125;    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)        signalNotEmpty();<span class="hljs-comment">//唤醒等待的 出队线程</span>    <span class="hljs-keyword">return</span> c &gt;= <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> </span>&#123;    <span class="hljs-comment">// assert putLock.isHeldByCurrentThread();</span>    <span class="hljs-comment">// assert last.next == null;</span>    last = last.next = node;<span class="hljs-comment">//赋值操作</span>&#125;</code></pre><p><code>offer</code>添加数据时，当队列已满时，直接返回<code>false</code>。未满时，插入新数据后，<code>count</code>自加后唤醒<code>notFull、notEmpty</code>。</p><p><code>poll()</code>非阻塞获取数据</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;    <span class="hljs-keyword">if</span> (count.get() == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<span class="hljs-comment">//队列为空返回null</span>    E x = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;    takeLock.lock();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (count.get() &gt; <span class="hljs-number">0</span>) &#123;            x = dequeue();<span class="hljs-comment">//出队</span>            c = count.getAndDecrement();            <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)                notEmpty.signal();<span class="hljs-comment">//通知非空线程</span>        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        takeLock.unlock();    &#125;    <span class="hljs-keyword">if</span> (c == capacity)        signalNotFull();<span class="hljs-comment">//通知非满线程</span>    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// assert takeLock.isHeldByCurrentThread();</span>    <span class="hljs-comment">// assert head.item == null;</span>    Node&lt;E&gt; h = head;    Node&lt;E&gt; first = h.next;    h.next = h; <span class="hljs-comment">// help GC</span>    head = first;    E x = first.item;    first.item = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">return</span> x;&#125;</code></pre><p><code>poll</code>获取数据时，队列为空时，直接返回<code>null</code>。队列非空时，获取数据后，数据出队，<code>count</code>自减后，先后唤醒<code>notEmpty</code>、<code>notFull</code>。</p><h6 id="put-阻塞添加数据-1"><a href="#put-阻塞添加数据-1" class="headerlink" title="put()阻塞添加数据"></a><code>put()</code>阻塞添加数据</h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">// Note: convention in all put/take/etc is to preset local var</span>    <span class="hljs-comment">// holding count negative to indicate failure unless set.</span>    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> Node&lt;E&gt;(e);    <span class="hljs-keyword">final</span> ReentrantLock putLock = <span class="hljs-keyword">this</span>.putLock;    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;    putLock.lockInterruptibly();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;            notFull.await();<span class="hljs-comment">//队列已满时，等待非满通知</span>        &#125;        enqueue(node);<span class="hljs-comment">//插入新数据</span>        c = count.getAndIncrement();<span class="hljs-comment">//数据自增</span>        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)            notFull.signal();<span class="hljs-comment">//通知非满线程</span>    &#125; <span class="hljs-keyword">finally</span> &#123;        putLock.unlock();    &#125;    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)        signalNotEmpty();<span class="hljs-comment">//通知非空线程</span>&#125;</code></pre><p><code>put()</code>添加数据时，队列已满时，会进行阻塞等待直到队列非满。</p><h6 id="take-阻塞获取数据-1"><a href="#take-阻塞获取数据-1" class="headerlink" title="take()阻塞获取数据"></a><code>take()</code>阻塞获取数据</h6><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    E x;    <span class="hljs-keyword">int</span> c = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">final</span> AtomicInteger count = <span class="hljs-keyword">this</span>.count;    <span class="hljs-keyword">final</span> ReentrantLock takeLock = <span class="hljs-keyword">this</span>.takeLock;    takeLock.lockInterruptibly();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;            notEmpty.await();<span class="hljs-comment">//队列为空时，等待非空通知</span>        &#125;        x = dequeue();<span class="hljs-comment">//出队</span>        c = count.getAndDecrement();        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)            notEmpty.signal();<span class="hljs-comment">//通知非空线程</span>    &#125; <span class="hljs-keyword">finally</span> &#123;        takeLock.unlock();    &#125;    <span class="hljs-keyword">if</span> (c == capacity)        signalNotFull();<span class="hljs-comment">//通知非满线程</span>    <span class="hljs-keyword">return</span> x;&#125;</code></pre><p><code>take()</code>获取数据时，队列为空时，会进行阻塞等到直到队列非空。</p><p><img src="/images/v2-8bc04760ad1133e7630717dbc38c1cc7_1440w.jpg" srcset="/img/loading.gif" alt="img"></p><p>从上述源码对<code>LinkedBlockingQueue</code>进行总结：</p><p><strong><code>LinkedBlockingQueue</code>底层数据结构为<code>单链表</code>，内部持有两个<code>Lock：putLock、takeLock</code>，相互之间不会干扰执行，提高了并发性能。</strong></p><h5 id="与ArrayBlockingQueue比较"><a href="#与ArrayBlockingQueue比较" class="headerlink" title="与ArrayBlockingQueue比较"></a>与<code>ArrayBlockingQueue</code>比较</h5><table><thead><tr><th></th><th>ArrayBlockingQueue</th><th>LinkedBlockingQueue</th></tr></thead><tbody><tr><td>构造方法</td><td>必须指定构造大小<br>指定后无法修改</td><td>默认大小为<code>Integer.MAX</code><br>可以指定大小</td></tr><tr><td>底层数据结构</td><td>数组</td><td>单链表</td></tr><tr><td>锁</td><td>出队入队使用同一把锁<br>数据的删除和添加操作互斥</td><td>出队使用<code>takeLock</code>，入队使用<code>putLock</code><br>数据删除、添加操作不干扰，提升并发性能</td></tr></tbody></table><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><blockquote><p>容量为0，无法储存数据的阻塞队列。提供了公平与非公平锁的设置。</p></blockquote><h5 id="关键成员变量-2"><a href="#关键成员变量-2" class="headerlink" title="关键成员变量"></a>关键成员变量</h5><pre><code class="hljs java"><span class="hljs-comment">//针对不同操作定义的统一接口</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Transferer&lt;E&gt; transferer;    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transferer</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;       <span class="hljs-comment">//e为空则表示 需要获取数据；e不为空表示 需要添加数据</span>        <span class="hljs-function"><span class="hljs-keyword">abstract</span> E <span class="hljs-title">transfer</span><span class="hljs-params">(E e, <span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos)</span></span>;    &#125;</code></pre><h5 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynchronousQueue</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//默认非公平构造</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SynchronousQueue</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;    <span class="hljs-comment">//公平与非公平对应两种实现形式</span>    transferer = fair ? <span class="hljs-keyword">new</span> TransferQueue&lt;E&gt;() : <span class="hljs-keyword">new</span> TransferStack&lt;E&gt;();&#125;</code></pre><h5 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h5><p>数据操作<code>offer()/poll() put()/take()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">return</span> transferer.transfer(e, <span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>) != <span class="hljs-keyword">null</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> transferer.transfer(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">if</span> (transferer.transfer(e, <span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">null</span>) &#123;        Thread.interrupted();        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    E e = transferer.transfer(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">return</span> e;    Thread.interrupted();    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();&#125;</code></pre><p>上述的数据操作方法都涉及到了两部分内容：</p><ul><li><code>transferer</code>：数据调度</li><li><code>transfer</code>：数据执行</li></ul><h6 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h6><blockquote><p><code>SynchronousQueue</code>的<strong>公平</strong>实现，内部实现使用队列，可以保证先进先出的特性。</p></blockquote><p>基本实现方法：</p><p>当前队列为空的时候或者存在了与即将添加的<code>QNode</code>操作模式一致(<code>isData一致</code>)的节点，线程进行同步等待，<code>QNode</code>添加到队列中。</p><p>继续等待与队列头部<code>QNode</code>操作互补(<code>写操作(isData = true)，等待一个读操作(isData = false)</code>)的<code>QNode</code>节点</p><p>新添加的<code>QNode</code>节点与队头<code>QNode</code>操作互补时，尝试通过<code>CAS</code>更新等待节点的item字段，然后让队头等待节点出列，并返回节点元素和更新队头节点。</p><p>如果队列中的节点的<code>waiter</code>等待线程被取消，节点也会被清理出队列。</p><p><img src="/images/TransferQueue.jpg" srcset="/img/loading.gif" alt="TransferQueue公平队列"></p><p><code>isData</code>：true 表示<code>put</code>操作，false表示<code>take</code>操作。</p><p><code>next</code>：下一个节点</p><p><code>waiter</code>：当前等待的线程</p><p><code>item</code>：元素信息</p><h6 id="TransferStack"><a href="#TransferStack" class="headerlink" title="TransferStack"></a>TransferStack</h6><blockquote><p><code>SynchronousQueue</code>非公平实现，内部实现使用<strong>栈</strong>，实现了<code>先进后出</code>的特性。</p></blockquote><p>基本实现方法：</p><p>当前栈为空或者存在了与即将添加的<code>SNode</code>模式相同的节点(<code>mode一致</code>)，线程进行同步等待，<code>SNode</code>添加到栈中</p><p>继续等待与栈顶<code>SNode</code>操作互补(<code>写操作(mode = DATA)，读操作(mode=REQUEST)</code>)的节点</p><p>出现与栈顶<code>SNode</code>操作互补的节点后，新增<code>SNode</code>节点的<code>mode</code>会变为<code>FULFILLING</code>，与栈顶节点匹配，匹配完成后，将俩节点都弹出并返回匹配节点的结果。</p><p>如果栈顶元素找到匹配节点，就会继续向下帮助匹配(<code>此时上一个匹配操作还没结束又进入一个新的请求</code>)</p><p><img src="/images/TransferStack.jpg" srcset="/img/loading.gif" alt="TranferStack"></p><p><code>next</code>：下一个元素</p><p><code>item</code>：元素信息</p><p><code>waiter</code>：当前等待的线程</p><p><code>match</code>：匹配的节点</p><p><code>mode</code>：<code>DATA(1)</code>-添加数据、<code>REQUEST(0)</code>-获取数据、<code>FULFILLING(2)</code>-互补模式</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li><code>SynchronousQueue</code>容量为0，无法进行数据存储</li><li>每次写入数据时，写线程都需要等待；直到另一个线程执行读操作，写线程会返回数据。<em>写入元素不能为null</em></li><li><code>peek()</code>返回<code>null</code>；<code>size()</code>返回<code>0</code>；无法进行迭代操作</li><li>提供了<code>公平</code>，<code>非公平</code>两种策略处理，分别是基于<code>Queue-TransferQueue</code>与<code>Stack-TransferStack</code>实现。</li></ul><h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><p>绝大多数都是利用了<strong>Lock锁的多条件(Condition)阻塞控制</strong>。</p><p>拿<code>ArrayBlockigQueue</code>进行简单描述就是：</p><ol><li><code>put</code>和<code>take</code>操作都需要先<strong>获取锁</strong>，无法获取的话就要一直自旋拿锁，直到获取锁为止</li><li>在拿到锁以后。还需要判断当前队列是否可用(<code>队列非满且非空</code>)，如果队列不可用就会被阻塞，并<strong>释放锁</strong></li><li>阻塞的线程被唤醒时，依然需要在拿到锁之后才可以继续执行，否则，自旋拿锁，拿到锁继续判断当前队列是否可用(<strong>使用while判断</strong>)</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h5 id="生产-消费模型"><a href="#生产-消费模型" class="headerlink" title="生产-消费模型"></a>生产-消费模型</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> queueSize = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(queueSize, <span class="hljs-keyword">true</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        PCDemo blockQueue = <span class="hljs-keyword">new</span> PCDemo();        Producter producter = blockQueue.<span class="hljs-keyword">new</span> Producter();        Customer customer = blockQueue.<span class="hljs-keyword">new</span> Customer();        producter.start();        customer.start();    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    queue.take();                    System.err.println(<span class="hljs-string">"消费哦，剩余空间为"</span> + queue.size());                    Thread.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    queue.put(<span class="hljs-number">1</span>);                    System.err.println(<span class="hljs-string">"生产哦，剩余空间为"</span> + (queueSize - queue.size()));                    Thread.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><a href="/2019/09/13/Java-线程池/" title="Java-线程池">Java-线程池</a><h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><h3 id="Guarded-Suspension（保护性暂时挂起）"><a href="#Guarded-Suspension（保护性暂时挂起）" class="headerlink" title="Guarded Suspension（保护性暂时挂起）"></a>Guarded Suspension（保护性暂时挂起）</h3><p><strong>当服务进程准备好时，才提供服务。</strong></p><p><img src="/images/java-concurrent-guarded-suspension.png" srcset="/img/loading.gif" alt="img"></p><p>本质是一种<strong>等待唤醒机制的实现</strong>，也称为<strong>多线程的if</strong></p><p>基本实现代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuardedObject</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;  <span class="hljs-keyword">private</span> T obj;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReetrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition done = lock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(Predicate&lt;T&gt; p)</span></span>&#123;    lock.lock();    <span class="hljs-keyword">try</span>&#123;      <span class="hljs-keyword">while</span>(!p.test(obj))&#123;        done.await(); <span class="hljs-comment">//等待事件执行</span>      &#125;    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;      e.printStacktrace();    &#125;<span class="hljs-keyword">finally</span>&#123;      lock.unlock();    &#125;    <span class="hljs-keyword">return</span> obj;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChange</span><span class="hljs-params">(T obj)</span></span>&#123;    lock.lock();    <span class="hljs-keyword">try</span>&#123;      <span class="hljs-keyword">this</span>.obj = obj;      done.signAll();<span class="hljs-comment">//数据发生变化，进行通知</span>    &#125;<span class="hljs-keyword">finally</span>&#123;      lock.unlock();    &#125;  &#125;&#125;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/dwlsxj/archive/2004/01/13/Thread.html" target="_blank" rel="noopener">SynchronousQueue-公平模式</a></p><p><a href="https://www.jianshu.com/p/a565b0b25c43" target="_blank" rel="noopener">SynchronousQueue</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-线程相关</title>
    <link href="/2018/12/21/Android-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    <url>/2018/12/21/Android-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<!--AsyncTask 内部实现--><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Android中的线程.png" srcset="/img/loading.gif" class="full-image" alt="Android线程" title="Android线程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>在Android中进程一般指代App，线程又分为</p><ul><li>主线程：进程所拥有的线程，默认情况下一个进程只有一个线程，这个线程就是主线程。Android中对应UI线程</li><li>子线程：工作线程，除主线程以外的线程都是工作线程。Android中的子线程的作用是处理耗时任务，比如网络请求，IO操作。</li></ul><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><blockquote><p>轻量级的异步任务，可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程更新UI。</p></blockquote><p>在Android中实现异步任务机制机制有两种方式：<code>Handler</code>和<code>AsyncTask</code>。</p><ul><li>Handler机制存在的问题：代码相对臃肿；多任务同时执行时不易控制线程。</li></ul><p>AsyncTask的优点：创建异步任务更简单，直接继承它可以方便实现后台异步任务的执行科进度的回调更新UI，而无需编写任务线程和Handler实例就能完成相同的任务。</p><h3 id="AsyncTask的重要参数及方法"><a href="#AsyncTask的重要参数及方法" class="headerlink" title="AsyncTask的重要参数及方法"></a>AsyncTask的重要参数及方法</h3><p>AsyncTask是抽象的泛型类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">Params</span>,<span class="hljs-title">Progress</span>,<span class="hljs-title">Result</span>&gt;</span>&#123;  ...&#125;</code></pre><p>三个泛型参数：</p><ul><li><code>Params</code>：表示执行AsyncTask需要传入的参数，可用于在后台任务中使用</li><li><code>Progress</code>：后台执行任务的进度的类型</li><li><code>Result</code>：后台任务的返回结果的类型</li></ul><p>不需要传递具体的参数，都可以用<code>void</code>代替。</p><p>五个核心方法：</p><ul><li><code>onPreExecute()</code>：在主线程中执行，在异步任务执行之前调用，一般可以做一些初始化工作。</li><li><code>doInBackground(Params... params)</code>：在线程池中执行，可用于处理所有的耗时任务。可以通过调用<code>publishProgress()</code>来更新任务进度。</li><li><code>onProgrssUpdate(Progress... values)</code>：在主线程中执行，后台任务执行进度发生改变时调用此方法。</li><li><code>onPostExecute(Result result)</code>：在主线程中执行，在异步任务执行完毕并通过return语句返回时被调用。</li><li><code>onCancelled()</code>：在主线程中执行，当异步任务取消时被调用，可用于取消任务时的界面更新。</li></ul><p><strong>不要直接调用上述方法，并且AsyncTask对象必须在主线程创建。一个AsyncTask对象只能执行一次，否则会报异常。</strong></p><h3 id="AsyncTask使用"><a href="#AsyncTask使用" class="headerlink" title="AsyncTask使用"></a>AsyncTask使用</h3><p>实现一个下载文件的AsyncTask</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownloadTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Integer</span>, <span class="hljs-title">Boolean</span>&gt; </span>&#123;        <span class="hljs-meta">@Override</span><span class="hljs-comment">//初始化一个ProgressDialog  </span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPreExecute</span><span class="hljs-params">()</span> </span>&#123;          progressDialog.show();      &#125;        <span class="hljs-meta">@Override</span><span class="hljs-comment">//具体的下载逻辑</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Boolean <span class="hljs-title">doInBackground</span><span class="hljs-params">(String... params)</span> </span>&#123;          <span class="hljs-keyword">try</span> &#123;              <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                  <span class="hljs-keyword">int</span> downloadPercent = doDownload(params[<span class="hljs-number">0</span>]);                  publishProgress(downloadPercent);                  <span class="hljs-keyword">if</span> (downloadPercent &gt;= <span class="hljs-number">100</span>) &#123;                      <span class="hljs-keyword">break</span>;                  &#125;              &#125;          &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;          &#125;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125;        <span class="hljs-meta">@Override</span><span class="hljs-comment">//显示当前的下载进度</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgressUpdate</span><span class="hljs-params">(Integer... values)</span> </span>&#123;          progressDialog.setMessage(<span class="hljs-string">"当前下载进度："</span> + values[<span class="hljs-number">0</span>] + <span class="hljs-string">"%"</span>);      &#125;        <span class="hljs-meta">@Override</span><span class="hljs-comment">//提示任务的执行结果  </span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPostExecute</span><span class="hljs-params">(Boolean result)</span> </span>&#123;          progressDialog.dismiss();          <span class="hljs-keyword">if</span> (result) &#123;              Toast.makeText(context, <span class="hljs-string">"下载成功"</span>, Toast.LENGTH_SHORT).show();          &#125; <span class="hljs-keyword">else</span> &#123;              Toast.makeText(context, <span class="hljs-string">"下载失败"</span>, Toast.LENGTH_SHORT).show();          &#125;      &#125;  &#125;</code></pre><pre><code class="hljs java">DownlaodTask task = <span class="hljs-keyword">new</span> DownloadTask();<span class="hljs-comment">//任务启动</span>task.execute(<span class="hljs-string">"downloadUrl"</span>)；<span class="hljs-comment">//任务取消</span>task.cancel(<span class="hljs-keyword">true</span>);</code></pre><p><code>execute(Params... params)</code>：必须在主线程中调用，表示开始一个异步任务。<strong>一个AsyncTask只能调用一次该方法</strong>。</p><p><code>cancel(boolean mayInterruptIfRunning)</code>：必须在主线程中调用，表示停止一个异步任务。<code>mayInterruptIfRunning</code>表示是否立即停止任务，true立即停止，false则等待执行完毕。</p><h3 id="AsyncTask工作原理"><a href="#AsyncTask工作原理" class="headerlink" title="AsyncTask工作原理"></a>AsyncTask工作原理</h3><h4 id="新建AsyncTask实例"><a href="#新建AsyncTask实例" class="headerlink" title="新建AsyncTask实例"></a>新建AsyncTask实例</h4><p>必须要先新建一个AsyncTask实例，后续才可以去执行启动或停止等操作。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncTask</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">this</span>((Looper) <span class="hljs-keyword">null</span>);   &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncTask</span><span class="hljs-params">(@Nullable Looper callbackLooper)</span> </span>&#123;       mHandler = callbackLooper == <span class="hljs-keyword">null</span> || callbackLooper == Looper.getMainLooper()           ? getMainHandler()           : <span class="hljs-keyword">new</span> Handler(callbackLooper);       mWorker = <span class="hljs-keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;           <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;               <span class="hljs-comment">//表示当前任务已被调用</span>               mTaskInvoked.set(<span class="hljs-keyword">true</span>);               Result result = <span class="hljs-keyword">null</span>;               <span class="hljs-keyword">try</span> &#123;                   <span class="hljs-comment">//设置线程优先级为  后台线程</span>                   Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);                   <span class="hljs-comment">//开始调用后台任务执行</span>                   result = doInBackground(mParams);                   Binder.flushPendingCommands();               &#125; <span class="hljs-keyword">catch</span> (Throwable tr) &#123;                   <span class="hljs-comment">//出错取消任务</span>                   mCancelled.set(<span class="hljs-keyword">true</span>);                   <span class="hljs-keyword">throw</span> tr;               &#125; <span class="hljs-keyword">finally</span> &#123;                   <span class="hljs-comment">//发送任务执行结果</span>                   postResult(result);               &#125;               <span class="hljs-keyword">return</span> result;           &#125;       &#125;;       <span class="hljs-comment">//实现了 Runnable 和Future接口，因此可以包装 Runnble和 Callable</span>       mFuture = <span class="hljs-keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">done</span><span class="hljs-params">()</span> </span>&#123;               <span class="hljs-keyword">try</span> &#123;                   postResultIfNotInvoked(get());               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                   android.util.Log.w(LOG_TAG, e);               &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"An error occurred while executing doInBackground()"</span>,                           e.getCause());               &#125; <span class="hljs-keyword">catch</span> (CancellationException e) &#123;                   postResultIfNotInvoked(<span class="hljs-keyword">null</span>);               &#125;           &#125;       &#125;;   &#125;      <span class="hljs-comment">//一个Callable对象</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerRunnable</span>&lt;<span class="hljs-title">Params</span>, <span class="hljs-title">Result</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Result</span>&gt; </span>&#123;       Params[] mParams;   &#125;</code></pre><p>新建实例过程中，只是初始化了两个变量<code>mWorker，mFuture</code>。</p><h4 id="启动AsyncTask"><a href="#启动AsyncTask" class="headerlink" title="启动AsyncTask"></a>启动AsyncTask</h4><p>新建实例完成后，就要开始启动任务去执行。</p><pre><code class="hljs java"><span class="hljs-comment">//标记主线程执行</span><span class="hljs-meta">@MainThread</span><span class="hljs-comment">//启动异步任务</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="hljs-title">execute</span><span class="hljs-params">(Params... params)</span> </span>&#123;    <span class="hljs-keyword">return</span> executeOnExecutor(sDefaultExecutor, params);&#125;<span class="hljs-meta">@MainThread</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="hljs-title">executeOnExecutor</span><span class="hljs-params">(Executor exec,        Params... params)</span> </span>&#123;    <span class="hljs-comment">//如果在任务执行或结束时 重复调用执行 会出错</span>    <span class="hljs-keyword">if</span> (mStatus != Status.PENDING) &#123;        <span class="hljs-keyword">switch</span> (mStatus) &#123;            <span class="hljs-keyword">case</span> RUNNING:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot execute task:"</span>                        + <span class="hljs-string">" the task is already running."</span>);            <span class="hljs-keyword">case</span> FINISHED:                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot execute task:"</span>                        + <span class="hljs-string">" the task has already been executed "</span>                        + <span class="hljs-string">"(a task can be executed only once)"</span>);        &#125;    &#125;    <span class="hljs-comment">//标记运行状态</span>    mStatus = Status.RUNNING;    <span class="hljs-comment">//异步开始前的准备</span>    onPreExecute();    mWorker.mParams = params;    <span class="hljs-comment">//开始执行任务</span>    exec.execute(mFuture);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre><p><code>exec</code>是传递的一个数据，它指向一个串行线程池。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor SERIAL_EXECUTOR = <span class="hljs-keyword">new</span> SerialExecutor();     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR; <span class="hljs-comment">//串行线程池</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerialExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Executor</span> </span>&#123;     <span class="hljs-keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="hljs-keyword">new</span> ArrayDeque&lt;Runnable&gt;();     Runnable mActive;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable r)</span> </span>&#123;         <span class="hljs-comment">//FutureTask 插入 mTasks中</span>         mTasks.offer(<span class="hljs-keyword">new</span> Runnable() &#123;             <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                 <span class="hljs-keyword">try</span> &#123;                     r.run();                 &#125; <span class="hljs-keyword">finally</span> &#123;                     scheduleNext();                 &#125;             &#125;         &#125;);         <span class="hljs-keyword">if</span> (mActive == <span class="hljs-keyword">null</span>) &#123;             scheduleNext();         &#125;     &#125;     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleNext</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">if</span> ((mActive = mTasks.poll()) != <span class="hljs-keyword">null</span>) &#123;             THREAD_POOL_EXECUTOR.execute(mActive);         &#125;     &#125; &#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InternalHandler</span><span class="hljs-params">(Looper looper)</span> </span>&#123;        <span class="hljs-keyword">super</span>(looper);    &#125;    <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"unchecked"</span>, <span class="hljs-string">"RawUseOfParameterizedType"</span>&#125;)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;        <span class="hljs-keyword">switch</span> (msg.what) &#123;            <span class="hljs-keyword">case</span> MESSAGE_POST_RESULT:                <span class="hljs-comment">// 通知任务结束 调用结束之后事件</span>                result.mTask.finish(result.mData[<span class="hljs-number">0</span>]);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MESSAGE_POST_PROGRESS:                <span class="hljs-comment">//通知进度更新</span>                result.mTask.onProgressUpdate(result.mData);                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><p><strong>内部静态Handler</strong>。负责将环境从线程池中切换到主线程；通过他来发送任务执行的进度以及执行结束等消息。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors(); <span class="hljs-comment">// CPU核数</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CORE_POOL_SIZE = Math.max(<span class="hljs-number">2</span>, Math.min(CPU_COUNT - <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<span class="hljs-comment">// 核数为2 核心线程数为 2</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//核数为2 最大允许 5</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> KEEP_ALIVE_SECONDS = <span class="hljs-number">30</span>;<span class="hljs-comment">// 最多存活30s</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadFactory sThreadFactory = <span class="hljs-keyword">new</span> ThreadFactory() &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger mCount = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, <span class="hljs-string">"AsyncTask #"</span> + mCount.getAndIncrement());    &#125;&#125;;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =        <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">128</span>);<span class="hljs-comment">/** * An &#123;<span class="hljs-doctag">@link</span> Executor&#125; that can be used to execute tasks in parallel. */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor THREAD_POOL_EXECUTOR;<span class="hljs-keyword">static</span> &#123;    ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,            sPoolWorkQueue, sThreadFactory);    threadPoolExecutor.allowCoreThreadTimeOut(<span class="hljs-keyword">true</span>);    THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125;</code></pre><p><strong>真正执行异步任务的线程池。</strong></p><p><code>AsyncTask</code>的任务都是串行执行的，如果需要并行执行，可以使用如下代码：</p><pre><code class="hljs java">task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,<span class="hljs-string">""</span>);</code></pre><p>还可以使用自己定义的线程池</p><pre><code class="hljs java">Executor exec = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">15</span>, <span class="hljs-number">200</span>, <span class="hljs-number">10</span>,TimeUnit.SECONDS, <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<span class="hljs-keyword">new</span> DownloadTask().executeOnExecutor(exec);</code></pre><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><blockquote><p>HandlerThread是一个线程类，它继承自Thread。</p><p>它比普通Thread多了<strong>消息循环</strong>效果。</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    mTid = Process.myTid();    Looper.prepare();    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;        mLooper = Looper.myLooper();        notifyAll();    &#125;    Process.setThreadPriority(mPriority);    onLooperPrepared();    Looper.loop();    mTid = -<span class="hljs-number">1</span>;&#125;</code></pre><p>内部就已经实现了<code>Looper</code>，通过<code>Looper.prepare()</code>创建消息队列，通过<code>Looper.loop()</code>开启循环效果。</p><p>使用实例</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> HandlerThread myHandlerThread ;  <span class="hljs-keyword">private</span> Handler handler ;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;      <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);     setContentView(R.layout.activity_main);     <span class="hljs-comment">//实例化HandlerThread</span>   myHandlerThread = <span class="hljs-keyword">new</span> HandlerThread(<span class="hljs-string">"myHandler"</span>) ;     <span class="hljs-comment">//开启HandlerThread</span>   myHandlerThread.start();     <span class="hljs-comment">//将Handler对象与HandlerThread线程绑定</span>   handler =<span class="hljs-keyword">new</span> Handler(myHandlerThread.getLooper())&#123;         <span class="hljs-meta">@Override</span>          <span class="hljs-function">publicvoid <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;             <span class="hljs-keyword">super</span>.handleMessage(msg);             <span class="hljs-comment">// do something</span>        &#125;      &#125;;        handler.sendEmptyMessage(<span class="hljs-number">1</span>) ;     <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>          <span class="hljs-function">publicvoid <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;             handler.sendEmptyMessage(<span class="hljs-number">2</span>) ;          &#125;      &#125;).start();  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">super</span>.onDestroy();     <span class="hljs-comment">//终止HandlerThread运行</span>   myHandlerThread.quit() ;  <span class="hljs-comment">//立马退出</span>  <span class="hljs-comment">//myHandlerThread.quitSafely() //执行完毕后退出</span>&#125;</code></pre><p>主要用于在子线程中创建Handler时使用。</p><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><blockquote><p>继承了Service并且是一个抽象类。</p><p>IntentService可用于执行后台耗时任务，任务执行完毕后会自动停止，同时由于IntentService是服务的原因，优先级高于线程，更不容易被杀死。</p></blockquote><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalIntentService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span></span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"LocalIntentService"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LocalIntentService</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">super</span>(TAG);  &#125;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHandleIntent</span><span class="hljs-params">(Intent intent)</span></span>&#123;    String action = intent.getExtras().getString(<span class="hljs-string">"action"</span>);    <span class="hljs-keyword">switch</span>(action)&#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">"action1"</span>:        Log.i(TAG,<span class="hljs-string">"action1"</span>);        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">break</span>;    &#125;  &#125;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>&#123;    Log.i(TAG,<span class="hljs-string">"onCreate"</span>);    <span class="hljs-keyword">super</span>.onCreate();  &#125;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartCommand</span><span class="hljs-params">(Intent intent, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> startId)</span></span>&#123;    Log.i(TAG,<span class="hljs-string">"onStartCommand"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onStartCommand(intent, flags, startId);  &#125;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>&#123;    Log.i(TAG,<span class="hljs-string">"onDestroy"</span>);    <span class="hljs-keyword">super</span>.onDestroy();  &#125;&#125;</code></pre><p>在AndroidManifest.xml 中注册</p><pre><code class="hljs java">&lt;service android:name=".LocalIntentService"&gt;            &lt;intent-filter &gt;                &lt;action android:name="com.wxy.service"/&gt;            &lt;/intent-filter&gt;        &lt;/service&gt;</code></pre><p>在Activity中使用</p><pre><code class="hljs java">Intent i = <span class="hljs-keyword">new</span> Intent(<span class="hljs-string">"com.wxy.service"</span>);Bundle bundle = <span class="hljs-keyword">new</span> Bundle();bundle.putString(<span class="hljs-string">"action"</span>,<span class="hljs-string">"action1"</span>);i.putExtras(bundle);startService(i);</code></pre><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>从IntentService启动开始</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">super</span>.onCreate();       <span class="hljs-comment">//利用HandlerThread创建线程并启动</span>       HandlerThread thread = <span class="hljs-keyword">new</span> HandlerThread(<span class="hljs-string">"IntentService["</span> + mName + <span class="hljs-string">"]"</span>);       thread.start();            mServiceLooper = thread.getLooper();       <span class="hljs-comment">//handler与handlerThread创建的Looper进行绑定</span>       mServiceHandler = <span class="hljs-keyword">new</span> ServiceHandler(mServiceLooper);   &#125;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceHandler</span><span class="hljs-params">(Looper looper)</span> </span>&#123;           <span class="hljs-keyword">super</span>(looper);       &#125;       <span class="hljs-meta">@Override</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;           <span class="hljs-comment">//获取的消息 交由 onHandleIntent 进行处理</span>           onHandleIntent((Intent)msg.obj);           <span class="hljs-comment">//消息处理完毕后 关闭Service</span>           stopSelf(msg.arg1);       &#125;   &#125;   <span class="hljs-meta">@WorkerThread</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHandleIntent</span><span class="hljs-params">(@Nullable Intent intent)</span></span>;</code></pre><p>上述源码完成了一次工作线程的创建。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">(@Nullable Intent intent, <span class="hljs-keyword">int</span> startId)</span> </span>&#123;    Message msg = mServiceHandler.obtainMessage();    msg.arg1 = startId;    msg.obj = intent;    <span class="hljs-comment">//把请求发送至消息队列中</span>    mServiceHandler.sendMessage(msg);&#125;<span class="hljs-comment">/** * You should not override this method for your IntentService. Instead, * override &#123;<span class="hljs-doctag">@link</span> #onHandleIntent&#125;, which the system calls when the IntentService * receives a start request. * <span class="hljs-doctag">@see</span> android.app.Service#onStartCommand */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">onStartCommand</span><span class="hljs-params">(@Nullable Intent intent, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> startId)</span> </span>&#123;    onStart(intent, startId);    <span class="hljs-keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//退出循环 并清空消息</span>    mServiceLooper.quit();&#125;</code></pre><p>通过<code>onStartCommand()</code>将消息(<code>intent</code>)依次插入到消息队列中。</p><p>从源码中我们可以得知以下要点：</p><ol><li><p><strong>工作任务是顺序执行的</strong></p><p>由于每执行一个后台任务都必须去启动一次IntentSercvice，每启动一次都会想IntentService中的消息队列插入消息，也就只能按照顺序去执行后台任务。</p></li><li><p><strong>不建议通过<code>bindService()</code>启动IntentService</strong></p><p><code>bindService()</code>启动的Service不会触发<code>onStart()/onStartCommand()</code>执行，所以无法将消息插入到队列中，自然也无法执行任务。</p></li></ol><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/IntentService执行流程.png" srcset="/img/loading.gif" class="full-image" alt="IntentService执行流程" title="IntentService执行流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-红黑树</title>
    <link href="/2018/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2018/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<!--二叉平衡树的区别，好处有哪些，红黑树的节点增删...不会-->]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RecyclerView简析</title>
    <link href="/2018/12/20/RecycleView%E7%AE%80%E6%9E%90/"/>
    <url>/2018/12/20/RecycleView%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView机制.png" srcset="/img/loading.gif" class="full-image" alt="RecyclerView机制" title="RecyclerView机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="RecyclerView定义"><a href="#RecyclerView定义" class="headerlink" title="RecyclerView定义"></a>RecyclerView定义</h2><blockquote><p>RecyclerView是一个新的组件，用来代替ListView组件的。</p></blockquote><p>相比于ListView来说，RecyclerView的最大一个特性就是<strong>灵活性</strong>，主要体现在以下几个方面：</p><ul><li><code>多样式</code>：可以对数据展示进行定制，可以显示成列表，表格或者是瀑布流，你还可以自定义成任何显示样式。</li><li><code>局部刷新</code>：可以刷新指定的Item或者区域</li><li><code>刷新动画</code>：支持对Item的添加和移除添加动画</li><li><code>添加装饰</code>：支持自定义Item之间的分割线效果</li></ul><p>相比ListView还有其他的优点：</p><ul><li>默认实现View的复用，不需要判断<code>if(convertView == null)</code>的实现，回收机制更加完善。</li><li>容易实现拖拽，侧滑删除等效果。(利用<code>ItemTouchHelper</code>)</li></ul><p>RecyclerView是一个插件式的实现，对各个功能进行解耦，从而扩展性比较好。</p><h2 id="RecyclerView用法"><a href="#RecyclerView用法" class="headerlink" title="RecyclerView用法"></a>RecyclerView用法</h2><p>RecyclerView的标准实现流程如下：</p><ul><li><p>创建Adapter：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">DemoAdapter</span>.<span class="hljs-title">VH</span>&gt; </span>&#123;...&#125;</code></pre><p>创建一个继承<code>RecyclerView.Adapter</code>的Adapter类</p></li><li><p>创建ViewHolder：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span> </span>&#123;    <span class="hljs-keyword">final</span> TextView title;      VH(<span class="hljs-meta">@NonNull</span> View itemView) &#123;        <span class="hljs-keyword">super</span>(itemView);        title = itemView.findViewById(R.id.title);    &#125;&#125;</code></pre><p>创建一个继承<code>RecyclerView.ViewHolder</code>的静态内部类，记为<code>VH</code>。内部实现类似<code>ListView的ViewHolder</code>。</p></li><li><p>完善以下方法：</p><ul><li><p><code>VH onCreateViewHolder(ViewGroup parent,int viewType)</code>：绑定对应的layout id并创建<code>VH</code>返回</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> DemoAdapter.<span class="hljs-function">VH <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(@NonNull ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_demo, parent, <span class="hljs-keyword">false</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VH(view);&#125;</code></pre></li><li><p><code>void onBindViewHolder(VH holder,int position)</code>：为<code>VH</code>设置事件以及数据</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(@NonNull VH holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;    holder.title.setText(mData.get(position));    holder.itemView.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;            <span class="hljs-comment">//设置item点击事件</span>        &#125;    &#125;);&#125;</code></pre></li><li><p><code>int getItemCount()</code>：返回item个数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> mData.size(); &#125;</code></pre></li></ul></li></ul><p>Adapter创建完成后，需要把Adapter设置到RecyclerView上。一般来说需要为RecyclerView进行四大设置：</p><ul><li><strong>设置Adapter(必须设置)</strong>：给RecyclerView绑定数据源 </li><li><strong>设置LayoutManager(必须设置)</strong>：给RecyclerView设置显示样式</li><li><strong>设置Item Decoration(可以设置)</strong>：给RecyclerView设置Item间的分割线</li><li><strong>设置Item Animator(可以设置)</strong>：给RecyclerView设置Item的添加和删除动画</li></ul><p>设置实例：</p><pre><code class="hljs java">List&lt;String&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();RecyclerView rv_demo = (RecyclerView)findViewById(R.id.rv_demo);rv_demo.setAdapter(<span class="hljs-keyword">new</span> DemoAdapter(data));rv_demo.setLayoutManager(<span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>));<span class="hljs-comment">//默认竖向显示</span></code></pre><p>更新数据：</p><pre><code class="hljs java">rv_demo.notifyDataSetChanged();<span class="hljs-comment">//更新整个视图</span><span class="hljs-comment">//更新局部视图</span>rv_demo.notifyitemInserted();rv_demo.notifyItemRemoved();rv_demo.notifyitemChanged();</code></pre><h2 id="RecyclerView源码解析"><a href="#RecyclerView源码解析" class="headerlink" title="RecyclerView源码解析"></a>RecyclerView源码解析</h2><blockquote><p>RecyclerView的四大组成部分：<strong>Adapter、LayoutManager、ItemAnimator，ItemDecoration</strong>。</p></blockquote><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><blockquote><p>主要为了给RecyclerView提供数据，将Data与View进行绑定。创建ViewHolder以及数据变化时通知到RecyclerView。通知RecyclerView使用的是<em>观察者模式</em>。</p></blockquote><p>在<code>setAdapter()</code>时，就会给Adapter注册一个观察者，去通知RecyclerView数据变化</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAdapter</span><span class="hljs-params">(Adapter adapter)</span> </span>&#123;    <span class="hljs-comment">// bail out if layout is frozen</span>    setLayoutFrozen(<span class="hljs-keyword">false</span>);    setAdapterInternal(adapter, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);    requestLayout();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAdapterInternal</span><span class="hljs-params">(Adapter adapter, <span class="hljs-keyword">boolean</span> compatibleWithPrevious,        <span class="hljs-keyword">boolean</span> removeAndRecycleViews)</span> </span>&#123;    ...    <span class="hljs-keyword">if</span> (adapter != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//注册观察者</span>        adapter.registerAdapterDataObserver(mObserver);        adapter.onAttachedToRecyclerView(<span class="hljs-keyword">this</span>);    &#125;    ...&#125;</code></pre><p><br></p><h3 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h3><blockquote><p>负责RecyclerView的布局，其中包含了Item View的获取与回收。后面会分析它的缓存机制。</p></blockquote><p>还是按照绘制流程来看，LayoutManager在RecyclerView中是如何使用的？</p><blockquote><p>Measure流程</p></blockquote><pre><code class="hljs java">LayoutManager mLayout;   <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthSpec, <span class="hljs-keyword">int</span> heightSpec)</span> </span>&#123;      <span class="hljs-keyword">if</span> (mLayout.mAutoMeasure) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> skipMeasure = widthMode == MeasureSpec.EXACTLY                    &amp;&amp; heightMode == MeasureSpec.EXACTLY;            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);       ...       &#125;      ...    &#125;</code></pre><p>在<code>RecyclerView.onMeasure()</code>中调用到了<code>LayoutManager.onMeasure()</code>，然后其中执行到了<code>RecyclerView.defaultOnMeasure()</code></p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">defaultOnMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthSpec, <span class="hljs-keyword">int</span> heightSpec)</span> </span>&#123;        <span class="hljs-comment">// calling LayoutManager here is not pretty but that API is already public and it is better</span>        <span class="hljs-comment">// than creating another method since this is internal.</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = LayoutManager.chooseSize(widthSpec,                getPaddingLeft() + getPaddingRight(),                getMinimumWidth());        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = LayoutManager.chooseSize(heightSpec,                getPaddingTop() + getPaddingBottom(),                getMinimumHeight());        setMeasuredDimension(width, height);    &#125;<span class="hljs-comment">// LayoutManager.java</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">chooseSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> spec, <span class="hljs-keyword">int</span> desired, <span class="hljs-keyword">int</span> min)</span> </span>&#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mode = View.MeasureSpec.getMode(spec);            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = View.MeasureSpec.getSize(spec);            <span class="hljs-keyword">switch</span> (mode) &#123;                <span class="hljs-keyword">case</span> View.MeasureSpec.EXACTLY:                    <span class="hljs-keyword">return</span> size;                <span class="hljs-keyword">case</span> View.MeasureSpec.AT_MOST:                    <span class="hljs-keyword">return</span> Math.min(size, Math.max(desired, min));                <span class="hljs-keyword">case</span> View.MeasureSpec.UNSPECIFIED:                <span class="hljs-keyword">default</span>:                    <span class="hljs-keyword">return</span> Math.max(desired, min);            &#125;        &#125;</code></pre><p>最终RecyclerView的<code>Measure流程</code>依赖<code>LayoutManager.chooseSize()</code>来确定最后的RecyclerView宽高。</p><blockquote><p>Layout流程</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    Trace.beginSection(TRACE_ON_LAYOUT_TAG);    dispatchLayout();    Trace.endSection();    mFirstLayoutComplete = <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchLayout</span><span class="hljs-params">()</span> </span>&#123;   ...    mState.mIsMeasuring = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">//第一次开始布局</span>    <span class="hljs-keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;        <span class="hljs-comment">//存储ziView状态并确定是否要执行动画</span>        dispatchLayoutStep1();        mLayout.setExactMeasureSpecsFrom(<span class="hljs-keyword">this</span>);        dispatchLayoutStep2();      <span class="hljs-comment">//发生了数据变化(notifyDataSetChanges)或者布局变化</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()            || mLayout.getHeight() != getHeight()) &#123;        <span class="hljs-comment">// First 2 steps are done in onMeasure but looks like we have to run again due to</span>        <span class="hljs-comment">// changed size.</span>        mLayout.setExactMeasureSpecsFrom(<span class="hljs-keyword">this</span>);        <span class="hljs-comment">//Item布局过程</span>        dispatchLayoutStep2();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// always make sure we sync them (to ensure mode is exact)</span>        mLayout.setExactMeasureSpecsFrom(<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-comment">//执行Item 动画</span>    dispatchLayoutStep3();&#125;</code></pre><p>观察上述源码发现，涉及布局过程的只有<code>dispatchLayoutStep2()</code>，从这个方法继续向下看</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchLayoutStep2</span><span class="hljs-params">()</span> </span>&#123;    ...    <span class="hljs-comment">// Step 2: Run layout</span>    mState.mInPreLayout = <span class="hljs-keyword">false</span>;    mLayout.onLayoutChildren(mRecycler, mState);    ...&#125;</code></pre><p>这里涉及到了<code>LayoutManager.onLayoutChildren()</code>，由于默认是空实现，我们就拿<code>LinearLayoutManager</code>这个子类继续分析</p><pre><code class="hljs java"><span class="hljs-comment">// LinearLayoutManager.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayoutChildren</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;     ...        <span class="hljs-keyword">int</span> startOffset;        <span class="hljs-keyword">int</span> endOffset;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> firstLayoutDirection;        <span class="hljs-keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL                    : LayoutState.ITEM_DIRECTION_HEAD;        &#125; <span class="hljs-keyword">else</span> &#123;            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD                    : LayoutState.ITEM_DIRECTION_TAIL;        &#125;        onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);        detachAndScrapAttachedViews(recycler);        mLayoutState.mInfinite = resolveIsInfinite();        mLayoutState.mIsPreLayout = state.isPreLayout();        <span class="hljs-comment">//是否从底部布局</span>        <span class="hljs-keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;             <span class="hljs-comment">// 向上布局</span>            updateLayoutStateToFillStart(mAnchorInfo);            mLayoutState.mExtra = extraForStart;            <span class="hljs-comment">//填充item</span>            fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);            startOffset = mLayoutState.mOffset;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> firstElement = mLayoutState.mCurrentPosition;            <span class="hljs-keyword">if</span> (mLayoutState.mAvailable &gt; <span class="hljs-number">0</span>) &#123;                extraForEnd += mLayoutState.mAvailable;            &#125;            <span class="hljs-comment">//向下布局</span>            updateLayoutStateToFillEnd(mAnchorInfo);            mLayoutState.mExtra = extraForEnd;            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;            fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);            endOffset = mLayoutState.mOffset;            <span class="hljs-keyword">if</span> (mLayoutState.mAvailable &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// end could not consume all. add more items towards start</span>                extraForStart = mLayoutState.mAvailable;                updateLayoutStateToFillStart(firstElement, startOffset);                mLayoutState.mExtra = extraForStart;                fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);                startOffset = mLayoutState.mOffset;            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;          ...                  &#125;      ...    &#125;</code></pre><p>确定布局方向后，就需要填充子View，利用<code>fill()</code>实现。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fill</span><span class="hljs-params">(RecyclerView.Recycler recycler, LayoutState layoutState,        RecyclerView.State state, <span class="hljs-keyword">boolean</span> stopOnFocusable)</span> </span>&#123;   <span class="hljs-comment">//存储当前可用空间</span>   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = layoutState.mAvailable;   ...    <span class="hljs-comment">//计算可用布局宽高</span>    <span class="hljs-keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;   <span class="hljs-comment">//迭代填充Item</span>    <span class="hljs-keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="hljs-number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;        layoutChunkResult.resetInternal();        <span class="hljs-comment">//布局item</span>        layoutChunk(recycler, state, layoutState, layoutChunkResult);        <span class="hljs-keyword">if</span> (layoutChunkResult.mFinished) &#123;            <span class="hljs-keyword">break</span>;        &#125;      layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;       <span class="hljs-comment">//子View的回收工作</span>    &#125;  ...&#125;</code></pre><p>在<code>fill()</code>中循环调用<code>layoutChunk()</code>进行布局。每次布局完成后需要计算剩余空间，之后判断是否需要继续布局Item。</p><p>向下看Item的布局方法<code>layoutChunk()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layoutChunk</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state,LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;<span class="hljs-comment">// 获取item view</span>View view = layoutState.next(recycler);<span class="hljs-comment">// 获取布局参数</span>LayoutParams params = (LayoutParams) view.getLayoutParams();<span class="hljs-keyword">if</span> (layoutState.mScrapList == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection== LayoutState.LAYOUT_START)) &#123;<span class="hljs-comment">// 增加item view</span>addView(view);&#125; <span class="hljs-keyword">else</span> &#123;addView(view, <span class="hljs-number">0</span>);&#125;&#125; <span class="hljs-comment">// 测量item</span>measureChildWithMargins(view, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">// 计算item使用的空间</span>result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);<span class="hljs-keyword">int</span> left, top, right, bottom;<span class="hljs-comment">// 竖直方向布局，计算Item坐标</span><span class="hljs-keyword">if</span> (mOrientation == VERTICAL) &#123;    <span class="hljs-comment">//设置了从右向左的布局方式</span><span class="hljs-keyword">if</span> (isLayoutRTL()) &#123;right = getWidth() - getPaddingRight();left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);&#125; <span class="hljs-keyword">else</span> &#123;left = getPaddingLeft();right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);&#125;<span class="hljs-keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;bottom = layoutState.mOffset;top = layoutState.mOffset - result.mConsumed;&#125; <span class="hljs-keyword">else</span> &#123;top = layoutState.mOffset;bottom = layoutState.mOffset + result.mConsumed;&#125;   &#125;   <span class="hljs-comment">//水平方向布局，计算Item坐标</span>  <span class="hljs-keyword">else</span> &#123;     top = getPaddingTop();     bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);     <span class="hljs-keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;          right = layoutState.mOffset;          left = layoutState.mOffset - result.mConsumed;     &#125; <span class="hljs-keyword">else</span> &#123;          left = layoutState.mOffset;          right = layoutState.mOffset + result.mConsumed;     &#125;   &#125;  <span class="hljs-comment">// item布局</span>layoutDecoratedWithMargins(view, left, top, right, bottom);  ...&#125;<span class="hljs-comment">//测量子View的布局</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChildWithMargins</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> widthUsed, <span class="hljs-keyword">int</span> heightUsed)</span> </span>&#123;            <span class="hljs-keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();            <span class="hljs-keyword">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);            widthUsed += insets.left + insets.right;            heightUsed += insets.top + insets.bottom;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),                    getPaddingLeft() + getPaddingRight()                            + lp.leftMargin + lp.rightMargin + widthUsed, lp.width,                    canScrollHorizontally());            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),                    getPaddingTop() + getPaddingBottom()                            + lp.topMargin + lp.bottomMargin + heightUsed, lp.height,                    canScrollVertically());            <span class="hljs-keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;               <span class="hljs-comment">//子View测量</span>                child.measure(widthSpec, heightSpec);            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layoutDecoratedWithMargins</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right,                <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;            <span class="hljs-keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();            <span class="hljs-keyword">final</span> Rect insets = lp.mDecorInsets;            <span class="hljs-comment">//子view布局</span>            child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,                    right - insets.right - lp.rightMargin,                    bottom - insets.bottom - lp.bottomMargin);        &#125;</code></pre><p>在<code>layoutChunk()</code>中完成了子View的<code>measure以及layout</code>过程。</p><blockquote><p>Draw过程</p></blockquote><p>Draw过程就是下文描述到的<code>ItemDecoration</code>，主要完成的就是绘制分割线的过程。</p><p><br></p><h3 id="ItemAnimator"><a href="#ItemAnimator" class="headerlink" title="ItemAnimator"></a>ItemAnimator</h3><blockquote><p>RecyclerView能够通过<code>RecyclerView.setItemAnimator(ItemAnimator animator)</code>设置添加、删除、移动、改变的动画效果。提供了默认的动画效果<code>DefaultItemAnimator</code>。</p></blockquote><pre><code class="hljs java">class CustomItemAnimator : RecyclerView.ItemAnimator()&#123;  override fun isRunning(): Boolean &#123;        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.    &#125;        override fun animatePersistence(        viewHolder: RecyclerView.ViewHolder,        preLayoutInfo: ItemHolderInfo,        postLayoutInfo: ItemHolderInfo    ): Boolean &#123;        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.    &#125;    override fun runPendingAnimations() &#123;        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.    &#125;    override fun endAnimation(item: RecyclerView.ViewHolder) &#123;        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.    &#125;    override fun animateDisappearance(        viewHolder: RecyclerView.ViewHolder,        preLayoutInfo: ItemHolderInfo,        postLayoutInfo: ItemHolderInfo?    ): Boolean &#123;        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.    &#125;    override fun animateChange(        oldHolder: RecyclerView.ViewHolder,        newHolder: RecyclerView.ViewHolder,        preLayoutInfo: ItemHolderInfo,        postLayoutInfo: ItemHolderInfo    ): Boolean &#123;        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.    &#125;    override fun animateAppearance(        viewHolder: RecyclerView.ViewHolder,        preLayoutInfo: ItemHolderInfo?,        postLayoutInfo: ItemHolderInfo    ): Boolean &#123;        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.    &#125;    override fun endAnimations() &#123;        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.    &#125;&#125;</code></pre><ul><li><code>animateAppearance()</code>：当ViewHolder出现在屏幕上时被调用(<em>可能是add或move</em>)</li><li><code>animateDisappearance()</code>：当ViewHolder消失在屏幕上时被调用(<em>可能是remove或move</em>)</li><li><code>animatePersistence()</code>：在没调用<code>notifyItemChanged()</code>和<code>notifyDataSetChanged()</code>的情况下发生布局改变时被调用</li><li><code>animateChange()</code>：在调用<code>notifyItemChanged()</code>或<code>notifyDataSetChanged()</code>的情况下发生布局改变时被调用</li><li><code>runPendingAnimations()</code>：RecyclerView的执行方式是每帧执行一次，如果在帧之间添加了多个Item，就会保存Pending动画，等到下一帧一起执行。<strong>前面定义的<code>animateXXX()</code>返回true。</strong></li><li><code>isRunning()</code>：是否有动画要执行或正在执行</li><li><code>dispatchAnimationsFinished()</code>：当全部动画执行完毕时调用</li></ul><blockquote><p>对于<code>ItemAnimator</code>，最常见的是<em>闪屏问题</em> ——当Item中存在图片和文字时，刷新RecyclerView时会出现闪烁问题。</p><p>出现原因是由于调用<code>notifyDataSetChanged()</code>，会调用到<code>DefaultAnimator.animateChangeImpl()</code>执行change动画，导致透明度发生0-1的变化，发生闪烁。</p><p>解决方法：在<code>setAdapter()</code>之前调用<code>((SimpleItemAnimator)rv.getItemAnimator()).setSupportsChangeAnimations(false)</code>禁用change动画。</p></blockquote><p><br></p><h3 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h3><blockquote><p>RecyclerView通过<code>addItemDecoration()</code>添加Item之间的分割线。</p></blockquote><p>如果我们要自己实现一个分割线效果，需要自己创建一个类并继承<code>RecyclerView.ItemDecoration</code>，重写一下两个方法：</p><ul><li><code>onDraw()</code>：绘制分割线</li><li><code>getItemOffsets()</code>：设置分割线的宽高</li></ul><pre><code class="hljs java">class CustomDecoration : RecyclerView.ItemDecoration() &#123;    override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State) &#123;        //调用在Item绘制完毕前，绘制分割线    &#125;    override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) &#123;        //定义分割线的宽/高，在不同的显示模式下    &#125;    override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) &#123;       //调用在Item绘制完毕后，绘制分割线    &#125;&#125;</code></pre><p>接下来分析RecyclerView是如何调用到分割线？</p><p>回顾View的绘制流程是<em>measure-&gt;layout-&gt;draw</em>，我们开始分析分割线的调用流程。</p><p>由于RecyclerView继承自<code>ViewGroup</code>，分割线是作为Item之间的间隔使用，那就要从<code>measureChild()</code>开始查看</p><pre><code class="hljs java">       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChild</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> widthUsed, <span class="hljs-keyword">int</span> heightUsed)</span> </span>&#123;           <span class="hljs-keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();           <span class="hljs-comment">//获取设置的分割线</span>           <span class="hljs-keyword">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);           widthUsed += insets.left + insets.right;           heightUsed += insets.top + insets.bottom;           <span class="hljs-comment">//都需要在原基础上 加上分割线的宽/高</span>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),                   getPaddingLeft() + getPaddingRight() + widthUsed, lp.width,                   canScrollHorizontally());           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),                   getPaddingTop() + getPaddingBottom() + heightUsed, lp.height,                   canScrollVertically());            <span class="hljs-keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;               child.measure(widthSpec, heightSpec);           &#125;       &#125;<span class="hljs-function">Rect <span class="hljs-title">getItemDecorInsetsForChild</span><span class="hljs-params">(View child)</span> </span>&#123;       ...           <span class="hljs-comment">//调用到设置的 getItemOffsets()</span>           mItemDecorations.get(i).getItemOffsets(mTempRect, child, <span class="hljs-keyword">this</span>, mState);       ...   &#125;</code></pre><p>在<code>measureChild()</code>找到了引用分割线并设置宽高的地方，接下啦需要找到引用绘制(<code>onDraw</code>)的地方</p><pre><code class="hljs java">    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas c)</span> </span>&#123;        <span class="hljs-comment">//调用到父类的 onDraw 即 View.onDraw</span>        <span class="hljs-keyword">super</span>.onDraw(c);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mItemDecorations.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;            mItemDecorations.get(i).onDraw(c, <span class="hljs-keyword">this</span>, mState);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas c)</span> </span>&#123;        <span class="hljs-comment">//调用到父类的 draw() 即  View.draw()</span>        <span class="hljs-keyword">super</span>.draw(c);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mItemDecorations.size();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;            mItemDecorations.get(i).onDrawOver(c, <span class="hljs-keyword">this</span>, mState);        &#125;      ...    &#125;<span class="hljs-comment">// View.java</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;  ...    <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);  ... &#125;</code></pre><p>上面找到了两个引用了<code>ItemDecoration</code>的绘制方法。这里回顾一下<code>ViewGroup</code>的Draw流程，先调用自身的<code>draw()</code>，然后<code>drawBackground()</code>，向下到<code>onDraw()</code>，绘制子View<code>disaptchDraw()</code>。</p><p>根据Draw流程分析，先调用到<code>RecyclerView.draw()</code>，发现调用到了<code>super.draw()</code>即指向了<code>View.draw()</code>这时View调用到自身的<code>onDraw()</code>，而RecyclerView重写了该方法，就调用到了<code>ItemDecoration.onDraw()</code>，然后走向<code>dispatchDraw()</code>绘制子View。绘制完毕后，最后调用到了<code>ItemDecoration.onDrawOver()</code>。</p><p>综上所述：<strong><code>onDraw()</code>调用在子View绘制前，<code>onDrawOver()</code>在绘制之后执行</strong>。</p><p><br></p><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><blockquote><p>RecyclerView是以<code>RecyclerView.ViewHolder</code>作为单位进行回收。Recycler是RecyclerView回收机制的实现类。</p></blockquote><p>Recycler实现的是<strong>四级缓存</strong>：</p><ul><li><code>mAttachedScrap</code>：缓存已在屏幕上的ViewHolder。   <em>一级缓存</em></li><li><code>mCacheViews</code>：缓存屏幕外的ViewHolder，默认为2个。  <em>一级缓存</em></li><li><code>mViewCacheExtension</code>：需要用户定制，默认不实现。  <em>二级缓存</em></li><li><code>mRecyclerPool</code>：缓存池，<code>mCacheViews</code>集合中装满时，会放到这里。技术上可以实现所有<code>RecyclerViewPool</code>共用。默认为5个。 <em>三级缓存</em></li><li><code>createViewHolder</code>：创建ViewHolder。<em>‌四级缓存</em></li></ul><p>缓存机制主要分为两段流程：<strong>复用机制和回收机制。</strong></p><h4 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h4><blockquote><p> 从<code>Recycler</code>获取一个<code>ViewHolder</code></p></blockquote><p><code>LayoutManager</code>通过调用<code>Recycler.getViewForPosition(pos)</code>获取<code>pos</code>位置上的<code>view</code>。</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getViewForPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;        <span class="hljs-keyword">return</span> getViewForPosition(position, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-function">View <span class="hljs-title">getViewForPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">boolean</span> dryRun)</span> </span>&#123;        <span class="hljs-keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;    &#125;    <span class="hljs-comment">//复用机制的主要方实现</span><span class="hljs-function">ViewHolder <span class="hljs-title">tryGetViewHolderForPositionByDeadline</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position,            <span class="hljs-keyword">boolean</span> dryRun, <span class="hljs-keyword">long</span> deadlineNs)</span> </span>&#123;        <span class="hljs-comment">//判断位置是否正常</span>        <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || position &gt;= mState.getItemCount()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Invalid item position "</span> + position                    + <span class="hljs-string">"("</span> + position + <span class="hljs-string">"). Item count:"</span> + mState.getItemCount());        &#125;        <span class="hljs-keyword">boolean</span> fromScrapOrHiddenOrCache = <span class="hljs-keyword">false</span>;        ViewHolder holder = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 是否设置动画</span>        <span class="hljs-keyword">if</span> (mState.isPreLayout()) &#123;            holder = getChangedScrapViewForPosition(position);            fromScrapOrHiddenOrCache = holder != <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//从 mAttcherScrap 或者 mCachedViews 获取holder</span>            holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);①            <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//判定ViewHolder是否有效</span>                <span class="hljs-keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;②                    <span class="hljs-comment">// recycle holder (and unscrap if relevant) since it can't be used</span>                    <span class="hljs-keyword">if</span> (!dryRun) &#123;                        <span class="hljs-comment">//设置回收标记</span>                        holder.addFlags(ViewHolder.FLAG_INVALID);                        <span class="hljs-keyword">if</span> (holder.isScrap()) &#123;                            removeDetachedView(holder.itemView, <span class="hljs-keyword">false</span>);                            holder.unScrap();                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.wasReturnedFromScrap()) &#123;                            holder.clearReturnedFromScrapFlag();                        &#125;                        recycleViewHolderInternal(holder);                    &#125;                    holder = <span class="hljs-keyword">null</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    fromScrapOrHiddenOrCache = <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;                <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);            <span class="hljs-keyword">if</span> (offsetPosition &lt; <span class="hljs-number">0</span> || offsetPosition &gt;= mAdapter.getItemCount()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Inconsistency detected. Invalid item "</span>                        + <span class="hljs-string">"position "</span> + position + <span class="hljs-string">"(offset:"</span> + offsetPosition + <span class="hljs-string">")."</span>                        + <span class="hljs-string">"state:"</span> + mState.getItemCount());            &#125;            <span class="hljs-comment">//获取item设置的type</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);            <span class="hljs-comment">// stable id 就是标识一个viewholder的唯一性</span>            <span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;                holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),③                        type, dryRun);                <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">// update position</span>                    holder.mPosition = offsetPosition;                    fromScrapOrHiddenOrCache = <span class="hljs-keyword">true</span>;                &#125;            &#125;            <span class="hljs-comment">//从用户自己设置的 mViewCacheExtension 去寻找对应ViewHolder·</span>            <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// We are NOT sending the offsetPosition because LayoutManager does not</span>                <span class="hljs-comment">// know it.</span>                <span class="hljs-keyword">final</span> View view = mViewCacheExtension                        .getViewForPositionAndType(<span class="hljs-keyword">this</span>, position, type);                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">//包装成一个ViewHolder</span>                    holder = getChildViewHolder(view);                    <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"getViewForPositionAndType returned"</span>                                + <span class="hljs-string">" a view which does not have a ViewHolder"</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.shouldIgnore()) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"getViewForPositionAndType returned"</span>                                + <span class="hljs-string">" a view that is ignored. You must call stopIgnoring before"</span>                                + <span class="hljs-string">" returning this view."</span>);                    &#125;                &#125;            &#125;            <span class="hljs-comment">//从 RecyclerViewPool去寻找对应的ViewHolder</span>            <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// fallback to pool</span>                <span class="hljs-keyword">if</span> (DEBUG) &#123;                    Log.d(TAG, <span class="hljs-string">"tryGetViewHolderForPositionByDeadline("</span>                            + position + <span class="hljs-string">") fetching from shared pool"</span>);                &#125;                holder = getRecycledViewPool().getRecycledView(type);④                <span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) &#123;                    holder.resetInternal();⑤                    <span class="hljs-keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;                        invalidateDisplayListInt(holder);                    &#125;                &#125;            &#125;            <span class="hljs-comment">//从以上三级缓存中都没有找到对应的ViewHolder就只能自己创建了</span>            <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">long</span> start = getNanoTime();                <span class="hljs-keyword">if</span> (deadlineNs != FOREVER_NS                        &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;                    <span class="hljs-comment">// abort - we have a deadline we can't meet</span>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                &#125;                <span class="hljs-comment">//创建对应的ViewHolder</span>                holder = mAdapter.createViewHolder(RecyclerView.<span class="hljs-keyword">this</span>, type);                <span class="hljs-keyword">if</span> (ALLOW_THREAD_GAP_WORK) &#123;                    <span class="hljs-comment">// only bother finding nested RV if prefetching</span>                    RecyclerView innerView = findNestedRecyclerView(holder.itemView);                    <span class="hljs-keyword">if</span> (innerView != <span class="hljs-keyword">null</span>) &#123;                        holder.mNestedRecyclerView = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(innerView);                    &#125;                &#125;                <span class="hljs-keyword">long</span> end = getNanoTime();                mRecyclerPool.factorInCreateTime(type, end - start);                <span class="hljs-keyword">if</span> (DEBUG) &#123;                    Log.d(TAG, <span class="hljs-string">"tryGetViewHolderForPositionByDeadline created new ViewHolder"</span>);                &#125;            &#125;        &#125;        <span class="hljs-comment">// This is very ugly but the only place we can grab this information</span>        <span class="hljs-comment">// before the View is rebound and returned to the LayoutManager for post layout ops.</span>        <span class="hljs-comment">// We don't need this in pre-layout since the VH is not updated by the LM.</span>        <span class="hljs-keyword">if</span> (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder                .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) &#123;            holder.setFlags(<span class="hljs-number">0</span>, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);            <span class="hljs-keyword">if</span> (mState.mRunSimpleAnimations) &#123;                <span class="hljs-keyword">int</span> changeFlags = ItemAnimator                        .buildAdapterChangeFlagsForAnimations(holder);                changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;                <span class="hljs-keyword">final</span> ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState,                        holder, changeFlags, holder.getUnmodifiedPayloads());                recordAnimationInfoIfBouncedHiddenView(holder, info);            &#125;        &#125;        <span class="hljs-keyword">boolean</span> bound = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;            <span class="hljs-comment">// do not update unless we absolutely have to.</span>            holder.mPreLayoutPosition = position;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;            <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; holder.isRemoved()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Removed holder should be bound and it should"</span>                        + <span class="hljs-string">" come here only in pre-layout. Holder: "</span> + holder);            &#125;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);            bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);        &#125;        <span class="hljs-comment">//设置对应ViewHolder的 layoutparams</span>        <span class="hljs-keyword">final</span> ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();        <span class="hljs-keyword">final</span> LayoutParams rvLayoutParams;        <span class="hljs-keyword">if</span> (lp == <span class="hljs-keyword">null</span>) &#123;            rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();            holder.itemView.setLayoutParams(rvLayoutParams);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!checkLayoutParams(lp)) &#123;            rvLayoutParams = (LayoutParams) generateLayoutParams(lp);            holder.itemView.setLayoutParams(rvLayoutParams);        &#125; <span class="hljs-keyword">else</span> &#123;            rvLayoutParams = (LayoutParams) lp;        &#125;        rvLayoutParams.mViewHolder = holder;        rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound;        <span class="hljs-keyword">return</span> holder;    &#125;</code></pre><p>①<code>getScrapOrHiddenOrCachedHolderForPosition()</code>：从<code>mAttchedScrap</code>或者<code>mCachedViews</code>去获取ViewHolder</p><pre><code class="hljs java"><span class="hljs-function">ViewHolder <span class="hljs-title">getScrapOrHiddenOrCachedHolderForPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">boolean</span> dryRun)</span> </span>&#123;    <span class="hljs-comment">//先从 mAttachedScrap 获取对应的ViewHolder</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; scrapCount; i++) &#123;               <span class="hljs-keyword">final</span> ViewHolder holder = mAttachedScrap.get(i);               <span class="hljs-keyword">if</span> (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position                       &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) &#123;                   holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);                   <span class="hljs-keyword">return</span> holder;               &#125;           &#125;   <span class="hljs-comment">//从隐藏的View中去寻找ViewHolder</span>   <span class="hljs-keyword">if</span> (!dryRun) &#123;               View view = mChildHelper.findHiddenNonRemovedView(position);               <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;                   <span class="hljs-comment">// This View is good to be used. We just need to unhide, detach and move to the</span>                   <span class="hljs-comment">// scrap list.</span>                   <span class="hljs-keyword">final</span> ViewHolder vh = getChildViewHolderInt(view);                   mChildHelper.unhide(view);                   <span class="hljs-keyword">int</span> layoutIndex = mChildHelper.indexOfChild(view);                   <span class="hljs-keyword">if</span> (layoutIndex == RecyclerView.NO_POSITION) &#123;                       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"layout index should not be -1 after "</span>                               + <span class="hljs-string">"unhiding a view:"</span> + vh);                   &#125;                   mChildHelper.detachViewFromParent(layoutIndex);                   scrapView(view);                   vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP                           | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);                   <span class="hljs-keyword">return</span> vh;               &#125;           &#125;    <span class="hljs-comment">//从mCachedViews去获取对应的ViewHolder</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cacheSize = mCachedViews.size();           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cacheSize; i++) &#123;               <span class="hljs-keyword">final</span> ViewHolder holder = mCachedViews.get(i);               <span class="hljs-comment">// invalid view holders may be in cache if adapter has stable ids as they can be</span>               <span class="hljs-comment">// retrieved via getScrapOrCachedViewForId</span>               <span class="hljs-keyword">if</span> (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) &#123;                   <span class="hljs-keyword">if</span> (!dryRun) &#123;                       mCachedViews.remove(i);                   &#125;                   <span class="hljs-keyword">if</span> (DEBUG) &#123;                       Log.d(TAG, <span class="hljs-string">"getScrapOrHiddenOrCachedHolderForPosition("</span> + position                               + <span class="hljs-string">") found match in cache: "</span> + holder);                   &#125;                   <span class="hljs-keyword">return</span> holder;               &#125;           &#125;&#125;</code></pre><p>根据<code>position</code>从<code>mAttachedScrap -&gt; hideView -&gt; mCachedViews</code>的顺序向下获取。</p><p><strong>mCachedViews里面存放的都是已存在的ViewHolder，新位置的是没法获取的。</strong></p><p>②<code>validateViewHolderForOffsetPosition(holder)</code>：校验获取的ViewHolder是否有效</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">validateViewHolderForOffsetPosition</span><span class="hljs-params">(ViewHolder holder)</span> </span>&#123;    <span class="hljs-comment">// if it is a removed holder, nothing to verify since we cannot ask adapter anymore</span>    <span class="hljs-comment">// if it is not removed, verify the type and id.</span>    <span class="hljs-keyword">if</span> (holder.isRemoved()) &#123;        <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; !mState.isPreLayout()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"should not receive a removed view unless it"</span>                    + <span class="hljs-string">" is pre layout"</span>);        &#125;        <span class="hljs-keyword">return</span> mState.isPreLayout();    &#125;    <span class="hljs-keyword">if</span> (holder.mPosition &lt; <span class="hljs-number">0</span> || holder.mPosition &gt;= mAdapter.getItemCount()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Inconsistency detected. Invalid view holder "</span>                + <span class="hljs-string">"adapter position"</span> + holder);    &#125;    <span class="hljs-keyword">if</span> (!mState.isPreLayout()) &#123;        <span class="hljs-comment">// don't check type if it is pre-layout.</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> type = mAdapter.getItemViewType(holder.mPosition);        <span class="hljs-keyword">if</span> (type != holder.getItemViewType()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;        <span class="hljs-keyword">return</span> holder.getItemId() == mAdapter.getItemId(holder.mPosition);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p>判断获取的ViewHolder存在和位置是否正确。</p><p>③<code>getScrapOrCachedViewForId()</code>：根据<code>position</code>获取对应的<code>itemId</code>然后获取ViewHolder</p><pre><code class="hljs java"><span class="hljs-function">ViewHolder <span class="hljs-title">getScrapOrCachedViewForId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">boolean</span> dryRun)</span> </span>&#123;            <span class="hljs-comment">// Look in our attached views first</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mAttachedScrap.size();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;                <span class="hljs-keyword">final</span> ViewHolder holder = mAttachedScrap.get(i);                <span class="hljs-keyword">if</span> (holder.getItemId() == id &amp;&amp; !holder.wasReturnedFromScrap()) &#123;                    <span class="hljs-keyword">if</span> (type == holder.getItemViewType()) &#123;                        holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);                        <span class="hljs-keyword">if</span> (holder.isRemoved()) &#123;                            <span class="hljs-keyword">if</span> (!mState.isPreLayout()) &#123;                                holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE                                        | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED);                            &#125;                        &#125;                        <span class="hljs-keyword">return</span> holder;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!dryRun) &#123;                        mAttachedScrap.remove(i);                        removeDetachedView(holder.itemView, <span class="hljs-keyword">false</span>);                        quickRecycleScrapView(holder.itemView);                    &#125;                &#125;            &#125;</code></pre><p>利用转化的<code>itemId</code>从<code>mAttachedScrap</code>获取对应的ViewHolder</p><p>④<code>getRecycledViewPool().getRecycledView()</code>：从<code>mRecyclerViewPool</code>去获取对应的ViewHolder</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ViewHolder <span class="hljs-title">getRecycledView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> viewType)</span> </span>&#123;    <span class="hljs-keyword">final</span> ScrapData scrapData = mScrap.get(viewType);    <span class="hljs-keyword">if</span> (scrapData != <span class="hljs-keyword">null</span> &amp;&amp; !scrapData.mScrapHeap.isEmpty()) &#123;        <span class="hljs-keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;        <span class="hljs-keyword">return</span> scrapHeap.remove(scrapHeap.size() - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>存储时会根据不同的<code>itemType</code>进行存储，然后取对应ViewHolder时，就不像前面获取ViewHodler需要通过<code>position或itemId</code>完整的匹配，只要找到对应<code>ViewType</code>并有值，直接取出最后一个ViewHolder缓存进行复用即可。</p><p>⑤<code>holder.resetInternal()</code>：对从<code>mRecyclerViewPool</code>取出的ViewHolder重新进行设置，变成一个全新的ViewHolder</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resetInternal</span><span class="hljs-params">()</span> </span>&#123;    mFlags = <span class="hljs-number">0</span>;    mPosition = NO_POSITION;    mOldPosition = NO_POSITION;    mItemId = NO_ID;    mPreLayoutPosition = NO_POSITION;    mIsRecyclableCount = <span class="hljs-number">0</span>;    mShadowedHolder = <span class="hljs-keyword">null</span>;    mShadowingHolder = <span class="hljs-keyword">null</span>;    clearPayload();    mWasImportantForAccessibilityBeforeHidden = View.IMPORTANT_FOR_ACCESSIBILITY_AUTO;    mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET;    clearNestedRecyclerViewIfNotNested(<span class="hljs-keyword">this</span>);&#125;</code></pre><p>由于取出的ViewHolder进行了重新设置，所以后续就需要调用<code>bindViewHolder()</code>重新进行数据绑定</p><p>观察上述源码可知，复用机制简单分为以下几步：</p><ul><li>从<code>mAttachedScrap</code>或<code>mCachedViews</code>(<em>一级缓存</em>)去获取可复用的ViewHolder</li><li>如果没有找到可复用的ViewHolder，就会从<code>mViewacheExtension</code>(<em>二级缓存</em>)去获取可复用的ViewHolder。<code>如果用户没有定义就跳过这一级。</code></li><li>用户未定义货没有找到可复用的ViewHolder，就会从<code>mRecyclerPool</code>(<em>三级缓存</em>)去获取可复用的ViewHolder。<strong>这时需要调用<code>onBindViewHolder()</code></strong></li><li>从上面三步中都没有获取到，就只能自己调用<code>createViewHolder</code>(<em>四级缓存</em>)去重新创建一个ViewHolder以供使用，然后在调用<code>bindViewHolder()</code>绑定数据。最后调整<code>ViewHolder。itemView</code>的布局参数。</li><li>返回最终得到的ViewHolder。</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView复用机制.png" srcset="/img/loading.gif" class="full-image" alt="RecyclerView复用机制" title="RecyclerView复用机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h4><blockquote><p>由<code>Recycler</code>进行View的回收</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycleView</span><span class="hljs-params">(View view)</span> </span>&#123;    <span class="hljs-comment">//传入对应的View 然后通过View获取ViewHolder</span>    ViewHolder holder = getChildViewHolderInt(view);    <span class="hljs-comment">//标记该View要移除</span>    <span class="hljs-keyword">if</span> (holder.isTmpDetached()) &#123;        removeDetachedView(view, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">//该ViewHolder来自缓存可见的数组</span>    <span class="hljs-keyword">if</span> (holder.isScrap()) &#123;        <span class="hljs-comment">//清除缓存</span>        holder.unScrap();    &#125; <span class="hljs-comment">//holder来自缓存的不可见ViewHolder</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holder.wasReturnedFromScrap()) &#123;        <span class="hljs-comment">//清除缓存</span>        holder.clearReturnedFromScrapFlag();    &#125;    <span class="hljs-comment">//开始回收流程</span>    recycleViewHolderInternal(holder);&#125;</code></pre><p>回收流程的真正执行逻辑是在<code>recyclerViewHolderInternal()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recycleViewHolderInternal</span><span class="hljs-params">(ViewHolder holder)</span> </span>&#123;    ...    <span class="hljs-comment">//noinspection unchecked</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> transientStatePreventsRecycling = holder            .doesTransientStatePreventRecycling();    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> forceRecycle = mAdapter != <span class="hljs-keyword">null</span>            &amp;&amp; transientStatePreventsRecycling            &amp;&amp; mAdapter.onFailedToRecycleView(holder);    <span class="hljs-keyword">boolean</span> cached = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">boolean</span> recycled = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (DEBUG &amp;&amp; mCachedViews.contains(holder)) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"cached view received recycle internal? "</span>                + holder);    &#125;    <span class="hljs-keyword">if</span> (forceRecycle || holder.isRecyclable()) &#123;        <span class="hljs-comment">//要求缓存数量&gt;0，并且ViewHolder的标志是有效的额，且非REMOVED或UPDATE，进行缓存</span>        <span class="hljs-keyword">if</span> (mViewCacheMax &gt; <span class="hljs-number">0</span> <span class="hljs-comment">/*大小默认为2*/</span>                &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID                        | ViewHolder.FLAG_REMOVED                        | ViewHolder.FLAG_UPDATE                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;            <span class="hljs-comment">// Retire oldest cached view</span>            <span class="hljs-keyword">int</span> cachedViewSize = mCachedViews.size();            <span class="hljs-comment">//mCacheViews已经满了，就把最前面缓存的ViewHolder放到RecyclerViewPool中</span>            <span class="hljs-keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//移除 mCachedViews的第一条缓存数据</span>                recycleCachedViewAt(<span class="hljs-number">0</span>);①                cachedViewSize--;            &#125;            <span class="hljs-keyword">int</span> targetCacheIndex = cachedViewSize;            <span class="hljs-keyword">if</span> (ALLOW_THREAD_GAP_WORK                    &amp;&amp; cachedViewSize &gt; <span class="hljs-number">0</span>                    &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123;                <span class="hljs-comment">// when adding the view, skip past most recently prefetched views</span>                <span class="hljs-keyword">int</span> cacheIndex = cachedViewSize - <span class="hljs-number">1</span>;                <span class="hljs-keyword">while</span> (cacheIndex &gt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">int</span> cachedPos = mCachedViews.get(cacheIndex).mPosition;                    <span class="hljs-comment">//缓存的时候不能覆盖最近经常使用的缓存 利用LFU算法 -- 最少使用策略</span>                    <span class="hljs-keyword">if</span> (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                    cacheIndex--;                &#125;                targetCacheIndex = cacheIndex + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-comment">//将最新的ViewHolder缓存数据插入到mCacheViews中复用</span>            mCachedViews.add(targetCacheIndex, holder);            cached = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">//如果没有触发缓存的话 就放进RecyclerViewPool中</span>        <span class="hljs-keyword">if</span> (!cached) &#123;            addViewHolderToRecycledViewPool(holder, <span class="hljs-keyword">true</span>);            recycled = <span class="hljs-keyword">true</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> A view can fail to be recycled when it is scrolled off while an animation</span>        <span class="hljs-comment">// runs. In this case, the item is eventually recycled by</span>        <span class="hljs-comment">// ItemAnimatorRestoreListener#onAnimationFinished.</span>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> consider cancelling an animation when an item is removed scrollBy,</span>        <span class="hljs-comment">// to return it to the pool faster</span>        <span class="hljs-keyword">if</span> (DEBUG) &#123;            Log.d(TAG, <span class="hljs-string">"trying to recycle a non-recycleable holder. Hopefully, it will "</span>                    + <span class="hljs-string">"re-visit here. We are still removing it from animation lists"</span>);        &#125;    &#125;    <span class="hljs-comment">// even if the holder is not removed, we still call this method so that it is removed</span>    <span class="hljs-comment">// from view holder lists.</span>    mViewInfoStore.removeViewHolder(holder);    <span class="hljs-keyword">if</span> (!cached &amp;&amp; !recycled &amp;&amp; transientStatePreventsRecycling) &#123;        holder.mOwnerRecyclerView = <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p>①<code>recycleCachedViewAt(0)</code>：移除<code>mCachedViews</code>中的第一条数据并放入到<code>mRecyclerViewPool</code>中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recycleCachedViewAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cachedViewIndex)</span> </span>&#123;    ViewHolder viewHolder = mCachedViews.get(cachedViewIndex);    addViewHolderToRecycledViewPool(viewHolder, <span class="hljs-keyword">true</span>);    mCachedViews.remove(cachedViewIndex);&#125;</code></pre><p><code>mRecyclerPool</code>是根据<code>itemType</code>进行缓存的，最大上限为5。</p><p>观察上述源码可知，回收机制步骤如下：<strong>回收机制是发生在 RecyclerView滚动时进行的。</strong></p><ul><li>在RecyclerView滑动时，会调用到<code>LayoutManager.scrollVerticalBy()</code>去处理，在<code>LayoutManager.fill()</code>中会去完成<code>复用以及回收ViewHolder</code>的功能，最终调用到<code>recyclerView()</code>开始回收工作</li><li>回收时，先判断<code>mCachedViews</code>是否已满，未满直接放入。如果<code>mCachedViews</code>已满，则取出第一个缓存的ViewHolder放入<code>RecyclerViewPool</code>中，然后放入新的ViewHolder进行缓存</li><li>如果因为<code>ViewHolder</code>设置了<code>REMOVED或UPDATED</code>标志，无法加入<code>mCacheViews</code>中，就直接放入到<code>mRecyclerPool</code>中。</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/RecyclerView回收机制.png" srcset="/img/loading.gif" class="full-image" alt="RecyclerView回收机制" title="RecyclerView回收机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>1.RecyclerView的操作场景主要有三种：</p><ul><li><p><em>有无到有</em>：RecyclerView中没有任何数据，然后调用<code>setAdapter()</code>添加数据源后。RecyclerView添加了数据并显示。</p><blockquote><p><code>Recycler</code>在这时只是调用到<code>createViewHolder()</code>不会发生缓存事件。</p></blockquote></li><li><p><em>在原有数据的情况下刷新</em>：做了下拉刷新操作，只对屏幕上可见的数据源进行替换。</p><blockquote><p>这时ViewHolder会被标记<code>FLAG_TMP_DETACHED</code>，然后这时的Viewolder就会被保存到<code>mAttachedScrap</code>中等待复用。</p></blockquote></li><li><p><em>RecyclerView发生滑动</em>：RecyclerView发生了上下或者左右滑动操作。</p></li></ul><p>2.RecyclerView滑动场景下的回收复用涉及到的结构有以下两个：<code>mCachedViews</code>和<code>mRecyclerPool</code></p><p>  <code>mCachedViews</code>的优先级高于<code>mRecyclerPool</code>，回收时最新的ViewHolder先放入到<code>mCachedViews</code>中，没位置了就移除最旧的那个给新的腾地方，最旧的就放到<code>mRecyclerPool</code>中。</p><p>  复用时也是一样，先从<code>mCachedViews</code>去获取对应的ViewHolder，需要匹配<code>position</code>，就是需要位置对应才能进行复用。找不到就去<code>mRecyclerPool</code>中找，在<code>mRecyclerPool</code>中的ViewHolder都跟新的一样，需要重新绑定数据(<em>bindViewHolder()</em>)。还没有就要自己创建了(<em>createViewHolder()</em>)。</p><p>3.<code>mCachedViews</code>上限是2</p><h2 id="RecyclerView优化"><a href="#RecyclerView优化" class="headerlink" title="RecyclerView优化"></a>RecyclerView优化</h2><ul><li><p><strong>数据处理与视图绑定分离</strong></p><blockquote><p><code>bindViewHolder()</code>是在主线程中进行的，如果里面发生了耗时操作，会影响滑动的流畅性。</p><p><strong><code>onBindViewHolder()</code>中应该只进行数据的<code>set</code>操作，不需要做其他判断。</strong></p></blockquote></li><li><p><strong>数据优化</strong></p><blockquote><ol><li>分页加载远端数据，对拉取的数据进行缓存，提高二次加载的速度</li><li>对于新增或删除数据通过<code>DiffUtil</code>，来进行局部数据刷新，而不是每次都去进行全量刷新。</li></ol></blockquote></li><li><p><strong>布局优化</strong></p><blockquote><ol><li><code>减少过度绘制</code>：减少布局层级，可以考虑使用自定义View来减少层级，或者设置更合理的布局。</li><li><code>减少xml文件</code>：<code>inflate</code>时间：去解析xml都需要经过耗时的IO操作，可以利用代码直接生成对应的布局，利用<code>new View()</code>生成。</li><li><code>减少View对象的创建</code>：需要尽可能简化ItemView，对多ViewType能够共用的部分尽量设计成自定义View，减少View的构造和嵌套。</li></ol></blockquote></li><li><p><strong>其他优化</strong></p><blockquote><ol><li><p>设置高度固定：如果Item高度固定的话，可以使用<code>RecyclerView.setHasFixedSize(true)</code>，避免调用<code>requestLayout()</code></p></li><li><p>共用<code>RecycledViewPool</code>：具有相关的Adapter，就可以调用<code>RecyclerView.setRecycledViewPool(pool)</code>共用同一个。</p></li><li><p>加大RecyclerView的缓存：空间换时间</p><pre><code class="hljs java">&gt;    recyclerView.setItemViewCacheSize(<span class="hljs-number">20</span>);&gt;    recyclerView.setDrawingCacheEnabled(<span class="hljs-keyword">true</span>);&gt;    recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);&gt;</code></pre></li></ol></blockquote><blockquote><ol start="4"><li><p>增加RecyclerView预留的额外空间：显示范围之外，增加额外的缓存空间。<em>默认为2。</em></p><pre><code class="hljs java">&gt;    <span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>) &#123;&gt;        <span class="hljs-meta">@Override</span>&gt;        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getExtraLayoutSpace</span><span class="hljs-params">(RecyclerView.State state)</span> </span>&#123;&gt;            <span class="hljs-keyword">return</span> size;&gt;        &#125;&gt;    &#125;;&gt;</code></pre></li></ol></blockquote><blockquote><ol start="5"><li><p>减少ItemView监听器的创建</p><blockquote><p>不要对每个Item都去创建一个监听器，而是根据<code>android:id</code>设置不同的操作，共用一个监听器。</p></blockquote></li><li><p>优化滑动操作：设置<code>RecyclerView.addOnScrollListener()</code>在滑动过程中停止加载</p></li><li><p>关闭默认动画效果：设置<code>((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false)</code></p></li></ol></blockquote></li></ul><h2 id="RecyclerView拓展"><a href="#RecyclerView拓展" class="headerlink" title="RecyclerView拓展"></a>RecyclerView拓展</h2><p>是否需要将ListView替换成RecyclerView?</p><blockquote><p>从性能上看，RecyclerView并没有带来明显的提升。如果需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView。只是单纯用于展示数据的话，ListView实现更加简单。</p></blockquote><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://www.cnblogs.com/dasusu/p/7746946.html" target="_blank" rel="noopener">基于场景解析RecyclerView的回收复用机制原理</a></p><p><a href="https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA?" target="_blank" rel="noopener">RecyclerView必知必会</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android性能优化</title>
    <link href="/2018/12/20/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2018/12/20/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<!--简要解释一下 ANR？为什么会发生 ANR？如何避免发生 ANR？如何定位 ANR？ANR发生条件？如何分析ANR--><!--bitmap高效加载，三级缓存等。--><!--android性能优化：布局优化、绘制优化、内存泄露优化、bitmap、内存泄露等。--><!--内存泄露的概念？android中发生的场景？怎么解决？讲了handler、动画等。--><!--Android性能优化工具使用（这个问题建议配合Android中的性能优化）--><!--App启动优化，如何检测启动耗时 --><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Android性能优化.png" srcset="/img/loading.gif" class="full-image" alt="Android性能优化" title="Android性能优化"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>针对Android中的性能优化，主要有以下几个有效的优化方法：</p><blockquote><p><strong>布局优化、绘制优化、内存泄漏优化、响应速度优化、ListView/RecyclerView及Bitmap优化、线程优化、其他</strong></p></blockquote><h2 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h2><blockquote><p>核心思想就是：<strong>减少布局文件的层级。</strong></p></blockquote><h3 id="删除布局中无用的控件和层次，其次有选择的使用性能比较低的ViewGroup。"><a href="#删除布局中无用的控件和层次，其次有选择的使用性能比较低的ViewGroup。" class="headerlink" title="删除布局中无用的控件和层次，其次有选择的使用性能比较低的ViewGroup。"></a>删除布局中无用的控件和层次，其次有选择的使用性能比较低的ViewGroup。</h3><p>可以使用RelativeLayout来减少嵌套，从而达到减少层级的目的。<em>如果层级相同的情况，可以使用LinearLayout相比更高效。</em></p><blockquote><p>如果LinearLayout需要实现<code>android:weight</code>那么就需要绘制两次，还是用RelativeLayout好。</p></blockquote><p><br></p><h3 id="采用-lt-include-gt-、-lt-merge-gt-、ViewStub，Space优化布局"><a href="#采用-lt-include-gt-、-lt-merge-gt-、ViewStub，Space优化布局" class="headerlink" title="采用&lt;include&gt;、&lt;merge&gt;、ViewStub，Space优化布局"></a>采用<code>&lt;include&gt;、&lt;merge&gt;、ViewStub，Space</code>优化布局</h3><p><code>&lt;include&gt;</code>：主要用于布局复用</p><p><code>&lt;merge&gt;</code>：一般和<code>&lt;include&gt;</code>配合使用，可以减少布局的层级</p><p><code>ViewStub</code>：提供了按需加载的功能，提供初始化效率。</p><p><code>Space</code>：主要用于进行空白占位，本身<code>onDraw()</code>不实现。</p><a href="/2019/01/03/include、merge-ViewStub相关/" title="include、merge及ViewStub相关">include、merge及ViewStub相关</a><h4 id="尽可能少用wrap-content"><a href="#尽可能少用wrap-content" class="headerlink" title="尽可能少用wrap_content"></a>尽可能少用<code>wrap_content</code></h4><p>会增加布局测量时的计算成本，应尽可能少用。</p><p><br></p><h3 id="布局优化工具"><a href="#布局优化工具" class="headerlink" title="布局优化工具"></a>布局优化工具</h3><h4 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h4><blockquote><p>Android SDK自带的可视化调试工具，用来检查布局嵌套和绘制的时间。</p></blockquote><h4 id="Android-Lint"><a href="#Android-Lint" class="headerlink" title="Android Lint"></a>Android Lint</h4><blockquote><p>可以利用其中的 XML布局检查 ，是否出现布局层级问题。</p></blockquote><h2 id="绘制优化"><a href="#绘制优化" class="headerlink" title="绘制优化"></a>绘制优化</h2><blockquote><p>核心思想是：</p><ul><li><strong>避免在<code>View.onDraw()</code>执行大量操作。</strong></li><li><strong>避免过度绘制</strong></li></ul></blockquote><h3 id="onDraw-中不要创建新的局部对象"><a href="#onDraw-中不要创建新的局部对象" class="headerlink" title="onDraw()中不要创建新的局部对象"></a><code>onDraw()</code>中不要创建新的局部对象</h3><p><code>onDraw()</code>会被频繁调用，就会在一瞬间产生大量的临时对象，占用过多的内存并且导致系统频繁的发生GC，降低系统的执行效率。</p><h3 id="onDraw-不要做耗时的任务或者执行大量的循环操作"><a href="#onDraw-不要做耗时的任务或者执行大量的循环操作" class="headerlink" title="onDraw()不要做耗时的任务或者执行大量的循环操作"></a><code>onDraw()</code>不要做耗时的任务或者执行大量的循环操作</h3><p>Google官方推荐的标准是：<strong>View的绘制帧率保证60fps</strong>。尽量降低<code>onDraw()</code>的复杂度可以有效提高帧率。</p><h3 id="避免过度绘制"><a href="#避免过度绘制" class="headerlink" title="避免过度绘制"></a>避免过度绘制</h3><blockquote><p>在屏幕上某个像素在同一帧的时间的被绘制多次。在多层次重叠的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区被绘制多次，同时也会浪费大量的CPU和GPU资源。</p></blockquote><p>产生这一情况主要有两个原因：</p><ul><li>在XML布局中，控件有重叠且都设置了背景。</li><li>View的<code>onDraw()</code>在同一区域绘制了多次</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/GPU过度绘制.png" srcset="/img/loading.gif" class="full-image" alt="GPU过度绘制" title="GPU过度绘制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="过度绘制优化原则"><a href="#过度绘制优化原则" class="headerlink" title="过度绘制优化原则"></a>过度绘制优化原则</h4><ul><li>一些过度绘制是无法避免的。例如文字和背景导致的过度绘制</li><li>尽可能将过度绘制控制在2次及以下，原色和蓝色最佳</li><li>尽可能避免粉色和红色，或者尽可能减少这些区域</li><li>不允许存在面积超过屏幕1/4区域的3次(<code>粉色</code>)及以上过度绘制</li></ul><h4 id="过度绘制优化方法"><a href="#过度绘制优化方法" class="headerlink" title="过度绘制优化方法"></a>过度绘制优化方法</h4><ol><li><p>移除默认的Window背景</p><blockquote><p>需要在项目初期就做好，有可能因为某些界面忘记设置背景色，而导致显示了黑色的背景。</p></blockquote></li><li><p>移除不必要的背景</p><blockquote><p>例如在ListView中如果设置了ListView的背景色，且Item背景与其一致，就不需要去设置背景了。</p></blockquote></li><li><p>优化布局，减少层级</p></li><li><p>自定义View中，在<code>onDraw()</code>利用<code>clipRect()及quickReject()</code>进行重叠布局的优化绘制</p><blockquote><p><code>clipRect()</code>：设置需要绘制的区域，当某个View的部分区域不可见时，就不进行绘制。</p><p><code>quickReject()</code>：判断是否和某个矩形相交，跳过相交局域减少绘制层级。</p></blockquote></li></ol><h3 id="应用卡顿"><a href="#应用卡顿" class="headerlink" title="应用卡顿"></a>应用卡顿</h3><blockquote><p>在16ms内无法完成界面的渲染、计算和绘制，就会产生丢帧的现象，丢帧就会造成应用的卡顿。</p></blockquote><p>造成应用卡顿的原因主要有以下几点：</p><ul><li><code>过度绘制</code>：加重CPU与GPU渲染压力，导致渲染时间过长。</li><li><code>布局嵌套过多</code>：导致CPU与GPU压力变大</li><li><code>动画执行次数过多</code>：导致CPU与GPU压力变大</li><li><code>频繁GC</code>：执行GC，所有操作需要暂停，GC完成才可以继续操作。阻塞了渲染过程。</li><li><code>执行耗时操作</code>：会阻塞线程</li></ul><h3 id="绘制性能分析工具"><a href="#绘制性能分析工具" class="headerlink" title="绘制性能分析工具"></a>绘制性能分析工具</h3><h4 id="Profile-GPU-Rendering"><a href="#Profile-GPU-Rendering" class="headerlink" title="Profile GPU Rendering"></a>Profile GPU Rendering</h4><blockquote><p>是Android系统提供的开发辅助功能，在屏幕上会显示出彩色的柱状图。</p></blockquote><p>绿色的横线为警戒线，超过这条线就以为着渲染时间超过了16ms。<strong>尽量要保持垂直彩色柱不要超过警戒线。</strong></p><h4 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h4><blockquote><p>Android SDK自带的工具，用于对Android的应用程序以及Frtamework层代码进行性能分析。</p></blockquote><p>使用方式：</p><p><code>在代码中加入调试语句</code>：在开始监控的地方调用<code>Debug.startMethodTracing()</code>，结束监控的地方调用<code>Debug.stopMethodTracing()</code>。系统会在SD卡生成trace文件，将trace文件导出SD卡中，通过<code>traceView</code>命令对trace文件进行分析。<strong>注意设置内存卡访问权限。</strong></p><h2 id="内存泄漏优化"><a href="#内存泄漏优化" class="headerlink" title="内存泄漏优化"></a>内存泄漏优化</h2><blockquote><p><code>内存泄漏(Memory Leak)</code>：程序在申请内存后，无法释放已申请的内存空间。是造成应用OOM的主要原因之一。</p><p><code>内存溢出(out of memory)</code>：程序在申请内存时，没有足够的内存空间可以使用。</p></blockquote><h3 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h3><h4 id="静态变量导致的内存泄漏"><a href="#静态变量导致的内存泄漏" class="headerlink" title="静态变量导致的内存泄漏"></a><code>静态变量导致的内存泄漏</code></h4><blockquote><p>一个静态变量又是非静态内部类会一直持有对外部类的引用，导致外部类Activity无法被回收。<em>例如静态context、静态View</em></p></blockquote><p>示例代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Context context;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>&#123;    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    sContext = <span class="hljs-keyword">this</span>;  &#125;&#125;</code></pre><p>解决方法：可以将内部类设为静态内部类或独立出来；使用<code>context.getApplicationContext()</code>。</p><p><br></p><h4 id="单例模式导致的内存泄漏"><a href="#单例模式导致的内存泄漏" class="headerlink" title="单例模式导致的内存泄漏"></a><code>单例模式导致的内存泄漏</code></h4><blockquote><p>单例传入的参数来自Activity，使得持有对Activity的引用。</p></blockquote><p>示例代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleInstance</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingleInstance sInstance;  <span class="hljs-keyword">private</span> Context context;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleInstance</span><span class="hljs-params">(Context _context)</span></span>&#123;    <span class="hljs-keyword">this</span>.context = _context;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SingleInstance <span class="hljs-title">getInstance</span><span class="hljs-params">(Context _context)</span></span>&#123;    <span class="hljs-keyword">if</span>(sInstance==<span class="hljs-keyword">null</span>)&#123;      <span class="hljs-keyword">synchronized</span>(SingleInstance<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;        <span class="hljs-keyword">if</span>(sInstance==<span class="hljs-keyword">null</span>)&#123;          sInstance= <span class="hljs-keyword">new</span> SingleInstance(_context);        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>解决方法：传入的<code>context</code>修正成<code>ApplicationContext</code>。</p><p><br></p><h4 id="属性动画导致的内存泄漏"><a href="#属性动画导致的内存泄漏" class="headerlink" title="属性动画导致的内存泄漏"></a><code>属性动画导致的内存泄漏</code></h4><blockquote><p>在Activity中播放无限循环动画且没有在<code>onDestroy()</code>中去停止动画，使得View持有了Activity</p></blockquote><p>示例代码：</p><pre><code class="hljs java">objectAnimator.setRepeatCount(ValueAnimator.InFINITE);<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">super</span>.onDestroy();&#125;</code></pre><p>解决方法：在<code>onDestroy()</code>或其他时机调用<code>animator.cancel()</code>及时取消动画。</p><p><br></p><h4 id="Handler导致的内存泄漏"><a href="#Handler导致的内存泄漏" class="headerlink" title="Handler导致的内存泄漏"></a><code>Handler导致的内存泄漏</code></h4><blockquote><p>Handler的<code>Message</code>被存储在<code>MessageQueue</code>中，有些<code>Message</code>并不能马上被处理，就会存在的时间很长。导致Handler无法被回收。</p><p>Handler又是非静态的匿名内部类的实例，会隐式持有对外部类Activity的引用，使得引用关系会持续到消息被全部处理，导致内存泄漏。</p></blockquote><p>示例代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span></span>&#123;    <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>&#123;    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);    setContentView(R.layout.act_handler);    Button button = findViewById(R.id.btn);    <span class="hljs-keyword">final</span> Handler mHandler = <span class="hljs-keyword">new</span> Hnadler() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span></span>&#123;        <span class="hljs-keyword">super</span>.handleMessage(msg);      &#125;    &#125;    btn.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener()&#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span></span>&#123;        mHandler.sendEmptyMessage(<span class="hljs-number">1</span>);      &#125;    &#125;)  &#125;&#125;</code></pre><p>解决方法：</p><ul><li><p><code>使用静态内部类+WeakReference弱引用</code></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;HandlerActivity&gt; mActivity;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHandler</span> <span class="hljs-params">(HandlerActivity activity)</span></span>&#123;    mActivity = <span class="hljs-keyword">new</span> WeakReference&lt;HandlerActivity&gt;(activity);  &#125;    <span class="hljs-meta">@Oberride</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span></span>&#123;     <span class="hljs-comment">// do sth</span>  &#125;&#125;</code></pre></li></ul><ul><li><p><code>外部类生命周期结束时清空消息队列(MessageQueue)</code></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">if</span>(myHandler!=<span class="hljs-keyword">null</span>)&#123;    myHandler.removeCallbacksAndMessages(<span class="hljs-keyword">null</span>);  &#125;  <span class="hljs-keyword">super</span>.onDestroy();&#125;</code></pre></li></ul><p><br></p><h4 id="线程导致的内存泄漏"><a href="#线程导致的内存泄漏" class="headerlink" title="线程导致的内存泄漏"></a><code>线程导致的内存泄漏</code></h4><blockquote><p>AsyncTask/Runnable以<em>匿名内部类</em>的方式存在，会隐式持有对所在Activity的引用。</p></blockquote><p>解决方法：</p><ul><li><p>将AysncTask和Runnable设置为静态内部类或独立出来；</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAsyncTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AsyncTask</span>&lt;<span class="hljs-title">Void</span>,<span class="hljs-title">Void</span>,<span class="hljs-title">Void</span>&gt;</span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> Void <span class="hljs-title">doInBackground</span><span class="hljs-params">(Void... params)</span></span>&#123;    <span class="hljs-comment">// do Sth</span>  &#125;&#125;</code></pre></li></ul><ul><li><p>在线程内部采用弱引用保存Context引用</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;  WeakReference&lt;ThreadActivity&gt; mThreadActivity;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(ThreadActivity activity)</span></span>&#123;    mThreadActivity = <span class="hljs-keyword">new</span> WeakReference&lt;ThreadActivity&gt;(activity);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">super</span>.run();    <span class="hljs-keyword">if</span>(mThreadActivity == <span class="hljs-keyword">null</span>)      <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(mThreadActivity.get()!=<span class="hljs-keyword">null</span>)&#123;      mThreadActivity.get().doSth();    &#125;  &#125;&#125;</code></pre><blockquote><p>使用静态内部类：切断Activity对于MyTherad的强引用</p><p>使用弱引用：切断MyThread对于Activity的强引用。</p></blockquote></li></ul><p><br></p><h4 id="资源对象没关闭"><a href="#资源对象没关闭" class="headerlink" title="资源对象没关闭"></a><code>资源对象没关闭</code></h4><blockquote><p>未及时注销资源导致内存泄漏，例如BroadcastReceiver、File、Cursor、Stream，Bitmap等。<em>往往都使用了缓冲，会造成内存泄漏。</em></p></blockquote><p>解决方法：在Activity销毁的时候需要及时关闭或者注销。还有在资源对象不使用时，一定要确保它们已经关闭并将引用置为null，通常在<code>finally</code>执行关闭。</p><blockquote><p><code>BroadcastReceiver</code>：调用<code>unregisterReceiver()</code></p><p><code>Cursor、Steam、File</code>：调用<code>close()</code>关闭</p></blockquote><p><br></p><h3 id="内存泄漏分析工具"><a href="#内存泄漏分析工具" class="headerlink" title="内存泄漏分析工具"></a>内存泄漏分析工具</h3><h4 id="MAT分析工具"><a href="#MAT分析工具" class="headerlink" title="MAT分析工具"></a>MAT分析工具</h4><blockquote><p>利用DDMS生成堆存储文件，输出文件格式为<code>hprof</code>，利用MAT分析堆存储文件。</p></blockquote><h2 id="响应速度优化"><a href="#响应速度优化" class="headerlink" title="响应速度优化"></a>响应速度优化</h2><blockquote><p>核心思想：<strong>避免在主线程中做耗时操作。</strong></p></blockquote><p>将耗时操作放到线程中去执行，采用异步方式执行耗时操作。</p><blockquote><p>如果在主线程中做太多事情，会导致Activity启动时出现黑屏现象，甚至出现<strong>ANR</strong>。</p><p>出现ANR的场景：</p><ul><li>Activity5秒之内无法响应屏幕触摸事件或者键盘输入事件</li><li>BroadcaseReceiver在<em>前台广播10秒或后台广播60秒</em>未处理完操作</li><li>Service在<em>前台20秒后台200秒内</em>内无法执行完<code>onCreate()</code>操作</li></ul></blockquote><a href="/2019/01/28/ANR分析/" title="ANR分析">ANR分析</a><h2 id="ListView-RecyclerView优化和Bitmap优化"><a href="#ListView-RecyclerView优化和Bitmap优化" class="headerlink" title="ListView/RecyclerView优化和Bitmap优化"></a>ListView/RecyclerView优化和Bitmap优化</h2><a href="/2019/01/04/ListView简析/" title="ListView简析">ListView简析</a><a href="/2018/12/20/RecycleView简析/" title="RecyclerView简析">RecyclerView简析</a><a href="/2019/01/28/Bitmap分析/" title="Bitmap分析">Bitmap分析</a><h2 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h2><blockquote><p>核心思想：<strong>采用线程池，避免程序中存在大量的Thread。</strong></p></blockquote><p>线程池中可以重用内部的线程，从而避免了线程的创建和销毁所带来的性能开销，同时线程池还能有效控制线程池的最大并发数，避免大量的线程因为互相抢占系统资源从而导致阻塞现象的发生。</p><h2 id="其他性能优化建议"><a href="#其他性能优化建议" class="headerlink" title="其他性能优化建议"></a>其他性能优化建议</h2><ul><li>避免创建过多的对象</li><li>不要过度使用枚举，枚举占用的内存空间要比整型大（<em>大概4倍</em>）</li><li>常量请使用<code>static final</code>进行修饰</li><li>使用一些Android特有的数据结构，比如<code>SparseArray</code>(<em>减少了自动装箱和拆箱的消耗</em>)</li><li>适当使用弱引用和软引用</li><li>采用内存缓存和磁盘缓存</li><li>尽量采用静态内部类(<em>不会持有外部类的实例</em>)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-ReentrantLock原理及解析</title>
    <link href="/2018/12/19/Java-ReentrantLock%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <url>/2018/12/19/Java-ReentrantLock%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>一般的锁都是配合<code>synchronized</code>使用的，实际上在<code>java.util.concurrent.locks</code>还提供了其他几个锁的实现，拥有更加强大的功能和更好的性能。</p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><blockquote><p><code>可重入锁</code>：任意线程在获取该锁后能够再次获取锁时不会被阻塞。</p><p><strong>当前线程恶可以反复加锁，但必须释放同样多次数的锁，否则会导致锁不会释放。可以避免<code>死锁</code></strong></p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>通过组合自定义同步器(<code>AQS</code>)实现锁的获取与释放</p><ul><li>再次进行<code>lock()</code>，需要判断当前是否为已获得锁的线程，如果是，计数+1</li><li>执行<code>unlock()</code>，计数-1</li></ul><p>在释放锁后，如果计数不为0，就会导致程序卡死。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><code>synchronized</code>修饰的方法或代码块</li><li><code>ReentrantLock</code></li></ul><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p><strong>多个线程按照申请锁的先后顺序获取锁</strong>。内部持有一个等待队列，按照<code>FIFO</code>取出线程获取锁。</p><p>实现：<code>ReentrantLock(true)</code></p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p><strong>多个线程不是按照申请锁的先后顺序去获取锁。</strong></p><p><code>非公平锁</code>的性能高于<code>公平锁</code>，但是可能发生<strong>线程饥饿(某个线程长时间无法获得锁)</strong>。</p><p>实现：<code>synchronized</code>和<code>ReentrantLock(false)默认非公平</code></p><h3 id="读写锁和排他锁"><a href="#读写锁和排他锁" class="headerlink" title="读写锁和排他锁"></a>读写锁和排他锁</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p><strong>同一时刻允许多个读线程访问。</strong>分为了<strong>读锁</strong>和<strong>写锁</strong>，<code>读锁</code>允许多个线程获取读锁，访问同一个资源；<code>写锁</code>只允许一个线程获取写锁，不允许同时访问同一资源。</p><p><strong>在读多写少的情况下，大大提高了性能。</strong></p><blockquote><p>即使用读写锁，在写线程访问时，所有读线程和其他写线程都会被阻塞。</p></blockquote><p>实现：<code>ReentrantReadWhiteLock</code></p><h4 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h4><p><strong>同一时刻只允许一个线程访问</strong>。</p><p>实现：<code>ReentrantLock</code>、<code>synchronized</code></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote><p>两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，他们都将无法推进下去。</p></blockquote><p>死锁形成必须要求四个条件：</p><ul><li><p><strong>互斥条件</strong>：一个资源每次只能被一个线程使用</p></li><li><p><strong>请求与保持条件</strong>：一个线程引请求资源而阻塞时，对已获得的资源保持不放</p></li><li><strong>不剥夺条件</strong>：线程已获得的资源，在未使用完之前，不能强行剥夺</li><li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><blockquote><p> 在Java中锁是用来控制多个线程访问共享资源的方式。在Java SE5.0之后新增Lock接口。提供了与<code>synchronized</code>关键字类似的同步功能，只是在使用时需要显式的获取和释放锁，缺点就是无法像<code>synchronized</code>可以隐式的释放锁，但是可以自由操作获取锁和释放锁。</p></blockquote><h3 id="synchronized的不足之处"><a href="#synchronized的不足之处" class="headerlink" title="synchronized的不足之处"></a><code>synchronized</code>的不足之处</h3><ul><li>如果只是只读操作，应该多线程一起执行会更好，但是<code>synchronized</code>在<strong>同一时间只能一个线程执行</strong>。</li><li><code>synchronized</code>无法知道线程是否获取锁，而且无法主动进行释放锁</li><li>使用<code>synchronized</code>获取锁后，如果发生阻塞，就会导致所有线程等待锁释放</li></ul><h3 id="提供方法"><a href="#提供方法" class="headerlink" title="提供方法"></a>提供方法</h3><h4 id="lock-获取锁"><a href="#lock-获取锁" class="headerlink" title="lock()-获取锁"></a><code>lock()</code>-获取锁</h4><blockquote><p>执行时，如果锁处于空闲状态，当前线程获得锁。如果锁已被其他线程持有，将禁用当前线程，直到该线程获取锁。</p><p><strong>不会响应中断，直到获取锁成功才会进行响应。</strong></p></blockquote><h4 id="lockInterruptibly-获取锁，响应中断"><a href="#lockInterruptibly-获取锁，响应中断" class="headerlink" title="lockInterruptibly()-获取锁，响应中断"></a><code>lockInterruptibly()</code>-获取锁，响应中断</h4><blockquote><p><strong>获取锁时，优先响应中断，而不是先去进行获取。</strong></p></blockquote><h4 id="tryLock-非阻塞获取锁"><a href="#tryLock-非阻塞获取锁" class="headerlink" title="tryLock()-非阻塞获取锁"></a><code>tryLock()</code>-非阻塞获取锁</h4><blockquote><p>非阻塞获取锁，立即返回获取锁结果，<code>true</code>-成功，<code>false</code>-失败</p></blockquote><h4 id="tryLock-time-unit-指定时间获取锁"><a href="#tryLock-time-unit-指定时间获取锁" class="headerlink" title="tryLock(time,unit)-指定时间获取锁"></a><code>tryLock(time,unit)</code>-指定时间获取锁</h4><blockquote><p>指定时间获取锁，会响应中断</p><ul><li><code>time</code>内获取锁立即返回<code>true</code></li><li><code>time</code>内线程中断会立即返回获取锁结果</li><li><code>time</code>时间结束后，立即返回获取锁结果</li></ul></blockquote><h4 id="unlock-释放锁"><a href="#unlock-释放锁" class="headerlink" title="unlock()-释放锁"></a><code>unlock()</code>-释放锁</h4><blockquote><p>当前线程释放持有锁，<strong>锁只能由持有者释放，如果并未持有锁，执行解锁方法，就会抛出异常</strong>。</p></blockquote><h4 id="newCondition-获取锁条件"><a href="#newCondition-获取锁条件" class="headerlink" title="newCondition()-获取锁条件"></a><code>newCondition()</code>-获取锁条件</h4><blockquote><p>返回该锁的<code>Condition</code>实例，实现<strong>多线程通信</strong>。该组件会与当前锁绑定，当前线程只有获取了锁，才能调用组件的<code>await()</code>方法，调用后，线程释放锁。</p></blockquote><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><blockquote><p>一个可重入的互斥锁，具备一样的线程重入特性</p></blockquote><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>尝试获得锁</li><li>获取到锁的线程能够响应中断</li></ul><h2 id="读写锁-1"><a href="#读写锁-1" class="headerlink" title="读写锁"></a>读写锁</h2><blockquote><p>ReentrantLock是完全互斥排他的，这样其实效率不高</p></blockquote><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReenTrantLockTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获得同步锁</span>            lock.lock();            System.err.println(<span class="hljs-string">"获取锁"</span> + System.currentTimeMillis());            condition.await();            System.err.println();        &#125; <span class="hljs-keyword">catch</span> (                InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//释放同步锁</span>            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        ReenTrantLockTest test = <span class="hljs-keyword">new</span> ReenTrantLockTest();        Thread t1 = <span class="hljs-keyword">new</span> Thread(test);        Thread t2 = <span class="hljs-keyword">new</span> Thread(test);        t1.start();        t2.start();        t1.join();        t2.join();        System.err.println(<span class="hljs-string">"结束"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        test();    &#125;&#125;</code></pre><p>相比<code>synchronized</code>增加了一些高级功能：</p><ul><li><p><strong>等待可中断</strong>：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，去操作其他事情。</p></li><li><p><strong>公平锁</strong>：<code>多个线程在等待同一个锁时，必须按照申请锁的时间来依次获得锁。</code> <code>synchronized</code>是非公平锁，即<code>在锁被释放时，任何一个等待锁的线程都有机会获得锁。</code>这样就有可能会产生 <strong>饥饿现象(有些线程可能永远无法获得锁)</strong>。<code>ReenTrantLock</code>默认非公平锁，在构造时修改参数即可变为公平锁。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockFairTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-comment">//true为公平锁  false为非公平锁 默认false</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);    AtomicInteger iii = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (iii.get() &lt; <span class="hljs-number">20</span>) &#123;            lock.lock();            iii.getAndIncrement();            <span class="hljs-keyword">try</span> &#123;                System.err.println(Thread.currentThread().getName() + <span class="hljs-string">"获得锁"</span>);            &#125; <span class="hljs-keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        LockFairTest test = <span class="hljs-keyword">new</span> LockFairTest();        Thread t1 = <span class="hljs-keyword">new</span> Thread(test);        Thread t2 = <span class="hljs-keyword">new</span> Thread(test);        Thread t3 = <span class="hljs-keyword">new</span> Thread(test);        Thread t4 = <span class="hljs-keyword">new</span> Thread(test);        t1.start();        t2.start();        t3.start();        t4.start();    &#125;&#125;输出结果：公平锁：Thread-<span class="hljs-number">0</span>获得锁Thread-<span class="hljs-number">1</span>获得锁Thread-<span class="hljs-number">2</span>获得锁Thread-<span class="hljs-number">3</span>获得锁非公平锁：Thread-<span class="hljs-number">2</span>获得锁Thread-<span class="hljs-number">2</span>获得锁Thread-<span class="hljs-number">2</span>获得锁Thread-<span class="hljs-number">2</span>获得锁</code></pre></li><li><p><strong>锁绑定多个条件</strong>：一个<code>ReenTrantLock</code>对象可以通过多次调用<code>newCondition()</code>同时绑定多个<code>Condition</code>对象。在<code>synchronized</code>只能实现一个隐含的条件，要多关联只能额外添加锁。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Lock类可以实现线程同步，获得锁需要执行<code>lock</code>，释放锁使用<code>unlock</code></li><li>Lock分为公平锁(按照顺序)和不公平锁(不按顺序)</li><li>Lock还有读锁和写锁。<strong>读读共享，写写互斥，读写互斥</strong>。</li></ul><h2 id="自定义重入锁"><a href="#自定义重入锁" class="headerlink" title="自定义重入锁"></a>自定义重入锁</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomReetrantLock</span> </span>&#123;    <span class="hljs-keyword">boolean</span> isLocked = <span class="hljs-keyword">false</span>;    Thread lockedBy = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">int</span> lockedCount = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Thread callThread = Thread.currentThread();        <span class="hljs-keyword">while</span> (isLocked &amp;&amp; lockedBy != Thread.currentThread()) &#123;            wait();        &#125;        isLocked = <span class="hljs-keyword">true</span>;        lockedCount++;        lockedBy = callThread;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unLock</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (Thread.currentThread() == <span class="hljs-keyword">this</span>.lockedBy) &#123;            lockedCount--;            <span class="hljs-keyword">if</span> (lockedCount == <span class="hljs-number">0</span>) &#123;                isLocked = <span class="hljs-keyword">false</span>;                notify();            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关及其拓展(七) — 线程安全与锁优化</title>
    <link href="/2018/12/19/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%83/"/>
    <url>/2018/12/19/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><blockquote><p>首先需要并发的正确性，然后在此基础上实现高效。</p></blockquote><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p></blockquote><p>线程安全的代码必须具备一个特征：<strong>代码本身封装了所有必要的正确保障性手段，令调用者无需关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。</strong></p><p>线程安全的“安全程度”由强至弱分为以下5类：</p><ul><li><h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><blockquote><p>只要一个不可变的对象被正确的构建出来，那其外部的可见状态永远不会改变</p><p><code>不发生 this引用逃逸 情况下成立 -- 在构造函数返回之前，其他线程已经取得了该对象的引用。</code></p></blockquote><p>实现方案：</p><ul><li>如果共享数据是一个<code>基本数据类型</code>，只要在定义时用<code>final</code>修饰</li><li>如果共享数据是一个<code>对象</code>，最简单的就是 吧对象中带有状态的变量都声明为final</li></ul><p>符合不可变要求的类型：<code>String、枚举类(Enum)、Long，Double以及BigInteger等大数据类型</code></p></li><li><h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><blockquote><p>完全满足线程安全的定义，即达到”不管运行环境如何，调用者都不需要任何额外的同步措施。”</p></blockquote></li><li><h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><blockquote><p>保证对这个对象单独的操作是线程安全的，调用时不需做额外的保障措施，但是对于一些特定顺序的连续调用，就需要在调用端使用额外的同步手段保证调用的正确性。</p></blockquote><p>大部分的线程安全类都属于这种类型，例如<code>Vector,HashTable,synchronizedCollection()</code></p></li><li><h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><blockquote><p>对象本身并非线程安全，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全的使用。</p></blockquote><p>例如<code>ArrayList,HashMap</code></p></li><li><h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><blockquote><p>无论调用端是否采取了同步措施，都无法在多线程环境中并发使用。<strong>应当尽量避免</strong></p></blockquote><p>例如<code>Thread中的suspend()和resume()</code>。</p></li></ul><h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><blockquote><p>①通过代码实现线程安全 ②通过虚拟机本身实现同步与锁</p></blockquote><h3 id="互斥同步-阻塞同步"><a href="#互斥同步-阻塞同步" class="headerlink" title="互斥同步 (阻塞同步)"></a>互斥同步 (阻塞同步)</h3><blockquote><p><strong>同步</strong>：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只能被一个线程使用。</p><p><strong>互斥</strong>：实现同步的一种手段，<code>临界区、互斥量和信号量都是主要的互斥实现方法</code></p></blockquote><p><strong>互斥是因，同步是果；互斥是方法，同步是目的</strong></p><p><strong>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），就会出现问题，无论共享数据是否真的会出现数据竞争，都要进行加锁。</strong></p><p>实现手段：</p><ul><li><p><strong>synchronized</strong></p></li><li><p><strong>ReentrantLock</strong></p></li></ul><p><code>synchronized</code>和<code>ReentrantLock</code>的异同：</p><ul><li><p>两者都是<strong>可重入锁</strong>  <!--自己实现一个可重入锁--></p><blockquote><p><strong>可重入锁</strong>：当一个线程得到一个对象锁后，再次请求该对象锁时是可以再次得到该对象锁的。<strong>自己可以再次获得自己的内部锁。</strong></p></blockquote></li><li><p><code>synchronized</code>依赖于JVM而<code>ReentrantLock</code>依赖于API</p><p><code>synchronized</code>底层用<strong>Mutex(互斥量)</strong>实现，<code>ReentrantLock</code>继承自<code>Lock接口</code>,Lock接口又依赖于AQS实现</p></li><li><p><code>synchronized</code>的锁状态无法在代码中判断，<code>ReentrantLock</code>通过<code>isLocked()</code>判断</p></li><li><p><code>synchronized</code>非公平锁，另一个可以是公平也可以是非公平的</p></li><li><p><code>synchronized</code>不可被中断，另一个调用<code>lockInterrupbity()</code>即可中断</p></li><li><p><code>ReentrantLock</code>可以提高多个线程的读操作的效率</p></li></ul><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><blockquote><p>基于冲突检测的乐观并发策略，即先进行操作，若无其他线程争用共享数据，操作成功；反之，产生了冲突再去采用其他的补偿措施（<strong>最常见自旋——不停重试，直到成功为止</strong>）。</p></blockquote><p>为了保证<strong>操作和冲突检测</strong>具备原子性，需要用到硬件指令集，比如：</p><ul><li>测试并设置</li><li>获取并增加</li><li>交换</li><li><strong><em>比较并交换(CAS)</em></strong></li><li>加载链接/条件存储</li></ul><a href="/2018/12/18/Atomic原子操作类分析/" title="CAS操作&Atomic原子操作类分析">CAS操作&Atomic原子操作类分析</a><h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><blockquote><p>不用同步的方式保证线程安全，因为有些天生就是安全的。</p></blockquote><p>有以下两类：</p><ul><li><h4 id="可重入代码-纯代码-Reentrant-Code-Pure-Code"><a href="#可重入代码-纯代码-Reentrant-Code-Pure-Code" class="headerlink" title="可重入代码/纯代码(Reentrant Code/Pure Code)"></a>可重入代码/纯代码(Reentrant Code/Pure Code)</h4><blockquote><p>在代码执行的时候在任何时刻去中断，再去执行另外的代码，在控制权返回后，原来的程序不会出现任何的错误。</p></blockquote><p><strong>可重入性是它的基本特征，满足可重入性的代码一定是线程安全的，反之，满足线程安全的代码不一定是可重入的。</strong></p><p>共同特征：不依赖存储在堆上的数据和公用的系统资源、用到的状态栏都由参数中传入、不调用非可重入的方法等</p><p>判定依据：<strong>返回结果是可预测的，只要是输入了相同的数据就能返回相同的结果，就满足可重入性的要求。</strong></p></li><li><h4 id="线程本地存储-Thread-Local-Storage"><a href="#线程本地存储-Thread-Local-Storage" class="headerlink" title="线程本地存储(Thread Local Storage)"></a>线程本地存储(Thread Local Storage)</h4><blockquote><p>把共享数据的可见范围限制在同一个进程之内，无须同步也可以保证线程之间不出现数据争用的情况。</p></blockquote><p>使用<code>ThreadLocal</code>类可实现本地存储的功能。</p></li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><blockquote><p>锁优化是为了在线程之间更高效的共享数据，以及解决竞争性问题。</p><p>锁的状态共分为4种：<strong>无锁状态、偏向锁、轻量级锁和重量级锁</strong>。锁随着竞争情况可以升级，<strong>但升级后不能降级</strong>。</p><p><code>无锁状态-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</code></p></blockquote><h3 id="1-自旋锁与适应性自旋"><a href="#1-自旋锁与适应性自旋" class="headerlink" title="1. 自旋锁与适应性自旋"></a>1. 自旋锁与适应性自旋</h3><p>互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，影响系统的并发性能。同时，共享数据的锁定状态只会持续很短的一段时间，不值得去挂起和恢复线程。</p><p><strong>自旋锁</strong>：若物理机器有一个以上的处理器，能使多个线程同时并行执行，让后面的请求锁线程(通过自旋——<strong>CPU忙循环执行空指令</strong>)等待，但不放弃处理器的执行时间，看看持有锁的线程是否很快释放锁。</p><p><code>自旋等待不能代替阻塞，虽然避开了线程切换的开销，但要占用处理器时间，因此自旋等待必须有一定的上限，若超过了次数没有成功，就需要去挂起线程。</code></p><p><strong>自适应自旋锁</strong>：自旋时间不固定，由该锁上次的自旋时间及锁的拥有者状态决定。</p><ul><li>对于某个锁，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，JVM就会认为这次自旋也会再次成功获得锁，进而允许等待持续相对更长的时间</li><li>对于某个所，自选很少成功获得锁，以后再获取这个锁时可能忽略自旋过程，以避免浪费处理器资源。</li></ul><h3 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2. 锁消除"></a>2. 锁消除</h3><blockquote><p>JVM即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p></blockquote><p>判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为他们是线程私有的，同步加锁操作自然就无须进行。</p><p>例如<code>StringBuffer</code>对象的连续<code>append()</code></p><h3 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3. 锁粗化"></a>3. 锁粗化</h3><blockquote><p>JVM探测到一串零碎的操作都对同一对象进行加锁，将会把加锁同步的范围扩展（<strong>粗化</strong>）到整个操作序列的外代码</p></blockquote><h3 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="4. 轻量级锁"></a>4. 轻量级锁</h3><blockquote><p>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。<strong>轻量级锁并不是用来代替重量级锁的</strong></p></blockquote><p>必须先了解 HotSpot虚拟机的对象(<strong>对象头部分</strong>)的内存布局：分为两部分</p><ul><li><strong><em>Mark Word</em></strong>：存储自身的运行时数据，如：<code>HashCode、GC分代年龄和锁信息</code>，这部分数据的长度在32和64位中的JVM中分别为32bit和64bit。<strong>它是实现轻量级锁和偏向锁的关键。</strong></li><li>存储指向方法区对象类型数据的指针，如果是数组对象的话，额外会存储数据的长度。</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/MarkWord.png" srcset="/img/loading.gif" class="full-image" alt="Mark Word" title="Mark Word"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>加锁过程</p></blockquote><p>代码进入同步块时，如果同步对象未锁定(标记位为<code>01</code>)，虚拟机会在当前线程的栈帧中建立一个<code>锁记录(Lock Record)</code>的空间，用于存储对象目前的<code>Mark Word</code>拷贝（<strong>Displaced Mark Word</strong>）。</p><p>然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。</p><ul><li>更新成功，那么当前线程拥有了该对象的锁，且对象Mark Word的锁标志位为<code>00</code> ，处于轻量级锁定状态。</li><li>更新失败，JVM首先会检查对象的Mark Word是否指向当前线程的栈帧<ul><li>已指向表明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行</li><li>没指向表明该对象已被其他线程抢占。</li></ul></li></ul><p><strong>如果有两条以上的线程竞争同一个锁，轻量级锁就无法使用，需要膨胀为重量级锁，Mark Word的锁标志位变为<code>10</code>,存储的是指向重量级的指针，后面等待锁的也会进入阻塞状态。</strong></p><blockquote><p>解锁过程</p></blockquote><p>若对象的Mark Word仍然指向线程的Lock Record，那就用CAS操作把对象当前的Mark Word和Displaced Mark Word替换回来</p><ul><li>替换成功，就完成了整个同步过程</li><li>替换失败，说明有其他线程尝试获取锁，就要在释放锁的同时，唤醒被挂起的线程</li></ul><blockquote><p><code>栈帧</code>：用于支持虚拟西进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址信息。第一个方法从调用开始到执行完成，就是一个栈帧从入栈到出栈的过程。</p></blockquote><h3 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5. 偏向锁"></a>5. 偏向锁</h3><blockquote><p>消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。<strong>提高一个对象在很长一段时间内都只被一个线程用做锁对象场景下的性能。</strong></p><p><em>偏向锁可以提高带有同步但无竞争的程序性能。</em></p></blockquote><p>这个锁会偏向于第一个获得它的线程，如果后续该锁没有被其他线程获取，则持有偏向锁的线程将永远不会进行同步。</p><blockquote><p>加锁过程</p></blockquote><p>JVM启用了<code>偏向锁</code>模式，当锁对象第一次被线程获取的时候，JVM会把锁标记位置为<code>01</code>,即偏向模式。使用CAS操作记录锁的线程ID到Mark Word中。</p><ul><li>CAS操作成功。持有偏向锁的线程在每次进入和退出同步块是，只要比较一下Mark Word存储的线程ID是否相同。<ul><li>相同代表线程已经获得了锁，不需要再用CAS操作加锁和解锁</li><li>不同，就需要CAS操作竞争锁，竞争成功，替换Mark Word中的ThreadID为当前竞争线程的ID</li></ul></li></ul><blockquote><p>解锁过程</p></blockquote><p>当有另一个线程去尝试获取偏向锁时，CAS替换ThreadID失败，就要撤销偏向锁。(撤销偏向锁，需要等待原持有偏向锁的线程到达全局安全点<code>所有线程都是暂停的，没有字节码正在执行</code>，暂停线程，并检查状态)。判断原持有偏向锁的线程是否处于活动状态</p><ul><li>无活动则置为无锁状态(锁标志为<code>01</code>，是否偏向锁状态<code>0</code>)</li><li>还处于活动状态，则升级为轻量锁(标志位为<code>00</code>)</li></ul><blockquote><p>关闭偏向锁模式</p></blockquote><p>使用JVM参数 <code>-XX:BlasedLockingStartupDelay=0</code>可以关闭延迟，因为偏向锁需要应用启动后过几秒激活</p><p><code>-XX:UseBlasedLocking=false</code>关闭偏向锁</p><p>三种锁的升级</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/lock-upgrade.png" srcset="/img/loading.gif" class="full-image" alt="锁的升级，锁的升级"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>三种锁的比较</p><table><thead><tr><th style="text-align:center">锁</th><th>优点</th><th>缺点</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">偏向锁</td><td>加锁和解锁不需要额外的消耗，与执行非同步方法相比仅存在纳秒级的差距</td><td>线程间存在锁竞争，需要带来额外锁撤销的消耗</td><td style="text-align:center">只有一个线程访问同步块场景</td></tr><tr><td style="text-align:center">轻量级锁</td><td>竞争的线程不会阻塞，提高程序的相应速度</td><td>始终得不到锁竞争的线程，会使用自旋消耗CPU资源</td><td style="text-align:center">追求相应时间，同步块执行速度非常快</td></tr><tr><td style="text-align:center">重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢</td><td style="text-align:center">追求吞吐量，同步块执行时间较长</td></tr></tbody></table><blockquote><p><strong>重量级锁</strong>：本质上是依赖操作系统的<code>Mutex Lock</code>互斥量来实现同步操作。由于线程间的切换需要从用户态转向核心态，转换成本较高，耗时相对较长。</p></blockquote><p><em>一个线程如何判断自己是否取得锁？</em></p><blockquote><p>线程在获取锁之前会判断对象的<code>Mark Word</code>中是否存放自己的<code>threadId</code>，存放且相同则重入；不同，则使用CAS进行切换，锁升级为<code>轻量级锁</code>，释放偏向锁，清空<code>Mark Word</code>，线程开始竞争，竞争成功的就存入自己的<code>ThreadId</code>，失败的开始自旋。</p><p>调用<code>Thread.holdsLock()</code></p></blockquote><h2 id="其他锁类型及其概念"><a href="#其他锁类型及其概念" class="headerlink" title="其他锁类型及其概念"></a>其他锁类型及其概念</h2><h3 id="1-乐观锁"><a href="#1-乐观锁" class="headerlink" title="1.乐观锁"></a>1.乐观锁</h3><blockquote><p>由于在进程挂起和恢复执行过程中需要很大的开销进行切换。所以有了乐观锁概念。</p><p>每次去拿数据的时候都认为别人不会修改，但在更新的时候会去判断在此期间是否数据发生修改，没有被修改则进行数据更新。如果因为修改过产生冲突就失败就重试到成功为止(<strong>自旋</strong>)。</p></blockquote><p>实例：例如<code>Atomic原子类</code></p><p>使用场景：适合读取操作比较频繁的场景</p><h3 id="2-悲观锁"><a href="#2-悲观锁" class="headerlink" title="2.悲观锁"></a>2.悲观锁</h3><blockquote><p>每次获取数据的时候，担心数据被修改，所以每次都要加锁，确保操作过程中数据不会发生改变，操作完成后再解锁让其他线程操作。</p><p>在某个资源不可用的时候，就将CPU让出，把当前等待的线程切换为阻塞状态。等到资源可用，将阻塞线程唤醒，进入Runnable状态等待CPU调度。</p></blockquote><p>实例：例如<code>synchronized</code> </p><p>使用场景：比较适合写入操作频繁的场景</p><h3 id="3-互斥锁"><a href="#3-互斥锁" class="headerlink" title="3.互斥锁"></a>3.互斥锁</h3><blockquote><p>通过<code>排他性</code>，同时只允许一个访问者对其进行访问来保证资源的有效同步，但无法限制线程对该资源的访问顺序</p></blockquote><h3 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.<strong>死锁</strong></h3><blockquote><p>两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，他们都将无法推进下去。</p></blockquote><p>死锁形成必须要求四个条件：</p><ul><li><p><strong>互斥条件</strong>：一个资源每次只能被一个线程使用</p></li><li><p><strong>请求与保持条件</strong>：一个线程引请求资源而阻塞时，对已获得的资源保持不放</p></li><li><strong>不剥夺条件</strong>：线程已获得的资源，在未使用完之前，不能强行剥夺</li><li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><p>常见死锁类型：</p><ul><li><p><strong>静态的锁顺序死锁</strong> <code>所有需要多个锁的线程，都要以相同的顺序获得锁</code></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockTest</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lockA = <span class="hljs-keyword">new</span> Object();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lockB = <span class="hljs-keyword">new</span> Object();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">synchronized</span>(lockA)&#123;            <span class="hljs-keyword">synchronized</span>(lockB)&#123;                System.out.println(<span class="hljs-string">"func A"</span>)            &#125;        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">synchronized</span>(lockB)&#123;            <span class="hljs-keyword">synchronized</span>(lockA)&#123;                System.out.println(<span class="hljs-string">"func b"</span>)            &#125;        &#125;    &#125;&#125;</code></pre></li><li><p><strong>动态的锁顺序死锁</strong> <code>自定义锁的顺序，确保所有线程以相同的顺序获得锁</code></p></li><li><p><strong>协作对象之间发生的死锁</strong> <code>避免在持有锁的情况下调用外部的方法</code></p></li></ul><p>死锁预防：</p><ul><li><p>以确定的顺序获得锁</p><p>将所有的锁都按照特定顺序进行获取，防止死锁发生。</p><blockquote><p><strong>银行家算法</strong>：允许进程动态的申请资源，但在系统进行资源分配之前，先计算此次资源分配的安全性，若分配不会导致进入不安全状态，则分配；否则等待。</p></blockquote></li><li><p>超时放弃</p><blockquote><p>例如<code>synchronized</code>只要线程没有获得锁，就会永远等待下去，<code>Lock</code>提供了<code>tryLock()</code>可以实现超时放弃</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程基础</title>
    <link href="/2018/12/19/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2018/12/19/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<!--生成者-消费者模式 创建线程 为什么要使用多线程？会有什么问题 线程池概念以及实现原理、四种初始化方案 开线程影响那块区域 进程与线程 多线程断点续传 线程关闭以及防止线程的内存泄漏 线程池上限 为什么要有线程 并发 线程模型 wait和sleep的区别 控制允许并发访问的个数 自己实现线程安全类--><h1 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h1><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/多线程基础.png" srcset="/img/loading.gif" class="full-image" alt="多线程基础" title="多线程基础"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>操作系统结构的基础，是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单位。<code>进程就是程序的实体</code></p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>线程是进程的一个实体，是CPU调度和分配的基本单位，线程是一个比进程更小的执行单位，一个进程在执行期间可以产生多个线程。<code>一个进程至少一个线程</code>。一般应用于高并发场景，可以提高CPU的利用率。</p></blockquote><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><blockquote><p>每个进程都拥有自己独立的资源，多个进程可在单核处理器上并发执行，在多核处理器并行执行。</p></blockquote><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote><p>一个进程可由多个线程组成，多个线程共享进程内资源，多个线程可在单核处理器上并发执行，在多核处理器并行执行。解决多任务同时执行的需求，合理使用CPU资源。<strong>多线程具有不稳定性</strong></p></blockquote><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><blockquote><p>在一段时间内多个任务同时执行，或者说在一段时间内可以执行多条指令，微观上看起来就是同时运行多个进程。<strong>偏重于多个任务交替执行，有可能串行执行</strong></p></blockquote><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><blockquote><p>在同一时刻内多个任务同时执行，多核处理器才可以做到。<strong>偏重于同时执行。</strong></p></blockquote><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/线程基础.png" srcset="/img/loading.gif" class="full-image" alt="线程基础" title="线程基础"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h3><p>两者的区别：</p><ul><li>多个进程间的内部数据和状态都是完全独立的，而多线程是共享一块内存空间和一组系统资源，有可能互相影响</li><li>线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以<strong>线程的切换负担比进程的切换负担小</strong></li><li>进程是重量级的任务，需要分配给他们独立的地址空间，进程间通信以及切换时很复杂的。</li></ul><h3 id="2-线程的实现"><a href="#2-线程的实现" class="headerlink" title="2. 线程的实现"></a>2. 线程的实现</h3><p>线程的实现一般有以下3中方法，前面两种比较常见：</p><ul><li><h4 id="继承Thread类，重写run-方法"><a href="#继承Thread类，重写run-方法" class="headerlink" title="继承Thread类，重写run()方法"></a>继承Thread类，重写<code>run()</code>方法</h4><blockquote><p><code>Thread</code>本质上是实现了<code>Runnable</code>接口的一个实例。<strong>调用<code>start()</code>后并不是立即执行代码，而是是线程的状态变为<code>Runnable</code>可运行态，何时运行由操作系统决定。</strong></p></blockquote><p>主要步骤：</p><ol><li>定义Thread类的子类，重写<code>run()</code>方法，<code>run()</code>方法内部代表了线程需要完成的任务，所以该方法又称<code>执行体</code></li><li>创建Thread类子类实例，即创建线程对象</li><li>调用线程对象的<code>start()</code>启动线程</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"Hello Thread"</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Thread thread = <span class="hljs-keyword">new</span> ThreadTest();        thread.start();    &#125;&#125;</code></pre><p>拓展：</p><p>只调用<code>run()</code>和执行普通方法是一致的。</p></li><li><h4 id="实现Runnable接口，并实现run-方法"><a href="#实现Runnable接口，并实现run-方法" class="headerlink" title="实现Runnable接口，并实现run()方法"></a>实现Runnable接口，并实现<code>run()</code>方法</h4><p>主要步骤：</p><ol><li>自定义类实现<code>Runnable</code>，实现<code>run()</code>方法</li><li>创建Thread类子类实例，即创建Thread对象</li><li>调用实例的<code>start()</code></li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"Hello Runnable"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        RunnableTest runnable = <span class="hljs-keyword">new</span> RunnableTest();        Thread thread = <span class="hljs-keyword">new</span> Thread(runnable);        thread.start();    &#125;&#125;</code></pre></li><li><h4 id="实现Callable接口，重写call-方法需配合Future或者FutureTask"><a href="#实现Callable接口，重写call-方法需配合Future或者FutureTask" class="headerlink" title="实现Callable接口，重写call()方法需配合Future或者FutureTask"></a>实现Callable接口，重写<code>call()</code>方法需配合<code>Future</code>或者<code>FutureTask</code></h4><p>主要步骤：</p><ol><li>创建<code>Callable</code>接口实现类，并实现<code>call()</code>方法</li><li>创建<code>Callable</code>实现类的实例，使用<code>FutureTask</code>包装<code>Callable</code>对象</li><li>使用<code>FutureTask</code>对象作为Thread对象的target创建并启动新线程</li><li>调用<code>FutureTask</code>对象的<code>get()</code>方法获得子线程执行结束后的返回值，<strong>调用<code>get()</code>会阻塞线程</strong></li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCallable</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello Callable"</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        MyTestCallable myTestCallable = <span class="hljs-keyword">new</span> MyTestCallable();        <span class="hljs-comment">//利用futuretask </span>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(myTestCallable);        Thread t =<span class="hljs-keyword">new</span> Thread(futureTask);        t.start();        <span class="hljs-keyword">try</span> &#123;            System.err.println(futureTask.get());        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">//利用ExecutorService产生一个线程 结合future</span>        ExecutorService executorService = Executors.newSingleThreadExecutor();        Future future = executorService.submit(myTestCallable);        <span class="hljs-keyword">try</span> &#123;            System.err.println(future.get());            executorService.shutdown();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">//利用ExecutorService产生一个线程 结合futureTask</span>        executorService.submit(futureTask);        <span class="hljs-keyword">try</span> &#123;            System.err.println(futureTask.get());            executorService.shutdown();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><code>Runnable</code>与<code>Callable</code>不同点：</p><ul><li><code>Runnable</code>不返回执行结果，<code>Callable</code>可返回结果</li><li><code>Callable</code>可以抛出异常</li><li><code>Runnable</code>可直接由<code>Thread构造</code>或者<code>EXecutorService.submit()</code>执行</li></ul><p>运行<code>Callable</code>可以得到一个Future对象，表示异步计算的结果。提供了检查计算是否完成的方法以等待计算的完成，并检查计算结果。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-comment">//试图取消任务的执行。mayInterruptIfRunning确定是否应该以试图停止任务的方式中断执行任务流程。true 直接中断 false等待执行完成 </span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;    <span class="hljs-comment">//任务正常完成前将其取消，返回true</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//任务已完成或者因为正常终止、异常，取消而完成，返回true</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//等待计算结果的返回，如果被取消则抛出异常</span>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;    <span class="hljs-comment">//设定执行时间，超过时间则抛出Timeout异常</span>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;&#125;</code></pre><h4 id="三种方法的比较"><a href="#三种方法的比较" class="headerlink" title="三种方法的比较"></a>三种方法的比较</h4></li></ul><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread类</td><td>编写简单，可以使用<code>this</code>直接访问当前线程</td><td>1.受限于Java类的单继承，无法继承其他类；<br>2.多个线程之间无法共享方法或实例变量</td></tr><tr><td>实现Runnable接口</td><td>多个线程可共享一个实现了<code>Runnable</code>接口的类，非常适合多个线程处理同一任务</td><td>1.<code>run()</code>没有返回值<br>2.不能直接捕获运行过程中的异常，需要使用<code>setDefaultUncaughtExceptionHandler()</code>捕获子线程的异常</td></tr><tr><td>实现Callable接口</td><td>多个线程可共享一个实现了<code>Callable</code>接口的类，非常适合多个线程处理同一任务；可以有返回值；可以抛出异常</td><td>编写略微复杂，要访问当前线程需要使用<code>Thread.currentThread()</code></td></tr></tbody></table><h4 id="线程创建的内存代价"><a href="#线程创建的内存代价" class="headerlink" title="线程创建的内存代价"></a>线程创建的内存代价</h4><blockquote><p>每当有线程创建时，JVM就需要在内存中分配<code>虚拟机栈</code>和<code>本地方法栈</code>来记录调用方法的内容，分配<code>程序计数器</code>记录指令执行的位置，这样的<code>内存消耗</code>就是创建线程的内存代价。</p></blockquote><h3 id="3-线程的状态"><a href="#3-线程的状态" class="headerlink" title="3. 线程的状态"></a>3. 线程的状态</h3><p>Java线程在运行的生命周期中可能处于6种不同的状态：</p><ul><li><h4 id="New-创建"><a href="#New-创建" class="headerlink" title="New(创建)"></a>New(创建)</h4><p>线程被创建，还没有调用<code>start()</code>，还没有运行</p></li><li><h4 id="Runnable-可运行"><a href="#Runnable-可运行" class="headerlink" title="Runnable(可运行)"></a>Runnable(可运行)</h4><p>一旦调用<code>start()</code>，线程处于<code>Runnable</code>状态，一个可运行的线程可能处于正在运行或没有运行状态，这取决与操作系统给系统提供运行的时间</p></li><li><h4 id="Blocked-阻塞"><a href="#Blocked-阻塞" class="headerlink" title="Blocked(阻塞)"></a>Blocked(阻塞)</h4><p>表示线程被锁阻塞而等待监视锁(<code>monitor</code>)，暂时不能活动</p></li><li><h4 id="Waiting-等待"><a href="#Waiting-等待" class="headerlink" title="Waiting(等待)"></a>Waiting(等待)</h4><p>线程暂时不活动，并不运行任何代码，消耗最少资源并等待线程调度器重新激活它。</p></li><li><h4 id="Timed-Waiting-超时等待"><a href="#Timed-Waiting-超时等待" class="headerlink" title="Timed Waiting(超时等待)"></a>Timed Waiting(超时等待)</h4><p>在指定等待时间内等待另一个线程执行特定的方法的线程状态</p></li><li><h4 id="Terminated-终止"><a href="#Terminated-终止" class="headerlink" title="Terminated(终止)"></a>Terminated(终止)</h4><p>表示当前线程已执行完毕。导致线程处于终止态有两种情况：</p><ul><li><code>run()</code>执行完毕正常退出</li><li>一个没有捕获的异常终止了<code>run()</code>，导致线程终止</li></ul></li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Thread-State.png" srcset="/img/loading.gif" class="full-image" alt="线程状态" title="线程状态"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="4-线程的分类"><a href="#4-线程的分类" class="headerlink" title="4. 线程的分类"></a>4. 线程的分类</h3><ul><li><h4 id="普通线程-用户线程"><a href="#普通线程-用户线程" class="headerlink" title="普通线程(用户线程)"></a>普通线程(用户线程)</h4><p>运行在前台，执行具体的任务，如程序的主线程，链接网络的子线程都是用户线程</p></li><li><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>运行在后台，为其他线程提供服务，如果所有的前台线程都死亡，守护线程也随之死亡。当整个虚拟机只剩下后台线程，虚拟机也就退出了。</p><p>应用：JVM虚拟机启动后的后台检测线程，数据库连接池中的检测线程</p><p>最常见的守护线程：<code>虚拟机中的垃圾回收线程</code></p></li></ul><h3 id="5-线程中的常见方法"><a href="#5-线程中的常见方法" class="headerlink" title="5. 线程中的常见方法"></a>5. 线程中的常见方法</h3><ul><li><h4 id="start"><a href="#start" class="headerlink" title="start()"></a><code>start()</code></h4><p><code>start()</code>方法执行后，表示该线程到达了<code>Runnable</code>状态，何时运行还要等待线程调度器调度</p><p><strong>线程死亡后，不可再次调用<code>start()</code>，只能对<code>New</code>状态的线程调用且只能调用一次<code>start()</code></strong></p></li><li><h4 id="run"><a href="#run" class="headerlink" title="run()"></a><code>run()</code></h4><p>直接调用<code>run()</code>，只是调用线程中的代码，多个线程无法并发执行</p></li><li><h4 id="join"><a href="#join" class="headerlink" title="*join()"></a>*<code>join()</code></h4><p>主要作用是<strong>等待该线程终止</strong>。<code>主线程需要等待子线程执行完成之后再结束，也就是在子线程调用了join()方法后面的代码只有子线程结束了才可以执行。</code> </p></li><li><h4 id="sleep-long-mills"><a href="#sleep-long-mills" class="headerlink" title="*sleep(long mills)"></a>*<code>sleep(long mills)</code></h4><p>主动放弃占用的处理器资源，进入<code>Blocked</code>。使当前执行的线程以指定的毫秒数休眠（<code>暂时停止执行</code>），具体取决于定时器和调度程序的精度和准确性。当超过了指定的睡眠时间后，线程进入<code>Runnable</code>，等待线程调度器调用。</p></li><li><h4 id="yield"><a href="#yield" class="headerlink" title="*yield()"></a>*<code>yield()</code></h4><p>主动放弃占用的处理器资源，进入<code>Runnable</code>状态，等待线程调度器调用。<strong>这个方法要注意的是它只会让步给比它优先级高的或者和它优先级相同并处在就绪状态的线程。放弃的时间不确定，可能一会就回重新获取CPU，线程调度器重新调用。</strong></p></li><li><h4 id="interrupt-和isInterrupted"><a href="#interrupt-和isInterrupted" class="headerlink" title="*interrupt()和isInterrupted()"></a>*<code>interrupt()</code>和<code>isInterrupted()</code></h4><p><code>interrupted()</code>：请求线程终止，实际线程并不一定会终止，执行后可以将中断标识位设置为false。线程会时不时的检测中断标识位，以判断线程是否应该被中断。</p><p><code>isInterrupted()</code>：检测当前线程是都已经是中断状态，检测中断标识位</p></li><li><h4 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority()"></a><code>setPriority()</code></h4><p>设置线程的优先级，<strong>理论上说：线程优先级高的更容易被执行，但也要结合具体的系统。</strong></p><p>使用<code>getPriority()</code>可以查看当前线程的优先级。</p></li><li><h4 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a><code>isAlive()</code></h4><p>检查线程是否处于活动状态，如果线程处于<code>Runnable(就绪或运行),Blocked(阻塞)</code>返回<code>true</code>，若处于<code>New(新建),Terminated(终止)</code>返回<code>false</code></p></li><li><h4 id="wait-wait-long-mills"><a href="#wait-wait-long-mills" class="headerlink" title="*wait()/wait(long mills)"></a>*<code>wait()/wait(long mills)</code></h4><p>导致线程进入等待状态，并释放锁。<code>mills</code>为等待时间，超过这个时间没有对当前线程进行唤醒(调用<code>notify()/notifyAll()</code>)即会自动唤醒。未设置<code>mills</code>，则直到被唤醒为止。<strong>只能在同步方法或者同步块内调用，例如<code>synchronized(lockobj) {...}</code></strong></p></li><li><h4 id="notify"><a href="#notify" class="headerlink" title="*notify()"></a>*<code>notify()</code></h4><p>让当前线程通知那些处于等待(<code>Waiting</code>)的线程，当前线程执行完毕后释放锁，随机选择一个在该对象上调用<code>wait()</code>的线程，解除其阻塞状态。<strong>只能在同步方法或者同步块内调用，例如<code>synchronized(lockobj) {...}</code></strong></p></li><li><h4 id="notifyAll"><a href="#notifyAll" class="headerlink" title="*notifyAll()"></a>*<code>notifyAll()</code></h4><p>让当前线程通知那些处于等待(<code>Waiting</code>)的线程，当前线程执行完毕后释放锁，唤醒所有在该对象上调用<code>wait()</code>的线程，解除其阻塞状态。<strong>只能在同步方法或者同步块内调用，例如<code>synchronized(lockobj) {...}</code></strong></p></li></ul><blockquote><p><code>wait()</code>和<code>sleep()</code>的区别</p><ul><li><code>sleep()</code>来自于Thread类方法，<code>wait()</code>来自Object类</li><li><p><code>sleep()</code>不会释放锁，<code>wait()</code>释放锁，使得其他线程可以使用同步控制块或者方法</p></li><li><p><code>sleep()</code>让当前正在执行的线程休眠，等待一定的时间之后，会重新进入<code>Runnable</code>。<code>wait()</code>使实体所处线程暂停运行，直到被<code>notify()/notifyAll()</code>唤醒或者<code>wait()</code>的时间到达。</p></li></ul></blockquote><h3 id="6-线程安全中断"><a href="#6-线程安全中断" class="headerlink" title="6. 线程安全中断"></a>6. 线程安全中断</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptThreadTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;       <span class="hljs-comment">//第一种 判定当前线程的中断标识位是否为true</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> l = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;            l++;            System.err.println(<span class="hljs-string">"l = "</span> + l);        &#125;        System.err.println(<span class="hljs-string">"线程已经停止"</span>);    &#125;   <span class="hljs-comment">//第二种 自己设置中断标识位 on</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> on = <span class="hljs-keyword">true</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> l = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(on)&#123;            l++;            System.err.println(<span class="hljs-string">"l = "</span> + l);        &#125;        System.err.println(<span class="hljs-string">"线程已经停止"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>&#123;        on = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            InterruptThreadTest thread = <span class="hljs-keyword">new</span> InterruptThreadTest();            thread.start();            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);            <span class="hljs-comment">//第一种 调用interrupt设置中断标识位为 true</span>            thread.interrupt();            <span class="hljs-comment">//第二种 自己设置中断标识位</span>            cancel();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h3 id="7-线程优先级"><a href="#7-线程优先级" class="headerlink" title="7. 线程优先级"></a>7. 线程优先级</h3><blockquote><p>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使用哪个线程进入运行状态。<em>低优先级的线程并不意味着不会被运行，只是运行几率会变小。</em></p><p>线程优先级具有<strong>继承特性</strong>，比如A线程启动B线程，则B线程与A线程优先级一致</p><p>线程优先级具有<strong>随机性</strong>，线程优先级高的不一定每次都先执行完。</p><p>优先级从<code>1-10</code>，10为最高级，1为最低级</p></blockquote><h3 id="8-线程调度策略"><a href="#8-线程调度策略" class="headerlink" title="8. 线程调度策略"></a>8. 线程调度策略</h3><ul><li><h4 id="抢占式调度策略"><a href="#抢占式调度策略" class="headerlink" title="抢占式调度策略"></a>抢占式调度策略</h4><p>如果一个优先级比其他任何处于可运行状态的线程都高的线程都进入就绪状态，那么运行时系统就会选择该线程运行。</p></li><li><h4 id="时间片轮转调度策略"><a href="#时间片轮转调度策略" class="headerlink" title="时间片轮转调度策略"></a>时间片轮转调度策略</h4><p>从所有处于就绪状态的线程中优先选择优先级最高的线程分配一定的CPU时间运行，该时间过后再去选择其他线程运行。<code>只有当线程运行结束或者放弃等原因进入阻塞状态，低优先级的线程才有机会执行。</code>若优先级相同，则调度程序以轮转的方式选择运行的线程。</p></li></ul><h2 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-多线程的优缺点"><a href="#1-多线程的优缺点" class="headerlink" title="1. 多线程的优缺点"></a>1. 多线程的优缺点</h3><p>优点：</p><blockquote><ol><li>资源利用率好</li><li>提高程序的执行效率(多个线程同时执行)</li><li>程序响应更快</li></ol></blockquote><p>缺点：</p><blockquote><ol><li><p>设计更复杂</p><p>多线程程序在访问共享数据时需要小心处理，否则会出现难以修复的bug。线程之间的交互往往非常复杂，不正确的线程同步产生的错误难以被发现并修复(由于线程调度的无序性，可能依赖于某种特殊的线程执行序列)。</p></li><li><p>上下文切换的开销</p><p>线程是由CPU进行调度的，CPU的一个时间片内只执行一个线程上下文内的线程。<strong>上下文切换</strong>(<code>当CPU从执行一个线程切换到执行另一个线程时，需要先存储当前线程的本地数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后开始执行另一个线程。</code>)这个过程并不廉价，如果没有必要，要尽量减少<code>上下文切换</code>的发生。</p></li><li><p>更多的资源消耗</p><p>除了CPU执行<code>上下文切换</code>的消耗外，线程的执行还有其他的资源消耗。例如<strong>内存同步的开销(线程需要一些内存维持本地栈去存储线程专用数据)</strong>、<strong>创建线程和终止的开销</strong>，<strong>线程调度的开销</strong>等。</p></li></ol></blockquote><p>拓展：</p><ul><li><p>引起<strong>上下文切换</strong>的原因</p><ul><li>时间片用完，CPU正常调度下一个任务</li><li>被其他线程优先级更高的任务抢占</li><li>执行任务遇到阻塞，调度器挂起当前任务，切换执行另一个任务</li><li>用户主动挂起线程(<code>yield()</code>,<code>sleep()</code>)</li><li>多任务抢占资源，没有抢到被挂起</li><li>硬件中断</li></ul></li><li><p>线程切换的性能代价</p><blockquote><p>JVM需要先保存起被挂起线程的上下文环境：将线程执行位置保存在<code>程序计数器</code>中，调用方法的信息保存到<code>栈</code>中，待执行线程的<code>程序计数器</code>和<code>栈</code>中信息写入到处理器中。维护线程隔离数据区中的内容在<strong>处理器中的导入导出</strong>，就是线程切换的性能代价。</p></blockquote><p>减少线程上下文切换的方法：</p><ul><li>使用基于CAS的非拥塞算法</li><li>无锁并发编程，尽量使用<code>ThreadLocal</code>或者不变量，而不是用锁 <a href="https://www.jianshu.com/p/bb36fee3e55c" target="_blank" rel="noopener">安全共享策略</a></li><li>使用<code>线程池+等待队列</code>的方式，控制线程数目</li></ul></li></ul><h3 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h3><blockquote><p>如果两个线程竞争统一资源时，并且每一个线程都调用了修改该对象的方法，这种情况通常称为<strong>竞态条件</strong>。导致竞态条件发生的代码区称为<strong>临界区</strong>。</p><p>若一个资源的创建、使用，销毁都在同一个线程内，且不会脱离该线程的控制，则无需同步。</p></blockquote><ul><li><h4 id="同步方法-synchronized方法锁"><a href="#同步方法-synchronized方法锁" class="headerlink" title="同步方法 synchronized方法锁"></a>同步方法 <code>synchronized</code>方法锁</h4></li><li><h4 id="同步代码块-synvhronized类锁"><a href="#同步代码块-synvhronized类锁" class="headerlink" title="同步代码块 synvhronized类锁"></a>同步代码块 <code>synvhronized</code>类锁</h4></li><li><h4 id="wait-和notify"><a href="#wait-和notify" class="headerlink" title="wait()和notify()"></a>wait()和notify()</h4></li><li><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4></li><li><h4 id="重入锁-Lock"><a href="#重入锁-Lock" class="headerlink" title="重入锁 Lock"></a>重入锁 <code>Lock</code></h4></li><li><h4 id="局部变量-ThreadLocal"><a href="#局部变量-ThreadLocal" class="headerlink" title="局部变量 ThreadLocal"></a>局部变量 <code>ThreadLocal</code></h4></li><li><h4 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列 BlockingQueue"></a>阻塞队列 <code>BlockingQueue</code></h4></li></ul><h3 id="3-线程通信"><a href="#3-线程通信" class="headerlink" title="3. 线程通信"></a>3. 线程通信</h3><blockquote><p>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p></blockquote><ul><li><h4 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait()/notify()"></a>wait()/notify()</h4><p>在<code>synchronized</code>修饰的同步方法或者同步代码块中使用Object类提供的<code>wait()、notify()，notifyAll()</code>这三个方法进行线程通信</p></li><li><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>当程序使用<code>Lock</code>类同步，系统不存在隐式的同步监视器，只能用Condition控制线程通信</p></li><li><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><code>BlockingQueue</code>提供了<code>put(E e)</code>和<code>take()</code>支持阻塞的方法。</p></li></ul><p>体现在<code>生产者-消费者模式</code></p><p>生产者-消费者模式的实现</p><ol><li><p>wait()/notify()实现</p> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductCustomerWithWaitNotify</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_SIZE = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedList&lt;Object&gt; linkedList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(ProductCustomerWithWaitNotify::produce).start();        <span class="hljs-keyword">new</span> Thread(ProductCustomerWithWaitNotify::produce).start();        <span class="hljs-keyword">new</span> Thread(ProductCustomerWithWaitNotify::produce).start();        <span class="hljs-keyword">new</span> Thread(ProductCustomerWithWaitNotify::produce).start();        <span class="hljs-keyword">new</span> Thread(ProductCustomerWithWaitNotify::consume).start();        <span class="hljs-keyword">new</span> Thread(ProductCustomerWithWaitNotify::consume).start();        <span class="hljs-keyword">new</span> Thread(ProductCustomerWithWaitNotify::consume).start();        <span class="hljs-keyword">new</span> Thread(ProductCustomerWithWaitNotify::consume).start();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (linkedList) &#123;            <span class="hljs-keyword">while</span> (linkedList.size() == MAX_SIZE) &#123;                <span class="hljs-keyword">try</span> &#123;                    linkedList.wait();                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;            linkedList.add(<span class="hljs-keyword">new</span> Object());            System.err.println(<span class="hljs-string">"生成新产品，当前个数为"</span> + linkedList.size());            linkedList.notifyAll();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (linkedList) &#123;            <span class="hljs-keyword">while</span> (linkedList.size() == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    linkedList.wait();                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;            linkedList.remove();            System.err.println(<span class="hljs-string">"消费了产品，当前个数为"</span> + linkedList.size());            linkedList.notifyAll();        &#125;    &#125;&#125;</code></pre></li><li><p>Condition()</p></li></ol><ol start="3"><li><p>BlockingQueue</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductCustomerBlockQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> queueSize = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(queueSize,<span class="hljs-keyword">true</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ProductCustomerBlockQueue blockQueue = <span class="hljs-keyword">new</span> ProductCustomerBlockQueue();        Producter producter = blockQueue.<span class="hljs-keyword">new</span> Producter();        Customer customer = blockQueue.<span class="hljs-keyword">new</span> Customer();        producter.start();        customer.start();    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    queue.take();                    System.err.println(<span class="hljs-string">"消费哦"</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    queue.put(<span class="hljs-number">1</span>);                    System.err.println(<span class="hljs-string">"生产哦"</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></li></ol><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关及其拓展(六) -- Java与线程</title>
    <link href="/2018/12/18/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%85%AD/"/>
    <url>/2018/12/18/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h1><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程间既可以共享进程资源，又可以独立调度(<code>线程是CPU调度的基本单位</code>)。</p><p>实现线程主要有三种方式：</p><ul><li><h3 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h3><blockquote><p>直接由操作系统内核支持的线程。</p><p>由内核来完成切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。</p></blockquote><p><code>多线程内核</code>：有能力处理多件事情，支持多线程的内核</p><p><code>轻量级进程</code>：内核线程的一种高级接口。<code>只有先支持内核线程，才能有轻量级进程</code></p><ul><li>优点：每个轻量级进程都是一个独立的调度单元，即使有一个在系统调用中堵塞了，也不影响整个进程继续工作。</li><li>缺点：各种线程操作都需要进行系统调用，代价相对高，需要在<strong>用户态和内核态</strong>中来回切换。另外轻量级进程的数量是有限的。</li><li>轻量级进程与内核线程是1:1的关系</li></ul></li><li><h3 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h3><blockquote><p>广义：一个线程只要不是内核线程，就可以认为是用户线程</p><p>狭义：完全建立在用户空间的线程库上，而系统内核不能感知线程存在的实现</p></blockquote><ul><li>优点：线程的建立、同步、销毁和调度都在用户态中完成，不需要内核参与，所以操作时非常快速且低消耗，还支持更大的线程数量</li><li>缺点：没有系统内核的支持，所有线程操作都需要用户程序自己处理，实现较复杂</li><li>进程与用户线程之间是1:N的关系</li></ul></li><li><h3 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h3><blockquote><p>既存在用户线程，也存在轻量级进程。</p></blockquote><ul><li>优点：用户线程还是在用户空间中，还可以支持大规模的用户线程并发；轻量级进程可以作为内核线程和用户线程之间的桥梁，用户线程的系统调用需要轻量级进程来完成，大大降低了系统被阻塞的危险。</li><li>采用多对多的线程模型。</li></ul></li></ul><p>Java线程的实现是不能确定的。<strong>由于操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的。</strong></p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><blockquote><p>系统为线程分配处理器使用权的过程。</p></blockquote><p>主要调度方式有两种：</p><ul><li><h3 id="协同式线程调度"><a href="#协同式线程调度" class="headerlink" title="协同式线程调度"></a>协同式线程调度</h3><blockquote><p>线程的执行时间有 <strong>线程本身</strong> 控制，线程把自己的工作执行完后，要主动通知系统切换到另一个线程上。</p></blockquote><ul><li>优点：实现简单，切换操作可知，基本不存在线程同步问题</li><li>缺点：线程执行时间不可控</li></ul></li><li><h3 id="抢占式线程调度"><a href="#抢占式线程调度" class="headerlink" title="抢占式线程调度"></a>抢占式线程调度</h3><blockquote><p>每个线程由系统分配执行时间，线程的切换不由线程本身决定</p></blockquote><ul><li><p>线程执行时间是可控的，不存在因为一个线程而堵塞整个系统的问题</p></li><li><p>可以设置<strong>线程优先级</strong>，优先级越高的线程越容易被系统选择执行</p><p><code>线程优先级并不是太靠谱，一方面线程调度还是取决于操作系统，优先级的实现不会太一致。另一方面优先级会被系统自行改变。</code></p></li></ul></li></ul><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><blockquote><p>在任意时间点，一个线程有且只有一个状态</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Thread-State.png" srcset="/img/loading.gif" class="full-image" alt="线程状态转换" title="线程状态转换"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><blockquote><p>线程创建后尚未启动的线程状态</p></blockquote></li><li><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><blockquote><p>包括正在执行和等待着CPU为它分配执行时间</p></blockquote></li><li><h3 id="无限期等待"><a href="#无限期等待" class="headerlink" title="无限期等待"></a>无限期等待</h3><blockquote><p>不会被分配CPU执行时间，要等待被其他线程显示的唤醒。以下方法会让线程陷入无限期的等待状态：</p><ol><li>没有设置Timeout参数的<code>Object,wait()</code></li><li>没有设置Timeout参数的<code>Thread.join()</code></li><li><code>LockSupport.park()</code></li></ol></blockquote></li><li><h3 id="限期等待"><a href="#限期等待" class="headerlink" title="限期等待"></a>限期等待</h3><blockquote><p>不会被分配CPU执行时间，但在一定时间后会被系统唤醒。以下方法会让线程进入限期等待状态：</p><ol><li><code>Thread.sleep()</code></li><li>设置Timeout参数的<code>Object,wait()</code></li><li>设置Timeout参数的<code>Thread.join()</code></li><li><code>LockSupport.parkNanos()</code></li><li><code>LockSupport.parkUntil()</code></li></ol></blockquote></li><li><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><blockquote><p>线程被阻塞了 在程序等待进入同步区域的时候进入这种状态。</p><p><strong>阻塞状态</strong>：等待着获取到一个<strong>排他锁</strong>，将在另一个线程放弃这个锁的时候发生</p><p><strong>等待状态</strong>：在等待一段时间或者唤醒动作的发生</p></blockquote></li><li><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><blockquote><p>线程已经结束执行</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-synchronized关键字分析</title>
    <link href="/2018/12/18/Java-synchorized%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/"/>
    <url>/2018/12/18/Java-synchorized%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized场景"><a href="#synchronized场景" class="headerlink" title="synchronized场景"></a><code>synchronized</code>场景</h2><p>一般用在以下场景</p><h3 id="修饰实例方法（锁定当前对象实例）"><a href="#修饰实例方法（锁定当前对象实例）" class="headerlink" title="修饰实例方法（锁定当前对象实例）"></a>修饰实例方法（锁定当前对象实例）</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedInstance</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//...</span>  &#125;&#125;</code></pre><blockquote><p>锁定的是访问该方法的实例对象，如果在多个线程中的不同对象访问该方法，则不可保证互斥同步效果</p></blockquote><h3 id="修饰静态方法-锁定当前类Class对象"><a href="#修饰静态方法-锁定当前类Class对象" class="headerlink" title="修饰静态方法(锁定当前类Class对象)"></a>修饰静态方法(锁定当前类Class对象)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedStatic</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//...</span>  &#125;&#125;</code></pre><blockquote><p>由于静态方法是类方法，所以锁的是包含这个方法的类，也就是类对象；如果多个线程调用不同实例对象，也会有互斥同步效果</p></blockquote><h3 id="修饰代码块-锁定指定对象"><a href="#修饰代码块-锁定指定对象" class="headerlink" title="修饰代码块(锁定指定对象)"></a>修饰代码块(锁定指定对象)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Suingleton mInstance;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span>(mInstance==<span class="hljs-keyword">null</span>)&#123;      <span class="hljs-keyword">synchronized</span>(Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;        <span class="hljs-keyword">if</span>(mInstance==<span class="hljs-keyword">null</span>)&#123;          mInstance = <span class="hljs-keyword">new</span> Singleton();        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> mInstance;  &#125;&#125;</code></pre><blockquote></blockquote><blockquote><p><code>synchronized</code>可作用于一段代码或方法，既可以保证可见性也可以保证原子性。</p><p><strong>可见性</strong>：通过<code>synchronized</code>能保证同一个时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前将会对变量的修改刷新到主存中。</p><p><strong>原子性</strong>：要么不执行，要么执行到底。</p><p>锁类型为：<strong>可重入锁，非公平锁，独占锁，互斥锁</strong></p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/synchronized.png" srcset="/img/loading.gif" class="full-image" alt="synchronized关键字" title="synchronized关键字"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="synchronized作用"><a href="#synchronized作用" class="headerlink" title="synchronized作用"></a><code>synchronized</code>作用</h2><ul><li>确保线程互斥的访问代码块，同一时刻只有一个方法进入临界区，其他线程必须等到当前线程执行完毕才能使用。</li><li>保证共享变量的修改能即时可见</li><li>有效解决重排序问题</li></ul><h2 id="synchronized使用"><a href="#synchronized使用" class="headerlink" title="synchronized使用"></a><code>synchronized</code>使用</h2><h3 id="修饰实例方法，锁的是当前对象实例-this"><a href="#修饰实例方法，锁的是当前对象实例-this" class="headerlink" title="修饰实例方法，锁的是当前对象实例(this)"></a>修饰实例方法，锁的是当前对象实例(this)</h3><blockquote><p>一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedMethodTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.err.println(<span class="hljs-string">"method1 finish"</span> + System.currentTimeMillis());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">2000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.err.println(<span class="hljs-string">"method2 finish"</span>+ System.currentTimeMillis());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-keyword">final</span> SynchronizedMethodTest test =<span class="hljs-keyword">new</span> SynchronizedMethodTest();        <span class="hljs-keyword">new</span> Thread(test::method1).start();        <span class="hljs-keyword">new</span> Thread(test::method2).start();    &#125;&#125;输出结果：method1 finish <span class="hljs-number">1545188801152</span>method2 finish <span class="hljs-number">1545188803157</span></code></pre><h3 id="修饰静态方法，锁的是当前Class对象-静态方法属于类，而不是对象"><a href="#修饰静态方法，锁的是当前Class对象-静态方法属于类，而不是对象" class="headerlink" title="修饰静态方法，锁的是当前Class对象(静态方法属于类，而不是对象)"></a>修饰静态方法，锁的是当前Class对象(静态方法属于类，而不是对象)</h3><blockquote><p>由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedStaticMethodTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.err.println(<span class="hljs-string">"method1 finish"</span> + System.currentTimeMillis());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">2000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.err.println(<span class="hljs-string">"method2 finish"</span> + System.currentTimeMillis());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(SynchronizedStaticMethodTest::method1).start();        <span class="hljs-keyword">new</span> Thread(SynchronizedStaticMethodTest::method2).start();    &#125;&#125;输出结果method1 finish <span class="hljs-number">1545189344322</span>method2 finish <span class="hljs-number">1545189346327</span></code></pre><h3 id="修饰代码块，锁的是括号里的对象"><a href="#修饰代码块，锁的是括号里的对象" class="headerlink" title="修饰代码块，锁的是括号里的对象"></a>修饰代码块，锁的是括号里的对象</h3><blockquote><p>修饰代码块 其中普通代码块 如<code>synchronized（obj）</code> 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；<br>Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。<br>Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。</p><p><strong>就是 Synchronized代码块更加灵活精确。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedCodeBlockTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.err.println(<span class="hljs-string">"method1 finish"</span> + System.currentTimeMillis());        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">2000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.err.println(<span class="hljs-string">"method2 finish"</span> + System.currentTimeMillis());        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> SynchronizedCodeBlockTest test =<span class="hljs-keyword">new</span> SynchronizedCodeBlockTest();        <span class="hljs-keyword">new</span> Thread(test::method1).start();        <span class="hljs-keyword">new</span> Thread(test::method2).start();    &#125;&#125;输出结果：method1 finish <span class="hljs-number">1545189694303</span>method2 finish <span class="hljs-number">1545189696308</span></code></pre><h3 id="修饰代码块，但是指定了修饰类，此时锁的是括号里的Class类对象"><a href="#修饰代码块，但是指定了修饰类，此时锁的是括号里的Class类对象" class="headerlink" title="修饰代码块，但是指定了修饰类，此时锁的是括号里的Class类对象"></a>修饰代码块，但是指定了修饰类，此时锁的是括号里的Class类对象</h3><blockquote><p>Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">synchronized</span>(Test<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;            <span class="hljs-keyword">try</span>&#123;                Thread.sleep(<span class="hljs-number">500</span>);            &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="synchronized锁的区别"><a href="#synchronized锁的区别" class="headerlink" title="synchronized锁的区别"></a><code>synchronized</code>锁的区别</h2><h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3><blockquote><p>类似<code>synchronized(this)</code>就为对象锁的一种，其他的还包括<code>synchronized</code>修饰的实例方法<code>public synchronized void method()</code>。</p></blockquote><p><strong>控制方法间的同步。</strong>Java中的所有对象都包含一个<code>互斥锁</code>，这个锁由JVM自动获取和释放。当线程进入<code>synchronized</code>的时候会获取该对象的锁，如果有其他线程已经获得了这个对象锁，当前线程就需要等待其他线程执行完毕——<code>synchronized</code>正常返回或者抛出异常终止。JVM就会自动释放该锁。</p><h3 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h3><blockquote><p>类似<code>synchronized(obj.class)</code>就为类锁的一种，其他还包括<code>synchronized</code>修饰的静态方法<code>public synchronized static void method()</code>。</p></blockquote><p><strong>控制静态方法之间的同步。</strong>由于Java类中只会有一个Class对象，类的不同实例之间共享该类的Class对象。类锁对应的锁数量也就只有一个，就是锁住Class对象。</p><table><thead><tr><th>类型</th><th>锁对象</th><th>锁的数量</th><th>实现形式</th><th>使用场景</th></tr></thead><tbody><tr><td>对象锁(包括实例方法锁)</td><td>实例对象</td><td>多个<br>类的对象实例可以有多个</td><td><code>synchronized void method()</code><br><code>synchronized(this){}</code></td><td>控制方法间的同步</td></tr><tr><td>类锁(包括静态方法锁)</td><td>类对象</td><td>1个<br>一个类只会有一个类对象</td><td><code>synchronized static void method()</code><br><code>synchronized(obj.class)</code></td><td>控制静态方法间的同步</td></tr></tbody></table><h2 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a><code>synchronized</code>原理</h2><p>JVM基于进入和退出<code>monitor</code>对象来实现<strong>代码块同步</strong>和<strong>方法同步</strong>。</p><ul><li><p><strong>代码块同步</strong></p><p>在编译后通过<code>monitorenter</code>插入到同步代码的开始处，将<code>monitorexit</code>插入到代码结束处和异常处，反编译字节码时就可以看到相关指令。<strong>JVM要保证每个monitorenter必须有对应的monitorexit。</strong></p><p><code>monitorenter</code>：每个对象都有一个监视器锁(<code>monitor</code>)，当某个monitir被某个线程占用时就会处于锁定状态，线程执行<code>monitorenter</code>指令时会尝试获取<code>monitor</code>的所有权，尝试获取对象的锁。</p><ul><li>monitor进入数为0，则该进程进入monitor，然后将进入数置为1，该进程即为monitor的持有者</li><li>如果线程已占有monitor，只是重新进入，则monitor进入数+1</li><li>如果其他线程已占用monitor，则该线程处于堵塞状态，直至monitor进入数为0，在尝试重新获取monitor的所有权</li></ul><p><code>monitorexit</code>：执行<code>monitorexit</code>的线程必须是objectref所对应的monitor持有者。指令执行时，monitor进入数-1，如果-1后进入数为0，则线程退出monitor，不再是monitor持有者。其他被这个monitor阻塞的线程就可以尝试去获取monitor。</p><blockquote><p>反编译命令 <code>javap -v **.class</code></p></blockquote><pre><code class="hljs java"> 3: monitorenter 4: ldc2_w        #16                 // long 2000l 7: invokestatic  #4                  // Method java/lang/Thread.sleep:(J)V  ...45: aload_146: monitorexit47: goto          5550: astore_351: aload_152: monitorexit</code></pre></li><li><p><strong>方法同步</strong></p><p><code>synchronized</code>在<code>method_info</code>会添加<code>ACC_synchronized</code>标记，线程执行会识别该标记，获取对应的锁。</p><pre><code class="hljs java">public synchronized void method2();    descriptor: ()V    flags: ACC_PUBLIC, ACC_SYNCHRONIZED    Code:      stack=4, locals=2, args_size=1         0: ldc2_w        #16                 // long 2000l         3: invokestatic  #4                  // Method java/lang/Thread.sleep:(J)V</code></pre></li></ul><p>两者实现细节不同，<strong>本质上都是对一个对象的监视器(monitor)获取，任意一个对象都拥有自己的监视器。</strong>当这个对象由代码块同步或者方法同步调用时，<strong>执行方法的线程必须先获取对象的监视器才能进入同步块或同步方法，没有获取到对象监视器的线程就会被堵塞在入口处，变为Blocked堵塞状态。当成功获取监视器线程释放了锁后，会唤醒堵塞的同步队列的线程，使其重新尝试获取监视器。</strong></p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/synchronized-monitor.png" srcset="/img/loading.gif" class="full-image" alt="同步方法关系" title="同步方法关系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>理解Java中的synchronized关键字。<br>指标：理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。</p><p>有如下一个类A</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><p>然后创建两个对象</p><pre><code class="hljs java">A a1 = <span class="hljs-keyword">new</span> A();A a2 = <span class="hljs-keyword">new</span> A();</code></pre><p>然后在两个线程中并发访问如下代码：<br>Thread1                       Thread2<br>a1.a();                       a2.a();</p><p>请问二者能否构成线程同步？</p><p>如果A的定义是下面这种呢？</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。</p><blockquote><p>Synchronized作用:</p></blockquote><ul><li>确保线程互斥的访问同步代码块</li><li>保证共享变量的修改能够及时可见</li><li>有效解决重排序问题</li></ul><blockquote><p>wait(),notify(),notifyAll(),sleep()作用</p></blockquote><ul><li>wait 调用线程 释放锁，然后进入休眠</li><li>sleep thread的一个操作方法，不释放锁直接进入休眠</li><li>notify 唤醒等待队列中的第一个相关进程</li><li>notifyAll 唤醒所有</li></ul><blockquote><p>Synchronized主修修饰对象为以下三种：</p></blockquote><ol><li>修饰普通方法 一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。</li><li>修饰静态方法 由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。</li><li>修饰代码块 其中普通代码块 如Synchronized（obj） 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。<br>Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。<br>Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。</li></ol><p>简单来说 就是 Synchronized代码块更加灵活精确。</p><blockquote><p>示例代码</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SyncThread</span><span class="hljs-params">()</span> </span>&#123;        count = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;                <span class="hljs-keyword">try</span> &#123;                    System.err.println(Thread.currentThread().getName() + <span class="hljs-string">" "</span> + (count++));                    Thread.sleep(<span class="hljs-number">100</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre><h1 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;       SyncThread syncThread = <span class="hljs-keyword">new</span> SyncThread();       Thread thread1 = <span class="hljs-keyword">new</span> Thread(syncThread, <span class="hljs-string">"sync1"</span>);       Thread thread2 = <span class="hljs-keyword">new</span> Thread(syncThread, <span class="hljs-string">"sync2"</span>);       thread1.start();       thread2.start();   &#125;</code></pre><p>访问的同一个对象时，同一时刻只能有一个线程执行，执行代码块是会锁定当前对象，所以需要执行完才能释放，下一个线程才能继续执行并锁定对象</p><blockquote><p>运行结果</p></blockquote><pre><code class="hljs log">sync1 0sync1 1sync1 2sync1 3sync1 4sync2 5sync2 6sync2 7sync2 8sync2 9</code></pre><h1 id="修饰对象"><a href="#修饰对象" class="headerlink" title="修饰对象"></a>修饰对象</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;       Thread thread1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> SyncThread(), <span class="hljs-string">"sync1"</span>);       Thread thread2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> SyncThread(), <span class="hljs-string">"sync2"</span>);       thread1.start();       thread2.start();   &#125;</code></pre><p>这时创建了两个SyncThread对象，线程1执行对象1中的同步代码，线程2执行的是对象2的代码，这时两把锁分别锁定SyncThread1和SyncThread2对象，两把锁互不干扰也不互斥，所以同时执行。</p><blockquote><p>运行结果</p></blockquote><pre><code class="hljs log">sync1 0sync2 1sync1 2sync2 3sync1 4sync2 5sync1 6sync2 7sync1 8sync2 9</code></pre><p>问题1 ：不能同步</p><ul><li>a1.a()锁是a1 a2.b()锁是a2 不是同一把锁 所以不同步<br>问题2：能同步</li><li>锁都为A.class对象，是统一把锁</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS操作&amp;Atomic原子操作类分析</title>
    <link href="/2018/12/18/Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    <url>/2018/12/18/Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/CAS.png" srcset="/img/loading.gif" class="full-image" alt="CAS基本知识" title="CAS基本知识"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h1 id="CAS与原子操作"><a href="#CAS与原子操作" class="headerlink" title="CAS与原子操作"></a>CAS与原子操作</h1><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>认为每次访问共享资源时都会发生冲突，必须对每次对象操作进行上锁，以保证临界区的程序同时只能有一个线程执行。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>假设对共享资源的访问不会发生冲突，线程可以不停的执行，无需加锁。</p><p><strong>一旦发生线程冲突，通常都会采用<code>CAS操作</code>保证线程执行的安全性</strong></p><blockquote><p><code>悲观锁</code>适用于<strong>写多读少</strong>的环境，避免频繁失败和重试影响性能。</p><p><code>乐观锁</code>适用于<strong>写少读多</strong>的环境，避免频繁加锁影响性能。</p></blockquote><h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><blockquote><p>CAS是乐观锁技术，当多个线程尝试使用CAS更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程不会被挂起，而是告知竞争失败，并尝试再次发起请求。</p></blockquote><p>CAS指令需要有三个操作数：</p><ul><li><strong>内存位置(V)</strong>：简单的理解为变量的内存地址</li><li><strong>旧的预期值(A)</strong></li><li><strong>新值(B)</strong></li></ul><p>执行CAS操作，当且仅当<code>V</code>符合旧预期<code>A</code>时，处理器就会更新<code>B</code>到<code>V</code>上。否则处理器不做任何操作。</p><pre><code class="hljs java"><span class="hljs-comment">//伪代码实现</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwap</span><span class="hljs-params">(V,A,B)</span></span>&#123;    <span class="hljs-keyword">if</span>(V!=A)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//CAS操作失败</span>    &#125;<span class="hljs-keyword">else</span>&#123;        V=B;<span class="hljs-comment">//替换内存中的值为新值</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//CAS操作成功</span>    &#125;&#125;</code></pre><p><strong>由于CAS是一种原子操作，当多个线程同时使用CAS操作一个变量时，只有一个会成功，并且更新变量，其他线程都会失败。但失败的线程不会被挂起，只是告知失败，并且继续尝试操作变量。</strong></p><h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><blockquote><p><code>compareAndSet()</code>内部是调用Java本地方法<code>compareAndSwapInt()</code>实现的，虚拟机内部对这些方法做了特殊处理，借助C来调用CPU的底层指令保证硬件层面实现原子操作。</p><p>Intel CPU 利用<strong>cmpxchg</strong>指令实现CAS</p></blockquote><p>CAS操作是由<code>sun.misc.Unsafe</code>类里面的<code>computeAndSwapXX()</code>实现的</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,Object expected, Object x)</span></span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,<span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> x)</span></span>;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,<span class="hljs-keyword">long</span> expected,<span class="hljs-keyword">long</span> x)</span></span>;</code></pre><p><code>Unsafe</code>主要提供一些用于执行低级别，不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言等底层资源操作能力方法面起到了很大的作用。</p><p>但由于<code>Unsafe</code>可以操作内存空间，增加了程序发生指针问题的风险。</p><p> <a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html" target="_blank" rel="noopener">Java魔法类：Unsafe应用解析</a></p><h3 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>因为CAS需要在操作值的时候检查值是否发生变化，如果没有发生变化则更新，但如果一个值原来是A，变成了B，再变成了A，对于CAS检查而言就是没有发生过变化，实际已经发生变化。</p><p>解决思路就是利用版本号，在变量前添加版本号，并每次更新时加1，则A-&gt;B-&gt;A 会变为 1A-&gt;2B-&gt;3A。</p><p>可以利用<code>AtomicStampedReference</code>来解决，它内部的<code>compareAndSwap()</code>首先会去检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，全部相等才会替换值。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V   expectedReference,                             V   newReference,                             <span class="hljs-keyword">int</span> expectedStamp,                             <span class="hljs-keyword">int</span> newStamp)</span> </span>&#123;    Pair&lt;V&gt; current = pair;    <span class="hljs-keyword">return</span>        expectedReference == current.reference &amp;&amp;        expectedStamp == current.stamp &amp;&amp; <span class="hljs-comment">//比较标志是否等于预期标志</span>        ((newReference == current.reference &amp;&amp;          newStamp == current.stamp) ||         casPair(current, Pair.of(newReference, newStamp)));&#125;</code></pre><p>也可使用<code>AtomicMarkableReference</code>主要关心的是<strong>引用变量是否发生变化</strong>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V       expectedReference,                             V       newReference,                             <span class="hljs-keyword">boolean</span> expectedMark,                             <span class="hljs-keyword">boolean</span> newMark)</span> </span>&#123;    Pair&lt;V&gt; current = pair;    <span class="hljs-keyword">return</span>        expectedReference == current.reference &amp;&amp;        expectedMark == current.mark &amp;&amp;        ((newReference == current.reference &amp;&amp;          newMark == current.mark) ||         casPair(current, Pair.of(newReference, newMark)));&#125;</code></pre><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>相对于<code>synchronized</code>省去了挂起线程以及恢复线程的开销。CAS是非阻塞同步，不会将线程挂起，会进行自旋（<code>死循环</code>），时间过长会对性能造成很大的消耗。<code>Pause</code>指令</p><h4 id="只能保证一个变量的原子操作"><a href="#只能保证一个变量的原子操作" class="headerlink" title="只能保证一个变量的原子操作"></a>只能保证一个变量的原子操作</h4><p>当对多个变量进行操作时，CAS无法保证原子性操作，这时可以用锁或者<code>AtomicReference</code>保证引用对象之间的原子性，就可以把多个变量放在一个对象里进行操作。</p><h2 id="Atomic原子操作类"><a href="#Atomic原子操作类" class="headerlink" title="Atomic原子操作类"></a>Atomic原子操作类</h2><blockquote><p>方便在多线程环境下，无锁的进行原子操作。<strong>提供非阻塞的线程安全编程</strong></p></blockquote><h3 id="类摘要"><a href="#类摘要" class="headerlink" title="类摘要"></a>类摘要</h3><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>AtomicInteger</td><td>更新int</td></tr><tr><td>AtomicBoolean</td><td>更新boolean</td></tr><tr><td>AtomicLong</td><td>更新long</td></tr><tr><td>AtomicIntegerArray</td><td>更新int数组</td></tr><tr><td>AtomicIntegerFieldUpdater</td><td>基于反射，可以对指定类的指定<code></code>volatile int`字段进行更新</td></tr><tr><td>AtomicLongArray</td><td>更新long数组</td></tr><tr><td>AtomicLongFieldUpdater</td><td>基于反射，可以对指定类的指定<code>volatile long</code>字段进行更新</td></tr><tr><td>AtomicMarkableReference</td><td>维护带有标记的对象引用，可以更新</td></tr><tr><td>AtomicReference</td><td>更新对象引用</td></tr><tr><td>AtomicReferenceArray</td><td>更新对象引用数组</td></tr><tr><td>AtomicReferenceFieldUpdater</td><td>基于反射，可以对指定类的指定volatile 字段进行更新</td></tr><tr><td>AtomicStampedReference</td><td>维护带有整数标志的对象引用，可以更新</td></tr></tbody></table><p>Java 8之后新增了4个新的原子操作类</p><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>LongAdder</td><td>更新long</td></tr><tr><td>DoubleAdder</td><td>更新double</td></tr><tr><td>LongAccumulator</td><td>更新long</td></tr><tr><td>DoubleAccumulator</td><td>更新double</td></tr></tbody></table><p>上述四个类引用<code>多段锁</code>的概念。<strong>通过CAS保证原子性，通过自旋保证当次修改的最终修改成功，通过降低锁粒度（多段锁）增加并发性能。</strong> 他们<strong>属于原子累加器，适用于数据统计以及高并发环境，不适用于其他粒度的应用。</strong></p><blockquote><p><code>原子累加器</code>使用了<strong>热点分离</strong>思想</p><p><strong>热点分离</strong>：①将竞争的数据进行分解成多个单元，在每个单元中分别进行数据处理 ②各单元处理完成后，通过<code>Hash算法</code>进行求和，从而得到最终结果</p><p><code>热点分离</code>减小了锁的粒度，提供并发环境下的吞吐量，但需要额外空间存储数据，增大空间消耗。</p></blockquote><h3 id="如何保证原子操作"><a href="#如何保证原子操作" class="headerlink" title="如何保证原子操作"></a>如何保证原子操作</h3><p>内部都实现了一个<code>compareAndSet()</code>方法</p><pre><code class="hljs java">     // setup to use Unsafe.compareAndSwapInt for updates    private static final Unsafe unsafe = Unsafe.getUnsafe();    private static final long valueOffset;    static &#123;        try &#123;            valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField("value"));        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;    &#125;    //用volatile修饰 value 保证可见性    private volatile int value;public final boolean compareAndSet(int expect, int update) &#123;        return unsafe.compareAndSwapInt(this, valueOffset/*V 内存地址*/, expect/*A 旧的预期值*/, update/*B 修改值*/);    &#125;</code></pre><p><code>compareAndSwap()</code>涉及了两个重要对象，一个是<code>unsafe</code>另一个是<code>valueOffset</code>。</p><p><code>unsafe</code>是JVM提供的一个后门，用来执行 <strong>硬件级别的原子操作</strong>。</p><p><code>valueOffset</code>是通过<code>unsafe</code>获取到的，代表 <strong>AtomicInteger对象value成员变量在内存中的偏移量</strong>。可以简单的认为是<em>value变量的内存地址</em>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile关键字分析</title>
    <link href="/2018/12/17/Java-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/"/>
    <url>/2018/12/17/Java-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<!--缓存一致性 指令重排序概念--><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/volatile.png" srcset="/img/loading.gif" class="full-image" alt="volatile相关概念" title="volatile相关概念"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="volatile基础概念"><a href="#volatile基础概念" class="headerlink" title="volatile基础概念"></a>volatile基础概念</h2><p><strong><em>volatile的主要作用是保证可见性以及有序性，不一定保证原子性。</em></strong></p><p><strong>JVM提供的最轻量级的同步机制。</strong></p><p>当一个变量被<code>volatile</code>关键字修饰后，就会具备两层语义：</p><ul><li><strong>保证此变量对所有线程的可见性，这里指  当一条线程修改了这个变量的值，新值对于其他线程来说是立即可得知的。</strong></li><li><strong>禁止进行指令重排序优化</strong></li></ul><h3 id="volatile-保证可见性"><a href="#volatile-保证可见性" class="headerlink" title="volatile 保证可见性"></a>volatile 保证可见性</h3><p>在使用<code>volatile</code>关键字修饰一个变量后，该变量在一个线程中被修改后，会发生如下事情：</p><ol><li>修改后，修改的变量值会强制立即写入主内存中</li><li>然后强制过期其他线程中工作内存中的缓存，使缓存无效</li><li>由于缓存无效，其他线程需要读取该变量值时，会强制重新从主内存中读取</li></ol><blockquote><p>当访问共享变量时，多个线程也会在自己的工作内存中有一份共享变量的副本。当某个线程更改了自己工作内存中的数据时，由于某些原因（线程阻塞）没有及时的刷新数据至主内存，然后其他线程的工作内存中的数据还是老数据。就会导致<code>缓存一致性</code>问题。</p><p><strong>缓存一致性</strong>：当其他线程读取该变量时，发现该缓存是无效的，就会从主内存中重新读取。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/volatile-process.png" srcset="/img/loading.gif" class="full-image" alt="volatile可见性" title="volatile可见性"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="volatile-保证有序性"><a href="#volatile-保证有序性" class="headerlink" title="volatile 保证有序性"></a>volatile 保证有序性</h3><p><code>volatile</code>禁止指令重排序，可以在一定程度上保证有序性。</p><p><strong>指令重排序</strong>：JVM为了优化指令，提高程序运行效率，在不影响<strong>单线程</strong>执行结果的前提下，尽可能的提高并行度。</p><p>volatile关键字通过提供“<strong>内存屏障(重排序时不能把后面的指令重排序到内存屏障之前的位置)</strong>”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<code>加入volatile关键字的代码会多出一个lock前缀指令</code>。</p><p>内存屏障提供如下功能：</p><ul><li>重排序时不会把后面的指令重排序到内存屏障之前的位置—<code>有序性</code></li><li>本CPU的Cache立即写入内存，并且会引起别的CPU或者别的内核无效化其Cache，可以是对volatile变量的修改对其他CPU可见—<code>可见性</code></li></ul><p><code>内存屏障</code>在<code>volatile</code>读写时是不同位置插入<code>lock</code>指令</p><ul><li><p><code>volatile读</code></p><p>在<code>volatile读</code>操作后分别插入<code>LoadLoad</code>和<code>LoadStore</code>屏障</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/volatile读.webp" srcset="/img/loading.gif" class="full-image" alt="volatile读" title="volatile读"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>LoadLoad</code>屏障：禁止<code>volatile读</code>与后面的普通读进行重排序</p><p><code>LoadStore</code>屏障：禁止<code>volatile读</code>与后面的普通写进行重排序</p></li><li><p><code>volatile写</code></p><p>在<code>volatile写</code>操作前后分别插入<code>StoreStore</code>和<code>StoreLoad</code>屏障</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/volatile写.webp" srcset="/img/loading.gif" class="full-image" alt="volatile写" title="volatile写"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>StoreStore</code>屏障：保证<code>volatile写</code>之前的普通写操作已经对所有线程可见，该屏障保证<strong>前面的所有普通写操作的值都刷新到主内存。</strong></p><p><code>StoreLoad</code>屏障：禁止<code>volatile写</code>与后面可能存在的<code>volatile读/写</code>进行重排序。</p></li></ul><h3 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h3><p><code>volatile</code>只能保证对单个volatile变量的读/写具有原子性，但是对于<code>volatile++</code>这样的复合操作没办法。</p><p>自增操作 <code>volatile++</code>实际执行了三步：</p><ol><li>读取变量的初始值</li><li>在CPU中加1</li><li>重新写入工作内存，在写入主内存</li></ol><p>要想保证原子性，只能借助于<code>synchronized、Lock和java.util.concurrent.atomic包下的原子操作类</code>保证这些操作时原子性操作。</p><h2 id="volatile应用场景"><a href="#volatile应用场景" class="headerlink" title="volatile应用场景"></a>volatile应用场景</h2><p><code>volatile</code>由于无法保证原子性，所以要使用必须具备以下两个条件：</p><ul><li><p>对变量的写操作不依赖于当前值 </p><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span> ;a = a * <span class="hljs-number">2</span>;</code></pre></li><li><p>该变量没有包含在具有其他变量的不变式中</p></li></ul><p>  <strong><em>在多线程场景下，这两种情况即时使用<code>volatile</code>修饰，也有可能会有同步问题。</em></strong></p><h2 id="volatile使用实例"><a href="#volatile使用实例" class="headerlink" title="volatile使用实例"></a>volatile使用实例</h2><ol><li><p>状态量标记</p><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> bool flag = <span class="hljs-keyword">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span>&#123;    flag = <span class="hljs-keyword">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span>(flag)&#123;        doSth();    &#125;&#125;</code></pre></li><li><p>单例模式的实现(DCL)</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;            &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton sInstance;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstence</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(sInstance == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span>(Sineleton<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;                <span class="hljs-keyword">if</span>(sInstance == <span class="hljs-keyword">null</span>)&#123;                    sInstance = <span class="hljs-keyword">new</span> Singleton();                  <span class="hljs-comment">/**                  * 1.内存中创建对象                  * 2.分配内存，并将指针指向内存区域                  * 如果此时发生指令重排序，可能导致构造函数在初始化对象完成就赋值完成，导致其他线程获取对象为空，所以使用volatile进行修饰，避免指令重排序                  */</span>                &#125;            &#125;         &#125;         <span class="hljs-keyword">return</span> sInstance;    &#125;&#125;</code></pre></li></ol><h2 id="volatile和-synchronized区别"><a href="#volatile和-synchronized区别" class="headerlink" title="volatile和 synchronized区别"></a>volatile和 synchronized区别</h2><ul><li><code>volatile</code>仅能使用在变量级别，<code>synchronized</code>适用于变量、方法和类</li><li><code>volatile</code>仅能实现变量修改可见性，不保证原子性；<code>synchronized</code>可以保证可见性及原子性</li><li><code>volatile</code>不会造成线程的阻塞；<code>synchronized</code>会造成阻塞(<code>阻塞同步</code>)</li><li><code>volatile</code>由于禁止指令重排序，不会被编译器优化；<code>synchronized</code>会被优化</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/5ea913d35188256d4576d199#heading-17" target="_blank" rel="noopener">volatile</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DiskLruCache源码分析</title>
    <link href="/2018/12/17/DiskLruCache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2018/12/17/DiskLruCache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>可以将缓存数据持久化的存储到磁盘上，并且使用<code>LRU算法</code>维持缓存在一个固定的大小。</p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现自定义图片加载框架</title>
    <link href="/2018/12/17/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/"/>
    <url>/2018/12/17/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>View的工作原理</title>
    <link href="/2018/12/14/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2018/12/14/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<!--MeasureSpec是什么？有什么作用？，自定义View/ViewGroup需要注意什么？invalidate()和postInvalidate()的区别？,invalidate和postInvalidate的区别及使用 Requestlayout，onlayout，onDraw，DrawChild区别与联系  View刷新机制  View绘制流程  计算一个view的嵌套层级（递归）  onMeasure的具体过程，先measure子view还是自己  onDraw的具体过程，先draw子view还是自己  实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展 view的工作原理及measure、layout、draw流程。哪一个流程可以放在子线程中去执行？draw方法中需要注意的问题？Invalidate、postInvalidate、requestLayout应用场景 TextView.setText()调用什么方法去刷新 --><p><img src="/images/View工作原理.png" srcset="/img/loading.gif" alt="View工作原理"></p><a id="more"></a><h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><p><code>Window</code>是一个抽象类，提供了各种窗口操作方法。每个Activity都会持有一个<code>Window</code>。</p><p><code>PhoneWindow</code>是<code>Window</code>唯一实现类，在<code>Activity.attach()</code>进行初始化</p><pre><code class="hljs java"><span class="hljs-comment">//ActivityThread.java</span><span class="hljs-comment">//Activity开始启动</span><span class="hljs-function"><span class="hljs-keyword">public</span> Activity <span class="hljs-title">handleLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r,            PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123; ...    <span class="hljs-keyword">final</span> Activity a = performLaunchActivity(r, customIntent);&#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;      <span class="hljs-comment">//创建Application对象</span>            Application app = r.packageInfo.makeApplication(<span class="hljs-keyword">false</span>, mInstrumentation);            <span class="hljs-comment">//Activity初始化</span>       activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,                        r.ident, app, r.intent, r.activityInfo, title, r.parent,                        r.embeddedID, r.lastNonConfigurationInstances, config,                        r.referrer, r.voiceInteractor, window, r.configCallback);    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//Activity.java</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context, ActivityThread aThread,            Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,            Application application, Intent intent, ActivityInfo info,            CharSequence title, Activity parent, String id,            NonConfigurationInstances lastNonConfigurationInstances,            Configuration config, String referrer, IVoiceInteractor voiceInteractor,            Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;      ...        <span class="hljs-comment">//初始化PhoneWindow对象</span>        mWindow = <span class="hljs-keyword">new</span> PhoneWindow(<span class="hljs-keyword">this</span>, window, activityConfigCallback);        mWindow.setWindowControllerCallback(<span class="hljs-keyword">this</span>);      <span class="hljs-comment">//绑定Window对象</span>        mWindow.setCallback(<span class="hljs-keyword">this</span>);          &#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//PhoneWindow.java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneWindow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Window</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MenuBuilder</span>.<span class="hljs-title">Callback</span> </span>&#123;    <span class="hljs-comment">// This is the top-level view of the window, containing the window decor.</span>    <span class="hljs-keyword">private</span> DecorView mDecor;<span class="hljs-comment">//对应DecorView  </span>&#125;</code></pre><h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><p><strong>DecorView是整个Window界面的最顶层View。</strong> <em>可以使用Android Studio自带的Layout Inspector查看页面层级</em></p><h3 id="DecorView的布局结构"><a href="#DecorView的布局结构" class="headerlink" title="DecorView的布局结构"></a>DecorView的布局结构</h3><p>一般情况下<code>DecorView</code>会包含一个竖直方向的LinearLayout，该LinearLayout分为上下两个部分，上面是标题栏(<code>titlebar</code>)，下面是内容栏(<code>继承自FrameLayout 且id为content</code>)。因此我们设置Activity的布局方法叫做<code>setContentView()</code>，因为他们都被加进了<code>id为content的FrameLayout</code>中。</p><p>我们可以利用<code>ViewGroup content = findViewById(R.android.id.content)</code>获取conetnt。使用<code>content.getChildAt(0)</code>获取设置的Activity布局。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/Activity.java</span>    <span class="hljs-keyword">public</span> &lt;T extends View&gt; <span class="hljs-function">T <span class="hljs-title">findViewById</span><span class="hljs-params">(@IdRes <span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-comment">//从Window中去获取View</span>        <span class="hljs-keyword">return</span> getWindow().findViewById(id);    &#125;<span class="hljs-comment">// ../android/view/Window.java</span>    <span class="hljs-keyword">public</span> &lt;T extends View&gt; <span class="hljs-function">T <span class="hljs-title">findViewById</span><span class="hljs-params">(@IdRes <span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-comment">//从DecorView获取View</span>        <span class="hljs-keyword">return</span> getDecorView().findViewById(id);    &#125;</code></pre><p>所有的View都会从DecorView中开始检索，所以<strong>View层的事件都会先经过DecorView，再传递到我们定义的View上</strong>。</p><h3 id="setContentView-过程"><a href="#setContentView-过程" class="headerlink" title="setContentView()过程"></a>setContentView()过程</h3><blockquote><p>通过<code>setContentView()</code>将需要加载的布局放到<code>DecorView</code>中</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//Activity.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;        getWindow().setContentView(layoutResID);        initWindowDecorActionBar();    &#125;</code></pre><p><code>Activity.setContentView()</code>调用<code>PhoneWindow.setContentView()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;    <span class="hljs-comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span>    <span class="hljs-comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span>    <span class="hljs-comment">// before this happens.</span>    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//创建DecorView</span>        installDecor();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;        mContentParent.removeAllViews();    &#125;    <span class="hljs-keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;        <span class="hljs-keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,                getContext());        transitionTo(newScene);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//开始加载对应布局</span>        mLayoutInflater.inflate(layoutResID, mContentParent);    &#125;    mContentParent.requestApplyInsets();    <span class="hljs-keyword">final</span> Callback cb = getCallback();    <span class="hljs-keyword">if</span> (cb != <span class="hljs-keyword">null</span> &amp;&amp; !isDestroyed()) &#123;        cb.onContentChanged();    &#125;    mContentParentExplicitlySet = <span class="hljs-keyword">true</span>;&#125;</code></pre><p><code>setContentView()</code>主要执行以下两步：</p><h4 id="installDecor-——创建DecorView"><a href="#installDecor-——创建DecorView" class="headerlink" title="installDecor()——创建DecorView"></a><code>installDecor()</code>——创建DecorView</h4><blockquote><p>基础<code>DecorView</code>主要包含两部分，标题<code>title_bar</code>和内容<code>content</code></p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//PhoneWindow.java</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installDecor</span><span class="hljs-params">()</span> </span>&#123;        mForceDecorInstall = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (mDecor == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//生成DecoeView</span>            mDecor = generateDecor(-<span class="hljs-number">1</span>);            ...        &#125; <span class="hljs-keyword">else</span> &#123;            mDecor.setWindow(<span class="hljs-keyword">this</span>);        &#125;        <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;           <span class="hljs-comment">//根据DecorView生成子View</span>            mContentParent = generateLayout(mDecor);          ...        &#125; &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> DecorView <span class="hljs-title">generateDecor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> featureId)</span> </span>&#123;        Context context;        <span class="hljs-keyword">if</span> (mUseDecorContext) &#123;            Context applicationContext = getContext().getApplicationContext();            <span class="hljs-keyword">if</span> (applicationContext == <span class="hljs-keyword">null</span>) &#123;                context = getContext();            &#125; <span class="hljs-keyword">else</span> &#123;                context = <span class="hljs-keyword">new</span> DecorContext(applicationContext, getContext());                <span class="hljs-keyword">if</span> (mTheme != -<span class="hljs-number">1</span>) &#123;                    context.setTheme(mTheme);                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            context = getContext();        &#125;      <span class="hljs-comment">// 生成DecorView对象</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecorView(context, featureId, <span class="hljs-keyword">this</span>, getAttributes());    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> ViewGroup <span class="hljs-title">generateLayout</span><span class="hljs-params">(DecorView decor)</span> </span>&#123;      ...        <span class="hljs-keyword">int</span> layoutResource;        <span class="hljs-keyword">int</span> features = getLocalFeatures();        <span class="hljs-keyword">if</span> ((features &amp; (<span class="hljs-number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="hljs-number">0</span>) &#123;            layoutResource = R.layout.screen_swipe_dismiss;            setCloseOnSwipeEnabled(<span class="hljs-keyword">true</span>);             &#125;...         <span class="hljs-keyword">else</span>&#123;           layoutResource = R.layout.screen_simple; <span class="hljs-comment">//默认布局</span>         &#125;         mDecor.startChanging();         <span class="hljs-comment">//开始加载布局</span>         mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);         <span class="hljs-comment">//根据id找到 content</span>         ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);<span class="hljs-comment">//com.android.internal.R.id.content</span>         ...         <span class="hljs-keyword">return</span> contentParent;    &#125;<span class="hljs-comment">//DecorView.java</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onResourcesLoaded</span><span class="hljs-params">(LayoutInflater inflater, <span class="hljs-keyword">int</span> layoutResource)</span> </span>&#123;        <span class="hljs-keyword">final</span> View root = inflater.inflate(layoutResource, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (mDecorCaptionView != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (mDecorCaptionView.getParent() == <span class="hljs-keyword">null</span>) &#123;                addView(mDecorCaptionView,                        <span class="hljs-keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));            &#125;            mDecorCaptionView.addView(root,                    <span class="hljs-keyword">new</span> ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//解析得到的View放到DecorView中</span>            addView(root, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));        &#125;        mContentRoot = (ViewGroup) root;    &#125;</code></pre><p><code>installDecor()</code>主要负责创建<code>DecorView</code>并执行<code>generateLayout()</code>生成<code>contentParent</code>将自定义的布局放入其中。</p><h4 id="inflate-layoutResID-mContentParent-——加载布局"><a href="#inflate-layoutResID-mContentParent-——加载布局" class="headerlink" title="inflate(layoutResID, mContentParent)——加载布局"></a>inflate(layoutResID, mContentParent)——加载布局</h4><p><code>inflate()</code>主要将<code>layoutResID</code>加载成具体的View，并加入到<code>mContentParent</code>中，进行显示。</p><p><img src="/images/setContentView流程.png" srcset="/img/loading.gif" alt="执行流程"></p><h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><blockquote><p><em>ViewRoot对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程均需通过ViewRoot完成。</em></p></blockquote><h3 id="ViewRootImpl创建时机"><a href="#ViewRootImpl创建时机" class="headerlink" title="ViewRootImpl创建时机"></a>ViewRootImpl创建时机</h3><p>当Activity创建时，最终是调用到<code>ActivityThread</code>的<code>handleLaunchActivity</code>来创建Activity。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123; ...      <span class="hljs-comment">//创建一个Activity 会调用到onCreate()方法 从而完成DecroView的创建</span>      Activity a = performLaunchActivity(r, customIntent);        <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>) &#123;            r.createdConfig = <span class="hljs-keyword">new</span> Configuration(mConfiguration);            reportSizeConfigurations(r);            Bundle oldState = r.state;                        handleResumeActivity(r.token, <span class="hljs-keyword">false</span>, r.isForward,                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);            ...        &#125;    ...&#125;</code></pre><p>上述方法后续调用到了<code>handleResumeActivity()</code>,在这个方法中调用到了<code>WindowManager.addView()</code>将View传递至WindowManager</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(IBinder token,            <span class="hljs-keyword">boolean</span> clearHide, <span class="hljs-keyword">boolean</span> isForward, <span class="hljs-keyword">boolean</span> reallyResume, <span class="hljs-keyword">int</span> seq, String reason)</span> </span>&#123;         ActivityClientRecord r = mActivities.get(token);        <span class="hljs-keyword">if</span> (!checkAndUpdateLifecycleSeq(seq, r, <span class="hljs-string">"resumeActivity"</span>)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        unscheduleGcIdler();        mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// 在这里会调用到生命周期中的onResume方法</span>        r = performResumeActivity(token, clearHide, reason);        ...            <span class="hljs-keyword">if</span>(r!=<span class="hljs-keyword">null</span>)&#123;                ...                <span class="hljs-keyword">final</span> Activity a = r.activity;                ...                <span class="hljs-comment">//获得当前Activty的Window对象</span>                r.window = r.activity.getWindow();                <span class="hljs-comment">//获得当前Window的DecorView</span>                View decor = r.window.getDecorView();                decor.setVisibility(View.INVISIBLE);                <span class="hljs-comment">//获得当前Activity的WindowManager对象</span>                ViewManager wm = a.getWindowManager();                WindowManager.LayoutParams l = r.window.getAttributes();                a.mDecor = decor;                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;                l.softInputMode |= forwardBit;                <span class="hljs-keyword">if</span> (r.mPreserveWindow) &#123;                    a.mWindowAdded = <span class="hljs-keyword">true</span>;                    r.mPreserveWindow = <span class="hljs-keyword">false</span>;                    ViewRootImpl impl = decor.getViewRootImpl();                    <span class="hljs-keyword">if</span> (impl != <span class="hljs-keyword">null</span>) &#123;                        impl.notifyChildRebuilt();                    &#125;                &#125;                <span class="hljs-keyword">if</span> (a.mVisibleFromClient) &#123;                    <span class="hljs-keyword">if</span> (!a.mWindowAdded) &#123;                        a.mWindowAdded = <span class="hljs-keyword">true</span>;                        <span class="hljs-comment">//将DecorView添加到PhoneWindow中</span>                        wm.addView(decor, l);                    &#125; <span class="hljs-keyword">else</span> &#123;                        a.onWindowAttributesChanged(l);                    &#125;                &#125;            <span class="hljs-comment">// If the window has already been added, but during resume</span>            <span class="hljs-comment">// we started another activity, then don't yet make the</span>            <span class="hljs-comment">// window visible.</span>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!willBeVisible) &#123;                <span class="hljs-keyword">if</span> (localLOGV) Slog.v(                    TAG, <span class="hljs-string">"Launch "</span> + r + <span class="hljs-string">" mStartedActivity set"</span>);                r.hideForNow = <span class="hljs-keyword">true</span>;            &#125;                &#125;        <span class="hljs-keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="hljs-keyword">null</span> &amp;&amp; !r.hideForNow) &#123;...            <span class="hljs-keyword">if</span> (r.activity.mVisibleFromClient) &#123;              <span class="hljs-comment">//显示DecorView</span>                r.activity.makeVisible();            &#125;        &#125;...    &#125;<span class="hljs-comment">//Activity.java</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeVisible</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!mWindowAdded) &#123;            ViewManager wm = getWindowManager();            wm.addView(mDecor, getWindow().getAttributes());            mWindowAdded = <span class="hljs-keyword">true</span>;        &#125;      <span class="hljs-comment">//显示DecorView及其内容</span>        mDecor.setVisibility(View.VISIBLE);    &#125;</code></pre><p>后续调用到了<code>wm.addView()</code>。将对应的DecorView传递进去。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/WindowManagerImpl.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowManagerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WindowManager</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Window mParentWindow;    ...    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;        applyDefaultToken(params);        <span class="hljs-comment">//调用到了WindowManagerGlobal中的addView</span>        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);    &#125;       ...&#125;<span class="hljs-comment">// ../android/view/WindowManagerGlobal.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,            Display display, Window parentWindow)</span> </span>&#123;        ...        ViewRootImpl root;        View panelParentView = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">synchronized</span> (mLock) &#123;            ...            <span class="hljs-comment">//创建了ViewRootImpl实例</span>            root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);<span class="hljs-comment">//初始化了ViewRootImpl对象</span>            view.setLayoutParams(wparams);            mViews.add(view);            mRoots.add(root);            mParams.add(wparams);            <span class="hljs-comment">// do this last because it fires off messages to start doing things</span>            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//调用setView 将传进来的DecorView添加到PhoneWindow中。 </span>                root.setView(view, wparams, panelParentView);            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;                <span class="hljs-comment">// BadTokenException or InvalidDisplayException, clean up.</span>                <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;                    removeViewLocked(index, <span class="hljs-keyword">true</span>);                &#125;                <span class="hljs-keyword">throw</span> e;            &#125;        &#125;    &#125;</code></pre><p>经过<code>ActivityThread.handleResumeActivity() -&gt; WindowManagerGlobal.addView()</code>创建了<code>ViewRootImpl</code>对象</p><h3 id="与DecorView的关系"><a href="#与DecorView的关系" class="headerlink" title="与DecorView的关系"></a>与DecorView的关系</h3><p>上述流程走完后，就把DecorView加载到了Window中。<strong>这个流程中将ViewRootImpl对象与DecorView进行了关联</strong>。</p><pre><code class="hljs java"><span class="hljs-comment">//view 表示 DecorView </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;     <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;         <span class="hljs-comment">//传进来的DecorView作为全局变量使用</span>          mView = view;         ...          <span class="hljs-comment">// Schedule the first layout -before- adding to the window</span>                <span class="hljs-comment">// manager, to make sure we do the relayout before receiving</span>                <span class="hljs-comment">// any other events from the system.</span>          <span class="hljs-comment">//绘制整个布局</span>          requestLayout();            ...          <span class="hljs-comment">//设置ViewRootImpl为DecorView的parentView </span>          view.assignParent(<span class="hljs-keyword">this</span>);     &#125;    &#125;</code></pre><p>执行到<code>ViewRootImpl.setView()</code>设置<code>DecorView,assignParent(root)</code>。表示<strong>ViewRootImpl是DecorView的parent</strong>。</p><blockquote><p><code>Activity</code>、<code>Window(PhoneWindow)</code>、<code>View(DecorView)</code>、<code>ViewRootImpl</code>之间的关系？</p><p><code>PhoneWindow</code>是<code>Window</code>的唯一子类，在<code>Activity.attach()</code>构建的实例，是<strong>Activity与View交互的中间层</strong></p><p><code>DecorView</code>是<code>所有View</code>的最顶层，<code>ViewRootImpl</code>是<code>DecorView</code>的<code>parent</code>，负责<code>WindowManagerService</code>与<code>DecorView</code>的通信。<strong>掌管View的各种事件，例如<code>刷新、点击</code>事件等</strong></p></blockquote><h2 id="LayoutInflater"><a href="#LayoutInflater" class="headerlink" title="LayoutInflater"></a>LayoutInflater</h2><blockquote><p><code>LayoutInflater</code>是一个抽象类，具体实现类为<code>PhoneLayoutInflater</code>。主要用于进行<code>布局加载</code>。</p></blockquote><h3 id="PhoneLayoutInflater"><a href="#PhoneLayoutInflater" class="headerlink" title="PhoneLayoutInflater"></a>PhoneLayoutInflater</h3><blockquote><p> 通过系统注册服务可以得到<code>LayoutInflater</code>的实现类<code>PhoneLayoutInflater</code></p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//LayoutInflater.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LayoutInflater <span class="hljs-title">from</span><span class="hljs-params">(Context context)</span> </span>&#123;    LayoutInflater LayoutInflater =            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);<span class="hljs-comment">//获取系统配置的加载服务</span>    <span class="hljs-keyword">if</span> (LayoutInflater == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">"LayoutInflater not found."</span>);    &#125;    <span class="hljs-keyword">return</span> LayoutInflater;&#125;<span class="hljs-comment">//SystemServerRegistry.java</span><span class="hljs-comment">//系统设置 PhoneInflater 为加载类</span>registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater<span class="hljs-class">.<span class="hljs-keyword">class</span>,            <span class="hljs-title">new</span> <span class="hljs-title">CachedServiceFetcher</span>&lt;<span class="hljs-title">LayoutInflater</span>&gt;() </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> LayoutInflater <span class="hljs-title">createService</span><span class="hljs-params">(ContextImpl ctx)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());        &#125;&#125;);</code></pre><p><code>PhoneLayoutInflater</code>设置的<code>context</code>为<code>ContextImpl.getOuterContext()</code></p><pre><code class="hljs java"><span class="hljs-comment">//ContextImpl.java</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOuterContext</span><span class="hljs-params">(Context context)</span> </span>&#123;        mOuterContext = context;    &#125;    <span class="hljs-function"><span class="hljs-keyword">final</span> Context <span class="hljs-title">getOuterContext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mOuterContext;    &#125;<span class="hljs-comment">//ActivityThread.java</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;      ...        appContext.setOuterContext(activity);<span class="hljs-comment">//设置外部context为Activity</span>    &#125;</code></pre><p><strong>一般从<code>Activity、View、Dialog，Fragment</code>获取的<code>layoutInflater.getContext()</code>为Activity</strong></p><h3 id="inflate-加载布局"><a href="#inflate-加载布局" class="headerlink" title="inflate()-加载布局"></a>inflate()-加载布局</h3><blockquote><p><code>source</code>：需要加载的layout id</p><p><code>root</code>：根布局</p><p>*<code>attachToRoot</code>：是否添加到<code>root</code>中</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//LayoutInflater.java</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> resource, @Nullable ViewGroup root)</span> </span>&#123;        <span class="hljs-keyword">return</span> inflate(resource, root, root != <span class="hljs-keyword">null</span>);   &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> resource, @Nullable ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span> </span>&#123;        <span class="hljs-keyword">final</span> Resources res = getContext().getResources();        ...        <span class="hljs-comment">//构造xml解析器</span>        <span class="hljs-keyword">final</span> XmlResourceParser parser = res.getLayout(resource);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> inflate(parser, root, attachToRoot);        &#125; <span class="hljs-keyword">finally</span> &#123;            parser.close();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (mConstructorArgs) &#123;            Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="hljs-string">"inflate"</span>);            <span class="hljs-keyword">final</span> Context inflaterContext = mContext;            <span class="hljs-keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);            Context lastContext = (Context) mConstructorArgs[<span class="hljs-number">0</span>];            mConstructorArgs[<span class="hljs-number">0</span>] = inflaterContext;            View result = root;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// Look for the root node.</span>                <span class="hljs-keyword">int</span> type;                <span class="hljs-comment">//非xml起始与结尾标记</span>                <span class="hljs-keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;                        type != XmlPullParser.END_DOCUMENT) &#123;                &#125;                            <span class="hljs-keyword">if</span> (type != XmlPullParser.START_TAG) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(parser.getPositionDescription()                            + <span class="hljs-string">": No start tag found!"</span>);                &#125;                <span class="hljs-keyword">final</span> String name = parser.getName();                <span class="hljs-comment">//处理&lt;merge&gt;标签</span>                <span class="hljs-keyword">if</span> (TAG_MERGE.equals(name)) &#123;                    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !attachToRoot) &#123;                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"&lt;merge /&gt; can be used only with a valid "</span>                                + <span class="hljs-string">"ViewGroup root and attachToRoot=true"</span>);                    &#125;                    <span class="hljs-comment">//传入rootview 解析得到的布局直接加入rootView中</span>                    rInflate(parser, root, inflaterContext, attrs, <span class="hljs-keyword">false</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// Temp is the root view that was found in the xml</span>                    <span class="hljs-comment">//根据Tag创建对应的View 例如&lt;TextView&gt;</span>                    <span class="hljs-keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);                    ViewGroup.LayoutParams params = <span class="hljs-keyword">null</span>;                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-comment">// Create layout params that match root, if supplied</span>                        params = root.generateLayoutParams(attrs);                        <span class="hljs-keyword">if</span> (!attachToRoot) &#123;                            <span class="hljs-comment">// Set the layout params for temp if we are not</span>                            <span class="hljs-comment">// attaching. (If we are, we use addView, below)</span>                            temp.setLayoutParams(params);                        &#125;                    &#125;                    <span class="hljs-comment">// Inflate all children under temp against its context.</span>                    <span class="hljs-comment">//创建temp子View</span>                    rInflateChildren(parser, temp, attrs, <span class="hljs-keyword">true</span>);                    <span class="hljs-comment">// We are supposed to attach all the views we found (int temp)</span>                    <span class="hljs-comment">// to root. Do that now.</span>                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span> &amp;&amp; attachToRoot) &#123;                        <span class="hljs-comment">//将temp添加到rootView中</span>                        root.addView(temp, params);                    &#125;                    <span class="hljs-comment">// Decide whether to return the root that was passed in or the</span>                    <span class="hljs-comment">// top view found in xml.</span>                    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !attachToRoot) &#123;                        <span class="hljs-comment">//attachToRoot：将View添加到RootView中，非就是直接返回解析的子View</span>                        result = temp;                    &#125;                &#125;            &#125; <span class="hljs-keyword">catch</span> (XmlPullParserException e) &#123;                <span class="hljs-keyword">final</span> InflateException ie = <span class="hljs-keyword">new</span> InflateException(e.getMessage(), e);                ie.setStackTrace(EMPTY_STACK_TRACE);                <span class="hljs-keyword">throw</span> ie;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                <span class="hljs-keyword">final</span> InflateException ie = <span class="hljs-keyword">new</span> InflateException(parser.getPositionDescription()                        + <span class="hljs-string">": "</span> + e.getMessage(), e);                ie.setStackTrace(EMPTY_STACK_TRACE);                <span class="hljs-keyword">throw</span> ie;            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">// Don't retain static reference on context.</span>                mConstructorArgs[<span class="hljs-number">0</span>] = lastContext;                mConstructorArgs[<span class="hljs-number">1</span>] = <span class="hljs-keyword">null</span>;                Trace.traceEnd(Trace.TRACE_TAG_VIEW);            &#125;            <span class="hljs-keyword">return</span> result;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rInflate</span><span class="hljs-params">(XmlPullParser parser, View parent, Context context,            AttributeSet attrs, <span class="hljs-keyword">boolean</span> finishInflate)</span> <span class="hljs-keyword">throws</span> XmlPullParserException, IOException </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> depth = parser.getDepth();        <span class="hljs-keyword">int</span> type;        <span class="hljs-keyword">boolean</span> pendingRequestFocus = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||                parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;            <span class="hljs-keyword">if</span> (type != XmlPullParser.START_TAG) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">final</span> String name = parser.getName();            <span class="hljs-keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;                pendingRequestFocus = <span class="hljs-keyword">true</span>;                consumeChildElements(parser);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_TAG.equals(name)) &#123;                parseViewTag(parser, parent, attrs);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;<span class="hljs-comment">//&lt;include&gt;</span>                <span class="hljs-keyword">if</span> (parser.getDepth() == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"&lt;include /&gt; cannot be the root element"</span>);                &#125;                parseInclude(parser, context, parent, attrs);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TAG_MERGE.equals(name)) &#123;<span class="hljs-comment">//&lt;merge&gt;</span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InflateException(<span class="hljs-string">"&lt;merge /&gt; must be the root element"</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//创建View</span>                <span class="hljs-keyword">final</span> View view = createViewFromTag(parent, name, context, attrs);                <span class="hljs-keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;                <span class="hljs-keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);                <span class="hljs-comment">//递归创建子View</span>                rInflateChildren(parser, view, attrs, <span class="hljs-keyword">true</span>);                <span class="hljs-comment">//创建的子View添加会parent</span>                viewGroup.addView(view, params);            &#125;        &#125;        <span class="hljs-keyword">if</span> (pendingRequestFocus) &#123;            parent.restoreDefaultFocus();        &#125;        <span class="hljs-keyword">if</span> (finishInflate) &#123;            parent.onFinishInflate();        &#125;    &#125;</code></pre><p><code>layoutInflater.inflate()</code>主要是调用<code>createViewFromTag()</code>从xml生成view的。</p><h4 id="createViewFromTag"><a href="#createViewFromTag" class="headerlink" title="* createViewFromTag()"></a>* createViewFromTag()</h4><blockquote><p>主要负责将<code>&lt;tag&gt;</code>创建成<code>View</code>对象</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//LayoutInflater.java</span><span class="hljs-function">View <span class="hljs-title">createViewFromTag</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs,            <span class="hljs-keyword">boolean</span> ignoreThemeAttr)</span> </span>&#123;        <span class="hljs-comment">/**        * view标签 取class 做为name        */</span>        <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">"view"</span>)) &#123;            name = attrs.getAttributeValue(<span class="hljs-keyword">null</span>, <span class="hljs-string">"class"</span>);        &#125;        <span class="hljs-comment">// 设置View的Theme</span>        <span class="hljs-keyword">if</span> (!ignoreThemeAttr) &#123;            <span class="hljs-keyword">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> themeResId = ta.getResourceId(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span> (themeResId != <span class="hljs-number">0</span>) &#123;                context = <span class="hljs-keyword">new</span> ContextThemeWrapper(context, themeResId);            &#125;            ta.recycle();        &#125;        <span class="hljs-comment">//处理 &lt;blink&gt;标签</span>        <span class="hljs-keyword">if</span> (name.equals(TAG_1995)) &#123;            <span class="hljs-comment">// Let's party like it's 1995!</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BlinkLayout(context, attrs);        &#125;        <span class="hljs-keyword">try</span> &#123;            View view;            <span class="hljs-comment">//通过Factory /Factory2  进行View的实例化</span>            <span class="hljs-keyword">if</span> (mFactory2 != <span class="hljs-keyword">null</span>) &#123;                view = mFactory2.onCreateView(parent, name, context, attrs);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mFactory != <span class="hljs-keyword">null</span>) &#123;                view = mFactory.onCreateView(name, context, attrs);            &#125; <span class="hljs-keyword">else</span> &#123;                view = <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-comment">//通过 mPrivateFactory实例化View</span>            <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span> &amp;&amp; mPrivateFactory != <span class="hljs-keyword">null</span>) &#123;                view = mPrivateFactory.onCreateView(parent, name, context, attrs);            &#125;            <span class="hljs-comment">//未设置 Factory，走默认创建View的流程</span>            <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">final</span> Object lastContext = mConstructorArgs[<span class="hljs-number">0</span>];                mConstructorArgs[<span class="hljs-number">0</span>] = context;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//&lt;tag&gt;中存在 . 可以判断为自定义View，走View自身的创建流程</span>                    <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == name.indexOf(<span class="hljs-string">'.'</span>)) &#123;                        view = onCreateView(parent, name, attrs);                    &#125; <span class="hljs-keyword">else</span> &#123;                        view = createView(name, <span class="hljs-keyword">null</span>, attrs);                    &#125;                &#125; <span class="hljs-keyword">finally</span> &#123;                    mConstructorArgs[<span class="hljs-number">0</span>] = lastContext;                &#125;            &#125;            <span class="hljs-keyword">return</span> view;        &#125;         ,,,    &#125;&#125;</code></pre><p><code>createViewFromTag()</code>主要做了以下几步：</p><ol><li><p>如果为<code>&lt;view&gt;</code>标签，读取<code>class</code>属性做为类名</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"LinearLayout"</span>/&gt;</span> 等价于<span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></code></pre></li></ol><ol start="2"><li><p>应用<code>ContenxtThemeWrapper</code>为View设置主题<code>Theme</code></p></li><li><p>使用<code>Factory/Factory2/mPrivateFactory</code>实例化<code>View</code>，相当于<strong>拦截</strong></p><blockquote><p>实例化<code>View</code>的优先顺序为<code>Factory2 &gt; Factory &gt; mPrivateFactory &gt; PhoneLayoutInflater</code></p></blockquote></li><li><p>未设置<code>以上factory</code>，执行<code>View</code>的默认创建流程</p><blockquote><p>主要通过<code>PhoneLayoutInflater</code>执行</p></blockquote></li></ol><h3 id="Factory-Factory2-拦截View创建"><a href="#Factory-Factory2-拦截View创建" class="headerlink" title="Factory/Factory2-拦截View创建"></a>Factory/Factory2-拦截View创建</h3><blockquote><p>在上节有说到<code>Factory/Factory2</code>执行相当于拦截的功能，<code>hook</code>View创建的流程</p><p><code>mPrivateFactory</code>实现了<code>Factory2</code>接口，主要用于拦截<code>&lt;fragment&gt;</code>标签处理</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">private</span> Factory mFactory;<span class="hljs-keyword">private</span> Factory2 mFactory2;<span class="hljs-keyword">private</span> Factory2 mPrivateFactory;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, Context context, AttributeSet attrs)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span></span>;&#125;</code></pre><p><code>Factory2</code>相对于<code>Factory</code>在<code>onCreateView()</code>多传入了<code>parent</code></p><h4 id="Factroy2"><a href="#Factroy2" class="headerlink" title="Factroy2"></a>Factroy2</h4><p>设置<code>Factroy2</code>的方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFactory2</span><span class="hljs-params">(Factory2 factory)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mFactorySet) &#123; <span class="hljs-comment">//只允许设置一次 Factory2</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"A factory has already been set on this LayoutInflater"</span>);    &#125;    <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//设置的factory不能为null</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"Given factory can not be null"</span>);    &#125;    mFactorySet = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span> (mFactory == <span class="hljs-keyword">null</span>) &#123;        mFactory = mFactory2 = factory;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//控制factory调用顺序</span>        mFactory = mFactory2 = <span class="hljs-keyword">new</span> FactoryMerger(factory, factory, mFactory, mFactory2);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMerger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory2</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Factory mF1, mF2;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Factory2 mF12, mF22;    FactoryMerger(Factory f1, Factory2 f12, Factory f2, Factory2 f22) &#123;        mF1 = f1;        mF2 = f2;        mF12 = f12;        mF22 = f22;    &#125;  <span class="hljs-comment">//此处对应Factory</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;        View v = mF1.onCreateView(name, context, attrs);        <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> v;        <span class="hljs-keyword">return</span> mF2.onCreateView(name, context, attrs);    &#125;   <span class="hljs-comment">//此处对应Factory2</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;        View v = mF12 != <span class="hljs-keyword">null</span> ? mF12.onCreateView(parent, name, context, attrs)                : mF1.onCreateView(name, context, attrs);        <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> v;        <span class="hljs-keyword">return</span> mF22 != <span class="hljs-keyword">null</span> ? mF22.onCreateView(parent, name, context, attrs)                : mF2.onCreateView(name, context, attrs);    &#125;&#125;</code></pre><p>最终都是通过<code>FactoryMerger</code>执行的<code>onCreateView</code></p><h5 id="何处调用setFactory2"><a href="#何处调用setFactory2" class="headerlink" title="何处调用setFactory2()"></a>何处调用setFactory2()</h5><pre><code class="hljs java"><span class="hljs-comment">//AppCompatActivity.onCreate() -&gt; AppCompatDelegate.installViewFactory() -&gt;</span><span class="hljs-comment">//AppCompatDelegateImpl.installViewFactory()</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installViewFactory</span><span class="hljs-params">()</span> </span>&#123;        LayoutInflater layoutInflater = LayoutInflater.from(<span class="hljs-keyword">this</span>.mContext);        <span class="hljs-keyword">if</span> (layoutInflater.getFactory() == <span class="hljs-keyword">null</span>) &#123;            LayoutInflaterCompat.setFactory2(layoutInflater, <span class="hljs-keyword">this</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(layoutInflater.getFactory2() <span class="hljs-keyword">instanceof</span> AppCompatDelegateImpl)) &#123;            Log.i(<span class="hljs-string">"AppCompatDelegate"</span>, <span class="hljs-string">"The Activity's LayoutInflater already has a Factory installed so we can not install AppCompat's"</span>);        &#125;    &#125;<span class="hljs-comment">//设置Factory2执行到 onCreateView()</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.createView(parent, name, context, attrs);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">createView</span><span class="hljs-params">(View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mAppCompatViewInflater == <span class="hljs-keyword">null</span>) &#123;            TypedArray a = <span class="hljs-keyword">this</span>.mContext.obtainStyledAttributes(styleable.AppCompatTheme);            String viewInflaterClassName = a.getString(styleable.AppCompatTheme_viewInflaterClass);            <span class="hljs-keyword">if</span> (viewInflaterClassName != <span class="hljs-keyword">null</span> &amp;&amp; !AppCompatViewInflater<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>().<span class="hljs-title">equals</span>(<span class="hljs-title">viewInflaterClassName</span>)) </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    Class viewInflaterClass = Class.forName(viewInflaterClassName);                    <span class="hljs-keyword">this</span>.mAppCompatViewInflater = (AppCompatViewInflater)viewInflaterClass.getDeclaredConstructor().newInstance();                &#125; <span class="hljs-keyword">catch</span> (Throwable var8) &#123;                    Log.i(<span class="hljs-string">"AppCompatDelegate"</span>, <span class="hljs-string">"Failed to instantiate custom view inflater "</span> + viewInflaterClassName + <span class="hljs-string">". Falling back to default."</span>, var8);                    <span class="hljs-keyword">this</span>.mAppCompatViewInflater = <span class="hljs-keyword">new</span> AppCompatViewInflater();                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">this</span>.mAppCompatViewInflater = <span class="hljs-keyword">new</span> AppCompatViewInflater();            &#125;        &#125;        ...        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mAppCompatViewInflater.createView(...);    &#125;</code></pre><p>通过<code>AppCompatViewInflater</code>去执行View的创建</p><pre><code class="hljs java"><span class="hljs-comment">//AppCompatViewInflater.java</span>    <span class="hljs-function"><span class="hljs-keyword">final</span> View <span class="hljs-title">createView</span><span class="hljs-params">(View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs, <span class="hljs-keyword">boolean</span> inheritContext, <span class="hljs-keyword">boolean</span> readAndroidTheme, <span class="hljs-keyword">boolean</span> readAppTheme, <span class="hljs-keyword">boolean</span> wrapContext)</span> </span>&#123;  ...     <span class="hljs-keyword">switch</span> (name) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">"TextView"</span>:                view = createTextView(context, attrs);                verifyNotNull(view, name);                <span class="hljs-keyword">break</span>;         ...     &#125;&#125;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AppCompatTextView <span class="hljs-title">createTextView</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AppCompatTextView(context, attrs);    &#125;</code></pre><p>此处可以在使用到<code>AppCompatActivity</code>时，将原先的<code>&lt;TextView&gt;</code>转换为<code>AppCompatTextView</code></p><h4 id="mPrivateFactory"><a href="#mPrivateFactory" class="headerlink" title="mPrivateFactory"></a>mPrivateFactory</h4><blockquote><p>系统hide对象，无法被外界使用，主要处理<code>&lt;fragment&gt;</code></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrivateFactory</span><span class="hljs-params">(Factory2 factory)</span> </span>&#123;    <span class="hljs-keyword">if</span> (mPrivateFactory == <span class="hljs-keyword">null</span>) &#123;        mPrivateFactory = factory;    &#125; <span class="hljs-keyword">else</span> &#123;        mPrivateFactory = <span class="hljs-keyword">new</span> FactoryMerger(factory, factory, mPrivateFactory, mPrivateFactory);    &#125;&#125;</code></pre><h5 id="何处调用setPrivateFactory"><a href="#何处调用setPrivateFactory" class="headerlink" title="何处调用setPrivateFactory()"></a>何处调用setPrivateFactory()</h5><pre><code class="hljs java"><span class="hljs-comment">//Activity.java</span><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context, ActivityThread aThread,            Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,            Application application, Intent intent, ActivityInfo info,            CharSequence title, Activity parent, String id,            NonConfigurationInstances lastNonConfigurationInstances,            Configuration config, String referrer, IVoiceInteractor voiceInteractor,            Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;  ...    mWindow.getLayoutInflater().setPrivateFactory(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//this 表示当前Activity</span>  ...&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-string">"fragment"</span>.equals(name)) &#123;            <span class="hljs-keyword">return</span> onCreateView(name, context, attrs);        &#125;       <span class="hljs-comment">//&lt;fragment&gt;标签直接解析执行 onCreateView</span>        <span class="hljs-keyword">return</span> mFragments.onCreateView(parent, name, context, attrs);    &#125;</code></pre><h4 id="拓展使用"><a href="#拓展使用" class="headerlink" title="拓展使用"></a>拓展使用</h4><p>系统通过<code>Factory</code>提供<code>hook</code>方法，方便拦截<code>LayoutInflater</code>创建View的过程。支持以下应用场景：</p><ul><li>支持对自定义标签名称的处理</li><li>全局替换系统控件为自定义View</li><li><strong>替换字体</strong></li><li><strong>全局换肤</strong></li><li><strong>获取控件加载耗时</strong></li></ul><p>针对以上场景，实现部分关键代码以供参考</p><h5 id="获取控件加载耗时"><a href="#获取控件加载耗时" class="headerlink" title="获取控件加载耗时"></a>获取控件加载耗时</h5><pre><code class="hljs java"><span class="hljs-comment">//XXActivity.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;      <span class="hljs-comment">//设置自定义Factory</span>        setFactory2();        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.act_xx);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFactory2</span><span class="hljs-params">()</span></span>&#123;        LayoutInflaterCompat.setFactory2(getLayoutInflater(), <span class="hljs-keyword">new</span> LayoutInflater.Factory2() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;                <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<span class="hljs-comment">//加载开始时间</span>                View view = getDelegate().createView(parent, name, context, attrs);<span class="hljs-comment">//开始加载</span>                <span class="hljs-keyword">long</span> costTime = System.currentTimeMillis() - startTime;<span class="hljs-comment">//加载结束时间</span>                Log.e(<span class="hljs-string">"costTime"</span>,costTime+<span class="hljs-string">""</span>);                <span class="hljs-keyword">return</span> view;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125;);    &#125;</code></pre><p><code>setFactory2()</code>不可以放到<code>super.onCreate()</code>之后，会触发<code>A factory has already been set on this LayoutInflater</code>异常，原因就在于<code>setFactory2()</code>最多支持设置一个。</p><h5 id="替换字体"><a href="#替换字体" class="headerlink" title="替换字体"></a>替换字体</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFontFactory2</span><span class="hljs-params">()</span> </span>&#123;    LayoutInflaterCompat.setFactory2(getLayoutInflater(), <span class="hljs-keyword">new</span> LayoutInflater.Factory2() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;            View view = getDelegate().createView(parent, name, context, attrs);            <span class="hljs-keyword">if</span> (view <span class="hljs-keyword">instanceof</span> TextView ) &#123;                ((TextView) view).setTypeface(XX);<span class="hljs-comment">//设置对应字体</span>            &#125;            <span class="hljs-keyword">return</span> view;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;);&#125;</code></pre><p>只要执行了<code>getDelegate().createView()</code>可以保证<code>原生控件-&gt;兼容控件</code>功能正常。</p><h3 id="View默认创建流程"><a href="#View默认创建流程" class="headerlink" title="View默认创建流程"></a>View默认创建流程</h3><blockquote><p>未设置<code>Factory/Factory2</code>就会执行默认的View创建流程</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//LayoutInflater.java</span>    <span class="hljs-function">View <span class="hljs-title">createViewFromTag</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs,            <span class="hljs-keyword">boolean</span> ignoreThemeAttr)</span> </span>&#123;      ...        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">final</span> Object lastContext = mConstructorArgs[<span class="hljs-number">0</span>];                mConstructorArgs[<span class="hljs-number">0</span>] = context;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == name.indexOf(<span class="hljs-string">'.'</span>)) &#123;                        view = onCreateView(parent, name, attrs);<span class="hljs-comment">//系统提供View</span>                    &#125; <span class="hljs-keyword">else</span> &#123;                        view = createView(name, <span class="hljs-keyword">null</span>, attrs);<span class="hljs-comment">//自定义View</span>                    &#125;                &#125; <span class="hljs-keyword">finally</span> &#123;                    mConstructorArgs[<span class="hljs-number">0</span>] = lastContext;                &#125;            &#125;      ...    &#125;</code></pre><h4 id="系统提供View"><a href="#系统提供View" class="headerlink" title="系统提供View"></a>系统提供View</h4><blockquote><p>例如<code>&lt;TextView/&gt;、&lt;Button/&gt;</code>等</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhoneLayoutInflater</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LayoutInflater</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] sClassPrefixList = &#123;        <span class="hljs-string">"android.widget."</span>,        <span class="hljs-string">"android.webkit."</span>,        <span class="hljs-string">"android.app."</span>    &#125;;     <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, AttributeSet attrs)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;        <span class="hljs-keyword">for</span> (String prefix : sClassPrefixList) &#123;            <span class="hljs-keyword">try</span> &#123;                View view = createView(name, prefix, attrs);                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">return</span> view;                &#125;            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                <span class="hljs-comment">// In this case we want to let the base class take a crack</span>                <span class="hljs-comment">// at it.</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onCreateView(name, attrs);    &#125;  &#125;<span class="hljs-comment">//LayoutInflater.java</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(String name, AttributeSet attrs)</span>            <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;        <span class="hljs-keyword">return</span> createView(name, <span class="hljs-string">"android.view."</span>, attrs);    &#125;</code></pre><p>优先判断</p><ul><li><code>android.widget.*</code> 例如<code>android.widget.TextView</code></li><li><code>android.webkit.*</code> 例如<code>android.webkit.WebView</code></li><li><code>android.app.*</code> 例如<code>android.app.ActionBar</code></li></ul><p>是否有对应<code>nmae</code>的View实例存在</p><p>都不存在，就在<code>android.view.*</code>找寻对应View实例 例如<code>android.view.ViewStub</code></p><h4 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h4><blockquote><p>例如<code>android.support.v7.widget.RecyclerView</code>等</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View <span class="hljs-title">createView</span><span class="hljs-params">(String name, String prefix, AttributeSet attrs)</span>            <span class="hljs-keyword">throws</span> ClassNotFoundException, InflateException </span>&#123;       <span class="hljs-comment">//构建缓存，缓存已加载的View</span>        Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);        <span class="hljs-keyword">if</span> (constructor != <span class="hljs-keyword">null</span> &amp;&amp; !verifyClassLoader(constructor)) &#123;            constructor = <span class="hljs-keyword">null</span>;            sConstructorMap.remove(name);        &#125;        Class&lt;? extends View&gt; clazz = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);            <span class="hljs-comment">//新建View构造器</span>            <span class="hljs-keyword">if</span> (constructor == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// 得到全限定名 例如android,widget.TextView</span>                clazz = mContext.getClassLoader().loadClass(                        prefix != <span class="hljs-keyword">null</span> ? (prefix + name) : name).asSubclass(View<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                <span class="hljs-keyword">if</span> (mFilter != <span class="hljs-keyword">null</span> &amp;&amp; clazz != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">boolean</span> allowed = mFilter.onLoadClass(clazz);                    <span class="hljs-keyword">if</span> (!allowed) &#123;                        failNotAllowed(name, prefix, attrs);                    &#125;                &#125;                constructor = clazz.getConstructor(mConstructorSignature);                constructor.setAccessible(<span class="hljs-keyword">true</span>);                sConstructorMap.put(name, constructor);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// If we have a filter, apply it to cached constructor</span>                <span class="hljs-keyword">if</span> (mFilter != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">// Have we seen this name before?</span>                    Boolean allowedState = mFilterMap.get(name);                    <span class="hljs-keyword">if</span> (allowedState == <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-comment">// New class -- remember whether it is allowed</span>                        clazz = mContext.getClassLoader().loadClass(                                prefix != <span class="hljs-keyword">null</span> ? (prefix + name) : name).asSubclass(View<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;                        <span class="hljs-keyword">boolean</span> allowed = clazz != <span class="hljs-keyword">null</span> &amp;&amp; mFilter.onLoadClass(clazz);                        mFilterMap.put(name, allowed);                        <span class="hljs-keyword">if</span> (!allowed) &#123;                            failNotAllowed(name, prefix, attrs);                        &#125;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allowedState.equals(Boolean.FALSE)) &#123;                        failNotAllowed(name, prefix, attrs);                    &#125;                &#125;            &#125;            Object lastContext = mConstructorArgs[<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (mConstructorArgs[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// Fill in the context if not already within inflation.</span>                mConstructorArgs[<span class="hljs-number">0</span>] = mContext;            &#125;            Object[] args = mConstructorArgs;            args[<span class="hljs-number">1</span>] = attrs;            <span class="hljs-comment">//根据得到的 constuctor 实例化View对象</span>            <span class="hljs-keyword">final</span> View view = constructor.newInstance(args);            <span class="hljs-comment">//针对ViewStub特殊处理</span>            <span class="hljs-keyword">if</span> (view <span class="hljs-keyword">instanceof</span> ViewStub) &#123;                <span class="hljs-comment">// Use the same context when inflating ViewStub later.</span>                <span class="hljs-keyword">final</span> ViewStub viewStub = (ViewStub) view;                viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="hljs-number">0</span>]));            &#125;            mConstructorArgs[<span class="hljs-number">0</span>] = lastContext;            <span class="hljs-keyword">return</span> view;        &#125;   ...    &#125;</code></pre><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p><code>View默认创建</code>流程分为：</p><ul><li><code>&lt;tag&gt;</code>不包含<code>.</code>，用于处理<code>&lt;TextView&gt;、&lt;WebView&gt;</code>等标签，此时需要拼接<code>android.widget. 或 android.webkit. 或 android.app.</code>前缀(<strong>实现位于<code>PhoneLayoutInflater</code></strong>)，都没有找到对应的<code>View实例</code>时，就会在添加<code>android.view.</code>再去加载。</li><li><code>&lt;tag&gt;</code>包含<code>.</code>，此时的实例View分为以下几步：<ul><li>构建View的缓存，缓存的是<code>constructor</code>，根据<code>name</code>获取<code>constructor</code></li><li>缓存中不存在时，需要根据<code>prefix+name</code>获取View的<code>constructor</code>，并存入缓存中</li><li>根据<code>constructor</code>构造<code>View实例</code>——<code>constructor.newInstance()</code></li><li>如果需要处理<code>ViewStub</code>，为<code>ViewStub</code>指定加载类</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/LayoutInflater过程.jpg" srcset="/img/loading.gif" alt="LayoutInflater过程"></p><h2 id="View的绘制流程触发"><a href="#View的绘制流程触发" class="headerlink" title="View的绘制流程触发"></a>View的绘制流程触发</h2><p>调用了<code>ViewRootImpl.setView(decorView)</code>将DecorView与ViewRootImpl进行了关联。View的绘制流程就是从ViewRoot开始的。</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;     <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;         <span class="hljs-comment">//传进来的DecorView作为全局变量使用</span>          mView = view;         ...          <span class="hljs-comment">// Schedule the first layout -before- adding to the window</span>                <span class="hljs-comment">// manager, to make sure we do the relayout before receiving</span>                <span class="hljs-comment">// any other events from the system.</span>          <span class="hljs-comment">//绘制整个布局</span>          requestLayout();            ...          <span class="hljs-comment">//设置ViewRootImpl为DecorView的parentView </span>          view.assignParent(<span class="hljs-keyword">this</span>);     &#125;    &#125;<span class="hljs-comment">//请求刷新整个布局</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;            checkThread();            mLayoutRequested = <span class="hljs-keyword">true</span>;            scheduleTraversals();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;            mTraversalScheduled = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">//添加同步屏障</span>            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();            mChoreographer.postCallback(                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">if</span> (!mUnbufferedInputDispatch) &#123;                scheduleConsumeBatchedInput();            &#125;            notifyRendererOfFramePending();            pokeDrawLockIfNeeded();        &#125;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraversalRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            doTraversal();        &#125;    &#125;    <span class="hljs-keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="hljs-keyword">new</span> TraversalRunnable();    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doTraversal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;            mTraversalScheduled = <span class="hljs-keyword">false</span>;            <span class="hljs-comment">//移除同步屏障</span>            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);            <span class="hljs-keyword">if</span> (mProfile) &#123;                Debug.startMethodTracing(<span class="hljs-string">"ViewAncestor"</span>);            &#125;            <span class="hljs-comment">//这里开始View的绘制流程</span>            performTraversals();            <span class="hljs-keyword">if</span> (mProfile) &#123;                Debug.stopMethodTracing();                mProfile = <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;</code></pre><p><code>ViewRootImpl.setView()</code>中最后调用到了<code>performTraversals()</code>在这个方法中开始View的绘制流程</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;  ...   <span class="hljs-keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);      ...   <span class="hljs-keyword">if</span> (!mStopped || mReportNextDraw) &#123;      <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);  <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);      ...        <span class="hljs-keyword">if</span>(layoutRequested)&#123;          <span class="hljs-comment">//开始Measure过程，定义View的宽高</span>          performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);          ...        &#125;   &#125;      <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);    <span class="hljs-keyword">if</span>(didLayout)&#123;        <span class="hljs-comment">//开始Layout过程，决定View的位置</span>        performLayout(lp, mWidth, mHeight);        ...    &#125;         <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;            <span class="hljs-keyword">if</span> (mPendingTransitions != <span class="hljs-keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;                    mPendingTransitions.get(i).startChangingAnimations();                &#125;                mPendingTransitions.clear();            &#125;            <span class="hljs-comment">//开始Draw过程，决定了View的显示，这个过程结束才可以看到内容</span>            performDraw();     &#125;&#125;</code></pre><p>通过以上流程分析：<strong>View的绘制流程是从<code>ViewRootImpl</code>中开始的，先调用<code>performTraversals()</code>开始绘制，随后调用内部的<code>performMeasure()</code>开始Measure过程，调用<code>performLayout()</code>，开始Layout过程，最后调用<code>performDraw()</code>开始Draw，完成后就可以现在在屏幕上。</strong></p><p><img src="/images/View绘制流程.png" srcset="/img/loading.gif" alt="View绘制流程"></p><p>如上图所示，<code>performTraversals()</code>依次调用<code>performMeasure()，performLayout(),performDraw()</code>完成View的绘制。</p><h2 id="View工作流程"><a href="#View工作流程" class="headerlink" title="View工作流程"></a>View工作流程</h2><blockquote><p>主要是指<code>measure(测量)</code>,<code>layout(布局)</code>,<code>draw(绘制)</code>三大流程。</p></blockquote><h3 id="measure-测量"><a href="#measure-测量" class="headerlink" title="measure-测量"></a>measure-测量</h3><blockquote><p>起点位于<code>performMeasure()</code>。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> childWidthMeasureSpec, <span class="hljs-keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;       ...        <span class="hljs-keyword">try</span> &#123;            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);        &#125; <span class="hljs-keyword">finally</span> &#123;            Trace.traceEnd(Trace.TRACE_TAG_VIEW);        &#125;    &#125;</code></pre><h4 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h4><blockquote><p>MeasureSpec代表一个32位int值，高2位代表SpecMode(测量模式)，低30位代表SpecSize(某种测量模式下的规格大小)。</p></blockquote><p>作用：父控件提供给子View的一个参数，作为设定自身大小参考，实际大小还是有子View自身决定。</p><p><img src="/images/MeasureSpec结构" srcset="/img/loading.gif" alt="MeasureSpec结构"></p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MeasureSpec</span> </span>&#123;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MODE_SHIFT = <span class="hljs-number">30</span>;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MODE_MASK  = <span class="hljs-number">0x3</span> &lt;&lt; MODE_SHIFT;       <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> */</span>       <span class="hljs-meta">@IntDef</span>(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)       <span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)       <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MeasureSpecMode &#123;&#125;         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNSPECIFIED = <span class="hljs-number">0</span> &lt;&lt; MODE_SHIFT;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> EXACTLY     = <span class="hljs-number">1</span> &lt;&lt; MODE_SHIFT;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> AT_MOST     = <span class="hljs-number">2</span> &lt;&lt; MODE_SHIFT;     <span class="hljs-meta">@MeasureSpecMode</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measureSpec)</span> </span>&#123;           <span class="hljs-comment">//noinspection ResourceType</span>           <span class="hljs-keyword">return</span> (measureSpec &amp; MODE_MASK);       &#125;               <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measureSpec)</span> </span>&#123;           <span class="hljs-keyword">return</span> (measureSpec &amp; ~MODE_MASK);       &#125;</code></pre><p><code>SpecMode</code>分为三类：</p><ul><li><code>UNSPECIFIED</code>：<strong>未指定模式</strong>。父控件不对子控件添加束缚，子元素可以为任意大小，一般用于系统内部的测量。比如<code>ScrollView</code></li><li><code>EXACTLY</code>：<strong>精确模式</strong>。父控件为子View指定精确大小，希望子View完全按照自己给的尺寸处理大小。一般是设置了<code>明确的值</code>或是<code>MATCH_PARENT</code></li><li><code>AT_MOST</code>：<strong>最大模式</strong>。父控件为子View指定最大尺寸，希望子View不要超过这个尺寸。一般对应<code>WRAP_CONTENT</code></li></ul><h5 id="MeasureSpec与LayoutParams的关系"><a href="#MeasureSpec与LayoutParams的关系" class="headerlink" title="MeasureSpec与LayoutParams的关系"></a>MeasureSpec与LayoutParams的关系</h5><p>每一个View，都持有一个MeasureSpec，里面保存了View的尺寸。我们也可以使用<code>LayoutParams</code>指定View的尺寸。所以在View测量的时候，系统会将<code>LayoutParams</code>在父容器的约束下转换成<code>MeasureSpec</code>，然后根据转换后的值确定宽高。</p><p><strong>转换后的MeasureSpec是由LayoutParams和父容器的MeasureSpec一起决定的。</strong></p><table><thead><tr><th>下：childLayoutParams 右：parentSpecMode</th><th>EXACTLY</th><th>AT_MOST</th><th>UNSPECIFIED</th></tr></thead><tbody><tr><td>固定大小</td><td>Exactly<br>childSize</td><td>Exactly<br>childSize</td><td>Exactly<br>childSize</td></tr><tr><td>match_parent</td><td>Exactly<br>parentSize(父容器剩余空间)</td><td>AT_MOST<br>parentSize(最大父容器剩余空间)</td><td>UNSPECIFIED<br>0 或 parentSize(最大父容器剩余空间)</td></tr><tr><td>wrap_content</td><td>AT_MOST<br>parentSize(最大父容器剩余空间)</td><td>AT_MOST<br>parentSize(最大父容器剩余空间)</td><td>UNSPECIFIED<br>0 或 parentSize(最大父容器剩余空间)</td></tr></tbody></table><p>根据<code>ViewGroup.getChildMeasureSpec()</code>得出上表。</p><h6 id="DecorView转换MeasureSpec"><a href="#DecorView转换MeasureSpec" class="headerlink" title="DecorView转换MeasureSpec"></a>DecorView转换MeasureSpec</h6><blockquote><p>DecorView的转换由Window的尺寸和自身的LayoutParams决定。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewRootImpl.java</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;    ...       <span class="hljs-comment">//DecorView Measure过程</span>       <span class="hljs-keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);       <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);       performMeasure(childWidthMeasureSpec,childHeightMeasureSpec)    ...  &#125;<span class="hljs-comment">//在方法中生成了DecoeView的MeasureSpec 根据Window的尺寸和自身的LayoutParams</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRootMeasureSpec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> windowSize<span class="hljs-comment">/*Window尺寸*/</span>, <span class="hljs-keyword">int</span> rootDimension)</span> </span>&#123;        <span class="hljs-keyword">int</span> measureSpec;        <span class="hljs-keyword">switch</span> (rootDimension) &#123;               <span class="hljs-keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:            <span class="hljs-comment">//MeasureSpec中的specSize就是窗口尺寸,specMode为EXACTLY 精确模式</span>            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:            <span class="hljs-comment">//MeasureSpec中的specSize为窗口尺寸,specMode为aT_MOST 最大模式，最大值为窗口尺寸</span>            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-comment">//MeasureSpec中的specSize为固定尺寸,specMode为EXACTLY 精确模式</span>            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> measureSpec;    &#125;</code></pre><h4 id="View的measure过程"><a href="#View的measure过程" class="headerlink" title="View的measure过程"></a>View的measure过程</h4><p>主要是由<code>measure()</code>方法完成</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/View.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;      ...        <span class="hljs-comment">//需要执行onMeasure</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;        <span class="hljs-comment">// 布局发生变化</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> needsLayout = specChanged                &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);            ...        <span class="hljs-keyword">if</span> (forceLayout || needsLayout) &#123;          ...            onMeasure(widthMeasureSpec, heightMeasureSpec);          ...            <span class="hljs-comment">//添加 PFLAG_LAYOUT_REQUIRED标记，表示需要执行 layout流程</span>             mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;        &#125;    &#125;</code></pre><p>在<code>measure()</code>中调用<code>onMeasure()</code>去进行实际的测量</p><pre><code class="hljs java"><span class="hljs-comment">//../android/view/View.java</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;        setMeasuredDimension(            getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));    &#125;   <span class="hljs-comment">//设置View的宽高</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMeasuredDimension</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measuredWidth, <span class="hljs-keyword">int</span> measuredHeight)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> optical = isLayoutModeOptical(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;            Insets insets = getOpticalInsets();            <span class="hljs-keyword">int</span> opticalWidth  = insets.left + insets.right;            <span class="hljs-keyword">int</span> opticalHeight = insets.top  + insets.bottom;            measuredWidth  += optical ? opticalWidth  : -opticalWidth;            measuredHeight += optical ? opticalHeight : -opticalHeight;        &#125;        setMeasuredDimensionRaw(measuredWidth, measuredHeight);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMeasuredDimensionRaw</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measuredWidth, <span class="hljs-keyword">int</span> measuredHeight)</span> </span>&#123;        mMeasuredWidth = measuredWidth;        mMeasuredHeight = measuredHeight;        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;    &#125;    <span class="hljs-comment">//返回View的MeasureSpec中的specSize</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDefaultSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> measureSpec)</span> </span>&#123;        <span class="hljs-keyword">int</span> result = size;        <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);        <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);        <span class="hljs-keyword">switch</span> (specMode) &#123;        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:            result = size;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<span class="hljs-comment">//wrap_content</span>        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<span class="hljs-comment">//match_parent / XX </span>        <span class="hljs-comment">//这段代码中可以分析得出 一个直接继承View的自定义View 定义为wrap_content和match_parent大小都是一致的.</span>            result = specSize;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuggestedMinimumHeight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (mBackground == <span class="hljs-keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());    &#125;<span class="hljs-comment">//如果View没有设置背景，返回minWidth值，默认为0。若设置了背景就取背景宽度和最小宽度中的最大值返回。</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuggestedMinimumWidth</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (mBackground == <span class="hljs-keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());    &#125;    <span class="hljs-comment">// ../android/graphics/drawable/Drawable.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumWidth</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> intrinsicWidth = getIntrinsicWidth();    <span class="hljs-keyword">return</span> intrinsicWidth &gt; <span class="hljs-number">0</span> ? intrinsicWidth : <span class="hljs-number">0</span>;&#125;</code></pre><p><img src="/images/View-Measure.png" srcset="/img/loading.gif" alt="View-Measure"></p><p>结合上述流程图，简单分析View的Measure过程</p><ul><li>系统在绘制开始时回去调用<code>View.measure()</code>，这个类是final的们无法被重写</li><li>后续调用<code>View.onMeasure()</code>,自定义View时可以按照自己的需求对这个方法进行重写</li><li><code>onMeasure()</code>中调用到<code>setMeasureDimension()</code>对View进行宽高的设置</li><li>需要使用<code>getDefaultSize()</code>去获取最终显示出的宽高</li><li>在<code>getDefaultSize()</code>中需要对传进来的<code>MeasureSpec</code>进行分析处理<ul><li>SpecMode若为<code>UNSPECIFIED</code>，则最终尺寸为传进来的<code>SpecSize</code></li><li>SpecMode为<code>AT_MOST</code>,<code>EXACTLY</code>，还需要额外判断View是否有背景<ul><li>有背景，最终尺寸就为View的最小尺寸和背景尺寸的最大值</li><li>没背景，最终尺寸就为View的最小尺寸</li></ul></li></ul></li><li>取到最终尺寸后，数据回溯到<code>onMeasure()</code>中，即完成测量(<code>Measure</code>)过程</li></ul><p>在上述分析中，自定义View中使用<code>wrap_content</code>时，specMode为<code>AT_MOST</code>，尺寸为父控件剩余大小，效果与使用<code>match_parent</code>一致。这也是自定义View中常碰到的问题 <em>为何自定义View是wrap_content无效？</em> 解决方法就是 自己重写<code>onMeasure()</code>对<code>wrap_content</code>特殊处理。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec,<span class="hljs-keyword">int</span> heightMeasureSpec)</span></span>&#123;    <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec,heightMeasureSpec);    <span class="hljs-keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);    <span class="hljs-keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);    <span class="hljs-keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);    <span class="hljs-keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);        <span class="hljs-keyword">if</span>(widthSpecMode = MeasureSpec.AT_MOST &amp;&amp; heightSpecMode = MeasureSpec.AT_MOST)&#123;        setMeasureDimension(mWidth,mHeight);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(widthSpecMode = MeasureSpec.AT_MOST)&#123;        setMeasureDimension(mWidth,heightSpecSize);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(heightSpecMode = MeasureSpec.AT_MOST)&#123;        setMeasureDimension(widthSpecSize,mHeight);    &#125;    &#125;</code></pre><h4 id="ViewGroup的measure过程"><a href="#ViewGroup的measure过程" class="headerlink" title="ViewGroup的measure过程"></a>ViewGroup的measure过程</h4><blockquote><p>除了完成自身的measure过程之外，还要去遍历调用所有子元素的measure方法，各个子元素再去递归执行这个过程。</p><p><strong>先Measure子View，再Measure自己</strong></p></blockquote><p>ViewGroup中没有定义<code>onMeasure()</code>，定义了一个<code>measureChildren()</code>。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewGroup.java</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = mChildrenCount;        <span class="hljs-keyword">final</span> View[] children = mChildren;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;            <span class="hljs-keyword">final</span> View child = children[i];            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;                <span class="hljs-comment">//遍历对每一个子元素进行测量过程</span>                measureChild(child, widthMeasureSpec, heightMeasureSpec);            &#125;        &#125;    &#125;</code></pre><p>循环调用<code>measureChild()</code></p><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewGroup.java</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChild</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> parentWidthMeasureSpec,            <span class="hljs-keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;        <span class="hljs-comment">//获得子View的LayoutParams</span>        <span class="hljs-keyword">final</span> LayoutParams lp = child.getLayoutParams();        <span class="hljs-comment">//</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,                mPaddingLeft + mPaddingRight, lp.width);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,                mPaddingTop + mPaddingBottom, lp.height);        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);    &#125; <span class="hljs-comment">//子View的MEasureSpec由父View的MEasureSpec以及自身的LayoutParams共同决定</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getChildMeasureSpec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> spec, <span class="hljs-keyword">int</span> padding, <span class="hljs-keyword">int</span> childDimension)</span> </span>&#123;        <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(spec);        <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(spec);        <span class="hljs-comment">//padding代指父View已占用的空间，子View无法使用，所以子View的空间需要减去padding部分</span>        <span class="hljs-keyword">int</span> size = Math.max(<span class="hljs-number">0</span>, specSize - padding);        <span class="hljs-keyword">int</span> resultSize = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> resultMode = <span class="hljs-number">0</span>;        <span class="hljs-keyword">switch</span> (specMode) &#123;        <span class="hljs-comment">// Parent has imposed an exact size on us</span>        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:            <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;                <span class="hljs-comment">// Child wants to be our size. So be it.</span>                resultSize = size;                resultMode = MeasureSpec.EXACTLY;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;                <span class="hljs-comment">// Child wants to determine its own size. It can't be</span>                <span class="hljs-comment">// bigger than us.</span>                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            &#125;            <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// Parent has imposed a maximum size on us</span>        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:            <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// Child wants a specific size... so be it</span>                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;                <span class="hljs-comment">// Child wants to be our size, but our size is not fixed.</span>                <span class="hljs-comment">// Constrain child to not be bigger than us.</span>                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;                <span class="hljs-comment">// Child wants to determine its own size. It can't be</span>                <span class="hljs-comment">// bigger than us.</span>                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            &#125;            <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// Parent asked to see how big we want to be</span>        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:            <span class="hljs-keyword">if</span> (childDimension &gt;= <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// Child wants a specific size... let him have it</span>                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;                <span class="hljs-comment">// Child wants to be our size... find out how big it should</span>                <span class="hljs-comment">// be</span>                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;                resultMode = MeasureSpec.UNSPECIFIED;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;                <span class="hljs-comment">// Child wants to determine its own size.... find out how</span>                <span class="hljs-comment">// big it should be</span>                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="hljs-number">0</span> : size;                resultMode = MeasureSpec.UNSPECIFIED;            &#125;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">//noinspection ResourceType</span>        <span class="hljs-keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);    &#125;</code></pre><p>由于ViewGroup有不同布局的需要，很难统一，所以没有提供统一的<code>onMeasure()</code>方法，而是让子类自己去实现<code>onMeasure()</code>。</p><p><img src="/images/ViewGroup-Measure.png" srcset="/img/loading.gif" alt="ViewGroup-Measure"></p><p>根据上述流程图，简单总结一下：</p><ul><li>ViewGroup调用自身的<code>measureChildren()</code>，里面遍历自己的子View</li><li>遍历后调用<code>measureChild()</code>，准备给每一个子View计算它的<code>MeasureSpec</code></li><li>调用<code>getChildMeasureSpec()</code>计算子View的<code>MeasureSpec</code>，需要结合父布局的<code>MeasureSpec</code>以及子View的<code>LayoutParams</code>共同得出结果</li><li>调用子View的<code>measure()</code>，完成子View的测量过程。</li><li>合并子View的测量值，得到ViewGroup的测量值</li></ul><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol><li>在Activity启动时获取View的尺寸？<ul><li>在 Activity#onWindowFocusChanged 回调中获取宽高。<br><code>当Activity得到焦点或失去焦点的时候，这个方法都会被频繁调用</code></li><li>view.post(runnable)，在 runnable 中获取宽高。<br><code>利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。</code></li><li>ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。<br><code>监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露</code></li><li>调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高<br><code>手动对view进行measure来得到View的尺寸。</code></li></ul></li></ol><h3 id="layout-布局"><a href="#layout-布局" class="headerlink" title="layout-布局"></a>layout-布局</h3><blockquote><p>ViewGroup用来确定子元素的位置，当ViewGroup位置被确定后，在<code>onLayout()</code>中遍历所有子View，并调用其<code>layout()</code>。</p><p><strong>先layout自身后layout子元素。</strong></p></blockquote><h4 id="View的layout过程"><a href="#View的layout过程" class="headerlink" title="View的layout过程"></a>View的layout过程</h4><p>主要是由View的<code>layout()</code>方法实现</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/View.java   </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="hljs-number">0</span>) &#123;            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;        &#125;                <span class="hljs-comment">//左上角顶点距父容器左边的距离</span>        <span class="hljs-keyword">int</span> oldL = mLeft;        <span class="hljs-comment">//左上角顶点距父容器上边的距离</span>        <span class="hljs-keyword">int</span> oldT = mTop;        <span class="hljs-comment">//右下角顶点距父容器上边的距离</span>        <span class="hljs-keyword">int</span> oldB = mBottom;        <span class="hljs-comment">//右下角顶点距父容器上边的距离</span>        <span class="hljs-keyword">int</span> oldR = mRight;        <span class="hljs-comment">//</span>        <span class="hljs-keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);        <span class="hljs-keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;            onLayout(changed, l, t, r, b);            ...        &#125;        ...    &#125;<span class="hljs-comment">//由于子View下是没有子类了，所以该方法内不没有任何代码实现 一般自定义View是不需要重写该方法的</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;        &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setOpticalFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;        Insets parentInsets = mParent <span class="hljs-keyword">instanceof</span> View ?                ((View) mParent).getOpticalInsets() : Insets.NONE;        Insets childInsets = getOpticalInsets();        <span class="hljs-comment">//根据特效边框重新计算四个顶点的位置，然后调用setFrame重新计算</span>        <span class="hljs-keyword">return</span> setFrame(                left   + parentInsets.left - childInsets.left,                top    + parentInsets.top  - childInsets.top,                right  + parentInsets.left + childInsets.right,                bottom + parentInsets.top  + childInsets.bottom);    &#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;             <span class="hljs-keyword">boolean</span> changed = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;            changed = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">// Remember our drawn bit</span>            <span class="hljs-keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;            <span class="hljs-keyword">int</span> oldWidth = mRight - mLeft;            <span class="hljs-keyword">int</span> oldHeight = mBottom - mTop;            <span class="hljs-keyword">int</span> newWidth = right - left;            <span class="hljs-keyword">int</span> newHeight = bottom - top;            <span class="hljs-keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);            <span class="hljs-comment">// Invalidate our old position</span>            invalidate(sizeChanged);            <span class="hljs-comment">//重新计算View的四个顶点距父布局左上边框的距离</span>            mLeft = left;            mTop = top;            mRight = right;            mBottom = bottom;            mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);            ...        &#125;&#125;<span class="hljs-comment">//判断当前View是否存在阴影或者外发光等边框效果</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLayoutModeOptical</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-keyword">return</span> o <span class="hljs-keyword">instanceof</span> ViewGroup &amp;&amp; ((ViewGroup) o).isLayoutModeOptical();    &#125;</code></pre><p><img src="/images/View-Layout.png" srcset="/img/loading.gif" alt="View-Layout"></p><p>按照流程图总结一下：</p><ul><li>View调用<code>layout()</code>开始布局过程(<code>确定最终宽高以及四个顶点的位置</code>)</li><li>根据是否有边缘效果(<code>例如发光，阴影</code>)<ul><li>有边缘效果，调用<code>setOpticalFrame()</code>去除边缘的影响，最终还是调用<code>setFrame()</code>设立自己的四个顶点</li><li>无边缘效果，调用<code>setFrame()</code>设立自己的四个顶点</li></ul></li><li>最后调用<code>onLayout()</code>最终确立宽高以及四点坐标。</li></ul><h4 id="ViewGroup的layout过程"><a href="#ViewGroup的layout过程" class="headerlink" title="ViewGroup的layout过程"></a>ViewGroup的layout过程</h4><p>当有子View存在的时候，需要遍历子View进行<code>layout</code>过程。即需要在<code>onLayout()</code>方法实现子View的<code>layout</code>。</p><pre><code class="hljs java"><span class="hljs-comment">//源码与上述相同 由于ViewGroup中所有子View的layout都需要实现，所以需要实现 onLayout() 方法</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> top,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> bottom)</span></span>&#123;    <span class="hljs-comment">//遍历子View</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span> ; i &lt;getChildCount();i++)&#123;        View child = getChildAt(i);                <span class="hljs-comment">//在这里可以添加 顶点变化逻辑</span>        <span class="hljs-keyword">int</span> childTop = Top;        <span class="hljs-keyword">int</span> childLeft = Left;        <span class="hljs-keyword">int</span> childBottom = Bottom;        <span class="hljs-keyword">int</span> childRight = Right;                 ...        setChildFrame(child,childLeft,childTop,childRight,childBottom);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChildFrame</span><span class="hljs-params">(child,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-comment">//按照上一节流程走</span>    child.layout(l,t,r,b);&#125;</code></pre><p><img src="/images/ViewGroup-Layout.png" srcset="/img/loading.gif" alt="ViewGroup-Layout"></p><p>按照流程图简单总结一下：</p><ul><li>先调用ViewGroup的<code>layout()</code>，先对ViewGroup进行布局过程</li><li>在ViewGroup的<code>onLayout()</code>中实现子View的遍历布局过程</li><li>对遍历的子View按照ViewGroup的要求进行顶点坐标的计算，计算完成后调用子View的<code>layout()</code></li></ul><p>拓展：</p><ol><li><p>View的测量宽/高(<code>getMeasureWidth()/getMeasureHeight()</code>)与最终得到的宽/高(<code>getWidth()/getHeight()</code>)有什么区别？</p><pre><code class="hljs java"><span class="hljs-comment">//获得View在测量过程中的宽</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMeasuredWidth</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;    &#125;<span class="hljs-comment">//获得View在测量过程中的高</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMeasuredHeight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mMeasuredHeight &amp; MEASURED_SIZE_MASK;    &#125;<span class="hljs-comment">//上节 measure 源码分析中就是调用了该方法 进行View的测量</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMeasuredDimensionRaw</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measuredWidth, <span class="hljs-keyword">int</span> measuredHeight)</span> </span>&#123;        mMeasuredWidth = measuredWidth;        mMeasuredHeight = measuredHeight;        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;    &#125;<span class="hljs-comment">//获得View最终宽</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mRight - mLeft;    &#125;<span class="hljs-comment">//获得View最终高</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mBottom - mTop;    &#125;</code></pre><blockquote><p>两者的比较</p></blockquote></li></ol><table><thead><tr><th style="text-align:left">类型</th><th>何时赋值</th><th>赋值方法</th><th>使用场景</th></tr></thead><tbody><tr><td style="text-align:left">View测量结束宽/高<br>getMeasureWidth()/getMeasureHeight()</td><td>View的<code>measure</code>过程</td><td><code>setMeasureDimension()</code></td><td>在<code>onLayout()</code>获取View的宽/高</td></tr><tr><td style="text-align:left">View最终宽/高<br>getWidth()/getHeight()</td><td>View的<code>layout</code>过程</td><td><code>layout()</code>对top,left,right,bottom进行操作</td><td><code>onLayout()</code>结束后获取最终宽/高</td></tr></tbody></table><p>   <strong>一般情况下，二者返回的数据是相同的，除非人为对View的<code>layout()</code>进行重写。</strong></p>   <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">super</span>.layout(j,t,r+<span class="hljs-number">100</span>,b+<span class="hljs-number">100</span>);&#125;</code></pre><p>   上述代码就会导致View最终结果与测量时不同。</p><h3 id="draw-绘制"><a href="#draw-绘制" class="headerlink" title="draw-绘制"></a>draw-绘制</h3><blockquote><p>draw作用主要将View绘制在屏幕上面</p><p><strong>draw过程，先draw自身再draw子View</strong></p></blockquote><h4 id="View的draw过程"><a href="#View的draw过程" class="headerlink" title="View的draw过程"></a>View的draw过程</h4><p>View的draw过程，从<code>View.draw()</code>开始</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/View.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;    <span class="hljs-comment">//标记当前View是否需要绘制背景</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;                (mAttachInfo == <span class="hljs-keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);        <span class="hljs-keyword">int</span> saveCount;        <span class="hljs-comment">//1. 绘制背景</span>    <span class="hljs-keyword">if</span> (!dirtyOpaque) &#123;            drawBackground(canvas);        &#125;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> viewFlags = mViewFlags;    <span class="hljs-comment">//是否有水平边缘</span>    <span class="hljs-keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="hljs-number">0</span>;    <span class="hljs-comment">//是否有竖直边缘</span>    <span class="hljs-keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(!horizontalEdges &amp;&amp; !verticalEdges)&#123;       <span class="hljs-comment">// 3.绘制View本身</span>          <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);       <span class="hljs-comment">// 4.绘制子View</span>          dispatchDraw(canvas);               <span class="hljs-comment">// 6.绘制装饰 例如滚动条</span>          onDrawForeground(canvas);            ...       <span class="hljs-keyword">return</span>;     &#125;        <span class="hljs-comment">//如果有竖直边缘或者水平边缘 例如divide</span>        <span class="hljs-comment">// 2. 保存当前Canvas层</span>        saveCount = canvas.getSaveCount();        <span class="hljs-keyword">int</span> solidColor = getSolidColor();        <span class="hljs-keyword">if</span> (solidColor == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;            <span class="hljs-keyword">if</span> (drawTop) &#123;                canvas.saveLayer(left, top, right, top + length, <span class="hljs-keyword">null</span>, flags);            &#125;            <span class="hljs-keyword">if</span> (drawBottom) &#123;                canvas.saveLayer(left, bottom - length, right, bottom, <span class="hljs-keyword">null</span>, flags);            &#125;            <span class="hljs-keyword">if</span> (drawLeft) &#123;                canvas.saveLayer(left, top, left + length, bottom, <span class="hljs-keyword">null</span>, flags);            &#125;            <span class="hljs-keyword">if</span> (drawRight) &#123;                canvas.saveLayer(right - length, top, right, bottom, <span class="hljs-keyword">null</span>, flags);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            scrollabilityCache.setFadeColor(solidColor);        &#125;    ...        <span class="hljs-comment">// 3.绘制View本身</span>          <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);       <span class="hljs-comment">// 4.绘制子View</span>          dispatchDraw(canvas);        ...        <span class="hljs-comment">// 5.绘制边缘效果 例如阴影</span>        canvas.restoreToCount(saveCount);    ...               <span class="hljs-comment">// 6.绘制装饰 例如滚动条</span>          onDrawForeground(canvas);    ...    &#125;<span class="hljs-comment">//绘制View本身的背景</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawBackground</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;        <span class="hljs-keyword">final</span> Drawable background = mBackground;        <span class="hljs-keyword">if</span> (background == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//设置View的背景边界</span>        setBackgroundBounds();        ...                  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrollX = mScrollX;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scrollY = mScrollY;        <span class="hljs-keyword">if</span> ((scrollX | scrollY) == <span class="hljs-number">0</span>) &#123;            background.draw(canvas);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//将画布偏移 然后在偏移后的画布上进行背景绘制</span>            canvas.translate(scrollX, scrollY);            background.draw(canvas);            canvas.translate(-scrollX, -scrollY);        &#125;    &#125;<span class="hljs-comment">//绘制View本身的内容</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;    <span class="hljs-comment">// 默认空实现 需要子类复写该方法以实现内容的绘制 ，自定义View中必须执行该方法</span>    &#125;<span class="hljs-comment">//绘制子View的内容</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;    <span class="hljs-comment">//由于View不存在子View，所以不需要实现</span>    &#125;<span class="hljs-comment">//绘制装饰 例如滚动条 前景图片</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDrawForeground</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;        onDrawScrollIndicators(canvas);        onDrawScrollBars(canvas);        <span class="hljs-keyword">final</span> Drawable foreground = mForegroundInfo != <span class="hljs-keyword">null</span> ? mForegroundInfo.mDrawable : <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (foreground != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (mForegroundInfo.mBoundsChanged) &#123;                mForegroundInfo.mBoundsChanged = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">final</span> Rect selfBounds = mForegroundInfo.mSelfBounds;                <span class="hljs-keyword">final</span> Rect overlayBounds = mForegroundInfo.mOverlayBounds;                <span class="hljs-keyword">if</span> (mForegroundInfo.mInsidePadding) &#123;                    selfBounds.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, getWidth(), getHeight());                &#125; <span class="hljs-keyword">else</span> &#123;                    selfBounds.set(getPaddingLeft(), getPaddingTop(),                            getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());                &#125;                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ld = getLayoutDirection();                Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);                foreground.setBounds(overlayBounds);            &#125;            foreground.draw(canvas);        &#125;    &#125;</code></pre><p><img src="/images/View-Draw.png" srcset="/img/loading.gif" alt="View-Draw"></p><p>结合上述流程图分析Draw过程：</p><ul><li>先调用<code>View.draw()</code>方法开始Draw流程</li><li>如果需要<code>dirtyOpaque</code>，就绘制背景<code>drawBackground()</code></li><li>如果需要显示边缘效果，就进行保存画布<code>canvas.saveLayer()</code></li><li>如果需要<code>dirtyOpaque</code>，绘制自身的内容<code>onDraw()</code> – <strong>自定义View必须实现</strong></li><li>调用<code>dispatchDraw()</code>绘制子View</li><li>如果需要显示边缘效果，绘制后，还原画布<code>canvas.restore()</code></li><li>调用<code>drawForeground()</code>绘制装饰，例如滚动条或前景</li></ul><h4 id="ViewGroup的draw过程"><a href="#ViewGroup的draw过程" class="headerlink" title="ViewGroup的draw过程"></a>ViewGroup的draw过程</h4><p>ViewGroup的draw过程主要调整了上述源码中的<code>dispatchDraw()</code>，在其内部进行了子View的遍历以及绘制过程</p><pre><code class="hljs java"> <span class="hljs-comment">// ../android/view/ViewGroup.java</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childrenCount = mChildrenCount;        <span class="hljs-keyword">final</span> View[] children = mChildren;    ...        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;            <span class="hljs-keyword">while</span> (transientIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;                <span class="hljs-keyword">final</span> View transientChild = mTransientViews.get(transientIndex);                <span class="hljs-keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||                        transientChild.getAnimation() != <span class="hljs-keyword">null</span>) &#123;                    more |= drawChild(canvas, transientChild, drawingTime);                &#125;                transientIndex++;                <span class="hljs-keyword">if</span> (transientIndex &gt;= transientCount) &#123;                    transientIndex = -<span class="hljs-number">1</span>;                &#125;            &#125;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;                more |= drawChild(canvas, child, drawingTime);            &#125;        &#125;    ...&#125;<span class="hljs-comment">//绘制子View</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">drawChild</span><span class="hljs-params">(Canvas canvas, View child, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;      <span class="hljs-comment">//调用子View的draw方法</span>      <span class="hljs-keyword">return</span> child.draw(canvas, <span class="hljs-keyword">this</span>, drawingTime);&#125;</code></pre><p><img src="/images/ViewGroup-Draw.png" srcset="/img/loading.gif" alt="ViewGroup-Draw"></p><p>结合上述流程图分析ViewGroup的Draw过程：</p><ul><li>draw过程与上述<code>View的draw过程一致</code></li><li><code>dispatchDraw()</code>默认实现，内部包含了子View的遍历以及绘制</li></ul><p>拓展：</p><ol><li><p><code>View.setWillNotDraw()</code>有什么意义?</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWillNotDraw</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> willNotDraw)</span> </span>&#123;    <span class="hljs-comment">//设置 不需绘制 标记位</span>    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="hljs-number">0</span>, DRAW_MASK);&#125;</code></pre><p>如果一个View不需要绘制任何内容，设置这个标记为<code>true</code>，系统就会进行相应优化。</p><p><strong><em>View默认不开启<code>willNotDraw</code>标记位，ViewGroup默认开启。</em></strong></p></li><li><p><code>ViewGroup</code>修改子View绘制顺序</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDraw</span><span class="hljs-params">(Canvas canvas)</span></span>&#123;  ...    <span class="hljs-comment">//设置自定义绘制顺序</span>   <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties                ? <span class="hljs-keyword">null</span> : buildOrderedChildList();        <span class="hljs-comment">//是否允许自定义绘制顺序</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = preorderedList == <span class="hljs-keyword">null</span>                &amp;&amp; isChildrenDrawingOrderEnabled();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;            <span class="hljs-keyword">while</span> (transientIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;                <span class="hljs-keyword">final</span> View transientChild = mTransientViews.get(transientIndex);                <span class="hljs-keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||                        transientChild.getAnimation() != <span class="hljs-keyword">null</span>) &#123;                    more |= drawChild(canvas, transientChild, drawingTime);                &#125;                transientIndex++;                <span class="hljs-keyword">if</span> (transientIndex &gt;= transientCount) &#123;                    transientIndex = -<span class="hljs-number">1</span>;                &#125;            &#125;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="hljs-keyword">null</span>) &#123;                more |= drawChild(canvas, child, drawingTime);            &#125;        &#125;  ...&#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isChildrenDrawingOrderEnabled</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (mGroupFlags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == FLAG_USE_CHILD_DRAWING_ORDER;    &#125;<span class="hljs-comment">//设置是否允许自定义绘制顺序</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChildrenDrawingOrderEnabled</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> enabled)</span> </span>&#123;        setBooleanFlag(FLAG_USE_CHILD_DRAWING_ORDER, enabled);    &#125; <span class="hljs-comment">//初始子View的绘制顺序 按照z轴的值调整绘制顺序，z轴从大到小绘制</span>    <span class="hljs-function">ArrayList&lt;View&gt; <span class="hljs-title">buildOrderedChildList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childrenCount = mChildrenCount;        <span class="hljs-keyword">if</span> (childrenCount &lt;= <span class="hljs-number">1</span> || !hasChildWithZ()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (mPreSortedChildren == <span class="hljs-keyword">null</span>) &#123;            mPreSortedChildren = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(childrenCount);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// callers should clear, so clear shouldn't be necessary, but for safety...</span>            mPreSortedChildren.clear();            mPreSortedChildren.ensureCapacity(childrenCount);        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> customOrder = isChildrenDrawingOrderEnabled();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;            <span class="hljs-comment">// add next child (in child order) to end of list</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);            <span class="hljs-keyword">final</span> View nextChild = mChildren[childIndex];            <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> currentZ = nextChild.getZ();            <span class="hljs-comment">// insert ahead of any Views with greater Z</span>            <span class="hljs-keyword">int</span> insertIndex = i;            <span class="hljs-keyword">while</span> (insertIndex &gt; <span class="hljs-number">0</span> &amp;&amp; mPreSortedChildren.get(insertIndex - <span class="hljs-number">1</span>).getZ() &gt; currentZ) &#123;                insertIndex--;            &#125;            mPreSortedChildren.add(insertIndex, nextChild);        &#125;        <span class="hljs-keyword">return</span> mPreSortedChildren;    &#125;    <span class="hljs-comment">//确定当前子View的绘制顺序</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndVerifyPreorderedIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> childrenCount, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">boolean</span> customOrder)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex;        <span class="hljs-keyword">if</span> (customOrder) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex1 = getChildDrawingOrder(childrenCount, i);            <span class="hljs-keyword">if</span> (childIndex1 &gt;= childrenCount) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"getChildDrawingOrder() "</span>                        + <span class="hljs-string">"returned invalid index "</span> + childIndex1                        + <span class="hljs-string">" (child count is "</span> + childrenCount + <span class="hljs-string">")"</span>);            &#125;            childIndex = childIndex1;        &#125; <span class="hljs-keyword">else</span> &#123;            childIndex = i;        &#125;        <span class="hljs-keyword">return</span> childIndex;    &#125;<span class="hljs-comment">//需要重写该方法，调整绘制顺序</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getChildDrawingOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> childCount, <span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">return</span> i;    &#125;<span class="hljs-comment">//调整当前子View顺序</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> View <span class="hljs-title">getAndVerifyPreorderedView</span><span class="hljs-params">(ArrayList&lt;View&gt; preorderedList, View[] children,            <span class="hljs-keyword">int</span> childIndex)</span> </span>&#123;        <span class="hljs-keyword">final</span> View child;        <span class="hljs-keyword">if</span> (preorderedList != <span class="hljs-keyword">null</span>) &#123;            child = preorderedList.get(childIndex);            <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Invalid preorderedList contained null child at index "</span>                        + childIndex);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            child = children[childIndex];        &#125;        <span class="hljs-keyword">return</span> child;    &#125;</code></pre></li></ol><p>   根据上述源码，默认的绘制<strong>按照z轴从大到小的顺序</strong>进行绘制，如果需要修改绘制顺序的话，需要执行以下两步：</p><ol><li><code>setChildrenDrawingEnabled(true)</code>打开自定义设置开关</li><li><p>继承<code>ViewGroup</code>后，重写<code>getChildDrawingOrder()</code>方法，设置对应的绘制顺序</p><p>常用的<code>RecyclerView</code>、<code>ViewPager</code>都实现了该方法，其中<code>RecyclerView</code>通过设置<code>ChildDrawingOrderCallback</code>也可以实现这个功能。</p></li></ol><h2 id="自定义View-1"><a href="#自定义View-1" class="headerlink" title="自定义View"></a>自定义View</h2><blockquote><p>自定义View需要了解View的层次、View的事件分发机制以及View的工作流程。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="1-继承View重写onDraw"><a href="#1-继承View重写onDraw" class="headerlink" title="1.继承View重写onDraw()"></a>1.继承View重写<code>onDraw()</code></h4><blockquote><p>主要用于实现一些不规则的效果，不方便通过布局的组合方法可以直接实现，往往需要静态或者动态的显示一些不规则图形(圆形啥的)。</p><p>特殊形状的这种就需要重写<code>onDraw()</code>实现。<strong>一般需要额外支持wrtap_content，并且也需要处理padding方法。</strong></p></blockquote><h4 id="2-继承ViewGroup派生特殊的Layout"><a href="#2-继承ViewGroup派生特殊的Layout" class="headerlink" title="2.继承ViewGroup派生特殊的Layout"></a>2.继承ViewGroup派生特殊的Layout</h4><blockquote><p>主要用于实现自定义的布局，除了常用的一些布局外。实现的是几种View的组合形式</p><p><strong>实现稍微复杂，需要合适的处理ViewGroup的<code>onMeasure()，onLayout()</code>以及子View的<code>onMeasure()，onLayout()</code></strong></p></blockquote><h4 id="3-继承特定的View-例如TextView"><a href="#3-继承特定的View-例如TextView" class="headerlink" title="3.继承特定的View(例如TextView)"></a>3.继承特定的View(例如TextView)</h4><blockquote><p>这种比较常见，一般用于拓展已有View的功能。</p><p><strong>实现比较简单，无需自己处理wrap_content以及padding</strong></p></blockquote><h4 id="4-继承特定的ViewGroup-例如LinearLayout"><a href="#4-继承特定的ViewGroup-例如LinearLayout" class="headerlink" title="4.继承特定的ViewGroup(例如LinearLayout)"></a>4.继承特定的ViewGroup(例如LinearLayout)</h4><blockquote><p>比较常见，当某种效果看起来很像几种View组合在一起的时候</p><p><strong>实现比较简单，无需自己处理测量以及布局过程</strong></p></blockquote><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-让View支持wrap-content"><a href="#1-让View支持wrap-content" class="headerlink" title="1.让View支持wrap_content"></a>1.让View支持wrap_content</h4><blockquote><p>直接继承View或ViewGroup的控件，不重写<code>onMeasure()</code>并对<code>AT_MOST</code>进行处理，就无法达到需要的显示效果。</p></blockquote><h4 id="2-需要的话，让View支持padding"><a href="#2-需要的话，让View支持padding" class="headerlink" title="2.需要的话，让View支持padding"></a>2.需要的话，让View支持padding</h4><blockquote><p>直接继承View的控件，需要在<code>draw</code>过程处理padding属性，不然padding属性无法起作用。</p><p>直接继承ViewGroup的控件，需要在<code>onMeasure()，onLayout()</code>处理自身的padding以及子View的margin</p></blockquote><h4 id="3-尽量不要在View中使用Handler"><a href="#3-尽量不要在View中使用Handler" class="headerlink" title="3.尽量不要在View中使用Handler"></a>3.尽量不要在View中使用Handler</h4><blockquote><p>View内部提供了<code>post</code>方法，可以替代Handler使用</p></blockquote><h4 id="4-View中如果有线程或动画，需要及时停止"><a href="#4-View中如果有线程或动画，需要及时停止" class="headerlink" title="4.View中如果有线程或动画，需要及时停止"></a>4.View中如果有线程或动画，需要及时停止</h4><blockquote><ol><li>不处理有可能造成内存泄漏，View不可见时也需要停止线程和动画</li><li>包含View的Activity启动时，View的<code>onAccachedToWindow()</code>会调用</li><li>包含View的Activity退出或当前View被移除时，调用<code>View.onDetachedFromWindow()</code>时关闭线程和动画</li></ol></blockquote><h4 id="5-View若有滑动冲突情况，需要处理"><a href="#5-View若有滑动冲突情况，需要处理" class="headerlink" title="5.View若有滑动冲突情况，需要处理"></a>5.View若有滑动冲突情况，需要处理</h4><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><a href="/2019/01/02/自定义View实践/" title="自定义View实践">自定义View实践</a><a href="/2019/01/02/自定义ViewGroup实践/" title="自定义ViewGroup实践">自定义ViewGroup实践</a><h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><h3 id="如何触发View的重新绘制？"><a href="#如何触发View的重新绘制？" class="headerlink" title="如何触发View的重新绘制？"></a>如何触发View的重新绘制？</h3><p>通过调用<code>invalidate()/postInvalidate()</code>或<code>requestLayout()</code>实现。</p><h4 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h4><blockquote><p>在需要刷新<code>View</code>的布局时会调用该函数。不应该在布局的过程中调用这个函数。</p><p>这个请求可能会在以下场景执行：当前布局结束、当前帧绘制完成，下次布局发生时</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//View.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (mMeasureCache != <span class="hljs-keyword">null</span>) mMeasureCache.clear();        <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// Only trigger request-during-layout logic if this is the view requesting it,</span>            <span class="hljs-comment">// not the views in its parent hierarchy</span>            ViewRootImpl viewRoot = getViewRootImpl();            <span class="hljs-keyword">if</span> (viewRoot != <span class="hljs-keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;                <span class="hljs-keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="hljs-keyword">this</span>)) &#123;                  <span class="hljs-comment">//如果当前在layout过程中，且调用了 requestLayout，就需要直接返回</span>                  <span class="hljs-comment">//等待下一次信号到来时执行</span>                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-comment">//设置强制刷新标记</span>        mPrivateFlags |= PFLAG_FORCE_LAYOUT;<span class="hljs-comment">//该标记可执行onMeasure()</span>        mPrivateFlags |= PFLAG_INVALIDATED;<span class="hljs-comment">//</span>        <span class="hljs-keyword">if</span> (mParent != <span class="hljs-keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;            <span class="hljs-comment">//向父布局继续请求刷新布局</span>            mParent.requestLayout();        &#125;        <span class="hljs-keyword">if</span> (mAttachInfo != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="hljs-keyword">this</span>) &#123;            mAttachInfo.mViewRequestingLayout = <span class="hljs-keyword">null</span>;        &#125;    &#125;</code></pre><p><code>mParent</code>对应父节点，一层层向上递归调用父节点<code>requestLayout()。</code>直到调用<code>ViewRootImpl.requestLayout()</code>结束.</p><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;          <span class="hljs-comment">//检查当前是否主线程</span>            checkThread();            mLayoutRequested = <span class="hljs-keyword">true</span>;            scheduleTraversals();        &#125;    &#125;</code></pre><p>调用到<code>scheduleTraversals()</code>就是开始了<code>View的绘制流程</code>。</p><p>一开始调用的<code>performMeasure()</code></p><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> childWidthMeasureSpec, <span class="hljs-keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;       ...        <span class="hljs-keyword">try</span> &#123;            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);        &#125; <span class="hljs-keyword">finally</span> &#123;            Trace.traceEnd(Trace.TRACE_TAG_VIEW);        &#125;    &#125;<span class="hljs-comment">//View.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;      ...        <span class="hljs-comment">//需要执行onMeasure</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;      ...        <span class="hljs-keyword">if</span> (forceLayout || needsLayout) &#123;          ...            onMeasure(widthMeasureSpec, heightMeasureSpec);          ...            <span class="hljs-comment">//添加 PFLAG_LAYOUT_REQUIRED标记，表示需要执行 layout流程</span>             mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;        &#125;    &#125;</code></pre><p>继续向下调用<code>performLayout()</code></p><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performLayout</span><span class="hljs-params">(WindowManager.LayoutParams lp, <span class="hljs-keyword">int</span> desiredWindowWidth,            <span class="hljs-keyword">int</span> desiredWindowHeight)</span> </span>&#123;       <span class="hljs-comment">//正在执行layout流程</span>       mInLayout = <span class="hljs-keyword">true</span>;       <span class="hljs-keyword">final</span> View host = mView;<span class="hljs-comment">//对应DecorView</span>       <span class="hljs-comment">//在layout过程中 尚未执行requestLayout的view</span>       <span class="hljs-keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();       <span class="hljs-keyword">if</span> (numViewsRequestingLayout &gt; <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">//寻找mPrivateFlags为PFLAG_FORCE_LAYOUT的View</span>           ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,                        <span class="hljs-keyword">false</span>);                <span class="hljs-keyword">if</span> (validLayoutRequesters != <span class="hljs-keyword">null</span>) &#123;                  <span class="hljs-comment">//当前View重新measure</span>                     measureHierarchy(host, lp, mView.getContext().getResources(),                            desiredWindowWidth, desiredWindowHeight);                       <span class="hljs-comment">//重新执行layout</span>                     host.layout(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());                    ...                    <span class="hljs-comment">//寻找尚未设置 PFLAG_FORCE_LAYOUT的View</span>                     validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="hljs-keyword">true</span>);                                        <span class="hljs-keyword">if</span> (validLayoutRequesters != <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;                        <span class="hljs-comment">// 执行requestLayout在下一帧执行时</span>                        getRunQueue().post(<span class="hljs-keyword">new</span> Runnable() &#123;                            <span class="hljs-meta">@Override</span>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                                <span class="hljs-keyword">int</span> numValidRequests = finalRequesters.size();                                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numValidRequests; ++i) &#123;                                    <span class="hljs-keyword">final</span> View view = finalRequesters.get(i);                                    Log.w(<span class="hljs-string">"View"</span>, <span class="hljs-string">"requestLayout() improperly called by "</span> + view +                                            <span class="hljs-string">" during second layout pass: posting in next frame"</span>);                                    view.requestLayout();                                &#125;                            &#125;                        &#125;);                    &#125;                                 &#125;       &#125;          &#125;</code></pre><p>主要执行了三步：</p><ul><li>执行<code>DecorView</code>的<code>layout</code>过程</li><li>执行调用过<code>requestLayout()</code>的View(包含<code>PFLAG_FORCE_LAYOUT</code>标志)的<code>measure</code>和<code>layout</code></li><li>还没调用过<code>requestLayout()</code>的View加入到队列中，等待下一帧绘制时执行</li></ul><pre><code class="hljs java"><span class="hljs-comment">//View.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;      <span class="hljs-comment">//判断当前位置是否发生变化</span>        <span class="hljs-keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);            <span class="hljs-comment">//位置发生变化。或 需要layout</span>        <span class="hljs-keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;          <span class="hljs-comment">//回调onLayout()</span>            onLayout(changed, l, t, r, b);          ...         <span class="hljs-comment">//移除 PFLAG_LAYOUT_REQUIRED标志 在measure过程添加   </span>          mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;          ...        &#125;      ...        <span class="hljs-comment">//layout过程完成后 移除 PFLAG_FORCE_LAYOUT标志</span>        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;                  &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;      <span class="hljs-comment">//位置发生变化时，就需要执行 invalidate()重绘View</span>      <span class="hljs-keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;         <span class="hljs-keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);          <span class="hljs-comment">//需要重绘视图</span>            invalidate(sizeChanged);      &#125;    &#125;</code></pre><blockquote><p><code>requestLayout()</code>主要执行了以下几步：</p><ul><li>添加<code>PFLAG_FORCE_LAYOUT</code>和<code>PFLAG_INVALIDATED</code>标记</li><li><code>measure</code>执行需要判断<code>PFLAG_FORCE_LAYOUT</code>标记是否存在</li><li><code>measure</code>执行后，添加<code>PFLAG_LAYOUT_REQUIRED</code>标记，可以去执行<code>onLayout()</code></li><li><code>layout</code>执行后，移除<code>PFLAG_LAYOUT_REQUIRED</code>和<code>PFLAG_FORCE_LAYOUT</code>标记</li><li>在<code>layout</code>过程中，如果位置发生了变化，会执行到<code>invalidate()</code>，可能会执行<code>draw</code>过程；如果未发生变化，就不会执行<code>draw</code>过程</li></ul></blockquote><h4 id="invalidate-postInvalidate"><a href="#invalidate-postInvalidate" class="headerlink" title="invalidate/postInvalidate"></a>invalidate/postInvalidate</h4><blockquote><p><code>invalidate()</code>必须在主线程调用。<code>postInvalidate()</code>可以在子线程调用(通过handler发送消息到主线程调用)</p><p>主要用于请求View的重绘，只会影响到View的<code>draw</code>过程</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//View.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postInvalidate</span><span class="hljs-params">()</span> </span>&#123;        postInvalidateDelayed(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchInvalidateDelayed</span><span class="hljs-params">(View view, <span class="hljs-keyword">long</span> delayMilliseconds)</span> </span>&#123;        Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);        mHandler.sendMessageDelayed(msg, delayMilliseconds);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;            <span class="hljs-keyword">switch</span> (msg.what) &#123;                <span class="hljs-keyword">case</span> MSG_INVALIDATE:                    ((View) msg.obj).invalidate();<span class="hljs-comment">//继续执行到invalidate()</span>                    <span class="hljs-keyword">break</span>;                ...            &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidate</span><span class="hljs-params">()</span> </span>&#123;        invalidate(<span class="hljs-keyword">true</span>);    &#125;</code></pre><p>最终执行到<code>invalidateInternal()</code></p><pre><code class="hljs java"><span class="hljs-comment">//View.java</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidateInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">boolean</span> invalidateCache,            <span class="hljs-keyword">boolean</span> fullInvalidate)</span> </span>&#123;        ...        <span class="hljs-comment">//当前View不可见</span>        <span class="hljs-keyword">if</span> (skipInvalidate()) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)                || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)                || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED<span class="hljs-comment">//当前没有执行invalidate</span>                || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;          <span class="hljs-comment">//需要全量重绘</span>            <span class="hljs-keyword">if</span> (fullInvalidate) &#123;                mLastIsOpaque = isOpaque();              <span class="hljs-comment">//添加重绘标记</span>                mPrivateFlags &amp;= ~PFLAG_DRAWN;            &#125;           <span class="hljs-comment">//添加当前View重绘标记</span>            mPrivateFlags |= PFLAG_DIRTY;           <span class="hljs-comment">//是否刷新缓存</span>            <span class="hljs-keyword">if</span> (invalidateCache) &#123;                mPrivateFlags |= PFLAG_INVALIDATED;                mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;            &#125;            <span class="hljs-comment">// Propagate the damage rectangle to the parent view.</span>            <span class="hljs-keyword">final</span> AttachInfo ai = mAttachInfo;            <span class="hljs-keyword">final</span> ViewParent p = mParent;            <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; ai != <span class="hljs-keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;                <span class="hljs-keyword">final</span> Rect damage = ai.mTmpInvalRect;                damage.set(l, t, r, b);              <span class="hljs-comment">//设置重绘区域 并把自身传递到父布局</span>                p.invalidateChild(<span class="hljs-keyword">this</span>, damage);            &#125;          ...        &#125;    &#125;</code></pre><p>上述代码修改标记完成后，调用父类的<code>invalidateChild()</code>将需要重绘的区域(<code>脏区域</code>)传入。(<code>ViewGroup以及ViewRootImpl都继承自ViewParent类</code>)</p><blockquote><p>脏区域：<em>为了保证绘制的效率，控件树仅对需要绘制的区域进行重绘，需要重绘的区域成为<code>脏区域</code></em>。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//ViewGroup.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidateChild</span><span class="hljs-params">(View child, <span class="hljs-keyword">final</span> Rect dirty)</span> </span>&#123;      <span class="hljs-comment">//开启硬件加速</span>        <span class="hljs-keyword">if</span> (attachInfo != <span class="hljs-keyword">null</span> &amp;&amp; attachInfo.mHardwareAccelerated) &#123;            <span class="hljs-comment">// 更新DisplayList</span>            onDescendantInvalidated(child, child);            <span class="hljs-keyword">return</span>;        &#125;               <span class="hljs-comment">//当前View是否 不透明</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp;                    child.getAnimation() == <span class="hljs-keyword">null</span> &amp;&amp; childMatrix.isIdentity();         <span class="hljs-comment">//全不透明 标记为 PFLAG_DIRTY_OPAQUE</span>        <span class="hljs-comment">//部分透明 标记为 PFLAG_DIRTY</span>        <span class="hljs-keyword">int</span> opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;      ...        <span class="hljs-keyword">do</span> &#123;                View view = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> View) &#123;                    view = (View) parent;                &#125;                <span class="hljs-keyword">if</span> (drawAnimation) &#123;                    <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> ViewRootImpl) &#123;                        ((ViewRootImpl) parent).mIsAnimating = <span class="hljs-keyword">true</span>;                    &#125;                &#125;                <span class="hljs-comment">// If the parent is dirty opaque or not dirty, mark it dirty with the opaque</span>                <span class="hljs-comment">// flag coming from the child that initiated the invalidate</span>                <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class="hljs-number">0</span> &amp;&amp;                            view.getSolidColor() == <span class="hljs-number">0</span>) &#123;                        opaqueFlag = PFLAG_DIRTY;                    &#125;                    <span class="hljs-keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;                        view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;                    &#125;                &#125;                <span class="hljs-comment">//递归调用父布局的重绘方法</span>                parent = parent.invalidateChildInParent(location, dirty);                <span class="hljs-comment">//计算需要重绘区域</span>                dirty.set((<span class="hljs-keyword">int</span>) Math.floor(boundingRect.left),                                (<span class="hljs-keyword">int</span>) Math.floor(boundingRect.top),                                (<span class="hljs-keyword">int</span>) Math.ceil(boundingRect.right),                                (<span class="hljs-keyword">int</span>) Math.ceil(boundingRect.bottom));                          ...            &#125; <span class="hljs-keyword">while</span> (parent != <span class="hljs-keyword">null</span>);          &#125;<span class="hljs-comment">//ViewGroup.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewParent <span class="hljs-title">invalidateChildInParent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] location, <span class="hljs-keyword">final</span> Rect dirty)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">//将子View转换为当前View显示的位置</span>          ...        &#125;    &#125;</code></pre><p>当<code>parent==null</code>时，表示已经到了最顶层<code>ViewRootImpl</code></p><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewParent <span class="hljs-title">invalidateChildInParent</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] location, Rect dirty)</span> </span>&#123;      <span class="hljs-comment">//检查当前是否主线程</span>        checkThread();        <span class="hljs-keyword">if</span> (DEBUG_DRAW) Log.v(mTag, <span class="hljs-string">"Invalidate child: "</span> + dirty);        <span class="hljs-keyword">if</span> (dirty == <span class="hljs-keyword">null</span>) &#123;            invalidate();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;       ...      <span class="hljs-comment">//更新屏幕对应脏区域</span>        invalidateRectOnScreen(dirty);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidateRectOnScreen</span><span class="hljs-params">(Rect dirty)</span> </span>&#123;        <span class="hljs-keyword">final</span> Rect localDirty = mDirty;        <span class="hljs-keyword">if</span> (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;            mAttachInfo.mSetIgnoreDirtyState = <span class="hljs-keyword">true</span>;            mAttachInfo.mIgnoreDirtyState = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// Add the new dirty rect to the current one</span>        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);        <span class="hljs-comment">// Intersect with the bounds of the window to skip</span>        <span class="hljs-comment">// updates that lie outside of the visible region</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> appScale = mAttachInfo.mApplicationScale;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intersected = localDirty.intersect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>,                (<span class="hljs-keyword">int</span>) (mWidth * appScale + <span class="hljs-number">0.5f</span>), (<span class="hljs-keyword">int</span>) (mHeight * appScale + <span class="hljs-number">0.5f</span>));        <span class="hljs-keyword">if</span> (!intersected) &#123;            localDirty.setEmpty();        &#125;        <span class="hljs-keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;          <span class="hljs-comment">//执行绘制流程</span>            scheduleTraversals();        &#125;    &#125;</code></pre><p>通过<code>scheduleTraversals()</code>执行绘制流程，由于未设置<code>PFLAG_FORCE_LAYOUT</code>无法执行<code>measure</code>过程，如果位置没有发生变化后续<code>layout</code>也无法执行。</p><p>最后调用<code>performDraw()</code></p><pre><code class="hljs java"><span class="hljs-comment">//ViewRootImpl.java</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performDraw</span><span class="hljs-params">()</span> </span>&#123;      ...        <span class="hljs-keyword">boolean</span> canUseAsync = draw(fullRedrawNeeded);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;            <span class="hljs-keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="hljs-keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;              <span class="hljs-comment">//硬件绘制</span>              ...                mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="hljs-keyword">this</span>, callback);                          &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-comment">//软件绘制</span>              ...              <span class="hljs-keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,                        scalingRequired, dirty, surfaceInsets)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;          ...    &#125;</code></pre><p>向下调用到<code>View.draw()</code></p><pre><code class="hljs java"><span class="hljs-comment">//View.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;                (mAttachInfo == <span class="hljs-keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);        <span class="hljs-keyword">if</span> (!dirtyOpaque) &#123;            drawBackground(canvas);<span class="hljs-comment">//绘制背景</span>        &#125;        <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);<span class="hljs-comment">//绘制自身</span>        dispatchDraw(canvas); <span class="hljs-comment">//绘制子View </span>        onDrawForeground(canvas);<span class="hljs-comment">//绘制前景</span>    &#125;</code></pre><p>关键在于是否持有<code>PFLAG_DIRTY_OPAQUE</code>标志，这个标志主要是在<code>invalidate()</code>打上的。</p><blockquote><p><code>invalidate()</code>通过设置<code>PFLAG_INVALIDATED</code>和<code>PFLAG_DRAWING_CACHE_VALID</code>标记，然后执行<code>invalidateChild()</code>通过层层向上调用<code>parent.invalidateChildInParent()</code>把需要重新绘制的区域传递上去，直到达到<code>ViewRootImpl</code>为止。最后调用到<code>invalidateRectOnScreen()</code>传入最终需要重新绘制的区域，开始执行绘制流程。</p><p><strong>invalidate()会打上<code>PFLAG_DIRTY_OPAQUE</code>标记，只有这个标记才会执行<code>onDraw()</code>。</strong></p></blockquote><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><p><code>rquestLayout()</code>和<code>invalidate()</code>都可以触发整个绘制流程，但是触发<code>measure</code>、<code>layout</code>、<code>draw</code>各条件都不同</p><ul><li><code>measure</code>过程触发：<code>mPrivateFlags</code>包含<code>PFLAG_FORCE_LAYOUT</code></li><li><code>layout</code>过程触发：<code>mPrivateFlags</code>包含<code>PFLAG_LAYOUT_REQUIRED(measure执行后添加)</code>或者<code>位置发生变化</code></li><li><code>draw</code>过程触发：<code>mPrivateFlags</code>包含<code>PFLAG_DIRTY_OPAQUE</code></li></ul><p><code>requestLayout()</code>主要用来设置<code>PFLAG_FORCE_LAYOUT</code>标志，会执行到<code>measure、layout</code>过程，如果位置发生变化则可能执行<code>draw</code>过程</p><p><code>invalidate()</code>主要用来设置<code>PFLAG_DIRTY_OPAQUE</code>标志，若发生位置变化会执行<code>layout</code>过程，继续往后执行<code>draw</code>过程</p><h4 id="同时调用"><a href="#同时调用" class="headerlink" title="同时调用"></a>同时调用</h4><blockquote><p>在某些情况下，需要<code>requestLayout</code>和<code>invalidate</code>配合使用，得到最终的结果</p></blockquote><h3 id="include、merge、ViewStub作用以及实现"><a href="#include、merge、ViewStub作用以及实现" class="headerlink" title="include、merge、ViewStub作用以及实现"></a>include、merge、ViewStub作用以及实现</h3><a href="/2019/01/03/include、merge-ViewStub相关/" title="include、merge及ViewStub相关">include、merge及ViewStub相关</a><h3 id="View的层级计算"><a href="#View的层级计算" class="headerlink" title="View的层级计算"></a>View的层级计算</h3><pre><code class="hljs java"><span class="hljs-comment">//实际形成一个二叉树 递归计算深度    </span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxViewDeep</span><span class="hljs-params">(View view)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!(view <span class="hljs-keyword">instanceof</span> ViewGroup)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        ViewGroup vp = (ViewGroup) view;        <span class="hljs-keyword">if</span> (vp.getChildCount() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> count = vp.getChildCount();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;            <span class="hljs-keyword">int</span> deep = maxViewDeep(vp.getChildAt(i)) + <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (deep &gt; max) &#123;                max = deep;            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;</code></pre><h3 id="AsyncLayoutInflater异步加载"><a href="#AsyncLayoutInflater异步加载" class="headerlink" title="AsyncLayoutInflater异步加载"></a>AsyncLayoutInflater异步加载</h3><a href="/2020/11/02/Android布局优化-AsyncLayoutInflater简析/" title="AsyncLayoutInflater">AsyncLayoutInflater</a><h3 id="inflate-时，root与attachToRoot的结果源码"><a href="#inflate-时，root与attachToRoot的结果源码" class="headerlink" title="inflate()时，root与attachToRoot的结果源码"></a>inflate()时，<code>root</code>与<code>attachToRoot</code>的结果源码</h3><pre><code class="hljs java"><span class="hljs-comment">//LayoutInflater.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">inflate</span><span class="hljs-params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="hljs-keyword">boolean</span> attachToRoot)</span> </span>&#123;            View result = root;                          <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-comment">// Create layout params that match root, if supplied</span>                        params = root.generateLayoutParams(attrs);                        <span class="hljs-keyword">if</span> (!attachToRoot) &#123;                            <span class="hljs-comment">// Set the layout params for temp if we are not</span>                            <span class="hljs-comment">// attaching. (If we are, we use addView, below)</span>                            temp.setLayoutParams(params);                        &#125;                    &#125;                          <span class="hljs-comment">// We are supposed to attach all the views we found (int temp)</span>                    <span class="hljs-comment">// to root. Do that now.</span>                    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span> &amp;&amp; attachToRoot) &#123;                        <span class="hljs-comment">//将temp添加到rootView中</span>                        root.addView(temp, params);                    &#125;                    <span class="hljs-comment">// Decide whether to return the root that was passed in or the</span>                    <span class="hljs-comment">// top view found in xml.</span>                    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || !attachToRoot) &#123;                        <span class="hljs-comment">//attachToRoot：将View添加到RootView中，非就是直接返回解析的子View</span>                        result = temp;                    &#125;            <span class="hljs-keyword">return</span> result;    &#125;</code></pre><p>根据源码分析到，<code>root</code>与<code>attachToRoot</code>会对<code>infalte()</code>结果产生影响以及实现代码会有差异</p><table><thead><tr><th><code>root</code>与<code>attachToRoot</code>参数</th><th>表现</th><th><code>inflate()</code>返回结果</th></tr></thead><tbody><tr><td><code>root == nuill &amp;&amp; attachToRoot == false/true</code></td><td>直接显示<code>source</code>加载的结果，而且设置的<code>宽高属性</code>也会失效</td><td><code>source</code>加载后的<code>View实例</code></td></tr><tr><td><code>root != null &amp;&amp; attachToRoot == false</code></td><td>直接显示<code>source</code>加载的结果，且设置的<code>宽高属性</code>保持</td><td><code>source</code>加载后的<code>View实例</code></td></tr><tr><td><code>root != null &amp;&amp; attachToRoot == true</code></td><td>直接显示<code>root</code>并且<code>source</code>已被<code>add</code>进去且设置的<code>宽高属性</code>保持</td><td><code>root</code></td></tr></tbody></table><p><strong><code>root</code>不为null，无论<code>attachToRoot</code>，都会保持需要加载布局的宽高属性。<code>root</code>为null，无论<code>attachToRoot</code>，都不会持有原有的宽高属性。</strong></p><h3 id="MeasureSpec-UNSPECIFIED使用场景"><a href="#MeasureSpec-UNSPECIFIED使用场景" class="headerlink" title="MeasureSpec.UNSPECIFIED使用场景"></a><code>MeasureSpec.UNSPECIFIED</code>使用场景</h3><blockquote><p><code>UNSPECIFIED</code>就是未指定的意思，在这个模式下 父控件不会干涉子控件的尺寸。</p><p><strong>一般用于支持滚动的布局中，例如<code>ScrollView</code>、<code>RecyclerView</code>中。</strong></p><p>在可滚动的<code>ViewGroup</code>中，不应该限制子View的尺寸。有可能子View会超出父布局的尺寸，在<code>AT_MOST/EXACTLY</code>都会对子View的尺寸进行限制。</p></blockquote><p>拿<code>ScrollView</code>举例</p><pre><code class="hljs java"><span class="hljs-comment">//ScrollView.java</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChild</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> parentWidthMeasureSpec,            <span class="hljs-keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;        ViewGroup.LayoutParams lp = child.getLayoutParams();        <span class="hljs-keyword">int</span> childWidthMeasureSpec;        <span class="hljs-keyword">int</span> childHeightMeasureSpec;        childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft                + mPaddingRight, lp.width);        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> verticalPadding = mPaddingTop + mPaddingBottom;      <span class="hljs-comment">//强制设置子View的测量模式为`UNSPECIFIED`</span>        childHeightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(                Math.max(<span class="hljs-number">0</span>, MeasureSpec.getSize(parentHeightMeasureSpec) - verticalPadding),                MeasureSpec.UNSPECIFIED);        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);    &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java - 反射</title>
    <link href="/2018/12/14/Java-%E5%8F%8D%E5%B0%84/"/>
    <url>/2018/12/14/Java-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Java反射机制基础"><a href="#Java反射机制基础" class="headerlink" title="Java反射机制基础"></a>Java反射机制基础</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/反射-基础概念.png" srcset="/img/loading.gif" class="full-image" alt="反射-基础概念" title="反射-基础概念"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="反射机制定义"><a href="#反射机制定义" class="headerlink" title="反射机制定义"></a>反射机制定义</h3><p>反射(<code>Reflection</code>)是Java的特征之一，它允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。对于任何一个类，能够知道这个类中的所有属性和方法；对于任何一个对象，都能够调用它的任意一个方法和属性。</p><h3 id="反射机制功能"><a href="#反射机制功能" class="headerlink" title="反射机制功能"></a>反射机制功能</h3><p>通过反射，可以在运行时获取程序中的每一个类型的成员和成员信息。利用Java的反射机制可以动态的创建对象并调用其属性。反射可以提供运行时的类信息，并且可以支持这个类在运行过程中加载进来，甚至在编译时也没有加入编译的类。</p><p>主要提供了如下功能：</p><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li><li>生成动态代理</li></ul><p><strong>一切都是在运行时而不是编译时。</strong></p><h3 id="反射机制支持"><a href="#反射机制支持" class="headerlink" title="反射机制支持"></a>反射机制支持</h3><p>由<code>java.lang.reflect</code>提供反射机制的支持，主要包含了三个类：</p><ul><li><code>Field</code>：使用<code>getField()</code>和<code>setField()</code>读取和修改Field对象关联的字段</li><li><code>Method</code>：使用<code>invoke()</code>调用<code>Method</code>对象关联的方法</li><li><code>Constructor</code>：创建新的对象</li></ul><h3 id="反射机制优点"><a href="#反射机制优点" class="headerlink" title="反射机制优点"></a>反射机制优点</h3><ul><li><strong>可拓展性</strong>：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类</li><li><strong>类浏览器和可视化开发环境</strong>：可以枚举类的成员</li><li><strong>调试器和调试工具</strong>：可以调用类中的<code>private</code>或者<code>protected</code>的对象。</li></ul><h3 id="反射机制缺点"><a href="#反射机制缺点" class="headerlink" title="反射机制缺点"></a>反射机制缺点</h3><ul><li><strong>性能开销</strong>：反射涉及了动态类型的解析，所以JVM无法对这些代码进行优化。导致效率低</li><li><strong>安全限制</strong>：使用反射要求在没有安全限制的环境下去进行</li><li><strong>内部暴露</strong>：由于反射允许代码执行一些正常情况下无法执行的操作(<em>访问私有变量或方法</em>)，反射代码也破坏了抽象性，当内部代码发生改变时，反射的代码也需要进行相应调整。</li></ul><h2 id="Java反射机制使用场景"><a href="#Java反射机制使用场景" class="headerlink" title="Java反射机制使用场景"></a>Java反射机制使用场景</h2><ul><li>用于逆向代码，反编译</li><li>与注解相结合的框架 例如<code>Retrofit</code>使用的运行时注解</li><li>单纯的利用反射机制的框架 例如<code>EventBus</code>所以那些Event都不能被混淆</li><li>动态代理</li></ul><h2 id="Java反射机制的基本运用"><a href="#Java反射机制的基本运用" class="headerlink" title="Java反射机制的基本运用"></a>Java反射机制的基本运用</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/反射-基本运用.png" srcset="/img/loading.gif" class="full-image" alt="反射-基本运用" title="反射-基本运用"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><blockquote><p>每个类被加载后，系统都会为其生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类</p></blockquote><p>获取Class对象的方法有如下三种</p><h4 id="使用Class-forName-String-className-必须完整包名-获取对象。"><a href="#使用Class-forName-String-className-必须完整包名-获取对象。" class="headerlink" title="使用Class.forName(String className/*必须完整包名*/)获取对象。"></a>使用<code>Class.forName(String className/*必须完整包名*/)</code>获取对象。</h4><pre><code class="hljs java">Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"com.example.wxy.FieldUtil"</span>);</code></pre><h4 id="调用类的class属性来获取该类对应的Class对象"><a href="#调用类的class属性来获取该类对应的Class对象" class="headerlink" title="调用类的class属性来获取该类对应的Class对象"></a>调用类的class属性来获取该类对应的Class对象</h4><pre><code class="hljs java">Class&lt;?&gt; clazz = FieldUtil<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;</code></pre><h4 id="调用某个对象的getClass-，"><a href="#调用某个对象的getClass-，" class="headerlink" title="调用某个对象的getClass()，"></a>调用某个对象的<code>getClass()</code>，</h4><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> Person();Class&lt;?&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> </span>= Person.getClass();</code></pre><h3 id="获取Class对象的方法"><a href="#获取Class对象的方法" class="headerlink" title="获取Class对象的方法"></a>获取Class对象的方法</h3><p>主要有以下几个方法：</p><h4 id="getDeclaredMethods"><a href="#getDeclaredMethods" class="headerlink" title="getDeclaredMethods()"></a><code>getDeclaredMethods()</code></h4><blockquote><p>返回类或接口声明的所有方法，包括<code>public(公共)、private(私有)、protected(保护)，default(默认)</code>，但不包括继承的方法</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> Method[] getDeclaredMethods() <span class="hljs-keyword">throws</span> SecurityException</code></pre><h4 id="getMethods"><a href="#getMethods" class="headerlink" title="getMethods()"></a><code>getMethods()</code></h4><blockquote><p>返回类或接口所有的<code>公共(public)</code>方法，包括父类的<code>公共(public)</code>方法</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> Method[] getMethods() <span class="hljs-keyword">throws</span> SecurityException</code></pre><h4 id="getDeclaredMethod"><a href="#getDeclaredMethod" class="headerlink" title="getDeclaredMethod()"></a><code>getDeclaredMethod()</code></h4><blockquote><p>返回Class对象对应类的且带指定形参列表的所有方法</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/*** name 方法名称* parameterTypes 参数对应的Class对象*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> Method <span class="hljs-title">getDeclaredMethod</span><span class="hljs-params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></code></pre><h4 id="getMethod"><a href="#getMethod" class="headerlink" title="getMethod()"></a><code>getMethod()</code></h4><blockquote><p>返回Class对象对应类的且带指定形参列表的<code>公共(public)</code>方法</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/*** name 方法名称* parameterTypes 参数对应的Class对象*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> Method <span class="hljs-title">getMethod</span><span class="hljs-params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></code></pre><h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">reflect</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Class&lt;?&gt; methodClass = MethodClass<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;            <span class="hljs-comment">//获取所有共用方法，且包含父类方法</span>            Method[] methods = methodClass.getMethods();            <span class="hljs-comment">//获取所有方法，不包含父类方法</span>            Method[] declaredMethods = methodClass.getDeclaredMethods();            <span class="hljs-comment">//反射得到私有add()</span>            Method addMethod = methodClass.getDeclaredMethod(<span class="hljs-string">"add"</span>, <span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;            <span class="hljs-comment">//反射得到共有sub()</span>            Method subMethod = methodClass.getMethod(<span class="hljs-string">"sub"</span>, <span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;            System.err.println(<span class="hljs-string">"Declared Method "</span>+addMethod);            System.err.println(<span class="hljs-string">"public Method "</span>+subMethod);            <span class="hljs-keyword">for</span> (Method method : methods) &#123;                System.err.println(<span class="hljs-string">"Public Methods "</span>+method);            &#125;            <span class="hljs-keyword">for</span> (Method method : declaredMethods) &#123;                System.err.println(<span class="hljs-string">"Declared Methods "</span>+method);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodClass</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> a + b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> a - b;    &#125;&#125;运行结果为:Declared Method <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> MethodClass.add(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)Public Method <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> MethodClass.sub(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)<span class="hljs-comment">//获取到的所有公共方法 包含了父类 Object中的公共方法</span>Public Methods <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> MethodClass.sub(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)Public Methods <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> java.lang.Object.wait(<span class="hljs-keyword">long</span>,<span class="hljs-keyword">int</span>) <span class="hljs-keyword">throws</span> java.lang.InterruptedExceptionPublic Methods <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> java.lang.Object.wait(<span class="hljs-keyword">long</span>) <span class="hljs-keyword">throws</span> java.lang.InterruptedExceptionPublic Methods <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> java.lang.Object.wait() <span class="hljs-keyword">throws</span> java.lang.InterruptedExceptionPublic Methods <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> java.lang.Object.equals(java.lang.Object)Public Methods <span class="hljs-keyword">public</span> java.lang.String java.lang.Object.toString()Public Methods <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> java.lang.Object.hashCode()Public Methods <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> java.lang.Class java.lang.Object.getClass()Public Methods <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> java.lang.Object.notify()Public Methods <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> java.lang.Object.notifyAll()<span class="hljs-comment">//获取到当前类的所有方法，不包含父类</span>Declared Methods <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> MethodClass.add(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)Declared Methods <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> MethodClass.sub(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</code></pre><h3 id="获取Class对象的成员变量"><a href="#获取Class对象的成员变量" class="headerlink" title="获取Class对象的成员变量"></a>获取Class对象的成员变量</h3><p>主要有以下方法：</p><h4 id="getFields"><a href="#getFields" class="headerlink" title="getFields()"></a><code>getFields()</code></h4><blockquote><p>获取Class对象的public属性的所有变量</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> Field[] getFields() <span class="hljs-keyword">throws</span> SecurityException</code></pre><h4 id="getField"><a href="#getField" class="headerlink" title="getField()"></a><code>getField()</code></h4><blockquote><p>获取Class对象的指定public属性变量</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Field <span class="hljs-title">getField</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;</code></pre><h4 id="getDeclardFields"><a href="#getDeclardFields" class="headerlink" title="getDeclardFields()"></a><code>getDeclardFields()</code></h4><blockquote><p>获取Class对象的所有变量</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Field[] getDeclaredFields();</code></pre><h4 id="getDeclardField"><a href="#getDeclardField" class="headerlink" title="getDeclardField()"></a><code>getDeclardField()</code></h4><blockquote><p>获取Class对象的指定属性变量</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Field <span class="hljs-title">getDeclaredField</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException</span></code></pre><h4 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">reflect</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Class&lt;?&gt; methodClass = MethodClass<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;            <span class="hljs-comment">//返回所有public属性变量</span>            Field[] fields = methodClass.getFields();            <span class="hljs-comment">//返回所有变量</span>            Field[] declaredFields = methodClass.getDeclaredFields();            Field field = methodClass.getField(<span class="hljs-string">"a"</span>);            Field declaredField = methodClass.getDeclaredField(<span class="hljs-string">"c"</span>);            <span class="hljs-keyword">for</span> (Field f : fields) &#123;                System.err.println(<span class="hljs-string">"Public Fields "</span> + f);            &#125;            <span class="hljs-keyword">for</span> (Field f : declaredFields) &#123;                System.err.println(<span class="hljs-string">"Declared Fields "</span> + f);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodClass</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">5</span>;&#125;运行结果为：Public Fields <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MethodClass.aDeclared Fields <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MethodClass.aDeclared Fields <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MethodClass.c</code></pre><h3 id="获取Class对象的构造函数"><a href="#获取Class对象的构造函数" class="headerlink" title="获取Class对象的构造函数"></a>获取Class对象的构造函数</h3><h4 id="getConstructors"><a href="#getConstructors" class="headerlink" title="getConstructors()"></a><code>getConstructors()</code></h4><blockquote><p>获取Class对象的Public构造函数</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> Constructor&lt;?&gt;[] getConstructors() <span class="hljs-keyword">throws</span> SecurityException</code></pre><h4 id="getDeclaredConstructors"><a href="#getDeclaredConstructors" class="headerlink" title="getDeclaredConstructors()"></a><code>getDeclaredConstructors()</code></h4><blockquote><p>获取Class对象的所有构造函数</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> Constructor&lt;?&gt;[] getDeclaredConstructors() <span class="hljs-keyword">throws</span> SecurityException</code></pre><h4 id="getConstructor"><a href="#getConstructor" class="headerlink" title="getConstructor()"></a><code>getConstructor()</code></h4><blockquote><p>获取指定声明的public构造函数</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/*** parameterTypes 参数对应的Class对象*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> Constructor&lt;T&gt; <span class="hljs-title">getConstructor</span><span class="hljs-params">(Class&lt;?&gt;... parameterTypes)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException</span></code></pre><h4 id="getDeclaredConstructor"><a href="#getDeclaredConstructor" class="headerlink" title="getDeclaredConstructor()"></a><code>getDeclaredConstructor()</code></h4><blockquote><p>获取指定声明的构造函数</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/*** parameterTypes 参数对应的Class对象*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> Constructor&lt;T&gt; <span class="hljs-title">getDeclaredConstructor</span><span class="hljs-params">(Class&lt;?&gt;... parameterTypes)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException</span></code></pre><h4 id="实例分析-2"><a href="#实例分析-2" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">reflect</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Class&lt;?&gt; methodClass = MethodClass<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;            Constructor&lt;?&gt;[] constructors = methodClass.getConstructors();            Constructor&lt;?&gt;[] declaredConstructors = methodClass.getDeclaredConstructors();            Constructor&lt;?&gt; constructor = methodClass.getConstructor(<span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;            Constructor&lt;?&gt; declaredConstructor = methodClass.getDeclaredConstructor(<span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">int</span>.<span class="hljs-title">class</span>,<span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;            <span class="hljs-keyword">for</span> (Constructor f : constructors) &#123;                System.err.println(<span class="hljs-string">"Public Constructors "</span> + f);            &#125;            <span class="hljs-keyword">for</span> (Constructor f : declaredConstructors) &#123;                System.err.println(<span class="hljs-string">"Declared Constructors "</span> + f);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b)</span></span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span>&#123;    &#125;&#125;运行结果：<span class="hljs-function">Public Constructors <span class="hljs-keyword">public</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span>Declared Constructors <span class="hljs-keyword">public</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span>Declared Constructors <span class="hljs-keyword">private</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span></code></pre><h3 id="创建Class对象实例"><a href="#创建Class对象实例" class="headerlink" title="创建Class对象实例"></a>创建Class对象实例</h3><h4 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance()"></a><code>newInstance()</code></h4><blockquote><p>创建对象的实例 <strong>需要对应Class有无参构造函数</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException</span>;</code></pre><h4 id="Constructor-newInstance"><a href="#Constructor-newInstance" class="headerlink" title="Constructor.newInstance()"></a><code>Constructor.newInstance()</code></h4><blockquote><p>通过构造器去创建对象实例</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(Object ... initargs)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></code></pre><h4 id="实例分析-3"><a href="#实例分析-3" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">reflect</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Class&lt;?&gt; methodClass = MethodClass<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;            Object object = methodClass.newInstance();            Constructor&lt;?&gt; constructor = methodClass.getConstructor(<span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;            Object object1 = constructor.newInstance(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);            System.err.println(<span class="hljs-string">"newInstance() "</span>+object.getClass());            System.err.println(<span class="hljs-string">"Constructor.newInstance() "</span>+object1.getClass());        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodClass</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">6</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">5</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">this</span>(a, b, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;        <span class="hljs-keyword">this</span>.a = a;        <span class="hljs-keyword">this</span>.b = b;        <span class="hljs-keyword">this</span>.c = c;    &#125;&#125;运行结果：newInstance() <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodClass</span><span class="hljs-title">Constructor</span>.<span class="hljs-title">newInstance</span>()  <span class="hljs-title">class</span> <span class="hljs-title">MethodClass</span></span></code></pre><h3 id="调用Class对象方法"><a href="#调用Class对象方法" class="headerlink" title="调用Class对象方法"></a>调用Class对象方法</h3><h4 id="invoke"><a href="#invoke" class="headerlink" title="invoke()"></a><code>invoke()</code></h4><blockquote><p>传入方法名和参数，就可以调用到对应方法</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><span class="hljs-meta">@FastNative</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span>            <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>;</code></pre><blockquote><p><code>@FastNative</code>：Android 8.0新增加的注解，可以更快速的进行原生调用</p><p><code>@CallserSensitive</code>：跳过检查直接确定调用的对象</p></blockquote><h4 id="实例分析-4"><a href="#实例分析-4" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">reflect</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Class&lt;?&gt; methodClass = MethodClass<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;            Object object = methodClass.newInstance();            Method addMethod = methodClass.getDeclaredMethod(<span class="hljs-string">"add"</span>, <span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;            addMethod.setAccessible(<span class="hljs-keyword">true</span>);            addMethod.invoke(object,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);                      Method subMethod = methodClass.getMethod(<span class="hljs-string">"sub"</span>, <span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;            subMethod.invoke(object,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        System.err.println(<span class="hljs-string">"I`m reflect private method "</span> + a+b);        <span class="hljs-keyword">return</span> a + b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;        System.err.println(<span class="hljs-string">"I`m reflect public method"</span> + a-b);        <span class="hljs-keyword">return</span> a - b;    &#125;&#125;运行结果：I`m reflect <span class="hljs-keyword">private</span> method <span class="hljs-number">3</span>I`m reflect <span class="hljs-keyword">public</span> method <span class="hljs-number">1</span></code></pre><blockquote><p>当通过<code>Method.invoke()</code>调用对应方法时，要求程序必须拥有调用该方法的权限。如果程序调用了private方法，就需要设置<code>setAccessible(boolean flag)</code>，设置<code>flag</code>为true则取消访问权限检查；false继续执行检查，则会报错<code>Class reflect can not access a member of class MethodClass with modifiers &quot;private&quot;</code>。</p></blockquote><h3 id="设置Class对象变量值"><a href="#设置Class对象变量值" class="headerlink" title="设置Class对象变量值"></a>设置Class对象变量值</h3><h4 id="Field-set-Field-get"><a href="#Field-set-Field-get" class="headerlink" title="Field.set()/Field.get()"></a><code>Field.set()/Field.get()</code></h4><blockquote><p>设置/获取任意变量值<em>Object</em></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Object obj, Object value)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">get</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</code></pre><h4 id="Field-setXX-Field-getXX"><a href="#Field-setXX-Field-getXX" class="headerlink" title="Field.setXX()/Field.getXX()"></a><code>Field.setXX()/Field.getXX()</code></h4><blockquote><p>设置/获取基本类型变量<em>int,boolean.long,double,float,char,short,byte8种基本类型</em></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getBoolean</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBoolean</span><span class="hljs-params">(Object obj, <span class="hljs-keyword">boolean</span> z)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</code></pre><table><thead><tr><th>基本类型</th><th>对应名称(位数)</th></tr></thead><tbody><tr><td>整数型</td><td>byte(8位)，short(16位)，int(32位)，long(64位)</td></tr><tr><td>浮点型</td><td>float(32位)，double(64位) 默认为double，要设置成float，需要结尾加f</td></tr><tr><td>字节型</td><td>char(16位)</td></tr><tr><td>布尔型</td><td>boolean(1位)</td></tr></tbody></table><p>实例分析</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">reflect</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Class&lt;?&gt; methodClass = MethodClass<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;            Object object = methodClass.newInstance();            Field field = methodClass.getField(<span class="hljs-string">"a"</span>);            Field declaredField = methodClass.getDeclaredField(<span class="hljs-string">"b"</span>);            field.setAccessible(<span class="hljs-keyword">true</span>);            declaredField.setAccessible(<span class="hljs-keyword">true</span>);            field.set(object,<span class="hljs-number">3</span>);            declaredField.set(object,<span class="hljs-number">5</span>);            Method addMethod = methodClass.getDeclaredMethod(<span class="hljs-string">"add"</span>, <span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;            addMethod.setAccessible(<span class="hljs-keyword">true</span>);            addMethod.invoke(object,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodClass</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">6</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">5</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">this</span>(a, b, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MethodClass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;        <span class="hljs-keyword">this</span>.a = a;        <span class="hljs-keyword">this</span>.b = b;        <span class="hljs-keyword">this</span>.c = c;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        System.err.println(<span class="hljs-string">"reflect value a="</span>+ <span class="hljs-keyword">this</span>.a+<span class="hljs-string">" b="</span>+ <span class="hljs-keyword">this</span>.b);        <span class="hljs-keyword">return</span> a + b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> a - b;    &#125;&#125;运行结果：reflect value a=<span class="hljs-number">3</span> b=<span class="hljs-number">5</span></code></pre><h2 id="Java反射机制的高级运用"><a href="#Java反射机制的高级运用" class="headerlink" title="Java反射机制的高级运用"></a>Java反射机制的高级运用</h2><h3 id="反射创建数组"><a href="#反射创建数组" class="headerlink" title="反射创建数组"></a>反射创建数组</h3><blockquote><p>数组是一个比较特殊的类型，在反射机制中有专门的处理类——<code>java.lang.reflect.Array</code></p><p><code>newInstance()</code>：创建一个数组对象</p><p><code>get()/getXX()</code>：获取数组中对应位置的值</p><p><code>set()/setXX()</code>：设置数组中对应位置的值</p></blockquote><h4 id="实例分析-5"><a href="#实例分析-5" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenerateArray</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">"java.lang.String"</span>);            <span class="hljs-comment">//创建一个 String型数组</span>            Object array = Array.newInstance(clazz,<span class="hljs-number">20</span>);            Array.set(array,<span class="hljs-number">0</span>,<span class="hljs-string">"12"</span>);            Array.set(array,<span class="hljs-number">1</span>,<span class="hljs-string">"23"</span>);            System.err.println(Array.get(array,<span class="hljs-number">1</span>));        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;运行结果：<span class="hljs-number">23</span></code></pre><h3 id="反射获取泛型"><a href="#反射获取泛型" class="headerlink" title="反射获取泛型"></a>反射获取泛型</h3><a href="/2019/01/02/Java-泛型/" title="Java - 泛型">Java - 泛型</a><p>反射只能对普通类型的Field有效，如果该Field的类型是有泛型限制的类型，例如<code>Map&lt;String,String&gt;</code>类型，则无法准备取得该Field的泛型参数。</p><h4 id="ParameterizedType"><a href="#ParameterizedType" class="headerlink" title="ParameterizedType"></a><code>ParameterizedType</code></h4><p>代表被参数化的类型，增加了泛型限制的类型。</p><h4 id="getRawType"><a href="#getRawType" class="headerlink" title="getRawType()"></a><code>getRawType()</code></h4><p>返回没有泛型信息的原始类型</p><h4 id="getActualTypeArguments"><a href="#getActualTypeArguments" class="headerlink" title="getActualTypeArguments()"></a><code>getActualTypeArguments()</code></h4><p>返回泛型参数的类型</p><h4 id="实例分析-6"><a href="#实例分析-6" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="hljs undefined">public class GenerateArray &#123;    //使用泛型类型的Map    private Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    public static void main(String[] args) &#123;        try &#123;            Class&lt;GenerateArray&gt; clazz = GenerateArray.class;            //反射获取Map变量            Field f = clazz.getDeclaredField(&quot;map&quot;);            //直接获取Field类型            Class&lt;?&gt; mapClazz = f.getType();            System.err.println(mapClazz);            //获取Field的泛型类型            Type type = f.getGenericType();            //判断是否为泛型类型            if (type instanceof ParameterizedType) &#123;                //强制类型转换                ParameterizedType pType = (ParameterizedType) type;                //获取原始类型 这里得到的是Map                Type rType = pType.getRawType();                System.err.println(&quot;原始类型 ：&quot; + rType);                //获取泛型类型的泛型参数                Type[] types = pType.getActualTypeArguments();                System.err.println(&quot;泛型类型 ：&quot;);                for (int i = 0; i &lt; types.length; i++) &#123;                    System.err.println(types[i]);                &#125;            &#125; else &#123;                System.err.println(&quot;无法获取泛型类型&quot;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="反射使用注意事项"><a href="#反射使用注意事项" class="headerlink" title="反射使用注意事项"></a>反射使用注意事项</h2><p>由于反射会额外的消耗一定的系统资源，如果不需要动态的创建一个对象，那么就不需要用到反射。</p><p>另外反射调用方法时会忽略权限检查，因此可能会破坏封装性导致安全问题。</p><h2 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h2><p>反射慢的原因主要在两点：</p><ul><li>虽然javac不怎么优化代码，但反射导致JIT编译器无法有效做优化，使得反射执行慢</li><li>反射方法的检测，需要检测<code>类、方法是否存在，权限是否正确</code></li></ul><p>优化点如下：</p><ul><li><code>setAccessible(true)</code>避免反射时的检测</li><li>若大量执行反射，对反射对象的反射结果进行缓存，可以后续反射时直接调用缓存</li><li>使用三方反射库，例如<code>ReflactASM</code>通过添加字节码的方式实现反射功能。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LruCache原理</title>
    <link href="/2018/12/14/LRUCache%E5%8E%9F%E7%90%86/"/>
    <url>/2018/12/14/LRUCache%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h1><blockquote><p>一般来说，缓存的策略主要包含缓存的<code>添加、获取和删除</code>。但由于缓存的大小都是有上限的。缓存慢了之后，要想继续添加 ，就需要删除一些旧的缓存以提供空间。</p><p>所以使用到了<code>LruCache</code>缓存算法，即<strong>最近最少使用</strong>算法，当缓存满时，会优先淘汰掉 最近最少使用的缓存对象。</p></blockquote><p><strong>LruCache的核心原理就是利用了LinkedHashMap</strong>。</p><h2 id="LruCache的使用"><a href="#LruCache的使用" class="headerlink" title="LruCache的使用"></a>LruCache的使用</h2><pre><code class="hljs java"><span class="hljs-keyword">int</span> maxMemory = (<span class="hljs-keyword">int</span>)(Runtime.getRuntime().totalMemory()/<span class="hljs-number">1024</span>);<span class="hljs-comment">//设置LruCache缓存的大小</span><span class="hljs-keyword">int</span> cacheSize = maxMemory/<span class="hljs-number">8</span>;LruCache memoryCache = <span class="hljs-keyword">new</span> LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sizeOf</span><span class="hljs-params">(@NonNull String key, @NonNull Bitmap value)</span> </span>&#123;        <span class="hljs-comment">//重写sizeof方法，计算需要缓存的图片大小</span>        <span class="hljs-keyword">return</span> value.getRowBytes() * value.getHeight() / <span class="hljs-number">1024</span>;    &#125;&#125;;</code></pre><h2 id="LruCache的实现原理"><a href="#LruCache的实现原理" class="headerlink" title="LruCache的实现原理"></a>LruCache的实现原理</h2><p><code>LruCache内部需要维护好一个缓存对象列表，其中对象的排列方式应该按照访问顺序排列的，即一直没访问的对象，要放在队尾，最近访问的对象就会放在对头，最晚被淘汰。</code></p><p>查看源码中发现内部是利用了<code>LinkedHashMap</code>去缓存对象的。</p><pre><code class="hljs java"><span class="hljs-comment">//LruCache构造方法</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedHashMap&lt;K, V&gt; map;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LruCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;        <span class="hljs-keyword">if</span> (maxSize &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"maxSize &lt;= 0"</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.maxSize = maxSize;            <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> LinkedHashMap(<span class="hljs-number">0</span>, <span class="hljs-number">0.75F</span>, <span class="hljs-keyword">true</span>);        &#125;    &#125;<span class="hljs-comment">//LinkedHashMap的构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-comment">/*map初始化大小*/</span><span class="hljs-keyword">int</span> initialCapacity,                         <span class="hljs-comment">/*初始负载因子*/</span><span class="hljs-keyword">float</span> loadFactor,                         <span class="hljs-comment">/*accessOrder意为访问顺序，若为true按照访问顺序排列，false则为插入顺序排列*/</span>                     <span class="hljs-keyword">boolean</span> accessOrder)</span> </span>&#123;        <span class="hljs-keyword">super</span>(initialCapacity, loadFactor);        <span class="hljs-keyword">this</span>.accessOrder = accessOrder;    &#125;</code></pre><p>在<code>LruCache</code>构造方法中，设置了<code>maxSize</code>以及创建一个<code>LinkedHashMap</code>对象用来存储对象。</p><p><code>LruCache</code>中需要移除最近最少使用的对象，即为优先删除访问最早对象，所以应该按照访问顺序排列，为true。</p><pre><code class="hljs java"><span class="hljs-comment">//LruCache获取key对应的value </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"key == null"</span>);        &#125;        V mapValue;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">//返回不为null，就将其移到队列头部</span>            mapValue = map.get(key);            <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-keyword">null</span>) &#123;                hitCount++;                <span class="hljs-keyword">return</span> mapValue;            &#125;            missCount++;        &#125;        <span class="hljs-comment">//当获取不到value的时候，会调用create()</span>        V createdValue = create(key);        <span class="hljs-keyword">if</span> (createdValue == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            createCount++;            mapValue = map.put(key, createdValue);            <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// There was a conflict so undo that last put</span>                map.put(key, mapValue);            &#125; <span class="hljs-keyword">else</span> &#123;                size += safeSizeOf(key, createdValue);            &#125;        &#125;        <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-keyword">null</span>) &#123;            entryRemoved(<span class="hljs-keyword">false</span>, key, createdValue, mapValue);            <span class="hljs-keyword">return</span> mapValue;        &#125; <span class="hljs-keyword">else</span> &#123;            trimToSize(maxSize);            <span class="hljs-keyword">return</span> createdValue;        &#125;     &#125;</code></pre><p>LruCache的<code>get()</code>实际调用的就是<code>LinkedHashMap</code>对应的<code>get(key)</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;        Node&lt;K,V&gt; e;        <span class="hljs-keyword">if</span> ((e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//如果按照访问顺序排列 则需要将该get对象移到尾部</span>        <span class="hljs-keyword">if</span> (accessOrder)            afterNodeAccess(e);        <span class="hljs-keyword">return</span> e.value;    &#125;    <span class="hljs-comment">/**     * The head (eldest) of the doubly linked list.     */</span><span class="hljs-keyword">transient</span> LinkedHashMapEntry&lt;K,V&gt; head;    <span class="hljs-comment">/**     * The tail (youngest) of the doubly linked list.     */</span><span class="hljs-keyword">transient</span> LinkedHashMapEntry&lt;K,V&gt; tail;<span class="hljs-comment">//将节点移到双端链表的尾部</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// move node to last</span>        LinkedHashMap.Entry&lt;K,V&gt; last;        <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;            LinkedHashMap.Entry&lt;K,V&gt; p =                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;            p.after = <span class="hljs-keyword">null</span>;。             <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)                head = a;            <span class="hljs-keyword">else</span>                b.after = a;                        <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>)                a.before = b;            <span class="hljs-keyword">else</span>                last = b;                        <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)                head = p;            <span class="hljs-keyword">else</span> &#123;                p.before = last;                last.after = p;            &#125;            tail = p;            ++modCount;        &#125;    &#125;</code></pre><p>先调用<code>getNode()</code>获取key对应节点，如果不存在则返回null。若存在并且需要按照访问顺序排列，就把找到的节点移到双端链表的尾部。</p> <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"key == null || value == null"</span>);        &#125;        V previous;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            putCount++;            <span class="hljs-comment">//增加已有缓存大小</span>            size += safeSizeOf(key, value);            <span class="hljs-comment">//返回关键过这个key的对象</span>            previous = map.put(key, value);            <span class="hljs-comment">//若存在已关联对象 则恢复原先缓存大小</span>            <span class="hljs-keyword">if</span> (previous != <span class="hljs-keyword">null</span>) &#123;                size -= safeSizeOf(key, previous);            &#125;        &#125;        <span class="hljs-keyword">if</span> (previous != <span class="hljs-keyword">null</span>) &#123;            entryRemoved(<span class="hljs-keyword">false</span>, key, previous, value);        &#125;        <span class="hljs-comment">//每次put后，需要重新调整缓存大小避免超过上限</span>        trimToSize(maxSize);        <span class="hljs-keyword">return</span> previous;    &#125;</code></pre><p>在调用<code>put</code>过后，需要调用一次<code>trimToSize()</code>调整缓存对象。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;        Object key;        Object value;        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.size &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">this</span>.map.isEmpty() &amp;&amp; <span class="hljs-keyword">this</span>.size != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-keyword">this</span>.getClass().getName() + <span class="hljs-string">".sizeOf() is reporting inconsistent results!"</span>);            &#125;            <span class="hljs-comment">//直到缓存大小size&lt;=最大缓存值maxSize</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.size &lt;= maxSize || <span class="hljs-keyword">this</span>.map.isEmpty()) &#123;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">//取出双链表中的头元素</span>            Entry&lt;K, V&gt; toEvict = (Entry)<span class="hljs-keyword">this</span>.map.entrySet().iterator().next();            key = toEvict.getKey();            value = toEvict.getValue();            <span class="hljs-comment">//移除头部元素</span>            <span class="hljs-keyword">this</span>.map.remove(key);            <span class="hljs-keyword">this</span>.size -= <span class="hljs-keyword">this</span>.safeSizeOf(key, value);            ++<span class="hljs-keyword">this</span>.evictionCount;        &#125;        <span class="hljs-keyword">this</span>.entryRemoved(<span class="hljs-keyword">true</span>, key, value, (Object)<span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><p>原理总结：</p><p>内部是利用了<code>LinkedHashMap</code>来实现一个<code>最近最少使用算法</code>，在每次调用<code>put</code>和<code>get</code>时，都会算作一次对<code>LinkedHashMap</code>的访问，当设置<code>accessOrder</code>为<code>true</code>时，就会按照访问顺序排列，就会把每次访问的元素放在尾部，当缓存值达到阈值<code>maxSzie</code>后，就会去删除<code>LinkedHashMap</code>的首部元素，来降低内存占用。</p><p><code>LinkedHashMap</code>在<code>HashMap</code>基础上使用了一个双端链表维持有序的节点。</p><h2 id="自定义LRUCache"><a href="#自定义LRUCache" class="headerlink" title="自定义LRUCache"></a>自定义LRUCache</h2>]]></content>
    
    
    
    <tags>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式--基本原则</title>
    <link href="/2018/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <url>/2018/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/设计模式-基本原则.png" srcset="/img/loading.gif" class="full-image" alt="设计模式-基本原则" title="设计模式-基本原则"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><blockquote><p>单一职责原则英文名称为<code>Single Responsibility Principle</code>,简称SRP。</p></blockquote><p>优点：</p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义</li><li>可读性提高，复杂性降低</li><li>可维护性高</li></ul><p>对于开发过程来说，<strong>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化</strong>。</p><h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><blockquote><p>所有引用父类的地方都必须能透明的使用其子类的对象。简单的说就是 <strong>父类能出现的地方子类就可以出现。</strong></p></blockquote><p>里氏替换原则为良好的继承定义了一个规范，主要包含了4个含义：</p><ul><li><strong>子类必须完全实现父类的方法</strong>：<code>如果子类不能完整的实现父类的方法，或者父类方法在子类中已无法实现，建议断开父子继承关系，采用依赖、聚集，组合等方法代替继承。</code></li><li><strong>子类可以有自己的个性</strong>：<code>里氏替换原则可以正着用，但不能反过来用。子类出现的地方，父类未必可以使用。</code></li><li><strong>覆盖或实现父类的方法时输入参数可以被放大</strong>：<code>子类中的方法前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松。</code></li><li><strong>覆写或实现父类的方法时输出结果可以被缩小</strong></li></ul><p>在开发过程中尽量避免子类的”个性“，有了之后，与父类的关系就难调和。</p><h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><blockquote><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖于抽象</li></ul><p><strong>面向接口编程</strong></p></blockquote><p>本质就是通过抽象（接口或者抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的送耦合。</p><h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><blockquote><p>接口分为两种：实例接口 和 类接口</p><p>接口尽量细化，同时接口中的方法要尽量少。尽量使用多个专门的接口。</p></blockquote><p>接口隔离原则是对接口进行规范约束，包含以下4层含义：</p><ul><li>接口要尽量小 <strong>不能违反单一职责原则</strong></li><li>接口要高内聚：<code>高内聚就是提高接口、类，模块的处理能力，减少对外的交互</code></li><li>定制服务：<strong>只提供访问者需要的方法，减少可能引起的风险</strong></li><li>接口设计是有限度的：<code>接口的设计粒度越小，系统越灵活，但是会增加结构复杂度以及开发难度</code></li></ul><p>在开发过程中可以按照如下规则设计：</p><ul><li>一个接口只服务于一个子模块或业务逻辑</li><li>通过业务逻辑压缩接口中的public方法</li><li>已经被污染的接口尽量去修改</li><li>根据每个项目或产品去制定拆分标准</li></ul><h2 id="迪米特法则（LoD）–最少知识原则-LKP"><a href="#迪米特法则（LoD）–最少知识原则-LKP" class="headerlink" title="迪米特法则（LoD）–最少知识原则(LKP)"></a>迪米特法则（LoD）–最少知识原则(LKP)</h2><blockquote><p>一个对象应该对其他对象有最少的了解</p></blockquote><p>迪米特法则对类的低耦合提出了明确的要求，包含以下4个含义：</p><ul><li>只和朋友交流：<strong>在类的一个方法中尽量不引入一个类中不存在的对象</strong></li><li>朋友间也是有距离的：<strong>尽量不对外公布太多的public方法和非静态的public变量，尽量内敛</strong></li><li>是自己的就是自己的：<strong>如果一个方法放在本类中，既不增加类间关系，也不会对本类产生负面影响，就可以放置在本类中</strong></li><li>谨慎使用Serializable：<strong>在进行传输对象时需要进行序列化，当修改了属性时，会导致反序列化失败</strong></li></ul><p>迪米特法则核心观念就是<strong>类间解耦，弱耦合</strong>。</p><h2 id="开闭原则（OCP）—最基础的原则"><a href="#开闭原则（OCP）—最基础的原则" class="headerlink" title="开闭原则（OCP）—最基础的原则"></a>开闭原则（OCP）—最基础的原则</h2><blockquote><p>软件实体应该对扩展开放，对修改关闭。<code>一个软件实体应该通过扩展来实现变化，而不是去修改已有代码。</code></p></blockquote><p><strong>开闭原则并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合</strong></p><p>开闭原则的重要性：</p><ul><li>减少测试工作量</li><li>提高复用性</li><li>提高可维护性</li><li>面向对象开发</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式--单例模式</title>
    <link href="/2018/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2018/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote><p>一个类只能产生一个对象。确保某一个只有一个实例，而且自行实例化并向整个系统提供这个实例且构造函数私有化。</p></blockquote> <span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Pattern-Singleton.png" srcset="/img/loading.gif" class="full-image" alt="单例模式" title="单例模式"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><pre><code class="hljs java"><span class="hljs-comment">//单例模式通用代码</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton singleton = <span class="hljs-keyword">new</span> Singleton();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;           &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> singleton;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSth</span><span class="hljs-params">()</span></span>&#123;            &#125;&#125;</code></pre><h2 id="单例模式优点"><a href="#单例模式优点" class="headerlink" title="单例模式优点"></a>单例模式优点</h2><ol><li>由于单例模式只存在一个实例，减少了内存开支</li><li>减少了系统的开销</li><li>避免对资源的多重占用</li><li>在系统设置全局访问点，优化和共享资源访问</li><li>允许可变数目的实例，基于单例模式可以进行拓展，可以获得指定个数的对象实例，既节省系统资源，又解决单例对象过多的性能损耗</li></ol><h2 id="单例模式缺点"><a href="#单例模式缺点" class="headerlink" title="单例模式缺点"></a>单例模式缺点</h2><ol><li>单例模式一般没有接口，扩展很困难。</li><li>单例模式对测试是不利的，因为单例模式没有完成时，是不能进行测试的。</li><li>与单一职责原则有冲突</li></ol><h2 id="单例模式使用场景"><a href="#单例模式使用场景" class="headerlink" title="单例模式使用场景"></a>单例模式使用场景</h2><ol><li>要求生成唯一序列号的环境</li><li>在整个项目中需要一个共享访问点或共享数据</li><li>创建一个对象需要的消耗资源过多，如访问IO和数据库</li><li>需要定义大量的静态常亮和静态方法</li></ol><h2 id="单例模式的实现条件"><a href="#单例模式的实现条件" class="headerlink" title="单例模式的实现条件"></a>单例模式的实现条件</h2><ol><li><code>构造函数私有</code></li><li><code>有一个该类的静态私有对象</code></li><li><code>有一个静态的公用函数用于创建或获取本身静态私有对象</code></li><li><strong>线程同步</strong></li></ol><h2 id="单例模式注意事项"><a href="#单例模式注意事项" class="headerlink" title="单例模式注意事项"></a>单例模式注意事项</h2><ol><li>在高并发情况下，注意单例模式的线程同步问题</li><li>考虑对象的复制情况</li></ol><h2 id="单例模式实现实例"><a href="#单例模式实现实例" class="headerlink" title="单例模式实现实例"></a>单例模式实现实例</h2><ul><li><p>双重校验锁（DCL）–Java5之后可以安心使用该方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton mInstance;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) &#123;                    mInstance = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> mInstance;    &#125;        <span class="hljs-comment">//反序列化提供的一个特殊方法，可以控制对象的反序列化</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> mInstance;<span class="hljs-comment">//返回实例对象</span>    &#125;&#125;</code></pre><blockquote><p>在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则<code>mInstance = new Singleton();</code>可能出现<code>mInstance</code>尚未被初始化的异常。</p><p><code>mInstance = new Singleton();</code>包括三步：<code>为对象分配内存</code>，<code>执行构造方法，初始化实例对象</code>，<code>把mInstance的引用指向分配的内存空间</code>。在JVM的执行过程中并不是原子性的。</p></blockquote></li><li><p>静态内部类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;            &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;    &#125;&#125;</code></pre><blockquote><p>为何可以保证线程安全？<code>虚拟机可以保证一个类的类构造器</code><clinit>()`在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。<strong>同一个类加载器下，一个类型只会被初始化一次。</strong></clinit></p></blockquote></li><li><p>枚举</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Singleton &#123;    INSTANCE;&#125;</code></pre><blockquote><p>防止反序列化重新创建新对象，在Android中不建议使用枚举，大概会增加4倍消耗。</p></blockquote></li></ul><h2 id="单例模式在Android中的体现"><a href="#单例模式在Android中的体现" class="headerlink" title="单例模式在Android中的体现"></a>单例模式在Android中的体现</h2><pre><code class="hljs java"><span class="hljs-comment">//../android/view/inoputmethod/InputMethodManager.java </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InputMethodManager <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (InputMethodManager<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;            <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    sInstance = <span class="hljs-keyword">new</span> InputMethodManager(Looper.getMainLooper());                &#125; <span class="hljs-keyword">catch</span> (ServiceNotFoundException e) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(e);                &#125;            &#125;            <span class="hljs-keyword">return</span> sInstance;        &#125;    &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Binder系列-ContentProvider</title>
    <link href="/2018/12/13/Binder%E7%B3%BB%E5%88%97-ContentProvide/"/>
    <url>/2018/12/13/Binder%E7%B3%BB%E5%88%97-ContentProvide/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Binder系列-ServiceManager相关</title>
    <link href="/2018/12/12/Binder%E7%B3%BB%E5%88%97-ServiceManager%E7%9B%B8%E5%85%B3/"/>
    <url>/2018/12/12/Binder%E7%B3%BB%E5%88%97-ServiceManager%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPC机制</title>
    <link href="/2018/12/11/Binder%E5%8F%8AAIDL/"/>
    <url>/2018/12/11/Binder%E5%8F%8AAIDL/</url>
    
    <content type="html"><![CDATA[<h1 id="IPC机制"><a href="#IPC机制" class="headerlink" title="IPC机制"></a>IPC机制</h1><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/IPC机制.png" srcset="/img/loading.gif" class="full-image" alt="IPC机制" title="IPC机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>IPC是Inter-Process Communication的缩写。含义为进程间通信或者跨进程通信，指代两个进程间进行数据交换的过程、</p></blockquote><p>还需要理解进程以及线程的区别和联系</p><blockquote><p>进程：一般指一个执行单元，在设备上一般代指应用程序。</p><p>线程：CPU调度的最小单元且线程是有限资源。</p><p>一个进程可以包含多个线程，即一个应用内部可以执行多个任务。在Android中就会区分为<code>主线程(UI线程)</code>和<code>子线程</code>，一般会在子线程上做耗时操作，主线程不可。</p></blockquote><p>由于IPC的使用场景是在多进程模式下。多进程的使用情况主要分为两种：<code>一个应用因为某些原因需要采用多进程模式来实现，比如获取更大内存空间</code>,<code>当前应用需要向其他应用来获取数据</code>。</p><h2 id="1-多进程模式"><a href="#1-多进程模式" class="headerlink" title="1.  多进程模式"></a>1.  多进程模式</h2><ol><li><p>开启多进程模式</p><ul><li>通过JNI在native层fork一个新的进程</li><li>在<code>AndroidManifest.xml</code>中给四大组件指定属性<code>android:process</code>。</li></ul></li><li><p>进程名的命名</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>           <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.wxy.test.AActivity"</span>          <span class="hljs-attr">android:process</span>=<span class="hljs-string">":remote"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>          <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.wxy.text.BActivity"</span>          <span class="hljs-attr">android:process</span>=<span class="hljs-string">"com.wxy.test.remote"</span>/&gt;</span></code></pre><p>上述代码为两种命名方案</p><ul><li>省略包名以:开头：代指进程名为<code>com.wxy.test:remote</code>为<strong>私有进程</strong>，其他应用的组件不可以和他跑到同一个进程中</li><li>完整命名：如上述<code>com.wxy.test.remote</code>为<strong>全局进程</strong>，其他应用可以通过<code>ShareUID方式与他在同一进程中运行。</code></li></ul><p>Android系统会为每一个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。</p><p>上述通过ShareUID将两个应用跑在同一个进程间是有要求的，<strong>必须是两个应用具有相同的ShareUID且签名相同才可以</strong>。达成上述要求时就可以 <strong>共享两者间的data目录、组件信息以及内存数据</strong>。</p><p>拓展知识：当两者签名不同时，会触发安装错误[INSTALL_FAILED_SHARED_USER_INCOMPATIBLE]</p></li><li><p>查看进程信息</p><p><code>adb shell ps|grep $packageName</code></p></li><li><p>运行机制</p><p>Android为每一个应用分配了一个独立的虚拟机，或者说为了每一个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上就会有不同的地址空间，就会导致不同的虚拟机访问同一个类的对象会产生多分副本。</p><p><strong>所有运行在不同进程的四大组件，只要他们通过内存共享数据，就会共享失败。</strong></p></li><li><p>多进程的优点</p><ul><li>Android系统对每个应用占用内存是有限制的，占用内存越大越容易被杀死。可以提出组件运行于单独的进程中，减少主进程占用内存，降低被杀死几率。</li><li>子进程如果因为某种原因崩溃不会影响到主进程的使用。</li><li>独立进程的启动与退出不依赖于用户的使用，可以完全独立的控制，不会因为主进程的退出而结束。</li></ul></li><li><p>多进程造成的问题</p><ul><li>静态成员变量和单例模式完全失效</li><li>线程同步机制失败</li><li>SharedPreferences的可靠性下降 <code>不支持多进程读写</code></li><li>Application会多次创建<code>分配了独立的虚拟机</code></li></ul><p>一个应用内的多进程：<strong>相当于两个不同的应用采用了ShareUId模式</strong>。虽说不能直接共享内存数据，但是可以通过跨进程通信来实现数据交互。</p></li></ol><h2 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2. 序列化"></a>2. 序列化</h2><blockquote><p> 当我们需要跨进程通信时，传递的数据就需要进行序列化传递，然后接受方在反序列化得到传递数据</p></blockquote><blockquote><p>什么是序列化？</p><p>将对象转化为可以传输的二进制流的过程，就可以通过序列化，转化为可以在网络传输或者保存到本地的流，从而进行传输数据。反序列化即为从二进制流转化为对象的过程。</p><p>也为了解决对象的持久化问题。当你在程序中声明一个类后，程序关闭则释放对象，持久化就是为了应用关闭后类的内容依然存在。</p></blockquote><ol><li><p><code>Serializable</code></p><blockquote><p>由Java提供的一个序列化接口，为对象提供标准的序列化以及反序列化操作。</p></blockquote><p>使用方式相当简单</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-comment">//该参数是用来辅助序列化以及反序列化的过程，原则上该值相同才可以进行序列化以及反序列化的操作.</span>    <span class="hljs-comment">//不指定时 系统也会自动生成 但是容易因为变量的数量和类型发生改变而导致序列化失败。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">123123L</span>;        <span class="hljs-keyword">public</span> String name;    ...&#125;</code></pre><p>优缺点：使用简单但是效率较低，在序列化(ObjectOutputStream)以及反序列化(ObjectInputStream)类调用中会有大量的I/O操作。</p><p>适用场景：将对象类序列化存储到设备或者需要网络传输。</p></li><li><p><code>Parcelable</code></p><blockquote><p>Android提供的序列化接口，使用起来较为繁琐</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.os.Parcel;<span class="hljs-keyword">import</span> android.os.Parcelable;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span> </span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">User</span><span class="hljs-params">(Parcel in)</span> </span>&#123;        name = in.readString();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="hljs-keyword">new</span> Creator&lt;User&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">createFromParcel</span><span class="hljs-params">(Parcel in)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(in);        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> User[] newArray(<span class="hljs-keyword">int</span> size) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User[size];        &#125;    &#125;;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">describeContents</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeToParcel</span><span class="hljs-params">(Parcel dest, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;        dest.writeString(name);    &#125;&#125;</code></pre><p>序列化功能由<code>writeToParcel</code>实现，反序列化由<code>Parcel的read</code>实现。</p><p>优缺点：传递效率高效使用较为繁琐，主要序列化都在内存上进行。由于Parcelabel是Android提供的方法，可能会由于版本更新而会有些许改动。</p><p>适用场景：在内存的序列化中使用。</p></li></ol><h2 id="3-IPC方式"><a href="#3-IPC方式" class="headerlink" title="3. IPC方式"></a>3. IPC方式</h2><blockquote><p>本节主要讲述各种跨进程通信方式，目前有以下六种：</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/IPC-mode.png" srcset="/img/loading.gif" class="full-image" alt="IPC方式" title="IPC方式"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>上述方式实际都是通过Binder来实现的</p></blockquote><h3 id="1-Bundle"><a href="#1-Bundle" class="headerlink" title="1.Bundle"></a>1.Bundle</h3><blockquote><p>支持在<code>Activity、Service和Receiver</code>之间通过Intent来传递Bundle数据(调用<code>intent.putExtra()</code>)，由于Bundle实现了Parcelable接口，所以可以方便的在不同进程间传递(<code>传输的数据必须可以被序列化，不然无法进行传递</code>)。可以看做为一个特殊的Map类型。</p><p><strong>最简单的进程间通信方式。</strong></p></blockquote><p>拓展：当A进程计算后的结果无法通过Bundle传递至B进程时，可以将计算的过程用B进程的一个Service进行操作，然后在回调给B进程。</p><blockquote><p>为什么Bundle不直接使用HashMap呢？</p><ol><li>Bundle内部是由ArrayMap实现的，ArrayMap实质内部为两个数组，一个是<code>int[]</code>用于保存每个item的<code>hashCode</code>，另一个<code>Object[]</code>用于保存<code>key/value</code>键值对，容量为上一个数组的2倍。在添加、查找数据时，只要用二分查找法找到对应位置进行操作即可。占用内存也会小于<code>HashMap</code>。</li><li>在Android中如果需要使用Intent传递数据的话，需要的数据类型必须为<code>基本类型</code>或<code>可序列化类型</code>，<code>HashMap</code>采用<code>Serializable</code>进行序列化，<code>Bundle</code>采用了<code>Paracelable</code>进行序列化，更加适合于Android平台，在内存中完成序列化功能，开销更小。</li></ol></blockquote><h3 id="2-文件共享"><a href="#2-文件共享" class="headerlink" title="2.文件共享"></a>2.文件共享</h3><blockquote><p><strong>两个进程间通过读/写一个文件来进行数据传递</strong>，适用于对数据同步要求不高的进程间通信，并且需要对<strong>并发读/写</strong>进行妥善处理</p></blockquote><p>拓展：Android中的SharedPreferences也是文件共享方案的一种，但由于系统提供了一种缓存策略(内存中会有一份该文件的缓存)，导致它在多进程模式下，读/写并不可靠，甚至丢失数据。</p><h3 id="3-Messenger"><a href="#3-Messenger" class="headerlink" title="3.Messenger"></a>3.Messenger</h3><blockquote><p>轻量级的IPC方案，可以在不同的进程间传递Message对象。调用<code>Messenger.send(Message message)</code>传递Message对象。</p><p>Messager的底层实现是<code>AIDL</code>。它对AIDL做了封装，由于它一次只可以处理一个请求<strong>（串行请求）</strong>，因此不需考虑线程同步的问题。不过不能直接调用服务端的方法，只能通过传递消息处理。</p><p>由于主要传递的都是Message对象，导致无法实现远程调用。</p></blockquote><p>Messenger的构造函数分以下两种：</p> <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Messenger</span><span class="hljs-params">(IBinder target)</span></span>&#123;    mTarget = IMessenger.Stub.asInterface(target);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Messenger</span><span class="hljs-params">(Handler target)</span></span>&#123;    mTarget = target.getImessenger();&#125;</code></pre><blockquote><p>拓展：<strong>Handler主要用于线程间通信，Messenger用于进程间通信</strong></p></blockquote><p>实现一个Messenger需要以下两步：</p><ul><li><p><strong>服务端进程</strong>：</p><p>①创建一个Service来处理客户端的连接请求</p><p>②创建一个Handler并由他构造一个Messenger对象</p><p>③然后在Service的onBind方法中返回该Messenger对象中的Binder。</p><p>代码示例：</p><pre><code class="hljs java"><span class="hljs-comment">//MessengerServcice.java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessengerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessengerHanler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;           <span class="hljs-comment">//处理返回的Message消息</span>            ...                <span class="hljs-comment">//获取Client返回的Messenger对象</span>                    Messenger client = msg.replyTo;                    <span class="hljs-keyword">if</span> (client != <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-comment">//拼接数据 发送消息</span>                    &#125;                    &#125;    &#125;    <span class="hljs-comment">//通过Handler构造一个Messenger对象</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Messenger mMessenger = <span class="hljs-keyword">new</span> Messenger(<span class="hljs-keyword">new</span> MessengerHanler());       <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IBinder <span class="hljs-title">onBind</span><span class="hljs-params">(Intent intent)</span> </span>&#123;        <span class="hljs-comment">//返回IBinder对象 将消息交由对应Handler处理</span>        <span class="hljs-keyword">return</span> mMessenger.getBinder();    &#125;&#125;</code></pre></li><li><p><strong>客户端进程</strong>：</p><p>①绑定服务端Service –<code>bindService</code></p><p>②绑定后使用Service返回的IBinder对象创建一个Messenger对象</p><p>③通过Messenger对象向服务端发送Message  <strong>完成单向通信</strong></p><p>④创建一个Handler由此创建一个Messenger对象，然后将Messenger对象放入Message的<strong>replyTo</strong>字段传递给Server。  <strong>完成双向通信</strong></p><p>代码示例：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessengerActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_messenger);        Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, MessengerService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);    &#125;    <span class="hljs-keyword">private</span> Messenger mService;    <span class="hljs-keyword">private</span> ServiceConnection mConnection = <span class="hljs-keyword">new</span> ServiceConnection() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> </span>&#123;            mService = <span class="hljs-keyword">new</span> Messenger(service);            Message msg = Message.obtain(<span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>);            Bundle data = <span class="hljs-keyword">new</span> Bundle();            data.putString(<span class="hljs-string">"msg"</span>, <span class="hljs-string">"it is from client"</span>);            msg.setData(data);            <span class="hljs-comment">//若存在则形成了双向通信</span>            msg.replyTo = mGetReplyMessenger;            <span class="hljs-keyword">try</span> &#123;                mService.send(msg);            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> </span>&#123;        &#125;    &#125;;    <span class="hljs-keyword">private</span> Messenger mGetReplyMessenger = <span class="hljs-keyword">new</span> Messenger(<span class="hljs-keyword">new</span> MessengerHanler());    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessengerHanler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;           <span class="hljs-comment">//处理消息</span>        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//取消绑定service</span>        unbindService(mConnection);        <span class="hljs-keyword">super</span>.onDestroy();    &#125;&#125;</code></pre></li></ul><p>Messenger的工作原理：</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Messenger-principle.png" srcset="/img/loading.gif" class="full-image" alt="Messenger工作原理" title="Messenger工作原理"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="4-AIDL"><a href="#4-AIDL" class="headerlink" title="4.AIDL"></a>4.AIDL</h3><a href="/2019/01/06/Binder系列-Binder/" title="Binder系列-Binder">Binder系列-Binder</a><h3 id="5-ContentProvider"><a href="#5-ContentProvider" class="headerlink" title="5.ContentProvider"></a>5.ContentProvider</h3><blockquote><p>ContentProvider是专门用于不同应用间进行数据共享的方式，底层同样是由Binder实现。<strong>主要是提供了一个统一的接口为了存储和获取数据。</strong></p></blockquote><p><a href="https://www.jianshu.com/p/9048b47bb267" target="_blank" rel="noopener">ContentProvide</a></p><h3 id="6-Socket"><a href="#6-Socket" class="headerlink" title="6.Socket"></a>6.Socket</h3><blockquote><p>Socket也称为”套接字”，是网络通信中的概念，分为流式套接字(<code>基于TCP协议，采用流的方式提供可靠的字节流服务</code>)和用户数据报套接字（<code>基于UDP协议，采用数据报文提供数据打包发送的服务</code>）两种。<strong>Socket不仅可以跨进程通信还可以跨设备通信。</strong></p></blockquote><p><code>TCP协议是面向连接的协议，提供稳定的双向通信功能，因为连接的建立需要经过&#39;三次握手&#39;才能完成，由于本身提供了超时重传机制，因此具有很高的稳定性。</code></p><p><code>UDP是无连接的，提供不稳定的单向通信功能，在性能上拥有良好的效率，但数据不一定能够有效传输。</code></p><ol><li><p>实现方法：</p><p>服务端：</p><ul><li>创建一个Service，在线程中建立TCP服务，监听相应的端口等待客户端连接请求</li><li>与客户端连接时，会生成新的Socket对象，利用它可与客户端进行数据传输</li><li>断开连接时，关闭相应的socket并结束线程</li></ul><p>客户端：</p><ul><li>开启一个线程，通过Socket发起连接请求</li><li>连接成功后，读取服务端消息</li><li>断开连接，关闭Socket</li></ul></li><li><p>注意事项：</p><ul><li>需要声明网络权限</li></ul></li></ol><p>以上6种IPC方式比较：</p><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Bundle</td><td>简单易用</td><td>只能传输Bundle支持的数据类型</td><td>四大组件的进程间通信</td></tr><tr><td>文件共享</td><td>简单易用</td><td>不适合高并发场景，且无法做到实时通信</td><td>无并发访问情形，数据简单且实时性不高</td></tr><tr><td>AIDL</td><td>功能强大，支持一对多并发通信，支持实时通信</td><td>使用稍复杂，需要处理好线程同步</td><td>一对多通信且支持远程调用</td></tr><tr><td>Messenger</td><td>功能强大，支持一对多串行通信，支持实时通信</td><td>不能很好处理高并发场景，数据只能通过Message进行传输</td><td>低并发的一对多即时通信，并且不需要返回结果，不需要远程调用</td></tr><tr><td>ContentProvider</td><td>在数据访问方面功能强大，支持一对多数据共享，可通过Call方法扩展其他操作</td><td>受约束的AIDL实现，主要提供对数据的CRUD操作</td><td>一对多的进程间数据共享</td></tr><tr><td>Socket</td><td>功能强大，可以通过网络传输字节流，支持一对多并发通信</td><td>实现细节稍微麻烦</td><td>网络数据交换</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android需要的必备知识</title>
    <link href="/2018/12/09/Android%E9%9C%80%E8%A6%81%E7%9A%84%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2018/12/09/Android%E9%9C%80%E8%A6%81%E7%9A%84%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>第一关：Binder、AIDL、多进程（建议学习时间：2周）<br>知识点：Binder原理、AIDL的使用、多进程的定义和特性<br>学习资料：<br>① Android开发艺术探索第2章【推荐理由】地球人都知道学Android要看艺术探索。<br>② <a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Bander设计与实现 - 设计篇 - universus的专栏 - CSDN博客</a> 【推荐理由】Binder底层史上最牛逼分析，没有之一。<br>③ 艺术探索第2章的例子，请一定手动运行一遍并仔细理解，地址：<a href="https://github.com/singwhatiwanna/android-art-res" target="_blank" rel="noopener">GitHub - singwhatiwanna/android-art-res: the sourc…</a>。<br>第二关：View的绘制（建议学习时间：3天）<br>知识点：View的measure、layout和draw，View的工作原理<br>学习资料：<br>① Android开发艺术探索第4章【推荐理由】地球人都知道学Android要看艺术探索。<br>② <a href="https://www.jianshu.com/p/3d2c49315d68" target="_blank" rel="noopener">图解View测量、布局及绘制原理 - 简书</a> 【推荐理由】配有流程图，比艺术探索好理解一些。<br>③ <a href="https://juejin.im/entry/5819968bda2f60005dda6a2d" target="_blank" rel="noopener">android ListView 工作原理 - Android - 掘金</a>【推荐理由】帮大家了解ListView的工作过程，很有价值。<br>第三关：事件分发（建议学习时间：1周）<br>知识点：事件分发原理和规则<br>学习资料：<br>① Android开发艺术探索第3章【推荐理由】地球人都知道学Android要看艺术探索。<br>② <a href="https://www.jianshu.com/p/fc0590afb1bf" target="_blank" rel="noopener">Android事件分发机制，大表哥带你慢慢深入 - 简书</a> 【推荐理由】通过实际的例子来讲事件分发，好理解。<br>③ <a href="https://blog.csdn.net/lmj623565791/article/details/39102591" target="_blank" rel="noopener">Android ViewGroup事件分发机制 - Hongyang - CSDN博客</a> 【推荐理由】张鸿洋写的。<br>第四关：消息队列（建议学习时间：1天）<br>要求：Handler、Looper、Thread三者之间的关系；得知道子线程创建Handler为什么会报错，如何才能不报错<br>学习资料：<br>① Android开发艺术探索第10章【推荐理由】这块内容不难，艺术探索就够了。<br>② <a href="https://blog.csdn.net/dfskhgalshgkajghljgh/article/details/52601802" target="_blank" rel="noopener">源码角度讲解子线程创建Handler报错的原因 - 曹银飞的专栏 - CSDN博客</a>【推荐理由】一个实际的例子帮助大家更好地理解。<br>第五关：Activity难点（建议学习时间：1天）<br>① setResult和finish的顺序关系<br>② onSaveInstanceState()和onRestoreInstanceState()<br>③ onNewIntent()和onConfigurationChanged()<br>学习资料：<br>① <a href="https://www.cnblogs.com/shaweng/p/3875825.html" target="_blank" rel="noopener">setResult()的调用时机 - 沙翁 - 博客园</a>【推荐理由】清晰易懂，直接了当。<br>② <a href="https://www.jianshu.com/p/27181e2e32d2" target="_blank" rel="noopener">onSaveInstanceState()和onRestoreInstanceState()使用详解…</a>【推荐理由】简单好懂。<br>③ <a href="https://blog.csdn.net/qq_27570955/article/details/55046934" target="_blank" rel="noopener">关于onConfigurationChanged方法及常见问题解决 - 朱小姐。的博客 - CSDN…</a>【推荐理由】简单好懂，文章在郭霖公号投稿了。<br>④ 艺术探索第1章【推荐理由】地球人都知道学Android要看艺术探索。<br>第六关：Service难点（建议学习时间：2天）<br>① 先start再bind，如何停止一个Service<br>② Service onStartCommand的返回值<br>③ bindService后，ServiceConnection里面的回调方法运行在哪个线程？它们的调用时机分别是什么？<br>④ Service的onCreate运行在哪个线程？<br>学习资料：<br>① <a href="https://www.jianshu.com/p/d870f99b675c" target="_blank" rel="noopener">Android中startService和bindService的区别 - 简书</a>【推荐理由】详细全面地回答了上面的问题。<br>② <a href="https://blog.csdn.net/veryitman/article/details/7600008" target="_blank" rel="noopener">Service: onStartCommand 诡异的返回值 - CodingMan - CSDN博…</a>【推荐理由】通过实例来演示onStartCommand那诡异的返回值。<br>③ Service的onCreate、onStartCommand、onDestory等全部生命周期方法都运行在UI线程，ServiceConnection里面的回调方法也是运行在UI线程，大家一定要记住。【推荐理由】任玉刚说的，你们自己可以打log验证一下<br>第七关：ContentProvider难点(建议学习时间：3天)<br>① ContentProvider的生命周期<br>② ContentProvider的onCreate和CRUD运行在哪个线程？它们是线程安全的吗？<br>③ ContentProvider的内部存储只能是sqlite吗？<br>学习资料：<br>① 艺术探索第9章中ContentProvider的启动、艺术探索第二章中ContentProvider的介绍【推荐理由】详细了解下，艺术探索的内容无需解释<br>② <a href="https://www.jianshu.com/p/0f1e36507b9d" target="_blank" rel="noopener">android ContentProvider onCreate()在 Application……</a>【推荐理由】此文明确说明了ContentProvider的onCreate早于Application的onCreate而执行。<br>③ <a href="https://www.jianshu.com/p/cfa46bea6d7b" target="_blank" rel="noopener">ContentProvider总结 - 简书</a>【推荐理由】此文明确说明了ContentProvider的onCreate和CRUD所在的线程<br>注意：ContentProvider的底层是Binder，当跨进程访问ContentProvider的时候，CRUD运行在Binder线程池中，不是线程安全的，而如果在同一个进程访问ContentProvider，根据Binder的原理，同进程的Binder调用就是直接的对象调用，这个时候CRUD运行在调用者的线程中。另外，ContentProvider的内部存储不一定是sqlite，它可以是任意数据。<br>第八关：AsyncTask原理(建议学习时间：3天)<br>要求：知道AsyncTask的工作原理，知道其串行和并行随版本的变迁<br>① <a href="https://blog.csdn.net/singwhatiwanna/article/details/17596225" target="_blank" rel="noopener">Android源码分析—带你认识不一样的AsyncTask - 任玉刚 - CSDN博客</a> 【推荐理由】只看这一篇文章就够了<br>② <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.1.0_r46/core/java/android/os/AsyncTask.java" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/base/ /android-8.1.0_r46/core/java/android/os/AsyncTask.java</a> 【推荐理由】阅读AsyncTask 8.1版本的源码，看看是否有更新</p><p>第九关：RemoteViews(建议学习时间：7天)<br>要求：熟悉RemoteViews并了解其原理<br>① Android开发艺术探索 第5章【推荐理由】艺术探索是高级工程师进阶必备<br>② <a href="https://juejin.im/post/5c3b588be51d4551de1da844" target="_blank" rel="noopener">关于 RemoteViews 跨进程资源访问的勘误 - 掘金</a> 【推荐理由】进一步理解RemoteViews的实现，通过它可以实现资源的跨进程访问，艺术探索中的担心是多余的<br>第十关：Window和ViewRootImpl(建议学习时间：14天)<br>要求：熟悉Window、WMS和ViewRootImpl的原理<br>① Android开发艺术探索 第8章【推荐理由】艺术探索是高级工程师进阶必备<br>② Android进阶解密 第8章 【推荐理由】进阶必备<br>③ <a href="https://www.jianshu.com/p/9da7bfe18374" target="_blank" rel="noopener">Android窗口机制（四）ViewRootImpl与View和WindowManager - 简书</a>【推荐理由】另一个优秀作者对Window的描述<br>④ <a href="https://blog.csdn.net/singwhatiwanna/article/details/50775201" target="_blank" rel="noopener">Android中MotionEvent的来源和ViewRootImpl - 任玉刚 - CSDN博客</a> 【推荐理由】另一个角度理解下输入事件和ViewRootImpl的关联<br>第十一关：刁钻问题汇总 (建议学习时间：一周)<br>① 子线程访问 UI 却不报错的原因：<a href="https://blog.csdn.net/xyh269/article/details/52728861" target="_blank" rel="noopener">Android中子线程真的不能更新UI吗？ - yinhuanxu - CSDN博客</a><br>② 主线程的消息循环是一个死循环，为何不会卡死：<a href="https://www.zhihu.com/question/34652589" target="_blank" rel="noopener">Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ - 知乎</a><br>③ Binder、IBinder、IInterface的关系：<a href="https://pan.baidu.com/s/1VImj3EXesFXAqT3pskcSig" target="_blank" rel="noopener">把玩Android多进程.pdf_免费高速下载|百度网盘-分享无限制</a><br>注意：主线程的消息循环背后，一切皆是消息，消息机制和Binder是Android系统的两大核心机制，屏幕触摸消息、键盘消息、四大组件的启动等均是由消息驱动。<br>第十二关：Retrofit原理分析 (建议学习时间：14天)<br>要求：熟悉Retrofit/OKHttp的工作原理<br>① <a href="https://www.jianshu.com/p/27c1554b7fee" target="_blank" rel="noopener">OKHttp源码解析 - 简书</a>【推荐理由】okhttp源码分析<br>② <a href="https://zhuanlan.zhihu.com/p/35121326" target="_blank" rel="noopener">Retrofit原理解析最简洁的思路 - 知乎</a> 【推荐理由】retrofit原理分析<br>③ <a href="https://www.jianshu.com/p/cb3a7413b448" target="_blank" rel="noopener">Retrofit是如何工作的？ - 简书</a>【推荐理由】另一个retrofit原理分析<br>④ 自行阅读okhttp/retrofit的源码，并写出一篇原理分析的文章 【推荐理由】源码一定要亲自读一读，并沉淀为自己的知识<br>第十三关：RxJava原理分析 (建议学习时间：14天)<br>① <a href="https://juejin.im/post/5a209c876fb9a0452577e830" target="_blank" rel="noopener">友好 RxJava2.x 源码解析（一）基本订阅流程 - 掘金</a>【推荐理由】基本订阅流程，已在玉刚说投稿<br>② <a href="https://juejin.im/post/5a248206f265da432153ddbc" target="_blank" rel="noopener">友好 RxJava2.x 源码解析（二）线程切换 - 掘金</a> 【推荐理由】线程切换，已在玉刚说投稿<br>③ <a href="https://juejin.im/post/5ac16a2d6fb9a028b617a82a" target="_blank" rel="noopener">友好 RxJava2.x 源码解析（三）zip 源码分析 - 掘金</a>【推荐理由】zip，已在玉刚说投稿<br>④ 自行阅读RxJava源码，并写出一篇原理分析的文章 【推荐理由】源码一定要亲自读一读，并沉淀为自己的知识</p><p>第十四关：Glide原理分析 (建议学习时间：14天)<br>① <a href="https://blog.csdn.net/guolin_blog/article/details/53939176" target="_blank" rel="noopener">Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程 - 郭霖的专栏 - …</a>【推荐理由】glide工作原理，文章很长，郭霖出品<br>② 自行阅读 glide 4 源码，并写出一篇原理分析的文章 【推荐理由】源码一定要亲自读一读，并沉淀为自己的知识<br>第十五关：Groovy (建议学习时间：3天)<br>要求：熟悉groovy的常见语法<br>① <a href="https://blog.csdn.net/singwhatiwanna/article/details/76084580" target="_blank" rel="noopener">Gradle从入门到实战 - Groovy基础 - 任玉刚 - CSDN博客</a>【推荐理由】groovy语法基础，任玉刚出品<br>② <a href="http://www.groovy-lang.org/documentation.html" target="_blank" rel="noopener">The Apache Groovy programming language - Documenta…</a> 【推荐理由】官方文档，可当做字典来查阅<br>第十六关：Gradle插件基础 (建议学习时间：7天)<br>要求：熟悉gradle语法，可以书写简单的gradle插件<br>① <a href="https://blog.csdn.net/singwhatiwanna/article/details/78797506" target="_blank" rel="noopener">全面理解Gradle - 执行时序 - 任玉刚 - CSDN博客</a>【推荐理由】gradle执行时序，任玉刚出品<br>② <a href="https://blog.csdn.net/singwhatiwanna/article/details/78898113" target="_blank" rel="noopener">全面理解Gradle - 定义Task - 任玉刚 - CSDN博客</a>【推荐理由】task定义，任玉刚出品<br>③ <a href="https://mp.weixin.qq.com/s/KCpl0CNgwMv0CgvbadNK6A" target="_blank" rel="noopener">一篇文章带你了解Gradle插件的所有创建方式</a>【推荐理由】gradle插件的三种创建方式，已在玉刚说投稿<br>④ <a href="https://juejin.im/post/5b02113a5188254289190671" target="_blank" rel="noopener">写给 Android 开发者的 Gradle 系列（三）撰写 plugin - 掘金</a> 【推荐理由】一个简单的小例子，让大家理解gradle插件的价值<br>第十七关：设计模式 (建议学习时间：30-60天)<br>要求：熟悉6大基本原则、23种设计模式，并能在实际中灵活使用<br>① 《大话设计模式》【推荐理由】强烈建议买一本设计模式的书，好好看看，这事急不得<br>② <a href="https://blog.csdn.net/longyulu/article/details/9159589" target="_blank" rel="noopener">23种设计模式全解析 - 龙鱼鹿 - CSDN博客</a> 【推荐理由】这是一篇文章，涵盖了全部设计模式，我收藏了好几年了，拿出来给大家看，但是只看这篇文章是远远不够的<br>③  <a href="https://t.zsxq.com/QzZZZNj" target="_blank" rel="noopener">https://t.zsxq.com/QzZZZNj</a>【推荐理由】学习设计模式的精神，任玉刚出品<br>④ <a href="https://juejin.im/post/5b3cddb6f265da0f8145c049" target="_blank" rel="noopener">如何通俗理解设计模式及其思想? - 掘金</a> 【推荐理由】学习设计模式的精神，却把青梅嗅出品<br>第十八关：MVC、MVP、MVVM (建议学习时间：14天)<br>要求：熟悉它们并会灵活使用<br>① <a href="https://juejin.im/post/5b3a3a44f265da630e27a7e6" target="_blank" rel="noopener">MVC、MVP、MVVM，我到底该怎么选？ - 掘金</a>【推荐理由】3M，理论结合小例子，好理解，玉刚说写作平台文章<br>② <a href="https://blog.csdn.net/singwhatiwanna/article/details/78898113" target="_blank" rel="noopener">全面理解Gradle - 定义Task - 任玉刚 - CSDN博客</a>【推荐理由】讲解MVP，理论结合小例子，好理解，玉刚说写作平台文章<br>③ <a href="https://juejin.im/post/5b44d50de51d451925627900" target="_blank" rel="noopener">https://juejin.im/post/5b44d50de51d451925627900</a>【推荐理由】3M，Mr.S的作品，玉刚说写作平台文章<br>第十九关：组件化 (建议学习时间：7天)<br>① <a href="https://juejin.im/post/5b5f17976fb9a04fa775658d" target="_blank" rel="noopener">Android 组件化最佳实践 - 掘金</a>【推荐理由】一篇长文搞定，包括所有内容，分析+实例<br>第二十关：jni和ndk基础 (建议学习时间：30-60天)<br>要求：熟悉jni和ndk语法，能进行简单的开发<br>① 《Android开发艺术探索》第14章【推荐理由】这是最最基本的jni和ndk入门<br>② <a href="https://blog.csdn.net/xyang81/column/info/blogjnindk" target="_blank" rel="noopener">JNI/NDK开发指南 - 技术改变生活（为理想而奋斗，为目标而努力！） - xyang0917 -…</a>【推荐理由】找了半天，找到一个还凑合的教程，真是资源匮乏呀<br>③ <a href="https://developer.android.com/ndk/guides/" target="_blank" rel="noopener">https://developer.android.com/ndk/guides/</a>【推荐理由】官方的ndk入门指南，讲了很多配置选项，推荐看看<br>④ <a href="https://www.jianshu.com/p/9b83cc5a5ba8" target="_blank" rel="noopener">Android JNI 编程实践 - 简书</a>【推荐理由】讲解了如何注册jin函数表，也需要大家看一下<br>⑤ 书籍《Android C++高级编程 使用NDK》 【推荐理由】如果要系统学习ndk，还是推荐看看书</p><p>第二十一关：安全 (建议学习时间：14天)<br>要求：熟悉各种发编译+二次打包工具，了解smali<br>① <a href="https://blog.csdn.net/ljheee/article/details/53191397" target="_blank" rel="noopener">浅析Android沙箱模型 - ljheee的博客 - CSDN博客</a>【推荐理由】了解沙盒机制<br>② <a href="https://blog.csdn.net/singwhatiwanna/article/details/19019547" target="_blank" rel="noopener">Smali语法介绍 - 任玉刚 - CSDN博客</a>【推荐理由】smali入门，很简单，之前我写的<br>③ <a href="https://ctf-wiki.github.io/ctf-wiki/android/basic_operating_mechanism/java_layer/smali/smali/" target="_blank" rel="noopener">Smali 介绍 - CTF Wiki</a>【推荐理由】复杂点的smali入门<br>④ <a href="https://blog.csdn.net/L25000/article/details/46842013" target="_blank" rel="noopener">android逆向分析之smali语法 - L25000的专栏 - CSDN博客</a>【推荐理由】各种工具的使用，以及一个使用apktool进行破解的例子<br>备注：各种工具软件大家网上自己找，反编译的话推荐jadx，比dex2jar+jd-gui更方便，smali有点复杂，如果不是特别需要，不建议深入学习，事实上，很多人私下研究安全其实就是为了破解。<br>第二十二关：动态化 (建议学习时间：30-60天)<br>要求：阅读VirtualAPK的源码，熟悉常见的热修复和插件化原理<br>① <a href="https://blog.csdn.net/sbsujjbcy/article/details/50812674" target="_blank" rel="noopener">Android 热修复Nuwa的原理及Gradle插件源码解析 - 区长的专栏 - CSDN博客</a>【推荐理由】nuwa原理浅析<br>② <a href="https://blog.csdn.net/lmj623565791/article/details/54882693" target="_blank" rel="noopener">Android 热修复 Tinker接入及源码浅析 - Hongyang - CSDN博客</a>【推荐理由】Tinker原理解析，鸿洋出品<br>③ <a href="https://blog.csdn.net/lmj623565791/article/details/75000580" target="_blank" rel="noopener">滴滴插件化方案 VirtualApk 源码解析 - Hongyang - CSDN博客</a>【推荐理由】VirtualAPK四大组件原理解析，鸿洋出品<br>④ <a href="https://www.notion.so/VirtualAPK-1fce1a910c424937acde9528d2acd537" target="_blank" rel="noopener">Notion – The all-in-one workspace for your notes, …</a>【推荐理由】VirtualAPK资源加载机制<br>⑤ <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="noopener">GitHub - tiann/understand-plugin-framework: demos …</a> 【推荐理由】插件化技术的方方面面，作者是田维术，必看的文章<br>⑥ <a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">GitHub - didi/VirtualAPK: A powerful and lightweig…</a> 【推荐理由】VirtualAPK引擎和构建部分，必看</p><p>应用双开与系统分身</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal原理分析</title>
    <link href="/2018/12/09/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2018/12/09/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal详解"><a href="#ThreadLocal详解" class="headerlink" title="ThreadLocal详解"></a>ThreadLocal详解</h1><blockquote><p>在前几节Handler详解中介绍 如何获取Looper对象时提及了是利用ThreadLocal来进行Looper的存储与获取。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ThreadLocal解析.png" srcset="/img/loading.gif" class="full-image" alt="ThreadLocal解析" title="ThreadLocal解析"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="1-初步理解ThreadLocal"><a href="#1-初步理解ThreadLocal" class="headerlink" title="1.初步理解ThreadLocal"></a>1.初步理解ThreadLocal</h2><p>ThreadLocal的定义为：<strong>用于提供线程变量，在多线程环境中可以保证各个线程的变量独立于其他线程里的变量。</strong>主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量不会互相干扰，适用于<code>高并发状态下实现无状态的调用即各个线程依赖不同的变量完成操作</code>。</p><p>ThreadLocal的另一个使用场景是<strong>复杂逻辑下的对象传递</strong>。</p><blockquote><p>ThreadLocal保证的是多线程环境下的独立性，同步机制则保证多线程下数据的一致性。</p></blockquote><h2 id="2-使用样例"><a href="#2-使用样例" class="headerlink" title="2.使用样例"></a>2.使用样例</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String label;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        label = <span class="hljs-string">"main"</span>;        threadLocal.set(<span class="hljs-string">"main"</span>);        <span class="hljs-comment">//new Thread</span>        Thread thread = <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">super</span>.run();                label = <span class="hljs-string">"new"</span>;                threadLocal.set(<span class="hljs-string">"new"</span>);            &#125;        &#125;;        thread.start();        <span class="hljs-keyword">try</span> &#123;            thread.join();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.err.println(<span class="hljs-string">"label = "</span> + label);        System.err.println(<span class="hljs-string">"threadLocal = "</span> + threadLocal.get());    &#125;&#125;<span class="hljs-comment">//console.log</span>label = <span class="hljs-keyword">new</span>threadLocal = main</code></pre><p>对于ThreadLocal中的变量，在一个线程中修改它的值，并不会影响到在其他线程中的值。<strong>ThreadLocal中的值在每个线程中都是独立的。</strong></p><h2 id="3-深入理解ThreadLocal"><a href="#3-深入理解ThreadLocal" class="headerlink" title="3.深入理解ThreadLocal"></a>3.深入理解ThreadLocal</h2><p>ThreadLocal类中提供了以下几个方法来进行变量的操作：</p><ul><li><code>public T get()</code>获取ThreadLocal在当前线程中保存的变量副本</li><li><code>public void set(T value)</code>设置当前线程中的变量副本</li><li><code>public void remove()</code>移除当前线程中的变量副本</li><li><code>protected T initialValue()</code>设置ThreadLocal的初始值，该方法为延迟加载</li></ul><p>接下来具体查看上述方法的内部实现。加深理解</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h3><pre><code class="hljs java"><span class="hljs-comment">//返回当前线程中存储的变量副本</span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//获取当前线程</span>        Thread t = Thread.currentThread();        <span class="hljs-comment">//获取到持有变量副本的map</span>        ThreadLocalMap map = getMap(t);        <span class="hljs-comment">//map存在则返回存储值</span>        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//该map key为ThreadLocal 故获取value用的是this</span>            ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)                T result = (T)e.value;                <span class="hljs-keyword">return</span> result;            &#125;        &#125;        <span class="hljs-comment">//不存在则返回默认值</span>        <span class="hljs-keyword">return</span> setInitialValue();    &#125;</code></pre><h3 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a><code>set(T value)</code></h3><pre><code class="hljs java"><span class="hljs-comment">//设置当前线程的变量副本</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span></span>&#123;   Thread t = Thread.currentThread();   ThreadLocalMap map = getMap(t);    <span class="hljs-comment">//map不为null 则保存value</span>    <span class="hljs-keyword">if</span>(map!=<span class="hljs-keyword">null</span>)&#123;        map.set(<span class="hljs-keyword">this</span>,value);    &#125;    <span class="hljs-comment">//否则创建一个ThreadLocalMap后保存value</span>    <span class="hljs-keyword">else</span>&#123;        createMap(t,value);    &#125;&#125;</code></pre><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a><code>remove()</code></h3><pre><code class="hljs java"><span class="hljs-comment">//移除保存的变量副本</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>&#123;    ThreadLocalMap map = getMap(Thread.currentThread);    <span class="hljs-comment">//map不为空 则移除当前ThreadLocal对应的变量副本</span>    <span class="hljs-keyword">if</span>(map!=<span class="hljs-keyword">null</span>)        map.remove(<span class="hljs-keyword">this</span>);&#125;</code></pre><h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue()"></a><code>initialValue()</code></h3><pre><code class="hljs java"><span class="hljs-comment">//子类可重写该方法 进行默认值的设置</span><span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;对应有setInitialValue()<span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">setInitialValue</span><span class="hljs-params">()</span></span>&#123;   T value = initialValue();   Thread t = Thread.currentThread();   ThreadLocalMap map = getMap(t);    <span class="hljs-keyword">if</span>(map!=<span class="hljs-keyword">null</span>)&#123;        map.set(<span class="hljs-keyword">this</span>,value);    &#125;<span class="hljs-keyword">else</span>&#123;        createMap(t,value);    &#125;    <span class="hljs-keyword">return</span> value;&#125;</code></pre><p>在上述四个方法中都会涉及到一个类<strong><code>ThreadLocalMap</code></strong>，该类是ThreadLocal的核心机制实现。<code>在使用ThreadLocal的方法对存储变量进行操作时都需要获得当前线程对应的ThreadLocalMap来对变量进行操作</code>。<strong>每个线程都会有专属的ThreadLocalMap，其中维护的value也是对应当前线程的。就保证了ThreadLocal中存储的变量都是相互独立的，不会受到多线程环境的影响。</strong></p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a><strong><code>ThreadLocalMap</code></strong></h3><blockquote><p>该类为ThreadLocal中的内部类，没有实现Map接口，内部自己实现了Map的功能。</p></blockquote><ol><li><p>构造方法</p><pre><code class="hljs java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;           table = <span class="hljs-keyword">new</span> Entry[INITIAL_CAPACITY];           <span class="hljs-keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);           table[i] = <span class="hljs-keyword">new</span> Entry(firstKey, firstValue);           size = <span class="hljs-number">1</span>;           setThreshold(INITIAL_CAPACITY);       &#125;</code></pre></li><li><p>初始对象</p><pre><code class="hljs java"><span class="hljs-comment">// 初始容量，必须是 2 的幂</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INITIAL_CAPACITY = <span class="hljs-number">16</span>;<span class="hljs-comment">// 存储数据的哈希表</span><span class="hljs-keyword">private</span> Entry[] table;<span class="hljs-comment">// table 中已存储的条目数</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<span class="hljs-comment">// 表示一个阈值，当 table 中存储的对象达到该值时就会扩容</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> threshold;<span class="hljs-comment">// 设置 threshold 的值</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThreshold</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;    threshold = len * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;&#125;</code></pre><p>由内部实现了一套Map机制</p></li><li><p>Entry</p><blockquote><p>table中存储的都为Entry对象，用于保存K-V数据结构</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>    Object value;       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;        <span class="hljs-keyword">super</span>(k);        value = v;    &#125;&#125;</code></pre><p>Entry继承自<code>WeakRefrence&lt;ThreadLocal&lt;?&gt;&gt;</code>为弱引用类型并且限制了<code>K</code>只能为ThreadLocal对象，但是对应的<code>V</code>为强引用类型，则可能导致<strong>内存泄漏</strong>。</p></li><li><p>保存key-value</p><pre><code class="hljs java"><span class="hljs-comment">//调用set方法将 key-value类型进行存储</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;            <span class="hljs-comment">// We don't use a fast path as with get() because it is at</span>            <span class="hljs-comment">// least as common to use set() to create new entries as</span>            <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span>            <span class="hljs-comment">// path would fail more often than not.</span>            Entry[] tab = table;            <span class="hljs-keyword">int</span> len = tab.length;            <span class="hljs-comment">//计算要存储的索引位置</span>            <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);            <span class="hljs-comment">//判断要存储的索引位置是否已经存在Entry 存在则继续向下</span>            <span class="hljs-keyword">for</span> (Entry e = tab[i];                 e != <span class="hljs-keyword">null</span>;                 e = tab[i = nextIndex(i, len)]) &#123;                ThreadLocal&lt;?&gt; k = e.get();                <span class="hljs-comment">//key相同则更新</span>                <span class="hljs-keyword">if</span> (k == key) &#123;                    e.value = value;                    <span class="hljs-keyword">return</span>;                &#125;                <span class="hljs-comment">//key为空 代表该位置对应的Entry已失效，需要直接进行替换</span>                <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;                    replaceStaleEntry(key, value, i);                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            <span class="hljs-comment">//若不存在 则将Entry保存到该位置</span>            tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);            <span class="hljs-keyword">int</span> sz = ++size;            <span class="hljs-comment">//超过当前负载 则需进行扩容机制 重新调整table</span>            <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)                rehash();        &#125;</code></pre><p>使用当前的ThreadLocal中对应的threadLocalHashCode来计算该键值对要存储的索引位置。该值是由ThreadLocal对象自动生成的，创建时就会进行赋值。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadLocalHashCode = nextHashCode();    <span class="hljs-comment">/**     * The next hash code to be given out. Updated atomically. Starts at     * zero.     * 使用AtomicInteger用来保证多线程环境下不会受到影响     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger nextHashCode =        <span class="hljs-keyword">new</span> AtomicInteger();    <span class="hljs-comment">/**     * The difference between successively generated hash codes - turns     * implicit sequential thread-local IDs into near-optimally spread     * multiplicative hash values for power-of-two-sized tables.     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HASH_INCREMENT = <span class="hljs-number">0x61c88647</span>;    <span class="hljs-comment">/**     * Returns the next hash code.     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextHashCode</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);    &#125;</code></pre><p>当table中的条目超出阈值时就需要进行扩容</p><pre><code class="hljs java"><span class="hljs-comment">//扩容是 新table的容量为原先的两倍 触发条件为table中的条目数超出了阈值的3/4</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span></span>&#123;    Entry[] oldTab = table;    <span class="hljs-keyword">int</span> oldLen = oldTab.length;    <span class="hljs-keyword">int</span> newLen = oldLen * <span class="hljs-number">2</span>;    Entry[] newTab = <span class="hljs-keyword">new</span> Entry[newLen];    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;oldLen;++j)&#123;        Entry e = oldTab[j];        <span class="hljs-keyword">if</span>(e!=<span class="hljs-keyword">null</span>)&#123;           ThreadLocal&lt;?&gt; k =e.get();            <span class="hljs-keyword">if</span>(k == <span class="hljs-keyword">null</span>)&#123;                e.value = <span class="hljs-keyword">null</span>;            &#125; <span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">//重新计算扩容后的Hash值</span>                <span class="hljs-keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);                <span class="hljs-keyword">while</span>(newTab[h]!=<span class="hljs-keyword">null</span>)&#123;                    h = nextIndex(h,newLen);                &#125;                newTab[h] = e;                count ++;            &#125;        &#125;    &#125;    <span class="hljs-comment">//重新设定当前容量</span>    setThreshold(newLen);    size = count;    table = newTab;&#125;</code></pre></li><li><p>获取Entry对象</p><pre><code class="hljs java"><span class="hljs-comment">//根据传递进来的ThreadLocal 获取对应的entry</span><span class="hljs-function"><span class="hljs-keyword">private</span> Entry <span class="hljs-title">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;           <span class="hljs-comment">//重新计算threadLocal对应的index</span>            <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);            Entry e = table[i];            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.get() == key)            <span class="hljs-comment">//entry不为空且对应位置key相同 则返回Entry</span>                <span class="hljs-keyword">return</span> e;            <span class="hljs-keyword">else</span>            <span class="hljs-comment">//否则 寻找临近的位置是否存在对应的值</span>                <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);        &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> Entry <span class="hljs-title">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-keyword">int</span> i, Entry e)</span> </span>&#123;    Entry[] tab = table;    <span class="hljs-keyword">int</span> len = tab.length;    <span class="hljs-comment">//当前传递的entry不为空 则开始循环</span>    <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>) &#123;        ThreadLocal&lt;?&gt; k = e.get();        <span class="hljs-keyword">if</span> (k == key)            <span class="hljs-comment">//相同则返回对应的 entry</span>            <span class="hljs-keyword">return</span> e;        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>)            <span class="hljs-comment">//key消失 则移除对应的Entry</span>            expungeStaleEntry(i);        <span class="hljs-keyword">else</span>            <span class="hljs-comment">//继续向下寻找</span>            i = nextIndex(i, len);        e = tab[i];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>调用<code>getEntryAfterMiss()</code>时，大部分由于哈希冲突(<code>Hash slot</code>)导致的。由于ThreadLocalMap没有使用链表的方式实现,所以解决Hash冲突的方式也只能使用一种<strong>线性探测</strong>的方式。<code>线性探测意为根据初始key的hashcode来确定元素在表中的位置，若发现位置已被占用，则会利用固定算法找到下一个位置，直到找到可以存放的位置。</code></p><p>ThreadLocalMap解决Hash冲突的方法就是 <code>步长+1或-1</code>,寻找下一个相邻的位置。</p></li><li><p>移除指定的Entry</p><pre><code class="hljs java"><span class="hljs-comment">//根据threadLocal移除对应位置的Entry</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;    Entry[] tab = table;    <span class="hljs-keyword">int</span> len = tab.length;    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (Entry e = tab[i];         e != <span class="hljs-keyword">null</span>;         e = tab[i = nextIndex(i, len)]) &#123;        <span class="hljs-keyword">if</span> (e.get() == key) &#123;            e.clear();            expungeStaleEntry(i);            <span class="hljs-keyword">return</span>;        &#125;    &#125;&#125;</code></pre></li><li><p>其他知识点</p><p>在上述<code>set(),get(),remove()</code>方法中都涉及到了一个点，都会去进行一次判断当前位置的Entry是否无效并清除的操作，主要是为了<strong>降低内存泄漏发生的可能性</strong>。</p><p>上面分析中就有提到ThreadLocalMap的key为弱引用型，而value为强引用型，就可能导致内存泄漏发生。</p><p><strong>所以当我们使用ThreadLocal时，每次使用完毕都需要主动调用一次remove()方法来防止内存泄漏的发生。</strong></p></li></ol><h2 id="4-实现原理"><a href="#4-实现原理" class="headerlink" title="4.实现原理"></a>4.实现原理</h2><p>在每个<code>Thread</code>中维护一个<code>ThreadLocalMap</code>，存储中的key为<code>ThreadLocal</code>对象本身，value是需要存储的对象。</p><p>这样设计的好处在于</p><ul><li><code>ThreadLocalMap</code>中存储的<code>Entry</code>数量会变少，数量由<code>ThreadLocal</code>对象的个数来决定。</li><li><code>Thread</code>销毁后其内部的<code>ThreadLocalMap</code>也会一并销毁，减少内存的使用。</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="ThreadLocal与synchronized的区别"><a href="#ThreadLocal与synchronized的区别" class="headerlink" title="ThreadLocal与synchronized的区别"></a>ThreadLocal与synchronized的区别</h3><p><code>ThreadLocal</code>是一个Java类，通过对当前线程中的局部变量的操作来解决不同线程间的变量访问问题。每个线程都拥有自己的变量副本。<strong>空间换时间</strong></p><p><code>synchronized</code>是一个关键字，依靠JVM中的锁机制<code>monitor</code>来实现变量访问的原子性。保证的是同一时间只有一个线程可以访问变量。<strong>时间换空间</strong></p><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><blockquote><p><code>ThreadLocal</code>中变量副本是线程私有的即其他线程无法对其进行访问。<code>InheritableThreadLocal</code>是可以支持<strong>在子线程中访问到父线程的变量副本</strong>。</p></blockquote><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InheritableThreadLocal&lt;Integer&gt; integerInheritableThreadLocal =            <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        threadLocal.set(<span class="hljs-string">"main"</span>);        integerInheritableThreadLocal.set(<span class="hljs-number">123</span>);        Thread thread = <span class="hljs-keyword">new</span> Thread() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">super</span>.run();                System.err.println(<span class="hljs-string">"threadLocal "</span>+ threadLocal.get());                System.err.println(<span class="hljs-string">"inheritableThreadLocal "</span>+ integerInheritableThreadLocal.get());            &#125;        &#125;;        thread.start();        <span class="hljs-keyword">try</span> &#123;            thread.join();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;运行结果：threadLocal <span class="hljs-keyword">null</span>inheritableThreadLocal <span class="hljs-number">123</span></code></pre><p>实现原理：</p><p>在线程进行初始化时，子线程会拷贝父线程的<code>inheritableThreadLocals</code>到自己的变量中，故调用<code>get()</code>时，会读取到父线程所存储的变量副本。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>每个ThreadLocal中只能保存一个变量副本，如果需要多个则需创建多个ThreadLocal</li><li>由于ThreadLocal内部中ThreadLocalMap的key实现为弱引用，可能导致内存泄漏，使用完成后需要及时调用<code>remove()</code>来避免泄漏</li><li>使用ThreadLocal时，需要先<code>set()</code>再<code>get()</code>避免发生空指针异常，若重写了<code>initialValue()</code>该方法，则没问题</li><li>ThreadLocal的适用场景为无状态且副本变量独立后不影响业务逻辑的高并发场景。</li></ul><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://www.jianshu.com/p/807686414c11" target="_blank" rel="noopener">JAVA并发-自问自答学ThreadLocal</a></p><p><a href="https://juejin.im/post/5c72805651882562276c49d6" target="_blank" rel="noopener">ThreadLocal解析</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler机制源码解析(二)</title>
    <link href="/2018/10/07/Handler%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C/"/>
    <url>/2018/10/07/Handler%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="主要包括Handler其他使用知识点"><a href="#主要包括Handler其他使用知识点" class="headerlink" title="主要包括Handler其他使用知识点"></a>主要包括Handler其他使用知识点</h1><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Handler拓展知识点.png" srcset="/img/loading.gif" class="full-image" alt="Handler拓展知识点" title="Handler拓展知识点"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="1-子线程创建Handler对象"><a href="#1-子线程创建Handler对象" class="headerlink" title="1. 子线程创建Handler对象"></a>1. 子线程创建Handler对象</h2><blockquote><p>不可以直接在子线程创建Handler对象，因为Handler对象必须要绑定一个Looper，才可以使用。</p><p>若在子线程需要使用Handler，则需要先创建一个Looper对象即执行<code>Looper.prepare()</code>然后再创建Handler对象时调用<code>Looper.myLooper()</code>获取Looper对象传入方法，最后调用<code>Looper.loop()</code>开始运行。</p></blockquote><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> : <span class="hljs-type">Activity&#123;</span></span>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mThread: MyThread    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mHandler: MyHandler        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)        setContentView(R.layout.act_main)        <span class="hljs-comment">//初始化子线程</span>        mThread = Mythread()        mThread.start()        <span class="hljs-comment">//需要发出的消息</span>        <span class="hljs-keyword">val</span> message = Message.obtain()        message.obj = <span class="hljs-string">"test"</span>        <span class="hljs-comment">//初始化Handler</span>        mHandler = MyHandler(<span class="hljs-keyword">this</span>, mThread.childLooper)        <span class="hljs-comment">//发送消息</span>        mHandler.sendMessage(message)    &#125;        <span class="hljs-comment">//子线程</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> : <span class="hljs-type">Thread</span></span>() &#123;        <span class="hljs-keyword">var</span> childLooper: Looper? = <span class="hljs-literal">null</span>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;            Looper.prepare()            childLooper = Looper.myLooper()            Looper.loop()        &#125;    &#125;        <span class="hljs-comment">//安全的Handler写法</span>     <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandler</span></span>(activity: MyActivity, looper: Looper?) : Handler(looper) &#123;        <span class="hljs-keyword">var</span> mWeakRe: WeakReference&lt;MyActivity&gt; = WeakReference(activity)        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>?)</span></span> &#123;            <span class="hljs-keyword">super</span>.handleMessage(msg)            <span class="hljs-keyword">val</span> activity: MyActivity? = mWeakRe.<span class="hljs-keyword">get</span>()            <span class="hljs-keyword">if</span> (activity!=<span class="hljs-literal">null</span>)&#123;                <span class="hljs-comment">//添加handlerMessage需要处理的逻辑</span>            &#125;        &#125;    &#125;&#125;</code></pre><p>以上代码执行完毕后就可以在子线程调用Handler对象。</p><p><strong>但是，在多次执行过程中，会有<font color="red">java.lang.NullPointerException: Attempt to read from field ‘android.os.MessageQueue android.os.Looper.mQueue’ on a null object reference</font>空指针导致应用崩溃。</strong>调试过程中发现是由于Looper对象为空导致的异常。由于<strong>在子线程<code>run()</code>初始化了Looper对象，Handler对象的初始化依然继续执行，Looper对象此时尚未初始化好，导致空指针异常。</strong></p><p>由于这种情况的出现是随机的，不是百分百重现，为了保证应用的运行就需要引入<code>HandlerThread</code>这个类，可以帮我们解决这个问题。</p><pre><code class="hljs kotlin"><span class="hljs-comment">//HandlerThread示例代码</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> : <span class="hljs-type">Activity&#123;</span></span>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mHandler: MyHandler    <span class="hljs-keyword">var</span> mHandlerThread: HandlerThread?=<span class="hljs-literal">null</span>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)        setContentView(R.layout.act_main)        <span class="hljs-comment">//初始化HandlerThread并指定线程名字为test</span>        mHandlerThread = HandlerThread(<span class="hljs-string">"test"</span>,Process.THREAD_PRIORITY_BACKGROUND)        mHandlerThread?.start()        <span class="hljs-comment">//需要发出的消息</span>        <span class="hljs-keyword">val</span> message = Message.obtain()        message.obj = <span class="hljs-string">"test"</span>        <span class="hljs-comment">//初始化Handler</span>        mHandler = MyHandler(<span class="hljs-keyword">this</span>, mHandlerThread?.looper)        <span class="hljs-comment">//发送消息</span>        mHandler.sendMessage(message)    &#125;        <span class="hljs-comment">//安全的Handler写法</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandler</span></span>(activity: MyActivity, looper: Looper?) : Handler(looper) &#123;        <span class="hljs-keyword">var</span> mWeakRe: WeakReference&lt;MyActivity&gt; = WeakReference(activity)        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>?)</span></span> &#123;            <span class="hljs-keyword">super</span>.handleMessage(msg)            <span class="hljs-keyword">val</span> activity: MyActivity? = mWeakRe.<span class="hljs-keyword">get</span>()            <span class="hljs-keyword">if</span> (activity!=<span class="hljs-literal">null</span>)&#123;                <span class="hljs-comment">//添加handlerMessage需要处理的逻辑</span>            &#125;        &#125;    &#125;        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">super</span>.onDestroy()        <span class="hljs-comment">//结束时停止thread</span>        mHandlerThread?.quit()    &#125;&#125;</code></pre><p>以上代码执行完毕后即在HandlerThread可以调用Handler对象。</p><p>我们需要从源码去分析为什么使用<code>HandlerThread</code>可以避免上述异常，是怎样一个机制实现的。</p><pre><code class="hljs java"><span class="hljs-comment">// 源码位置:../core/java/android/os/HandlerThread.java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    ...     <span class="hljs-comment">//设置线程优先级 优先级主要分为UI线程和后台线程(Background)</span>    <span class="hljs-keyword">int</span> mPriority;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HandlerThread</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">super</span>(name);        <span class="hljs-comment">//默认标准App线程优先级</span>        mPriority = Process.THREAD_PRIORITY_DEFAULT;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HandlerThread</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> priority)</span> </span>&#123;        <span class="hljs-keyword">super</span>(name);        mPriority = priority;    &#125;        <span class="hljs-comment">//可以重写这个方法，在内部新建Handler对象</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLooperPrepared</span><span class="hljs-params">()</span> </span>&#123;    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//获取到线程ID</span>        mTid = Process.myTid();        <span class="hljs-comment">//创建对应的Looper，MessageQueue对象</span>        Looper.prepare();        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">//对mLooper进行赋值</span>            mLooper = Looper.myLooper();            <span class="hljs-comment">//唤醒等待Looper赋值而阻塞的所有线程</span>            notifyAll();        &#125;        Process.setThreadPriority(mPriority);        onLooperPrepared();        Looper.loop();        mTid = -<span class="hljs-number">1</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> Looper <span class="hljs-title">getLooper</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//判断当前线程是否存活 关闭则返回空</span>        <span class="hljs-keyword">if</span> (!isAlive()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;                <span class="hljs-comment">// If the thread has been started, wait until the looper has been created.</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">//mLooper==null表明当前Looper对象尚未初始化</span>            <span class="hljs-keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//调用线程等待 直至初始化完成 阻塞其他线程</span>                    wait();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                &#125;            &#125;        &#125;        <span class="hljs-comment">//返回Looper对象</span>        <span class="hljs-keyword">return</span> mLooper;    &#125;        <span class="hljs-comment">//内嵌一个可以直接引用的Handler对象，外部可以直接使用</span>    <span class="hljs-meta">@NonNull</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Handler <span class="hljs-title">getThreadHandler</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (mHandler == <span class="hljs-keyword">null</span>) &#123;            mHandler = <span class="hljs-keyword">new</span> Handler(getLooper());        &#125;        <span class="hljs-keyword">return</span> mHandler;    &#125;        <span class="hljs-comment">//HandlerThread退出 同步于Looper.quit()</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">quit</span><span class="hljs-params">()</span> </span>&#123;        Looper looper = getLooper();        <span class="hljs-keyword">if</span> (looper != <span class="hljs-keyword">null</span>) &#123;            looper.quit();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;        <span class="hljs-comment">//HandlerThread退出 同步于Looper.quitSafely()</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">quitSafely</span><span class="hljs-params">()</span> </span>&#123;        Looper looper = getLooper();        <span class="hljs-keyword">if</span> (looper != <span class="hljs-keyword">null</span>) &#123;            looper.quitSafely();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p>总结：</p><ul><li><code>HandlerThread</code>内嵌了Handler,Looper,MessageQueue对象</li><li><code>HandlerThread</code>内部使用<code>wait(),notifyAll()</code>等线程同步方式保证<code>mLooper</code>对象不会为空，<code>wait()</code>当Looper对象尚未初始化完成时阻塞其他线程，<code>notifyAll()</code>当mLooper对象不为空时，通知其他线程使用mLooper。</li></ul><h2 id="2-IdleHandler"><a href="#2-IdleHandler" class="headerlink" title="2. IdleHandler"></a>2. IdleHandler</h2><blockquote><p>当Looper里面的Message暂时处理完毕即<strong>全部消息处理完毕或者阻塞等待新消息</strong>时会调用<code>IdleHandler</code>这个类去处理一些空闲时间的消息。</p><p>继承<code>IdleHandler</code>这个接口，需要设置<code>queueIdle()</code>的返回值。若返回<code>false</code>则调用一次后会移除，为<code>true</code>则继续持有，空闲时依然会调用。</p><p>概括就是：<strong>优先级别较低的<code>Message</code>，只有当<code>Looper</code>中没有消息要处理时，才会去处理<code>IdleHandler</code>。</strong></p></blockquote><pre><code class="hljs kotlin"><span class="hljs-comment">//使用示例代码</span><span class="hljs-keyword">val</span> message = Message.obtain()message.obj = <span class="hljs-string">"1234"</span>handler.sendMessage(message)<span class="hljs-keyword">val</span> delayMessage=Message.obtain()delayMessage.obj=<span class="hljs-string">"12344"</span>handler.sendMessageDelayed(delayMessage,<span class="hljs-number">3000</span>)<span class="hljs-comment">//子线程添加IdleHandler 限制API23以上使用</span>mHandlerThread?.looper?.queue?.addIdleHandler(OnceIdleHandler())mHandlerThread?.looper?.queue?.addIdleHandler(ForeverIdleHandler())<span class="hljs-comment">//主线程添加IdleHandler</span>Looper.myQueue().addIdleHandler(OnceIdleHandler())Looper.myQueue().addIdleHandler(ForeverIdleHandler())<span class="hljs-comment">//只使用一次的IdleHandler</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnceIdleHandler</span> : <span class="hljs-type">MessageQueue.IdleHandler &#123;</span></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queueIdle</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;        LogUtils.e(<span class="hljs-string">"idle once"</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;&#125;<span class="hljs-comment">//一直持续存在的IdleHandler</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForeverIdleHandler</span> : <span class="hljs-type">MessageQueue.IdleHandler &#123;</span></span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queueIdle</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;        LogUtils.e(<span class="hljs-string">"idle forever"</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;&#125;<span class="hljs-comment">//需要移除IdleHandler 调用</span> Looper.myQueue().removeIdleHandler(OnceIdleHandler()) Looper.myQueue().removeIdleHandler(ForeverIdleHandler())</code></pre><p>集成上述代码即可测试IdleHandler的使用，接下来要分析源码的实现以及使用场景。</p><pre><code class="hljs java"><span class="hljs-comment">// 源码位置:../core/java/android/os/MessageQueue.java</span>   <span class="hljs-comment">/**     * IdleHandler定义     * Callback interface for discovering when a thread is going to block     * waiting for more messages.     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IdleHandler</span> </span>&#123;        <span class="hljs-comment">/**         * Called when the message queue has run out of messages and will now         * wait for more.  Return true to keep your idle handler active, false         * to have it removed.  This may be called if there are still messages         * pending in the queue, but they are all scheduled to be dispatched         * after the current time.         */</span>        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">queueIdle</span><span class="hljs-params">()</span></span>;    &#125;   <span class="hljs-comment">//mIdleHandlers 是ArrayList型 故可以重复添加</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="hljs-keyword">new</span> ArrayList&lt;IdleHandler&gt;();   <span class="hljs-comment">//往MessageQueue中添加一个IdleHandler对象</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addIdleHandler</span><span class="hljs-params">(@NonNull IdleHandler handler)</span> </span>&#123;        <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"Can't add a null IdleHandler"</span>);        &#125;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">//添加IdleHandler是线程安全的 </span>            mIdleHandlers.add(handler);        &#125;    &#125;       <span class="hljs-comment">//移除一个IdleHandler</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeIdleHandler</span><span class="hljs-params">(@NonNull IdleHandler handler)</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            mIdleHandlers.remove(handler);        &#125;    &#125;    <span class="hljs-comment">//调用上述方法往mIdleHandlers添加或移除IdleHandler对象后 需要在next()方法中 去使用mIdleHandlers中的对象</span>   <span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-comment">//无限循环</span>       <span class="hljs-keyword">for</span>(;;)&#123;           ...                <span class="hljs-comment">// If first time idle, then get the number of idlers to run.</span>                <span class="hljs-comment">// Idle handles only run if the queue is empty or if the first message</span>                <span class="hljs-comment">// in the queue (possibly a barrier) is due to be handled in the future.</span>                <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span>                        &amp;&amp; (mMessages == <span class="hljs-keyword">null</span> || now &lt; mMessages.when)) &#123;                    pendingIdleHandlerCount = mIdleHandlers.size();                &#125;                <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">// 判断当前没有空闲线程可执行 则继续堵塞</span>                    mBlocked = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-keyword">null</span>) &#123;                    mPendingIdleHandlers = <span class="hljs-keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];                &#125;                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);       &#125;              <span class="hljs-comment">// Run the idle handlers.</span>            <span class="hljs-comment">// We only ever reach this code block during the first iteration.</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                <span class="hljs-keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];                mPendingIdleHandlers[i] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// release the reference to the handler</span>                <span class="hljs-keyword">boolean</span> keep = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//获取继承接口定义的queueIdle()返回值 判定后续是否需要继续执行</span>                    keep = idler.queueIdle();                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;                    Log.wtf(TAG, <span class="hljs-string">"IdleHandler threw exception"</span>, t);                &#125;                <span class="hljs-keyword">if</span> (!keep) &#123;                    <span class="hljs-comment">//不需要继续执行 则自动移除对象</span>                    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                        mIdleHandlers.remove(idler);                    &#125;                &#125;            &#125;   &#125;</code></pre><h2 id="3-Handler常见问题"><a href="#3-Handler常见问题" class="headerlink" title="3. Handler常见问题"></a>3. Handler常见问题</h2><h3 id="1-消息机制中的主要引用对象及其关系"><a href="#1-消息机制中的主要引用对象及其关系" class="headerlink" title="1. 消息机制中的主要引用对象及其关系"></a>1. 消息机制中的主要引用对象及其关系</h3><blockquote><p><code>Looper ，MessageQueue，Message，ThreadLocal，Handler</code></p></blockquote><ol><li>Looper对象有一个MessageQueue,MessgaeQueue为一个消息队列来存储Message</li><li>Message中带有一个Handler对象，从Looper中取出消息后，可以直接调用到Handler的相关方法</li><li>Handler发送消息时会把自身封装进Message  <code>Message.ontain(Handler h ,int what,int arg1,int arg2,Object onj)</code></li><li>Handler通过获取Looper对象中的MessageQueue插入消息来发送Message</li><li>Looper创建对象时会把自己保存至ThreadLocal中，并提供一个<code>public static Looper myLooper()</code>方法来返回一个Looper对象</li></ol><h3 id="2-Android主线程不会因为Looper-loop-死循环卡死"><a href="#2-Android主线程不会因为Looper-loop-死循环卡死" class="headerlink" title="2. Android主线程不会因为Looper.loop()死循环卡死"></a>2. Android主线程不会因为<code>Looper.loop()</code>死循环卡死</h3><p>简单来说就是<strong>循环里有阻塞<code>阻塞的原理是利用Linux的管道机制(PIPE/EPOLL)机制实现</code>，所以死循环不会一直执行，由于大部分时间都是没有消息的，所以主线程大部分处于休眠状态，也不会过度消耗CPU资源导致卡死。</strong></p><p>先说明进程和线程的区别：</p><blockquote><p><strong>进程</strong>：每个app运行时首先会创建一个进程，该进程是由zygote fork出来的，用于承载运行app上的Activity/Service等组件。进程对于上层应用来说是完全透明的，目的是为了<code>让App都运行在Android Runtimr</code>。大多数情况下一个App运行在一个线程中，除非配置了<code>Android:Process</code>属性，或者通过native fork 进程。</p><p><strong>线程</strong>：线程比较常见，每次<code>new Thread().start()</code>都会创建一个新线程。并且与当前App所在进程之间资源共享。<code>在CPU看来进程或线程无非是一段可执行的代码，CPU采用CFS调度算法，保证每个task尽可能公平享有CPU时间片</code>。</p><p>拓展知识：CFS调度算法是一种完全公平调度算法，基本设计思路是根据各个进程的权重来分配运行时间**。</p></blockquote><p>当进入死循环时又该如何处理其他事务呢？<strong>需要创建新的线程去处理</strong>。</p><p>主线程进入Looper的死循环后，需要处理 activity的各个生命周期的回调函数执行(<code>在同一个线程下，代码是按顺序执行的，如果死循环堵塞了，后续该如何执行</code>)。</p><pre><code class="hljs java"><span class="hljs-comment">//源码地址 android/app/ActivityThread.java </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    ...    <span class="hljs-comment">//Looper初始化</span>    Looper.prepareMainLooper();    <span class="hljs-comment">//new 一个ActivityThread并调用了attach方法</span>    ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();    thread.attach(<span class="hljs-keyword">false</span>);    <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;        sMainThreadHandler = thread.getHandler();    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>) &#123;       Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span>             LogPrinter(Log.DEBUG, <span class="hljs-string">"ActivityThread"</span>));       &#125;       <span class="hljs-comment">// End of event ActivityThreadMain.</span>       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);       Looper.loop();       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Main thread loop unexpectedly exited"</span>);&#125;</code></pre><p>源码中在初始化ActivityThread时也会初始化一个<code>H类型的成员，它继承了Handler</code>。</p><p>源码中调用<code>thread.attach(false)</code>时,<strong>回去创建一个Binder进程（具体代指ApplicationThread,Binder的服务端，用于接收系统AMS发出来的事件），由Handler线程发送Message至主线程。</strong></p><p>所以在主线程开启Looper死循环之前，就已经启动了一个Binder线程并且准备了<code>H 这一个Handler类</code>，就可以用于处理一些死循环之外的事务。<code>仅需通过Binder线程向H发送消息即可</code>。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/activity_binder.png" srcset="/img/loading.gif" class="full-image" alt="App运行过程" title="App运行过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><strong>system_server进程即为系统进程</strong>，里面运行了大量的系统服务，比如上图提供了<code>ApplicationThreadProxy以及ActivityManagerService</code>，这两者都基于IBinder接口，都是Binder线程。</p><p><strong>App进程即为我们常说的应用程序</strong>，主线程主要负责Activity等组件的生命周期以及UI绘制。每个App进程中至少会包括两个binder线程:<code>ApplicationThread和ActivityManagerProxy</code>。</p><p><strong>Binder用于不同进程间的通信，由一个进程的Binder客户端向另一个进程的服务端发送事务。</strong></p><p><strong>Handler则用于同一进程间不同线程的通信。</strong></p><h3 id="3-主线程的消息模型"><a href="#3-主线程的消息模型" class="headerlink" title="3.主线程的消息模型"></a>3.主线程的消息模型</h3><p>上图中绘制出主线程(ActivityThread)是如何循环的,简单的文字表达就是</p><blockquote><p><code>ActivityManagerService(AMS)</code> ==直接调用==&gt;<code>ApplicationThreadProxy(ATP)</code>==Binder==&gt;<code>ApplicationThread</code>==Handler方式==&gt;<code>ActivityThread</code></p><p>主线程(ActivityThread)通过<code>ApplicationThread</code>和<code>ActivityManagerService</code>进行进程间通信，AMS以进程间通信的方式完成<code>ActivityThread</code>的请求后回调<code>ApplicationThread</code>中的Binder方法。然后由<code>ApplicationThread</code>向<code>ActivityThread</code>中的<code>H</code>发送消息，然后收到消息后 把处理逻辑发送至<code>ActivityThread</code>中去执行。</p></blockquote><h3 id="4-Message的触发统计"><a href="#4-Message的触发统计" class="headerlink" title="4.Message的触发统计"></a>4.Message的触发统计</h3><blockquote><p>Message是在MessageQueue中进行存放，事件的分发需要通过Looper.next()从<code>MessageQueue</code>中获取Message，<code>BlockCanary</code>就是通过计算事件分发的时间间隔来判断当前是否出现卡顿。</p></blockquote><p>可以通过给Handler中的Looper对象设置<code>setMessageLogging()</code>，对事件的分发进行监听。</p><pre><code class="hljs java">Looper.getMainLooper().setMessageLogging(<span class="hljs-keyword">new</span> Printer()&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span></span>&#123;    <span class="hljs-comment">//x 包含了以下内容  Message.target Message.callback  Message.what</span>  &#125;&#125;)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Study-Plan-动态权限</title>
    <link href="/2018/08/26/Android-Study-Plan-%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/"/>
    <url>/2018/08/26/Android-Study-Plan-%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Study-Plan-XX</title>
    <link href="/2018/06/25/Android-Study-Plan-XX/"/>
    <url>/2018/06/25/Android-Study-Plan-XX/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><h2 id="大尺寸图片加载问题：给定一个1000px-2000px的大图，如何进行正常加载且不会导致OOM。"><a href="#大尺寸图片加载问题：给定一个1000px-2000px的大图，如何进行正常加载且不会导致OOM。" class="headerlink" title="大尺寸图片加载问题：给定一个1000px*2000px的大图，如何进行正常加载且不会导致OOM。"></a>大尺寸图片加载问题：给定一个1000px*2000px的大图，如何进行正常加载且不会导致OOM。</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Study-Plan-XIX</title>
    <link href="/2018/06/12/Android-Study-Plan-XIX/"/>
    <url>/2018/06/12/Android-Study-Plan-XIX/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><h2 id="AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。"><a href="#AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。" class="headerlink" title="AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。"></a>AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-动画分析</title>
    <link href="/2018/06/11/Android-%E5%8A%A8%E7%94%BB%E5%88%86%E6%9E%90/"/>
    <url>/2018/06/11/Android-%E5%8A%A8%E7%94%BB%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Android的动画就可以分为3种：</p><ul><li>View动画 <code>View Animation</code></li><li>帧动画 <code>Drawable Animation</code></li><li>属性动画 <code>Property Animation</code></li></ul></blockquote><h2 id="1-View动画"><a href="#1-View动画" class="headerlink" title="1.View动画"></a>1.View动画</h2><blockquote><p>View动画的作用对象是View。<strong>View动画的View移动只是视觉效果，并不能真正的改变位置。</strong></p></blockquote><h3 id="View动画的种类"><a href="#View动画的种类" class="headerlink" title="View动画的种类"></a>View动画的种类</h3><table><thead><tr><th>种类</th><th>标签</th><th>子类</th><th>效果</th></tr></thead><tbody><tr><td>平移动画</td><td><code>&lt;translate&gt;</code></td><td>TranslateAnimation</td><td>平移View</td></tr><tr><td>缩放动画</td><td><code>&lt;scale&gt;</code></td><td>ScaleAnimation</td><td>放大或者缩小View</td></tr><tr><td>旋转动画</td><td><code>&lt;rotate&gt;</code></td><td>RotateAnimation</td><td>旋转View</td></tr><tr><td>透明度动画</td><td><code>&lt;alpha&gt;</code></td><td>AlphaAnimation</td><td>View的透明度变化</td></tr></tbody></table><h3 id="使用View动画"><a href="#使用View动画" class="headerlink" title="使用View动画"></a>使用View动画</h3><p>要使用View动画，需要先创建动画的XML文件，这个文件的路径为<code>res/anim/animateFile.xml</code>。</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:interpolator</span>=<span class="hljs-string">""</span>    <span class="hljs-attr">android:shareInterpolator</span>=<span class="hljs-string">"[true | false]"</span>    <span class="hljs-attr">android:fillAfter</span>=<span class="hljs-string">"true"</span>    <span class="hljs-attr">android:duration</span>=<span class="hljs-string">'integar'</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">translate</span>        <span class="hljs-attr">android:fromXDelta</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:toXDelta</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:fromYDelta</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:toYDelta</span>=<span class="hljs-string">"float"</span>/&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">scale</span>        <span class="hljs-attr">android:fromXScale</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:toXScale</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:fromYScale</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:toYScale</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">"float"</span>/&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">rotate</span>        <span class="hljs-attr">android:fromDegrees</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:toDegrees</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">"float"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">alpha</span>         <span class="hljs-attr">android:fromAlpha</span>=<span class="hljs-string">"float"</span>        <span class="hljs-attr">android:toAlpha</span>=<span class="hljs-string">"float"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre><p><em>View动画既可以是单个动画，也可以由一系列动画组成。</em></p><p><code>&lt;set&gt;</code>：表示动画集合，对应<code>AnimationSet</code>，可以包含若干个动画，并且内部也可以嵌套其他动画集合。</p><ul><li><code>android:interpolator</code>：表示动画集合所采用的插值器，插值器会影响到动画的速度。</li><li><code>android:shareInterpolator</code>：是否共享插值器。<em>如果不指定，子动画就需要单独指定插值器或者使用默认值。</em></li><li><code>android:fillAfter</code>：表示动画结束时是否保持动画结束的状态。<code>false</code>回到动画初始样式</li><li><code>android:integar</code>：表示动画持续时长</li></ul><p><code>&lt;translate&gt;</code>：表示平移动画，对应<code>TranslateAnimation</code></p><ul><li><code>android:fromXDelta</code>：动画起始时X坐标上的位置。</li><li><code>android:toXDelta</code>：动画结束时X坐标上的位置。</li><li><code>android:fromYDelta</code>：动画起始时Y坐标上的位置。</li><li><code>android:toYDelta</code>：动画结束时Y坐标上的位置。</li></ul><blockquote><p>以上4个属性的取值可能为<code>数值，百分数，百分数P</code>，他们的含义有所区别：</p><p><code>数值</code>： 50 –&gt; 以View左上角为原点，向正方向偏移50px</p><p><code>百分数</code> 50% –&gt; 以View左上角为原点，向正方向偏移View宽/高的50%</p><p><code>百分数P</code> 50%P -&gt; 以View左上角为原点，向正方向偏移父布局(parent)宽/高的50%；</p></blockquote><p><code>&lt;scale&gt;</code>：表示缩放动画，对应<code>ScaleAnimation</code></p><ul><li><code>android:fromXScale</code>动画起始时水平方向伸缩值。 </li><li><code>android:toXScale</code>：动画结束时水平方向伸缩值。</li><li><code>android:fromYScale</code>：动画起始时竖直方向伸缩值。</li><li><code>android:toYScale</code>：动画结束时水平方向伸缩值。</li></ul><blockquote><p>以上4个属性的取值有不同的含义</p><p><code>值为0.0</code>  缩放比为0  代表缩放到原来的0 即消失</p><p><code>值&lt;1.0</code>  缩放比小于1 代表缩小</p><p><code>值为1.0</code> 缩放比等于1 代表与原来相同</p><p><code>值&gt;1.0</code> 缩放比大于1 代表放大</p></blockquote><ul><li><code>android:pivotX</code>：缩放轴点的X坐标。</li><li><code>android:pivotY</code>：缩放轴点的Y坐标。</li></ul><blockquote><p>以上两个属性表示 ，缩放的起始坐标，<strong>取值为%</strong>，<em>默认View的中心点，即50%,50%</em>。举个例子：如果<code>pivotX和pivotY</code>设置为0，即为左上角坐标，缩放时就是以左上角为原点向外向内。</p></blockquote><p><code>&lt;rotate&gt;</code>：表示旋转动画，对应<code>RotateAnimation</code></p><ul><li><code>android:fromDegrees</code>：动画起始时旋转的角度 。</li><li><code>android:toDegrees</code>：动画结束时旋转的角度。</li></ul><blockquote><p>以上两个属性共同确定旋转方向，原则是：当角度为<strong>负</strong>数时表示<strong>逆时针</strong>旋转，反之。</p><p>故共存在以下四种情况： </p><ul><li>from=负数 -&gt; to=正数：表示顺时针旋转</li><li>from=负数 -&gt;to =负数：表示逆时针旋转</li><li>from=正数 -&gt;to =正数：表示顺时针旋转</li><li>from=正数 -&gt;to=负数：表示逆时针旋转</li></ul></blockquote><ul><li><code>android:pivotX</code>：旋转轴点的X坐标。</li><li><code>android:pivotY</code>：旋转轴点的Y坐标。</li></ul><p><code>&lt;alpha&gt;</code>：表示透明度动画，对应<code>AlphaAnimation</code></p><ul><li><code>android:fromAlpha</code>：动画起始时透明度。</li><li><code>android:toAlpha</code>动画结束时透明度。</li></ul><blockquote><p>以上两个属性取值范围为 0~1</p><p><code>值&lt;=0</code> 代表完全透明</p><p><code>值&gt;=1</code> 代表完全不透明</p></blockquote><h3 id="应用代码"><a href="#应用代码" class="headerlink" title="应用代码"></a>应用代码</h3><blockquote><p>通过XML文件构建</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- animationset.xml --&gt;</span><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:shareInterpolator</span>=<span class="hljs-string">"true"</span> &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">translate</span>        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"2000"</span>        <span class="hljs-attr">android:fromXDelta</span>=<span class="hljs-string">"0"</span>        <span class="hljs-attr">android:fromYDelta</span>=<span class="hljs-string">"0"</span>        <span class="hljs-attr">android:toXDelta</span>=<span class="hljs-string">"100%"</span>        <span class="hljs-attr">android:toYDelta</span>=<span class="hljs-string">"100%"</span>&gt;</span> /&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">scale</span>       <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"2000"</span>       <span class="hljs-attr">android:fromXScale</span>=<span class="hljs-string">"1.0"</span>       <span class="hljs-attr">android:fromYScale</span>=<span class="hljs-string">"1.0"</span>       <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">"50%"</span>       <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">"50%"</span>       <span class="hljs-attr">android:toXScale</span>=<span class="hljs-string">"0.5"</span>       <span class="hljs-attr">android:toYScale</span>=<span class="hljs-string">"0.5"</span> /&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">rotate</span>        <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"2000"</span>        <span class="hljs-attr">android:fromDegrees</span>=<span class="hljs-string">"0"</span>        <span class="hljs-attr">android:toDegrees</span>=<span class="hljs-string">"360"</span>        <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">"50%"</span>        <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">"50%"</span>/&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">alpha</span>       <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"2000"</span>       <span class="hljs-attr">android:fromAlpha</span>=<span class="hljs-string">"1.0"</span>       <span class="hljs-attr">android:toAlpha</span>=<span class="hljs-string">"0"</span>/&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre><pre><code class="hljs java">Animation animation = AnimationUtils.loadAnimation(<span class="hljs-keyword">this</span>,R.anim.animationet);view.startAnimation(animation);animation.setAnimationListener(<span class="hljs-keyword">new</span> AnimationListener()&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationStart</span><span class="hljs-params">(Animation animation)</span></span>&#123;    <span class="hljs-comment">//动画开始</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationEnd</span><span class="hljs-params">(Animation animation)</span></span>&#123;    <span class="hljs-comment">//动画结束</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAnimationRepeat</span><span class="hljs-params">(Animation animation)</span></span>&#123;    <span class="hljs-comment">//动画重复 设置 android:repeatMode="[restart | reverse]" 时触发</span>  &#125;&#125;)</code></pre><blockquote><p>通过Java构建</p></blockquote><pre><code class="hljs java">AlphaAnimation alphaAnimation = <span class="hljs-keyword">new</span> AlphaAnimation(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);alphaAnimation.setDuration(<span class="hljs-number">2000</span>);AnimationSet animationSet = <span class="hljs-keyword">new</span> AnimationSet(<span class="hljs-keyword">true</span>);animationSet.addAnimation(alphaAnimation);view.startAnimation(animationSet);</code></pre><h3 id="自定义View动画"><a href="#自定义View动画" class="headerlink" title="自定义View动画"></a>自定义View动画</h3><blockquote><p>自定义View动画是为了 实现系统提供的无法满足的动画情况，例如<code>3D翻转效果</code>，无法简单组合就能实现，就需要用到自定义View动画。</p></blockquote><p>实现步骤：<code>继承Animation -&gt; 重写initialize()以及applyTransformation()方法</code></p><ul><li><code>inltialize()</code>：初始化工作</li><li><code>allpyTransformation()</code>：进行相应的矩阵变换</li></ul><h4 id="自定义View动画实例"><a href="#自定义View动画实例" class="headerlink" title="自定义View动画实例"></a>自定义View动画实例</h4><p>TODO</p><h3 id="View动画特殊使用场景"><a href="#View动画特殊使用场景" class="headerlink" title="View动画特殊使用场景"></a>View动画特殊使用场景</h3><h4 id="1-LayoutAnimation"><a href="#1-LayoutAnimation" class="headerlink" title="1. LayoutAnimation"></a>1. LayoutAnimation</h4><blockquote><p>作用于ViewGroup，为ViewGroup指定一个动画，当它的子元素出场时都会具有这样的效果。</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">layoutAnimation</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>                 <span class="hljs-attr">android:delay</span>=<span class="hljs-string">""</span>                 <span class="hljs-attr">android:animationOrder</span>=<span class="hljs-string">""</span>                 <span class="hljs-attr">android:animation</span>=<span class="hljs-string">""</span> /&gt;</span></code></pre><p><code>android:delay</code>：表示子元素开始动画的延迟时间。</p><blockquote><p>比如，设置子元素入场动画的周期为 300ms，delay设置为0.5意味着，每个子元素都需要延迟150ms播放动画</p></blockquote><p><code>android:animationOrder</code> ：表示子元素动画的顺序</p><ul><li>normal 正序显示，按照排列顺序播放</li><li>random 随机显示</li><li>reverse 逆序显示</li></ul><p><code>android:animation</code>：表示设置的子元素动画</p><h5 id="应用代码-1"><a href="#应用代码-1" class="headerlink" title="应用代码"></a>应用代码</h5><blockquote><p>XML定义</p></blockquote><pre><code class="hljs xml">// anim_layout.xml<span class="hljs-tag">&lt;<span class="hljs-name">layoutAnimation</span>     <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:animation</span>=<span class="hljs-string">"@anim/anim_layout_item"</span>    <span class="hljs-attr">android:delay</span>=<span class="hljs-string">"0.5"</span>    <span class="hljs-attr">android:animationOrder</span>=<span class="hljs-string">"normal"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">layoutAnimation</span>&gt;</span>//anim_layout_item.xml<span class="hljs-tag">&lt;<span class="hljs-name">set</span>     <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span>    <span class="hljs-attr">android:shareInterpolator</span>=<span class="hljs-string">"true"</span>    <span class="hljs-attr">android:interpolator</span>=<span class="hljs-string">"@android:anim/accelerate_interpolator"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">alpha</span>        <span class="hljs-attr">android:fromAlpha</span>=<span class="hljs-string">"0"</span>        <span class="hljs-attr">android:toAlpha</span>=<span class="hljs-string">"1"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scale</span>        <span class="hljs-attr">android:fromXScale</span>=<span class="hljs-string">"1"</span>        <span class="hljs-attr">android:toXScale</span>=<span class="hljs-string">"0"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ListView</span>           <span class="hljs-attr">android:layoutAnimation</span> =<span class="hljs-string">"@anim/anim_layout"</span> /&gt;</span></code></pre><blockquote><p>Java代码生成</p></blockquote><pre><code class="hljs java">Animation animation = AnimationUtils.loadLayoutAnimation(<span class="hljs-keyword">this</span>, R.anim.anim_item);        LayoutAnimationController controller = <span class="hljs-keyword">new</span> LayoutAnimationController(animation);<span class="hljs-comment">//对应android:animation属性</span>        controller.setDelay(<span class="hljs-number">0.5</span>);<span class="hljs-comment">//对应android:delay属性      </span>        controller.setOrder(LayoutAnimationController.ORDER_NORMAL);<span class="hljs-comment">//对应android:animationOrder属性</span>        listView.setLayoutAnimation(controller);<span class="hljs-comment">//对应android:layoutAnimation属性</span></code></pre><h4 id="2-Activity切换效果"><a href="#2-Activity切换效果" class="headerlink" title="2.Activity切换效果"></a>2.Activity切换效果</h4><blockquote><p>Activity有默认的切换效果，是由系统自己定义的。需要自定义切换效果就需要用到<code>oberridePendingTransition(int inAnim,int outAnim)</code></p></blockquote><pre><code class="hljs xml">// enter_anim.xml<span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>          <span class="hljs-attr">android:interpolator</span>=<span class="hljs-string">"@android:anim/decelerate_interpolator"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">scale</span> <span class="hljs-attr">android:fromXScale</span>=<span class="hljs-string">"2.0"</span> <span class="hljs-attr">android:toXScale</span>=<span class="hljs-string">"1.0"</span>             <span class="hljs-attr">android:fromYScale</span>=<span class="hljs-string">"2.0"</span> <span class="hljs-attr">android:toYScale</span>=<span class="hljs-string">"1.0"</span>             <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">"50%p"</span> <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">"50%p"</span>             <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"@android:integer/config_mediumAnimTime"</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>  //exit_anim.xml<span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>          <span class="hljs-attr">android:interpolator</span>=<span class="hljs-string">"@android:anim/decelerate_interpolator"</span>          <span class="hljs-attr">android:zAdjustment</span>=<span class="hljs-string">"top"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">scale</span> <span class="hljs-attr">android:fromXScale</span>=<span class="hljs-string">"1.0"</span> <span class="hljs-attr">android:toXScale</span>=<span class="hljs-string">".5"</span>             <span class="hljs-attr">android:fromYScale</span>=<span class="hljs-string">"1.0"</span> <span class="hljs-attr">android:toYScale</span>=<span class="hljs-string">".5"</span>             <span class="hljs-attr">android:pivotX</span>=<span class="hljs-string">"50%p"</span> <span class="hljs-attr">android:pivotY</span>=<span class="hljs-string">"50%p"</span>             <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"@android:integer/config_mediumAnimTime"</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">alpha</span> <span class="hljs-attr">android:fromAlpha</span>=<span class="hljs-string">"1.0"</span> <span class="hljs-attr">android:toAlpha</span>=<span class="hljs-string">"0"</span>              <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"@android:integer/config_mediumAnimTime"</span>/&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></code></pre><pre><code class="hljs java">Intent intent =<span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,AnimActivity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;startActivityIntent(intent);overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);<span class="hljs-comment">//退出时设置</span>finish();overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);</code></pre><p><strong>该方法必须在<code>startActivity()</code>或者<code>finish()</code>之后调用才生效。</strong></p><h2 id="2-帧动画"><a href="#2-帧动画" class="headerlink" title="2.帧动画"></a>2.帧动画</h2><blockquote><p>帧动画是顺序播放一组预先定义好的图片，对应<code>AnimationDrawable</code></p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">animation-list</span>  <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:oneshot</span>=<span class="hljs-string">"[true | false]"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">""</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"intreger"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animation-list</span>&gt;</span></code></pre><p><code>android:oneshot</code>：表示是否播放一次</p><h3 id="应用代码-2"><a href="#应用代码-2" class="headerlink" title="应用代码"></a>应用代码</h3><blockquote><p>XML方式</p></blockquote><pre><code class="hljs xml">// animationlist.xml<span class="hljs-tag">&lt;<span class="hljs-name">animation-list</span>  <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>    <span class="hljs-attr">android:oneshot</span>=<span class="hljs-string">"false"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/bg1"</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/bg2"</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/bg3"</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:drawable</span>=<span class="hljs-string">"@drawable/bg4"</span> <span class="hljs-attr">android:duration</span>=<span class="hljs-string">"500"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animation-list</span>&gt;</span></code></pre><pre><code class="hljs java">view.setBackgroundResource(R.drawable.animationlist);AnimationDrawable animationDrawable = (AnimationDrawable)mView.getBackground();animationDrawable.start();</code></pre><blockquote><p>Java生成</p></blockquote><pre><code class="hljs java">AnimationDrawable ad = <span class="hljs-keyword">new</span> AnimationDrawable();<span class="hljs-comment">//1.创建AnimationDrawable对象</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<span class="hljs-comment">//2.添加Drawable对象及其持续时间</span>        Drawable drawable = getResources().getDrawable(getResources().getIdentifier(<span class="hljs-string">"bg"</span> + i, <span class="hljs-string">"drawable"</span>, getPackageName()));        ad.addFrame(drawable, <span class="hljs-number">500</span>);    &#125;    ad.setOneShot(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//3.设置是否执行一次</span>    mView.setBackgroundResource(ad);<span class="hljs-comment">//4.将帧动画作为view背景</span>    ad.start();<span class="hljs-comment">//5.播放动画</span></code></pre><p><strong>使用帧动画时要注意不能使用尺寸过大的图片。否则容易造成OOM错误</strong></p><h3 id="优化内存占用"><a href="#优化内存占用" class="headerlink" title="优化内存占用"></a>优化内存占用</h3><blockquote><p>由于图片全部是从xml中读取的，一定要全部读取下来动画才可以开始，因为要不断地替换图片去实现动画效果。一次性取出所有图片，就容易导致OOM</p></blockquote><p>优化思路：<strong>一次只取一个图片，开启一个线程去取下一张，达到一致的效果。</strong></p><h2 id="3-属性动画"><a href="#3-属性动画" class="headerlink" title="3.属性动画"></a>3.属性动画</h2><a href="/2020/10/12/Android动画-属性动画/" title="Android动画-属性动画">Android动画-属性动画</a>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-树</title>
    <link href="/2018/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <url>/2018/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><blockquote><p>每个节点最多只能有两个子节点，</p></blockquote><h2 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h2><h2 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h2><h2 id="B树、B-树"><a href="#B树、B-树" class="headerlink" title="B树、B+树"></a>B树、B+树</h2><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h2 id="N叉树"><a href="#N叉树" class="headerlink" title="N叉树"></a>N叉树</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/5df4aaefe51d45581269a6d2" target="_blank" rel="noopener">红黑树</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2018/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2018/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<!--TCP三次握手、四次挥手。 http请求报文结构、响应报文，状态码。 http2.0相比于http1.0的新特性，推送、多路复用、消息头压缩等 。Https的原理？Tcp和Udp的区别？Http的报文结构？cookie是用来干嘛的？有哪些响应码，分别都代表什么意思？有自己实现过Socket协议吗？互联网的实现主要分为几层，http、ftp、tcp、ip分别位于哪一层。http和https的区别为什么tcp要经过三次握手，四次挥手socket了解过吗 TCP保证可靠传输的实现：停止等待协议、滑动窗口协议、流量控制、拥塞控制等 HTTPS SSLTCP/IP三次握手 Tcp 三次握手四次挥 get 与 post 的区别---><!--7 Http和Https的区别？--><!--1）Https是ssl加密传输，Http是明文传输--><!--2）Https是使用端口443，而Http使用80--><!--3）HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全--><!--4）Https协议需要到CA申请证书--><!--8 加密算法有哪些？对称加密和非对称加密的区别？--><!--MD5，SHA1，Base64，RSA，AES，DES--><!--对称：使用相同密钥，需要在网络传输，安全性不高。--><!--非对称：使用一对密钥，公钥和私钥，私钥不在网络传输，因此安全性高。--><!--9 TCP的三次握手？两次行不行？为什么？TCP攻击知道吗？如何进行攻击？--><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/计算机网络基础.png" srcset="/img/loading.gif" class="full-image" alt="TCP、UDP协议" title="TCP、UDP协议"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><blockquote><p>将网络节点所要完成的数据的发送或转发、打包或拆包，以及控制信息的加载或拆出等工作，分别由不同的硬件或软件模块来完成。</p></blockquote><p>计算机网络体系结构分为3种：<code>OSI体系结构</code>、<code>TCP/IP体系结构</code>、<code>五层体系结构</code>。</p><blockquote><ul><li><code>OSI体系结构</code>：概念清楚并且理念完整，但复杂且不实用</li><li><code>TCP/IP体系结构</code>：包含了一系列构成互联网基础的网络协议，是<code>Intenet</code>的核心协议并且被广泛应用于局域网和广域网</li><li><code>五层体系结构</code>：融合了<code>OSI</code>与<code>TCP/IP</code>的体系结构。</li></ul></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/计算机网络体系结构.png" srcset="/img/loading.gif" class="full-image" alt="计算机网络体系结构" title="计算机网络体系结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>以下主要分析 <code>五层协议</code></p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/网络模型(五层协议).png" srcset="/img/loading.gif" class="full-image" alt="网络模型(五层协议)" title="网络模型(五层协议)"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><blockquote><p>传输数据单位为比特(<code>bite</code>)，负责比特流在节点间的传输，即负责物理传输。例如光纤等</p></blockquote><p>具体协议：无</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><blockquote><p>控制网络层与物理层之间的通信，主要功能是如何在不可靠的物理线路上进行数据的可靠传递。</p><p>链路层使用的信道主要有两种类型：</p><ul><li>点对点信道</li><li>广播信道</li></ul></blockquote><p>具体协议：逻辑链路控制 LLC、媒体介入控制 MAC</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><blockquote><p>如何将数据从发送方到接收方。将<code>数据报</code>从一台主机移动到另一台主机。</p></blockquote><p>具体协议：IP协议、因特网控制报文协议ICMP</p><h3 id="传输层-运输层"><a href="#传输层-运输层" class="headerlink" title="传输层/运输层"></a>传输层/运输层</h3><blockquote><p>为两台主机上的应用程序提供通用的数据传输服务，传输内容为<code>应用层报文</code>。</p></blockquote><p>具体协议：传输控制协议 TCP、用户数据报协议 UDP</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><blockquote><p>网络应用程序和网络协议储存的分层。网络应用程序接收到传输层的数据后，就需要进行解读。</p></blockquote><p>具体协议：文件传输协议 FTP、超文本传输协议 HTTP、域名系统 DNS</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><blockquote><p><code>Transmission Control Protocol</code>——传输控制协议 <strong>主要用于传输层</strong></p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><table><thead><tr><th>特点</th><th>具体描述</th></tr></thead><tbody><tr><td>面向连接</td><td>使用TCP传输数据前，必须先建立TCP连接；传输完成后在释放连接</td></tr><tr><td>面向字节流</td><td>虽然应用程序和TCP的交互是一次一个数据块，但TCP只把数据看外一连串无结构的字节流。数据以流的形式传输</td></tr><tr><td>全双工通信</td><td>建立TCP连接后，通信双方都能发送数据</td></tr><tr><td>可靠</td><td>通过TCP传输的数据：不丢失、无差错、不重复，按序到达</td></tr></tbody></table><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：数据传输可靠</p><p>缺点：效率低（因为连接过程比较复杂）</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>传输文件：HTTP、HTTPS、FTP等协议</li><li>传输邮件：POP、SMTP等协议</li></ul><h3 id="报文段格式"><a href="#报文段格式" class="headerlink" title="报文段格式"></a>报文段格式</h3><p>报文段分为两部分：</p><p>TCP首部：全部功能体现于此，最小长度为20字节。</p><p>TCP数据：传输的数据</p><table><thead><tr><th>TCP首部字段</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>序号<br>Sequence Number(<strong>seq</strong>)</td><td>本报文段所发送数据的第一个字节序号</td><td>占4字节</td></tr><tr><td>确认号<br>Acknowledgment Number(<strong>ACK</strong>)</td><td>期望收到对方下一个报文段的第一个数据字节的序号</td><td>占4字节<br>若ACK为n，代表到序号n-1之前的数据都已正确收到</td></tr><tr><td>同步位<br><strong>SYN</strong></td><td>连接建立时用于同步序号</td><td>SYN = 1,ACK = 0，表示是连接请求报文段<br>SYN = 1,ACK = 1，表示连接请求响应报文段</td></tr><tr><td>终止控制位<br><strong>FIN</strong></td><td>释放连接</td><td>FIN = 1表示此报文段的发送方已发送数据完毕并要求释放连接</td></tr></tbody></table><h3 id="建立连接过程——三次握手"><a href="#建立连接过程——三次握手" class="headerlink" title="建立连接过程——三次握手"></a>建立连接过程——三次握手</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/TCP三次握手过程.webp" srcset="/img/loading.gif" class="full-image" alt="TCP三次握手过程" title="TCP三次握手过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>客户端主动打开连接，服务器被动打开连接，然后进入<code>LISTEN(监听)</code>状态，等待接收客户端的请求。</p><h4 id="第一次握手——客户端发送连接请求报文段到服务端"><a href="#第一次握手——客户端发送连接请求报文段到服务端" class="headerlink" title="第一次握手——客户端发送连接请求报文段到服务端"></a>第一次握手——客户端发送连接请求报文段到服务端</h4><p>设置<code>SYN = 1，seq = x</code>；然后客户端进入<code>SYN-SENT(同步已发送)</code>状态，等待服务端确认。</p><h4 id="第二次握手——服务器收到客户端请求连接报文段，对报文段内容进行确认"><a href="#第二次握手——服务器收到客户端请求连接报文段，对报文段内容进行确认" class="headerlink" title="第二次握手——服务器收到客户端请求连接报文段，对报文段内容进行确认"></a>第二次握手——服务器收到客户端请求连接报文段，对报文段内容进行确认</h4><p>设置<code>ack = x+1、SYN = 1，seq为y</code>一并加入报文段中，发送给客户端；然后服务端进入<code>SYN_RCVD(同步已接收)</code>状态。</p><h4 id="第三次握手——客户端收到服务端确认连接报文段，然后向服务端发送连接确认报文段"><a href="#第三次握手——客户端收到服务端确认连接报文段，然后向服务端发送连接确认报文段" class="headerlink" title="第三次握手——客户端收到服务端确认连接报文段，然后向服务端发送连接确认报文段"></a>第三次握手——客户端收到服务端确认连接报文段，然后向服务端发送连接确认报文段</h4><p>客户端收到服务端发出的<code>SYN+ACK</code>报文段；然后设置<code>ACK = y+1</code>，在向服务端发出<code>ACK</code>报文段，确认连接。然后客户端和服务端都进入<code>ESTABLISHED(TCP连接成功)</code>状态。</p><p>完成上述TCP的三次握手过程后，TCP连接建立完成，即可传送应用层数据。</p><blockquote><p>由于TCP是全双工通信，服务端和客户端在任何时候都可以互相发送数据。</p><p>如果三次握手期间，任何一次没有收到对方的回复，都需要进行重发。<strong>超时重发机制</strong></p></blockquote><h4 id="为什么需要进行三次握手？"><a href="#为什么需要进行三次握手？" class="headerlink" title="为什么需要进行三次握手？"></a>为什么需要进行三次握手？</h4><p><strong>防止服务端因接受了早已失效的连接请求报文，从而一直等待客户端请求，最终导致死锁，形成资源浪费。</strong></p><blockquote><p>SYN洪范攻击：利用了TCP的三次握手机制。模拟多个客户端发起连接请求，然后不处理服务端返回请求，这样就会导致服务端持续挂起，大量请求时会快速耗尽服务器资源，导致死机。</p><p>服务端的TCP资源分配发生在第二次握手结束时；客户端的TCP资源分配发生在第三次握手结束时。</p><p>如何对这种攻击进行防范？</p><p><strong>优化主机系统设置，如降低SYN timeout时间；设置cookie，如果短时间内连续收到同IP请求，则对该IP的请求进行抛弃。</strong></p></blockquote><h3 id="释放连接过程——四次挥手"><a href="#释放连接过程——四次挥手" class="headerlink" title="释放连接过程——四次挥手"></a>释放连接过程——四次挥手</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/TCP四次挥手过程.webp" srcset="/img/loading.gif" class="full-image" alt="TCP四次挥手过程" title="TCP四次挥手过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="第一次挥手——客户端向服务端发送连接释放报文段"><a href="#第一次挥手——客户端向服务端发送连接释放报文段" class="headerlink" title="第一次挥手——客户端向服务端发送连接释放报文段"></a>第一次挥手——客户端向服务端发送连接释放报文段</h4><p>设置<code>FIN = 1</code>发送至服务端；客户端进入<code>FIN_WAIT_1(终止等待1)</code>状态，此时客户端没有数据在需要发送了。</p><h4 id="第二次挥手——服务端收到连接释放报文段，再向客户端发送连接释放确认报文段"><a href="#第二次挥手——服务端收到连接释放报文段，再向客户端发送连接释放确认报文段" class="headerlink" title="第二次挥手——服务端收到连接释放报文段，再向客户端发送连接释放确认报文段"></a>第二次挥手——服务端收到连接释放报文段，再向客户端发送连接释放确认报文段</h4><p>设置<code>ACK = 1</code>发送至客户端；服务端进入<code>CLOSE_WAIT(关闭等待)</code>状态，客户端收到连接释放确认请求后，会进入<code>FIN_WAIT_2(终止等待2)</code>状态，等待服务端的释放连接请求。</p><p><strong>此时客户端 -&gt; 服务端的连接已断开</strong></p><h4 id="第三次挥手——若服务端没有再发送数据，则发出释放连接的报文段"><a href="#第三次挥手——若服务端没有再发送数据，则发出释放连接的报文段" class="headerlink" title="第三次挥手——若服务端没有再发送数据，则发出释放连接的报文段"></a>第三次挥手——若服务端没有再发送数据，则发出释放连接的报文段</h4><p>设置<code>FIN = 1</code>发送至客户端，请求关闭连接；服务端进入<code>LAST_ACK(最后确认)</code>状态。</p><h4 id="第四次挥手——客户端收到服务端的连接释放报文段，再向服务端发出连接释放确认报文段"><a href="#第四次挥手——客户端收到服务端的连接释放报文段，再向服务端发出连接释放确认报文段" class="headerlink" title="第四次挥手——客户端收到服务端的连接释放报文段，再向服务端发出连接释放确认报文段"></a>第四次挥手——客户端收到服务端的连接释放报文段，再向服务端发出连接释放确认报文段</h4><p>客户端收到服务端连接释放请求，再向服务端发送释放连接确认报文段，客户端进入<code>TIME_WAIT(时间等待)</code>状态。</p><p>服务端收到释放连接确认报文段后，服务端进入<code>CLOSED(关闭)</code>状态。</p><p>客户端等待<code>2MSL</code>后依然没有收到回复，客户端进入<code>CLOSED(关闭)</code>状态。</p><h4 id="为什么TCP释放需要四次挥手？"><a href="#为什么TCP释放需要四次挥手？" class="headerlink" title="为什么TCP释放需要四次挥手？"></a>为什么TCP释放需要四次挥手？</h4><p><strong>为了保证通信双方都通知到对方释放并断开连接。释放连接后，相互都无法发送和接收消息。</strong></p><h4 id="为什么需要等待2MSL时间没有回复在关闭？"><a href="#为什么需要等待2MSL时间没有回复在关闭？" class="headerlink" title="为什么需要等待2MSL时间没有回复在关闭？"></a>为什么需要等待<code>2MSL</code>时间没有回复在关闭？</h4><blockquote><p>MSL：最长报文段寿命</p></blockquote><ol><li>为了保证客户端发送的最后一个连接释放确认报文可以到达服务端，使得服务端可以释放连接</li><li>防止<strong>早已失效的连接请求报文</strong>出现在本次连接中。在<code>2MSL</code>时间内，在本连接中产生的所有报文都会消失。</li></ol><h3 id="可靠性保证"><a href="#可靠性保证" class="headerlink" title="可靠性保证"></a>可靠性保证</h3><p>主要分析的是如何保证TCP传输的可靠性。</p><blockquote><p>无论发送方以多块的速度发送数据，接收方总来得及处理收到的数据。</p></blockquote><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><blockquote><p><strong>出错重传</strong>：出现差错时，让发送方重新传输数据</p><p><strong>速度匹配</strong>：当接收方来不及接收收到的数据时，通知发送方降低发送数据的效率。</p></blockquote><h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><blockquote><p>是<strong>传输层进行流控</strong>的一种措施，接收方通过告知发送放自己的窗口大小，从而控制发送方的发送速度，达到防止发送方发送速度过快导致自己被淹没的目的。</p></blockquote><p>滑动窗口分为以下两部分：</p><table><thead><tr><th>类型</th><th>定义</th><th>作用</th></tr></thead><tbody><tr><td>发送窗口</td><td>任意时刻，发送方维持的一组连续的，允许发送帧的帧序号</td><td>对发送方进行流量控制</td></tr><tr><td>接收窗口</td><td>任意时刻，接收方维持的一组连续的，允许接收帧的帧序号</td><td>控制可以接收的数据帧以及不可接收的数据帧<br>接收方只有当收到的数据帧的序号落入接收窗口才允许收下该数据帧；否则，丢弃。</td></tr></tbody></table><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>对于TCP的发送方</p><p>每收到一个确认帧，发送窗口就向前滑动一个帧的距离。当发送窗口内没有可以发送的帧时(窗口内的帧全部为已发送但未收到确认的帧)，发送方停止发送，直到收到接收方发送的确认帧使发送窗口移动，然后发送窗口内还有可以发送的帧则继续发送。</p><blockquote><p>发送缓存内的数据可以分为4类：</p><ul><li>已经发送并得到确认帧</li><li><code>已经发送还未收到确认帧</code></li><li><code>未发送但对端允许发送</code></li><li>未发送且对端不允许发送</li></ul><p><code>已经发送还未收到确认帧、未发送但对端允许发送</code>就是发送窗口</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/滑动窗口协议-发送窗口.png" srcset="/img/loading.gif" class="full-image" alt="滑动窗口协议-发送窗口" title="滑动窗口协议-发送窗口"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>其中黑框部分就是<strong>发送窗口</strong>。</p><p>对于TCP的接收方</p><p>收到发送方的数据帧后，接收窗口向前移动一个帧位置，并发回确认帧到发送端，若收到的数据帧不在接收窗口内，则丢弃。</p><blockquote><p>接收缓存内的数据可以分为3类：</p><ul><li>已接收数据帧</li><li><code>未接受准备接收</code></li><li>未接受且为准备接收</li></ul><p><code>未接受准备接收</code>就是接收窗口</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/滑动窗口协议-接收窗口.png" srcset="/img/loading.gif" class="full-image" alt="滑动窗口协议-接收窗口" title="滑动窗口协议-接收窗口"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>其中黑框部分就是<strong>接收窗口</strong>。</p><h5 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h5><ol><li>只有接收窗口向前滑动，并且发送了确认帧到发送端时，发送窗口可以向前滑动</li><li>当接收窗口的大小为1时，可以保证帧有序接收</li></ol><h4 id="自动重传协议ARQ"><a href="#自动重传协议ARQ" class="headerlink" title="自动重传协议ARQ"></a>自动重传协议ARQ</h4><p>分为以下3类：</p><ul><li><p>停止-等待协议：发送窗口大小为1，接收窗口大小为1；<strong>单帧滑动窗口</strong></p><blockquote><p>发送方每发送一帧，要等到接收方返回的确认帧才可以继续发送下一帧</p><p>接收方每接收一帧，都要返回一个确认帧到发送方，表示可以接收下一帧</p><p>接收方不返回确认帧，发送方一直等待</p></blockquote></li><li><p>后退N帧协议：发送窗口大小&gt;1，接收窗口大小为1</p><blockquote><p>发送方连续发送多个数据帧，不需要等到接收方确认</p><p>接收方采用<strong>累计确认&amp;后退N帧</strong>的原理，只允许按顺序接收帧</p><p><strong>累计确认</strong>：收到多个数据帧后，只对按顺序到达的最后一帧发送确认帧，不必所有都去发送确认帧</p><p><strong>后退N帧</strong>：退回已发送过的N帧</p></blockquote></li><li><p>选择重传协议：发送窗口大小&gt;1，接收窗口大小&gt;1</p><blockquote><p>发送方连续发送多个数据帧，不需要等到接收方确认</p><p>接收窗口与发送窗口一样大，接收窗口直到数据填满再返回确认帧，否则需要发送方进行重传。</p></blockquote></li></ul><h4 id="流量控制-amp-拥塞控制"><a href="#流量控制-amp-拥塞控制" class="headerlink" title="流量控制&amp;拥塞控制"></a>流量控制&amp;拥塞控制</h4><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><blockquote><p>接收方根据自己接收缓存的大小，动态调整发送窗口大小，从而控制发送方的发送速率。</p></blockquote><p>容易出现<strong>死锁问题</strong>。当报文段在传送过程中丢失时，此时会出现发送方一直等待接收 接收方的非零窗口通知，然后接收方一直在等待发送方的数据，形成了死锁。</p><p>解决方案：TCP为每一个连接设有一个持续计时器(<em>persistence timer</em>)，只要TCP连接的一方收到对方的零窗口通知，就启动该计时器，若计时器计时结束，就会发出一个零窗口探测报文段。对方就会给出此时的窗口值：为0则需重新设置计时器，不为0 就要打破死锁。</p><h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><blockquote><p>防止过多的数据注入到网络中，使得网络中的路由器和链路不至于过载。</p></blockquote><p>具体解决方案分为两种：</p><h6 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h6><p>慢开始</p><blockquote><p>当主机开始发送数据时，由小到大逐渐增大<strong>拥塞窗口(发送窗口)数值</strong>，从而由小到大逐渐增大发送报文段。</p></blockquote><p>拥塞避免</p><blockquote><p>使得拥塞窗口<strong>按线性规律缓慢增长</strong>；没经过一个往返时间<em>RTT</em>，发送方的拥塞窗口加1。</p></blockquote><h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6><p>快重传</p><blockquote><p>接收方 每收到一个失序的报文段后，就立即发出<strong>重复确认</strong>，而不是等到自己发出数据时再带上确认数据</p><p>发送方 只要连续收到3个<strong>重复确认</strong>就立即重传对方尚未收到的报文段，不必等到设置的重传计时器到点。</p></blockquote><p>快恢复</p><blockquote><p><strong>是一个非常激进的算法。</strong></p><p>先执行<strong>乘法减小算法</strong>，设置<strong>慢开始门限(<code>ssthresh</code>)</strong>为当前发送窗口大小的一半</p><p>再设置<strong>拥塞窗口(<code>cwnd</code>)</strong>为<strong>慢开始门限(<code>ssthresh</code>)</strong>的一半</p><p>再执行<strong>加法增大算法</strong>，执行拥塞避免算法，线性加大发送窗口。</p></blockquote><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><blockquote><p><code>User Datagram Protocol</code>——用户数据报协议 <strong>主要用于传输层</strong></p></blockquote><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><table><thead><tr><th>UDP特点</th><th>具体描述</th></tr></thead><tbody><tr><td>无连接</td><td>使用UDP传输数据，不需要建立连接</td></tr><tr><td>不可靠</td><td>UDP的数据包发送后，不管其是否会到达接收方</td></tr><tr><td>面向报文</td><td>数据 以<strong>数据报文(包)</strong>的形式传输</td></tr><tr><td>无拥塞控制</td><td>由于是不可靠传输，不管是否到达接收方，所以不需要拥塞控制</td></tr></tbody></table><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：速度快</p><p>缺点：消息易丢失(<em>尤其是网络较差时</em>)</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>要求通信速度快，且不在乎结果。</strong></p><blockquote><p>域名转换 DNS协议、文件传输 FTP协议</p></blockquote><p>当前的游戏、视频、即时通信工具也多用UDP协议传输数据，但也会辅以TCP协议进行数据完善。</p><h3 id="报文段格式-1"><a href="#报文段格式-1" class="headerlink" title="报文段格式"></a>报文段格式</h3><p>分为两部分：<strong>首字段、数据字段</strong>。</p><table><thead><tr><th>字段</th><th>作用</th><th>描述</th></tr></thead><tbody><tr><td>源端口</td><td>源端口号，需要对方回信时使用</td><td></td></tr><tr><td>目的端口</td><td>目的端口号，终点交付报文时使用</td><td></td></tr><tr><td>长度</td><td>UDP用户数据报的长度</td><td>最小值 8</td></tr><tr><td>校验和</td><td>检测UDP用户数据报在传输中是否有错</td><td>出错则丢弃</td></tr><tr><td>伪首部</td><td>计算校验和（不会发送出去）</td><td>不在UDP首部范围</td></tr></tbody></table><h3 id="与TCP协议的区别"><a href="#与TCP协议的区别" class="headerlink" title="与TCP协议的区别"></a>与TCP协议的区别</h3><ol><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li></ol><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HTTP协议.png" srcset="/img/loading.gif" class="full-image" alt="HTTP协议" title="HTTP协议"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p><code>HyperText Trsnsfer Protocol</code>——超文本传输协议 <strong>主要用于应用层</strong>。基于TCP协议传输，端口号为80</p><p><strong>HTTP是一个在计算机世界专门在两点之间传输文字，图片、音频等超文本数据的约定与规范。</strong></p></blockquote><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><h4 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h4><ul><li>默认短连接</li><li>除了GET命令外还增加了POST、HEAD命令</li></ul><h4 id="HTTP1-1-目前最流行版本"><a href="#HTTP1-1-目前最流行版本" class="headerlink" title="HTTP1.1 (目前最流行版本)"></a>HTTP1.1 (<strong>目前最流行版本</strong>)</h4><ul><li>默认长连接</li><li>增加更多的请求头和响应头</li><li>增加身份认证、状态管理功能</li><li>支持分块传输编码</li></ul><h4 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h4><ul><li><strong>新的二进制格式</strong>：之前都是用解析文本的方式</li><li><strong>多路复用</strong></li><li><strong>服务端推送</strong>：在客户端请求资源时，会把相关资源一起发给客户端，就不需要客户端再次请求。</li><li><strong>消息头压缩</strong>：客户端和服务端同时维护和更新一个首部字段表，避免重复传输</li></ul><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><blockquote><p>位于服务端返回<strong>响应报文</strong>中的第一行，包含了状态码以及原因短语，用来告知客户端请求结果。</p></blockquote><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational(信息性状态码)</td><td>接收请求正在处理</td></tr><tr><td>2XX</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作完成请求</td></tr><tr><td>4XX</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error(服务端错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><h4 id="1XX-信息性状态码"><a href="#1XX-信息性状态码" class="headerlink" title="1XX 信息性状态码"></a>1XX 信息性状态码</h4><ul><li><strong>100 Continue</strong> ：客户端继续发送请求</li></ul><h4 id="2XX-成功状态码"><a href="#2XX-成功状态码" class="headerlink" title="2XX 成功状态码"></a>2XX 成功状态码</h4><ul><li><strong>200 OK</strong>：请求成功</li><li><strong>204 No Content</strong>：请求成功处理，但没有返回数据</li><li><strong>206 Partial Content</strong>：客户端进行了范围请求，响应报文包含了<code>Content-Range</code></li></ul><h4 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a>3XX 重定向状态码</h4><ul><li><strong>301 Moved Permanently</strong>：永久性重定向</li><li><strong>302 Found</strong>：临时性重定向</li></ul><h4 id="4XX-客户端错误状态码"><a href="#4XX-客户端错误状态码" class="headerlink" title="4XX 客户端错误状态码"></a>4XX 客户端错误状态码</h4><ul><li><strong>400 Bad Request</strong>：请求报文存在语法错误</li><li><strong>401 Unauthorized</strong>：用户认证失败</li><li><strong>403 Frobidden</strong>：请求拒绝</li><li><strong>404 Not Found</strong></li></ul><h4 id="5XX-服务端出错状态码"><a href="#5XX-服务端出错状态码" class="headerlink" title="5XX 服务端出错状态码"></a>5XX 服务端出错状态码</h4><ul><li><strong>500 Internal Server Error</strong>：服务器执行请求时发生错误</li><li><strong>503 Server Unavaliable</strong>：服务器无法处理请求</li></ul><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><blockquote><p>位于<strong>请求报文</strong>第一行，包含了方法字段</p></blockquote><table><thead><tr><th>请求方法</th><th>作用</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td><td>客户端需要从服务器读取资源时使用<br>一般用于获取/查询信息<br>通过URL传递且参数长度是有限制的<br>请求格式 <code>/test/result?key=key&amp;page=1</code><br>请求是安全的，因为只读，不会改变服务器数据</td></tr><tr><td>POST</td><td>传输实体主体</td><td>客户端向服务端提供信息时使用<br>可以附带数据，用于更新服务器数据<br>将请求参数封装在请求数据中，可传输大量数据<br>传参方式更加安全，但是请求是不安全的，会导致服务器数据发生改变</td></tr><tr><td>HEAD</td><td>获取报文首部</td><td>不返回报文实体部分，主要用于确认URL有效性以及资源更新日期</td></tr><tr><td>PUT</td><td>上传文件</td><td>自身不带验证机制，存在安全性问题。<strong>一般不使用</strong></td></tr><tr><td>PATCH</td><td>对资源部分进行修改</td><td>可以部分对资源进行修改</td></tr><tr><td>DELETE</td><td>删除文件</td><td>自身不带验证机制，存在安全性问题。</td></tr><tr><td>OPTIONS</td><td>查询支持的方法</td><td>查询指定的URL可以提供的方法。<br>返回示例：<code>Allow: GET , POST</code></td></tr><tr><td>CONNECT</td><td>要求与代理服务器通信时建立隧道</td><td>对通信内容进行加密后通过网络隧道传输</td></tr><tr><td>TRACE</td><td>追踪路径</td><td>将通信路径返回给客户端</td></tr></tbody></table><h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><blockquote><p>分为两部分：</p><ul><li><strong>请求报文</strong>：用于发送请求时</li><li><strong>响应报文</strong>：用于响应请求时</li></ul></blockquote><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HTTP_RequestMessage.png" srcset="/img/loading.gif" class="full-image" alt="请求报文" title="请求报文"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><p>声明请求方法、主机域名和协议版本</p><blockquote><p>基本格式： <strong>Method Request-URI HTTP-Version CRLF</strong></p><p>Method：表示请求方法，例如<code>GET、POST...</code></p><p>Request-URI：统一资源标识符，例如<code>https://leo-wxy.github.io/</code></p><p>HTTP-Version：HTTP协议版本，例如<code>HTTP/1.1 HTTP/2.0</code></p><p>CRLF：表示回车和换行，<code>\r\n</code></p><p>示例数据： <code>GET http://leo-wxy.github.io/ HTTP/1.1</code></p></blockquote><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p>声明客户端、服务器/报文的部分信息</p><blockquote><p>基本格式：<strong>header(字段名) : value(值)</strong></p></blockquote><p>报文通用Header(<em>可用于请求报文和响应报文</em>)</p><table><thead><tr><th>首部字段名</th><th>描述</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>允许发送指定连接的选项。例如<code>close</code>响应完成后，关闭服务器</td></tr><tr><td>Date</td><td>表示消息产生的日期和时间</td></tr></tbody></table><p>请求报文Header</p><table><thead><tr><th>首部字段名</th><th>描述</th></tr></thead><tbody><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>User-Agent</td><td>HTTP客户端程序的信息</td></tr><tr><td>Accept</td><td>用户可处理的媒体类型</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr></tbody></table><p>POST请求时的实体首部字段</p><table><thead><tr><th>首部字段名</th><th>描述</th></tr></thead><tbody><tr><td>Allow</td><td>可支持的HTTP方法</td></tr><tr><td>Content-Length</td><td>请求体/响应体的长度，单位字节</td></tr><tr><td>Content-Type</td><td>请求体/响应体的类型，例如<code>text/html</code></td></tr></tbody></table><h5 id="请求数据-请求体"><a href="#请求数据-请求体" class="headerlink" title="请求数据(请求体)"></a>请求数据(请求体)</h5><p>存放客户端发送给服务器的数据信息，如果为<code>GET</code>请求则没有该结构</p><p>使用方式共3种：</p><ul><li>数据交换</li><li>键值对</li><li>分部分形式</li></ul><h5 id="请求报文示例"><a href="#请求报文示例" class="headerlink" title="请求报文示例"></a>请求报文示例</h5><table><thead><tr><th>请求行</th><th><strong>GET /test/index.html HTTP/1.1</strong></th></tr></thead><tbody><tr><td><strong>请求头</strong></td><td>Host : <a href="http://www.github.io" target="_blank" rel="noopener">www.github.io</a></td></tr><tr><td></td><td>User-Agent : Mozilla/5.0</td></tr><tr><td><strong>空行</strong></td><td>(用于隔开请求头和请求体)</td></tr><tr><td><strong>请求体</strong></td><td>id=0&amp;page=1</td></tr></tbody></table><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HTTP_ResponseMessage.png" srcset="/img/loading.gif" class="full-image" alt="响应报文" title="响应报文"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><p>声明协议版本、状态码和描述</p><blockquote><p>基本格式： <strong>HTTP-Version Status-Code Reason-Parse CRLF</strong></p><p>HTTP-Version：HTTP协议版本，例如<code>HTTP/1.1 HTTP/2.0</code></p><p>Status-Code：服务器返回的状态码，对应上面的<a href="#响应状态码">响应状态码</a></p><p>Reason-Parse：状态码的文本描述，对应上面的<a href="#响应状态码">响应状态码</a></p><p>CRLF：表示回车和换行，<code>\r\n</code></p><p>示例数据： <code>HTTP/1.1 404 Not Found</code></p></blockquote><h5 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h5><p>声明客户端，服务端报文的部分信息</p><blockquote><p>基本格式：<strong>header(字段名) : value(值)</strong></p></blockquote><p>常见响应报头Header</p><table><thead><tr><th>首部字段名</th><th>描述</th></tr></thead><tbody><tr><td>Location</td><td>客户端重定向URL，用在更换域名时</td></tr><tr><td>Server</td><td>HTTP服务器的安装信息，与User-Agent是对应的</td></tr><tr><td>Age</td><td>推算资源创建经过的时间</td></tr></tbody></table><h5 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h5><p>存放返给客户端的数据信息</p><p>使用方式共3种：</p><ul><li>数据交换</li><li>键值对</li><li>分部分形式</li></ul><h5 id="响应报文示例"><a href="#响应报文示例" class="headerlink" title="响应报文示例"></a>响应报文示例</h5><table><thead><tr><th>状态行</th><th>HTTP/1.1 200 OK</th></tr></thead><tbody><tr><td><strong>响应报头</strong></td><td>Connection : keep-alive</td></tr><tr><td></td><td>Server : Nginx</td></tr><tr><td><strong>空行</strong></td><td>(用于隔开响应头和响应正文)</td></tr><tr><td><strong>响应正文</strong></td><td>{“error”:false,”result”:1}</td></tr></tbody></table><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP/1.1中引入了Cookie来保存状态信息。</p><p>Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被带上，用于告知服务器两个请求来自同一浏览器。每次都携带，会带来额外的性能开销。</p><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP/1.1之后默认支持长连接。<em>数据传输完成后TCP连接不会断开，继续使用该通道传输数据。</em></p><h4 id="如何建立长连接？"><a href="#如何建立长连接？" class="headerlink" title="如何建立长连接？"></a>如何建立长连接？</h4><p>设置HTTP Header：Connection</p><blockquote><p>Connection对应两种值：Connection : close 或 Connection ： Keep-Alive</p><p><code>close</code>：表示不使用长连接</p><p><code>keep-alive</code>：表示开启长连接，还有两个Header设置长连接相关属性</p><ul><li><code>Keep-Alive:max</code>：设置连接失败最大尝试次数，超过则断开</li><li><code>Keep-Alive:time</code>：设置最大超时时间，超过则断开</li></ul></blockquote><h4 id="关闭长连接"><a href="#关闭长连接" class="headerlink" title="关闭长连接"></a>关闭长连接</h4><ul><li>判断传输数据是否达到了<code>Content-Length</code>指示的大小</li><li>根据<code>chunked编码</code>判断，若<code>chunked编码</code>在最后有一个空块，表明本次传输结束</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HTTPS.png" srcset="/img/loading.gif" class="full-image" alt="HTTPS基础知识" title="HTTPS基础知识"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>HTTP有以下安全问题：</p><ul><li>使用明文进行通信，内容可能会被窃听</li><li>不验证通信方的身份，通信方的身份可能遭遇伪装</li><li>无法验证报文的完整性，报文内容可能被篡改</li></ul><p>HTTPS是建立在<code>SSL/TLS安全协议上的</code>，这套协议运行在<code>TCP协议</code>上；会对传输的内容进行加密；使用端口443。</p><p>通过使用SSL，HTTPS就具有了<strong>加密(防窃听)、认证(防伪装)，完整性保护(防止报文被篡改)</strong>功能。</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h4><blockquote><p>加密和解密使用同一密钥。</p></blockquote><p>优点：运算速度快</p><p>缺点：无法安全的将密钥传给客户端，安全性不高</p><p>具体算法：</p><p>DES算法，RC5算法、AES算法</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/对称密钥加解密过程.png" srcset="/img/loading.gif" class="full-image" alt="对称密钥加解密过程" title="对称密钥加解密过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h4><blockquote><p>加密和解密使用不同的密钥。分别是<strong>公钥，私钥</strong>。</p><p>公钥所有人都可以获得，通信方得到公钥后，就可以对发送内容进行加密，然后传递至服务端，服务端就可以利用私钥进行解密。</p><p>私钥还可以对服务端返回内容进行签名，利用公钥去验证签名是否正确，防止被人篡改。</p></blockquote><p>优点：可以更安全的将公钥传输给客户端，服务端持有私钥，不会暴露</p><p>缺点：加密解密速度慢</p><p>具体算法：</p><p>RSA算法</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/非对称密钥加解密过程.png" srcset="/img/loading.gif" class="full-image" alt="非对称密钥加解密过程" title="非对称密钥加解密过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="HTTPs采用的加密方式"><a href="#HTTPs采用的加密方式" class="headerlink" title="HTTPs采用的加密方式"></a>HTTPs采用的加密方式</h4><p>HTTPS采用了<strong>混合加密机制</strong>，使用<code>非对称闭钥的公钥</code>加密对称密钥来保证传输的安全性，之后服务端使用私钥解密出<code>对称加密密钥</code>，然后双方使用对称密钥来加密报文进行互相传输。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HTTPS加密过程.png" srcset="/img/loading.gif" class="full-image" alt="HTTPS加密过程" title="HTTPS加密过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>步骤1：客户端发起HTTPS请求</p><p>步骤2：服务端配置非对称加密的公钥、私钥</p><p>步骤3：传送公钥到客户端</p><p>步骤4：客户端判断公钥是否有效，无效则显示警告。证书没有问题则会生成一个随机值，使用传递的公钥进行加密</p><p>步骤5：客户端传送加密后的随机值到服务端</p><p>步骤6：服务端使用私钥解密传递过来的数据，得到客户端生成的随机值，利用该随机值对传输数据进行加密</p><p>步骤7：服务端传输加密后的数据到客户端</p><p>步骤8：客户端使用上次生成的随机值对服务端传输的数据进行解密,整套流程结束。</p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><blockquote><p>服务端在传输公钥的时候，可能中途被拦截，然后中间人对公钥进行篡改。这时在向下传递的公钥就完全是错误的，导致后续流程全部产生问题。</p></blockquote><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><blockquote><p>通过使用<strong>证书</strong>来对通信方进行认证。</p><p><code>数字证书认证机构(CA,Certificate Authority)</code>是客户端和服务端都可以信任的第三方机构。</p><p>服务端向CS申请公钥，CA对申请者身份认证通过后，会对公钥进行数字签名，然后分配公钥，再将公钥与证书进行绑定。进行HTTPS通信时，服务器吧证书也发给客户端，客户端可以利用证书对传递的公钥进行验证，验证通过后就可以继续后续的通信。</p></blockquote><h3 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h3><blockquote><p>SSL提供报文摘要功能进行完整性保护。</p></blockquote><p>HTTP的报文摘要功能是通过<code>MD5</code>实现的，中途被篡改了，然后重新MD5，客户端是无法感知内容已经发送变化。</p><p>HTTPs 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h3><ol><li>HTTPS协议握手阶段比较费时，因为需要进行加密/解密过程</li><li>SSL证书是需要钱的，越高级的越贵</li><li>HTTPS加密范围有限，而且证书也不是一定可以完全信任的。</li></ol><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket是通信的基石，是对<code>TCP/IP协议</code>的封装，是接口而非协议。创建Socket连接时可以指定传输层协议TCP或者UDP；</p><p>Socket建立连接过程分为三步：</p><ol><li>服务端监听</li><li>客户端请求</li><li>连接确认</li></ol><p>应用层可以和传输层通过Socket，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="地址栏中输入url会发生什么"><a href="#地址栏中输入url会发生什么" class="headerlink" title="地址栏中输入url会发生什么"></a>地址栏中输入url会发生什么</h3><ul><li>浏览器向DNS服务器请求解析该url中的域名对应的IP地址</li><li>解析得到IP地址后，根据IP地址和端口，与服务器建立TCP连接</li><li>浏览器发出读取文件的HTTP请求</li><li>服务器对浏览器请求做出响应，返回html文本到浏览器</li><li>根据Header中的<code>Connection</code>判断是否需要释放TCP连接，若为<code>close</code>则关闭连接；为<code>keep-alive</code>则保持该连接一段时间，可以继续接受服务器数据</li><li>浏览器解析服务端返回的html文本并显示</li></ul><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a><code>CDN</code></h3><blockquote><p>全称为<code>Content Delivery Network(内容分发网络)</code>，使用到了<code>HTTP协议</code>里的缓存和代理技术，代替源站响应客户端的请求。</p><p>​    </p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/5e38160a6fb9a07c7c2d4e78" target="_blank" rel="noopener">计算机网络高频面试解析 </a></p><p><a href="https://juejin.im/post/5e1870736fb9a02fef3a5dcb" target="_blank" rel="noopener">HTTP协议</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Study-Plan-XVIII -- 基础网络原理</title>
    <link href="/2018/05/31/Android-Study-Plan-XVIII/"/>
    <url>/2018/05/31/Android-Study-Plan-XVIII/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><h2 id="网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。"><a href="#网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。" class="headerlink" title="网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。"></a>网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler机制源码解析</title>
    <link href="/2018/05/14/Handler%E6%9C%BA%E5%88%B6%E5%8D%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2018/05/14/Handler%E6%9C%BA%E5%88%B6%E5%8D%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要的内容包括Handler的机制以及四个组成部分和源码的分析</p><p>下面的代码分析都是基于Android8.0 - Oreo的源代码</p></blockquote><p><img src="/images/Android消息机制.png" srcset="/img/loading.gif" alt="Android消息机制"></p><a id="more"></a><h2 id="1-消息机制简介"><a href="#1-消息机制简介" class="headerlink" title="1.  消息机制简介"></a>1.  消息机制简介</h2><p>在应用启动时，会执行<code>main()</code>方法，<code>main()</code>会创建一个Looper对象，然后开启一个死循环，目的是<strong>不断从消息队列<code>MessageQueue</code>里面取出<code>Message</code>对象并处理。</strong></p><p>在Android中使用消息机制，会优先想到的是Handler。Handler可以轻松的将一个任务切换到Handler所在的线程去执行。在多线程的应用场景中，<strong>可以将工作线程中需要更新UI的操作信息传递到主线程去执行</strong>，从而实现工作线程更新UI的操作，最终实现异步消息的处理。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/handler_process.png" srcset="/img/loading.gif" class="full-image" alt="Handler执行流程图" title="Handler执行流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span> <h2 id="2-Handler机制模型"><a href="#2-Handler机制模型" class="headerlink" title="2. Handler机制模型"></a>2. Handler机制模型</h2><p>消息机制主要包含<strong>Handler、Message、MessageQueue，Looper</strong>这四个类。</p><h3 id="Handler：消息辅助类"><a href="#Handler：消息辅助类" class="headerlink" title="Handler：消息辅助类"></a>Handler：消息辅助类</h3><p>主要功能将<code>Message</code>对象发送到<code>MessageQueue</code>中，同时将自己的引用赋值给<code>Message#target</code>(Handler.sendMessage())。也可以实现<code>handleMessage()</code>方法处理回调。</p><h3 id="Message：消息实体"><a href="#Message：消息实体" class="headerlink" title="Message：消息实体"></a>Message：消息实体</h3><p>需要传递的消息也可以传递数据。</p><p><code>Message</code>分为三种：</p><ul><li>同步消息(<code>默认消息</code>)</li><li>异步消息(<code>setAsynchronous(true)</code>)</li><li>同步屏障消息</li></ul><h3 id="MessageQueue：消息队列"><a href="#MessageQueue：消息队列" class="headerlink" title="MessageQueue：消息队列"></a>MessageQueue：消息队列</h3><p><strong>内部实现并不是队列，而是利用单链表去实现因为在插入和删除数据有优势。</strong>用于存储Handler发给来的消息(<code>Message</code>)以及取出。<code>内部使用单链表实现</code></p><h3 id="Looper：消息循环"><a href="#Looper：消息循环" class="headerlink" title="Looper：消息循环"></a>Looper：消息循环</h3><p>与线程绑定，不止局限于主线程，绑定的线程来处理<code>Message</code>。不断循环执行<code>Looper.loop()</code>，从<code>MessageQueue</code>中读取<code>Message</code>，按分发机制将消息分发出去给目标处理(将<code>Message</code>发到<code>Handler.dispatchMessage</code>方法去处理)。</p><h2 id="3-Handler运行流程"><a href="#3-Handler运行流程" class="headerlink" title="3. Handler运行流程"></a>3. Handler运行流程</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/handler_run_process.png" srcset="/img/loading.gif" class="full-image" alt="Handler运行流程图" title="Handler运行流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span> <p><img src="/images/study_plan/handler_run_process.png" srcset="/img/loading.gif" alt="Handler运行流程"></p><p>工作流程：<strong>异步通信准备==&gt;消息入队==&gt;消息循环==&gt;消息处理</strong></p><ol><li><p><strong>异步通信准备</strong></p><blockquote><p>假定在主线程创建Handler，则会直接在主线程中创建<code>Looper</code>,<code>MessageQueue</code>和<code>Handler</code>对象。<strong>Looper和MessageQueue对象均属于其<code>创建线程</code>（由主线程创建则属于主线程）。</strong>创建<code>Looper</code>时会自动创建<code>MessageQueue</code>对象，创建好<code>MessageQueue</code>对象后，<code>Looper</code>自动进入循环。<code>Handler</code>自动绑定<code>Looper</code>以及<code>MessageQueue</code>。</p><p><code>Looper</code>对象的创建方法一般通过<code>Looper.prepareMainLooper()</code>和<code>Looper.prepare()</code>方法。</p></blockquote></li><li><p><strong>消息入队</strong></p><blockquote><p>工作线程通过<code>Handler</code>发送<code>Message</code>到<code>MessageQueue</code>中。消息内容一般是UI操作，通过<code>Handler.sendMessage(Message message)</code>或<code>Handler.post(Runable r)</code>发送。加入<code>MessageQueue</code>一般通过<code>MessageQueue.enqueueMessage(Message msg,long when)</code>操作。</p></blockquote></li><li><p><strong>消息循环</strong></p><blockquote><p>分为<strong>消息出队</strong>和<strong>消息分发</strong>两个步骤</p><ul><li>消息出队：<code>Looper</code>从<code>MessageQueue</code>中循环取出<code>Message</code></li><li>消息分发：<code>Looper</code>将取出的<code>Message</code>分发给创建消息的<code>Handler</code></li></ul><p><strong>消息循环过程中，<code>MessageQueue</code>为空，则线程堵塞</strong></p></blockquote></li><li><p><strong>消息处理</strong></p><blockquote><p><code>Handler</code>接受发过来的<code>Message</code>并处理。</p></blockquote></li></ol><h2 id="4-Handler使用过程的注意点"><a href="#4-Handler使用过程的注意点" class="headerlink" title="4. Handler使用过程的注意点"></a>4. Handler使用过程的注意点</h2><ol><li><p>在工作线程中创建自己的消息队列时必须要调用<code>Looper.prepare()</code>,并且<strong>在一个线程中只可以调用一次</strong>，然后需要调用<code>Looper.loop()</code>,开启消息循环。</p><blockquote><p>在开发过程中基本不会调用上述方法，因为默认会调用主线程的Looper，然后一个线程中只能有一个Looper对象和一个MessageQueue。</p></blockquote></li><li><p><strong>要注意Handler可能引起的内存泄漏</strong>(在下面会介绍到为何会引发泄漏)。</p><p>错误的写法:</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Handler mHandler = <span class="hljs-keyword">new</span> Handler()&#123;            <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;                    <span class="hljs-keyword">super</span>.handleMessage(msg);       &#125;    &#125;;</code></pre><p><strong>非静态的内部类和匿名内部类都会隐式的持有其外部类的引用，而静态内部类不会持有外部类的引用。</strong></p><p>正确的写法：</p><blockquote><p>继承<code>Handler</code>时候要么放在单独的类文件中，要么直接使用静态内部类。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//需要在静态内部类中调用外部类时，可以直接使用  `弱引用`  进行处理</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;MyActivity&gt; mWeakReference；    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHandler</span><span class="hljs-params">(MyActivity activity)</span></span>&#123;         mWeakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(activity);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerMessage</span><span class="hljs-params">(Message msg)</span></span>&#123;        <span class="hljs-keyword">super</span>.handlerMessage(msg);        MyActivity activity = mWeakReference.get();    &#125;&#125;<span class="hljs-comment">//调用方法</span><span class="hljs-keyword">private</span> MyHandler mHandler = <span class="hljs-keyword">new</span> MyHandler(<span class="hljs-keyword">this</span>);</code></pre></li></ol><h2 id="5-Handler源码解析"><a href="#5-Handler源码解析" class="headerlink" title="5. Handler源码解析"></a>5. Handler源码解析</h2><h3 id="1-创建循环器对象（Looper）和创建消息队列对象-MessageQueue"><a href="#1-创建循环器对象（Looper）和创建消息队列对象-MessageQueue" class="headerlink" title="1.创建循环器对象（Looper）和创建消息队列对象(MessageQueue)"></a>1.<strong>创建循环器对象（<code>Looper</code>）和创建消息队列对象(<code>MessageQueue</code>)</strong></h3><blockquote><p>创建Looper对象主要有两个方法：<code>Looper.prepareMainLooper()</code>和<code>Looper.prepare()</code></p><p>创建MessageQueue对象方法：<strong>创建Looper对象时会自动创建MessageQueue</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-comment">// 源码位置:../core/java/android/os/Looper.java</span><span class="hljs-keyword">final</span> MessageQueue mQueue;<span class="hljs-keyword">final</span> Thread mThread;<span class="hljs-comment">//Looper对象创建时会自动创建一个MessageQueue对象。</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Looper</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;     mQueue = <span class="hljs-keyword">new</span> MessageQueue(quitAllowed);     mThread = Thread.currentThread();    &#125;<span class="hljs-comment">//为当前线程(子线程)创建一个Looper对象 需要在子线程中主动调用该方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span> </span>&#123;        prepare(<span class="hljs-keyword">true</span>);    &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;    <span class="hljs-comment">//判断sThreadLocal是否为null，不为空则直接跑出异常 可以保证一个线程只可以调用一次prepare方法</span>    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Only one Looper may be created per thread"</span>);       &#125;    sThreadLocal.set(<span class="hljs-keyword">new</span> Looper(quitAllowed));    &#125;<span class="hljs-comment">//为主线程创建一个Looper对象 该方法会在主线程创建时自动调用</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareMainLooper</span><span class="hljs-params">()</span> </span>&#123;        prepare(<span class="hljs-keyword">false</span>);        <span class="hljs-keyword">synchronized</span> (Looper<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;            <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"The main Looper has already been prepared."</span>);            &#125;            sMainLooper = myLooper();        &#125;    &#125;</code></pre><p>总结：</p><ol><li><p>创建<code>Looper</code>对象时会自动创建<code>MessageQueue</code>对象</p></li><li><p>主线程的Looper对象是自动生成的，而子线程需要调用<code>Looper.prepare()</code>创建<code>Looper</code>对象</p><blockquote><p>创建主线程是调用了<code>ActivityThread</code>的<code>main()</code>方法。</p><p>然后按照流程调用了<code>Looper.prepareMainLooper()</code>和<code>Looper.loop()</code>。所以主线程不需要调用代码生成Looper对象。</p> <pre><code class="hljs java"><span class="hljs-comment">//源码位置: ../core/java/android/app/ActivityThread.java</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;     ...      Looper.prepareMainLooper();      Looper.loop();     ... &#125;</code></pre></blockquote></li><li><p>Handler的主要作用是(<code>在主线程更新UI</code>)，所以<strong>Handler主要是在主线程创建的</strong>。</p></li><li><p>Looper与Thread是通过<code>ThreadLocal</code>关联的。由于<code>ThreadLocal</code>是与线程直接关联的，参考<code>prepare()</code>。</p></li><li><p>子线程创建Handler对象:无法在子线程直接调用Handler无参构造方法<strong>Handler创建时需要绑定Looper对象</strong>  。需要使用<code>HandlerThread</code>。</p></li></ol><h3 id="2-开启Looper即消息循环"><a href="#2-开启Looper即消息循环" class="headerlink" title="2.开启Looper即消息循环"></a>2.<strong>开启Looper即消息循环</strong></h3><blockquote><p>创建了<code>Looper和MessageQueue</code>对象后，自动进入消息循环，使用<code>Looper.loop()</code>方法开始消息循环。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//源码位置：../core/java/android/os/Looper.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//现获取Looper实例，保证调用loop时已有Looper，否则抛出异常</span>    <span class="hljs-keyword">final</span> Looper me = myLooper();    <span class="hljs-keyword">if</span> (me == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);       &#125;    <span class="hljs-comment">//获取对应Looper实例创建的MessageQueue对象</span>    <span class="hljs-keyword">final</span> MessageQueue queue = me.mQueue;    ...     <span class="hljs-comment">//开启消息循环-无限循环   </span>     <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">//从MessageQueue取出Message对象</span>            Message msg = queue.next(); <span class="hljs-comment">// might block</span>            <span class="hljs-comment">//取出消息为null，则退出循环</span>            <span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// No message indicates that the message queue is quitting.</span>                <span class="hljs-keyword">return</span>;            &#125;         <span class="hljs-comment">//把Message分发给相应的target</span>         <span class="hljs-keyword">try</span> &#123;                msg.target.dispatchMessage(msg);                end = (slowDispatchThresholdMs == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : SystemClock.uptimeMillis();            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;                    Trace.traceEnd(traceTag);                &#125;            &#125;         <span class="hljs-comment">//释放消息占据的资源</span>          msg.recycleUnchecked();     &#125;&#125;</code></pre><p><code>loop()</code>方法是一个死循环，唯一跳出循环的方法是从<code>MessageQueue</code>获取的消息对象为空。</p><h3 id="3-创建Handler对象"><a href="#3-创建Handler对象" class="headerlink" title="3.创建Handler对象"></a><strong>3.创建Handler对象</strong></h3><blockquote><p>创建Handler对象即可以进行消息的发送与处理</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//源码位置：.../core/java/android/os/Handler.java </span><span class="hljs-comment">//Handler默认构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>); &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Callback callback, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;        <span class="hljs-keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;            <span class="hljs-keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();            <span class="hljs-keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="hljs-number">0</span>) &#123;                Log.w(TAG, <span class="hljs-string">"The following Handler class should be static or leaks might occur: "</span> +                    klass.getCanonicalName());            &#125;        &#125;        <span class="hljs-comment">//从当前线程的ThreadLocal获取Looper对象</span>        mLooper = Looper.myLooper();        <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                <span class="hljs-string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);        &#125;        <span class="hljs-comment">//获取当前Looper的消息队列</span>        mQueue = mLooper.mQueue;        mCallback = callback;        <span class="hljs-comment">//设置消息是否为异步处理方式</span>        mAsynchronous = async;    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Looper looper, Callback callback, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;        mLooper = looper;        mQueue = looper.mQueue;        mCallback = callback;        mAsynchronous = async;    &#125;</code></pre><p><code>Handler的无参构造方法会默认关联当前线程的Looper对象和MessageQueue对象，设置callback回调方法为null，且消息处理方式为同步处理。</code></p><h3 id="4-创建消息对象"><a href="#4-创建消息对象" class="headerlink" title="4.创建消息对象"></a><strong>4.创建消息对象</strong></h3><blockquote><p>Handler发送Message并且进入MessageQueue循环，创建方式分为两种<code>new Message()</code>和<code>Message.obtain()</code>。通常使用<code>Message.obtain()</code>。这种方式<strong>有效避免创建重复Message对象</strong>。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//创建消息对象</span>Message msg = Message.obtain();msg.what = <span class="hljs-number">1</span>;msg.obj = <span class="hljs-string">"test"</span>;<span class="hljs-comment">//源码位置 .../core/java/android/os/Message.java</span>    <span class="hljs-comment">/** Constructor (but the preferred way to get a Message is to call &#123;<span class="hljs-doctag">@link</span> #obtain() Message.obtain()&#125;).    */</span><span class="hljs-comment">//new Message 方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">()</span> </span>&#123;    &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object sPoolSync = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//维护一个Message池，用于复用Message对象</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message sPool;<span class="hljs-comment">//obtain方法 直接从池内获取Message对象，避免new占用内存</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title">obtain</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;            <span class="hljs-keyword">if</span> (sPool != <span class="hljs-keyword">null</span>) &#123;                Message m = sPool;                sPool = m.next;                m.next = <span class="hljs-keyword">null</span>;                m.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear in-use flag</span>                sPoolSize--;                <span class="hljs-comment">//直接从池中取出</span>                <span class="hljs-keyword">return</span> m;            &#125;        &#125;        <span class="hljs-comment">//无可复用对象，则重新new获取</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Message();    &#125;</code></pre><h3 id="5-发送消息-Message"><a href="#5-发送消息-Message" class="headerlink" title="5.发送消息(Message)"></a><strong>5.发送消息(Message)</strong></h3><blockquote><p>Handler主要有以下几种发送消息的方式:</p><ul><li><code>sendMessage(Message msg)</code></li><li><code>sendMessageDelayed(int what, long delayMillis)</code></li><li><code>post(Runnable r)</code></li><li><code>postDelayed(Runnable r, long delayMillis)</code></li><li><code>sendMessageAtTime(Message msg, long uptimeMillis)</code></li></ul><p>最终都是会调用到<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>然后继续调用到<code>enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</code>放入MessageQueue</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//源码位置：.../core/java/android/os/Handler.java </span><span class="hljs-comment">//post方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">post</span><span class="hljs-params">(Runnable r)</span>    </span>&#123;       <span class="hljs-keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="hljs-number">0</span>);    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postAtTime</span><span class="hljs-params">(Runnable r, <span class="hljs-keyword">long</span> uptimeMillis)</span>    </span>&#123;        <span class="hljs-keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postAtTime</span><span class="hljs-params">(Runnable r, Object token, <span class="hljs-keyword">long</span> uptimeMillis)</span>    </span>&#123;        <span class="hljs-keyword">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postDelayed</span><span class="hljs-params">(Runnable r, <span class="hljs-keyword">long</span> delayMillis)</span>    </span>&#123;        <span class="hljs-keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);    &#125;<span class="hljs-comment">//利用post()方式发送消息，需要转换为Message向下传递</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title">getPostMessage</span><span class="hljs-params">(Runnable r, Object token)</span> </span>&#123;        Message m = Message.obtain();        m.obj = token;        <span class="hljs-comment">//将runnable赋值到callback上 以便后续判断是post还是sendMessage方式发送的消息</span>        m.callback = r;        <span class="hljs-keyword">return</span> m;    &#125;<span class="hljs-comment">//sendMessage方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(Message msg)</span>    </span>&#123;        <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageDelayed</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> delayMillis)</span>    </span>&#123;        <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;            delayMillis = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);    &#125;<span class="hljs-comment">//所有的发送消息有关方法 都会调用到这个方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageAtTime</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;        <span class="hljs-comment">//获取MessageQueue对象 </span>        MessageQueue queue = mQueue;        <span class="hljs-comment">//获取对象为空 抛出异常</span>        <span class="hljs-keyword">if</span> (queue == <span class="hljs-keyword">null</span>) &#123;            RuntimeException e = <span class="hljs-keyword">new</span> RuntimeException(                    <span class="hljs-keyword">this</span> + <span class="hljs-string">" sendMessageAtTime() called with no mQueue"</span>);            Log.w(<span class="hljs-string">"Looper"</span>, e.getMessage(), e);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">//对象不为空 调用enqueueMessage方法</span>        <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);    &#125;<span class="hljs-comment">//该方法为了 向MessageQueue插入Message</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(MessageQueue queue, Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;        <span class="hljs-comment">// 把当前的Handler设置为 消息标记位 即把消息派发给相对应的Handler实例</span>        msg.target = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">if</span> (mAsynchronous) &#123;            msg.setAsynchronous(<span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-comment">//调用MessageQueue的enqueueMessage方法</span>        <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);    &#125;</code></pre><p>总结：</p><ul><li>发送消息时<code>Message.when</code>表示期望该消息被分发的时间即<code>SystemClock.uptimeMillis() + delayMillis</code>。<code>SystemClock.uptimeMills</code>代表自系统开机到调用到该方法的时间差。</li><li><code>Message.when</code>利用时间差来表达期望事件分发的时间，所以使用的是一个相对时间。</li><li>使用<code>sendMessageDelayed()</code>发送消息时，该消息会立即进入<code>MessageQueue</code>中，并标记<code>mBlocked</code>为true，阻塞线程。<code>MessageQueue</code>中是按照希望被分发时间排序的，时间越小排在越前。</li></ul><h3 id="6-消息入队"><a href="#6-消息入队" class="headerlink" title="6.消息入队"></a><strong>6.消息入队</strong></h3><p>发送消息最后调用到的是<code>MessageQueue.enqueueMessage()</code>将发送的消息加入到<code>MessageQueue</code>中</p><pre><code class="hljs java"><span class="hljs-comment">//源码位置：..core/java/android/os/MessageQueue.java</span><span class="hljs-comment">//内部是一个单链表有序序列，由 Message.when 作为排序依据，该值为一个相对时间。</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;    ...    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-comment">//正在退出 回收Message</span>            <span class="hljs-keyword">if</span> (mQuitting) &#123;                IllegalStateException e = <span class="hljs-keyword">new</span> IllegalStateException(                        msg.target + <span class="hljs-string">" sending message to a Handler on a dead thread"</span>);                Log.w(TAG, e.getMessage(), e);                msg.recycle();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            msg.markInUse();            msg.when = when;            Message p = mMessages;            <span class="hljs-keyword">boolean</span> needWake;            <span class="hljs-comment">// p == null判断当前队列中是否有消息，插入消息作为队列头 </span>            <span class="hljs-comment">// when == 0||when &lt; p.when 队列当前处于等待状态 唤醒队列</span>            <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;                <span class="hljs-comment">// New head, wake up the event queue if blocked.</span>                msg.next = p;                mMessages = msg;                needWake = mBlocked;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span>                <span class="hljs-comment">// up the event queue unless there is a barrier at the head of the queue</span>                <span class="hljs-comment">// and the message is the earliest asynchronous message in the queue.</span>                <span class="hljs-comment">//当前队列有消息，按照消息创建时间插入到队列中</span>                needWake = mBlocked &amp;&amp; p.target == <span class="hljs-keyword">null</span> &amp;&amp; msg.isAsynchronous();                Message prev;                <span class="hljs-comment">//从对列头部开始遍历</span>                <span class="hljs-keyword">for</span> (;;) &#123;                    prev = p;                    p = p.next;                    <span class="hljs-comment">//循环到队列尾部或者出现一个when小于当前Message的when</span>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-comment">//如果是异步消息 且 存在同步屏障</span>                    <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                        needWake = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//不需要唤醒 队列</span>                    &#125;                &#125;                msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span>                prev.next = msg;            &#125;            <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span>            <span class="hljs-keyword">if</span> (needWake) &#123;                nativeWake(mPtr);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;</code></pre><p>总结：</p><ul><li>新消息进入时，优先判定当前队列中是否有消息<ul><li>没有消息，则新进入消息放入队列头部</li><li>有消息，则对新消息以及原消息对列的头消息进行执行时间比较，若小于则置于队列头部</li></ul></li><li>消息进入消息队列后，会唤醒消息队列进行等待</li></ul><h3 id="7-获取消息"><a href="#7-获取消息" class="headerlink" title="7.获取消息"></a><strong>7.获取消息</strong></h3><blockquote><p>发送了消息后，MessageQueue维护了消息队列，在Looper中通过<code>loop()</code>不断获取Message。通过<code>next()</code>获取Message.</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//源码位置：..core/java/android/os/MessageQueue.java</span><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//该参数用于确定消息队列中是否有消息 下一个消息到来前需要等待的时长</span>    <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;     <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;                Binder.flushPendingCommands();            &#125;            <span class="hljs-comment">//该方法位于native层 若nextPollTimeoutMillis为-1 代表消息队列处于等待状态 阻塞操作</span>            nativePollOnce(ptr, nextPollTimeoutMillis);            ...            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                ...                 Message msg = mMessages;                 <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;                        <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>                        nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// Got a message.</span>                        mBlocked = <span class="hljs-keyword">false</span>;                        <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;                            prevMsg.next = msg.next;                        &#125; <span class="hljs-keyword">else</span> &#123;                            mMessages = msg.next;                        &#125;                        msg.next = <span class="hljs-keyword">null</span>;                        <span class="hljs-comment">//标记消息使用状态 flag |= FLAG_IN_USE</span>                        msg.markInUse();                        <span class="hljs-comment">//返回一条消息</span>                        <span class="hljs-keyword">return</span> msg;                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// No more messages.</span>                    nextPollTimeoutMillis = -<span class="hljs-number">1</span>;                &#125;                <span class="hljs-comment">//消息正在退出</span>                <span class="hljs-keyword">if</span> (mQuitting) &#123;                    dispose();                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                &#125;            &#125;     &#125;&#125;</code></pre><h3 id="8-分发消息"><a href="#8-分发消息" class="headerlink" title="8.分发消息"></a><strong>8.分发消息</strong></h3><blockquote><p>分发消息到对应的Handler实例并根据传入的Message做对应的操作</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//源码位置：.../core/java/android/os/Handler.java </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;        <span class="hljs-comment">//若callback不为空，则代表使用了post(Runnable r)方式发送了消息，执行handleCallback方法</span>        <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-keyword">null</span>) &#123;            handleCallback(msg);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//代表使用了sendMessage()方式发送了消息，调用handleMessage方法</span>            <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;                    <span class="hljs-keyword">return</span>;                &#125;            &#125;            handleMessage(msg);        &#125;    &#125;<span class="hljs-comment">//创建Handler实例时复写 自定义消息处理方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;    &#125;<span class="hljs-comment">//直接回调runnable对象的run()</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleCallback</span><span class="hljs-params">(Message message)</span> </span>&#123;        message.callback.run();    &#125;</code></pre><p>总结：</p><ul><li><code>msg.target.dispatchMessage(msg)</code>中<code>msg.target</code>指向的就是对应Handler实例，</li><li>消息分发的优先级：<ol><li>Message的回调方法<code>message.callback.run()</code></li><li>Handler中Callback的回调方法<code>mCallback,handleMessage(msg)</code></li><li>Handler的默认方法<code>handleMessage()</code></li></ol></li></ul><h3 id="9-Message回收"><a href="#9-Message回收" class="headerlink" title="9.Message回收"></a><strong>9.Message回收</strong></h3><blockquote><p>上面讲到了新建Message推荐使用<code>obtain()</code>，因为可以有效的复用消息，其中里面复用的就是<code>sPool</code>变量，它是在Message回收的时候进行赋值的。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//源码位置 .../core/java/android/os/Message.java</span><span class="hljs-comment">/*package*/</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isInUse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//正在使用 无法回收</span>        <span class="hljs-keyword">if</span> (isInUse()) &#123;            <span class="hljs-keyword">if</span> (gCheckRecycle) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"This message cannot be recycled because it "</span>                        + <span class="hljs-string">"is still in use."</span>);            &#125;            <span class="hljs-keyword">return</span>;        &#125;        recycleUnchecked();    &#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recycleUnchecked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Mark the message as in use while it remains in the recycled object pool.</span>        <span class="hljs-comment">// Clear out all other details.</span>        <span class="hljs-comment">//置为使用标记</span>        flags = FLAG_IN_USE;        what = <span class="hljs-number">0</span>;        arg1 = <span class="hljs-number">0</span>;        arg2 = <span class="hljs-number">0</span>;        obj = <span class="hljs-keyword">null</span>;        replyTo = <span class="hljs-keyword">null</span>;        sendingUid = -<span class="hljs-number">1</span>;        when = <span class="hljs-number">0</span>;        target = <span class="hljs-keyword">null</span>;        callback = <span class="hljs-keyword">null</span>;        data = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//将Message放在了列表里，缓存的对象由obtain()拿出来复用</span>        <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;            <span class="hljs-keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;                next = sPool;                sPool = <span class="hljs-keyword">this</span>;                sPoolSize++;            &#125;        &#125;    &#125;</code></pre><h3 id="10-Looper退出"><a href="#10-Looper退出" class="headerlink" title="10.Looper退出"></a><strong>10.Looper退出</strong></h3><blockquote><p><code>Looper.loop()</code>内部由一个无限循环组成，默认情况下不会退出循环。需要退出就需要调用<code>quit()</code>或者<code>quitSafely()</code>。</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//源码位置 .../core/java/android/os/Looper.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quit</span><span class="hljs-params">()</span> </span>&#123;        mQueue.quit(<span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quitSafely</span><span class="hljs-params">()</span> </span>&#123;        mQueue.quit(<span class="hljs-keyword">true</span>);    &#125;<span class="hljs-comment">//源码位置 .../core/java/android/os/MessageQueue.java</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> safe)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!mQuitAllowed) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Main thread not allowed to quit."</span>);        &#125;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">if</span> (mQuitting) &#123;                <span class="hljs-keyword">return</span>;            &#125;            mQuitting = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">if</span> (safe) &#123;                removeAllFutureMessagesLocked();            &#125; <span class="hljs-keyword">else</span> &#123;                removeAllMessagesLocked();            &#125;            <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting was previously false.</span>            <span class="hljs-comment">//唤醒等待线程</span>            nativeWake(mPtr);        &#125;    &#125;<span class="hljs-comment">//直接移除MessageQueue中的所有消息</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAllMessagesLocked</span><span class="hljs-params">()</span> </span>&#123;        Message p = mMessages;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;            Message n = p.next;            <span class="hljs-comment">//回收未被处理的消息</span>            p.recycleUnchecked();            p = n;        &#125;        <span class="hljs-comment">//由于消息为null 则return 出无限循环</span>        mMessages = <span class="hljs-keyword">null</span>;    &#125;<span class="hljs-comment">//直接移除未处理的消息 已经在执行的继续处理</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAllFutureMessagesLocked</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();        Message p = mMessages;        <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//还未处理的Message</span>            <span class="hljs-keyword">if</span> (p.when &gt; now) &#123;                removeAllMessagesLocked();            &#125; <span class="hljs-keyword">else</span> &#123;                Message n;                <span class="hljs-keyword">for</span> (;;) &#123;                    n = p.next;                    <span class="hljs-keyword">if</span> (n == <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-keyword">return</span>;                    &#125;                    <span class="hljs-keyword">if</span> (n.when &gt; now) &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                    p = n;                &#125;                <span class="hljs-comment">//不接收后续消息</span>                p.next = <span class="hljs-keyword">null</span>;                <span class="hljs-keyword">do</span> &#123;                    p = n;                    n = p.next;                    p.recycleUnchecked();                &#125; <span class="hljs-keyword">while</span> (n != <span class="hljs-keyword">null</span>);            &#125;        &#125;    &#125;</code></pre><h2 id="6-Handler异步消息与同步屏障"><a href="#6-Handler异步消息与同步屏障" class="headerlink" title="6. Handler异步消息与同步屏障"></a>6. Handler异步消息与同步屏障</h2><h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><p><code>Handler</code>构造函数</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Callback callback, <span class="hljs-keyword">boolean</span> async<span class="hljs-comment">/*是否异步*/</span>)</span> </span>&#123;       <span class="hljs-keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;           <span class="hljs-keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();           <span class="hljs-keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;                   (klass.getModifiers() &amp; Modifier.STATIC) == <span class="hljs-number">0</span>) &#123;               Log.w(TAG, <span class="hljs-string">"The following Handler class should be static or leaks might occur: "</span> +                   klass.getCanonicalName());           &#125;       &#125;       mLooper = Looper.myLooper();       <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-keyword">null</span>) &#123;           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(               <span class="hljs-string">"Can't create handler inside thread "</span> + Thread.currentThread()                       + <span class="hljs-string">" that has not called Looper.prepare()"</span>);       &#125;       mQueue = mLooper.mQueue;       mCallback = callback;       mAsynchronous = async;<span class="hljs-comment">//设置异步标志</span>   &#125;</code></pre><p><code>mAsynchronus</code>异步标志默认为<code>false</code>，在以下代码中使用</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(MessageQueue queue, Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;    msg.target = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">if</span> (mAsynchronous) &#123;        msg.setAsynchronous(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//设置异步消息</span>    &#125;    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);&#125;</code></pre><p>设置消息为<code>异步消息</code>有两种方式：</p><ul><li><code>new Handler(true)</code>：所有发出去的消息都会<code>setAsynchronous(true)</code><strong>对应方法都为@hide，不推荐使用</strong></li><li><code>msg.setAsynchonous(true)</code>：手动设置消息为异步</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>View的刷新(<code>Chorgographer</code>发送的都是异步消息)</li></ul><h3 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h3><blockquote><p><code>同步屏障</code>：挡住普通消息，使得<code>异步消息</code>可以被更快处理</p></blockquote><h4 id="添加同步屏障"><a href="#添加同步屏障" class="headerlink" title="添加同步屏障"></a>添加同步屏障</h4><pre><code class="hljs java"><span class="hljs-comment">//MessageQueue.java</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">postSyncBarrier</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">postSyncBarrier</span><span class="hljs-params">(<span class="hljs-keyword">long</span> when)</span> </span>&#123;        <span class="hljs-comment">// Enqueue a new sync barrier token.</span>        <span class="hljs-comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> token = mNextBarrierToken++;            <span class="hljs-comment">//没有赋值target，后面需要通过判断target == null，判断是否为同步屏障消息</span>            <span class="hljs-keyword">final</span> Message msg = Message.obtain();            msg.markInUse();            msg.when = when;            msg.arg1 = token;            Message prev = <span class="hljs-keyword">null</span>;            Message p = mMessages;            <span class="hljs-keyword">if</span> (when != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;                    prev = p;                    p = p.next;                &#125;            &#125;            <span class="hljs-comment">//插入同步屏障</span>            <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// invariant: p == prev.next</span>                msg.next = p;                prev.next = msg;            &#125; <span class="hljs-keyword">else</span> &#123;                msg.next = p;                mMessages = msg;            &#125;            <span class="hljs-keyword">return</span> token;<span class="hljs-comment">//用来取消同步屏障</span>        &#125;    &#125;</code></pre><p><code>同步屏障</code>也是消息的一种，特殊之处在于<code>target==null</code>。<code>target</code>表示了<code>消息需要分发的对象</code>，而<code>同步屏障</code>不需要被分发。而且不会唤醒<code>消息队列</code>。</p><p>上面有说到<a href="#7-获取消息">获取消息</a>通过<code>MessageQueue.next()</code></p><pre><code class="hljs java"><span class="hljs-comment">//MessageQueue.java</span><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span>        <span class="hljs-comment">// This can happen if the application tries to restart a looper after quit</span>        <span class="hljs-comment">// which is not supported.</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ptr = mPtr;        <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span>        <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;                Binder.flushPendingCommands();            &#125;            <span class="hljs-comment">//唤醒队列</span>            nativePollOnce(ptr, nextPollTimeoutMillis);            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();                Message prevMsg = <span class="hljs-keyword">null</span>;                Message msg = mMessages;                <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">//同步屏障，找到下一个 异步消息</span>                    <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span>                    <span class="hljs-keyword">do</span> &#123;                        prevMsg = msg;                        msg = msg.next;                    &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());                &#125;                <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;                        <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>                        nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// Got a message.</span>                        mBlocked = <span class="hljs-keyword">false</span>;                        <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;                          <span class="hljs-comment">//取出异步消息</span>                            prevMsg.next = msg.next;                        &#125; <span class="hljs-keyword">else</span> &#123;                            mMessages = msg.next;                        &#125;                        msg.next = <span class="hljs-keyword">null</span>;                        <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">"Returning message: "</span> + msg);                        msg.markInUse();                        <span class="hljs-keyword">return</span> msg;                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// No more messages.</span>                    nextPollTimeoutMillis = -<span class="hljs-number">1</span>;                &#125;                <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span>                <span class="hljs-keyword">if</span> (mQuitting) &#123;                    dispose();                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                &#125;               ...            &#125;           ...        &#125;    &#125;</code></pre><p><code>Looper</code>通过循环调用<code>MessageQueue.next()</code>不断获取队头的<code>message</code>，执行一个再去取下一个。当<code>next()</code>获取队头消息为<code>同步屏障</code>时，就会向后遍历队列，获取<code>异步消息</code>优先执行，如果没有找到<code>异步消息</code>，就会让<code>next()</code>进入阻塞状态，主线程也会处于<code>空闲状态</code>，直到有<code>异步消息</code>进入队列，或者<code>移除同步屏障</code>。</p><h4 id="移除同步屏障"><a href="#移除同步屏障" class="headerlink" title="移除同步屏障"></a>移除同步屏障</h4><p>添加完<code>同步屏障</code>后，如果一直都没有消息处理，主线程就会进入空闲状态并且无法处理其他普通消息，此时就需要移除<code>同步屏障</code>，保证正常的消息处理。</p><pre><code class="hljs java"><span class="hljs-comment">//MessageQueue.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeSyncBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> token)</span> </span>&#123;        <span class="hljs-comment">// Remove a sync barrier token from the queue.</span>        <span class="hljs-comment">// If the queue is no longer stalled by a barrier then wake it.</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            Message prev = <span class="hljs-keyword">null</span>;            Message p = mMessages;            <span class="hljs-comment">//根据token找到对应的 同步屏障消息，并移除</span>            <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; (p.target != <span class="hljs-keyword">null</span> || p.arg1 != token)) &#123;                prev = p;                p = p.next;            &#125;            <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"The specified message queue synchronization "</span>                        + <span class="hljs-string">" barrier token has not been posted or has already been removed."</span>);            &#125;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> needWake;            <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span>) &#123;                prev.next = p.next;                needWake = <span class="hljs-keyword">false</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                mMessages = p.next;                needWake = mMessages == <span class="hljs-keyword">null</span> || mMessages.target != <span class="hljs-keyword">null</span>;            &#125;            p.recycleUnchecked();            <span class="hljs-comment">// If the loop is quitting then it is already awake.</span>            <span class="hljs-comment">// We can assume mPtr != 0 when mQuitting is false.</span>            <span class="hljs-keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;                nativeWake(mPtr);            &#125;        &#125;    &#125;</code></pre><p>移除<code>同步屏障</code>消息后，再次唤醒消息队列。</p><h2 id="7-主线程的消息循环"><a href="#7-主线程的消息循环" class="headerlink" title="7. 主线程的消息循环"></a>7. 主线程的消息循环</h2><p>Android的主线程就是<code>ActivityThread</code>，主线程的入口方法为<code>main()</code>。</p><pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; ...        <span class="hljs-comment">//创建主线程的Looper对象</span>        Looper.prepareMainLooper();        ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();        thread.attach(<span class="hljs-keyword">false</span>);        <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;            sMainThreadHandler = thread.getHandler();        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>) &#123;            Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span>                    LogPrinter(Log.DEBUG, <span class="hljs-string">"ActivityThread"</span>));        &#125;        <span class="hljs-comment">// End of event ActivityThreadMain.</span>        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        <span class="hljs-comment">//该方法后 不能在写方法因为会被阻塞  开启主线程的消息循环</span>        Looper.loop();&#125;<span class="hljs-comment">//主要处理四大组件的启动和停止等过程</span> <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;  ...    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;     ...     <span class="hljs-comment">//处理主线程消息</span>    &#125; &#125;</code></pre><blockquote><p>主线程间的消息循环模型：</p></blockquote><p><code>ActivityThread</code>通过<code>ApplicationThread</code>和<code>AMS(ActivityManagerService)</code>进行进程间通信，<code>AMS</code>以进程间通信的方式完成<code>ActivityThread</code>的请求后回调<code>ApplicationThread</code>中的<code>Binder()</code>，然后<code>ApplicationThread</code>向<code>ActivityThread.H</code>发送消息，<code>H</code>收到消息后会把<code>ApplicationThread</code>中的逻辑切换到<code>ActivityThread</code>中去执行，这时就切换到了主线程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android中的GC分析-Dalvik和ART虚拟机</title>
    <link href="/2018/05/13/Android%E4%B8%AD%E7%9A%84GC%E5%88%86%E6%9E%90-Dalvik%E5%92%8CART%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2018/05/13/Android%E4%B8%AD%E7%9A%84GC%E5%88%86%E6%9E%90-Dalvik%E5%92%8CART%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<!--如何对JVM进行优化 class文件如何转成dex文件--><h2 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h2><blockquote><p><code>Dalvik Virtual Machine</code>，简称Dalvik VM或者 DVM。DVM是Google专门为Android平台开发的虚拟机，是Android的重要组成部分，支持<code>dex格式</code>的Java应用程序运行。</p><p><code>dex格式</code>是专门为DVM设计的一种压缩格式，适合内存和处理器速度有限的系统。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Android系统架构图.jpg" srcset="/img/loading.gif" class="full-image" alt="Android系统架构图" title="Android系统架构图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>从架构图中可知，DVM运行在Android的运行时库层。</p><h3 id="DVM与JVM的区别"><a href="#DVM与JVM的区别" class="headerlink" title="DVM与JVM的区别"></a>DVM与JVM的区别</h3><h4 id="基于的架构不同"><a href="#基于的架构不同" class="headerlink" title="基于的架构不同"></a>基于的架构不同</h4><p>JVM是基于栈的，意味着需要去栈中读写数据，所需的指令会更多，会导致速度变慢，不适用于性能有限的移动设备。</p><p>DVM是基于寄存器的，不会有基于栈的虚拟机在复制数据时，使用大量的出入栈指令，同时指令更紧凑，简洁。</p><h4 id="执行的字节码不同"><a href="#执行的字节码不同" class="headerlink" title="执行的字节码不同"></a>执行的字节码不同</h4><p>Java类被编译成一个或多个.class文件，并打包成jar文件，JVM通过对应的.class和jar文件获取相应的字节码。</p><p><strong>执行顺序为： .java文件 -&gt; .class文件 -&gt; .jar文件</strong></p><p>DVM运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个dex文件中。DVM通过dex文件执行字节码。</p><p><strong>执行顺序为： .java文件 -&gt; .class文件 -&gt; .dex文件</strong></p><p><strong>dex文件体积小。Android SDK中有一个<code>dx</code>工具将Java字节码转换为Dalvik字节码。</strong></p><p>dx工具对Java类文件重新排序，消除在类文件中出现的所有冗余信息，避免虚拟机在初始化时反复进行文件加载与解析。<strong>消除其中的冗余信息，重新组合成一个常量池，所有类文件共享同一个常量池。由于dx工具对常量池的压缩，使得相同的字符串，常量在dex文件中只出现一次，从而减小文件体积。并把所有的.class文件整合到.dex文件中，减少了I/O操作，加快类查找速度。</strong></p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/执行的字节码区别.png" srcset="/img/loading.gif" class="full-image" alt="执行的字节码区别" title="执行的字节码区别"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>简单来讲，dex格式文件就是将多个class文件中共有的部分统一存放，取出冗余信息。</p><h4 id="DVM允许在有限的内存中同时允许多个进程"><a href="#DVM允许在有限的内存中同时允许多个进程" class="headerlink" title="DVM允许在有限的内存中同时允许多个进程"></a>DVM允许在有限的内存中同时允许多个进程</h4><p>在Android中的每一个应用都运行在一个DVM实例中，每一个DVM实例都运行在一个独立的进程空间中，独立的进程可以防止在虚拟机崩溃时导致所有程序关闭。</p><h4 id="DVM由Zygote创建和初始化"><a href="#DVM由Zygote创建和初始化" class="headerlink" title="DVM由Zygote创建和初始化"></a>DVM由Zygote创建和初始化</h4><p>每当系统需要创建一个应用程序时，Zygote就会fork自身，快速的创建和初始化一个DVM实例，用于应用程序的运行。</p><h4 id="DVM拥有共享机制"><a href="#DVM拥有共享机制" class="headerlink" title="DVM拥有共享机制"></a>DVM拥有共享机制</h4><p>不同应用之间可以在运行时共享相同的类，拥有更高的效率。JVM不支持这种共享机制，不同的程序都是彼此独立的。</p><h4 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h4><p><code>Just In Time Compiler</code>即时编译器，从Android2.2开始支持了<code>JIT</code>。</p><p><em>JIT会对多次运行的代码进行编译，生成相当精简的本地机器码，这样在下次执行相同的逻辑时，直接使用编译之后的本地机器码，而不是每次都需要编译。</em></p><p><strong>每次重新打开应用程序，都需要JIT编译。</strong></p><h3 id="DVM架构"><a href="#DVM架构" class="headerlink" title="DVM架构"></a>DVM架构</h3><p>DVM源码位于dalvik/目录下。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/DVM架构.png" srcset="/img/loading.gif" class="full-image" alt="DVM架构" title="DVM架构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>首先Java编译器的.class文件经过<code>DX工具</code>转换为.dex文件，.dex文件由类加载器进行处理，接着解释器根据指令集对Dalvik字节码进行解释、执行，最后交于Linux处理。</p><h3 id="DVM运行时堆"><a href="#DVM运行时堆" class="headerlink" title="DVM运行时堆"></a>DVM运行时堆</h3><p>DVM运行时堆使用<strong>标记-清除</strong>算法进行GC，它由两个Space以及多个辅助数据结构组成，两个Space分别是<code>Zygote Space(Zygote Heap)</code>和<code>Allocation Space(Active Heap)</code>。</p><p><code>Zygote Space</code>用来管理Zygote进程在启动过程中预加载和创建的各种对象，<code>Zygote Space</code>不会触发GC。所有进程都共享该区域，比如系统资源。</p><p><code>Allocation Space</code>是在Zygote进程fork第一个子进程之前创建的，它是一种私有进程，Zygote进程及fork的子进程在<code>Allocation Space</code>进行对象分配和释放。</p><p>还有以下数据结构：</p><p><code>Card Table</code>：记录垃圾信息</p><p><code>Heap Bitmap</code>：用来记录上次GC存活的对象，另一个用来记录这次GC存活的对象</p><p><code>Mark Stack</code>：遍历存活的对象。</p><h3 id="DVM-GC过程"><a href="#DVM-GC过程" class="headerlink" title="DVM-GC过程"></a>DVM-GC过程</h3><ol><li>当GC被触发的时候，会去查找所有活动的对象，这个时候整个程序与虚拟机内部的所有线程就会挂起，可以在较少的堆栈里找到所引用的对象。<strong>回收动作和应用程序是同时执行的(非并发执行)。</strong></li><li>GC对符合条件的对象进行标记</li><li>GC对标记的对象进行回收</li><li>恢复所有线程的执行现场继续执行</li></ol><p>GC的执行会相当快速，但如果出现频繁GC并且内存资源少，就会导致UI卡顿，掉帧。因为是和应用程序同时执行的。</p><h2 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h2><blockquote><p>ART虚拟机是在Android4.4发布的，用来替换Dalvik虚拟机。5.0之后默认采用ART虚拟机。</p></blockquote><h3 id="ART和DVM的区别"><a href="#ART和DVM的区别" class="headerlink" title="ART和DVM的区别"></a>ART和DVM的区别</h3><ol><li><p>DVM每次运行应用时，字节码都需要JIT编译器译为机器码，会使得应用程序运行效率降低。在ART中采用<strong>AOT(ahead of time Compilation，预编译)</strong>，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行就不需要执行编译了，大大提升运行效率。</p><p><code>AOT</code>优点：</p><ul><li>系统性能提升明显</li><li>应用启动更快，体验更流畅</li><li>设备的耗电量降低</li></ul><p><code>AOT</code>缺点：</p><ul><li>使得应用程序安装时间变长，尤其是复杂的应用</li><li>由于字节码预先编译成机器码，机器码需要的存储空间会多一些，会占用较多的存储空间</li></ul><p>在Android 7.0中加入了<code>JIT</code>，不会把字节码全部编译成机器码，而是在运行中将热点代码编译成机器码。从而缩短安装时间及减少安装空间。</p></li><li><p>DVM是为32位CPU设计的，而ART支持64位并兼容32位</p></li><li><p>ART对GC进行了改进，比如更频繁的执行并行垃圾收集，减少GC暂停次数</p></li><li><p>ART的运行时堆空间划分和DVM不同。</p></li></ol><h3 id="ART的运行时堆"><a href="#ART的运行时堆" class="headerlink" title="ART的运行时堆"></a>ART的运行时堆</h3><p>ART的GC类型有多种，主要分为<code>Mark-Sweep GC(标记-整理)</code>和<code>Compacting GC()</code>。ART运行时堆得空间根据不同的GC类型也有不同的划分，默认采用CMS方案。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ART运行时堆.png" srcset="/img/loading.gif" class="full-image" alt="ART运行时堆" title="ART运行时堆"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="ART-GC过程-提高内存使用，减少碎片化"><a href="#ART-GC过程-提高内存使用，减少碎片化" class="headerlink" title="ART-GC过程 - 提高内存使用，减少碎片化"></a>ART-GC过程 - 提高内存使用，减少碎片化</h3><ol><li>GC将会锁住Java堆，扫描并进行标记</li><li>标记完毕释放Java堆的锁，并且挂起所有线程</li><li>GC对标记的对象进行回收</li><li>恢复所有线程的执行线程继续运行</li><li>重复步骤2-4直到结束</li></ol><p>Art改善了GC过程：<strong>将其非并发过程改成了部分并发，还有就是堆内存的重新分配管理。</strong></p><p>DVM内存管理特点：<strong>内存碎片化严重，这也是由于标记-清除算法导致的。</strong></p><p>ART的解决方案：在ART中，它将Java分了一块空间<code>Large Object Space</code>，专门用来存放大对象。同时ART引入了<code>moving collector</code>技术，将不连续的物理内存块进行对其，对齐后碎片问题得到了很好的解决。</p><p>使用<code>Large Object Space</code>是因为<code>moving collector</code>对大块内存的位移时间过长，需要降低时间并提高内存利用率。</p><h3 id="Apk打包流程"><a href="#Apk打包流程" class="headerlink" title="Apk打包流程"></a>Apk打包流程</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/android_apk_build.png" srcset="/img/loading.gif" class="full-image" alt="android_apk_build" title="android_apk_build"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据流程图可知，apk打包流程分为7步：</p><ol><li>通过aapt打包res资源文件，生成<code>R.java、resource.asrc,res文件</code></li><li>处理.aidl文件，生成对应的Java接口文件</li><li>通过Java Compiler编译R.java、Java源文件，生成.class文件</li><li>通过 dx工具，将.class文件以及三方库中的.class文件合并生成 classes.dex</li><li>通过apkbuilder工具，将aapt生成的resource.arsc和res文件、assets文件以及classes.dex一起打包生成apk</li><li>通过Jarsigner工具，对上面的apk进行debug或release签名</li><li>通过Zipalign工具，将签名后的apk进行对齐处理。(<em>帮助操作系统更高效率的根据请求索引资源，按着有利于系统处理的方式对apk征用的资源文件进行排列</em>)</li></ol><h3 id="Apk安装流程"><a href="#Apk安装流程" class="headerlink" title="Apk安装流程"></a>Apk安装流程</h3><p>Apk开始安装时会执行以下几步：<em>(例如安装包名为 com.example.wxy 应用名为Demo的apk)</em></p><ul><li><p>解析APK中的<code>AndroidManifest.xml</code>，解析的内容会被存储到<code>/data/system/packages.xml</code>和<code>/data/system/package.list</code>中。</p></li><li><p><code>packages.list</code>中会指名了该apk包应用的默认存储的位置<code>/data/data/com.example.wxy</code>,<code>package.xml</code>会包含该应用申请的全新，签名和代码所在位置等信息</p><pre><code class="hljs xml">/data/system/packages.listcom.example.wxy.ipc 10021 1 /data/user/0/com.example.wxy.ipc default:targetSdkVersion=28 3003</code></pre><pre><code class="hljs xml"> /data/system/packages.xml   <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.example.wxy.ipc"</span> <span class="hljs-attr">codePath</span>=<span class="hljs-string">"/data/app/com.example.wxy.ipc-OTMEWujgopdNrmJevxTbaA=="</span> <span class="hljs-attr">nativeLibraryPath</span>=<span class="hljs-string">"/data/app/com.example.wxy.ipc-OTMEWujgopdNrmJevxTbaA==/lib"</span> <span class="hljs-attr">publicFlags</span>=<span class="hljs-string">"810073926"</span> <span class="hljs-attr">privateFlags</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">ft</span>=<span class="hljs-string">"1673c5a86e8"</span> <span class="hljs-attr">it</span>=<span class="hljs-string">"1673ae27837"</span> <span class="hljs-attr">ut</span>=<span class="hljs-string">"1673c5a8ab8"</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">"10021"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">sigs</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">schemeVersion</span>=<span class="hljs-string">"2"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">cert</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"15"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">sigs</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">perms</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android.permission.INTERNET"</span> <span class="hljs-attr">granted</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">flags</span>=<span class="hljs-string">"0"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"android.permission.ACCESS_NETWORK_STATE"</span> <span class="hljs-attr">granted</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">flags</span>=<span class="hljs-string">"0"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.example.wxy.permission.checkBook"</span> <span class="hljs-attr">granted</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">flags</span>=<span class="hljs-string">"0"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">perms</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">proper-signing-keyset</span> <span class="hljs-attr">identifier</span>=<span class="hljs-string">"16"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span></code></pre><p>标记了一个<code>userId</code>，Android系统可以利用该值来管理应用</p></li><li><p>根据<code>packages.xml</code>指定的<code>codePath</code>，创建一个目录，apk被命名为<code>base.apk</code>并拷贝到此，其中lib目录用在存放native库。</p></li><li><p>此时应用就可以运行了。为了提升效率，Android系统在应用安装时还会做些优化操作，把所有可运行的dex文件单独提取放在一块并做些优化。</p><ul><li>在DVM时，会使用dexopt把base.apk中的dex文件优化为odex，存储在<code>/data/dalvik-cache</code>中.</li><li>在ART时，则会使用dex2oat优化成oat文件也存储在该目录下，并且文件名一样，但是文件会大很多，因为ART会把dex优化成机器码，所以运行更快。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Study-Plan-XV -- 四大组件</title>
    <link href="/2018/05/13/Android-Study-Plan-XV/"/>
    <url>/2018/05/13/Android-Study-Plan-XV/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><h2 id="Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？"><a href="#Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？" class="headerlink" title="Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？"></a>Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？</h2><h3 id="Android四大组件："><a href="#Android四大组件：" class="headerlink" title="Android四大组件："></a>Android四大组件：</h3><ol><li><p><strong><code>Activity</code></strong></p><blockquote><p>Activity的主要作用是展示一个界面并和用户直接交互。</p></blockquote><p>activity的启动由Intent触发（<strong>需要在AndroidManifest.xml中注册</strong>）。Intent分为两种：</p><ul><li><p>显示Intent：直接跳转至指定的Activity类</p><pre><code class="hljs java"><span class="hljs-comment">// 构造方法中直接传入Component</span>Intent intent=<span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,Activity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;startActivity(intent);<span class="hljs-comment">// 调用SetComponent方法</span>ComponentName componentName=<span class="hljs-keyword">new</span> Component(<span class="hljs-keyword">this</span>,Activity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;Intent intent=<span class="hljs-keyword">new</span> Intent();intent.setComponentName(componentName);startActivity(intent);<span class="hljs-comment">// 使用setClass方法</span>Intent intent=<span class="hljs-keyword">new</span> Intent();intent.setClassName(<span class="hljs-keyword">this</span>,Activity<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;startActivity(intent);</code></pre></li><li><p>隐式Intent：不明确指定启动哪个Activity，而是利用Activity配置的Action，Data，Category来让系统进行选择(<code>筛选是根据所有的&lt;intent-filter&gt;来筛选</code>)</p><pre><code class="hljs java"> &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="TestActivity" /&gt;                &lt;category android:name="android.intent.category.DEFAULT" /&gt;            &lt;/intent-filter&gt;&lt;/activity&gt;// setAction方法Intent intent=new Intent();intent.setAction("TestActivity");startActivity(intent);//直接构造ActionIntent intent=new Intent("TestActivity");startActivity(intent);//在使用隐式调用时需要注意该Action是否存在,所以需要做try-catch防止异常发生//利用这个方法可以判断是否有处理该Action的Activity存在intent.resolveActivity(getPackageManager())</code></pre></li></ul></li><li><p><strong><code>Service</code></strong></p><p>Service主要用于在后台执行一系列需要耗时的任务，需要单独的线程去完成，因为Service本身是运行在主线程的。Service不会与UI进行交互，其他的组件也可以启动Service，即便用户切换了应用，Service依然后台运行。（<strong>需要在AndroidManifest.xml中注册</strong>），Service有两种启动方式：</p><ul><li><code>startService</code>：启动一个Service，系统回调<code>onStartCommand()方法</code>，需要调用<code>stopService()</code>来停止Service</li><li><code>bindService</code>：绑定一个Service，调用<code>unBindService()</code>来取消绑定，或者关闭绑定的组件也可以停止</li></ul></li><li><p><strong><code>BroadcastReceiver</code></strong></p><p><a href="https://www.jianshu.com/p/ca3d87a4cdf3" target="_blank" rel="noopener">完整介绍</a></p><p>广播主要用于在不同的组件甚至不用的应用间进行消息传递，不与用户产生交互，工作在系统内部。</p><p>广播的注册方式有两种：</p><ul><li><p>静态注册 （<strong>需要在AndroidManifest.xml中注册</strong>）</p><pre><code class="hljs xml">&lt;receiver android:name=".MyReceiver"          android:enabled=["true" | "false"]&lt;!--此broadcastReceiver能否接收其他App的发出的广播--&gt;//默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false    android:exported=["true" | "false"]    android:label="string resource"&lt;!--具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收--&gt;    android:permission="string"          &gt;&lt;intent-filter&gt;    &lt;action android:name="com.test"/&gt;&lt;/intent-filter&gt;&lt;/receiver&gt;</code></pre></li><li><p>动态注册</p><pre><code class="hljs java"><span class="hljs-comment">//最好在onResume中注册广播  </span><span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">super</span>.onResume();            mBroadcastReceiver=<span class="hljs-keyword">new</span> BroadcastReceiver();      IntentFilter intentFilter=<span class="hljs-keyword">new</span> IntentFilter();      intentFilter.addAction(<span class="hljs-string">"com.test"</span>);      <span class="hljs-keyword">this</span>.registerReceiver(mBroadcastReceiver,intentFilter);  &#125;<span class="hljs-comment">//在onPause中取消注册</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">super</span>.onPause();        <span class="hljs-keyword">this</span>.unregisterReceiver(mBroadcastReceiver);&#125;</code></pre></li></ul></li><li><p><strong><code>ContentProvider</code></strong></p><p><a href="https://www.jianshu.com/p/ea8bc4aaf057" target="_blank" rel="noopener">相关链接</a></p><p>主要用于给不同的应用提供共享数据,（<strong>需要在AndroidManifest.xml中注册</strong>）</p><pre><code class="hljs xml">&lt;provider           android:name="wxy.provider.MyContentProvider"          android:authorities="wxy.provider"          android:exported="true"           &lt;!--是否可被其他应用使用 --&gt;          &gt;&lt;/provider&gt;</code></pre><p>ContentProvider默认执行在主线程，需要实现以下方法</p><ul><li><code>onCreate()</code>：初始化Provider</li><li><code>query()</code>：查询数据 <strong>需异步操作</strong></li><li><code>insert()</code>：插入数据</li><li><code>update()</code>：更新Provider的数据</li><li><code>delete()</code>：删除Provider的数据</li><li><code>getType()</code>：返回指定Uri中的数据MIME类型</li></ul><p>相关的操作可能会被多个线程并发调用需要注意线程安全。</p></li></ol><h3 id="开启多进程"><a href="#开启多进程" class="headerlink" title="开启多进程"></a>开启多进程</h3><p>Android的四大组件都可以开启多进程，只要在AndroidManifest.xml中配置<code>android:process=&quot;any&quot;</code>，需要配置<code>android:exported</code>属性</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关及其拓展(五) -- Java内存模型</title>
    <link href="/2018/05/09/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%94/"/>
    <url>/2018/05/09/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><blockquote><p>屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到的一致的内存访问效果。</p></blockquote><p>主要目标：</p><p><strong>定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。变量包括了实例字段、静态字段和构成对象的元素，但不包括局部变量和方法参数（他们为线程私有，不被共享）。</strong></p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Java内存模型.png" srcset="/img/loading.gif" class="full-image" alt="Java内存模型" title="Java内存模型"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><blockquote><p>Java内存模型规定了所有的变量都存储在<code>主内存(Main Memory)</code>中，每条线程还有自己的<code>工作内存(Work Memory)</code>。工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取，赋值等)必须在工作内存中进行，不能直接读取主内存的变量。<strong>不同线程之间也无法直接访问对方工作内存中的变量，线程间传递变量均需通过主内存完成。</strong></p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/JVM-JMM.png" srcset="/img/loading.gif" class="full-image" alt="线程-主内存-工作内存的交互关系" title="线程-主内存-工作内存的交互关系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。</p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><blockquote><p>关于主内存与工作内存具体的交互协议，<strong>即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，JMM中定义了8种操作来完成.</strong></p><p><code>每种操作都是原子、不可再分</code></p></blockquote><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Lock(锁定)</td><td>作用于主内存的变量，把一个变量表示为一条线程独占的状态</td></tr><tr><td>Unlock(解锁)</td><td>作用于主内存的变量，把一个锁定状态的变量释放出来</td></tr><tr><td>Read(读取)</td><td>作用于主内存的变量，一个变量值从主内存传输到线程的工作内存中</td></tr><tr><td>Load(载入)</td><td>作用于工作内存的变量，从read操作中得到的值放入工作内存的变量副本中</td></tr><tr><td>Use(使用)</td><td>作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行</td></tr><tr><td>Assign(赋值)</td><td>作用于工作内存的变量，把接收到的值赋值给工作内存中的变量，遇到需要赋值的情况会执行</td></tr><tr><td>Store(存储)</td><td>作用于工作内存的变量，把工作内存中的变量值传到主内存中</td></tr><tr><td>Write(写入)</td><td>作用于主内存的变量，把store操作中得到的工作内存中的变量的值放入主内存的变量中</td></tr></tbody></table><blockquote><p>如果要把一个变量从主内存复制到工作内存，就要顺序执行<code>read</code>和<code>load</code>操作，如果要从工作内存同步回主内存，就要顺序的执行<code>store</code>和<code>write</code>操作。</p></blockquote><h2 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h2><blockquote><p>Java内存模型就是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。这也是并发编程的三大概念。</p></blockquote><h3 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h3><blockquote><p><strong>对基本数据类型的读取和赋值都是原子操作</strong>，所谓原子性操作就代指这些<strong>操作是不可中断</strong>的，要么做完，要么就不执行。</p></blockquote><p>Java内存模型只保证了基本读取和赋值是原子操作。如果要实现更大范围操作的原子性，就需要通过<code>synchronized</code>和<code>lock</code>实现。</p><blockquote><p> Java中的原子操作包括：</p><ul><li>除long和double之外的基本数据类型赋值操作 <em>long和double占用的字节数是8即64bit，在32位操作系统上去读写数据需要两步完成，每一步取32位数据。需要添加volatile关键字保证</em></li><li>所有引用reference的赋值操作</li><li><code>java.concurrent.Atomic.*</code> 包下所有类的操作</li></ul></blockquote><h3 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性(Visibility)"></a>可见性(Visibility)</h3><blockquote><p>当一个线程修改了共享变量的值，其他线程能够立即得知这个值的修改。</p></blockquote><p>Java内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式实现可见性。</p><p><strong>当一个共享变量被volatile修饰时，他会保证修改的值会立即更新到主内存，当有其他线程需要读取时，会立即从主内存中读取新值。</strong></p><p>通过<code>synchronized</code>和<code>lock</code>也可保证可见性，<strong>保证同一时刻只有一个线程获取锁然后执行代码，并且在释放锁之前会将变量的修改刷新到主内存中，保证可见性。</strong></p><p>拓展：<code>final</code>也可以实现可见性，final修饰字段一旦初始化完成，在其他线程中就可以看到fianl的值。</p><h3 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性(Ordering)"></a>有序性(Ordering)</h3><blockquote><p>程序执行的顺序按照代码的先后顺序执行</p></blockquote><p>Java内存模型允许编译器和处理器对指令进行重排序，但是规定了<code>as-if-serial</code>（不管怎么重排序，程序的执行结果不能改变）。</p><p><strong>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</strong></p><p><code>volatile</code>本身包含了禁止指令重排序的语义，而<code>synchronized</code>通过<strong>一个变量在同一个时刻只允许一条线程对其lock操作</strong>实现有序性。</p><p><strong><em>要想并发程序正确的执行，必须要保证原子性、可见性和有序性，只要有一个没有被保证，就有可能导致程序运行不正确。</em></strong></p><h2 id="先行发生原则-happens-before"><a href="#先行发生原则-happens-before" class="headerlink" title="先行发生原则(happens-before)"></a>先行发生原则(happens-before)</h2><blockquote><p>JMM具备一些先天的<code>有序性</code>。<strong>不需要通过任何手段就可以保证有序性，称之为<code>先行发生原则</code>。如果两个操作的执行次序无法从先行发生原则推导出来，他们之间就没有顺序性保障，就不能保证有序性。</strong></p></blockquote><p>主要有以下规则：</p><ul><li><strong>程序次序规则</strong>：写在前面的代码先行发生于写在后面的(按照控制流顺序而不是代码顺序)</li><li><strong>管程锁定规则</strong>：一个解锁操作先行于时间后面发生的同一个线程的加锁操作</li><li><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于读操作</li><li><strong>线程启动规则</strong>：Thread对象的<code>start()</code>优先于该线程的任意操作</li><li><strong>传递性</strong>：如果操作A早于B，B又早于C，则A早于C</li><li><strong>线程中断规则</strong>：线程<code>interrupt()</code>调用早于该线程的中断检测。<code>Thread.interrupted()</code></li><li><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检测。<code>Thread.join()或者Thread.isAlive()</code></li><li><strong>对象终结规则</strong>：一个对象的初始化完成早于<code>finalize()</code></li></ul><p><a href="https://www.v2ex.com/t/671776#reply21" target="_blank" rel="noopener">JMM相关讨论</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--HashMap实现原理及解析</title>
    <link href="/2018/05/09/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
    <url>/2018/05/09/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<!--主要是对HashMap，ArrayMap，ConcurrentHashmap--><!-- HashMap和HashTable的区别 , HashMap和ConcurrentHashMap的区别，HashMap的底层源码,HashMap的原理,ConcurrentHashMap，ArrayMap,SparseArray,hashmap线程不安全，请问为什么线程不安全？答，并发时会成环。什么时候成环？比如我有两个数据要装入hashmap。hashset和hashmap的区别，写代码使用hashmap实现一个简单的hashset。--><!-- https://juejin.im/post/59e86f9351882521ad0f4147, https://juejin.im/post/5a7592f4f265da4e8d42ded2 --><!-- hashmap实现的数据结构，数组、桶等。hashmap的哈希冲突解决方法：拉链法等。拉链法的优缺点。hashmap的参数及影响性能的关键参数：加载因子和初始容量。Resize操作的过程。hashmap容量为2次幂的原因。hashtable线程安全、synchronized加锁。hashtable和hashmap异同。为什么hashtable被弃用？--><!--关于HashMap扩容，1.8之前，如果不发生Hash冲突不会触发扩容，1.8之后，只要HashMap中的元素个数大于阈值，就发生扩容。（欢迎纠正）expectedSize / 0.75F + 1.0F  equals 和 hashcode 关系,HashMap遍历原理 --><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HashMap结构.png" srcset="/img/loading.gif" class="full-image" alt="HashMap基础结构" title="HashMap基础结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="HashMap定义"><a href="#HashMap定义" class="headerlink" title="HashMap定义"></a>HashMap定义</h2><p><code>HashMap</code>是基于<code>Map</code>接口实现的一种<code>键-值对&lt;key,value&gt;</code>的存储结构。内部允许<code>null</code>值，同时非有序，非同步(<em>线程不安全</em>)。它存储和查找数据时，是根据<code>key</code>的<code>hashcode</code>计算出具体的存储位置。内部最多允许一条记录的<code>key</code>为<code>null</code>。</p><p><code>HashMap</code>的底层实现是<strong>数组+链表+红黑树(Java 8新增的)</strong>。</p><ul><li><p>数组是HashMap的主体  <em>所以HashMap的容量指的就是 数组的长度。HashMap的size指的就为存储键值对数量。</em></p></li><li><p>链表主要为了解决<code>Hash冲突</code>而存在的</p><blockquote><p>常用解决Hash冲突的方法有四种：</p><ul><li><code>开放地址法--线性探测</code> ：一般是在散列函数的基础上采取另一种算法，从而找到下一个空的数组位置，再将新数据填充进去。从而有效利用原数组空间。<strong>若整个空间都找不到空余的地址，则产生溢出。</strong></li><li><code>链地址法（拉链法）</code>：基本思路是<code>全部具有同样哈希地址的而不同的Key的数据元素连接到同一个链表中</code>。加入在某个位置发生<code>Hash冲突</code>，就将新数据以链表的形式接在已有数据的后面。<strong>HashMap1.7 是头插法，冲突的数据放在链表前端；HashMap在1.8之后是尾插法，冲突的数据放在链表尾端。</strong><ul><li>优点：无堆积现象存在，平均查找长度较短；节点空间是动态申请的，适用于无法缺点表长的情况；装填因子较大时，拉链法中增加的指针空间可忽略不计；删除节点的操作易于实现。</li><li>缺点：指针需要额外的空间。</li></ul></li><li><code>再哈希法</code>：同时构造多个不同的hash函数，直到不出现冲突为止。</li><li><code>建立公共溢出区</code>：将哈希表分为两部分：基本表和溢出表。所有冲突的数据都放到溢出表中。</li></ul></blockquote></li><li><p>当链表长度大于阈值(<em>一般为8</em>)时，会转换成红黑树，减少搜索时间(<em>最坏时间复杂度为 $ O(nlogn) $</em>)</p></li></ul><h2 id="HashMap中的重要参数分析"><a href="#HashMap中的重要参数分析" class="headerlink" title="HashMap中的重要参数分析"></a>HashMap中的重要参数分析</h2><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// 初始容量 左移4位得到16</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>; <span class="hljs-comment">// 最大容量</span></code></pre><p><code>capacity 容量</code>：必须是2的幂 并且小于 <code>MAXIMUM_CAPACITY</code>$2^{30}$。默认容量为16，如果不设置初始容量的话。</p><blockquote><p>为什么要转换为 $2^n$？</p><ul><li><code>可以提高取余的效率</code>。为了防止链表过长，要保证键值对在数组中尽可能均匀分布。确定元素位置的方法是通过<code>hash%length(table长度)</code>计算得出的。但是单纯的取余方式消耗相对较大，由于通过位运算<code>hash &amp; (length-1)</code>得到的结果是一样的。<strong>一个数对$ 2^n $取余，就是要去这个数二进制的最低n位。</strong></li><li><code>有利于提高计算元素存放位置的效率</code>。可以有效降低<code>Hash冲突</code>几率。</li></ul></blockquote><p><br></p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor; <span class="hljs-comment">// 实际负载因子</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>; <span class="hljs-comment">//默认负载因子</span><span class="hljs-keyword">int</span> threshold;<span class="hljs-comment">//扩容阈值 = 容量 * 负载因子</span></code></pre><p><code>loadFactor</code>：HashMap在其容量增加前可达到的最大负载。</p><blockquote><p><strong>LoadFactor取值范围为0~∞，当为0时会抛出IllegalArgumentException异常。</strong></p><p>主要分两种情况分析：</p><ul><li><code>loadFactory偏大</code>：则<code>HashMap</code>装载程度就会越高。意味着可以容纳更多的元素，空间利用率就会变高。但元素多了，发生<code>Hash冲突</code>的几率就会越大，从而链表会拉长，查询效率就会变低。</li><li><code>loadFactory偏小</code>：则<code>HashMap</code>装载程度就会变低，容纳的元素就会变少，空间利用率就会变低。但是发生<code>Hash冲突</code>的几率变低，并且链表长度也会较短，提高查询效率。由于会发生频繁的扩容操作，对性能也会有影响。</li></ul><p>合理的设置<code>loadFactory</code>：</p><ul><li>关心内存的话，采用<code>时间换空间策略</code>，适当的加大加载因子，牺牲查询速度，来换取更大的使用空间。</li><li>关心时间的话，采用<code>空间换时间策略</code>，适当的减小加载因子，从而提高查询性能，但需要考虑到频繁扩容带来的性能消耗。</li></ul></blockquote><p><code>threshold</code>：扩容阈值。当哈希表的大小 &gt;= 扩容阈值时，就会进行扩容操作。例如<code>capacity设置16，loadFactory设置0.75，则阈值为12。当存储元素个数&gt;12时，触发扩容。</code></p><blockquote><p>计算方式为<code>capacity * loadFactor</code>。</p><p><code>扩容</code>：对哈希表进行<code>resize</code>操作，扩大到原先的两倍表格大小。</p></blockquote><p><br></p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>; <span class="hljs-comment">//桶的树化阈值</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>; <span class="hljs-comment">//桶的链表还原阈值</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>; <span class="hljs-comment">//最小树形化容量阈值</span></code></pre><p><code>TREEIFY_THRESHOLD</code>：当链表长度大于该值时，链表就会转换成红黑树。</p><p><code>UNTREEIFY_THRESHOLD</code>：当红黑树节点小于该值时，红黑树会转换回聊表。发生在<code>resize()</code>扩容时。</p><p><code>MIN_TREEIFY_CAPACITY</code>：当哈希表中的容量大于该值时，才允许链表转换红黑树。</p><p><br></p><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;  <span class="hljs-comment">// 存储数据的Node类型 数组，长度 = 2的幂；数组的每个元素 = 1个单链表</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">// HashMap的大小，即 HashMap中存储的键值对的数量</span></code></pre><h2 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h2><h3 id="HashMap初始化"><a href="#HashMap初始化" class="headerlink" title="HashMap初始化"></a>HashMap初始化</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;  ...      <span class="hljs-comment">/**    * capacity = initialCapacity , loadFactory = loadFactor    */</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;        <span class="hljs-comment">//初始容量不得 &lt; 0</span>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> +initialCapacity);        <span class="hljs-comment">//初始容量最大就是 MAXIMUM_CAPACITY    </span>        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        <span class="hljs-comment">//负载因子必须 &gt; 0</span>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> +                                               loadFactor);        <span class="hljs-keyword">this</span>.loadFactor = loadFactor;        <span class="hljs-comment">//设置 扩容阈值</span>        <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);    &#125;        <span class="hljs-comment">/**    * capacity = initialCapacity , loadFactory = 0.75    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;        <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);    &#125;        <span class="hljs-comment">/**    * capacity = 16 , loadFactory = 0.75    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;    &#125;        <span class="hljs-comment">/**    * capacity = 16 , loadFactory = 0.75    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;        <span class="hljs-comment">//将传入的子Map中的数据逐个添加到 HashMap中</span>        putMapEntries(m, <span class="hljs-keyword">false</span>);    &#125;  ... &#125;</code></pre><blockquote><ol><li>在初始化<code>HashMap</code>中，只是进行了初始变量的赋值，还未进行<code>table</code>的设置</li><li><strong>真正初始化哈希表(table)是在第一次调用<code>put()</code>时。这个就是<code>lazy-load 懒加载</code>，直到被首次使用时，才会进行初始化。</strong></li></ol></blockquote><h3 id="HashMap插入数据-put"><a href="#HashMap插入数据-put" class="headerlink" title="HashMap插入数据 - put()"></a>HashMap插入数据 - put()</h3><blockquote><p>向<code>HashMap</code>中插入数据</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">//调用示例</span>HashMap map = <span class="hljs-keyword">new</span> HashMap();map.put(<span class="hljs-string">"Android"</span>,<span class="hljs-string">"Best"</span>);</code></pre><blockquote><p><code>put()</code> 源码</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;        <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);    &#125;</code></pre><p>在<code>put()</code>中，实现分为了两步：</p><ul><li><p><code>hash()</code>：将<code>key</code>转化成<code>hash值</code>。通过<code>扰动函数</code>生成对应<code>hash值</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h;        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);    &#125;</code></pre><p>当<code>key==null</code>时，<code>hash值</code>为0 ，所以可以允许<code>key</code>设置为null，不过后续都会覆盖原值。</p><p>当<code>key!=null</code>时，先获取原key的<code>hashcode()</code>，然后对其进行扰动处理： 按位异或(^) 再自身右移16位。</p><blockquote><p>所有处理的根本目的：<strong>为了提高 存储键值对 的数组下标位置的随机性&amp;分布均匀性，尽量避免出现Hash冲突。</strong></p></blockquote></li><li><p><code>putVal()</code>：添加<code>key-value</code>的实际方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,<span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;  <span class="hljs-comment">//记录当前的hash表</span>  Node&lt;K,V&gt;[] tab;   <span class="hljs-comment">//记录当前的链表节点</span>  Node&lt;K,V&gt; p;   <span class="hljs-comment">//n 记录hash表长度 i 记录当前操作的index</span>  <span class="hljs-keyword">int</span> n, i;  <span class="hljs-comment">//tab 为空则创建</span>  <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)    <span class="hljs-comment">// 初始化hash表，并把初始化后的hash表长度值赋值给n</span>    n = (tab = resize()).length;     <span class="hljs-comment">//通过hash &amp; (length -1 ) 确定最后的元素存储位置</span>  <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)        <span class="hljs-comment">//计算得出位置没有元素存在，则新建节点</span>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);  <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//当前位置已存在节点，可能是修改或者发生了Hash冲突</span>        Node&lt;K,V&gt; e;         K k;        <span class="hljs-comment">//得到的Hash值相同 且 定义的key也相同 可以判定为修改操作</span>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-comment">//将结果赋值给 e</span>            e = p;        <span class="hljs-comment">// 当前节点是树节点</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)            <span class="hljs-comment">//往红黑树结构中 插入新节点或者更新对应节点 如果是新增节点返回值为 null</span>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);        <span class="hljs-comment">// 当前节点为链表节点</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;                <span class="hljs-comment">//遍历链表到尾端也没有找到对应key值相同节点</span>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">//向尾端插入新节点</span>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);                    <span class="hljs-comment">//如果链表长度大于 阈值，就会转换成红黑树结构</span>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                        treeifyBin(tab, hash);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">//如果链表中存在key相同且hash值相同的节点，则更新对应值</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">break</span>;                p = e;            &#125;        &#125;        <span class="hljs-comment">// 发现对应的key，直接用新的value替换旧value，并返回旧value</span>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>            V oldValue = e.value;            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                e.value = value;            <span class="hljs-comment">//默认空实现，但是 LinkedHashMap有 实现该方法</span>            afterNodeAccess(e);            <span class="hljs-keyword">return</span> oldValue;        &#125;                ++modCount;        <span class="hljs-comment">//当前存储的键值对大于 阈值 则进行扩容操作。</span>        <span class="hljs-keyword">if</span> (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        <span class="hljs-comment">//证明该操作为新增操作</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;  &#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HashMap-put流程.png" srcset="/img/loading.gif" class="full-image" alt="HashMap-put流程" title="HashMap-put流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>总结流程：</p><ol><li>先判断<code>Node&lt;K,V&gt;[] table</code>是否为空或者null，是则执行<code>resize()</code>进行扩容</li><li>根据插入的键值<code>key</code>的<code>hash值</code>，通过<code>(length-1) &amp; hash值</code>得到需要的存储位置<code>index</code>，如果该位置上没有数据，则直接新建节点插入该位置。</li><li>如果存储位置已有元素存在，就需要判断<code>index</code>上的元素的<code>hash值和key</code>是否和当前要操作的一致，一致则判定为<code>修改操作</code>，覆盖原元素的value即可</li><li>当前存储位置既有元素，并且<code>key</code>也不一致，则判定该位置发生了<code>hash冲突</code>。接下来去判断当前头节点是否为树节点(<em>红黑树</em>)，如果是就以红黑树的方式插入或修改节点。</li><li>如果头节点不是树节点，则为默认的链表节点，将新增节点直接插入至链表的尾端，然后继续判断当前链表的长度是否大于<code>TREEIFY_THRESHOLD-1</code>，大于则转化为<code>红黑树</code>。遍历过程中发现<code>key</code>已经存在，则直接覆盖<code>value</code>。</li><li>插入成功后，在判断当前存储的键值对数量是否大于 <code>threshold阈值</code>，大于则触发扩容<code>resize()</code>操作。</li></ol></li></ul><h3 id="HashMap扩容-resize"><a href="#HashMap扩容-resize" class="headerlink" title="HashMap扩容 - resize()"></a>HashMap扩容 - resize()</h3><h4 id="为什么需要扩容"><a href="#为什么需要扩容" class="headerlink" title="为什么需要扩容"></a>为什么需要扩容</h4><blockquote><p>当需要存储的数据量大于HashMap的初始容量时，就会造成部分数据出现在链表或红黑树上，性能比直接通过数组下表查询数据差很多，就需要扩容来减少此类数据，提供查询性能。</p></blockquote><h4 id="如何触发扩容"><a href="#如何触发扩容" class="headerlink" title="如何触发扩容"></a>如何触发扩容</h4><blockquote><ol><li><code>初始化哈希表</code>。上文分析<code>put()</code>时看到，如果哈希表为null或空，就会触发扩容进行哈希表初始化。</li><li><code>当前数组容量过小，需要进行扩容</code>。HashMap存储的键值对大于<code>threshold</code>时，会触发扩容。</li></ol></blockquote><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><pre><code class="hljs java">    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;        <span class="hljs-comment">//扩容操作前的数组</span>        Node&lt;K,V&gt;[] oldTab = table;        <span class="hljs-comment">//扩容前的数组长度</span>        <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;        <span class="hljs-comment">//扩容前的扩容阈值</span>        <span class="hljs-keyword">int</span> oldThr = threshold;        <span class="hljs-comment">//新容量及新阈值初始</span>        <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;                <span class="hljs-comment">//触发扩容的条件为  原数组容量过小</span>        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//扩容前的数组长度已经达到最大值，则无法继续扩容</span>            <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;                threshold = Integer.MAX_VALUE;                <span class="hljs-keyword">return</span> oldTab;            &#125;            <span class="hljs-comment">//扩容后数组长度依然满足条件 则进行扩容</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                <span class="hljs-comment">//调整扩容阈值为原先2倍</span>                newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>        &#125;        <span class="hljs-comment">//触发扩容条件为 初始化哈希表</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>)             newCap = oldThr;                <span class="hljs-keyword">else</span> &#123;                           newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        &#125;        <span class="hljs-comment">//计算新的扩容阈值上限</span>        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?                      (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);        &#125;                threshold = newThr;        <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"uncheck ed"</span>&#125;)            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];        <span class="hljs-comment">//替换当前在用的数组</span>        table = newTab;                <span class="hljs-comment">//将扩容前的数据迁移到新表中</span>        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;                Node&lt;K,V&gt; e;                <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;                    oldTab[j] = <span class="hljs-keyword">null</span>;                    <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)                        <span class="hljs-comment">//数据是直接在数组上，直接进行赋值</span>                        newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                        <span class="hljs-comment">//数据在红黑树上，需要用红黑树的迁移方法</span>                        ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);                    <span class="hljs-keyword">else</span> &#123;                         <span class="hljs-comment">//数据在链表上 进行链表结构的扩容</span>                        Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;                        Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;                        Node&lt;K,V&gt; next;                        <span class="hljs-keyword">do</span> &#123;                            next = e.next;                            <span class="hljs-comment">//原索引</span>                            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                                <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)                                    loHead = e;                                <span class="hljs-keyword">else</span>                                    loTail.next = e;                                loTail = e;                            &#125;                            <span class="hljs-comment">//原索引 + oldcap</span>                            <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)                                    hiHead = e;                                <span class="hljs-keyword">else</span>                                    hiTail.next = e;                                hiTail = e;                            &#125;                        &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);                        <span class="hljs-comment">//原索引值放到新数组中</span>                        <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;                            loTail.next = <span class="hljs-keyword">null</span>;                            newTab[j] = loHead;                        &#125;                        <span class="hljs-comment">//原索引 + oldcap 放到新数组中</span>                        <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;                            hiTail.next = <span class="hljs-keyword">null</span>;                            newTab[j + oldCap] = hiHead;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> newTab;    &#125;<span class="hljs-comment">//树结构的扩容操作</span> <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> bit)</span> </span>&#123;            TreeNode&lt;K,V&gt; b = <span class="hljs-keyword">this</span>;            <span class="hljs-comment">// Relink into lo and hi lists, preserving order</span>            TreeNode&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;            TreeNode&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">int</span> lc = <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="hljs-keyword">null</span>; e = next) &#123;                next = (TreeNode&lt;K,V&gt;)e.next;                e.next = <span class="hljs-keyword">null</span>;                <span class="hljs-comment">//bit 指向了 oldcap</span>                <span class="hljs-keyword">if</span> ((e.hash &amp; bit) == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">if</span> ((e.prev = loTail) == <span class="hljs-keyword">null</span>)                        loHead = e;                    <span class="hljs-keyword">else</span>                        loTail.next = e;                    loTail = e;                    ++lc;                &#125;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">if</span> ((e.prev = hiTail) == <span class="hljs-keyword">null</span>)                        hiHead = e;                    <span class="hljs-keyword">else</span>                        hiTail.next = e;                    hiTail = e;                    ++hc;                &#125;            &#125;            <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//小于树还原阈值，就需要重新变回链表样式</span>                <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)                    tab[index] = loHead.untreeify(map);                <span class="hljs-keyword">else</span> &#123;                    tab[index] = loHead;                    <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// (else is already treeified)</span>                        loHead.treeify(tab);                &#125;            &#125;            <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)                    tab[index + bit] = hiHead.untreeify(map);                <span class="hljs-keyword">else</span> &#123;                    tab[index + bit] = hiHead;                    <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>)                        hiHead.treeify(tab);                &#125;            &#125;        &#125;</code></pre><p>根据源码发现，扩容机制会在原基础上扩大两倍的容量进行存储。<em>扩容后就会把原先在链表以及红黑树上的数据，重新分配到新的数组上去。</em></p><p>由于我们使用的2次幂的扩展(<em>每次扩容为原大小的2倍</em>)，所以元素在扩容后数组的位置要不在原位置（<code>index</code>），要不就在原位置加上扩容前的数组长度(<code>index + olcCap</code>)。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/扩容前后对比.png" srcset="/img/loading.gif" class="full-image" alt="扩容前后对比" title="扩容前后对比"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>简单的描述下，在链表上的数据如何进行扩容处理：</p><ul><li>遍历旧表，如果元素的next为空(<code>node.nect == null</code>)，直接取余后放入新数组</li><li>元素后面接了一个链表，那么需要新建两条链表，<code>hi链和lo链</code></li><li>开始遍历链表，计算每个元素的<code>hash值 &amp; oldcap</code>的值，如果为0则插入<code>lo链末端</code>，不为0则插入<code>hi链末端</code></li><li>遍历完成后，将两条链的头节点放入新数组中。<code>iohead</code>放入原来的位置，<code>hihead</code>放入原位置加上<code>oldcap</code>处。</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HashMap扩容过程.png" srcset="/img/loading.gif" class="full-image" alt="HashMap扩容过程" title="HashMap扩容过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p> 扩容后的元素移动方式就是<strong>要不在原位置，要不就是原位置加上旧容量值的位置。</strong> </p></blockquote><h3 id="HashMap获取数据-get"><a href="#HashMap获取数据-get" class="headerlink" title="HashMap获取数据 - get()"></a>HashMap获取数据 - get()</h3><blockquote><p>从HashMap获取数据</p></blockquote><pre><code class="hljs java">map.get(<span class="hljs-string">"Android"</span>);</code></pre><blockquote><p><code>get()</code>源码</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;    Node&lt;K,V&gt; e;    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;&#125;<span class="hljs-comment">//根据计算出的Hash值 去获取对应结果</span><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;    <span class="hljs-comment">//记录当前的hash表</span>    Node&lt;K,V&gt;[] tab;    <span class="hljs-comment">//first 记录对应hash位置的第一个节点</span>    Node&lt;K,V&gt; first, e;     <span class="hljs-keyword">int</span> n;     K k;    <span class="hljs-comment">//判断当前元素的存储位置是否有元素存在</span>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//头结点的hash值和要获取key的hash值相同 且 key相等</span>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-comment">//返回头结点</span>            <span class="hljs-keyword">return</span> first;        <span class="hljs-comment">//数组中不存在相等节点</span>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">//当前位置结构是 红黑树</span>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-comment">//当前位置结构是 链表</span>              <span class="hljs-comment">/**               * 遍历单链表，逐一比较链表节点，链表节点的hash值与key的hash值相等，并且key也相等               */</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-comment">//返回对应节点</span>                    <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);        &#125;    &#125;    <span class="hljs-comment">//经过上述方式都没找到 就返回null</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/HashMap-get流程.png" srcset="/img/loading.gif" class="full-image" alt="HashMap-get流程" title="HashMap-get流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>总结流程：</p><ul><li>先调用<code>key.hashcode ^ (h&gt;&gt;&gt;16)</code>计算出<code>key</code>的<code>hash值</code></li><li>根据计算出的<code>hash值</code>，通过<code>(length-1) &amp; hash值</code>计算出存储位置<code>table[i]</code>，判断位置上是否有元素存在</li><li>存储位置上没有元素存在，则直接返回null。</li><li>存储位置上存在元素，首先比较头节点(<code>头节点在数组上</code>)，如果头节点的<code>key hash值</code>和要获取<code>key hash值</code>相同并且<code>first.key == key</code>，则返回该位置的头节点。</li><li>头节点元素不是要找的元素，就需要判定头节点的结构</li><li>头节点结构为 红黑树 (<code>first instanceof TreeNode</code>)，按照红黑树的方式遍历查找节点，有就返回，没有返回null</li><li>头节点结构为 链表(<code>first instanceof Node</code>)，遍历单链表，逐一进行比较，当链表节点的<code>key hash值</code>和要获取<code>key hash值</code>相同并且<code>first.key == key</code>，则返回该节点；遍历结束都没找到，就返回null。</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="HashMap和HashTable以及HashSet的区别"><a href="#HashMap和HashTable以及HashSet的区别" class="headerlink" title="HashMap和HashTable以及HashSet的区别"></a>HashMap和HashTable以及HashSet的区别</h3><blockquote><p>HashMap</p><ul><li><p>基于<code>AbstractMap</code>类，实现<code>Map、Cloneable(被克隆)、Serializable(序列化)</code>接口</p></li><li><p>HashMap的<code>key,value</code>都可以为<code>null</code>，<code>HashMap</code>遇到<code>key == null</code>时，数据会放在<code>table[0]</code>上</p></li><li>HashMap初始容量为16，负载因子默认0.75,并且容器长度一定是2次幂。扩容时，也已2倍大小进行扩容。</li><li>HashMap是先将<code>key</code>经过<code>key.hashcode() ^ (h&gt;&gt;&gt;16)</code>计算出<code>hash值</code>，在拿<code>hash值</code>经过<code>hash &amp; (length -1 )</code>得到最终存储位置</li><li>HashMap不是线程安全，如果想线程安全，可以通过<code>Collections.synchronizedMap()</code>包裹HashMap，实质上是对HashMap的所有操作加了锁(<em>用synchronized进行修饰</em>)。导致运行效率下降，推荐使用<code>ConcurrentHashMap</code>。</li></ul></blockquote><p><br></p><blockquote><p>HashTable</p><ul><li><p>基于<code>Map</code>接口和<code>Dictionry</code>类</p></li><li><p>HashTable的<code>key,value</code>不允许为<code>null</code>，如果<code>key ==null</code>，抛出空指针异常</p></li><li>HashTable初始容量为11，负载因子默认0.75，扩容时是以原容量的两倍加1进行扩容，即<code>newCap = (oldCap &lt;&lt; 1)+1</code></li><li>HashTable用的是除留余数法计算存储位置的.<code>int index = (hash &amp; 0x7FFFFFFF) % tab.length</code></li><li>HashTable是线程安全的，每个操作方法都用<code>synchronized</code>进行修饰保证同步，运行效率低，建议使用<code>ConcurrentHashMap</code>替换。</li></ul></blockquote><p><br></p><blockquote><p>HashSet</p><ul><li>实现了Set接口</li><li>由于HashSet底层由HashMap实现，所以扩容机制与HashMap相同</li><li>HashSet只能存储对象，无法存储键值对。利用<code>add(E e)</code>插入对象，实质使用的是<code>HashMap.put(e,new Object())</code>进行操作。</li><li>HashSet和HashMap一样是线程不安全的。</li></ul></blockquote><h3 id="HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？"><a href="#HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？" class="headerlink" title="HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？"></a>HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？</h3><p>HashMap不是线程安全的，如果多个线程同时对 HashMap 进行数据更改的话，会导致数据不一致或者数据污染甚至数据丢失。</p><p>当出现线程不安全的操作时，HashMap尽可能抛出<code>ConcurrentModificationException</code>异常。</p><ul><li>当我们在对HashMap进行遍历时，如果在遍历期间我们对HashMap进行<code>put()、remove()</code>操作，会导致<code>modCount</code>发生变化(<code>exceptedModCount != modCount</code>)，然后抛出<code>ConcurrentModificationException</code>异常，这就是<strong><code>fail-fast快速失败</code></strong>机制。</li><li>由于存在扩容机制，多线程操作HashMap时，调用<code>resize()</code>进行扩容可能会导致死循环的发生。</li></ul><p>如果想要线程安全，还是推荐使用<code>ConcurrentHashMap</code>。</p><h3 id="使用HashMap时，使用什么对象作为key比较好？"><a href="#使用HashMap时，使用什么对象作为key比较好？" class="headerlink" title="使用HashMap时，使用什么对象作为key比较好？"></a>使用HashMap时，使用什么对象作为key比较好？</h3><p><strong>最好选择不可变对象作为key，因为为了计算<code>hashcode()</code>，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode，就会导致无法正确的找到对象。</strong></p><p><code>String和Interger</code>等包装类就很适合作为key，而且<code>String</code>最常用。因为<code>String</code>是不可变的且<code>final</code>修饰(<em>保证key的不可更改性</em>)，并且已经重写了<code>equals()和hashcode()</code>方法(<em>不容易出现hash值的计算错误</em>)。</p><p>不可变性还有其他的优点例如<code>线程安全</code>。</p><h3 id="如何使用自定义对象作为key？"><a href="#如何使用自定义对象作为key？" class="headerlink" title="如何使用自定义对象作为key？"></a>如何使用自定义对象作为key？</h3><p>HashMap的<code>key</code>可以是任何类型的对象，只要它遵守了<code>equals()和hashCode()</code>的定义规则，并且当对象插入到Map之后将不再会改变了。如果这个自定义对象是不可变的，那么它已经满足了作为键的条件。</p><blockquote><p><code>hashcode()</code>和<code>equals()</code>都是用来对比两个对象是否相等一致。</p><p>由于重写的<code>equals()</code>内部逻辑一般比较全面和复杂，效率就会比较低。利用<code>hashCode()</code>进行对比，只要生成一个对应的<code>hash值</code>就可以了，然后比较两者的<code>hash值</code>是否相同，不同肯定不相等。比较效率较高。</p><p>但是如果<code>hash值</code>相同的话，可能会有两个情况：</p><ol><li>他们真的是相同对象</li><li>由于hash的计算过程导致可能生成相同的<code>hash值</code>。</li></ol><p>这个时候就需要用到<code>equals()</code>去进行比较。</p><p>在改写<code>equals()</code>时，需要满足以下3点：</p><ul><li>自反性：a.equals(a) 必须为 true</li><li>对称性：<code>a.equals(b)</code>为true，则<code>b.equals(a)</code>必须成立</li><li>传递性：<code>a.equals(b)</code>为true，并且<code>b.equals(c)</code>也为true，那么<code>a.equals(c)</code>也为true。</li></ul><p><strong>每当需要对比的时候，首先用<code>hashCode()</code>进行比较，如果<code>hashCode()</code>不一样肯定不相等，就不需要调用<code>equals()</code>继续比较。如果<code>hashCode()</code>相同，再调用<code>equals()</code>继续比较，大大提高了效率也保证了数据的准确。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> userId;        <span class="hljs-keyword">private</span> String name;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getUserId</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> userId;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> userId)</span> </span>&#123;            <span class="hljs-keyword">this</span>.userId = userId;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> name;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;            <span class="hljs-keyword">this</span>.name = name;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o)                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            User user = (User) o;            <span class="hljs-keyword">return</span> userId == user.userId &amp;&amp;                    Objects.equals(name, user.name);        &#125;        <span class="hljs-comment">//设定userid为hashcode</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> userId;        &#125;    &#125;</code></pre><h3 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getMap3</span><span class="hljs-params">(Map&lt;String,String&gt; map)</span></span>&#123;    Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet();    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : set) &#123;        String value = entry.getValue();        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getMap4</span><span class="hljs-params">(Map&lt;String,String&gt; map)</span></span>&#123;    Set&lt;String&gt; set = map.keySet();    <span class="hljs-keyword">for</span> (String entry : set) &#123;    String value = map.get(entry);    &#125;&#125;</code></pre><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5c8910286fb9a049ad77e9a3" target="_blank" rel="noopener">深入接触HashMap线程安全性问题</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>Java源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关及其拓展(四) -- 垃圾收集器与内存分配策略</title>
    <link href="/2018/05/04/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%9B%9B/"/>
    <url>/2018/05/04/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><strong>垃圾收集(Garbage Collection,GC)：自动管理回收不再引用的内存数据</strong>需要完成的三件事情：</p><ul><li>哪些内存需要回收</li><li>什么时候回收</li><li>如何回收</li></ul><blockquote><p> Java语言会自动管理和回收不再引用的内存数据，由垃圾回收机制来完成。Java自身提供了内存管理机制，应用程序不需要去关注内存如何释放，内存用完后，GC会去自动进行处理，不需要人为干预出现错误。</p></blockquote><p>在<a href="/2018/04/10/JVM相关及其拓展/" title="JVM相关及其拓展（一）-- JVM内存区域">JVM相关及其拓展（一）-- JVM内存区域</a>章节中介绍了JVM的内存区域。</p><p><strong>其中<code>程序计数器</code>、<code>虚拟机栈</code>，<code>本地方法栈</code>随线程而生，随线程而灭</strong>。栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作，因此每一个栈帧分配多少内存基本是在类结构确定下来就已经是已知的。<strong>因此这几个区域的内存分配和回收都具备确定性。所以不需要过多考虑回收的问题，在方法结束或者线程结束后，内存就随着回收了，也就实现了内存的自动清理。</strong></p><p><strong>而<code>Java堆</code>和<code>方法区</code>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序运行期间才知道会创建哪些对象，这部分的内存分配和回收是动态的。垃圾收集器关注的就是这部分的内存。</strong></p><h3 id="2-判断对象是否可以回收"><a href="#2-判断对象是否可以回收" class="headerlink" title="2.判断对象是否可以回收"></a>2.判断对象是否可以回收</h3><blockquote><p> 在堆里面存放着几乎所有的对象实例，垃圾收集器在回收前需要去判断对象是否还被引用来决定是否回收，即找到那些不再被任何途径使用的对象。</p></blockquote><ul><li><p><strong>引用计数算法(Refrence Counting)</strong></p><blockquote><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时候计数器为0的对象是不能再被引用的，可以被当做垃圾收集。</p><p>优点：实现简单，判断效率高<br>缺点：无法检测出对象之间相互循环引用，开销大（会发生频繁且大量的引用变化，带来大量的额外运算）。</p></blockquote></li><li><p><strong>可达性分析算法(Reachability Analysis)</strong></p><blockquote><p>通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的节点为引用链，当一个对象到GC Roots没有任何引用链相连（从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p></blockquote></li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_reachability_analysis.png" srcset="/img/loading.gif" class="full-image" alt="可达性分析算法" title="可达性分析算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>在Java语言中，可作为GC Roots的对象包括以下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li><p>本地方法栈中JNI引用的对象（Native对象）</p><blockquote><p>优点：更加精确严谨可以分析出循环引用的情况</p><p>缺点：实现复杂，效率低，分析过程中需要GC停顿（因为应用关系不能发生改变，需要停止所有Java线程）</p></blockquote></li></ul><h3 id="3-对象是生存还是死亡"><a href="#3-对象是生存还是死亡" class="headerlink" title="3.对象是生存还是死亡"></a>3.对象是生存还是死亡</h3><blockquote><p>真正宣告一个对象死亡，至少要经历两次标记过程 </p></blockquote><ul><li><p><strong>第一次标记</strong>：</p><p>对象在进行可达性分析算法后没有发现与GC Roots相连接的引用链，将会被第一次标记并进行第一次筛选。筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。</p><ul><li><p>没必要执行</p><p>对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已被虚拟机调用过。</p></li><li><p>有必要执行</p><p>对象会被放置在一个F-Queue的队列中，稍后会由一个JVM自动建立的、低优先级的Finalizer线程去执行。</p></li></ul></li><li><p><strong>第二次标记：</strong></p><p>GC对F-Queue中的对象进行第二次小规模的标记，<code>finalize()</code>是对象摆除被回收的最后方法</p><ul><li>若对象要避免自己被回收，需要重新与引用链上的任何一个对象建立关系即可，譬如把自己（this）赋值给某个变量或者对象的成员变量，那就会移除被回收的集合</li><li>如果没有摆除，则基本上会被回收。任何一个对象的<code>finalize()</code>方法只会被系统自动调用一次，再次调用<code>finalize()</code>方法则不会再次执行。</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalizeEscapeGC</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isAlive</span><span class="hljs-params">()</span> </span>&#123;        System.err.println(<span class="hljs-string">"It is live"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        <span class="hljs-keyword">super</span>.finalize();        System.err.println(<span class="hljs-string">"finalize is executed"</span>);        FinalizeEscapeGC.SAVE_HOOK = <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        SAVE_HOOK = <span class="hljs-keyword">new</span> FinalizeEscapeGC();        SAVE_HOOK = <span class="hljs-keyword">null</span>;        System.gc();        Thread.sleep(<span class="hljs-number">500</span>);        <span class="hljs-keyword">if</span> (SAVE_HOOK != <span class="hljs-keyword">null</span>) &#123;            SAVE_HOOK.isAlive();        &#125; <span class="hljs-keyword">else</span> &#123;            System.err.println(<span class="hljs-string">"It is over"</span>);        &#125;        <span class="hljs-comment">//将对象的引用链重新置为null，则拯救失败</span>        SAVE_HOOK = <span class="hljs-keyword">null</span>;        System.gc();        Thread.sleep(<span class="hljs-number">500</span>);        <span class="hljs-keyword">if</span> (SAVE_HOOK != <span class="hljs-keyword">null</span>) &#123;            SAVE_HOOK.isAlive();        &#125; <span class="hljs-keyword">else</span> &#123;            System.err.println(<span class="hljs-string">"It is over"</span>);        &#125;            &#125;    &#125;</code></pre><ul><li><p><strong><code>finalize()</code></strong></p><p>运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</p></li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/判断Java对象是否存活.png" srcset="/img/loading.gif" class="full-image" alt="判断Java对象是否存活" title="判断Java对象是否存活"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="4-回收方法区"><a href="#4-回收方法区" class="headerlink" title="4.回收方法区"></a>4.回收方法区</h3><blockquote><p>永久代的垃圾收集主要分为两部分：<strong>废弃常量和无用的类</strong></p><p><strong>废弃常量</strong>：假如常量池中存在一个常量，但是没有任何对象引用该常量，在发生回收的时候，该常量就会被系统清理出常量池，常量池中的其他类（接口）、方法、字段的符号引用类似。</p><p><strong>无用的类</strong>：需要同时满足以下条件</p><ol><li>该类的所有实例已被回收，Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader已被回收</li><li>该类对应的Class对象没有在任何地方被引用，也无法在任何地方通过反射访问到该类的方法</li></ol></blockquote><h3 id="5-垃圾收集算法"><a href="#5-垃圾收集算法" class="headerlink" title="5.垃圾收集算法"></a>5.垃圾收集算法</h3><h4 id="标记-清除算法-Mark-Sweep-最基础的收集算法"><a href="#标记-清除算法-Mark-Sweep-最基础的收集算法" class="headerlink" title="标记-清除算法(Mark-Sweep)  最基础的收集算法"></a><strong>标记-清除算法(Mark-Sweep)  最基础的收集算法</strong></h4><blockquote><p>算法分为<code>标记</code>和<code>清除</code>两个阶段，<strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</strong>。主要不足有两个：一个是效率问题（<code>标记和清除两个过程的效率都不高</code>）；另一个是空间问题（<code>标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作</code>）。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_mark_sweep.png " srcset="/img/loading.gif" class="full-image" alt="标记-清除算法" title="标记-清除算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a><strong>复制算法(Copying)</strong></h4><blockquote><p>将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象移到另一块上面，然后把已使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时就不需考虑内存碎片等情况。</p><p>缺点：可用内存会减少一半；效率会随存活对象的升高而降低（当对象存活率较高的时候，需要更多的copy操作，导致效率降低）</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_copying.png" srcset="/img/loading.gif" class="full-image" alt="整理算法" title="整理算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>现在的商业虚拟机都采用这种收集算法来回收新生代。</p><p>提供了改良算法（基于<strong>弱代理论①</strong>）：不是按照1:1的比例去划分内存空间，而是分为较大的Eden空间和两块较小的Survivor空间，在回收时将Eden和Survivor存活的对象移至到另一块Survivor空间上。<strong>HotSpot中Eden和Survivor的大小比例为8:1。</strong><code>在一般场景下足够使用，当Survivor空间不够使用时，需要依赖其他内存(代指老年代)进行分配担保②</code>。</p><blockquote><p>①<strong>弱代理论</strong>：1. 大多数分配了内存的对象存活不会太久，在年轻代就会死掉；2. 很少有对象从年老代变成年轻代。</p><p>②<strong>分配担保</strong>：如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。</p></blockquote><h4 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a><strong>标记-整理算法(Mark-Compact)</strong></h4><blockquote><p>标记过程与“标记-清除”算法一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理端边界以外的内存。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_mark_compact.png" srcset="/img/loading.gif" class="full-image" alt="标记-整理算法" title="标记-整理算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>优点：1. 效率不随对象存活率升高而降低。 2. 不像标记-清除算法会产生大量的内存碎片（因为会进行一次整理，将存活对象集中到一端）。</p><p>缺点：除了需要进行标记，还需要整理过程，执行效率更低。</p></blockquote><h4 id="分代收集算法-Generational-Collection-——主流收集算法"><a href="#分代收集算法-Generational-Collection-——主流收集算法" class="headerlink" title="分代收集算法(Generational Collection)——主流收集算法"></a><strong>分代收集算法(Generational Collection)——主流收集算法</strong></h4><blockquote><p>根据对象存活周期的不同将内存划分为几块，一般是把Java堆分成新生代和老年代<del>和持久代(JDK8中移除)</del>，这样就可以根据各个年代的特点采用最适当的收集算法。<br><strong>新生代</strong>中每次垃圾收集都会有大量的对象被回收，只有少量存活，就可以使用复制算法。</p><p><strong>老年代</strong>中因为对象存活率较高，没有额外空间进行分配担保，所以必须使用“标记-清理”或者“标记-整理”算法。</p></blockquote><ul><li><p><strong>新生代(Young Generation)</strong>：所有新生对象都会放在新生代，新生代的目标是尽快收集生命周期短的对象，每次GC过后只有少量存活。新生代发生的GC叫做<strong><code>Minor GC（频率较高，新生代Eden区满才触发）</code></strong>。新生代细分为<code>Eden、From Survivor、To Survivor</code>三块空间（三块空间大小并非均分，默认比例为8:1:1）。</p><p>新生代的垃圾回收执行过程：</p><ol><li><code>Eden</code>区 + <code>From Survivor</code>区存活的对象复制到<code>To Survivor</code>区</li><li>清空<code>Eden以及From Survivor</code>区</li><li><code>From Survivor</code>和<code>To Survivor</code>进行交换</li></ol></li><li><p><strong>老年代(Tenured Generation)</strong>：新生代发生几次GC后依然存活的对象会放到老年代中，所以老年代中的对象生命周期较长。内存也比新生代大很多（大概2:1）,当老年代内存满时会触发<strong><code>Full GC/Major GC(针对新生代和老年代触发，经常会伴随至少一次的Minor GC，收集频率较低且耗时长，一般慢10倍以上)</code></strong>。</p></li><li><p><del><strong>持久代(Permanent Generation)</strong></del>：用于存放静态文件，如Java类，方法等，对GC没有影响。</p></li><li><p><strong>拓展</strong>：别处也有介绍   Full GC针对整个堆空间（包含新生代，老年代，永久代（如果包含））的回收。而Major GC是针对老年代的内存回收。</p></li><li><p><strong>Minor GC</strong>：新生代是堆的一部分，对象首先在新生代中分配。新生代填满时，垃圾收集器会暂停所有的应用程序，回收新生代空间。不再使用的对象会被回收，仍然使用的对象移动至其他地方。</p></li><li><p><strong>Full GC:</strong> 对象不断地移至老年代，最终老年代也被填满，JVM需要找到老年代不再使用的对象并进行回收。会导致长时间停顿。</p></li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_java_heap_memory.png" srcset="/img/loading.gif" class="full-image" alt="Java堆内存" title="Java堆内存"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="6-垃圾收集器"><a href="#6-垃圾收集器" class="headerlink" title="6.垃圾收集器"></a>6.垃圾收集器</h3><blockquote><p>收集算法是内存回收的方法论，垃圾收集器就为内存回收的具体实现。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_collectors.png" srcset="/img/loading.gif" class="full-image" alt="垃圾收集器" title="垃圾收集器"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据上图分析新生代收集器主要是：<strong>Serial收集器,ParNew收集器,Parallel Scavenge收集器和G1收集器</strong>。老年代收集器为<strong>CMS收集器，Serial Old收集器，Parallel收集器和G1收集器</strong>。</p><p>在两个收集器之间存在连线，则意味着他们之间可以搭配使用。</p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a><code>Serial收集器</code></h4><blockquote><p>该收集器是最基本、发展历史最悠久的收集器。这个收集器是一个<strong>单线程</strong>收集器（<code>不仅是他只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是他在进行垃圾收集时必须停止其他的工作线程(Stop The World)，直到收集结束。进行Full GC时，还会对老年代空间对象进行压缩整理。</code>）。</p></blockquote><p>是虚拟机运行在Client端的默认新生代收集器</p><p>有着优于其他收集器的地方：</p><ul><li><strong>简单而高效</strong></li><li><strong>没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集效率</strong></li></ul><p>关键控制参数：</p><ul><li>-XX:SurvivorRatio：设置两个Survivor区和Eden区的比值(<strong>8表示 1:1:8</strong>)</li><li>-XX:PretenureSizeThreshold：设定对象超过多少岁时进入老年代</li><li>-XX:HandlePromotionFailure：设置是否允许担保失败</li></ul><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a><code>ParNew收集器</code></h4><blockquote><p>ParNew收集器其实是Serial收集器的多线程版本。除了使用多线程进行垃圾收集之外，其他科Serial收集器完全一样。</p></blockquote><p>该收集器是运行在Server模式下的虚拟机中的首选的新生代收集器，其中有一个重要的原因就是：<strong>除了Serial收集器外，目前只有它能和CMS收集器配合工作。</strong>随着可以使用的CPU数量增加，GC时系统资源的有效利用还是有好处的。<strong>默认开启的收集线程数与CPU的数量相同</strong></p><blockquote><p><strong>并行（Parallel）</strong>：指多条垃圾收集器线程并行工作，但此时用户线程仍处于等待状态</p><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集器同时执行，用户程序仍继续运行，而垃圾收集器执行于另一个CPU上。</p></blockquote><p>关键控制参数：</p><ul><li>-XX:UserParNewGC：是否开启ParNew收集器</li></ul><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a><code>Parallel Scavenge收集器</code></h4><blockquote><p>Parallel Scavenge收集器是一个新生代收集器，使用了复制算法以及并行的多线程收集器。</p></blockquote><p>该收集器的目标是：<strong>达到一个可控制的吞吐量（ThroughPut）</strong>①。</p><p>停顿时间越短越适合需要与用户交互的程序，良好的响应速度可以提升用户体验，高吞吐量就可以高效率的利用CPU时间，主要适合在后台运算而不需要太多交互的任务。</p><blockquote><p><code>吞吐量</code>：CPU用于运行用户代码时间与CPU总消耗时间的比值。</p></blockquote><p>关键控制参数：</p><ul><li>-XX:UseAdaptiveSizePolicy：开关参数，当打开时就不需要去指定新生代大小以及Eden与Survivor比例，晋升老年代对象岁数大小等参数，触发<strong>GC自适应调节策略</strong>(<code>虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数已提供最适合的停顿时间或者最大的吞吐量</code>)</li></ul><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a><code>Serial Old收集器</code></h4><blockquote><p>是Serial收集器的老年代版本，同样是一个单线程收集器。使用“标记-整理算法”</p></blockquote><p>该收集器主要为了给Client模式下的虚拟机使用。如果在Server模式下，还有以下用途：</p><ul><li>在JDK1.5及之前的版本搭配Paraller Scavenge收集器</li><li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li></ul><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a><code>Parallel Old收集器</code></h4><blockquote><p>是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”。</p></blockquote><p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑<code>Parallel Scavenge +  Parallel Old</code>组合。</p><h4 id="CMS收集器（Concurrent-Mark-Sweep）"><a href="#CMS收集器（Concurrent-Mark-Sweep）" class="headerlink" title="CMS收集器（Concurrent Mark Sweep）"></a><strong><code>CMS收集器（Concurrent Mark Sweep）</code></strong></h4><blockquote><p>以获取最短回收停顿时间为目标的收集器。基于“<strong>标记-清除算法</strong>”实现。整体上来说内存回收过程是与用户线程一起并发执行的。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/CMS收集器.png" srcset="/img/loading.gif" class="full-image" alt="CMS收集器" title="CMS收集器"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>运作过程比较复杂，分为4个步骤：</p><ul><li><strong>初始标记</strong>：仅仅标记一下GC Roots能关联到的对象，速度很快  <code>触发Stop The World</code></li><li><strong>并发标记</strong>：进行GC Roots Tracing的过程</li><li><strong>重新标记</strong>：修正并发标记期间因用户程序继续运做而导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记长一些，但短于并发标记时间  <code>触发Stop The World</code></li><li><strong>并发清除</strong>：可以和用户线程一起工作</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_collectors_CMS.png" srcset="/img/loading.gif" class="full-image" alt="CMS" title="CMS"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>CMS收集器有3个明显的缺点：</p><ol><li><p><strong>对CPU资源非常敏感</strong></p><p><strong>面向并发设计的程序都对CPU资源比较敏感</strong>。在并发阶段，虽然不会导致用户线程停顿，但是会因为占了一部分CPU资源而导致线程变慢，吞吐量会降低。<code>CMS默认启动的回收线程数量为(CPU数量+3)/4</code></p></li><li><p><strong>无法处理浮动垃圾（Floating Garabge）</strong></p><p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就有新的垃圾产生，即<code>浮动垃圾(这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉他们，只能留到下一次GC进行清理)</code>。</p><p>因此CMS收集器不能像其他收集器一样等到老年代几乎完全满了在进行收集，需要预留一部分空间提供并发收集时使用。</p><p>JDK1.5默认设置下，CMS收集器到老年代到了68%即会激活，到1.6时提高到了92%。</p><p>要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<code>Concurrent Mode Failure</code>失败，虚拟机将会启动后备预案：<strong>临时启用Serial Old收集器来重新进行老年代的垃圾收集，停顿时间就会变得很长了。</strong></p></li><li><p><strong>产生的空间碎片</strong></p><p>由于CMS是基于“标记-清除”算法实现的收集器。这种方式会产生大量的空间碎片，碎片过多时将会给对象分配来很大麻烦，往往会出现老年代还有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p></li></ol><p>关键控制参数：</p><ul><li>-XX:CMSInitiatingOccupancyFraction：设置CMS触发阈值即老年代对象占用空间</li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a><strong><code>G1收集器</code></strong></h4><blockquote><p>全称Garbage-First收集器，通过-XX:+UseG1GC参数来启用，在JDK9中，被提议为默认收集器。<code>在JDK10中，把单线程的Full GC改良为了多线程Full GC</code></p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/G1收集器.png" srcset="/img/loading.gif" class="full-image" alt="G1收集器" title="G1收集器"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>G1收集器是一款面向服务端的垃圾收集器，设计目标是为了取代CMS收集器。具备如下特点：</p><ul><li><strong>并行与并发</strong>：使用多个CPU来缩短停顿时间，也会通过并发的方式让Java程序继续运行</li><li><strong>分代收集</strong>：分代概念在G1中得以保留，可以不需要其他的收集器配合管理整个堆，可以采用不同的方式去处理新创建的对象和旧对象。</li><li><strong>空间整合</strong>：整体基于“标记-整理”算法，局部（两个Region之间）采用“复制”算法实现</li><li><strong>可预测的停顿</strong>：除了追求低停顿外，还可建立可预测的时间停顿模型，用户可以指定期望停顿的时间</li></ul><h5 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h5><p>在G1收集器之前其他收集器进行收集的范围都是整个新生代或者老年代，而G1可以通用。使用G1收集器，Java堆的内存布局就与其他收集器不同，将整个Java堆划分为多个大小相等的独立区域（Region），虽然保留了新生代老年代的概念，但他们都变成了一部分Region的集合。</p><h5 id="可停顿的时间模型"><a href="#可停顿的时间模型" class="headerlink" title="可停顿的时间模型"></a>可停顿的时间模型</h5><p>可以实现有计划的避免在整个Java堆中进行全区域的垃圾收集。跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region空间。可以保证G1收集器在有限时间内获得尽可能高的收集效率。</p><h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h5><p>Region不可能是独立的，由于可能会被其他对象引用。在G1中，Region之间的对象引用以及其他收集器中的新生代老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。每一个Region都会对应一个Remembered Set，虚拟机发现在对Reference进行读写操作时，产生一个<code>Write Barrier</code>暂时中断写操作，检查对象引用是否位于不同的Region中，若是则通过<code>CardTable</code>记录相关引用信息到Remembered Set中。<strong>在进行内存回收时，在GC Roots中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</strong></p><h5 id="stop-the-world"><a href="#stop-the-world" class="headerlink" title="stop-the-world"></a><strong>stop-the-world</strong></h5><p>概念：<strong>除GC所需线程外，多有线程都要进如等待状态，直到GC任务完成。</strong></p><p>解决方法：使用多个CPU来缩短停顿时间。</p><h5 id="G1运作步骤"><a href="#G1运作步骤" class="headerlink" title="G1运作步骤"></a>G1运作步骤</h5><ul><li><strong>初始标记</strong>：标记一下GC Roots能直接关联的对象，需要停顿线程</li><li><strong>并发标记</strong>：从GC Roots开始进行可达性分析，找出存活的对象耗时较长</li><li><strong>最终标记</strong>：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，需要停顿线程，可并行执行</li><li><strong>筛选回收</strong>：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间来指定回收计划。</li></ul><p><strong>如果应用追求吞吐量，那并不会带来特别的好处</strong></p><h4 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a><code>ZGC收集器</code></h4><blockquote><p>在Java11 中引入的新型收集器</p></blockquote><h3 id="7-内存分配与回收策略"><a href="#7-内存分配与回收策略" class="headerlink" title="7.内存分配与回收策略"></a>7.内存分配与回收策略</h3><p><strong>对象的内存分配，就是在堆上进行分配。</strong></p><blockquote><p>对象优先在Eden分配,就是在JVM的堆上进行内存分配</p></blockquote><blockquote><p>大对象直接进入老年代</p></blockquote><p>大对象代指 <strong>需要连续内存空间的Java对象</strong></p><blockquote><p>长期存活的对象将进入老年代</p></blockquote><p>当Eden区满了，在创建对象会触发Minor GC(<strong>执行Minor GC时，Eden空间存活的对象会被复制到To Survivor·空间，并且之前经过一次Minor GC在From Survivor存活并年轻的对象也会被复制到To Survivor空间。如果存活对象的分代年龄超过阈值，则会晋升到老年代。</strong>)</p><blockquote><p>动态对象年龄判定</p></blockquote><p>为了更好的适应不同程序的内存状况，并不需要永远要求对象年龄必须达到<code>maxTenuringThreshold</code>才可以晋升老年代，<strong>若在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</strong></p><blockquote><p>空间分配担保</p></blockquote><p><strong>如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-链表</title>
    <link href="/2018/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <url>/2018/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构-链表"><a href="#数据结构-链表" class="headerlink" title="数据结构-链表"></a>数据结构-链表</h1><blockquote><p>链表是一种基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)，简单来说链表并不像数组存储在一个连续的内存地址空间里，他们可以是不连续的因为他们每个节点保存着下一个节点的引用（地址），所以较之数组来说这是一个优势。</p></blockquote><h2 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1.单链表"></a>1.单链表</h2><blockquote><p>单链表是链表的一种，由节点组成，每个节点包含到下一个节点的指针。</p></blockquote><blockquote><p>单链表特点：</p><ul><li>链表增删元素时间复杂度度为O(1)，查找一个元素复杂度为O(n)</li><li>单链表不需要预先分配空间，避免空间浪费</li><li>单链表不能进行回溯操作，例如读取倒数几个节点的值</li></ul></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/structures/single_linkedlist.png" srcset="/img/loading.gif" class="full-image" alt="单链表" title="单链表"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><pre><code class="hljs java"><span class="hljs-comment">/*** 表示一个节点*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-comment">//数据域</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> data;    <span class="hljs-comment">//下一节点</span>    <span class="hljs-keyword">public</span> Node next;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;        <span class="hljs-keyword">this</span>.data = data;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data, Node next)</span> </span>&#123;        <span class="hljs-keyword">this</span>.data = data;        <span class="hljs-keyword">this</span>.next = next;    &#125;&#125;</code></pre><h3 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h3><ul><li><p>链表添加元素</p><ul><li>添加头部</li><li>添加尾部</li></ul></li><li><p>链表删除元素</p><ul><li>删除指定位置</li><li>删除倒数第K个节点</li></ul></li><li><p>链表查询元素</p><ul><li>指定索引</li><li>查询倒数第K个节点</li></ul></li><li><p>其他操作</p><ul><li><p>寻找链表中间元素</p></li><li><p>旋转单链表</p></li><li><p>翻转单链表</p></li><li><p>单链表排序</p><ul><li>冒泡排序</li><li>插入排序</li></ul></li><li><p>链表相加求和</p></li><li><p>删除重复元素</p></li></ul></li></ul><h2 id="2-双循环链表"><a href="#2-双循环链表" class="headerlink" title="2.双循环链表"></a>2.双循环链表</h2>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关及其拓展(三) -- 虚拟机类加载器</title>
    <link href="/2018/04/16/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%89/"/>
    <url>/2018/04/16/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1-虚拟机类加载器"><a href="#1-虚拟机类加载器" class="headerlink" title="1.虚拟机类加载器"></a>1.虚拟机类加载器</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>在类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码块称为“类加载器”。</p><p>例如：编写的是.java文件，代码运行后变成.class文件，类加载器就是加载.class文件。</p><p><strong>不同的类加载器加载同一个类时，得到的两个类也是不相等的。</strong></p><h2 id="Java类加载器分类："><a href="#Java类加载器分类：" class="headerlink" title="Java类加载器分类："></a>Java类加载器分类：</h2><h3 id="1-系统提供的类加载器"><a href="#1-系统提供的类加载器" class="headerlink" title="1.系统提供的类加载器"></a>1.系统提供的类加载器</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/类加载器.png" srcset="/img/loading.gif" class="full-image" alt="类加载器分类" title="类加载器分类"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><p><strong>Bootstrap ClassLoader(启动类加载器)</strong>：由C/C++实现的加载器，用于加载虚拟机运行时所需要的系统类，如<code>java.lang.*、java.uti.*</code>等系统类。它负责将存放在&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。</p><p>这个加载器由于是C实现的，所以<strong>无法被Java程序直接引用</strong>。并且不继承<code>java.lang.ClassLoader</code>。</p></li><li><p><strong>Extension ClassLoader(扩展类加载器)</strong>：这个加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的，或者被<code>javax.ext.dirs</code>系统变量所指定的路径中的所有类库。</p><p><strong>开发者可以直接进行引用。</strong></p></li><li><p><strong>Application ClassLoader(应用程序类加载器)</strong>：这个加载器由sun.misc.Launcher$AppClassLoader实现。可以加载用户类路径上的指定类库，通过<code>ClassLoader.getSystemClassLoader()</code>方式获取，没有定义过自己的类加载器，则默认是这个。</p></li><li><p><strong>Custom ClassLoader(自定义加载器)</strong>：通过集成<code>java.lang.ClassLoader</code>来实现自己的加载器。</p></li></ul><h3 id="2-双亲委托模型"><a href="#2-双亲委托模型" class="headerlink" title="2.双亲委托模型"></a>2.双亲委托模型</h3><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/parent_loader.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="双亲委托模型"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><p>工作流程：如果一个类加载器收到了类加载的请求，不会自己去尝试加载这个类，而把这个请求委派给父类加载器去完成，每一层都是如此，依次向上递归，直到委托到最顶层的<code>Bootstrap ClassLoader</code>，若父加载器无法处理加载请求（它的搜索范围内没有找到所需的类时），则交由子加载器去加载。</p><blockquote><p>简单流程介绍</p><ol><li>自定义类加载器先从缓存中查看Class文件是否被加载，如果加载则返回Class，没有加载则委托给父类加载</li><li>一直委托到<code>Bootstrap ClassLoader</code>,在<code>Bootstrap ClassLoader</code>没有找到Class文件，则在自己的规定路径&lt;JAVA_HOME&gt;\lib或者-Xbootclasspath选项指定路径的jar包进行查询，找到则返回Class，没有就交由子加载器去加载。</li><li>最后交由我们自定义的类加载器去加载，还找不到则抛出<code>ClassNotFoundException</code>异常。</li></ol></blockquote></li><li>代码模型实现：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)       <span class="hljs-keyword">throws</span> ClassNotFoundException   &#123;       <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;           <span class="hljs-comment">// 检查请求的类是否已被加载过</span>           Class&lt;?&gt; c = findLoadedClass(name);           <span class="hljs-comment">//对应的类已被加载则不会往下进行</span>           <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">long</span> t0 = System.nanoTime();               <span class="hljs-keyword">try</span> &#123;                   <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                   <span class="hljs-comment">//父加载器不为null，调用父加载器的load方法</span>                       c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                   &#125; <span class="hljs-keyword">else</span> &#123;                   <span class="hljs-comment">//父加载器为null，则调用系统的BootstrapClassLoader</span>                       c = findBootstrapClassOrNull(name);                   &#125;               &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                   <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                   <span class="hljs-comment">// from the non-null parent class loader</span>                   <span class="hljs-comment">//父类加载器无法加载则抛出ClassNotFoundException异常</span>               &#125;               <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                   <span class="hljs-comment">// If still not found, then invoke findClass in order</span>                   <span class="hljs-comment">// to find the class.</span>                   <span class="hljs-comment">//父类加载器无法加载则调用本身的findClass()方法去加载</span>                   <span class="hljs-keyword">long</span> t1 = System.nanoTime();                   c = findClass(name);                   <span class="hljs-comment">// this is the defining class loader; record the stats</span>                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                   sun.misc.PerfCounter.getFindClasses().increment();               &#125;           &#125;           <span class="hljs-keyword">if</span> (resolve) &#123;               resolveClass(c);           &#125;           <span class="hljs-keyword">return</span> c;       &#125;   &#125;</code></pre><ul><li>好处：<ul><li>避免重复加载，若该Class已加载则从缓存中直接读取</li><li>更加安全，例如<code>java.lang.Object</code>，无论哪一个类加载器去加载这个类，最终都会委派给Bootstrap ClassLoader去进行加载，所以我们自定义的Object类并不会被加载而导致系统中出现多个Object类。</li></ul></li></ul><h3 id="3-破坏双亲委托模型"><a href="#3-破坏双亲委托模型" class="headerlink" title="3.破坏双亲委托模型"></a>3.破坏双亲委托模型</h3><p>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载实现方式。</p><ul><li>在JDK1.2发布之前，还没有双亲委托机制</li><li>由模型自身缺陷所导致的</li><li>用户对于程序动态性导致的，例如代码热替换，模块热部署</li></ul><h3 id="4-自定义ClassLoader"><a href="#4-自定义ClassLoader" class="headerlink" title="4.自定义ClassLoader"></a>4.自定义ClassLoader</h3><ul><li><p>自定义需要加载的类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jobs</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>&#123;        System.err.println(<span class="hljs-string">"自定义加载器加载"</span>);    &#125;&#125;</code></pre><p>自定义完成后需调用<code>javac Jobs.java</code>去生成对应的<code>Jobs.class</code>文件以用来加载。</p></li><li><p>实现自定义的ClassLoader</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiskClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;    <span class="hljs-keyword">private</span> String path;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiskClassLoader</span><span class="hljs-params">(String path)</span> </span>&#123;        <span class="hljs-keyword">this</span>.path = path;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;        Class clazz = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">byte</span>[] classData = loadClassData(name);        <span class="hljs-keyword">if</span> (classData == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException();        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//用来将获取的字节码数组转为class的实例</span>            clazz = defineClass(name, classData, <span class="hljs-number">0</span>, classData.length);        &#125;        <span class="hljs-keyword">return</span> clazz;    &#125;    <span class="hljs-comment">/**     * 获得class文件的字节码数组     * <span class="hljs-doctag">@param</span> name     * <span class="hljs-doctag">@return</span>     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] loadClassData(String name) &#123;        String fileName = getFileName(name);        File file = <span class="hljs-keyword">new</span> File(path, fileName);        System.err.println(fileName);        InputStream inputStream = <span class="hljs-keyword">null</span>;        ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);            byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> ((length = inputStream.read(buffer)) != -<span class="hljs-number">1</span>) &#123;                byteArrayOutputStream.write(buffer, <span class="hljs-number">0</span>, length);            &#125;            <span class="hljs-keyword">return</span> byteArrayOutputStream.toByteArray();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//读取流后需要关闭，以免造成内存泄露</span>            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-keyword">null</span>) &#123;                    inputStream.close();                &#125;            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (byteArrayOutputStream != <span class="hljs-keyword">null</span>) &#123;                    byteArrayOutputStream.close();                &#125;            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getFileName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">int</span> index = name.indexOf(<span class="hljs-string">'.'</span>);        <span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> name + <span class="hljs-string">".class"</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> name.substring(index + <span class="hljs-number">1</span>) + <span class="hljs-string">".class"</span>;        &#125;    &#125;&#125;</code></pre><p>自定义的ClassLoader需要读取对应Class的字节流数组，以便产生实例。注意不要忘记对流的关闭。</p></li><li><p>使用自定义的ClassLoader去加载类</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomClassLoaderTest</span></span>&#123;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      DiskClassLoader diskClassLoader = <span class="hljs-keyword">new</span> DiskClassLoader(<span class="hljs-string">"需要加载的class的地址"</span>);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//对class文件进行加载</span>            Class c = diskClassLoader.loadClass(<span class="hljs-string">"Jobs"</span>);            <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    Object object = c.newInstance();                    System.err.println(object.getClass().getClassLoader());                    Method method = c.getDeclaredMethod(<span class="hljs-string">"say"</span>, <span class="hljs-keyword">null</span>);                    method.invoke(object, <span class="hljs-keyword">null</span>);                &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;     &#125;&#125;</code></pre><p>在对应的文件夹下是否已存在Jobs.java文件：</p><ul><li><pre><code class="hljs java"><span class="hljs-comment">//存在要加载的Java文件</span>sun.misc.Launcher$AppClassLoader@<span class="hljs-number">18</span>b4aac2自定义加载器加载</code></pre></li><li><pre><code class="hljs java"><span class="hljs-comment">//不存在对应的Java文件</span>DiskClassLoader<span class="hljs-meta">@d</span>716361自定义加载器加载</code></pre></li></ul></li></ul><p>​          以上就为自定义ClassLoader的基本步骤，也是热修复框架中ClassLoader的雏形。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Study-Plan-XIV</title>
    <link href="/2018/04/16/Android-Study-Plan-XIV/"/>
    <url>/2018/04/16/Android-Study-Plan-XIV/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>##用过RxJava和RxAndroid吗？RxAndroid切换线程是怎么实现的？</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC,MVP,MVVM的理解</title>
    <link href="/2018/04/15/MVC-MVP-MVVM%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2018/04/15/MVC-MVP-MVVM%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/MVC+-+MVP+-MVVM简析.png" srcset="/img/loading.gif" class="full-image" alt="MVC、MVP、MVVM" title="MVC、MVP、MVVM"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>使用架构的目的是：<strong>模块内部的高内聚，模块之间的低耦合。</strong></p></blockquote><h2 id="1-MVC模式"><a href="#1-MVC模式" class="headerlink" title="1.MVC模式"></a>1.MVC模式</h2><p>MVC(Model-View-Controller，模型-视图-控制器)是20世纪80年代出现的一种设计模式。他用一种业务逻辑、数据、界面显示分离的方法组织代码。在Android中MVC的角色定义如下：</p><ul><li><p>Model(模型层)：针对业务模型，建立的数据结构和相关的类，就可以理解为Model。与View无关，与业务相关。主要负责网络请求、数据库处理、I/O操作。</p></li><li><p>View(视图层)：一般采用XML文件或者Java代码进行界面的描述。</p></li><li><p>Controller(控制器)：Android的控制层一般在Activity，Fragment中或者在由他们控制的其他业务类中。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/pattern/mvc_pattern.png" srcset="/img/loading.gif" class="full-image" alt="MVC" title="MVC"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul><p>优点：</p><ul><li>实现简单，不需要过于复杂的逻辑以及文件分层</li></ul><p>缺点：</p><ul><li>在Android开发中，Activity不是一个标准的Controller，首要职责为加载应用的布局和初始化界面，并接受用户的请求。随着界面以及代码逻辑的复杂，Activity会越来越庞大。</li></ul><h2 id="2-MVP模式"><a href="#2-MVP模式" class="headerlink" title="2.MVP模式"></a>2.MVP模式</h2><p>MVP(Model-View-Presenter)是MVC的演化版本，对于Android来说，Model层和MVC模式是一种概念，activity或者fragment对应的就是View层，所有用户相关事件处理由Presenter处理。使用Presenter进行解耦操作。</p><ul><li><p>Model：主要提供数据的存取功能。</p></li><li><p>View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件</p></li><li><p>Presenter：作为View和Model沟通的桥梁，从Model层检索数据并返回给View层，使得View和Model层完全解耦。Presenter与View可以通过接口来实现通信，只要View层去实现定义好的接口。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/pattern/mvp_pattern.png" srcset="/img/loading.gif" class="full-image" alt="MVP" title="MVP"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul><p>优点：</p><ul><li>View与Model完全分离，修改不会互相影响逻辑</li><li>Presenter可以进行复用，应用于多个View上</li><li>可以预先定义好Presenter，方便理解结构</li></ul><p>缺点：</p><ul><li>View层和Presenter层会交互过于频繁，若Presenter过多的渲染了View，往往导致过于紧密，若View发生改动，Presenter也要发生变更。</li><li>随着业务的复杂，Presenter的接口会越来越多，有其他的View引用到该Presenter时，也要去实现这些接口</li></ul><h2 id="3-MVVM模式"><a href="#3-MVVM模式" class="headerlink" title="3.MVVM模式"></a>3.MVVM模式</h2><p>MVVM(Model-View-ViewModel)是2015由微软提出的一个UI架构概念。将Presenter改为ViewModel，同时实现View和ViewModel的双向绑定（View的变动，自动反映在ViewModel，反之亦然）。</p><ul><li><p>Model：主要提供数据的存储过程</p></li><li><p>View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件</p></li><li><p>ViewModel：功能和Presenter类似，与View和Model双向绑定。只做业务逻辑与业务数据相关的事，内部不持有任何View，也不会引用View中的控件进行UI更新。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/pattern/mvvm_pattern.png" srcset="/img/loading.gif" class="full-image" alt="MVVM" title="MVVM"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul><p>优点：</p><ul><li>低耦合。View可以独立于Model变化和修改，ViewModel可以绑定不同的View</li><li>可重用性。把许多的试图逻辑处理放在一个ViewModel中，许多View可以使用该ViewModel</li><li>独立开发。开发人员可以专注于逻辑和数据的处理</li><li>可测试性。可以直接针对ViewModel进行单独测试。</li></ul><p>缺点：</p><ul><li>使得Bug很难调试，由于View和Model的双向绑定</li></ul><blockquote><p>可以使用Google官方提供的 <code>LiveData、ViewModel</code>去实现这套模式。</p></blockquote><h2 id="4-如何进行选择"><a href="#4-如何进行选择" class="headerlink" title="4.如何进行选择"></a>4.如何进行选择</h2><ol><li>如果项目简单，没什么复杂性，可以使用MVC架构，注意好封装各模块。</li><li>对于偏向展示型的App，业务逻辑多在后端实现，可以使用MVVM。</li><li>对于业务逻辑复杂且量级比较大的，推荐使用MVVM。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程保活介绍</title>
    <link href="/2018/04/12/%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E4%BB%8B%E7%BB%8D/"/>
    <url>/2018/04/12/%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h1><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/进程保活.png" srcset="/img/loading.gif" class="full-image" alt="进程保活" title="进程保活"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>进程保活的方式分为两个层面：<code>提高进程优先级，降低被杀死的概率</code>,<code>在进程被杀死后，进行拉活</code>。</p><h2 id="1-进程的优先级"><a href="#1-进程的优先级" class="headerlink" title="1. 进程的优先级"></a>1. 进程的优先级</h2>  <span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/process_level.webp" srcset="/img/loading.gif" class="full-image" alt="alt" title="进程优先级"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p> <code>优先级最低的进程首先被杀死、进程的等级会因为其他进程的依赖而提高一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低</code> </p><p>按重要性分类：</p><ul><li><strong>前台进程</strong>：进程持有一个正在与用户交互的Activity或者和交互Activity绑定的Service，前台运行的Service（执行<code>startForeground()</code>）,执行<code>onReceive()</code>的BroadcastReceiver</li><li><strong>可见进程</strong>：进程持有一个被用户可见但没有显示在最前端的Activity(调用到了<code>onPause()</code>)或者和可见Activity绑定的Service</li><li><strong>服务进程</strong>：进程持有一个<code>startService()</code>启动的Service进程，例如播放音乐，下载文件等Service</li><li><strong>后台进程</strong>：进程持有一个用户不可见的Activity(调用到<code>onStop()</code>没有到<code>onDestroy()</code>)，进程被存放在一个LRU列表中，即很长时间没用的Activity会被优先杀死</li><li><strong>空进程</strong>：进程不包含任何活跃的应用组件，唯一的作用是<code>为了缓存需要，缩短下次启动的时间</code></li></ul><h2 id="2-Android进程回收策略"><a href="#2-Android进程回收策略" class="headerlink" title="2. Android进程回收策略"></a>2. Android进程回收策略</h2><p>对于进程的回收，依靠LowmemoryKiller完成，按照OOM_ADJ的阈值级别触发对应的内存回收。<br> <span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/oom_adj.webp" srcset="/img/loading.gif" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><br>红色代表易被杀死的进程，绿色不易被杀死。LowmemoryKiller会优先杀死OOM_ADJ较大的进程，优先级相同则进一步受到进程所占内存和进程存活时间的影响。</p><h2 id="3-提升进程优先级"><a href="#3-提升进程优先级" class="headerlink" title="3. 提升进程优先级"></a>3. 提升进程优先级</h2><ul><li><strong>利用Activity提升权限</strong>：<code>监控手机锁屏解锁事件，在屏幕锁定时启动一个一像素的Activity，解锁时销毁。</code><strong>需把Activity设置成用户无感知</strong></li><li><strong>利用Notification提升权限</strong>：<code>Service的优先级为4，使用setForeground可以设置前台Service，提升进程的优先级，降低被杀的概率。</code><ul><li><strong>注意点</strong>：设置为前台Service时，在通知栏会显示一条通知。</li><li><strong>应对措施</strong>：可以去实现一个内部Service，在LiveService和其内部Service中同时发送相同ID的Notification，然后结束内部Service。内部Service被结束时，Notification也会消失，但是进程的优先级不会发生变化。</li></ul></li></ul><h2 id="4-进程死后拉活的方案"><a href="#4-进程死后拉活的方案" class="headerlink" title="4. 进程死后拉活的方案"></a>4. 进程死后拉活的方案</h2><ul><li><strong>利用系统广播拉活</strong>：在发生特定事件是，系统会发送相应的广播，可以在AndroidManifest中静态注册对应的广播监听器，即可在对应事件发生时拉活应用。以下是常见的拉活广播事件：<ul><li>开机广播：RECEIVE_BOOT_COMPLETED</li><li>网络变化：CHANGE_NETWORK_STATE,CHANGE_WIFI_STATE…</li><li>文件挂载：MOUNT_UNMOUNT_FILESYSTEMS</li><li>屏幕亮灭：SCREEN_ON,SCREEN_OFF</li><li>锁屏解锁：RECEIVE_USER_PRESENT</li><li>应用安装卸载：PACKAGE_ADDED,PACKAGE_REMOVED<br>缺点：</li><li>广播接收器容易被系统的管理软件通过“自启管理”禁用场景，从而无法处理</li><li>系统广播事件不可控，只能保证有对应事件是拉活进程，但不能保证能否立即拉活。</li></ul></li><li><strong>利用第三方应用广播拉活</strong>：该方案接受第三方应用的广播，反编译一些第三方应用，找到他们发送的广播，在自己应用内进行监听，当这些应用发送广播时，即可拉活自己的应用。<br>  缺点：<ul><li>需要反编译较多应用来确保效果</li><li>第三方应用的广播可能会在日后更新中修改或删除</li></ul></li><li><strong>利用系统Service机制拉活</strong>：把Service设置为<code>START_STICKY</code>，这个参数可以在Service被杀死后，利用系统机制尝试拉活。<br>  缺点：<ul><li>Service第一次被异常杀死后会在5秒内重启，第二层被杀死10秒内重启，第三次会在20秒内重启，一旦被杀死达到5次，则系统不会再重新拉活。</li><li>进程被Root权限的工具杀死活forcestop，无法重启。</li></ul></li><li><strong>利用Native进程拉活</strong>：利用Linux中的fork机制创建Native进程，在Native进程中监控主进程的存活，当主进程挂掉后，在Native进程中立即对主进程拉活。（该进程的生命周期不受Android的管理）。<br>  适用范围：<ul><li>在Android5.0以下版本手机效果很好，不受forcestop影响</li><li>在5.0以上的手机，Native进场也会被forcestop杀死，假如逻辑跑的比系统快，依然可以拉活。</li></ul></li><li><p><strong>利用JobScheduler机制拉活</strong>：系统在Android5.0以上版本提供了JobScheduler接口，系统会定时调用该进程使应用处理一些操作。<br>  适用范围：Android5.0以上系统手机，在部分小米手机可能无法拉活。</p>  <pre><code class="hljs java"><span class="hljs-meta">@TargetApi</span>(Build.VERSION_CODES.LOLLIPOP)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeepLiveService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JobService</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String TAG=<span class="hljs-string">"KeepLive"</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Service mKeepLiveService= <span class="hljs-keyword">null</span>;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onStartJob</span><span class="hljs-params">(JobParameters jobParameters)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onStopJob</span><span class="hljs-params">(JobParameters jobParameters)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startJobscheduler</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">int</span> jobId=<span class="hljs-number">1</span>;            JobInfo.Builder builder=<span class="hljs-keyword">new</span> JobInfo.Builder(jobId,                    <span class="hljs-keyword">new</span> ComponentName(MyApplication.getApplicationContext(),                            KeepLiveService<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;            builder.setPeriodic(<span class="hljs-number">10</span>);<span class="hljs-comment">//设置时间间隔</span>            builder.setPersisted(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//重启后需要继续执行</span>            JobScheduler js = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);            js.schedule(builder.build());        &#125;<span class="hljs-keyword">catch</span> (Throwable e)&#123;            e.printStackTrace();        &#125;    &#125;</code></pre></li><li><p><strong>利用账号同步进制拉活</strong>：Android系统的账号同步进制会定期同步执行，可以利用同步机制进行进程的拉活。<br>  适用范围：适用于所有的Android版本，在Android N中进行了一些变动，该方案失效。</p></li><li><strong>其他方案</strong>：<ul><li>利用系统通知权限进行拉活</li><li>利用辅助功能拉活，将应用加入厂商白名单</li><li>利用推送进行拉活（如小米、华为推送）</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关及其拓展(二) -- 虚拟机类加载机制</title>
    <link href="/2018/04/12/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%8C/"/>
    <url>/2018/04/12/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><code>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</code></p><h2 id="2-类的生命周期"><a href="#2-类的生命周期" class="headerlink" title="2.类的生命周期"></a>2.类的生命周期</h2><p>  类从被加载到虚拟机内存中开始，到卸载除内存为止，生命周期包括：<strong>加载(Loading)</strong>、<strong>验证(Verification)</strong>、<strong>准备(Preparation)</strong>、<strong>解析(Resolution)</strong>、<strong>初始化(Initialization)</strong>、<strong>使用(Using)</strong>、<strong>卸载(Unloading)</strong>。其中<code>验证</code>、<code>准备</code>、<code>解析</code>统称为<strong>连接(Linking)</strong><br><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/class_lifecycle.png" srcset="/img/loading.gif" class="full-image" alt="类的生命周期" title="类的生命周期"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><br>  加载、验证、准备、初始化和卸载阶段执行顺序为确定的，类的加载过程必须按照这个顺序开始。解析阶段不一定：在某些情况下可以在初始化阶段之后开始，为了支持Java语言的运行时绑定。<br>  初始化阶段，虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”：</p><ul><li>遇到<code>new ,getstatic,putstatic或invokestatic</code>指令时，类没有进行初始化，则需要先触发初始化。最常见的Java代码场景：使用new关键字实例化对象、读取或设置一个类的静态字段、调用一个类的静态方法。</li><li>使用<code>java.lang.reflect</code>进行反射调用的时候。</li><li>初始化一个类时，发现父类还没有初始化，先触发父类初始化方法。</li><li>虚拟机启动时，用户指定一个要执行的主类(包含<code>main()</code>方法的类)，先初始化该类。</li><li>使用动态语言支持时，若<code>java.lang.invoke,MethodHandle</code>实例最后解析结果为<code>REF_getStatic,REF_putStatic,REF_invokeStatic</code>的方法句柄，并且该类没有进行初始化。  </li></ul><p>使用阶段</p><p>执行类的初始化，主动引用会触发类的初始化，被动引用不会触发类的初始化过程。</p><h2 id="3-类加载的过程"><a href="#3-类加载的过程" class="headerlink" title="3.类加载的过程"></a>3.类加载的过程</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/类加载过程.png" srcset="/img/loading.gif" class="full-image" alt="类加载过程" title="类加载过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h3><p>虚拟机需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流 (<em>使用ClassLoader加载</em>)</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li></ol><p>并没有指定一个二进制字节流要从一个Class文件中获取</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h3><blockquote><p>（若代码被反复验证和使用过，可以使用<code>-Xverify:none</code>来关闭大部分的类验证措施，缩短虚拟机加载时间）</p></blockquote><p>验证是连接阶段的第一步，这一阶段的目的是为了<strong>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</strong>。<br>验证阶段大致需要完成以下4个阶段的检验动作：</p><ol><li><strong>文件格式验证</strong><br>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。<br><code>主要目的是保证输入的字节流能正确的解析并存储于方法区之内，格式上符合描述一个Java类信息的要求。在这个阶段字节流进入内存中的方法区后续不再操作字节流。</code></li><li><strong>元数据验证</strong><br>对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范</li><li><strong>字节码验证</strong><br>通过数据流和控制流分析，确定程序语义是合法且符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机的安全的事件。</li><li><strong>符号引用验证</strong><br>发生在虚拟机将符号引用转化为直接引用的时候，这个转化发生在解析阶段。对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验。<code>确保解析动作能正常执行</code></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h3><p><strong>准备阶段是正式为变量分配内存并设置类初始变量初始值的阶段</strong>，这些变量所使用的内存都将在方法区中进行分配。这个时候进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量。<br>初始值<code>通常情况</code>下是数据类型的零值，如</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<span class="hljs-comment">//在准备阶段过程中初始值为0，而不是123。</span></code></pre><p>  <code>特殊情况</code>：若类字段的属性表中有ConstantValue属性，那么准备阶段value就会初始化为ConstantValue指定的值，如<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<span class="hljs-comment">//在准备阶段过程中初始值为123。</span></code></pre></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h3><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。解析阶段中会涉及到<code>直接引用</code>(直接指向目标的指针、相对偏移量或者是一个能直接定位到目标的句柄)，<code>符号引用</code>(以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可)。<br>解析动作主要针对<code>类或接口（CONSTANT_Class_info）</code>、<code>字段（CONSTANT_Fieldref_info）</code>、<code>类方法（CONSTANT_Methodref_info）</code>、<code>接口方法（CONSTANT_InterfaceMethodref_info）</code>、<code>方法类型（CONSTANT_MethodType_info）</code>、<code>方法句柄（CONSTANT_MethodHandle_info）</code>、<code>调用点限定符（CONSTANT_InvokeDynamic_info）</code>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><p>初始化是类加载过程的最后一步。<strong>到这里才真正开始执行类中定义的Java程序代码</strong>。<br>执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><ul><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</li><li><code>&lt;clinit&gt;()</code>方法与类的构造函数不同，他不需要显示的调用父类构造器，因此虚拟中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是<code>java.long.object</code>。</li><li><strong>初始化过程就是对变量进行赋值及执行静态代码块。</strong></li></ul><h2 id="4-类的卸载"><a href="#4-类的卸载" class="headerlink" title="4.类的卸载"></a>4.类的卸载</h2><p><strong>由JVM自带的类加载器(<code>Bootstrap ClassLoader-根加载器、Extension ClassLoader-拓展加载器、Application ClassLoader-应用加载器</code>)所加载的类，在虚拟机的生命周期中，始终不会被卸载。</strong>这一切是由于Java本身始终引用这些加载类，导致被加载的类对象也会一直可达。</p><p><strong>只有由用户自定义的类加载器所加载的类是可以被卸载的。</strong></p><p>类卸载的触发条件：</p><ul><li>该类所有的实例都已经被GC，也就是在JVM中不存在该类的任何实例</li><li>加载该类的ClassLoader也被GC</li><li>该类的java.lang.Class对象没有在任何地方被引用，如反射都无法访问该类</li></ul><p>类卸载过程：</p><p>在方法区内的二进制数据会被卸载。</p><p><strong>若卸载后还需要使用，那么就需要去重新加载，然后在Java的虚拟机堆区上重新生成实例。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM相关及其拓展（一）-- JVM内存区域</title>
    <link href="/2018/04/10/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/"/>
    <url>/2018/04/10/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-JVM内存区域"><a href="#1-JVM内存区域" class="headerlink" title="1. JVM内存区域"></a>1. JVM内存区域</h1><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/jvm_data.png" srcset="/img/loading.gif" class="full-image" alt="JVM运行时数据区" title="JVM运行时数据区"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>JVM在执行Java程序的过程中会把管理的内存分为若干个数据局域。</p><ul><li><strong>程序计数器(Program Counter Register)</strong>：一块较小的内存空间，可看作为<strong>当前线程所执行的字节码的行号指示器</strong>。每条线程都需要一个独立的程序计数器，所以为线程私有区域。<code>没有规定任何OutOfMemoryError情况的区域</code>。<code>线程执行Java方法，则记录正在执行的虚拟机字节码指令地址，若为Native方法，则计数器值则为Undefined</code></li></ul><ul><li><strong>Java虚拟机栈(VM Stack)</strong>：虚拟机栈是线程私有的，生命周期与线程相同。描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行时都会创建一个栈帧用于存储局部变量表(存放编译器可知的各种基本数据类型<code>boolean,byte,char,int,long,float,double,short</code>,对象引用和returnAddress类型)，操作树栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。这个区域存在两种异常情况：<code>StackOverflowError：请求栈深度大于虚拟机所允许的深度</code>，<code>OutOfMemoryError：无法申请到足够的内存</code></li></ul><ul><li><p><strong>本地方法栈(Native Method Stack)</strong>：本地方法栈是线程私有的，虚拟机执行Native方法的服务，和虚拟机栈类似存在两个异常情况。</p></li><li><p><strong>Java堆(Heap)</strong>：JVM管理内存中最大的一块。是被所有线程共享的一块区域，在虚拟机启动时创建。唯一目的<code>存放对象实例</code>，几乎所有对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为”GC堆”。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，则抛出OutOfMemoryError异常。</p></li><li><p><strong>方法区(Method Area)</strong>：方法区与Java堆一样，是各个线程共享的内存区域。<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。同Java堆一样会抛出OutOfMemoryError异常。</p></li><li><p><strong>运行时常量池(Runtime Constant Pool)</strong>：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一个是常量池（存放编译器生成的各种字面量和符号引用）。有一个重要特征是具有动态性，运行期也可以将新的常量放入池中。受到方法区内存的限制，也会抛出OutOfMemoryError异常。</p></li><li><p><strong>直接内存(Direct Memory)</strong>：不属于虚拟机运行时数据区的一部分。</p></li></ul><blockquote><p>拓展：</p><ul><li>程序计数器，虚拟机栈，本地方法栈随着线程生命周期变化，生则生，死则死。</li><li>程序计数器，虚拟机栈，本地方法栈不需要过多考虑内存回收问题，随着方法结束或者线程结束时，内存随着就会回收。<br>堆和栈在操作系统内的区别？<br>都是内存存放数据的地方。具体区别在于：</li><li>栈内存：主要用于存放<strong>基本数据类型和局部变量</strong>；在代码块中定义一个变量时，便会在栈中为这个变量分配内存空间，超过变量的作用域后块空间就会被自动释放掉。</li><li>堆内存：用于存放<strong>‌运行时创建的对象</strong>，比如通过<code>new</code>创建出的对象，需要交由GC来对其进行回收。</li></ul></blockquote><p>简述：JVM的内存区域主要有以下5类：</p><ol><li>程序计数器：线程私有，当前线程所执行的字节码的行号指示器</li><li>虚拟机栈：线程私有，存放基本数据类型、对象引用和returnAddress类型，会发生内存溢出异常</li><li>本地方法栈：线程私有，为JVM中用到的Native方法服务，会发生内存溢出异常</li><li>Java堆：线程共享，存放对象的实例，也是GC回收管理器的主要区域，会发生内存溢出异常</li><li>方法区：线程共享，存储已被JVM加载的类信息、常量、静态变量、即时编译后的代码等数据，会发生内存溢出异常</li></ol><h1 id="2-HotSpot虚拟机对象创建，布局以及访问"><a href="#2-HotSpot虚拟机对象创建，布局以及访问" class="headerlink" title="2.HotSpot虚拟机对象创建，布局以及访问"></a>2.HotSpot虚拟机对象创建，布局以及访问</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>   在语言层面上，创建对象只需要一个<code>new</code>关键字。<br>   在虚拟机中，分为以下几步：</p><ul><li><strong>遇到一条new指令时，先去检查指令对应参数是否在常量池中可以定位到一个符号的引用，并且检查指令的参数是否已被加载、解析和初始化过。若无则需要执行相应的类加载过程。</strong></li><li><strong>类加载检查通过后，将为新生对象分配内存。</strong>对象所需的内存大小在类加载完成后便可确定，这块内存由Java堆中划分出来。内存的分配方式由Java堆中内存是否规整决定（<code>已使用的内存和空闲内存是否相互交错</code>）。规整则使用 <strong>指针碰撞</strong>（<code>把指针向空闲空间挪动对象大小的距离</code>），不规整则使用<strong>空闲列表</strong>（<code>虚拟机内维护一个列表用来记录内存块中的可用区域，然后找到一块足够大的空间划分给对象实例</code>）。</li><li><strong>处理并发安全问题。</strong>除了如何分配内存，还需要考虑虚拟机中对象创建是非常频繁的行为，就会涉及到线程安全。解决这个问题有两种方案：<ul><li>对分配内存空间的行为进行同步处理</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<code>本地线程分配缓存(TLAB)</code>。哪个线程需要分配内存就在哪个TLAB上分配，只有TLAB用完了，才同步申请另一块内存。</li></ul></li><li><strong>内存分配完成后，虚拟机将需要分配到的内存空间都初始化为零值（不包括对象头）。</strong>这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>虚拟机对对象进行设置，将<code>类的元数据信息、对象的哈希码、对象的GC分代年龄信息</code>存入对象头中。</strong></li><li><strong>执行init方法初始化。</strong>从虚拟机角度来说，对象已经产生完成，从Java方面来说才刚刚开始，要等到new指令执行并\&lt;init>方法执行后，把对象按照意愿初始化后，真正可用的对象生成完毕。</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Jvm对象创建过程.png" srcset="/img/loading.gif" class="full-image" alt="Jvm对象创建过程" title="Jvm对象创建过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：<code>对象头(Header)</code>、<code>实例数据(Instance Data)</code>和<code>对齐填充(Padding)</code></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><strong>存储自身的运行时数据</strong></p><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>膨胀(重量锁)</td></tr><tr><td>空，不需要记录信息</td><td>11</td><td>GC标记</td></tr><tr><td>偏向线程ID，偏向时间戳，对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table><p><strong>类型指针</strong><br>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象为一个Java数组，则对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>里面是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。在分配策略中，相同宽度的字段总是会被分配在一起。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>并非必然存在的，也没有特别的含义。仅仅起着占位符的作用。当实例数据部分没有对齐时，需要对齐填充来补全。</p><h2 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h2><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式是<code>句柄访问</code>和<code>直接指针访问</code>。</p><ul><li>使用句柄访问：Java堆中会划分出一块内存来作为句柄池，<code>refrence中存储的对象就是对象的句柄地址</code>，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<br>  <strong>句柄访问的最大好处是refrence中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，refrence本身不会有修改。</strong><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/get_object_by_handle.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li><li>使用直接指针访问：Java堆对象需要考虑如何放置访问类型数据的相关信息，而<code>refrence中存储的直接就是对象地址</code>。<br>  <strong>直接访问的最大好处是速度快，节省了一次指针定位的时间开销，在Java HotSpot虚拟机中很常用。</strong><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/get_object_direct.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式--静态代理模式和动态代理模式原理及实现</title>
    <link href="/2018/04/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2018/04/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式（委托模式）"><a href="#代理模式（委托模式）" class="headerlink" title="代理模式（委托模式）"></a>代理模式（委托模式）</h1><blockquote><p><strong>为其他对象提供一种代理以控制对这个对象的访问</strong>。引入<strong>代理对象</strong>来间接访问<strong>目标对象</strong></p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Pattern-Proxy.png" srcset="/img/loading.gif" class="full-image" alt="代理模式" title="代理模式"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>代理模式优点：</p><ul><li>职责清晰：真实的角色就是实现实际的业务逻辑，不需关心其他非本职责的事务</li><li>高扩展性：代理类可以在不做任何修改的情况下继续使用</li><li>智能化：动态代理演示</li></ul><p>代理模式缺点：</p><ol><li>在客户端和真实对象之间添加了代理，会造成请求的处理速度变慢</li><li>实现代理模式比较复杂，需要额外的工作</li></ol><p>代理模式的扩展：</p><ol><li><p>普通代理</p><blockquote><p>客户端只能访问代理角色，而不能直接访问真实角色。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">//屏蔽了GamePlayer的真实角色访问</span>        GamePlayerProxy gamePlayerProxy = <span class="hljs-keyword">new</span> GamePlayerProxy(<span class="hljs-string">"wxy"</span>);        gamePlayerProxy.login(<span class="hljs-string">"wxy"</span>,<span class="hljs-string">"124"</span>);        gamePlayerProxy.killBoss();        gamePlayerProxy.upgrade();    &#125;&#125;</code></pre><p>Client只是调用了<code>GamePlayerProxy</code>代理角色，而不知道真实角色是谁。<strong>非常适合扩展性要求较高的场景。</strong></p></li><li><p>强制代理</p><blockquote><p>通过真实角色来找到代理角色，否则不能访问。<strong>由真实角色来管理代理角色。不允许直接访问真实角色</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        <span class="hljs-comment">//必须是真实角色的代理对象才可以使用</span>        IGamePlayer gamePlayerProxy = <span class="hljs-keyword">new</span> GamePlayer(<span class="hljs-string">"wxy"</span>).getProxy();        <span class="hljs-comment">//直接生成代理对象无效</span>        <span class="hljs-comment">//GamePlayerProxy gamePlayerProxy = new GamePlayerProxy(new GamePlayer("wzr5"));</span>        gamePlayerProxy.login(<span class="hljs-string">"wxy"</span>,<span class="hljs-string">"124"</span>);        gamePlayerProxy.killBoss();        gamePlayerProxy.upgrade();    &#125;&#125;</code></pre></li><li><p>代理是有个性的</p><blockquote><p>一个类可以实现多个接口，完成不同任务的整合。<strong>代理类不仅可以实现主题接口，也可以实现其他接口完成不同的任务。</strong></p></blockquote></li><li><p><strong>动态代理</strong></p><blockquote><p>不需要<strong>显式实现与目标对象类相同的接口</strong>，将这种实现推迟到程序运行时由JVM实现。</p></blockquote><p>原理：通过Java反射机制的<code>method.invoke()</code>调用动态代理类对象方法，从而自动调用目标对象的方法。</p><p>优点：1. 只需要一个代理类就可以解决创建多个静态代理的问题，避免重复代码。2. 更加灵活</p><p>缺点：1. 效率低 <code>需要通过反射机制，间接调用目标对象方法</code> 2.应用场景局限<code>只能针对接口创建代理类，即只能动态代理实现了接口的类</code></p><p>应用场景：</p><ul><li><p>需要代理对象数量较多的情况下使用</p></li><li><p><code>AOP</code>-面向切面编程</p><blockquote><p>可以通过预编译的方式在运行期动态代理实现程序功能的统一维护，有效降低业务之间的耦合度，提供程序的可用性并提高了开发的效率。开发中主要用在日志收集，性能分析等。</p></blockquote></li></ul><p>使用方法：</p><ol><li><p>声明调用代理类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GamePlayIH</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-comment">//被代理实例</span>    T obj ;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GamePlayIH</span><span class="hljs-params">(T _obj)</span> </span>&#123;        <span class="hljs-keyword">this</span>.obj = _obj;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        Object result = method.invoke(<span class="hljs-keyword">this</span>.obj, args);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></li><li><p>声明目标对象类的抽象接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IGamePlayer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String user, String pwd)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">killBoss</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upgrade</span><span class="hljs-params">()</span></span>;&#125;</code></pre></li><li><p>声明目标对象类</p><pre><code class="hljs undefined">public class GamePlayer implements IGamePlayer &#123;    private String name = &quot;&quot;;    public GamePlayer(String _name) &#123;        this.name = _name;    &#125;    @Override    public void login(String user, String pwd) &#123;            System.err.println(&quot;登录名为：&quot; + user + &quot;  用户名为：&quot; + this.name + &quot;登录游戏&quot;);    &#125;    @Override    public void killBoss() &#123;           System.err.println(this.name + &quot;打Boss&quot;);    &#125;    @Override    public void upgrade() &#123;            System.err.println(this.name + &quot;升级了&quot;);    &#125;&#125;</code></pre></li><li><p>通过动态代理对象，调用目标方法</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建目标对象</span>        IGamePlayer player = <span class="hljs-keyword">new</span> GamePlayer(<span class="hljs-string">"wxy"</span>);        <span class="hljs-comment">//创建调用处理对象</span>        InvocationHandler handler = <span class="hljs-keyword">new</span> GamePlayIH&lt;&gt;(player);        <span class="hljs-comment">//指定产生代理对象的类加载器</span>        ClassLoader cl = player.getClass().getClassLoader();        <span class="hljs-comment">//创建动态代理对象</span>        IGamePlayer gamePlayerProxy = (IGamePlayer) Proxy.newProxyInstance(cl, <span class="hljs-keyword">new</span> Class[]&#123;IGamePlayer<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;, <span class="hljs-title">handler</span>)</span>;        <span class="hljs-comment">//调用动态代理对象方法</span>        gamePlayerProxy.login(<span class="hljs-string">"wxy"</span>, <span class="hljs-string">"124"</span>);        gamePlayerProxy.killBoss();        gamePlayerProxy.upgrade();    &#125;&#125;</code></pre></li></ol></li></ol><p><code>Proxy</code>：提供用于创建动态代理类和实例的静态方法，并且还是创建出代理类的超类。</p><p><code>InvocationHandler</code>：调用处理器接口，自定义<code>invoke()</code>，用于实现对真正委托类的代理方法。<strong>生成动态代理类实际调用的是<code>invoke()</code>。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android触摸事件分发</title>
    <link href="/2018/04/09/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <url>/2018/04/09/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-触摸事件的类型"><a href="#1-触摸事件的类型" class="headerlink" title="1.触摸事件的类型"></a>1.触摸事件的类型</h1><p>对应的类是<code>MotionEvent</code>，主要有以下三个类型：</p><ul><li><strong>ACTION_DOWN</strong>：监听用户手指按下的操作，一次按下标志触摸事件的开始。</li><li><strong>ACTION_MOVE</strong>：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。</li><li><strong>ACTION_UP</strong>：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。</li><li><strong>ACTION_CANCEL</strong>：当用户保持按下操作，并把手指移动到了控件外部局域时且父View处理事件触发。</li></ul><h1 id="2-事件传递的三个阶段"><a href="#2-事件传递的三个阶段" class="headerlink" title="2.事件传递的三个阶段"></a>2.事件传递的三个阶段</h1><ul><li><p><strong>分发（Dispatch）</strong>：事件的分发对应着<code>dispatchTouchEvent</code>方法，所有触摸事件由这个方法进行分发</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span></span></code></pre><p>在这个方法中，根据当前视图的需求来进行事件的分发给子视图还是直接消费不往下传递，返回<code>true</code>表示事件被消费，不往下传递。返回值为<code>super.dispatchTouchEvent</code>表示继续往下传递。</p></li><li><p><strong>拦截（Intercept）</strong>:事件的拦截对应着<code>onInterceptTouchEvent</code>方法，这个事件只在ViewGroup及其子类中存在。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span></span></code></pre><p>根据具体的逻辑，返回<code>true</code>表示拦截该事件，不继续把事件分发给子视图，交由自身的<code>onTouchEvent</code>进行处理，返回值为<code>false或super.onInterceptTouchEvent</code>表示继续往下传递。</p></li><li><p><strong>消费（Consume）</strong>：事件的消费对应着<code>onTouchEvent</code>方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span></span></code></pre><p>返回值为<code>true</code>时，表示当前视图可以处理事件，不会向上传递给父视图；返回值为<code>false</code>表示当前视图不处理这个事件，事件传递给父视图的<code>onTouchevent</code>进行处理。</p></li></ul><blockquote><p>在Android系统中，可以处理事件传递的类有以下三种：</p><ul><li><strong>Activity</strong>：包含<code>dispatchTouchEvent</code>，<code>onTouchEvent</code>方法</li><li><strong>ViewGroup</strong>：包含<code>dispatchTouchEvent</code>，<code>onInterceptTouchEvent</code>，<code>onTouchEvent</code></li><li><strong>View</strong>：包含<code>dispatchTouchEvent</code>，<code>onTouchEvent</code>方法</li></ul></blockquote><h1 id="3-View的事件传递机制"><a href="#3-View的事件传递机制" class="headerlink" title="3.View的事件传递机制"></a>3.View的事件传递机制</h1><p>View包括TextView，ImageView等子类，不包括ViewGroup。</p><pre><code class="hljs java"><span class="hljs-comment">/*** Custom TextView with touchevent*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTextView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatTextView</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG=<span class="hljs-string">"MyTextView"</span>;    ...     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (event.getAction()) &#123;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_DOWN"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_UP"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_MOVE"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_CANCEL"</span>);                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);②    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (event.getAction()) &#123;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_DOWN"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_UP"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_MOVE"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_CANCEL"</span>);                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event);④    &#125;    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG=<span class="hljs-string">"MainActivity"</span>;    MyTextView mtv;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        mtv= (MyTextView) findViewById(R.id.mtv);        mtv.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View view)</span> </span>&#123;                Log.e(TAG,<span class="hljs-string">"MyTextView_onclick"</span>);            &#125;        &#125;);        mtv.setOnTouchListener(<span class="hljs-keyword">new</span> View.OnTouchListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouch</span><span class="hljs-params">(View view, MotionEvent event)</span> </span>&#123;                <span class="hljs-keyword">switch</span> (event.getAction()) &#123;                    <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:                        Log.e(TAG,<span class="hljs-string">"MyTextView_onTouch_ACTION_DOWN"</span>);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:                        Log.e(TAG,<span class="hljs-string">"MyTextView_onTouch_ACTION_UP"</span>);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:                        Log.e(TAG,<span class="hljs-string">"MyTextView_onTouch_ACTION_MOVE"</span>);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:                        Log.e(TAG,<span class="hljs-string">"MyTextView_onTouch_ACTION_CANCEL"</span>);                        <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;③            &#125;        &#125;);    &#125; <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUserInteraction</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.onUserInteraction();        Log.e(TAG,<span class="hljs-string">"onUserInteraction"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (event.getAction()) &#123;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_DOWN"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_UP"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_MOVE"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_CANCEL"</span>);                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);①    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (event.getAction()) &#123;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_DOWN"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_UP"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_MOVE"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_CANCEL"</span>);                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event);    &#125;&#125;</code></pre><ul><li><p>常规输出：(返回的都为默认值)</p><ul><li>点击MyTextView区域</li></ul><pre><code class="hljs java">E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MyTextView: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyTextView: dispatchTouchEvent_ACTION_UPE/MainActivity: MyTextView_onTouch_ACTION_UPE/MyTextView: onTouchEvent_ACTION_UPE/MainActivity: MyTextView_onclick</code></pre><ul><li>点击MyTextView外部区域</li></ul><pre><code class="hljs java">E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MainActivity: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_MOVEE/MainActivity: onTouchEvent_ACTION_MOVEE/MainActivity: dispatchTouchEvent_ACTION_UPE/MainActivity: onTouchEvent_ACTION_UP</code></pre></li><li><p>① <strong>Activity的dispatchTouchEvent()</strong><code>return true;或return false;</code></p><pre><code class="hljs java">E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_MOVEE/MainActivity: dispatchTouchEvent_ACTION_MOVEE/MainActivity: dispatchTouchEvent_ACTION_UP</code></pre><blockquote><p>不会再继续分发触摸事件，及后续控件的触摸事件都不会响应。</p></blockquote></li><li><p>② <strong>View的dispatchTouchEvent()</strong><code>return true;</code>不会调用MyTextView的<code>onClick</code>事件</p><pre><code class="hljs java">E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MyTextView: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyTextView: dispatchTouchEvent_ACTION_UPE/MainActivity: MyTextView_onTouch_ACTION_UPE/MyTextView: onTouchEvent_ACTION_UP</code></pre><p><strong>View的dispatchTouchEvent()</strong><code>return false;</code>只响应MyTextView的<code>ACTION_DOWN</code>事件，后续的处理由MainActivity的<code>onTouchEvent</code>执行</p><pre><code class="hljs java">E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_MOVEE/MainActivity: onTouchEvent_ACTION_MOVEE/MainActivity: dispatchTouchEvent_ACTION_UPE/MainActivity: onTouchEvent_ACTION_UP</code></pre></li><li><p>③<strong>Activity中View的onTouch()</strong><code>return true;</code>不往下分发事件及不会调用到<code>onClick</code>事件</p><pre><code class="hljs java">E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyTextView: dispatchTouchEvent_ACTION_UPE/MainActivity: MyTextView_onTouch_ACTION_UP</code></pre></li><li><p>④ <strong>View的onTouchEvent()</strong><code>return true;</code>不触发<code>onClick</code>事件</p><pre><code class="hljs java">E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MyTextView: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyTextView: dispatchTouchEvent_ACTION_UPE/MainActivity: MyTextView_onTouch_ACTION_UPE/MyTextView: onTouchEvent_ACTION_UP</code></pre><p><strong>View的onTouchEvent()</strong><code>return false;</code>只响应MyTextView的<code>ACTION_DOWN</code>事件，后续的处理由MainActivity的<code>onTouchEvent</code>执行</p><pre><code class="hljs java">E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MyTextView: onTouchEvent_ACTION_DOWNE/MainActivity: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MainActivity: onTouchEvent_ACTION_UP</code></pre></li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/Activity-View dispatch.png" srcset="/img/loading.gif" class="full-image" alt="View的事件传递" title="View的事件传递"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>总结：</p><ul><li><p>触摸事件传递从dispatchTouchEvent开始，在不修改默认返回的数值时，事件会按照嵌套层次由外向内传递，到达最内层的View时，就由它的onTouchEvent处理。</p></li><li><p>若事件在传递过程中，返回参数设为true，则导致事件提前被消费，内层View无法处理事件</p></li><li><p>View的事件触发顺序为先执行onTouch方法，最后执行onClick方法。onTouch返回false，则会响应onClick，否则事件不会继续传递。</p></li><li><p>View的点击事件流程：</p><p><strong>Activity.dispatchTouchEvent() -&gt; View.dispatchTouchEvent()-&gt;View.onTouch()-&gt;View.onTouchEvent()-&gt;View.onClick()</strong></p></li></ul></blockquote><h1 id="4-ViewGroup事件传递机制"><a href="#4-ViewGroup事件传递机制" class="headerlink" title="4.ViewGroup事件传递机制"></a>4.ViewGroup事件传递机制</h1><p>ViewGroup作为View的容器存在，ViewGroup包括LinearLayout，RelativeLayout等。</p><pre><code class="hljs java"><span class="hljs-comment">/*** Custom ViewGroup with touchEvent*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRelativeLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RelativeLayout</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG=<span class="hljs-string">"MyRelativeLayout"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRelativeLayout</span><span class="hljs-params">(Context context)</span> </span>&#123;        <span class="hljs-keyword">super</span>(context);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRelativeLayout</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> </span>&#123;        <span class="hljs-keyword">super</span>(context, attrs);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (event.getAction()) &#123;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_DOWN"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_UP"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_MOVE"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:                Log.e(TAG,<span class="hljs-string">"dispatchTouchEvent_ACTION_CANCEL"</span>);                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (event.getAction()) &#123;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:                Log.e(TAG,<span class="hljs-string">"onInterceptTouchEvent_ACTION_DOWN"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:                Log.e(TAG,<span class="hljs-string">"onInterceptTouchEvent_ACTION_UP"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:                Log.e(TAG,<span class="hljs-string">"onInterceptTouchEvent_ACTION_MOVE"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:                Log.e(TAG,<span class="hljs-string">"onInterceptTouchEvent_ACTION_CANCEL"</span>);                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onInterceptTouchEvent(event);⑥    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (event.getAction()) &#123;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_DOWN"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_UP"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_MOVE"</span>);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:                Log.e(TAG,<span class="hljs-string">"onTouchEvent_ACTION_CANCEL"</span>);                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event);    &#125;&#125;</code></pre><ul><li><p>常规模式（全为默认值）</p><pre><code class="hljs log">E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWNE/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MyTextView: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyRelativeLayout: dispatchTouchEvent_ACTION_UPE/MyRelativeLayout: onInterceptTouchEvent_ACTION_UPE/MyTextView: dispatchTouchEvent_ACTION_UPE/MainActivity: MyTextView_onTouch_ACTION_UPE/MyTextView: onTouchEvent_ACTION_UPE/MainActivity: MyTextView_onclick</code></pre></li><li><p>ViewGroup.onInterceptTouchEvent()返回true</p><pre><code class="hljs java">E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWNE/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWNE/MainActivity: MyRelativeLayoutonTouch_ACTION_DOWNE/MyRelativeLayout: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyRelativeLayout: dispatchTouchEvent_ACTION_UPE/MainActivity: MyRelativeLayout_onTouch_ACTION_UPE/MyRelativeLayout: onTouchEvent_ACTION_UP</code></pre></li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/Activity-ViewGroup-View dispatch.png" srcset="/img/loading.gif" class="full-image" alt="View的事件传递" title="View的事件传递"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>总结:</p><ul><li><p>对于一个包裹在ViewGroup中的View，点击发生的触摸流程为：</p><p><strong>Activity.dispatchTouchEvent()-&gt;ViewGroup.dispatchTouchEvent()-&gt;ViewGroup.onInterceptTouchEvent()-&gt;View.dispatchTouchEvent()-&gt;View.onTouch()-&gt;View.onTouchEvent()-&gt;View.onClick()</strong></p></li><li><p>dispatchTouchEvent事件分发逻辑如下：</p><p>如果 return true，事件会分发给当前 View 并由 dispatchTouchEvent 方法进行消费，同时事件会停止向下传递；<br>如果 return false，事件分发分为两种情况：<br>1.如果当前 View 获取的事件直接来自 Activity，则会将事件返回给 Activity 的 onTouchEvent 进行消费；<br>2.如果当前 View 获取的事件来自外层父控件，则会将事件返回给父 View 的  onTouchEvent 进行消费。</p></li><li><p>onInterceptTouchEvent 的事件拦截逻辑如下：<br> 如果 onInterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理；<br>  如果 onInterceptTouchEvent 返回 false或super.onInterceptTouchEvent(ev)，则表示将事件放行，当前 View 上的事件会被传递到子 View 上，再由子 View 的 dispatchTouchEvent 来开始这个事件的分发；</p></li><li>onTouchEvent 的事件响应逻辑如下：<br>   如果事件传递到当前 View 的 onTouchEvent 方法，而该方法返回了 false，那么这个事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，如果传递到上面的 onTouchEvent 也返回 false，这个事件就会“消失”，而且接收不到下一次事件。<br>   如果返回了 true 则会接收并消费该事件。<br>   如果返回 super.onTouchEvent(ev) 默认处理事件的逻辑和返回 false 时相同。</li></ul></blockquote><h1 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5.源码分析"></a>5.源码分析</h1><p>//TODO</p><h1 id="6-实例分析"><a href="#6-实例分析" class="headerlink" title="6.实例分析"></a>6.实例分析</h1>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热修复基本原理</title>
    <link href="/2018/04/07/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <url>/2018/04/07/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<!-- <blockquote class="blockquote-center">热修复主要用来解决线上出现大问题的一个补救方案。</blockquote> --><blockquote><p>目前流行的热修复方案主要有以下三种：</p><ul><li>代码修复</li><li>资源修复</li><li>动态链接库修复</li></ul></blockquote><p>本章主要讲述 第一种方案：<strong>代码修复</strong>。</p><h2 id="代码修复"><a href="#代码修复" class="headerlink" title="代码修复"></a>代码修复</h2><blockquote><p>原理：对出现Bug的类进行修改或替换</p></blockquote><h3 id="类加载方案"><a href="#类加载方案" class="headerlink" title="类加载方案"></a>类加载方案</h3><blockquote><p>核心思想：使用Android的类加载器，通过类加载器去加载已修复好Bug的Class并对有问题的Class进行覆盖。</p><p><strong>加载完成后需要重启应用才可生效，因为当前在使用的类是无法卸载的即不可替换，只有重启后重新加载才可成功。</strong></p></blockquote><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li><p><code>65536限制</code></p><p>随着应用功能越来越复杂，代码量不断地增大，引入的库也会越来越多，可能导致出现异常</p><pre><code class="hljs undefined">com.android.dex.DexIndexOverflowException:method ID not in [0,0xffff]：65536</code></pre><p>应用中是限制了引用方法超过最大数65536个。限制是由于<code>DVM bytecode</code>的限制导致的，因为DVM指令集的方法调用指令<code>invoke-kind</code>索引最大值为16bits，故为65536个方法。</p></li><li><p><code>LinearAlloc限制</code></p><p>在安装应用时可能会提示<code>INSTALL_FAILED_DEXOPT</code>，产生的原因就是<code>LinearAlloc</code>限制，LinearAlloc是一个固定的缓存区，超出即会报错。</p></li></ul><p>为了解决上述的两个问题，产生了<strong>DEX分包方案</strong>。主要在打包时将应用代码分成多个Dex，将应用启动时必须的类以及直接引用类放入主Dex中，其他代码放到次Dex中。<em>应用启动时就先去加载主Dex，然后动态加载次Dex，从而缓解上述限制</em>。</p><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>类加载方案需要通过<code>ClassLoader</code>的实现类完成。在Android中主要有两种类加载器：</p><ul><li><p>DexClassLoader</p><blockquote><p>继承自BaseDexClassLoader，支持加载包含classes.dex的jar、apk，zip文件，可以是SD卡的路径。是实现热修复的关键。<strong>注意不要把优化后的文件放在外部存储，可能导致注入攻击。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDexClassLoader</span></span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DexClassLoader</span><span class="hljs-params">(String dexPath, String optimizedDirectory,            String librarySearchPath, ClassLoader parent)</span> </span>&#123;        <span class="hljs-keyword">super</span>(dexPath, <span class="hljs-keyword">null</span>, librarySearchPath, parent);    &#125;&#125;</code></pre></li><li><p>PathClassLoader</p><blockquote><p>用来加载Android系统类和应用程序的类，<strong>在dalvik上只能加载已安装apk的dex(/data/app目录)，在ART虚拟机上则没有这个限制</strong>。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PathClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDexClassLoader</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, ClassLoader parent)</span> </span>&#123;      <span class="hljs-keyword">super</span>(dexPath,<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, parent);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;      <span class="hljs-keyword">super</span>(dexPath,<span class="hljs-keyword">null</span>, librarySearchPath, parent);  &#125;&#125;</code></pre></li></ul><h5 id="上述类加载器都继承自BaseDexClassLoader。"><a href="#上述类加载器都继承自BaseDexClassLoader。" class="headerlink" title="上述类加载器都继承自BaseDexClassLoader。"></a>上述类加载器都继承自<code>BaseDexClassLoader</code>。</h5>  <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseDexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DexPathList pathList;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseDexClassLoader</span><span class="hljs-params">(String dexPath, File optimizedDirectory,            String librarySearchPath, ClassLoader parent)</span> </span>&#123;      <span class="hljs-keyword">super</span>(parent);      <span class="hljs-keyword">this</span>.pathList = <span class="hljs-keyword">new</span> DexPathList(<span class="hljs-keyword">this</span>, dexPath, librarySearchPath, <span class="hljs-keyword">null</span>);     ...   &#125;    ...  <span class="hljs-meta">@Override</span>  <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;      List&lt;Throwable&gt; suppressedExceptions = <span class="hljs-keyword">new</span> ArrayList&lt;Throwable&gt;();      <span class="hljs-comment">//根据类名去找出对应的类文件</span>      Class c = pathList.findClass(name, suppressedExceptions);      <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;          ClassNotFoundException cnfe = <span class="hljs-keyword">new</span> ClassNotFoundException(                 <span class="hljs-string">"Didn't find class \""</span> + name + <span class="hljs-string">"\" on path: "</span> + pathList);          <span class="hljs-keyword">for</span> (Throwable t : suppressedExceptions) &#123;              cnfe.addSuppressed(t);          &#125;          <span class="hljs-keyword">throw</span> cnfe;      &#125;      <span class="hljs-keyword">return</span> c;  &#125;&#125;</code></pre><p>  主要构造函数介绍：</p><ul><li><code>dexPath</code>：指<code>目标类所在的apk、dex或jar文件的路径，也可以是SD卡的路径</code>，类加载器从该路径加载目标类。如果包含多个路径，路径之间必须用特定的分隔符去分隔，特定的分隔符从<code>System.getProperty(&quot;path.separtor&quot;)</code>获取（默认分割符为”:”）。最终将路径上的文件ODEX优化到optimizedDirectory，然后进行加载。</li><li><code>optimizedDirectory</code>：解压出的dex文件路径，这个路径必须为内部路径，一般情况下的路径为<code>/data/data/&lt;Package_Name&gt;/</code></li><li><code>librarySearchPath</code>：存放目标类中使用的native文件库，也以”:”分割</li><li><code>parent</code>：父加载器，在Android中以<code>context.getClassLoader</code>作为父加载器。</li></ul><blockquote><p>在Android8.0之后，<code>optimizedDirectory</code>参数失效。由子类去控制解压文件路径。</p></blockquote><p><code>findClass()</code>用来加载dex中的Class文件。内部调用到<code>DexPathList.findClass()</code>实现</p><h5 id="DexPathList"><a href="#DexPathList" class="headerlink" title="DexPathList"></a>DexPathList</h5><blockquote><p>内部存储的是一个个的Dex文件地址，方便后续进行寻找调用</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DexPathList</span></span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEX_SUFFIX = <span class="hljs-string">".dex"</span>;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String zipSeparator = <span class="hljs-string">"!/"</span>;    <span class="hljs-comment">/** class definition context */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader definingContext;    <span class="hljs-comment">//存储dex文件</span>    <span class="hljs-keyword">private</span> Element[] dexElements;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DexPathList</span><span class="hljs-params">(ClassLoader definingContext, String dexPath,        String libraryPath, File optimizedDirectory)</span> </span>&#123;    ...    <span class="hljs-keyword">this</span>.definingContext = definingContext;    <span class="hljs-keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions);    ...&#125;&#125;</code></pre><p>保存当前的类加载器<code>definingContext</code>，并调用<code>makeDexElements()</code>初始化Element数组。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) &#123;    <span class="hljs-comment">// 1.创建Element集合</span>    ArrayList&lt;Element&gt; elements = <span class="hljs-keyword">new</span> ArrayList&lt;Element&gt;();    <span class="hljs-comment">// 2.遍历所有dex文件（也可能是jar、apk或zip文件）</span>    <span class="hljs-keyword">for</span> (File file : files) &#123;      <span class="hljs-keyword">if</span>(file.isDirectory())&#123;        elements[elementsPos++] = <span class="hljs-keyword">new</span> Element(file);      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(file.isFile)&#123;        String name = file.getName();        ...        <span class="hljs-comment">// 如果是dex文件</span>        <span class="hljs-keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;          dex = loadDexFile(file, optimizedDirectory, loader, elements);          <span class="hljs-keyword">if</span>(dex!=<span class="hljs-keyword">null</span>)&#123;            elements[elementsPos++] = <span class="hljs-keyword">new</span> Elements(dex,<span class="hljs-keyword">null</span>);          &#125;        <span class="hljs-comment">// 如果是apk、jar、zip文件（这部分在不同的Android版本中，处理方式有细微差别）</span>        &#125; <span class="hljs-keyword">else</span> &#123;            DexFile dex = <span class="hljs-keyword">null</span>;          <span class="hljs-keyword">try</span>&#123;            dex = loadDexFile(file, optimizedDirectory);          &#125;                    &#125;        ...        <span class="hljs-comment">// 3.将dex文件或压缩文件包装成Element对象，并添加到Element集合中</span>                <span class="hljs-keyword">if</span> (dex == <span class="hljs-keyword">null</span>) &#123;                    elements[elementsPos++] = <span class="hljs-keyword">new</span> Element(file);                &#125; <span class="hljs-keyword">else</span> &#123;                    elements[elementsPos++] = <span class="hljs-keyword">new</span> Element(dex, file);                &#125;      &#125;    &#125;    <span class="hljs-comment">// 4.将Element集合转成Element数组返回</span>  <span class="hljs-keyword">if</span>(elementsPos != elements.length)&#123;    elements = Arrays.copyOf(elements,elementsPos);  &#125;    <span class="hljs-keyword">return</span> elements;&#125;</code></pre><p>在<code>makeDexElement</code>中，将传入的文件(<em>Dex、apk、zip</em>)封装成一个个的<code>Element</code>对象，然后添加至Element集合中。</p><blockquote><p>在Android的类加载器中，他们只会去解析<code>dex文件</code>。通过<code>loadDexFile()</code>就可以将其他类型的文件转换成<code>dex文件</code>以供加载。</p></blockquote><p><code>findClass()</code>：寻找类名相同的类并返回</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">findClass</span><span class="hljs-params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;    <span class="hljs-keyword">for</span> (Element element : dexElements) &#123;        <span class="hljs-comment">// 遍历出一个dex文件</span>        DexFile dex = element.dexFile;        <span class="hljs-keyword">if</span> (dex != <span class="hljs-keyword">null</span>) &#123;            Class clazz = element.findClass(name,definingContext,suppressed);            <span class="hljs-keyword">if</span> (clazz != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> clazz;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (dexElementsSuppressedExceptions != <span class="hljs-keyword">null</span>) &#123;        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Element</span></span>&#123;  ...     <span class="hljs-keyword">public</span> Class&lt;?&gt; findClass(String name, ClassLoader definingContext,                List&lt;Throwable&gt; suppressed) &#123;       <span class="hljs-comment">//在dex文件中查找类名相同的类</span>       <span class="hljs-keyword">return</span> dexFile != <span class="hljs-keyword">null</span> ? dexFile.loadClassBinaryName(name, definingContext,suppressed): <span class="hljs-keyword">null</span>;        &#125;  ...&#125;</code></pre><p>在<code>findClass()</code>中，对Elements数组进行遍历，一旦找到与传入类名相同的类即返回。</p><blockquote><p>Element内部封装了DexFile，DexFile用于加载Dex文件，因此一个Element对象会对应一个Dex文件。多个Element组成了有序数组<code>dexElements</code>。需要查找类时便去遍历<code>dexElements</code>，再去调用<code>findClass()</code>查找类。在Dex中存储的是一堆Class文件，需要在dex文件中通过<code>loadClassBinaryName()</code>去找寻对应的Class文件。<em>如果没有找到就接着去下一个Element中寻找。</em></p></blockquote><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>经过上述的源码分析，加载一个类时都会从<code>dexElements</code>数组获取到对应的类之后再进行加载。遍历过程由数组头部开始。所以我们可以将已修复好的Class打包成一个Dex文件并放置到<code>dexElements</code>数组的第一个位置(<em>也解决了CLASS_ISPREVERIFIED问题，当打上该标记时该类就无法被替换</em>)，这样就可以保证已修复好的Class会被优先加载而排在数组后面的Bug类就不会被加载(<strong>由于双亲委托机制</strong>)。</p><blockquote><p>双亲委托机制：如果一个类加载器收到了类加载的请求，不会自己去尝试加载这个类，而把这个请求委派给父类加载器去完成，每一层都是如此，依次向上递归，直到委托到最顶层的<code>Bootstrap ClassLoader</code>，若父加载器无法处理加载请求（它的搜索范围内没有找到所需的类时），则交由子加载器去加载。</p><p>双亲委托机制的好处：</p><ul><li>避免重复加载，若Class已被加载则从缓存中获取不会重新加载</li><li>更加安全，例如<code>java.lang.Object</code>基础类的加载都需要最终委派到<code>BootstrapClassLoader</code>进行加载，即时去自定义类加载器进行加载也不会产生多个类。</li></ul></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/类加载方案.png" srcset="/img/loading.gif" class="full-image" alt="类加载方案" title="类加载方案"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="修复实战"><a href="#修复实战" class="headerlink" title="修复实战"></a>修复实战</h4><ol><li><p>制作一个有Bug的类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> BugActivity extends AppCompatActivity&#123;  <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.act_bug);        Log.e(<span class="hljs-string">"Bug"</span>, String.valueOf(<span class="hljs-number">2</span>/<span class="hljs-number">0</span>));    &#125;&#125;</code></pre></li><li><p>制作一个Bug修复类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> BugActivity extends AppCompatActivity&#123;  <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(R.layout.act_bug);        Log.e(<span class="hljs-string">"Bug"</span>, <span class="hljs-string">"fix"</span>);    &#125;&#125;</code></pre></li><li><p>将Bug修复类<code>BugActivity.class</code>打包成dex(<strong>DVM只能识别dex文件</strong>)</p><p><code>rebuild project</code>之后在<code>build-&gt;intermediates-&gt;javac</code>可以找到对应的class文件。</p><p>取出该class文件后(<code>取出时需要带上完整的包名路径</code>)，就需要通过<code>SDK/build-tools/XX/dx</code>将class文件转成dex文件</p><pre><code class="hljs shell">//dex文件中放置着对应的class文件及其完整路径 Mac：sh dx --dex --output=../dex/classes2.dex ../dexWin: dx --dex --output=../dex/classes2.dex ../dex//执行完毕后就会生成对应的dex文件 --  classes2.dex</code></pre><p>此时就可以得到最终需要替换进去的dex文件。</p></li><li><p>加载dex文件</p><blockquote><p>利用反射机制去修改<code>DexClassLoader</code>中的<code>dexElements</code>，需要把修复过后的<code>classes2.dex</code>插入到头部位置，保证可以优先加载。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixDexUtil</span> </span>&#123;    <span class="hljs-comment">//列出修复支持的文件格式</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEX_SUFFIX = <span class="hljs-string">".dex"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String APK_SUFFIX = <span class="hljs-string">".apk"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAR_SUFFIX = <span class="hljs-string">".jar"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ZIP_SUFFIX = <span class="hljs-string">".zip"</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEX_DIR = <span class="hljs-string">"odex"</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String OPTIMIZE_DEX_DIR = <span class="hljs-string">"optimize_dex"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashSet&lt;File&gt; loadedDex = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">//清理已存在的dex</span>        loadedDex.clear();    &#125;        <span class="hljs-comment">/**     * 加载补丁，使用默认目录：data/data/包名/files/odex     *     * <span class="hljs-doctag">@param</span> context     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadFixedDex</span><span class="hljs-params">(Context context)</span> </span>&#123;        loadFixedDex(context, <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-comment">/**     * 加载补丁     *     * <span class="hljs-doctag">@param</span> context       上下文     * <span class="hljs-doctag">@param</span> patchFilesDir 补丁所在目录     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadFixedDex</span><span class="hljs-params">(Context context, File patchFilesDir)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> canFix = <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 遍历所有的修复dex , 因为可能是多个dex修复包</span>        File fileDir = patchFilesDir != <span class="hljs-keyword">null</span> ?                patchFilesDir :                <span class="hljs-keyword">new</span> File(context.getFilesDir(), DEX_DIR);<span class="hljs-comment">// data/data/包名/files/odex（这个可以任意位置）</span>        File[] listFiles = fileDir.listFiles();        <span class="hljs-keyword">if</span> (listFiles != <span class="hljs-keyword">null</span> &amp;&amp; listFiles.length != <span class="hljs-number">0</span>)            <span class="hljs-keyword">for</span> (File file : listFiles) &#123;                <span class="hljs-keyword">if</span> (file.getName().startsWith(<span class="hljs-string">"classes"</span>) &amp;&amp;                        (file.getName().endsWith(DEX_SUFFIX)                                || file.getName().endsWith(APK_SUFFIX)                                || file.getName().endsWith(JAR_SUFFIX)                                || file.getName().endsWith(ZIP_SUFFIX))) &#123;                    loadedDex.add(file);<span class="hljs-comment">// 存入集合</span>                    <span class="hljs-comment">//有修复包的存在，意味需要修复</span>                    canFix = <span class="hljs-keyword">true</span>;                &#125;            &#125;        <span class="hljs-comment">// dex合并之前的dex</span>        <span class="hljs-keyword">if</span> (canFix)            doDexInject(context, loadedDex);    &#125;     <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDexInject</span><span class="hljs-params">(Context appContext, HashSet&lt;File&gt; loadedDex)</span> </span>&#123;        String optimizeDir = appContext.getFilesDir().getAbsolutePath() +                File.separator + OPTIMIZE_DEX_DIR;        <span class="hljs-comment">// data/data/包名/files/optimize_dex（这个必须是自己程序下的目录）</span>        File fopt = <span class="hljs-keyword">new</span> File(optimizeDir);        <span class="hljs-keyword">if</span> (!fopt.exists()) &#123;            fopt.mkdirs();        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 1.加载应用程序dex的Loader</span>            PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader();            <span class="hljs-keyword">for</span> (File dex : loadedDex) &#123;                <span class="hljs-comment">// 2.加载指定的修复的dex文件的Loader</span>                DexClassLoader dexLoader = <span class="hljs-keyword">new</span> DexClassLoader(                        dex.getAbsolutePath(),<span class="hljs-comment">// 修复好的dex（补丁）所在目录</span>                        fopt.getAbsolutePath(),<span class="hljs-comment">// 存放dex的解压目录（用于jar、zip、apk格式的补丁）</span>                        <span class="hljs-keyword">null</span>,<span class="hljs-comment">// 加载dex时需要的库</span>                        pathLoader<span class="hljs-comment">// 父类加载器</span>                );                <span class="hljs-comment">// 3.开始合并</span>                <span class="hljs-comment">// 合并的目标是Element[],重新赋值它的值即可</span>                <span class="hljs-comment">/**                 * BaseDexClassLoader中有 变量: DexPathList pathList                 * DexPathList中有 变量 Element[] dexElements                 * 依次反射即可                 */</span>                <span class="hljs-comment">//3.1 准备好pathList的引用</span>                Object dexPathList = getPathList(dexLoader);                Object pathPathList = getPathList(pathLoader);                <span class="hljs-comment">//3.2 从pathList中反射出element集合</span>                Object leftDexElements = getDexElements(dexPathList);                Object rightDexElements = getDexElements(pathPathList);                <span class="hljs-comment">//3.3 合并两个dex数组</span>                Object dexElements = combineArray(leftDexElements, rightDexElements);                <span class="hljs-comment">// 重写给PathList里面的Element[] dexElements;赋值</span>                Object pathList = getPathList(pathLoader);<span class="hljs-comment">// 一定要重新获取，不要用pathPathList，会报错</span>                setField(pathList, pathList.getClass(), <span class="hljs-string">"dexElements"</span>, dexElements);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**     * 反射给对象中的属性重新赋值     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setField</span><span class="hljs-params">(Object obj, Class&lt;?&gt; cl, String field, Object value)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;        Field declaredField = cl.getDeclaredField(field);        declaredField.setAccessible(<span class="hljs-keyword">true</span>);        declaredField.set(obj, value);    &#125;    <span class="hljs-comment">/**     * 反射得到对象中的属性值     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getField</span><span class="hljs-params">(Object obj, Class&lt;?&gt; cl, String field)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;        Field localField = cl.getDeclaredField(field);        localField.setAccessible(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> localField.get(obj);    &#125;    <span class="hljs-comment">/**     * 反射得到类加载器中的pathList对象     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getPathList</span><span class="hljs-params">(Object baseDexClassLoader)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;        <span class="hljs-keyword">return</span> getField(baseDexClassLoader, Class.forName(<span class="hljs-string">"dalvik.system.BaseDexClassLoader"</span>), <span class="hljs-string">"pathList"</span>);    &#125;    <span class="hljs-comment">/**     * 反射得到pathList中的dexElements     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getDexElements</span><span class="hljs-params">(Object pathList)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;        <span class="hljs-keyword">return</span> getField(pathList, pathList.getClass(), <span class="hljs-string">"dexElements"</span>);    &#125;    <span class="hljs-comment">/**     * 数组合并     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">combineArray</span><span class="hljs-params">(Object arrayLhs, Object arrayRhs)</span> </span>&#123;        Class&lt;?&gt; clazz = arrayLhs.getClass().getComponentType();        <span class="hljs-keyword">int</span> i = Array.getLength(arrayLhs);<span class="hljs-comment">// 得到左数组长度（补丁数组）</span>        <span class="hljs-keyword">int</span> j = Array.getLength(arrayRhs);<span class="hljs-comment">// 得到原dex数组长度</span>        <span class="hljs-keyword">int</span> k = i + j;<span class="hljs-comment">// 得到总数组长度（补丁数组+原dex数组）</span>        Object result = Array.newInstance(clazz, k);<span class="hljs-comment">// 创建一个类型为clazz，长度为k的新数组</span>        System.arraycopy(arrayLhs, <span class="hljs-number">0</span>, result, <span class="hljs-number">0</span>, i);        System.arraycopy(arrayRhs, <span class="hljs-number">0</span>, result, i, j);        <span class="hljs-keyword">return</span> result;    &#125;  &#125;</code></pre><p>该类中主要的功能：</p><ol><li>获取对应目录中存在的<code>apk、dex、jar，zip</code>文件</li><li>将文件转换成<code>Element</code>格式并生成一个<code>elements</code>数组</li><li>将生成的数组与原先存在的<code>dexElements</code>数组进行合并</li><li>合并完成后利用<strong>反射</strong>将数组放置回<code>ClassLoader</code>中</li></ol><blockquote><p>如果要加载的文件格式为<code>apk、jar，zip</code>需要进行一些特殊处理</p><p><strong>这些文件格式中需要有一个<code>classes.dex</code>文件，不然会出错</strong></p></blockquote></li><li><p>进行检测以及修复工作</p><pre><code class="hljs java"><span class="hljs-comment">//在项目初始化时便去进行修复检测</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span></span>&#123;      <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attachBaseContext</span><span class="hljs-params">(Context base)</span> </span>&#123;        <span class="hljs-keyword">super</span>.attachBaseContext(base);        <span class="hljs-comment">//提前进行初始化 提前至 onCreate()之前</span>        FixDexUtil.loadFixedDex(base, Environment.getExternalStorageDirectory());    &#125;&#125;</code></pre></li><li><p>将修复好的<code>classes2.dex</code>文件放到对应的目录中，然后重新打开应用，重新观察结果即可。</p></li></ol><h3 id="底层替换方案"><a href="#底层替换方案" class="headerlink" title="底层替换方案"></a>底层替换方案</h3><blockquote><p>底层替换方案是在已经加载了的类中直接去替换原有方法，是在原来类的基础上进行修改。由于在原有类进行修改限制会比较多，且不能增减原有类的方法和字段，否则会破坏原有类的结构。<strong>底层的替换方案还与反射有所关联。</strong></p></blockquote><p>传统的底层替换方案，都是直接去修改虚拟机方法实现的具体字段。主要是去操作<code>ArtMethod</code>结构体，但是会存在兼容性问题，可能由于厂商对其进行了修改。</p><p>优化点就是 直接替换整个<code>ArtMethod</code>结构体，这样就不会存在兼容性的问题。</p><blockquote><p><code>ArtMethod</code>：包含了Java方法的所有信息，包括执行入口、访问权限、所属类和代码执行地址等。</p></blockquote><p>优点：<strong>底层替换方案直接替换了方法，而且是立即生效不需要进行重启操作。</strong></p><h3 id="Instant-Run方案"><a href="#Instant-Run方案" class="headerlink" title="Instant Run方案"></a>Instant Run方案</h3><p>Instant Run的部署方式有以下三种：</p><ul><li><strong>Hot Swap</strong>：<code>效率最高</code>。代码的增量改变不需要重启App，甚至Activity都不需要重启。修改一个现有方法中的代码多采用这种部署方式。</li><li><strong>Warm Swap</strong>：App不需要重启，但是Activity需要重启。修改或删除一个现有的资源文件时多采用这种部署方式。</li><li><strong>Cold Swap</strong>：App需要重启，但是不需要重新安装。添加、删除或修改一个字段和方法或者修改一个类等多采用这种部署方式。</li></ul><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/传统编译部署.webp" srcset="/img/loading.gif" class="full-image" alt="传统编译部署" title="传统编译部署"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Instant Run编译部署.webp" srcset="/img/loading.gif" class="full-image" alt="Instant Run编译部署" title="Instant Run编译部署"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>利用<strong>ASM</strong>在每一个方法中注入类似如下的代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IncrementalChange</span> </span>&#123;    Object access$dispatch(String id, Object... args);&#125;<span class="hljs-comment">//注入代码如下</span>IncrementalChange localIncrementalChange = $change;<span class="hljs-keyword">if</span>(localIncrementalChange!=<span class="hljs-keyword">null</span>)&#123;  localIncrementalChange.access$dispatch(<span class="hljs-string">""</span>);    <span class="hljs-keyword">return</span>;&#125;</code></pre><p><code>$change</code>指代了方法是否发生变化，如果发生变化就会调用到<code>access$dispatch()</code>生成对应的替换类<code>Class$override</code>替代执行原有方法，即完成了对原有方法的修改。</p><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p>《深入探索Android热修复技术原理》</p><p>《Android进阶解密》</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle操作小记</title>
    <link href="/2018/04/03/Gradle%E6%93%8D%E4%BD%9C%E5%B0%8F%E8%AE%B0/"/>
    <url>/2018/04/03/Gradle%E6%93%8D%E4%BD%9C%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>显示所有依赖关系解析树<br><pre><code class="hljs gradle">.<span class="hljs-regexp">/gradlew app:dependencies</span></code></pre></p></blockquote><blockquote><p>生成项目<br><pre><code class="hljs gradle">.<span class="hljs-regexp">/gradlew clean assembleEnvTestReleaseChannels -PchannelList=default</span></code></pre></p></blockquote><blockquote><p>清理项目</p></blockquote><pre><code class="hljs groovy">./gradlew clean</code></pre><blockquote><p>api与implementation的区别<br><code>api</code>：完全等同于原先的<code>compile</code>指令，使用了该命令编译的依赖项目，其他项目依赖于该项目时也可以使用该命令编译的依赖项目。<br><code>implementation</code>：使用了该命令编译的依赖项目，其他项目依赖于该项目时无法使用该命令编译的依赖项目。即该依赖是隐藏在项目内部的，不会对外开放。</p></blockquote><pre><code class="hljs groovy">./gradlew build --refresh-dependencies</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常细节记录</title>
    <link href="/2018/04/03/%E6%97%A5%E5%B8%B8%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95/"/>
    <url>/2018/04/03/%E6%97%A5%E5%B8%B8%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ol><li><p>强引用置为null时，不会立即回收对象，帮助回收器加快回收。但是会帮助GC 等到下次回收周期时即会回收</p></li><li><p>死锁的四个必要条件：互斥，占有且等待，不可抢占，循环等待</p></li><li><p>CAS(原子操作)是乐观锁用到的主要机制，乐观锁是不用加锁去执行操作，如果产生冲突则失败重试，直到成功为止，也叫做“自旋”。与乐观锁相对应的是悲观锁，synchronized就是悲观锁，也叫“独占锁”需要加锁进行操作，并且加锁代码块中的只能有一个线程进行操作。</p></li><li><p>点击App图标，系统最开始执行的是ActivityThread的main()方法</p></li><li><p>应用的启动方式：</p><ol start="2"><li>冷启动：启动应用时，后台没有该应用的进程。系统创建一个新的进程来进行重新分配。</li><li>热启动：启动应用时，后台已有该应用的进程。</li></ol></li><li><p>Application的生命周期：<code>onCreate()//应用开始时执行-&gt;onLowMemory()//内存低时执行-&gt;onTrimMemory()//关闭应用时执行  onTerminate()//在真机上不会调用</code></p></li><li><p>进程相关： <code>优先级最低的进程首先被杀死、进程的等级会因为其他进程的依赖而提高一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低</code> 按重要性分类：</p><ol start="2"><li>前台进程：进程持有一个正在与用户交互的Activity或者和交互Activity绑定的Service，前台运行的Service（执行<code>startForeground()</code>）,执行<code>onReceive()</code>的BroadcastReceiver</li><li>可见进程：进程持有一个被用户可见但没有显示在最前端的Activity(调用到了<code>onPause()</code>)或者和可见Activity绑定的Service</li><li>服务进程：进程持有一个<code>startService()</code>启动的Service进程，例如播放音乐，下载文件等Service</li><li>后台进程：进程持有一个用户不可见的Activity(调用到<code>onStop()</code>没有到<code>onDestroy()</code>)，进程被存放在一个LRU列表中，即很长时间没用的Activity会被优先杀死</li><li>空进程：进程不包含任何活跃的应用组件，唯一的作用是<code>为了缓存需要，缩短下次启动的时间</code></li></ol></li><li><p>统计应用启动时间：<code>adb shell am start -W [packageName]/[packageName.MainActivity]</code></p></li><li><p><code>volatile</code>作用是<code>可见性</code>(当一个线程修改了某一个全局变量的值，其他线程能否知道这个修改)，<code>有序性</code>（禁止指令重排优化,防止代码执行指令被重新排序）。<code>volatile</code>并不能保证线程安全即保证不了线程间操作的原子性。</p></li><li><p>SharedPreference中<code>apply</code>和<code>commit</code>方法的区别：<code>commit</code>同步保存更改，<code>apply</code>异步保存到磁盘，原子提交，性能较高，但不保存结果。SharedPreference不支持多线程操作，<code>MODE_MULTI_PROCESS</code>这个标记位并没有实际作用。可以利用<code>ContentProvider</code>去实现多进程，_方案后续会有介绍_。</p></li><li><p>MD5不是加密算法，是一种散列算法。加密算法一般是对称加密算法</p></li><li><p>使用ADB启动Activity：<code>adb shell am start -n 包名/需启动Activity路径</code></p></li><li><p>Fragment中<code>replace</code>与<code>add</code>区别：</p><ul><li><code>replcae</code>：把容器内所有内容进行替换，都需要重新走一遍fragment的生命周期</li><li><code>add</code>：添加不会清空容器内的内容。</li></ul></li><li><p>在三星手机上，进行原生分享文件时需要设置mimeType</p></li><li><p><code>invalidate()</code>、<code>postInvalidate()</code>和<code>requestLayout()</code>的区别：</p><ul><li><code>invalidate()</code>：当子View调用invalidate方法时，会给View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递至ViewRootImpl中，最终触发performTraversals方法，进行View的重绘（即调用onDraw方法）。<strong>该方法只能在UI线程中调用</strong></li><li><code>postInvalidate()</code>：与invalidate作用一致，都是使View进行重绘，<strong>该方法是在非UI线程中调用的</strong>。内部主要实现是提供一个Handler实现，然后直接调用了invalidate方法，继续执行重绘流程。</li><li><code>requestLayout()</code>：调用了这个方法会重新执行View的绘制流程，即重新执行测量(<code>onMeasure</code>)，布局(<code>onLayout</code>)，绘制(<code>onDraw</code>)方法。<strong>利用责任链模式-不断向上传递该事件，直到找到能处理该事件的上级</strong>。</li></ul></li><li><p>Bitmap所占用的内存 = 图片长度 x 图片宽度 x （屏幕分辨率÷图片资源目录分辨率）²×一个像素点占用的字节数</p></li><li><p>HashMap扩容机制 在1.8之前只要达到负载就进行扩容，1.8之后是防止Hash冲突才进行扩容，如果不冲突不会触发扩容。</p></li><li><p><code>px转换为dp</code>：<strong>px/(DPI/160) = dp</strong>，例如<code>1920 * 1080 , 480dpi</code>，最终转化就会得到360dp</p></li><li><p>内部类可以访问外部类 <code>private</code>变量。在内部类需要引用外部类的<code>private</code>变量时，会默认生成一个<code>access$XXX()</code>，内部会返回当前对象</p></li><li><p>Java与Dart一样都是采用了<strong>值传递</strong>的<code>求值策略</code>：</p><p>| 求值策略     | 求值时间 | 传值方式           |<br>| ———— | ——– | —————— |<br>| <strong>值传递</strong>   | 调用前   | 值的结果(值的副本) |<br>| <strong>引用传递</strong> | 调用前   | 原始值             |<br>| <strong>名传递</strong>   | 调用后   | 与值无关的一个名   |</p><p>其中最常见的是<strong>值传递</strong>(主要应用于Java、Dart、OC等)，然后是<strong>引用传递</strong>(C、C++、C#)。</p><p>这两者主要的区别如下：</p><blockquote><p><code>值传递</code>：调用函数时将参数<strong>复制</strong>一份传递到函数中，函数中对参数进行修改，也不会影响到实际参数<br><code>引用传递</code>：调用函数时传递的是<strong>实际参数的地址</strong>，函数中对参数进行修改时，也会影响到实际参数的值</p></blockquote><p><code>值传递</code>无论参数类型是<code>值类型或引用类型</code>，都会调用栈上创建的一个副本。</p><ul><li>对于<code>值类型</code>，栈上的副本是<strong>整个原始值的复制</strong></li><li>对于<code>引用类型</code>，由于<code>引用类型</code>的实例在堆上，栈上的副本是<strong>该变量在堆上的引用地址</strong></li></ul></li></ol><ol start="21"><li><p><code>UncaughtExceptionHandler</code>在<code>uncaughtException()</code>中接收应用所发生的异常，如果在该方法内再次发生异常<strong>就会导致进入无限崩溃状态</strong>。</p></li><li><p><code>build.gradle</code>中<code>compileSdkVersion</code>,<code>minSdkVersion</code>,<strong><code>targetSdkVersion</code></strong>这三个参数的说明：</p><p><code>compileSdkVersion</code>：编译应用使用的SDK版本，单纯在编译时使用。<em>使用最新的编译SDK的好处就在于可以及时了解到API的状态例如弃用并可以提前使用新的API。</em>此处需要注意一点：<strong>如果使用最新的<code>support library</code>，compileSdkVersion的版本至少要大于support的版本以保证编译通过。</strong></p><p><code>minSdkVersion</code>：<strong>应用可以运行的最低版本</strong>。<em>主要可以用于在应用使用高于该版本的api时进行提示，避免运行过程出现崩溃。</em>当依赖多个Module都制定了<code>minSdkVersion</code>时，自身推荐使用依赖库中最大的<code>minSdkVersion</code>避免出现问题。如果使用了比依赖库小的版本号，可以使用<code>tools:overrideLibrary</code>标志避免提示。</p><p><code>targetSdkVersion</code>：<strong>应用向前兼容的主要依据。</strong>为了保证老Apk在新版本系统上的兼容性，只要老Apk的<code>targetSdkVersion</code>版本不发生变化，在新系统依然会保持老系统上的行为。<br>Android系统通过获取<code>apk配置的targetSdkVersion</code>在调用系统对应Api时进行版本判断去执行不同的逻辑。</p></li></ol><p>这三者的大小顺序应该为<strong> minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</strong>这个是比较合理的顺序。</p><ol start="23"><li><p><code>==</code>与<code>equals()</code>的区别</p><ul><li><code>==</code>：所以基本类型比较的是<strong>值是否相等</strong>，所以引用类型比较的是<strong>两者在内存中存放的地址(堆内存地址)</strong>。</li><li><code>equals()</code>：默认比较的是<strong>对象的内存地址值</strong>，如果重写了<code>equals()</code>，则按照重写规则比较(例如String 重写了<code>equals()</code>这样就变成值比较)。<ul><li><code>hashcode()</code>：在比较<code>equals()</code>之前会先比较<code>hashcode</code>，如果不同则表示两个值不相等，若相同再进行<code>equals()</code>比较</li></ul></li></ul></li><li><p>自动装箱/拆箱相关知识</p><p>以下拿<code>int</code>，<code>Integer</code>举例：<code>int</code>就是原始类型，<code>Integer</code>就是包装类型。</p><p><code>自动装箱</code>：<strong>将原始类型转换为包装类型</strong> ── <code>Interger x = 1000</code>=&gt;<code>Integer x = Integer.valueOf(1000);</code>转换成如下代码</p><p><code>自动拆箱</code>：<strong>将包装类型转换为原始类型</strong>──<code>Integer x = 1000;System.out.println(x)</code>=&gt;<code>System.out.println(x.intValue())</code>转换成如下代码</p><p>拓展知识：</p><p><code>Integer</code>的缓存策略：<code>Integer</code>中存在一个缓存池(<code>IntegetCache</code>)将使用频繁的值进行缓存避免创建过多对象提高性能。默认缓存池范围为<code>-128~127</code>，如果在该范围内返回的就是 <code>IntegerCache</code>中的对象，否则返回<code>new Integer(XX)</code>。</p><pre><code class="hljs java">Integer a = <span class="hljs-number">127</span>;Integer a1 = <span class="hljs-number">127</span>;  Integer b = <span class="hljs-number">128</span>;Integer b1 = <span class="hljs-number">128</span>;System.out.println(a==a1); <span class="hljs-comment">//true 返回的实际上是缓存池的对象</span>System.out.println(a.equals(a1)); <span class="hljs-comment">//true</span>System.out.println(b==b1); <span class="hljs-comment">//false 重新new Integer</span>System.out.println(b.equals(b1)); <span class="hljs-comment">//true</span></code></pre></li></ol><ol start="25"><li><p>Linux中的<code>epoll、select、inotify</code>机制简析</p><p>都是<code>IO多路复用机制</code>，一个进程可以监视多个描述符，一旦某个描述符就位，就会通知系统回写。</p><blockquote><p><code>IO多路复用</code>：内核一旦发现进程指定的一个或者多个IO条件准备读取，就会通知该进程。</p><p>优势在于系统开销小，系统不需要创建进程/线程，也无需维护。</p></blockquote><ul><li><p><code>inotify</code>：允许监控程序打开一个独立文件描述符，并针对事件集监控一个或多个文件，例如：打开、关闭、重命名、创建、删除等功能。（用于<code></code>FileObserver`监听对应文件的打开、修改、创建等事件）</p><ul><li><code>inotify_init()</code>创建一个监听文件变动的inotify实例,并返回指向该实例的文件描述符（fd）</li><li><code>inotify_add_watch</code>增加对文件或目录的监控，并指定监控事件</li><li><code>inotify_rm_watch</code>移除对文件或目录的监控</li></ul></li><li><p><code>select</code>：允许进程指示内核等待多个事件的任何一个发送，并只有在一个或多个事件发生或经历一段指定的时间后才唤醒。</p><p><code>select</code>需要遍历所有句柄才可以获取到哪个句柄有事件通知，并且最多支持1024个句柄，超过则可能导致溢出异常。</p></li><li><p><code>epoll</code>：epoll使用一个文件描述符管理多个文件描述符，将用户关系的文件描述符的事件存放到一个内核的事件表中。</p><ul><li><p><code>epoll_create(int size)</code>：告诉内核需要监听的文件描述符个数</p></li><li><p><code>epoll_ctl(int epfd,int op,int fd,struct epoll_event *event)</code>：对指定文件描述符进行<code>op</code>操作</p><ul><li><p>epfd：epoll_create 返回的文件描述符</p></li><li><p>op：1)EPOLL_CTL_ADD 增加监听事件</p><p>​      2)EPOLL_CTL_DEL 删除监听事件</p><p>​      3)EPOLL_CTL_MOD 修改监听事件</p></li><li><p>fd：需要监听的文件描述符</p></li><li><p>event：告诉内核需要监听的事件</p></li></ul></li><li><p><code>epoll_wait()</code>：等待epfd的监听回调</p><p><code>epoll</code>对于句柄事件的选择不是遍历的，当事件响应时会通知到epoll。</p><p><code>epoll</code>有两种工作模式：</p><ul><li>LT模式-水平触发(默认模式)：<code>epoll_wait</code>检测到描述符事件时会通知到应用程序，应用程序可以不立即处理该事件，等待下次<code>epoll_wait</code>时会继续发出通知。<strong>效率较低但是不用担心数据丢失。</strong></li><li>ET模式-边缘触发：<code>epoll_wait</code>检测到描述符事件时会通知到应用程序，应用程序必须立即处理该事件，等待下次<code>epoll_wait</code>时不会继续发出通知。<strong>效率最高但是需要对每个请求进行处理，避免丢失事件造成影响。必须使用非阻塞套接口，避免堵塞造成任务堵死。</strong></li></ul></li></ul></li></ul></li></ol><p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></p><ol start="26"><li><p>MarkDown在嵌套<code>&lt;html&gt;&lt;/html&gt;</code>时会产生多余的<code>&lt;br&gt;</code>，需要使用 <code>  包html table</code></p></li><li><p><code>i++</code>与<code>++i</code>的区别？</p><p><strong>1、 i++ 返回原来的值，++i 返回加1后的值。</strong><br><strong>2、 i++ 不能作为左值，而++i 可以。</strong></p></li></ol><p>   <strong>首先解释下什么是左值</strong>（以下两段引用自中文维基百科『右值引用』词条）。</p><blockquote><p>左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。</p></blockquote><p>   一般来说，<strong>左值是可以放到赋值符号左边的变量</strong>。但</p><blockquote><p>能否被赋值不是区分左值与右值的依据。比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。<strong>左值与右值的根本区别在于是否允许取地址&amp;运算符获得对应的内存地址。</strong></p></blockquote><p>   <code>i++</code>的字节码表示为：</p>   <pre><code class="hljs java"><span class="hljs-number">37</span>: lload         <span class="hljs-number">9</span>  <span class="hljs-number">39</span>: dup2 <span class="hljs-comment">//复制栈顶数据并压入栈顶，此时压入为i</span>  <span class="hljs-number">40</span>: lconst_1  <span class="hljs-number">41</span>: ladd  <span class="hljs-number">42</span>: lstore        <span class="hljs-number">9</span></code></pre><p>   <code>++i</code>的字节码表示为：</p>   <pre><code class="hljs java"><span class="hljs-number">37</span>: lload         <span class="hljs-number">9</span><span class="hljs-number">39</span>: lconst_1<span class="hljs-number">40</span>: ladd<span class="hljs-number">41</span>: dup2  <span class="hljs-comment">//复制栈顶数据并压入栈顶，此时压入为i+1</span><span class="hljs-number">42</span>: lstore        <span class="hljs-number">9</span></code></pre><ol start="28"><li><p><code>Boolean</code>在数组中占到了一个字节，在单独变量中等价于<code>int</code>占用了4个字节。</p></li><li><p><code>快速失败(fast-fail)</code>与<code>安全失败(safe-fail)</code>的概念</p><p><code>快速失败</code>：迭代器遍历集合时，在过程中对集合的内容进行了修改（增加、删除、修改），则会抛出<code>ConcurrentModificationException</code></p><p>因为遍历过程中会使用一个<code>modCount</code>变量，遍历期间如果内容发生了变化，<code>modCount</code>会发生改变，迭代器在执行<code>hasNext()/next()</code>时，都会检测该值是否发生变化，发生变化则终止遍历并抛出异常。</p><p><code>java.util</code>下的类都是<code>快速失败</code>的！</p><p><code>安全失败</code>：迭代器遍历的不是原有集合，而是原有集合的复制集合</p><p>因为遍历的是复制集合，所以遍历期间原有集合发生变化不会影响到遍历过程，就不会触发异常抛出。<strong>由于遍历的是复制集合，导致遍历时无法获取最新的修改。</strong></p><p><code>java.util.concurrent</code>下的类都是<code>安全失败</code>的！</p></li><li><p><code>Class.forName()</code>与<code>ClassLoader.class</code>的区别</p><p><code>Class.forName()</code></p><pre><code class="hljs undefined">public static Class&lt;?&gt; forName(String name, /*要加载的Class名字*/ boolean initialize,/*是否需要初始化-调用静态代码快及静态变量初始化*/                               ClassLoader loader/*指定ClassLoader进行加载*/)</code></pre><p>执行时默认会调用静态代码块<code>static{...}</code>，以及分配静态变量存储空间</p><p><code>ClassLoader.loadClass()</code></p><pre><code class="hljs undefined">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</code></pre><p>执行时不会对类进行初始化，只是将类加载到了虚拟机中。</p></li><li><p>编译期Debug</p><p>配置编译命令终端输入  <code>./gradlew :app:clean :app:assembleDebug -Dorg.gradle.daemon=false -Dorg.gradle.debug=true</code>，此时进入等待状态</p><p>配置<code>Run/Debug Configurations</code>，新增一个<code>Remote</code>配置，使用默认配置即可</p><p>切换到<code>Remote</code>配置，点击Debug按钮，然后debug attach成功</p><p>此时运行<code>Make Project</code>等待断点执行到</p></li><li><p>JNI抛出Java异常</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">throwException</span><span class="hljs-params">(JNIEnv *env, <span class="hljs-keyword">char</span> *msg)</span> </span>&#123;    jclass exClass;    <span class="hljs-keyword">char</span> *className = <span class="hljs-string">"java/lang/NullPointerException"</span>;    exClass = env-&gt;FindClass(className);  <span class="hljs-comment">//调用ThrowNew 抛出异常</span>    env-&gt;ThrowNew(exClass, msg);&#125;</code></pre><p><code>ThrowNew</code>的实现方法在<code>jni_interal.cc</code></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ThrowNewException</span><span class="hljs-params">(JNIEnv* env, jclass exception_class, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* msg, jobject cause)</span>    <span class="hljs-title">REQUIRES</span><span class="hljs-params">(!Locks::mutator_lock_)</span> </span>&#123;  <span class="hljs-comment">// Turn the const char* into a java.lang.String.</span>  <span class="hljs-function">ScopedLocalRef&lt;jstring&gt; <span class="hljs-title">s</span><span class="hljs-params">(env, env-&gt;NewStringUTF(msg))</span></span>;  <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">nullptr</span> &amp;&amp; s.get() == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-keyword">return</span> JNI_ERR;  &#125;  <span class="hljs-comment">// Choose an appropriate constructor and set up the arguments.</span>  jvalue args[<span class="hljs-number">2</span>];  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* signature;  <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">nullptr</span> &amp;&amp; cause == <span class="hljs-literal">nullptr</span>) &#123;    signature = <span class="hljs-string">"()V"</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">nullptr</span> &amp;&amp; cause == <span class="hljs-literal">nullptr</span>) &#123;    signature = <span class="hljs-string">"(Ljava/lang/String;)V"</span>;    args[<span class="hljs-number">0</span>].l = s.get();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">nullptr</span> &amp;&amp; cause != <span class="hljs-literal">nullptr</span>) &#123;    signature = <span class="hljs-string">"(Ljava/lang/Throwable;)V"</span>;    args[<span class="hljs-number">0</span>].l = cause;  &#125; <span class="hljs-keyword">else</span> &#123;    signature = <span class="hljs-string">"(Ljava/lang/String;Ljava/lang/Throwable;)V"</span>;    args[<span class="hljs-number">0</span>].l = s.get();    args[<span class="hljs-number">1</span>].l = cause;  &#125;  jmethodID mid = env-&gt;GetMethodID(exception_class, <span class="hljs-string">"&lt;init&gt;"</span>, signature);  <span class="hljs-keyword">if</span> (mid == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;    LOG(ERROR) &lt;&lt; <span class="hljs-string">"No &lt;init&gt;"</span> &lt;&lt; signature &lt;&lt; <span class="hljs-string">" in "</span>        &lt;&lt; mirror::Class::PrettyClass(soa.Decode&lt;mirror::Class&gt;(exception_class));    <span class="hljs-keyword">return</span> JNI_ERR;  &#125;  <span class="hljs-function">ScopedLocalRef&lt;jthrowable&gt; <span class="hljs-title">exception</span><span class="hljs-params">(      env, <span class="hljs-keyword">reinterpret_cast</span>&lt;jthrowable&gt;(env-&gt;NewObjectA(exception_class, mid, args)))</span></span>;  <span class="hljs-keyword">if</span> (exception.get() == <span class="hljs-literal">nullptr</span>) &#123;    <span class="hljs-keyword">return</span> JNI_ERR;  &#125;  <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;  soa.Self()-&gt;SetException(soa.Decode&lt;mirror::Throwable&gt;(exception.get()));  <span class="hljs-keyword">return</span> JNI_OK;&#125;<span class="hljs-comment">//thread.cc</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Thread::SetException</span><span class="hljs-params">(ObjPtr&lt;mirror::Throwable&gt; new_exception)</span> </span>&#123;  CHECK(new_exception != <span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> DCHECK(!IsExceptionPending());</span>  <span class="hljs-comment">//此处设置了 jni插入的异常信息 ,会触发ART的checkPoint的检测，检测到该信息时抛出对应异常</span>  tlsPtr_.exception = new_exception.Ptr();&#125;</code></pre><p>插入位置在<strong>方法调用</strong>或<strong>循环</strong>处。</p></li><li><p>使用Gradle命令更新 dependenices</p><pre><code class="hljs groovy">./gradlew --configure-on-demand</code></pre></li></ol><ol start="34"><li><p>Markdown常用操作</p><pre><code class="hljs markdown">[<span class="hljs-string">显示内容</span>](<span class="hljs-link">#标题</span>) 锚点跳转&#123;%post_link 文章标题%&#125;  文章跳转</code></pre></li></ol><ol start="35"><li><p>设置hexo的博客置顶规则，按照tops进行配置</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> posts = locals.posts.data.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<span class="hljs-comment">//两个post都定义了top</span><span class="hljs-keyword">if</span> (a.top &amp;&amp; b.top) &#123;<span class="hljs-comment">//按日期将降序</span><span class="hljs-keyword">if</span> (a.top == b.top) <span class="hljs-keyword">return</span> b.date - a.date;<span class="hljs-comment">//按top排序</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b.top - a.top;&#125;<span class="hljs-comment">//定义了top的排前面</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.top &amp;&amp; !b.top) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!a.top &amp;&amp; b.top) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//没有定义top就按照日期降序</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b.date - a.date;&#125;);</code></pre><p>需要配置在<code>node-modules/hexo-generator-index2/lib/generator.js</code>里面</p></li><li><p>kotlin中的<code>inline</code>、<code>noinline</code>、<code>crossinline</code>的作用、</p><p><code>inline</code>：函数进行内联，将<code>inline fun</code>直接插入到调用函数的代码内，优化代码结构，从而减少函数类型对象的创建。</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;  testInline()  print(<span class="hljs-string">"world"</span>)&#125;<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testInline</span><span class="hljs-params">()</span></span>&#123;  print(<span class="hljs-string">"Hello"</span>)&#125;输出结果：HelloWorld实际编译结果：<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;  print(<span class="hljs-string">"Hello"</span>)  print(<span class="hljs-string">"world"</span>)&#125;</code></pre></li></ol><pre><code>`noinline`：局部关掉函数内联优化，摆脱`inline不能使用函数类型的参数当对象用`的限制。作用于**函数的参数且参数必须为函数类型**<pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">noinline</span> a : <span class="hljs-type">Int</span>)</span></span> &#123;   <span class="hljs-comment">//Modifier 'noinline' is allowed only for function parameters of an inline function</span>   <span class="hljs-comment">//错误使用方法 `noinline`只能使用在函数参数上</span>&#125;<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>,  b: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span> &#123;    <span class="hljs-keyword">return</span> b  <span class="hljs-comment">//Illegal usage of inline-parameter 'b' </span>  <span class="hljs-comment">//错误使用方法 不能直接返回 函数类型，因为经过内联后，函数类型无法被调用，失去了存在意义</span>  <span class="hljs-comment">//这种错误写法，编译器可以直接检测出来</span>&#125;<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(a:<span class="hljs-type">Int</span> , <span class="hljs-keyword">noinline</span> b :(<span class="hljs-type">String</span>)-&gt;<span class="hljs-type">Unit</span>)</span></span> : (String) -&gt; <span class="hljs-built_in">Unit</span> &#123;  println(a)  b(<span class="hljs-string">"World"</span>)  <span class="hljs-keyword">return</span> b&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;  println(<span class="hljs-string">"Hello"</span>)  test(<span class="hljs-number">3</span>)&#123; it-&gt;    println(it)  &#125;&#125;输出结果：Hello<span class="hljs-number">3</span>World实际编辑结果：<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;  println(<span class="hljs-string">"Hello"</span>)  println(<span class="hljs-number">3</span>)  b.invoke(<span class="hljs-string">"World"</span>)&#125;</code></pre>`crossinline`：局部加强函数内联优化，将内联函数里的函数类型参数可以当作对象使用。首先声明两个概念：- Lambda表达式不允许使用`return`，可以使用`return@XX`来指定返回位置  <pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(a:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;  ...&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123; test &#123;   ...   <span class="hljs-keyword">return</span> <span class="hljs-comment">//这个是不被允许使用的</span> <span class="hljs-comment">//return@test 这个是可以的  </span> &#125; &#125;</code></pre>- 只有被`inline`修饰的内联函数的`Lambda表达式`可以使用return。在`间接调用`是被禁止的操作  <pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(action:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;  println(<span class="hljs-string">"Hello"</span>)  action()&#125;<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;  test&#123;    println(<span class="hljs-string">"World"</span>)    <span class="hljs-keyword">return</span> <span class="hljs-comment">//是被允许这么做的</span>  &#125;&#125;</code></pre>`crossinline`实质为了**声明函数参数的`lambda`不能写`return`，避免lambda中的return影响外部的执行流程**。使用`inline`修饰函数时需要注意以下几点：- `inline`修饰函数，最好函数参数也是`函数类型`，否则无法获得性能提升- **避免内联大型函数**，因为`inline`会增加代码的生成量- `inline`修饰的函数不持有函数的对象引用，也不能将函数参数传递给另一个函数  <pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test123</span><span class="hljs-params">(a:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;&#125;<span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test12</span><span class="hljs-params">(a:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;    test123(a) <span class="hljs-comment">//无法编译</span>&#125;</code></pre></code></pre><ol start="37"><li><p>匿名内存(Ashmem)</p><p>以Android Q为目标平台(<code>targetVersion 29</code>)的应用无法直接使用<code>ashmem</code>，必须通过NDK的<code>AsharedMemory</code>来访问共享内存，也无法直接使用<code>ioctl</code>，必须改为<code>AShredMemory</code>来创建共享内存区域。</p></li><li><p>当出现<code>您的连接不是私密连接</code>时，点击高级后，并直接输入<strong>thisisunsafe</strong>关键字并回车。</p></li><li><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    B b = <span class="hljs-keyword">new</span> B;  &#125;&#125;</code></pre><p>此时调用<code>A</code>类，是否触发<code>B</code>的加载？</p></li></ol><ol start="40"><li><p>如何获取当前Activity展示的Dialog？</p><pre><code class="hljs java">    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;View&gt; <span class="hljs-title">getViewRoots</span><span class="hljs-params">()</span> </span>&#123;        List&lt;View&gt; viewRoots = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">try</span> &#123;            Object windowManager;            windowManager = Class.forName(<span class="hljs-string">"android.view.WindowManagerGlobal"</span>)                    .getMethod(<span class="hljs-string">"getInstance"</span>).invoke(<span class="hljs-keyword">null</span>);<span class="hljs-comment">//WindowManagerGlobal 内部持有 mRoots(ViewRootImpl列表) mViews(DecorView列表) </span>            Field rootsField = windowManager.getClass().getDeclaredField(<span class="hljs-string">"mRoots"</span>);            rootsField.setAccessible(<span class="hljs-keyword">true</span>);            Field stoppedField = Class.forName(<span class="hljs-string">"android.view.ViewRootImpl"</span>)                    .getDeclaredField(<span class="hljs-string">"mStopped"</span>);            stoppedField.setAccessible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//ViewRootImpl mView对应了 DecorView</span>            Field rootViewField = Class.forName(<span class="hljs-string">"android.view.ViewRootImpl"</span>)                    .getDeclaredField(<span class="hljs-string">"mView"</span>);            rootViewField.setAccessible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//DecorView mWindow对应了 PhoneWindow</span>            Field windowField = Class.forName(<span class="hljs-string">"com.android.internal.policy.DecorView"</span>)                    .getDeclaredField(<span class="hljs-string">"mWindow"</span>);            windowField.setAccessible(<span class="hljs-keyword">true</span>);            List&lt;ViewParent&gt; viewParents = (List&lt;ViewParent&gt;) rootsField.get(windowManager);            <span class="hljs-comment">// Filter out inactive view roots</span>            <span class="hljs-keyword">for</span> (ViewParent viewParent : viewParents) &#123;                <span class="hljs-keyword">boolean</span> stopped = (<span class="hljs-keyword">boolean</span>) stoppedField.get(viewParent);                <span class="hljs-keyword">if</span> (!stopped) &#123;                    View view = (View) rootViewField.get(viewParent);                    Window w = (Window) windowField.get(view);                  <span class="hljs-comment">//Window setCallback 一般对应Window的创建者 </span>                    Log.w(<span class="hljs-string">"sss"</span>,w.getCallback().toString());                    viewRoots.add(view);                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> viewRoots;    &#125;</code></pre><p>当有dialog弹出时，此时页面就会有两个window对象。通过反射也可以获取两个对象。</p><blockquote><p>一般Activity和Dialog的布局都比较复杂，可能会存在标题栏等信息，需要封装一层DecorView。</p><p>然后通过<code>windowManager</code>管理。</p><p><code>Toast</code>与<code>PopupWindow</code>布局比较简单，直接addView即可。</p></blockquote></li><li><p>ss</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity,Window,View的关联与理解</title>
    <link href="/2018/04/01/Activity-Window-View%E7%9A%84%E5%85%B3%E8%81%94%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
    <url>/2018/04/01/Activity-Window-View%E7%9A%84%E5%85%B3%E8%81%94%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity-Window-View相关"><a href="#Activity-Window-View相关" class="headerlink" title="Activity,Window,View相关"></a>Activity,Window,View相关</h1><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ActivityWindowView的联系.png" srcset="/img/loading.gif" class="full-image" alt="Activity&Window&View" title="Activity&Window&View"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="1-什么是Activity-Window-View以及职能简介"><a href="#1-什么是Activity-Window-View以及职能简介" class="headerlink" title="1. 什么是Activity,Window,View以及职能简介"></a>1. 什么是Activity,Window,View以及职能简介</h2><ul><li>Activity：不负责视图控制，只是控制生命周期和处理事件，真正控制视图的是Window，一个Activity包含一个Window，Window真正代表一个窗口。<code>Activity是一个控制器，控制视图的添加与显示以及通过回调方法来进行Window与View的交互。</code></li><li>Window：Window是视图的承载器，内部持有一个DecorView，DecorView才是view的根布局，Window为抽象类，实际是Activity中的其子类PhoneWindow，其中有个内部类DecorView，通过创建DecorView来加载<code>R.layout.*</code>，Window通过WindowManager加载DecorView，并将DecorView和ViewRoot关联，进行视图控制与交互。</li><li>View：DecorView继承自FrameLayout,DecorView作为顶级View，一般其内部包含一个竖直方向的LinearLayout，里面包含ViewStub，标题栏（titleView），内容栏（contentView）。Activity通过<code>setContentView()</code>将布局文件加载进内容栏中。</li><li>ViewRoot：ViewRoot的实现类是ViewRootImpl，是WindowService和DecorView之间的纽带。ViewRoot不属于View节点，和View之间没有直接联系，不过实现了ViewParent接口。<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/activity_window_view.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul><h2 id="2-Activity如何和Window，View关联（附源码）"><a href="#2-Activity如何和Window，View关联（附源码）" class="headerlink" title="2. Activity如何和Window，View关联（附源码）"></a>2. Activity如何和Window，View关联（附源码）</h2><h3 id="Activity和Window关联"><a href="#Activity和Window关联" class="headerlink" title="Activity和Window关联"></a>Activity和Window关联</h3><a href="/2019/01/02/Activity启动过程/" title="Activity启动过程">Activity启动过程</a><p>在此简述下Activity的启动过程：</p><ul><li>调用<code>ContextImpl.startActivity()</code>实质调用<code>ContextImpl.startActivityForResult()</code></li><li>执行到<code>performLaunchActivity()</code>在其中完成启动流程</li><li>通过<code>Instrumentation.newActivity</code>使用类加载器创建Activity对象</li><li>通过<code>LoadedApk.makeApplication()</code>尝试创建Application对象(<em>Application已被创建则跳过</em>)</li><li>创建<code>ContextImpl</code>对象，并执行<code>Activity.attach()</code>完成一些重要数据的初始化</li><li>最终调用<code>Activity.onCreate()</code>完成启动流程。</li></ul><p>其中<code>Activity和Window的关联</code>发生在<code>Activity.attach()</code>中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Context context, ActivityThread aThread,           Instrumentation instr, IBinder token, <span class="hljs-keyword">int</span> ident,           Application application, Intent intent, ActivityInfo info,           CharSequence title, Activity parent, String id,           NonConfigurationInstances lastNonConfigurationInstances,           Configuration config, String referrer, IVoiceInteractor voiceInteractor,           Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;       attachBaseContext(context);       mFragments.attachHost(<span class="hljs-keyword">null</span> <span class="hljs-comment">/*parent*/</span>);       <span class="hljs-comment">//进行了PhoneWindow的初始化并进行关联</span>       mWindow = <span class="hljs-keyword">new</span> PhoneWindow(<span class="hljs-keyword">this</span>, window, activityConfigCallback);       mWindow.setWindowControllerCallback(<span class="hljs-keyword">this</span>);       mWindow.setCallback(<span class="hljs-keyword">this</span>);       mWindow.setOnWindowDismissedCallback(<span class="hljs-keyword">this</span>);       mWindow.getLayoutInflater().setPrivateFactory(<span class="hljs-keyword">this</span>);       ...&#125;</code></pre><p>其中<code>PhoneWindow</code>就是Activity的根Window，可以在其上添加其他的Window(<em>例如Dialog</em>)，<code>PhoneWindow</code>就是<code>Activity</code>与<code>View</code>之间的桥梁，Activity无法直接操作View。</p><h3 id="Window和View关联"><a href="#Window和View关联" class="headerlink" title="Window和View关联"></a>Window和View关联</h3><p>Activity无法直接和View交互，需要通过Window管理</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(@LayoutRes <span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;    getWindow().setContentView(layoutResID);    initWindowDecorActionBar();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Window <span class="hljs-title">getWindow</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> mWindow;&#125;</code></pre><p>Activity通过<code>setContentView()</code>加载要显示的布局，观察源码可知还是通过<code>Window</code>进行了加载操作。</p><h3 id="加载View"><a href="#加载View" class="headerlink" title="加载View"></a>加载View</h3><pre><code class="hljs java"> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;            installDecor();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;            mContentParent.removeAllViews();        &#125;        <span class="hljs-keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;            <span class="hljs-keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,                    getContext());            transitionTo(newScene);        &#125; <span class="hljs-keyword">else</span> &#123;            mLayoutInflater.inflate(layoutResID, mContentParent);        &#125;        mContentParent.requestApplyInsets();        <span class="hljs-keyword">final</span> Callback cb = getCallback();        <span class="hljs-keyword">if</span> (cb != <span class="hljs-keyword">null</span> &amp;&amp; !isDestroyed()) &#123;            cb.onContentChanged();        &#125;        mContentParentExplicitlySet = <span class="hljs-keyword">true</span>;    &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">installDecor</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (mDecor == <span class="hljs-keyword">null</span>) &#123;        mDecor = generateDecor(); <span class="hljs-comment">//生成DecorView</span>        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);        mDecor.setIsRootNamespace(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="hljs-number">0</span>) &#123;            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);        &#125;    &#125;    <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;        mContentParent = generateLayout(mDecor); <span class="hljs-comment">// 为DecorView设置布局格式，并返回mContentParent</span>        ...        &#125;     &#125;&#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> DecorView <span class="hljs-title">generateDecor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> featureId)</span> </span>&#123;        Context context;        <span class="hljs-keyword">if</span> (mUseDecorContext) &#123;            Context applicationContext = getContext().getApplicationContext();            <span class="hljs-keyword">if</span> (applicationContext == <span class="hljs-keyword">null</span>) &#123;                context = getContext();            &#125; <span class="hljs-keyword">else</span> &#123;                context = <span class="hljs-keyword">new</span> DecorContext(applicationContext, getContext().getResources());                <span class="hljs-keyword">if</span> (mTheme != -<span class="hljs-number">1</span>) &#123;                    context.setTheme(mTheme);                &#125;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            context = getContext();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DecorView(context, featureId, <span class="hljs-keyword">this</span>, getAttributes());    &#125;</code></pre><p>Activity通过<code>setContentView()</code>调用到<code>PhoneWindow.setContentView()</code>执行DecorView的创建流程。</p><blockquote><p><code>DecorView</code>直接和<code>PhoneWindow</code>进行关联，其内部包含了我们定义的布局(<em>ContentView</em>)以及一个<code>titlebar</code>。</p></blockquote><h3 id="显示View"><a href="#显示View" class="headerlink" title="显示View"></a>显示View</h3><p>上述方法只是创建了一个<code>DecorView</code>，而没有执行显示流程。这就涉及到了<code>Activity的生命周期</code>，其中有讲到在<code>onResume()</code>才对用户可见。</p><a href="/2018/12/14/View的工作原理/" title="View的工作原理">View的工作原理</a><p><strong>View需要通过Window才能展示在Activity上。</strong></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><blockquote><p>Activity就像个控制器，不负责视图部分；</p><p>Window像个承载器，装着内部视图；</p><p>DecorView就是个顶层视图，是所有View的最外层布局；</p><p>ViewRoot就是个连接器，负责沟通，是WindowManager和View之间的桥梁。</p></blockquote><p>Activity包含了一个PhoneWindow，而PhoneWindow就是继承于Window的，Activity通过<code>setContentView</code>将View设置到了PhoneWindow上，而View通过WindowManager的<code>addView()、removeView()、updateViewLayout()</code>对View进行管理。Window的添加过程以及Activity的启动流程都是一次IPC的过程。Activity的启动需要通过AMS完成；Window的添加过程需要通过WindowSession完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础排序算法介绍</title>
    <link href="/2018/03/20/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2018/03/20/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="基础排序算法介绍"><a href="#基础排序算法介绍" class="headerlink" title="基础排序算法介绍"></a>基础排序算法介绍</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a>知识点:</h2><ul><li>排序算法稳定性的定义：简单的介绍就是排序前相等的数据先后顺序在排序后的先后顺序位置相同</li><li><p>基本交换算法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = array[i];    array[i] = array[j];    array[j] = temp;&#125;</code></pre></li><li><p>时间复杂度：执行算法所需要的计算工作量 $ O(1) $ 意味没有循环即只执行单条语句 $ O(n) $ 执行没有嵌套的循环 $ O(n^2) $ 双重嵌套循环</p></li><li>空间复杂度：算法在运行工程中临时占用存储空间的量度</li></ul><table><thead><tr><th>算法</th><th style="text-align:center">平均时间</th><th style="text-align:center">最好</th><th style="text-align:center">最差</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td>  冒泡排序</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(n) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">稳定</td></tr><tr><td>  直接插入排序</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(n) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">稳定</td></tr><tr><td>  折半插入排序</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">稳定</td></tr><tr><td>  希尔排序</td><td style="text-align:center">$ O(nlogn) $ - $ O(n^2) $</td><td style="text-align:center">$ O(n^1.3) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">不稳定</td></tr><tr><td>  选择排序</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">不稳定</td></tr><tr><td>  快速排序</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(nlogn) $ - $ O(n^2) $</td><td style="text-align:center">不稳定</td></tr><tr><td>  归并排序</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(n) $</td><td style="text-align:center">稳定</td></tr><tr><td>  堆排序</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">不稳定</td></tr></tbody></table><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>在要排序的一组数中，对当前范围内还未排列好的数据由上而下进行比较，即每当相邻的数与要求的排序方式相反时将数据进行互换<br>改进版的写法就是利用标记法减少循环次数</p></blockquote><blockquote><p>基本写法<br><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;        <span class="hljs-keyword">int</span> size = array.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; size - i; j++) &#123;                <span class="hljs-keyword">if</span> (array[j - <span class="hljs-number">1</span>] &gt; array[j]) &#123;                    swap(array, j, j - <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;    &#125;</code></pre></p></blockquote><blockquote><p>改进写法<br><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">advancedBubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;        <span class="hljs-keyword">int</span> size = array.length;        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置标记位</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; i++) &#123;            flag = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; size - i; j++) &#123;                <span class="hljs-keyword">if</span> (array[j - <span class="hljs-number">1</span>] &gt; array[j]) &#123;                    flag = <span class="hljs-number">1</span>;                    swap(array, j, j - <span class="hljs-number">1</span>);                &#125;            &#125;            <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<span class="hljs-comment">//没有发生数据交换则意味着排序已经结束</span>                <span class="hljs-keyword">break</span>;        &#125;    &#125;</code></pre></p></blockquote><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>再一次遍历过程中找到最小值放在排序数据中的首位，每次寻找剩余中最小的直到结束为止。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;        <span class="hljs-keyword">int</span> size = array.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            <span class="hljs-keyword">int</span> minIndex = i;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; size; j++) &#123;                <span class="hljs-keyword">if</span> (array[j] &lt; array[minIndex]) &#123;                    minIndex = j;                &#125;            &#125;            swap(array, i, minIndex);        &#125;    &#125;</code></pre><hr><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><blockquote><p>按照顺序选定元素从后往前找，插入一个顺序数列中即可</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;       <span class="hljs-keyword">int</span> size = array.length;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;           <span class="hljs-keyword">int</span> temp = array[i];           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; array[j - <span class="hljs-number">1</span>] &gt; array[j]; j--) &#123;<span class="hljs-comment">//从该元素所在位置 向前移动 直到该元素位于 递增顺序</span>               array[j] = array[j - <span class="hljs-number">1</span>];               array[j - <span class="hljs-number">1</span>] = temp;           &#125;       &#125;   &#125;</code></pre><hr><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><blockquote><p>再往前寻找位置的过程中利用二分法寻找位置</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertBinarySort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;        <span class="hljs-keyword">int</span> size = array.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) &#123;            <span class="hljs-keyword">if</span> (array[i] &lt; array[i - <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//前比后大</span>                <span class="hljs-keyword">int</span> temp = array[i];                <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>, high = i - <span class="hljs-number">1</span>, mid;                <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<span class="hljs-comment">//直到相交或者相反</span>                    mid = (low + high) / <span class="hljs-number">2</span>;<span class="hljs-comment">//折中取点</span>                    <span class="hljs-keyword">if</span> (temp &lt; array[mid]) &#123;<span class="hljs-comment">//小于中点则位于中点左侧</span>                        high = mid - <span class="hljs-number">1</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        low = mid + <span class="hljs-number">1</span>;                    &#125;                &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt; low; j--) &#123;                    array[j] = array[j - <span class="hljs-number">1</span>];                &#125;                array[low] = temp;<span class="hljs-comment">//低点使用temp</span>            &#125;        &#125;    &#125;</code></pre><hr><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>先取<code>d</code>为间隔，将原始数组分为d个序列，将间隔的数组放在一个子序列利用插入排序法进行排序 然后缩小间隔<code>d</code> 重复上述操作，知道<code>d</code>为1时，则排序完成</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;        <span class="hljs-keyword">int</span> size = array.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = size / <span class="hljs-number">2</span>; d &gt; <span class="hljs-number">0</span>; d /= <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//设置步长</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i += d) &#123;                <span class="hljs-keyword">int</span> temp = array[i];                <span class="hljs-keyword">int</span> j = i;                <span class="hljs-keyword">for</span> (; j &gt;= d &amp;&amp; temp &lt; array[j - d]; j -= d) &#123;                    array[j] = array[j - d];                &#125;                array[j] = temp;            &#125;        &#125;    &#125;</code></pre><hr><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><blockquote><p>讲一组元素进行桶分配，按照每位数的大小进行排序</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;    <span class="hljs-keyword">int</span> size = array.length;    <span class="hljs-keyword">int</span> max = array[<span class="hljs-number">0</span>];<span class="hljs-comment">//数组中的最大数</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;        <span class="hljs-keyword">if</span> (array[i] &gt; max)            max = array[i];    &#125;    <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;<span class="hljs-comment">//最大位数</span>    <span class="hljs-keyword">while</span> (max &gt; <span class="hljs-number">0</span>) &#123;        max /= <span class="hljs-number">10</span>;        time++;    &#125;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<span class="hljs-comment">//索引</span>    <span class="hljs-keyword">int</span> m = <span class="hljs-number">1</span>;<span class="hljs-comment">//位值</span>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>;<span class="hljs-comment">//第几位</span>    <span class="hljs-keyword">int</span>[][] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][size];    <span class="hljs-keyword">int</span>[] order = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];    <span class="hljs-keyword">while</span> (m &lt;= time) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> arr : array) &#123;            <span class="hljs-keyword">int</span> lsd = (arr / n) % <span class="hljs-number">10</span>;            temp[lsd][order[lsd]] = arr;            order[lsd]++;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">if</span> (order[i] != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; order[i]; j++) &#123;                    array[k] = temp[i][j];                    k++;                &#125;            &#125;            order[i] = <span class="hljs-number">0</span>;        &#125;        n *= <span class="hljs-number">10</span>;        k = <span class="hljs-number">0</span>;        m++;    &#125;&#125;</code></pre><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>通过排序将待排序记录分成两部分，其中一部分记录的关键字均比另一部分小，然后分别对这两部分进行排序，直到整个序列有序。<strong>快速排序在元素很少时，效率很低</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span>(l&gt;=r)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> p=getMiddle(arr,l,r);<span class="hljs-comment">//取出中点</span>    quickSort(arr,l,p-<span class="hljs-number">1</span>);<span class="hljs-comment">//对左侧进行排序</span>    quickSort(arr,p+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//对右侧进行排序</span>&#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMiddle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = arr[l];<span class="hljs-comment">//定义左侧为基点</span>        <span class="hljs-keyword">int</span> middle = l;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = middle + <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;            <span class="hljs-keyword">if</span> (arr[i] &lt; temp) &#123;                swap(arr, middle + <span class="hljs-number">1</span>, i);                middle++;            &#125;        &#125;        swap(arr, l, middle);        <span class="hljs-keyword">return</span> middle;    &#125;</code></pre><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>把待排序序列分成若干个有序子序列，然后再把子序列合并成一个有序序列。</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (l &lt; r) &#123;        mergeSort(arr, l, mid);        mergeSort(arr, mid + <span class="hljs-number">1</span>, r);        merge(arr, l, mid, r);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[high - low + <span class="hljs-number">1</span>];    <span class="hljs-comment">//左指针</span>    <span class="hljs-keyword">int</span> i = low;    <span class="hljs-comment">//右指针</span>    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-comment">//把较小的数 移动到新数组中</span>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;        <span class="hljs-keyword">if</span> (arr[i] &lt; arr[j]) &#123;            temp[index++] = arr[i++];        &#125; <span class="hljs-keyword">else</span> &#123;            temp[index++] = arr[j++];        &#125;    &#125;    <span class="hljs-comment">//把左边剩余的数移到新数组中</span>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        temp[index++] = arr[i++];    &#125;    <span class="hljs-comment">//把右边剩余的数移到新数组中</span>    <span class="hljs-keyword">while</span> (j &lt;= high) &#123;        temp[index++] = arr[j++];    &#125;    <span class="hljs-comment">//得到新的数据 覆盖原有部分</span>    System.arraycopy(temp, <span class="hljs-number">0</span>, arr, low, temp.length);&#125;</code></pre><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>将数组构成大堆二叉树，即父节点比子节点大的二叉树，然后每次将根节点放在最后一位，循环遍历</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/** * 堆排序 * <span class="hljs-doctag">@param</span> arr */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-comment">//预先构建一次大堆二叉树</span>    buildMaxHeap(arr);    <span class="hljs-keyword">int</span> length = arr.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        swap(arr, <span class="hljs-number">0</span>, i);        maxHeap(arr, i, <span class="hljs-number">0</span>);    &#125;&#125;<span class="hljs-comment">/** *  */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> length = arr.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        maxHeap(arr, length, i);    &#125;&#125;<span class="hljs-comment">/** * 构建大堆二叉树节点 */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">maxHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> node)</span> </span>&#123;    <span class="hljs-keyword">int</span> left = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> right = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> maxIndex = node;    <span class="hljs-keyword">if</span> (left &lt; length &amp;&amp; arr[left] &gt; arr[maxIndex]) &#123;        maxIndex = left;    &#125;    <span class="hljs-keyword">if</span> (right &lt; length &amp;&amp; arr[right] &gt; arr[maxIndex]) &#123;        maxIndex = right;    &#125;    <span class="hljs-comment">//如果不是父节点最大，则找到最大的子节点进行调换</span>    <span class="hljs-keyword">if</span> (maxIndex != node) &#123;        swap(arr, node, maxIndex);        maxHeap(arr, length, maxIndex);    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android-Study-Plan-XI</title>
    <link href="/2018/03/19/Android-Study-Plan-XI/"/>
    <url>/2018/03/19/Android-Study-Plan-XI/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：Okhttp和Retrofit</p><p>1、介绍这两个框架的作用和联系<br>PS：这个问题几乎Android面试必问</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Glide源码解析要点</title>
    <link href="/2018/03/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%A6%81%E7%82%B9/"/>
    <url>/2018/03/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%A6%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<!-- TODO Glide如何加载大图 BitmapPool的使用--><blockquote><p>该源码解析是基于最新的Glide 4.8.0进行的</p></blockquote><h2 id="Glide基本流程分析"><a href="#Glide基本流程分析" class="headerlink" title="Glide基本流程分析"></a>Glide基本流程分析</h2><p>Glide的基本使用代码</p><pre><code class="hljs java">Glide.with(context).load($img$).apply(RequestOptions().transform(MultiTransformation(CenterCrop(),CircleCrop())).placeholder(R.drawable.ic_default_avatar)).into(imageView);</code></pre><p>按照上述的基本使用代码，Glide的加载过程可以分为以下几步：</p><h3 id="Glide对象初始化"><a href="#Glide对象初始化" class="headerlink" title="Glide对象初始化"></a><code>Glide对象初始化</code></h3><p>初始化代码是从<code>Glide.get()</code>开始的，在其中主要做了一些事情</p><pre><code class="hljs java"> <span class="hljs-meta">@NonNull</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Glide <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;    <span class="hljs-comment">//Glide对象时一个单例模式</span>    <span class="hljs-keyword">if</span> (glide == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">synchronized</span> (Glide<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;        <span class="hljs-keyword">if</span> (glide == <span class="hljs-keyword">null</span>) &#123;          checkAndInitializeGlide(context);        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> glide;  &#125;<span class="hljs-comment">//检查Glide对象是否初始化完毕</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkAndInitializeGlide</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;    <span class="hljs-comment">// In the thread running initGlide(), one or more classes may call Glide.get(context).</span>    <span class="hljs-comment">// Without this check, those calls could trigger infinite recursion.</span>    <span class="hljs-keyword">if</span> (isInitializing) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"You cannot call Glide.get() in registerComponents(),"</span>          + <span class="hljs-string">" use the provided Glide instance instead"</span>);    &#125;    isInitializing = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//真正初始化Glide的代码</span>    initializeGlide(context);    isInitializing = <span class="hljs-keyword">false</span>;  &#125;</code></pre><p>初始化Glide时再调用到<code>initializeGlide()</code>去进行真正的初始化工作</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeGlide</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;  initializeGlide(context, <span class="hljs-keyword">new</span> GlideBuilder());&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeGlide</span><span class="hljs-params">(@NonNull Context context, @NonNull GlideBuilder builder)</span> </span>&#123;  Context applicationContext = context.getApplicationContext();  GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();  List&lt;com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule&gt; manifestModules = Collections.emptyList();  <span class="hljs-comment">//是否使用Manifest配置的GlideModule</span>  <span class="hljs-keyword">if</span> (annotationGeneratedModule == <span class="hljs-keyword">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) &#123;    manifestModules = <span class="hljs-keyword">new</span> ManifestParser(applicationContext).parse();  &#125;  <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-keyword">null</span>      &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;    Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses =        annotationGeneratedModule.getExcludedModuleClasses();    Iterator&lt;com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule&gt; iterator = manifestModules.iterator();    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;      com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule current = iterator.next();      <span class="hljs-keyword">if</span> (!excludedModuleClasses.contains(current.getClass())) &#123;        <span class="hljs-keyword">continue</span>;      &#125;      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;        Log.d(TAG, <span class="hljs-string">"AppGlideModule excludes manifest GlideModule: "</span> + current);      &#125;      iterator.remove();    &#125;  &#125;  <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;    <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule glideModule : manifestModules) &#123;      Log.d(TAG, <span class="hljs-string">"Discovered GlideModule from manifest: "</span> + glideModule.getClass());    &#125;  &#125;  RequestManagerRetriever.RequestManagerFactory factory =      annotationGeneratedModule != <span class="hljs-keyword">null</span>          ? annotationGeneratedModule.getRequestManagerFactory() : <span class="hljs-keyword">null</span>;  builder.setRequestManagerFactory(factory);  <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule <span class="hljs-keyword">module</span> : manifestModules) &#123;    <span class="hljs-comment">//循环调用Module中的 applyOptions方法</span>    <span class="hljs-comment">//applyOptions的作用是 配置Glide加载时的图片缓存路径以及缓存空间大小</span>    <span class="hljs-keyword">module</span>.applyOptions(applicationContext, builder);  &#125;  <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">//调用注解配置Module中的 applyOptions方法</span>    <span class="hljs-comment">//applyOptions的作用是 配置Glide加载时的图片缓存路径以及缓存空间大小</span>    annotationGeneratedModule.applyOptions(applicationContext, builder);  &#125;  <span class="hljs-comment">//创建Glide对象</span>  Glide glide = builder.build(applicationContext);  <span class="hljs-comment">//循环调用Module中的 registerComponents()</span>  <span class="hljs-comment">//registerComponents的作用是 注册指定类型的数据源，以及加载图片使用ModelLoader</span>  <span class="hljs-keyword">for</span> (com.bumptech.glide.<span class="hljs-keyword">module</span>.GlideModule <span class="hljs-keyword">module</span> : manifestModules) &#123;    <span class="hljs-keyword">module</span>.registerComponents(applicationContext, glide, glide.registry);  &#125;  <span class="hljs-comment">//调用注解配置Module中的 registerComponents()</span>  <span class="hljs-comment">//registerComponents的作用是 注册指定类型的数据源，以及加载图片使用ModelLoader</span>  <span class="hljs-keyword">if</span> (annotationGeneratedModule != <span class="hljs-keyword">null</span>) &#123;    annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);  &#125;  applicationContext.registerComponentCallbacks(glide);  Glide.glide = glide;&#125;</code></pre><p>源码中发现<code>GlideModule</code>分为两种<code>manifestModules</code>和<code>annotationGeneratedModule</code>，其中<code>manifestModules</code>是为了兼容V3版本，以前的都是配置在<code>AndroidManifest.xml</code>中，而V4版本采用注解的方式，取消了清单文件中的配置。</p><pre><code class="hljs java"><span class="hljs-meta">@GlideModule</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomGlideModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppGlideModule</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyOptions</span><span class="hljs-params">(Context context, GlideBuilder builder)</span> </span>&#123;        MemorySizeCalculator calculator = <span class="hljs-keyword">new</span> MemorySizeCalculator.Builder(context).build();        <span class="hljs-keyword">int</span> defaultMemoryCacheSize = calculator.getMemoryCacheSize();        <span class="hljs-keyword">int</span> defaultBitmapPoolSize = calculator.getBitmapPoolSize();        <span class="hljs-keyword">int</span> customMemoryCacheSize = (<span class="hljs-keyword">int</span>) (<span class="hljs-number">1.2</span> * defaultMemoryCacheSize);        <span class="hljs-keyword">int</span> customBitmapPoolSize = (<span class="hljs-keyword">int</span>) (<span class="hljs-number">1.2</span> * defaultBitmapPoolSize);        builder.setMemoryCache(<span class="hljs-keyword">new</span> LruResourceCache(customMemoryCacheSize));        builder.setBitmapPool(<span class="hljs-keyword">new</span> LruBitmapPool(customBitmapPoolSize));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerComponents</span><span class="hljs-params">(Context context, Glide glide, Registry registry)</span> </span>&#123;        registry.replace(GlideUrl<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">InputStream</span>.<span class="hljs-title">class</span>, <span class="hljs-title">new</span> <span class="hljs-title">OkHttpUrlLoader</span>.<span class="hljs-title">Factory</span>(<span class="hljs-title">ProgressManager</span>.<span class="hljs-title">getOkHttpClient</span>()))</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isManifestParsingEnabled</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p>配置好<code>GlideModule</code>文件后，就需要去调用其中的<code>applyOptions()</code>设置Glide加载基本配置项，然后调用到了<code>GlideBuilder.build()</code>去构造Glide对象，最后调用其中的<code>regeisterComponents()</code>设置加载器。</p><p>接下来分析构造Glide对象的方法——<code>GlideBuilder.build()</code></p><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span><span class="hljs-function">Glide <span class="hljs-title">build</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;  <span class="hljs-comment">//设置加载图片的线程池</span>  <span class="hljs-keyword">if</span> (sourceExecutor == <span class="hljs-keyword">null</span>) &#123;    sourceExecutor = GlideExecutor.newSourceExecutor();  &#125;  <span class="hljs-comment">//写入本地磁盘缓存的线程池</span>  <span class="hljs-keyword">if</span> (diskCacheExecutor == <span class="hljs-keyword">null</span>) &#123;    diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();  &#125;  <span class="hljs-comment">//执行动画的线程池</span>  <span class="hljs-keyword">if</span> (animationExecutor == <span class="hljs-keyword">null</span>) &#123;    animationExecutor = GlideExecutor.newAnimationExecutor();  &#125;  <span class="hljs-comment">//计算内存缓存大小</span>  <span class="hljs-keyword">if</span> (memorySizeCalculator == <span class="hljs-keyword">null</span>) &#123;    memorySizeCalculator = <span class="hljs-keyword">new</span> MemorySizeCalculator.Builder(context).build();  &#125;  <span class="hljs-keyword">if</span> (connectivityMonitorFactory == <span class="hljs-keyword">null</span>) &#123;    connectivityMonitorFactory = <span class="hljs-keyword">new</span> DefaultConnectivityMonitorFactory();  &#125;  <span class="hljs-comment">//bitmap缓存池</span>  <span class="hljs-keyword">if</span> (bitmapPool == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">int</span> size = memorySizeCalculator.getBitmapPoolSize();    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123;      bitmapPool = <span class="hljs-keyword">new</span> LruBitmapPool(size);    &#125; <span class="hljs-keyword">else</span> &#123;      bitmapPool = <span class="hljs-keyword">new</span> BitmapPoolAdapter();    &#125;  &#125;  <span class="hljs-keyword">if</span> (arrayPool == <span class="hljs-keyword">null</span>) &#123;    arrayPool = <span class="hljs-keyword">new</span> LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());  &#125;  <span class="hljs-comment">//内存缓存</span>  <span class="hljs-keyword">if</span> (memoryCache == <span class="hljs-keyword">null</span>) &#123;    memoryCache = <span class="hljs-keyword">new</span> LruResourceCache(memorySizeCalculator.getMemoryCacheSize());  &#125;  <span class="hljs-comment">//硬盘缓存</span>  <span class="hljs-keyword">if</span> (diskCacheFactory == <span class="hljs-keyword">null</span>) &#123;    diskCacheFactory = <span class="hljs-keyword">new</span> InternalCacheDiskCacheFactory(context);  &#125;    <span class="hljs-keyword">if</span> (engine == <span class="hljs-keyword">null</span>) &#123;    engine =        <span class="hljs-keyword">new</span> Engine(            memoryCache,            diskCacheFactory,            diskCacheExecutor,            sourceExecutor,            GlideExecutor.newUnlimitedSourceExecutor(),            GlideExecutor.newAnimationExecutor(),            isActiveResourceRetentionAllowed);  &#125;  <span class="hljs-keyword">if</span> (defaultRequestListeners == <span class="hljs-keyword">null</span>) &#123;    defaultRequestListeners = Collections.emptyList();  &#125; <span class="hljs-keyword">else</span> &#123;    defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);  &#125;  RequestManagerRetriever requestManagerRetriever =      <span class="hljs-keyword">new</span> RequestManagerRetriever(requestManagerFactory);  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Glide(      context,      engine,      memoryCache,      bitmapPool,      arrayPool,      requestManagerRetriever,      connectivityMonitorFactory,      logLevel,      defaultRequestOptions.lock(),      defaultTransitionOptions,      defaultRequestListeners,      isLoggingRequestOriginsEnabled);&#125;</code></pre><p>当<code>GlideBuilder.build()</code>执行完毕后，最终调用到<code>new Glide()</code>完成初始化。其中关键参数为<code>Registry</code>后续的操作都需要用到该参数。</p><h3 id="with"><a href="#with" class="headerlink" title="with()"></a><code>with()</code></h3><blockquote><p>对Glide的生命周期进行管理。</p></blockquote><p>Glide对象初始化完毕后，首先会调用到的就是<code>with()</code></p><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;    <span class="hljs-keyword">return</span> getRetriever(context).get(context);  &#125;  <span class="hljs-meta">@NonNull</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;    <span class="hljs-keyword">return</span> getRetriever(activity).get(activity);  &#125;  <span class="hljs-meta">@NonNull</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull FragmentActivity activity)</span> </span>&#123;    <span class="hljs-keyword">return</span> getRetriever(activity).get(activity);  &#125;  <span class="hljs-meta">@NonNull</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull Fragment fragment)</span> </span>&#123;    <span class="hljs-keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);  &#125;  <span class="hljs-meta">@NonNull</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull View view)</span> </span>&#123;    <span class="hljs-keyword">return</span> getRetriever(view.getContext()).get(view);  &#125;</code></pre><p><code>with()</code>有5种重载方法，最后调用到的都是<code>getRetriever(context).get()</code></p><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span><span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;  <span class="hljs-keyword">if</span> (context == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"You cannot start a load on a null Context"</span>);  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="hljs-keyword">instanceof</span> Application)) &#123;    <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> FragmentActivity) &#123;      <span class="hljs-keyword">return</span> get((FragmentActivity) context);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> Activity) &#123;      <span class="hljs-keyword">return</span> get((Activity) context);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> ContextWrapper) &#123;      <span class="hljs-keyword">return</span> get(((ContextWrapper) context).getBaseContext());    &#125;  &#125;  <span class="hljs-keyword">return</span> getApplicationManager(context);&#125;<span class="hljs-meta">@NonNull</span><span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull FragmentActivity activity)</span> </span>&#123;  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;    <span class="hljs-keyword">return</span> get(activity.getApplicationContext());  &#125; <span class="hljs-keyword">else</span> &#123;    assertNotDestroyed(activity);    FragmentManager fm = activity.getSupportFragmentManager();    <span class="hljs-keyword">return</span> supportFragmentGet(        activity, fm, <span class="hljs-comment">/*parentHint=*/</span> <span class="hljs-keyword">null</span>, isActivityVisible(activity));  &#125;&#125;<span class="hljs-meta">@NonNull</span><span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Fragment fragment)</span> </span>&#123;  Preconditions.checkNotNull(fragment.getActivity(),        <span class="hljs-string">"You cannot start a load on a fragment before it is attached or after it is destroyed"</span>);  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;    <span class="hljs-keyword">return</span> get(fragment.getActivity().getApplicationContext());  &#125; <span class="hljs-keyword">else</span> &#123;    FragmentManager fm = fragment.getChildFragmentManager();    <span class="hljs-keyword">return</span> supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());  &#125;&#125;<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"deprecation"</span>)<span class="hljs-meta">@NonNull</span><span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;    <span class="hljs-keyword">return</span> get(activity.getApplicationContext());  &#125; <span class="hljs-keyword">else</span> &#123;    assertNotDestroyed(activity);    android.app.FragmentManager fm = activity.getFragmentManager();    <span class="hljs-keyword">return</span> fragmentGet(        activity, fm, <span class="hljs-comment">/*parentHint=*/</span> <span class="hljs-keyword">null</span>, isActivityVisible(activity));  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull View view)</span> </span>&#123;  <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;    <span class="hljs-keyword">return</span> get(view.getContext().getApplicationContext());  &#125;  Preconditions.checkNotNull(view);  Preconditions.checkNotNull(view.getContext(),      <span class="hljs-string">"Unable to obtain a request manager for a view without a Context"</span>);  Activity activity = findActivity(view.getContext());  <span class="hljs-comment">// The view might be somewhere else, like a service.</span>  <span class="hljs-keyword">if</span> (activity == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">return</span> get(view.getContext().getApplicationContext());  &#125;  <span class="hljs-comment">// Support Fragments.</span>  <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> FragmentActivity) &#123;    Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);    <span class="hljs-keyword">return</span> fragment != <span class="hljs-keyword">null</span> ? get(fragment) : get(activity);  &#125;  <span class="hljs-comment">// Standard Fragments.</span>  android.app.Fragment fragment = findFragment(view, activity);  <span class="hljs-keyword">if</span> (fragment == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">return</span> get(activity);  &#125;  <span class="hljs-keyword">return</span> get(fragment);&#125;</code></pre><p>简单分析上述源码可知，调用流程如下：</p><ul><li>首先判断当前调用是否在子线程，在子线程的话，直接调用<code>ApplicationContext</code>获取<code>ReqeustManager</code></li><li>不在子线程即运行在主线程时，需要判断<code>context</code>类型<ul><li><code>support.Fragment或者support.FragmentActivity</code>：调用<code>supportFragmentGet()</code></li><li><code>app.Activity或者app.fragment</code>：调用<code>fragmentGet()</code></li><li><code>Application</code>：调用<code>getApplicationManager()</code></li><li><code>view.getContext</code>：需要判断view的context类型，然后再走一次上面的步骤</li></ul></li></ul><p>根据流程分析，监听生命周期的方式主要是通过<code>监听一个无UI的Fragment(位于主线程且有对应的context存在)</code>和<code>监听Application(当位于后台线程或者contxt为Application)</code>。</p><p>其中<code>无UI的Fragment</code>对应源码中的两个类<code>RequestManagerFragment</code>、<code>SupportRequestFragment</code>在其中构造了<code>ActivityFragmentLifecycle</code>对象，在其中的关键生命周期进行联动，就可以对应的去进行加载和取消加载操作了。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">super</span>.onStart();   lifecycle.onStart(); &#125; <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">super</span>.onStop();   lifecycle.onStop(); &#125; <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">super</span>.onDestroy();   lifecycle.onDestroy();   unregisterFragmentWithRoot(); &#125;</code></pre><p>然后最后返回的<code>RequestManager</code>对象自身也会实现<code>LifecycleListener</code>接口，就可以根据对应调用跳转加载过程</p><pre><code class="hljs java"><span class="hljs-comment">//实现了LifecycleListener接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LifecycleListener</span></span>&#123;   <span class="hljs-comment">//主线程中执行</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable addSelfToLifecycle = <span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      lifecycle.addListener(RequestManager.<span class="hljs-keyword">this</span>);    &#125;  &#125;;...  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;    resumeRequests();    targetTracker.onStart();<span class="hljs-comment">//targetTracker监听</span>  &#125;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;    pauseRequests();    targetTracker.onStop();<span class="hljs-comment">//targetTracker监听</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resumeRequests</span><span class="hljs-params">()</span> </span>&#123;    Util.assertMainThread();    requestTracker.resumeRequests();<span class="hljs-comment">//requestTracker监听</span>  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pauseRequests</span><span class="hljs-params">()</span> </span>&#123;    Util.assertMainThread();    requestTracker.pauseRequests();<span class="hljs-comment">//requestTracker监听</span>  &#125;    <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;    targetTracker.onDestroy();<span class="hljs-comment">//targetTracker监听</span>    <span class="hljs-keyword">for</span> (Target&lt;?&gt; target : targetTracker.getAll()) &#123;      clear(target);    &#125;    targetTracker.clear();<span class="hljs-comment">//targetTracker监听</span>    requestTracker.clearRequests();<span class="hljs-comment">//requestTracker监听</span>    lifecycle.removeListener(<span class="hljs-keyword">this</span>);    lifecycle.removeListener(connectivityMonitor);    mainHandler.removeCallbacks(addSelfToLifecycle);    glide.unregisterRequestManager(<span class="hljs-keyword">this</span>);  &#125;&#125;</code></pre><p>完成上述流程后，RequestManager就可以实现对Fragment的监听，也就等同于实现了Glide的生命周期。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide的with.png" srcset="/img/loading.gif" class="full-image" alt="Glide的with过程" title="Glide的with过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="load"><a href="#load" class="headerlink" title="load()"></a><code>load()</code></h3><blockquote><p>传入需要加载的图片信息，通过<code>with()</code>得到的<code>RequestManager</code>进行加载。</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@CheckResult</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Bitmap bitmap)</span> </span>&#123;   <span class="hljs-keyword">return</span> asDrawable().load(bitmap); &#125; <span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@CheckResult</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Drawable drawable)</span> </span>&#123;   <span class="hljs-keyword">return</span> asDrawable().load(drawable); &#125; <span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@CheckResult</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable String string)</span> </span>&#123;   <span class="hljs-keyword">return</span> asDrawable().load(string); &#125; <span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@CheckResult</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Uri uri)</span> </span>&#123;   <span class="hljs-keyword">return</span> asDrawable().load(uri); &#125; <span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@CheckResult</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable File file)</span> </span>&#123;   <span class="hljs-keyword">return</span> asDrawable().load(file); &#125; <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"deprecation"</span>) <span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@CheckResult</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@RawRes @DrawableRes @Nullable Integer resourceId)</span> </span>&#123;   <span class="hljs-keyword">return</span> asDrawable().load(resourceId); &#125; <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"deprecation"</span>) <span class="hljs-meta">@CheckResult</span> <span class="hljs-meta">@Override</span> <span class="hljs-meta">@Deprecated</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable URL url)</span> </span>&#123;   <span class="hljs-keyword">return</span> asDrawable().load(url); &#125; <span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@CheckResult</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable <span class="hljs-keyword">byte</span>[] model)</span> </span>&#123;   <span class="hljs-keyword">return</span> asDrawable().load(model); &#125; <span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@CheckResult</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Object model)</span> </span>&#123;   <span class="hljs-keyword">return</span> asDrawable().load(model); &#125;</code></pre><p>经过<code>load()</code>分析，Glide加载的类型支持<code>Bitmap</code>、<code>Drawable</code>、<code>String(图片地址)</code>、<code>Uri</code>、<code>File(图片文件)</code>、<code>Integer(图片ResourceId)</code>、<code>URL</code>、<code>byte</code>，<code>Object</code>。</p><p>实际内部调用到的是<code>asDrawable.load()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="hljs-title">asDrawable</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> as(Drawable<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;<span class="hljs-meta">@NonNull</span><span class="hljs-meta">@CheckResult</span><span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;Bitmap&gt; <span class="hljs-title">asBitmap</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> as(Bitmap<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">apply</span>(<span class="hljs-title">DECODE_TYPE_BITMAP</span>)</span>;&#125;<span class="hljs-meta">@NonNull</span><span class="hljs-meta">@CheckResult</span><span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;GifDrawable&gt; <span class="hljs-title">asGif</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> as(GifDrawable<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">apply</span>(<span class="hljs-title">DECODE_TYPE_GIF</span>)</span>;&#125;<span class="hljs-meta">@NonNull</span><span class="hljs-meta">@CheckResult</span><span class="hljs-keyword">public</span> &lt;ResourceType&gt; <span class="hljs-function">RequestBuilder&lt;ResourceType&gt; <span class="hljs-title">as</span><span class="hljs-params">(    @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="hljs-keyword">this</span>, resourceClass, context);&#125;</code></pre><p>通过<code>asDrawable()</code>得到<code>RequestBuilder</code>对象，接下来走到<code>ReqeustBuilder.load()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Bitmap bitmap)</span> </span>&#123;    <span class="hljs-keyword">return</span> loadGeneric(bitmap)        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Drawable drawable)</span> </span>&#123;    <span class="hljs-keyword">return</span> loadGeneric(drawable)        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable String string)</span> </span>&#123;    <span class="hljs-keyword">return</span> loadGeneric(string);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Uri uri)</span> </span>&#123;    <span class="hljs-keyword">return</span> loadGeneric(uri);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable File file)</span> </span>&#123;    <span class="hljs-keyword">return</span> loadGeneric(file);  &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">loadGeneric</span><span class="hljs-params">(@Nullable Object model)</span> </span>&#123;    <span class="hljs-keyword">this</span>.model = model;    isModelSet = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">load</span><span class="hljs-params">(@Nullable Object model)</span> </span>&#123;    <span class="hljs-keyword">return</span> loadGeneric(model);  &#125;</code></pre><p>上述的<code>load()</code>都调用到了<code>loadGeneric()</code>然后进行了赋值操作，确定了<code>model</code>数据，然后完成了load流程。</p><p>//TODO 流程图</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a><code>apply()</code></h3><blockquote><p>设置一些额外配置，例如占位图、加载错误图片、图片显示类型，圆角什么的</p></blockquote><p><code>load()</code>流程结束后就得到了<code>RequestBuilder</code>对象，调用其中的<code>apply()</code></p><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestBuilder</span>&lt;<span class="hljs-title">TranscodeType</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRequestOptions</span>&lt;<span class="hljs-title">RequestBuilder</span>&lt;<span class="hljs-title">TranscodeType</span>&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">ModelTypes</span>&lt;<span class="hljs-title">RequestBuilder</span>&lt;<span class="hljs-title">TranscodeType</span>&gt;&gt; </span>&#123;      ...  <span class="hljs-meta">@NonNull</span>  <span class="hljs-meta">@CheckResult</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="hljs-title">apply</span><span class="hljs-params">(@NonNull BaseRequestOptions&lt;?&gt; requestOptions)</span> </span>&#123;    Preconditions.checkNotNull(requestOptions);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.apply(requestOptions);  &#125;            ...&#125;</code></pre><p>调用到了<code>super.apply()</code>其实就是<code>BaseRequestOptions.apply()</code></p><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span> <span class="hljs-meta">@CheckResult</span> <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">apply</span><span class="hljs-params">(@NonNull BaseRequestOptions&lt;?&gt; o)</span> </span>&#123;   <span class="hljs-keyword">if</span> (isAutoCloneEnabled) &#123;     <span class="hljs-keyword">return</span> clone().apply(o);   &#125;   BaseRequestOptions&lt;?&gt; other = o;   <span class="hljs-keyword">if</span> (isSet(other.fields, SIZE_MULTIPLIER)) &#123;     sizeMultiplier = other.sizeMultiplier;   &#125;   ...   fields |= other.fields;   options.putAll(other.options);   <span class="hljs-keyword">return</span> selfOrThrowIfLocked(); &#125;</code></pre><p><code>isSet()</code>是判断该属性是否设置，若已设置过则替换，设置完毕后，得到一个<code>RequestBuilder</code>对象，不过已经设置了<code>RequestOptions</code>里面包含了一些显示上以及缓存上的配置。</p><h3 id="into-——最关键步骤"><a href="#into-——最关键步骤" class="headerlink" title="into()——最关键步骤"></a><code>into()</code>——最关键步骤</h3><blockquote><p>进行图片的加载与显示</p></blockquote><h4 id="创建请求Request"><a href="#创建请求Request" class="headerlink" title="创建请求Request"></a>创建请求<code>Request</code></h4><p>起点是从<code>RequestBuilder.into()</code>开始</p><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span><span class="hljs-function"><span class="hljs-keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="hljs-title">into</span><span class="hljs-params">(@NonNull ImageView view)</span> </span>&#123;  Util.assertMainThread();  Preconditions.checkNotNull(view);  <span class="hljs-comment">//获取apply()设置的 RequestOptions</span>  BaseRequestOptions&lt;?&gt; requestOptions = <span class="hljs-keyword">this</span>;  <span class="hljs-comment">//是否设置了RequestOptions的ScaleType，未设置则使用ImageView的android:scaleType</span>  <span class="hljs-keyword">if</span> (!requestOptions.isTransformationSet()      &amp;&amp; requestOptions.isTransformationAllowed()      &amp;&amp; view.getScaleType() != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">switch</span> (view.getScaleType()) &#123;      <span class="hljs-keyword">case</span> CENTER_CROP:        requestOptions = requestOptions.clone().optionalCenterCrop();        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> CENTER_INSIDE:        requestOptions = requestOptions.clone().optionalCenterInside();        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> FIT_CENTER:      <span class="hljs-keyword">case</span> FIT_START:      <span class="hljs-keyword">case</span> FIT_END:        requestOptions = requestOptions.clone().optionalFitCenter();        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> FIT_XY:        requestOptions = requestOptions.clone().optionalCenterInside();        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> CENTER:      <span class="hljs-keyword">case</span> MATRIX:      <span class="hljs-keyword">default</span>:        <span class="hljs-comment">// Do nothing.</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> into(      glideContext.buildImageViewTarget(view, transcodeClass),      <span class="hljs-comment">/*targetListener=*/</span> <span class="hljs-keyword">null</span>,      requestOptions,      Executors.mainThreadExecutor());&#125;<span class="hljs-keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="hljs-function">Y <span class="hljs-title">into</span><span class="hljs-params">(    @NonNull Y target,    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,    BaseRequestOptions&lt;?&gt; options,    Executor callbackExecutor)</span> </span>&#123;  Preconditions.checkNotNull(target);  <span class="hljs-keyword">if</span> (!isModelSet) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"You must call #load() before calling #into()"</span>);  &#125;  <span class="hljs-comment">//构建Request请求对象</span>  Request request = buildRequest(target, targetListener, options, callbackExecutor);    Request previous = target.getRequest();  <span class="hljs-keyword">if</span> (request.isEquivalentTo(previous)      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;    request.recycle();    <span class="hljs-keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;      previous.begin();    &#125;    <span class="hljs-keyword">return</span> target;  &#125;  requestManager.clear(target);  <span class="hljs-comment">//给当前View设置请求</span>  target.setRequest(request);  requestManager.track(target, request);  <span class="hljs-keyword">return</span> target;&#125;</code></pre><p>通过<code>buildRequest()</code>构建图片加载请求对象。</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">buildRequest</span><span class="hljs-params">(      Target&lt;TranscodeType&gt; target,      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,      BaseRequestOptions&lt;?&gt; requestOptions,      Executor callbackExecutor)</span> </span>&#123;    <span class="hljs-keyword">return</span> buildRequestRecursive(        target,        targetListener,        <span class="hljs-comment">/*parentCoordinator=*/</span> <span class="hljs-keyword">null</span>,        transitionOptions,        requestOptions.getPriority(),        requestOptions.getOverrideWidth(),        requestOptions.getOverrideHeight(),        requestOptions,        callbackExecutor);  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">buildRequestRecursive</span><span class="hljs-params">(...)</span> </span>&#123;        ErrorRequestCoordinator errorRequestCoordinator = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//判断当前是否设置了 RequestBuilder.error()</span>    <span class="hljs-keyword">if</span> (errorBuilder != <span class="hljs-keyword">null</span>) &#123;      errorRequestCoordinator = <span class="hljs-keyword">new</span> ErrorRequestCoordinator(parentCoordinator);      parentCoordinator = errorRequestCoordinator;    &#125;    <span class="hljs-comment">//生成可能带有缩略图显示的Request</span>    Request mainRequest =        buildThumbnailRequestRecursive(...);        <span class="hljs-keyword">if</span> (errorRequestCoordinator == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> mainRequest;    &#125;    <span class="hljs-comment">//生成带有错误处理的Request</span>    Request errorRequest =        errorBuilder.buildRequestRecursive(...);    errorRequestCoordinator.setRequests(mainRequest, errorRequest);    <span class="hljs-keyword">return</span> errorRequestCoordinator;    ...        &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">buildThumbnailRequestRecursive</span><span class="hljs-params">(...)</span> </span>&#123;    <span class="hljs-comment">//是否设置了 RequestBuilder.thumbnailBuilder(RequestBuilder thumbnailBuilder)</span>    <span class="hljs-keyword">if</span> (thumbnailBuilder != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (isThumbnailBuilt) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"You cannot use a request as both the main request and a "</span>            + <span class="hljs-string">"thumbnail, consider using clone() on the request(s) passed to thumbnail()"</span>);      &#125;      TransitionOptions&lt;?, ? <span class="hljs-keyword">super</span> TranscodeType&gt; thumbTransitionOptions =          thumbnailBuilder.transitionOptions;      <span class="hljs-comment">// Apply our transition by default to thumbnail requests but avoid overriding custom options</span>      <span class="hljs-comment">// that may have been applied on the thumbnail request explicitly.</span>      <span class="hljs-keyword">if</span> (thumbnailBuilder.isDefaultTransitionOptionsSet) &#123;        thumbTransitionOptions = transitionOptions;      &#125;      Priority thumbPriority = thumbnailBuilder.isPrioritySet()          ? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);      <span class="hljs-keyword">int</span> thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();      <span class="hljs-keyword">int</span> thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();      <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)          &amp;&amp; !thumbnailBuilder.isValidOverride()) &#123;        thumbOverrideWidth = requestOptions.getOverrideWidth();        thumbOverrideHeight = requestOptions.getOverrideHeight();      &#125;      ThumbnailRequestCoordinator coordinator = <span class="hljs-keyword">new</span> ThumbnailRequestCoordinator(parentCoordinator);ThumbnailRequestCoordinator coordinator = <span class="hljs-keyword">new</span> ThumbnailRequestCoordinator(parentCoordinator);      Request fullRequest =          obtainRequest(...);      isThumbnailBuilt = <span class="hljs-keyword">true</span>;      <span class="hljs-comment">// Recursively generate thumbnail requests.</span>      Request thumbRequest =          thumbnailBuilder.buildRequestRecursive(...);      isThumbnailBuilt = <span class="hljs-keyword">false</span>;      coordinator.setRequests(fullRequest, thumbRequest);      <span class="hljs-keyword">return</span> coordinator;    &#125;  <span class="hljs-comment">//是否设置了 RequestBuilder.thumbnailBuilder(floar thumbSizeMultiplier)  对应的缩放比例</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thumbSizeMultiplier != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">// Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.</span>      ThumbnailRequestCoordinator coordinator = <span class="hljs-keyword">new</span> ThumbnailRequestCoordinator(parentCoordinator);      Request fullRequest = obtainRequest(...);      BaseRequestOptions&lt;?&gt; thumbnailOptions =          requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);      Request thumbnailRequest =          obtainRequest(...);      coordinator.setRequests(fullRequest, thumbnailRequest);      <span class="hljs-keyword">return</span> coordinator;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 没有设置 thunbmail相关参数</span>      <span class="hljs-keyword">return</span> obtainRequest(...);    &#125;  &#125; <span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">obtainRequest</span><span class="hljs-params">(      Target&lt;TranscodeType&gt; target,      RequestListener&lt;TranscodeType&gt; targetListener,      BaseRequestOptions&lt;?&gt; requestOptions,      RequestCoordinator requestCoordinator,      TransitionOptions&lt;?, ? <span class="hljs-keyword">super</span> TranscodeType&gt; transitionOptions,      Priority priority,      <span class="hljs-keyword">int</span> overrideWidth,      <span class="hljs-keyword">int</span> overrideHeight,      Executor callbackExecutor)</span> </span>&#123;    <span class="hljs-keyword">return</span> SingleRequest.obtain(...);  &#125;</code></pre><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide创建请求.png" srcset="/img/loading.gif" class="full-image" alt="Glide创建请求" title="Glide创建请求"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>总结一下创建请求的流程，最后调用的是<code>SingleRequest</code>对象。</p><ul><li><p>通过<code>RequestBuilder.buildRequest()</code>创建<code>Request</code>对象，调用到<code>buildRequestRecursive()</code>执行创建逻辑</p></li><li><p>先判断设置过<code>RequestBuilder.error()</code>参数，如果设置过<code>errorRequest</code>，需要通过<code>errorRequest</code>和<code>mainRequest</code>得到<code>ErrorRequestCoordinator(实现Request接口)</code>对象。</p></li><li><p>没设置过<code>RequestBuilder.error()</code>参数，则向下判断是否设置过<code>ReqeustBuilder.thumbnail()</code>参数，设置<code>ReqeustBuilder.thumbnail()</code>有两种方法：</p><ul><li><code>ReqeustBuilder.thumbnail(RequestBuilder thumbnailBuilder)</code>：自定义要显示的缩略图</li><li><code>ReqeustBuilder.thumbnail(float thumbSizeMultiper)</code>：设置原图缩放比例</li></ul><p>只要设置了其中的一种，就会产生<code>thumbRequest</code>对象，然后与<code>fullRequest</code>得到<code>ThumbnailRequestCoordinator(实现Request接口)</code>对象。</p></li><li><p><code>ReqeustBuilder.thumbnail()</code>也未设置，则最终调用<code>SingleRequest.obtain()</code>得到<code>SingleRequest(实现Request接口)</code>对象。</p></li></ul><blockquote><p> <code>errorRequest</code>表示了加载错误的请求</p><p> <code>thumbRequest</code>表示了缩略图加载请求</p><p> <code>mainRequest</code>和<code>fullRequest</code>都代表了原始图片加载请求。</p></blockquote><p>上述创建请求流程执行完毕后，就是发送请求。</p><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><blockquote><p>发送请求通过调用<code>Request</code>实现。</p></blockquote><p>在<a href="#创建请求">创建请求</a>中，创建完成后会调用到<code>requestManager.track(target, request);</code>去发送请求</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">track</span><span class="hljs-params">(@NonNull Target&lt;?&gt; target, @NonNull Request request)</span> </span>&#123;  <span class="hljs-comment">//监听target的生命周期</span>  targetTracker.track(target);  <span class="hljs-comment">//开启请求</span>  requestTracker.runRequest(request);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runRequest</span><span class="hljs-params">(@NonNull Request request)</span> </span>&#123;  requests.add(request);  <span class="hljs-keyword">if</span> (!isPaused) &#123;    <span class="hljs-comment">//开始启动</span>    request.begin();  &#125; <span class="hljs-keyword">else</span> &#123;    request.clear();    <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;      Log.v(TAG, <span class="hljs-string">"Paused, delaying request"</span>);    &#125;    pendingRequests.add(request);  &#125;&#125;</code></pre><p>接下来就是调用到<code>Request.begin()</code>，<code>Request</code>是一个接口，<code>singleRequest</code>是具体的实现类，即调用到<code>SingleRequest.begin()</code></p><pre><code class="hljs java">  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;    assertNotCallingCallbacks();    stateVerifier.throwIfRecycled();    startTime = LogTime.getLogTime();    <span class="hljs-keyword">if</span> (model == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;        width = overrideWidth;        height = overrideHeight;      &#125;      <span class="hljs-keyword">int</span> logLevel = getFallbackDrawable() == <span class="hljs-keyword">null</span> ? Log.WARN : Log.DEBUG;      <span class="hljs-comment">//返回加载失败</span>      onLoadFailed(<span class="hljs-keyword">new</span> GlideException(<span class="hljs-string">"Received null model"</span>), logLevel);      <span class="hljs-keyword">return</span>;    &#125;        <span class="hljs-keyword">if</span> (status == Status.RUNNING) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot restart a running request"</span>);    &#125;    <span class="hljs-comment">//加载完成</span>    <span class="hljs-keyword">if</span> (status == Status.COMPLETE) &#123;      onResourceReady(resource, DataSource.MEMORY_CACHE);      <span class="hljs-keyword">return</span>;    &#125;        status = Status.WAITING_FOR_SIZE;    <span class="hljs-comment">//判断设置大小是否合理</span>    <span class="hljs-keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;      onSizeReady(overrideWidth, overrideHeight);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//不合理 获取ImageView的size</span>      target.getSize(<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)        &amp;&amp; canNotifyStatusChanged()) &#123;      <span class="hljs-comment">//回调Target onLoadStarted()</span>      target.onLoadStarted(getPlaceholderDrawable());    &#125;    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;      logV(<span class="hljs-string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));    &#125;  &#125;<span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSizeReady</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;    stateVerifier.throwIfRecycled();    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;      logV(<span class="hljs-string">"Got onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));    &#125;    <span class="hljs-keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//更新请求状态为 请求中</span>    status = Status.RUNNING;    <span class="hljs-keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();    <span class="hljs-keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);    <span class="hljs-keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;      logV(<span class="hljs-string">"finished setup for calling load in "</span> + LogTime.getElapsedMillis(startTime));    &#125;    <span class="hljs-comment">//开始加载图片</span>    loadStatus = engine.load(...);    <span class="hljs-keyword">if</span> (status != Status.RUNNING) &#123;      loadStatus = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;      logV(<span class="hljs-string">"finished onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));    &#125;  &#125;</code></pre><p>上述流程主要是去计算得到 被加载图片的尺寸信息，如果手动设置了尺寸通过<code>override</code>那么通过合法性校验后，加载的图片大小就会为用户设置尺寸，否则使用<code>Target</code>的尺寸信息。</p><blockquote><p><code>Target</code>是一个接口，主要意义是提供View的确切尺寸信息以及对回调结果进行处理。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide发送请求.png" srcset="/img/loading.gif" class="full-image" alt="Glide发送请求" title="Glide发送请求"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h4><p>接下来调用<code>Engine.load()</code>开始加载图片，包括三级缓存的部分。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; <span class="hljs-function">LoadStatus <span class="hljs-title">load</span><span class="hljs-params">(...)</span> </span>&#123;    <span class="hljs-keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="hljs-number">0</span>;    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,        resourceClass, transcodeClass, options);    <span class="hljs-comment">//读取内存中的弱引用</span>    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);    <span class="hljs-keyword">if</span> (active != <span class="hljs-keyword">null</span>) &#123;      cb.onResourceReady(active, DataSource.MEMORY_CACHE);      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;        logWithTimeAndKey(<span class="hljs-string">"Loaded resource from active resources"</span>, startTime, key);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//读取内存缓存</span>    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);    <span class="hljs-keyword">if</span> (cached != <span class="hljs-keyword">null</span>) &#123;      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;        logWithTimeAndKey(<span class="hljs-string">"Loaded resource from cache"</span>, startTime, key);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;        EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);    <span class="hljs-keyword">if</span> (current != <span class="hljs-keyword">null</span>) &#123;      current.addCallback(cb, callbackExecutor);      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;        logWithTimeAndKey(<span class="hljs-string">"Added to existing load"</span>, startTime, key);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadStatus(cb, current);    &#125;    EngineJob&lt;R&gt; engineJob =        engineJobFactory.build(            key,            isMemoryCacheable,            useUnlimitedSourceExecutorPool,            useAnimationPool,            onlyRetrieveFromCache);    DecodeJob&lt;R&gt; decodeJob =        decodeJobFactory.build(...);    jobs.put(key, engineJob);    engineJob.addCallback(cb, callbackExecutor);    <span class="hljs-comment">//若从两级内存缓存中 都没有找到 则开启DecodeJob去加载图片</span>    engineJob.start(decodeJob);    <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;      logWithTimeAndKey(<span class="hljs-string">"Started new load"</span>, startTime, key);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadStatus(cb, engineJob);  &#125;</code></pre><p>在<code>Engine.load()</code>，主要执行逻辑是：先从<code>一级内存缓存-弱引用</code>中查找指定资源，找不到则去<code>二级内存缓存-LRUCache</code>中去查找，再没有就转到<code>DecodeJob</code>去加载图片。</p><p>加载图片的具体实现细节会单独在<a href="#Glide缓存实现原理">Glide缓存实现原理</a>说明。</p><h4 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h4><p>当图片从三级缓存中取出后，最终得到的是一个<code>Resource</code>对象，然后再回调到<code>SingleRequest.onResourceReady()</code>中</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReady</span><span class="hljs-params">(Resource&lt;?&gt; resource, DataSource dataSource)</span> </span>&#123;  stateVerifier.throwIfRecycled();  loadStatus = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">if</span> (resource == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">//回调加载失败事件</span>    onLoadFailed(exception);    <span class="hljs-keyword">return</span>;  &#125;  Object received = resource.get();  <span class="hljs-keyword">if</span> (received == <span class="hljs-keyword">null</span> || !transcodeClass.isAssignableFrom(received.getClass())) &#123;    <span class="hljs-comment">//回收资源</span>    releaseResource(resource);    onLoadFailed(exception);    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">if</span> (!canSetResource()) &#123;    releaseResource(resource);    <span class="hljs-comment">// 设置加载状态完成</span>    status = Status.COMPLETE;    <span class="hljs-keyword">return</span>;  &#125;  onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReady</span><span class="hljs-params">(Resource&lt;R&gt; resource, R result, DataSource dataSource)</span> </span>&#123;  <span class="hljs-comment">// We must call isFirstReadyResource before setting status.</span>  <span class="hljs-keyword">boolean</span> isFirstResource = isFirstReadyResource();  status = Status.COMPLETE;  <span class="hljs-keyword">this</span>.resource = resource;  <span class="hljs-keyword">if</span> (glideContext.getLogLevel() &lt;= Log.DEBUG) &#123;    Log.d(GLIDE_TAG, <span class="hljs-string">"Finished loading "</span> + result.getClass().getSimpleName() + <span class="hljs-string">" from "</span>        + dataSource + <span class="hljs-string">" for "</span> + model + <span class="hljs-string">" with size ["</span> + width + <span class="hljs-string">"x"</span> + height + <span class="hljs-string">"] in "</span>        + LogTime.getElapsedMillis(startTime) + <span class="hljs-string">" ms"</span>);  &#125;  isCallingCallbacks = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">boolean</span> anyListenerHandledUpdatingTarget = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (requestListeners != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">for</span> (RequestListener&lt;R&gt; listener : requestListeners) &#123;        anyListenerHandledUpdatingTarget |=            listener.onResourceReady(result, model, target, dataSource, isFirstResource);      &#125;    &#125;    anyListenerHandledUpdatingTarget |=        targetListener != <span class="hljs-keyword">null</span>            &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);    <span class="hljs-keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;      Transition&lt;? <span class="hljs-keyword">super</span> R&gt; animation =          animationFactory.build(dataSource, isFirstResource);      target.onResourceReady(result, animation);    &#125;  &#125; <span class="hljs-keyword">finally</span> &#123;    isCallingCallbacks = <span class="hljs-keyword">false</span>;  &#125;    notifyLoadSuccess();&#125;</code></pre><p>在<code>SingleRequest.onSourceReady()</code>主要回调了<code>Target.onResourceReady()</code>，把<code>Resource</code>显示到<code>Target</code>上，实质就是<code>into()</code>传入的Target对象。</p><pre><code class="hljs java"> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReady</span><span class="hljs-params">(@NonNull Z resource, @Nullable Transition&lt;? <span class="hljs-keyword">super</span> Z&gt; transition)</span> </span>&#123;   <span class="hljs-keyword">if</span> (transition == <span class="hljs-keyword">null</span> || !transition.transition(resource, <span class="hljs-keyword">this</span>)) &#123;     setResourceInternal(resource);   &#125; <span class="hljs-keyword">else</span> &#123;     maybeUpdateAnimatable(resource);   &#125; &#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResourceInternal</span><span class="hljs-params">(@Nullable Z resource)</span> </span>&#123;   <span class="hljs-comment">// Order matters here. Set the resource first to make sure that the Drawable has a valid and</span>   <span class="hljs-comment">// non-null Callback before starting it.</span>   setResource(resource);   maybeUpdateAnimatable(resource); &#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResource</span><span class="hljs-params">(@Nullable Z resource)</span></span>;</code></pre><p>其中有两个类继承了<code>ImageViewTarget</code>用于实现不同的功能。分别是<code>DrawableImageViewTarget</code>、<code>BitmapImageViewTarget</code>。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawableImageViewTarget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImageViewTarget</span>&lt;<span class="hljs-title">Drawable</span>&gt; </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DrawableImageViewTarget</span><span class="hljs-params">(ImageView view)</span> </span>&#123;    <span class="hljs-keyword">super</span>(view);  &#125;  <span class="hljs-comment">/**   * <span class="hljs-doctag">@deprecated</span> Use &#123;<span class="hljs-doctag">@link</span> #waitForLayout()&#125; instead.   */</span>  <span class="hljs-comment">// Public API.</span>  <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"unused"</span>, <span class="hljs-string">"deprecation"</span>&#125;)  <span class="hljs-meta">@Deprecated</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DrawableImageViewTarget</span><span class="hljs-params">(ImageView view, <span class="hljs-keyword">boolean</span> waitForLayout)</span> </span>&#123;    <span class="hljs-keyword">super</span>(view, waitForLayout);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResource</span><span class="hljs-params">(@Nullable Drawable resource)</span> </span>&#123;    view.setImageDrawable(resource);  &#125;&#125;</code></pre><p>最终通过<code>ImageView.setImageDrawable()</code>将图片显示在ImageView上。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide显示图片.png" srcset="/img/loading.gif" class="full-image" alt="Glide显示图片" title="Glide显示图片"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="Glide缓存实现原理"><a href="#Glide缓存实现原理" class="headerlink" title="Glide缓存实现原理"></a>Glide缓存实现原理</h2><blockquote><p>Glide的缓存主要分成了两个模块，一个是<strong>内存缓存</strong>，另一部分是<strong>硬盘缓存</strong>。</p><p><strong>内存缓存</strong>：防止应用重复将图片数据读取到内存当中</p><p><strong>硬盘缓存</strong>：防止应用重复从网络或其他地方重复下载和读取数据</p></blockquote><h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><p>1.在自定义的<code>GlideModule</code>中的<code>applyOptions()</code>中设置具体的缓存参数</p><pre><code class="hljs java"><span class="hljs-meta">@GlideModule</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomGlideModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppGlideModule</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyOptions</span><span class="hljs-params">(Context context, GlideBuilder builder)</span> </span>&#123;        MemorySizeCalculator calculator = <span class="hljs-keyword">new</span> MemorySizeCalculator.Builder(context).build();        <span class="hljs-keyword">int</span> defaultMemoryCacheSize = calculator.getMemoryCacheSize();        <span class="hljs-keyword">int</span> defaultBitmapPoolSize = calculator.getBitmapPoolSize();        <span class="hljs-keyword">int</span> customMemoryCacheSize = (<span class="hljs-keyword">int</span>) (<span class="hljs-number">1.2</span> * defaultMemoryCacheSize);        <span class="hljs-keyword">int</span> customBitmapPoolSize = (<span class="hljs-keyword">int</span>) (<span class="hljs-number">1.2</span> * defaultBitmapPoolSize);        builder.setMemoryCache(<span class="hljs-keyword">new</span> LruResourceCache(customMemoryCacheSize));        builder.setBitmapPool(<span class="hljs-keyword">new</span> LruBitmapPool(customBitmapPoolSize));    &#125;&#125;</code></pre><p>2.在具体请求中设置缓存参数</p><pre><code class="hljs java"><span class="hljs-comment">//设置 不在磁盘中进行缓存且内存中也不缓存</span>val requestBuilder =Glide.with(<span class="hljs-keyword">this</span>).asBitmap().apply(RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(<span class="hljs-keyword">true</span>)).load(path)</code></pre><h3 id="缓存Key"><a href="#缓存Key" class="headerlink" title="缓存Key"></a>缓存Key</h3><p>缓存功能，就需要有对应的缓存Key，应用可以根据这个Key找到对应的缓存文件。Glide的缓存Key生成代码如下</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; <span class="hljs-function">LoadStatus <span class="hljs-title">load</span><span class="hljs-params">(...）&#123;      EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,resourceClass, transcodeClass, options)</span></span>;...&#125;</code></pre><p><code>model</code>对应的就是<code>load()</code>过程中传入的参数，例如传入<code>String(图片加载地址)</code>，那么对应的就是加载地址。决定生成Key的参数有很多。</p><p>如果设置了<code>override</code>修改了加载尺寸，那也会有不同的key生成。</p><h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>默认情况下，内存缓存是自动开启的，加载图片完成后，就会默认在内存中缓存，然后下次再调用时就会从内存中直接读取显示，无需重新加载。</p><blockquote><p>可以通过设置<code>skipMemoryCache(true)</code>来关闭内存缓存功能。</p></blockquote><p>Glide中的内存缓存主要分为两部分处理：<strong>弱引用复用机制</strong>和<strong>LRUCache</strong>。</p><h4 id="弱引用复用-——-ActiveResources"><a href="#弱引用复用-——-ActiveResources" class="headerlink" title="弱引用复用 —— ActiveResources"></a>弱引用复用 —— ActiveResources</h4><blockquote><p>从正在活动的资源中取出缓存进行复用</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; <span class="hljs-function">LoadStatus <span class="hljs-title">load</span><span class="hljs-params">(...)</span></span>&#123;  ...    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);    <span class="hljs-keyword">if</span> (active != <span class="hljs-keyword">null</span>) &#123;      cb.onResourceReady(active, DataSource.MEMORY_CACHE);      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;        logWithTimeAndKey(<span class="hljs-string">"Loaded resource from active resources"</span>, startTime, key);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;  ...&#125;  <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class="hljs-keyword">boolean</span> isMemoryCacheable) &#123;    <span class="hljs-keyword">if</span> (!isMemoryCacheable) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    EngineResource&lt;?&gt; active = activeResources.get(key);    <span class="hljs-keyword">if</span> (active != <span class="hljs-keyword">null</span>) &#123;      active.acquire();    &#125;    <span class="hljs-keyword">return</span> active;  &#125;</code></pre><p>对应的Resource文件要从<code>ActiveResource</code>中获取</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();  <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deactivate</span><span class="hljs-params">(Key key)</span> </span>&#123;    ResourceWeakReference removed = activeEngineResources.remove(key);    <span class="hljs-keyword">if</span> (removed != <span class="hljs-keyword">null</span>) &#123;      removed.reset();    &#125;  &#125;<span class="hljs-meta">@Nullable</span>  <span class="hljs-keyword">synchronized</span> EngineResource&lt;?&gt; get(Key key) &#123;    <span class="hljs-comment">//获取Key对应的弱引用对象</span>    ResourceWeakReference activeRef = activeEngineResources.get(key);    <span class="hljs-keyword">if</span> (activeRef == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    EngineResource&lt;?&gt; active = activeRef.get();    <span class="hljs-keyword">if</span> (active == <span class="hljs-keyword">null</span>) &#123;      cleanupActiveReference(activeRef);    &#125;    <span class="hljs-keyword">return</span> active;  &#125;  <span class="hljs-comment">//清除当前被GC的对象</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanupActiveReference</span><span class="hljs-params">(@NonNull ResourceWeakReference ref)</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (listener) &#123;      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;        activeEngineResources.remove(ref.key);        <span class="hljs-keyword">if</span> (!ref.isCacheable || ref.resource == <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//创建新的Resource对象 ref.resource是强引用类型</span>        EngineResource&lt;?&gt; newResource =            <span class="hljs-keyword">new</span> EngineResource&lt;&gt;(ref.resource, <span class="hljs-comment">/*isCacheable=*/</span> <span class="hljs-keyword">true</span>, <span class="hljs-comment">/*isRecyclable=*/</span> <span class="hljs-keyword">false</span>);        newResource.setResourceListener(ref.key, listener);        <span class="hljs-comment">//将ref缓存进内存中</span>        listener.onResourceReleased(ref.key, newResource);      &#125;    &#125;  &#125; <span class="hljs-meta">@VisibleForTesting</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceWeakReference</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">EngineResource</span>&lt;?&gt;&gt; </span>&#123;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"WeakerAccess"</span>) <span class="hljs-meta">@Synthetic</span> <span class="hljs-keyword">final</span> Key key;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"WeakerAccess"</span>) <span class="hljs-meta">@Synthetic</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isCacheable;    <span class="hljs-meta">@Nullable</span> <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"WeakerAccess"</span>) <span class="hljs-meta">@Synthetic</span> Resource&lt;?&gt; resource;    <span class="hljs-meta">@Synthetic</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"WeakerAccess"</span>)    ResourceWeakReference(        <span class="hljs-meta">@NonNull</span> Key key,        <span class="hljs-meta">@NonNull</span> EngineResource&lt;?&gt; referent,        <span class="hljs-meta">@NonNull</span> ReferenceQueue&lt;? <span class="hljs-keyword">super</span> EngineResource&lt;?&gt;&gt; queue,        <span class="hljs-keyword">boolean</span> isActiveResourceRetentionAllowed) &#123;      <span class="hljs-keyword">super</span>(referent, queue);      <span class="hljs-keyword">this</span>.key = Preconditions.checkNotNull(key);      <span class="hljs-keyword">this</span>.resource =          referent.isCacheable() &amp;&amp; isActiveResourceRetentionAllowed              ? Preconditions.checkNotNull(referent.getResource()) : <span class="hljs-keyword">null</span>;      isCacheable = referent.isCacheable();    &#125;    <span class="hljs-comment">//清除强引用部分，方便回收</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;      resource = <span class="hljs-keyword">null</span>;      clear();    &#125;  &#125;</code></pre><p><code>listener</code>对应的就是<code>Engine</code>对象，调用到<code>Engine.onResourceReleased()</code></p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReleased</span><span class="hljs-params">(Key cacheKey, EngineResource&lt;?&gt; resource)</span> </span>&#123;     <span class="hljs-comment">//清除该key的强引用</span>  activeResources.deactivate(cacheKey);  <span class="hljs-keyword">if</span> (resource.isCacheable()) &#123;    <span class="hljs-comment">//缓存数据到内存缓存LRUCache中</span>    cache.put(cacheKey, resource);  &#125; <span class="hljs-keyword">else</span> &#123;    resourceRecycler.recycle(resource);  &#125;&#125;</code></pre><p><code>ActivieResources</code>采用<code>HashMap + WeakReference</code>来保存<code>EngineResource</code>，不会有上限。然后<code>get()</code>从<code>activeEngineResources</code>弱引用HashMap中获取数据，这里分为两种情况：</p><ol><li>获取到弱引用关联对象<code>EngineResource</code>，则直接返回结果</li><li>获取不到关联对象，则需进行清除工作调用<code>cleanupActiveResource()</code>，在<code>activeEngineResources</code>移除对应的key和引用，在判断是否开启缓存，若开启则缓存至<code>LRUCache</code>中。</li></ol><p>总结：</p><p><code>ActiveResources</code>采用弱引用的方式，里面存储的是<code>EngineResource</code>，同时采用强引用保存<code>EngineResource.resource</code>，在<code>ActiveResources</code>中还会有一个清理线程在运行，负责当<code>EngineResource</code>被回收时，就去取出对应的<code>EngineResource.resource</code>，然后创建一个新的<code>EngineResource</code>对象，回调到<code>Engine.onResourceReleased()</code>中，在其中做内存缓存，之后调用<code>ActivityResources.deactivate()</code>移除对应的强引用。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/内存缓存-弱引用机制.png" srcset="/img/loading.gif" class="full-image" alt="内存缓存-弱引用机制" title="内存缓存-弱引用机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h4><blockquote><p>在当前活动资源中没有对应的缓存时，就要从内存中去进行读取</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; <span class="hljs-function">LoadStatus <span class="hljs-title">load</span><span class="hljs-params">(...)</span></span>&#123;  ...    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);    <span class="hljs-keyword">if</span> (cached != <span class="hljs-keyword">null</span>) &#123;      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;        logWithTimeAndKey(<span class="hljs-string">"Loaded resource from cache"</span>, startTime, key);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;  <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class="hljs-keyword">boolean</span> isMemoryCacheable) &#123;    <span class="hljs-comment">//不允许缓存 直接返回null</span>    <span class="hljs-keyword">if</span> (!isMemoryCacheable) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);①    <span class="hljs-keyword">if</span> (cached != <span class="hljs-keyword">null</span>) &#123;      cached.acquire();      <span class="hljs-comment">//存入活动资源中</span>      activeResources.activate(key, cached);②    &#125;    <span class="hljs-keyword">return</span> cached;  &#125;  <span class="hljs-keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;    Resource&lt;?&gt; cached = cache.remove(key);③    <span class="hljs-keyword">final</span> EngineResource&lt;?&gt; result;    <span class="hljs-keyword">if</span> (cached == <span class="hljs-keyword">null</span>) &#123;      result = <span class="hljs-keyword">null</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cached <span class="hljs-keyword">instanceof</span> EngineResource) &#123;      result = (EngineResource&lt;?&gt;) cached;    &#125; <span class="hljs-keyword">else</span> &#123;      result = <span class="hljs-keyword">new</span> EngineResource&lt;&gt;(cached, <span class="hljs-keyword">true</span> <span class="hljs-comment">/*isMemoryCacheable*/</span>, <span class="hljs-keyword">true</span> <span class="hljs-comment">/*isRecyclable*/</span>);    &#125;    <span class="hljs-keyword">return</span> result;  &#125;</code></pre><p><code>loadFromCache()</code>实际调用到<code>getEngineResourceFromCache()</code>获取内存缓存中的资源，如果找到，缓存数量+1，然后会把<code>cached</code>放入<code>ActiveResources</code>中，变为活动资源，对应的要在<code>内存缓存</code>中移除引用。</p><p>①<code>getEngineResourceFromCache(key)</code>：从内存缓存中根据缓存key获取缓存</p><p>②<code>activeResources.activate(key, cached)</code>：取出的缓存数据存入到活动资源中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">activate</span><span class="hljs-params">(Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;  <span class="hljs-comment">//构件新的 弱引用对象</span>  ResourceWeakReference toPut =      <span class="hljs-keyword">new</span> ResourceWeakReference(          key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);    ResourceWeakReference removed = activeEngineResources.put(key, toPut);  <span class="hljs-comment">//如果存在替换，也需要把旧数据回收</span>  <span class="hljs-keyword">if</span> (removed != <span class="hljs-keyword">null</span>) &#123;    removed.reset();  &#125;&#125;</code></pre><p>③<code>cache.remove(key)</code>：从内存缓存中移除对应缓存</p><p><code>cache</code>对应的是<code>MemoryCache</code>是一个接口，实现类为<code>LruResourceCache</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LruResourceCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LruCache</span>&lt;<span class="hljs-title">Key</span>, <span class="hljs-title">Resource</span>&lt;?&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">MemoryCache</span> </span>&#123;  <span class="hljs-keyword">private</span> ResourceRemovedListener listener;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LruResourceCache</span><span class="hljs-params">(<span class="hljs-keyword">long</span> size)</span> </span>&#123;    <span class="hljs-keyword">super</span>(size);  &#125;  <span class="hljs-comment">//监听资源移除</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResourceRemovedListener</span><span class="hljs-params">(@NonNull ResourceRemovedListener listener)</span> </span>&#123;    <span class="hljs-keyword">this</span>.listener = listener;  &#125;  <span class="hljs-comment">//当前缓存被淘汰是调用</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemEvicted</span><span class="hljs-params">(@NonNull Key key, @Nullable Resource&lt;?&gt; item)</span> </span>&#123;    <span class="hljs-keyword">if</span> (listener != <span class="hljs-keyword">null</span> &amp;&amp; item != <span class="hljs-keyword">null</span>) &#123;      listener.onResourceRemoved(item);    &#125;  &#125;  <span class="hljs-comment">//获取当前缓存大小</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(@Nullable Resource&lt;?&gt; item)</span> </span>&#123;    <span class="hljs-keyword">if</span> (item == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getSize(<span class="hljs-keyword">null</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> item.getSize();    &#125;  &#125;  <span class="hljs-meta">@SuppressLint</span>(<span class="hljs-string">"InlinedApi"</span>)  <span class="hljs-meta">@Override</span>  <span class="hljs-comment">//内存不足时 触发</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimMemory</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level)</span> </span>&#123;    <span class="hljs-keyword">if</span> (level &gt;= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) &#123;      clearMemory();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level &gt;= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) &#123;      trimToSize(getMaxSize() / <span class="hljs-number">2</span>);    &#125;  &#125;&#125;</code></pre><p><code>LruResourceCache</code>继承自<code>LruCache</code>，不过内部计算缓存大小是通过<code>Resource</code>对象的大小累计，还增加了资源移除监听，为了和<code>ActiveResources</code>进行联动。</p><p><code>LruResourceCache</code>的<code>size</code>是在自定义<code>GlideModule</code>中的 <code>applyOptions()</code>时设置进来的，如果未设置会采用<code>MemorySizeCalculator.getMemoryCacheSize()</code>设置。</p><p>当前在内存中缓存的对象都是<code>Resource</code>，而不是通常认为的Bitmap，下面会介绍到转码的过程。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/内存缓存-LruCache.png" srcset="/img/loading.gif" class="full-image" alt="内存缓存-LruCache" title="内存缓存-LruCache"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在<code>内存缓存</code>中，分为两种方案：<strong>从弱引用中获取</strong>、<strong>从内存缓存中获取</strong>。两者的关系简单概括就是：</p><blockquote><p>读取内存缓存时，会优先从<code>ActiveResources</code>中读取，读取到的话，需要判断当前包装<code>Resource</code>的弱引用对象是否被回收，未回收则直接返回。被回收的话，需要重新包装<code>EngineResource.resource</code>然后存入到内存缓存中并需要移除<code>ActiveResources</code>对其的引用。</p><p>从<code>ActiveResources</code>中没有获取到对应缓存时，就从<code>LruResourceCache</code>中去获取，获取到的话，就需要从当前内存缓存中移除对应缓存引用，并存入到<code>ActiveResources</code>中。</p><p><strong>实现了正在使用的图片通过弱引用进行缓存，未使用的图片通过LruCache进行缓存。</strong></p><p><code>ActiveResources</code>优先级高于<code>LruResourceCache</code>。</p></blockquote><p>比较两者之间的区别：</p><table><thead><tr><th></th><th>弱引用获取</th><th>内存缓存获取</th></tr></thead><tbody><tr><td>基础实现</td><td>HashMap</td><td>LinkedHashMap(<em>LruCache</em>)</td></tr><tr><td>可否禁用</td><td>用户无法禁用</td><td>通过<code>skipMemoryCache(true)</code>禁用</td></tr><tr><td>运行位置</td><td>内存</td><td>内存</td></tr><tr><td>释放时机</td><td>依赖垃圾回收机制<br><strong>弱引用实现，GC时被回收</strong></td><td>采用<strong>最近最少使用</strong>来淘汰数据</td></tr></tbody></table><h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><blockquote><p>当内存中不存在缓存时，就会向下从硬盘中去读取缓存数据</p><p>通过设置<code>diskCacheStrategy(DiskCacheStrategy.NONE)</code>来关闭硬盘缓存功能。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> &lt;R&gt; <span class="hljs-function">LoadStatus <span class="hljs-title">load</span><span class="hljs-params">(...)</span></span>&#123;  ...    <span class="hljs-comment">//判断当前是否存在该任务 EngineJob</span>    <span class="hljs-comment">// private final Map&lt;Key, EngineJob&lt;?&gt;&gt; jobs = new HashMap&lt;&gt;();</span>    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);    <span class="hljs-keyword">if</span> (current != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">//资源加载完毕通知回调</span>      current.addCallback(cb, callbackExecutor);      <span class="hljs-keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;        logWithTimeAndKey(<span class="hljs-string">"Added to existing load"</span>, startTime, key);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LoadStatus(cb, current);    &#125;    <span class="hljs-comment">//内部维护线程池，用来管理资源加载</span>    EngineJob&lt;R&gt; engineJob =        engineJobFactory.build(...);    <span class="hljs-comment">//用来进行资源加载</span>    DecodeJob&lt;R&gt; decodeJob =        decodeJobFactory.build(... , engineJob);    <span class="hljs-comment">//插入任务列表中</span>    jobs.put(key, engineJob);    engineJob.addCallback(cb, callbackExecutor);    <span class="hljs-comment">//开始进行加载</span>    engineJob.start(decodeJob);&#125;</code></pre><p>从内存中读取不到缓存时，<code>Engine</code>尝试从<code>jobs</code>读取对应的<code>EngineJob</code>缓存，如存在就去回调<code>加载成功或加载失败</code>。不存在的话，就需要新建一个<code>EngineJob</code>以及<code>DecodeJob</code>去加载图片。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;  <span class="hljs-keyword">this</span>.decodeJob = decodeJob;  GlideExecutor executor = decodeJob.willDecodeFromCache()      ? diskCacheExecutor      : getActiveSourceExecutor();  executor.execute(decodeJob);&#125;</code></pre><p>通过线程池去执行<code>decodeJob</code>，<code>DecodeJob</code>实现了<code>Runnable</code>接口，<code>execute()</code>直接调用到<code>run()</code></p><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"PMD.AvoidRethrowingException"</span>) <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//统计执行时长</span>   GlideTrace.beginSectionFormat(<span class="hljs-string">"DecodeJob#run(model=%s)"</span>, model);   DataFetcher&lt;?&gt; localFetcher = currentFetcher;   <span class="hljs-keyword">try</span> &#123;     <span class="hljs-keyword">if</span> (isCancelled) &#123;       notifyFailed();       <span class="hljs-keyword">return</span>;     &#125;     <span class="hljs-comment">//实际执行逻辑</span>     runWrapped();   &#125; <span class="hljs-keyword">catch</span> (CallbackException e) &#123;     <span class="hljs-keyword">throw</span> e;   &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;     <span class="hljs-keyword">if</span> (stage != Stage.ENCODE) &#123;       throwables.add(t);       notifyFailed();     &#125;     <span class="hljs-keyword">if</span> (!isCancelled) &#123;       <span class="hljs-keyword">throw</span> t;     &#125;     <span class="hljs-keyword">throw</span> t;   &#125; <span class="hljs-keyword">finally</span> &#123;     <span class="hljs-comment">// Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call</span>     <span class="hljs-comment">// close in all cases anyway.</span>     <span class="hljs-keyword">if</span> (localFetcher != <span class="hljs-keyword">null</span>) &#123;       localFetcher.cleanup();     &#125;     GlideTrace.endSection();   &#125; &#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWrapped</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">switch</span> (runReason) &#123;     <span class="hljs-keyword">case</span> INITIALIZE:       stage = getNextStage(Stage.INITIALIZE);       currentGenerator = getNextGenerator();       runGenerators();       <span class="hljs-keyword">break</span>;     <span class="hljs-keyword">case</span> SWITCH_TO_SOURCE_SERVICE:       runGenerators();       <span class="hljs-keyword">break</span>;     <span class="hljs-keyword">case</span> DECODE_DATA:       <span class="hljs-comment">//解析数据并解码</span>       decodeFromRetrievedData();       <span class="hljs-keyword">break</span>;     <span class="hljs-keyword">default</span>:       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unrecognized run reason: "</span> + runReason);   &#125; &#125; <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> RunReason &#123;   <span class="hljs-comment">//第一次执行</span>   INITIALIZE,   <span class="hljs-comment">//从Cache中去读取数据失败，则从其他渠道读取</span>   SWITCH_TO_SOURCE_SERVICE,   <span class="hljs-comment">//解析数据</span>   DECODE_DATA, &#125;</code></pre><p>调用<code>DecodeJob.run()</code>开始加载资源，内部调用<code>runWrapped()</code>，此时<code>runWrapped()</code>中会根据<code>runReason</code>执行不同的操作，<code>runReason</code>就是用于控制当前执行到的任务。</p><blockquote><p><code>INITIALIZE</code>：第一次调用<code>run()</code>，执行目的是从<code>diskcache</code>中获取缓存</p><p><code>SWITCH_TO_SOURCE_SERVICE</code>：从<code>diskcache</code>中获取缓存失败，需要从数据源获取</p><p><code>DECODE_DATA</code>：缓存数据成功，对数据进行解析</p></blockquote><h4 id="获取硬盘缓存数据"><a href="#获取硬盘缓存数据" class="headerlink" title="获取硬盘缓存数据"></a>获取硬盘缓存数据</h4><pre><code class="hljs java"><span class="hljs-comment">//通过 RequestOptions.diskCacheStrategy() 设置</span><span class="hljs-keyword">private</span> DiskCacheStrategy diskCacheStrategy;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runGenerators</span><span class="hljs-params">()</span> </span>&#123;    currentThread = Thread.currentThread();    startFetchTime = LogTime.getLogTime();    <span class="hljs-keyword">boolean</span> isStarted = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">while</span> (!isCancelled &amp;&amp; currentGenerator != <span class="hljs-keyword">null</span>        &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;      stage = getNextStage(stage);      currentGenerator = getNextGenerator();      <span class="hljs-keyword">if</span> (stage == Stage.SOURCE) &#123;        reschedule();        <span class="hljs-keyword">return</span>;      &#125;    &#125;    <span class="hljs-comment">// We've run out of stages and generators, give up.</span>    <span class="hljs-keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;      notifyFailed();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> Stage <span class="hljs-title">getNextStage</span><span class="hljs-params">(Stage current)</span> </span>&#123;    <span class="hljs-keyword">switch</span> (current) &#123;      <span class="hljs-keyword">case</span> INITIALIZE:        <span class="hljs-comment">//支持转换后的图片缓存 返回状态就是RESOURCE_CACHE</span>        <span class="hljs-keyword">return</span> diskCacheStrategy.decodeCachedResource()            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);      <span class="hljs-keyword">case</span> RESOURCE_CACHE:        <span class="hljs-comment">//支持转换后的图片缓存 返回状态就是DATA_CACHE</span>        <span class="hljs-keyword">return</span> diskCacheStrategy.decodeCachedData()            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);      <span class="hljs-keyword">case</span> DATA_CACHE:        <span class="hljs-comment">//如果缓存已存在 就返回结束 否则去加载远程图片</span>        <span class="hljs-keyword">return</span> onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;      <span class="hljs-keyword">case</span> SOURCE:      <span class="hljs-keyword">case</span> FINISHED:        <span class="hljs-keyword">return</span> Stage.FINISHED;      <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unrecognized stage: "</span> + current);    &#125;  &#125;  <span class="hljs-comment">//根据不同的步骤 调用不同的Generator对象</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> DataFetcherGenerator <span class="hljs-title">getNextGenerator</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">switch</span> (stage) &#123;      <span class="hljs-keyword">case</span> RESOURCE_CACHE:        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="hljs-keyword">this</span>);      <span class="hljs-keyword">case</span> DATA_CACHE:        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataCacheGenerator(decodeHelper, <span class="hljs-keyword">this</span>);      <span class="hljs-keyword">case</span> SOURCE:        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SourceGenerator(decodeHelper, <span class="hljs-keyword">this</span>);      <span class="hljs-keyword">case</span> FINISHED:        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unrecognized stage: "</span> + stage);    &#125;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> Stage &#123;    <span class="hljs-comment">//加载初始状态</span>    INITIALIZE,    <span class="hljs-comment">//转换后图片的缓存</span>    RESOURCE_CACHE,    <span class="hljs-comment">//原图缓存</span>    DATA_CACHE,    <span class="hljs-comment">//远程图片</span>    SOURCE,    <span class="hljs-comment">//解析图片</span>    ENCODE,    <span class="hljs-comment">//加载完成</span>    FINISHED,  &#125;</code></pre><p><code>stage</code>对应<code>Stage</code>枚举类，可以通过<code>DiskCacheStrategy</code>得到<code>Stage</code>。</p><blockquote><p><code>DiskCacheStrategy</code>参数解释：</p><ul><li><code>NONE</code>：表示不缓存任何内容</li><li><code>DATA</code>：只缓存原始图片</li><li><code>RESOURCE</code>：只缓存转换后的图片</li><li><code>ALL</code>：原始图片和转换后的图片都进行缓存</li><li><code>AUTOMATIC</code>：尝试选择最佳策略。针对加载数据类型进行区分：<ul><li>加载本地图片：缓存原始图片</li><li>加载网络图片：缓存转换后的图片</li></ul></li></ul></blockquote><p><code>stage</code>默认尽量就是<code>INITIALIZE</code>，通过递归调用<code>getNextStage()</code>向下推进，并改变<code>stage</code>表示进行状态。<code>stage</code>的推进过程也表示了硬盘缓存的查找顺序。</p><table><thead><tr><th>Stage</th><th>描述</th></tr></thead><tbody><tr><td>INITIALIZE</td><td>初始状态</td></tr><tr><td>RESOURCE_CACHE</td><td>转换后缓存 调用<code>ResourceCacheGenerator</code></td></tr><tr><td>DATA_CACHE</td><td>原图缓存 调用<code>DataCacheGenerator</code></td></tr><tr><td>SOURCE</td><td>远程获取图片 调用<code>SourceGenerator</code></td></tr><tr><td>ENCODE</td><td>解析资源，生成<code>Resource</code>对象</td></tr><tr><td>FINISHED</td><td>解析完成</td></tr></tbody></table><p>查找缓存从<code>初始查找开始</code>-&gt;<code>查找转换后图片缓存</code>-&gt;<code>查找原图图片缓存</code>-&gt;<code>前面都没找到就去进行远程加载</code>-&gt;<code>加载完成后就开始解析数据</code>-&gt;<code>解析完成</code>。</p><p>查找缓存从<code>currentGenerator.startNext()</code>开始，就先从<code>ResourceCacheGenerator</code>开始</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> File cacheFile;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startNext</span><span class="hljs-params">()</span> </span>&#123;  List&lt;Key&gt; sourceIds = helper.getCacheKeys();  <span class="hljs-keyword">if</span> (sourceIds.isEmpty()) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  &#125;  List&lt;Class&lt;?&gt;&gt; resourceClasses = helper.getRegisteredResourceClasses();  <span class="hljs-keyword">if</span> (resourceClasses.isEmpty()) &#123;    <span class="hljs-keyword">if</span> (File<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">equals</span>(<span class="hljs-title">helper</span>.<span class="hljs-title">getTranscodeClass</span>())) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(       <span class="hljs-string">"Failed to find any load path from "</span> + helper.getModelClass() + <span class="hljs-string">" to "</span>           + helper.getTranscodeClass());  &#125;  <span class="hljs-keyword">while</span> (modelLoaders == <span class="hljs-keyword">null</span> || !hasNextModelLoader()) &#123;    resourceClassIndex++;    <span class="hljs-keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) &#123;      sourceIdIndex++;      <span class="hljs-keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;      resourceClassIndex = <span class="hljs-number">0</span>;    &#125;    Key sourceId = sourceIds.get(sourceIdIndex);    Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);    Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass);    <span class="hljs-comment">//构建磁盘缓存key</span>    currentKey =        <span class="hljs-keyword">new</span> ResourceCacheKey(<span class="hljs-comment">// NOPMD AvoidInstantiatingObjectsInLoops</span>            helper.getArrayPool(),            sourceId,            helper.getSignature(),            helper.getWidth(),            helper.getHeight(),            transformation,            resourceClass,            helper.getOptions());    <span class="hljs-comment">//根据Key去获取cacheFile</span>    cacheFile = helper.getDiskCache().get(currentKey);    <span class="hljs-keyword">if</span> (cacheFile != <span class="hljs-keyword">null</span>) &#123;      sourceKey = sourceId;      modelLoaders = helper.getModelLoaders(cacheFile);      modelLoaderIndex = <span class="hljs-number">0</span>;    &#125;  &#125;  loadData = <span class="hljs-keyword">null</span>;  <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;    <span class="hljs-comment">//使用FileLoader去加载对应cache文件</span>    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);    loadData = modelLoader.buildLoadData(cacheFile,        helper.getWidth(), helper.getHeight(), helper.getOptions());    <span class="hljs-keyword">if</span> (loadData != <span class="hljs-keyword">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123;      started = <span class="hljs-keyword">true</span>;      loadData.fetcher.loadData(helper.getPriority(), <span class="hljs-keyword">this</span>);    &#125;  &#125;  <span class="hljs-keyword">return</span> started;&#125;</code></pre><p>根据相关参数生成对应的<code>cacheKey</code>，然后从<code>DiskCache</code>中取出对应的<code>cacheFile</code>，然后使用<code>FileLoader</code>解析该文件。</p><blockquote><p><code>helper.getDiskCache()</code>对应的就是<code>DiskLruCacheWrapper</code>类，内部包装了<code>DiskLruCache</code>，内部实现了整套的文件读写功能。</p></blockquote><h4 id="远程获取数据"><a href="#远程获取数据" class="headerlink" title="远程获取数据"></a>远程获取数据</h4><p>若为初次加载的数据，肯定不会在<code>diskCache</code>中获取到，就需要远程加载。</p><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startNext</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//判断当前是否存在缓存</span>    <span class="hljs-keyword">if</span> (dataToCache != <span class="hljs-keyword">null</span>) &#123;      Object data = dataToCache;      dataToCache = <span class="hljs-keyword">null</span>;            cacheData(data);    &#125;    <span class="hljs-comment">//存在缓存</span>    <span class="hljs-keyword">if</span> (sourceCacheGenerator != <span class="hljs-keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    sourceCacheGenerator = <span class="hljs-keyword">null</span>;    loadData = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;      loadData = helper.getLoadData().get(loadDataListIndex++);      <span class="hljs-keyword">if</span> (loadData != <span class="hljs-keyword">null</span> &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;        started = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">//加载远程图片</span>        loadData.fetcher.loadData(helper.getPriority(), <span class="hljs-keyword">this</span>);      &#125;    &#125;    <span class="hljs-keyword">return</span> started;  &#125;<span class="hljs-comment">//缓存至磁盘中</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cacheData</span><span class="hljs-params">(Object dataToCache)</span> </span>&#123;    <span class="hljs-keyword">long</span> startTime = LogTime.getLogTime();    <span class="hljs-keyword">try</span> &#123;      Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);      DataCacheWriter&lt;Object&gt; writer =          <span class="hljs-keyword">new</span> DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());      originalKey = <span class="hljs-keyword">new</span> DataCacheKey(loadData.sourceKey, helper.getSignature());      helper.getDiskCache().put(originalKey, writer);      <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;        Log.v(TAG, <span class="hljs-string">"Finished encoding source to cache"</span>            + <span class="hljs-string">", key: "</span> + originalKey            + <span class="hljs-string">", data: "</span> + dataToCache            + <span class="hljs-string">", encoder: "</span> + encoder            + <span class="hljs-string">", duration: "</span> + LogTime.getElapsedMillis(startTime));      &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;      loadData.fetcher.cleanup();    &#125;    sourceCacheGenerator =        <span class="hljs-keyword">new</span> DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, <span class="hljs-keyword">this</span>);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDataReady</span><span class="hljs-params">(Object data)</span> </span>&#123;    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();    <span class="hljs-keyword">if</span> (data != <span class="hljs-keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;      <span class="hljs-comment">//上面判断是否cache</span>      dataToCache = data;      cb.reschedule();    &#125; <span class="hljs-keyword">else</span> &#123;      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,          loadData.fetcher.getDataSource(), originalKey);    &#125;  &#125;</code></pre><p>在<code>SourceGenerator.startNext()</code>会优先判断数据是否在<code>DiskCache</code>中，若存在调用<code>cacheData()</code>创建<code>DataCacheGenerator</code>调用其<code>startNext()</code>。不存在则循环去获取<code>loadData</code>，通过<code>DecodeHelper.getLoadData()</code>，然后继续执行<code>loadData.fetch.loadData()</code>去加载数据，加载成功后回调到<code>onDataReady()</code>。</p><p>现在开始按步骤分析：</p><h5 id="加载远程数据——地址加载-HttpUrlFetcher"><a href="#加载远程数据——地址加载-HttpUrlFetcher" class="headerlink" title="加载远程数据——地址加载(HttpUrlFetcher)"></a>加载远程数据——地址加载(<code>HttpUrlFetcher</code>)</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">(Priority priority, DataCallback&lt;? <span class="hljs-keyword">super</span> InputStream&gt; callback)</span> </span>&#123;   <span class="hljs-keyword">try</span> &#123;     InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, glideUrl.getHeaders());     callback.onDataReady(result);   &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;     callback.onLoadFailed(e);   &#125; <span class="hljs-keyword">finally</span> &#123;   &#125; &#125;</code></pre><h5 id="加载本地数据——本地文件加载-ByteBufferFetcher"><a href="#加载本地数据——本地文件加载-ByteBufferFetcher" class="headerlink" title="加载本地数据——本地文件加载(ByteBufferFetcher)"></a>加载本地数据——本地文件加载(<code>ByteBufferFetcher</code>)</h5><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteBufferFetcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DataFetcher</span>&lt;<span class="hljs-title">ByteBuffer</span>&gt; </span>&#123;  ...     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">(@NonNull Priority priority,        @NonNull DataCallback&lt;? <span class="hljs-keyword">super</span> ByteBuffer&gt; callback)</span> </span>&#123;      ByteBuffer result;      <span class="hljs-keyword">try</span> &#123;        result = ByteBufferUtil.fromFile(file);      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        <span class="hljs-keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;          Log.d(TAG, <span class="hljs-string">"Failed to obtain ByteBuffer for file"</span>, e);        &#125;        callback.onLoadFailed(e);        <span class="hljs-keyword">return</span>;      &#125;      callback.onDataReady(result);    &#125;&#125;</code></pre><p><code>loadData()</code>成功后，回调到<code>SourceGenerator.onDataReady()</code>中。这时需要判断是否开启了硬盘缓存，如果关闭了直接回调到<code>DecodeJob.onDataFetcherReady()</code>，开启了的话，就继续调用到<code>DecodeJob.reschedule()</code>。</p><pre><code class="hljs jave">@Override public void reschedule() &#123;   runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;   callback.reschedule(this); &#125; @Override public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher,     DataSource dataSource, Key attemptedKey) &#123;   this.currentSourceKey = sourceKey;   this.currentData = data;   this.currentFetcher = fetcher;   this.currentDataSource = dataSource;   this.currentAttemptingKey = attemptedKey;   if (Thread.currentThread() != currentThread) &#123;     //向下执行 数据解析     runReason = RunReason.DECODE_DATA;     //再次调用到 runWrapped() 此时会走向 decodeFromRetrievedData()     callback.reschedule(this);   &#125; else &#123;     GlideTrace.beginSection(&quot;DecodeJob.decodeFromRetrievedData&quot;);     try &#123;       // 解析数据的真正逻辑       decodeFromRetrievedData();     &#125; finally &#123;       GlideTrace.endSection();     &#125;   &#125; &#125;  private void runWrapped() &#123;   switch (runReason) &#123;     case INITIALIZE:       stage = getNextStage(Stage.INITIALIZE);       currentGenerator = getNextGenerator();       runGenerators();       break;     case SWITCH_TO_SOURCE_SERVICE:       runGenerators();       break;     case DECODE_DATA:       //解析数据并解码       decodeFromRetrievedData();       break;     default:       throw new IllegalStateException(&quot;Unrecognized run reason: &quot; + runReason);   &#125; &#125;</code></pre><p>在<code>reschedule()</code>，把<code>runReason</code>设为<code>SWITCH_TO_SOURCE_SERVICE</code>，继续调用到<code>EngineJob.reschedule()</code>，再次执行到<code>DecodeJob.run()</code>不过已经在一个新的线程池中继续执行。</p><p>在<code>onDataFetcherReady()</code>中，会判断当前线程是否相同，不同的话，设置<code>runReason</code>为<code>DECODE_DATA</code>，重新执行<code>EngineJob.reschedule()</code>还会走到<code>run()</code>中，继续执行到<code>decodeFromRetrievedData()</code>，线程相同则直接执行。</p><h4 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h4><blockquote><p>此时拿到的数据类型还是<code>InputStream</code>或者<code>ByteBuffer</code>，需要解析成常用的<code>File</code>或者<code>Bitmap</code>。</p></blockquote><p>此时<code>runReason</code>为<code>DECODE_DATA</code>，调用到<code>decodeFromRetrievedData()</code></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> Object currentData;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decodeFromRetrievedData</span><span class="hljs-params">()</span> </span>&#123;    ...    Resource&lt;R&gt; resource = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;      resource = decodeFromData(currentFetcher, currentData, currentDataSource);    &#125; <span class="hljs-keyword">catch</span> (GlideException e) &#123;      e.setLoggingDetails(currentAttemptingKey, currentDataSource);      throwables.add(e);    &#125;    <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;      notifyEncodeAndRelease(resource, currentDataSource);    &#125; <span class="hljs-keyword">else</span> &#123;      runGenerators();    &#125;  &#125;  <span class="hljs-keyword">private</span> &lt;Data&gt; <span class="hljs-function">Resource&lt;R&gt; <span class="hljs-title">decodeFromData</span><span class="hljs-params">(DataFetcher&lt;?&gt; fetcher, Data data,      DataSource dataSource)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;    <span class="hljs-keyword">try</span> &#123;      ...      Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);      <span class="hljs-keyword">return</span> result;    &#125; <span class="hljs-keyword">finally</span> &#123;      fetcher.cleanup();    &#125;  &#125;  <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)  <span class="hljs-keyword">private</span> &lt;Data&gt; <span class="hljs-function">Resource&lt;R&gt; <span class="hljs-title">decodeFromFetcher</span><span class="hljs-params">(Data data, DataSource dataSource)</span>      <span class="hljs-keyword">throws</span> GlideException </span>&#123;    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());    <span class="hljs-keyword">return</span> runLoadPath(data, dataSource, path);  &#125;  <span class="hljs-keyword">private</span> &lt;Data, ResourceType&gt; <span class="hljs-function">Resource&lt;R&gt; <span class="hljs-title">runLoadPath</span><span class="hljs-params">(Data data, DataSource dataSource,      LoadPath&lt;Data, ResourceType, R&gt; path)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;    Options options = getOptionsWithHardwareConfig(dataSource);    DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data);    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">return</span> path.load(          rewinder, options, width, height, <span class="hljs-keyword">new</span> DecodeCallback&lt;ResourceType&gt;(dataSource));    &#125; <span class="hljs-keyword">finally</span> &#123;      rewinder.cleanup();    &#125;  &#125;</code></pre><p>调用<code>decodeFromRetrievedData</code>开始解析加载返回的数据，数据格式可能为<code>InputSteam</code>、<code>ByteBuffer</code>。向下调用到<code>decodeFromData()</code>，再到<code>decodeFromFetcher()</code>，最终通过<code>DecodeHelper.getLoadPath()</code>得到的<code>LoadPath</code>去对获取的数据进行解析。</p><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> Resource&lt;Transcode&gt; <span class="hljs-title">load</span><span class="hljs-params">(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, <span class="hljs-keyword">int</span> width,      <span class="hljs-keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;    List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">return</span> loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);    &#125; <span class="hljs-keyword">finally</span> &#123;      listPool.release(throwables);    &#125;  &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> Resource&lt;Transcode&gt; <span class="hljs-title">loadWithExceptionList</span><span class="hljs-params">(DataRewinder&lt;Data&gt; rewinder,      @NonNull Options options,      <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback,      List&lt;Throwable&gt; exceptions)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;    Resource&lt;Transcode&gt; result = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//noinspection ForLoopReplaceableByForEach to improve perf</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = decodePaths.size(); i &lt; size; i++) &#123;      DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//又传递到DecodePath上</span>        result = path.decode(rewinder, width, height, options, decodeCallback);      &#125; <span class="hljs-keyword">catch</span> (GlideException e) &#123;        exceptions.add(e);      &#125;      <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">break</span>;      &#125;    &#125;    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlideException(failureMessage, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(exceptions));    &#125;    <span class="hljs-keyword">return</span> result;  &#125;</code></pre><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> Resource&lt;Transcode&gt; <span class="hljs-title">decode</span><span class="hljs-params">(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height,     @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;   Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);   Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);   <span class="hljs-keyword">return</span> transcoder.transcode(transformed, options); &#125; <span class="hljs-meta">@NonNull</span> <span class="hljs-function"><span class="hljs-keyword">private</span> Resource&lt;ResourceType&gt; <span class="hljs-title">decodeResource</span><span class="hljs-params">(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width,     <span class="hljs-keyword">int</span> height, @NonNull Options options)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;   List&lt;Throwable&gt; exceptions = Preconditions.checkNotNull(listPool.acquire());   <span class="hljs-keyword">try</span> &#123;     <span class="hljs-keyword">return</span> decodeResourceWithList(rewinder, width, height, options, exceptions);   &#125; <span class="hljs-keyword">finally</span> &#123;     listPool.release(exceptions);   &#125; &#125;<span class="hljs-meta">@NonNull</span> <span class="hljs-function"><span class="hljs-keyword">private</span> Resource&lt;ResourceType&gt; <span class="hljs-title">decodeResourceWithList</span><span class="hljs-params">(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width,     <span class="hljs-keyword">int</span> height, @NonNull Options options, List&lt;Throwable&gt; exceptions)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;   Resource&lt;ResourceType&gt; result = <span class="hljs-keyword">null</span>;   <span class="hljs-comment">//noinspection ForLoopReplaceableByForEach to improve perf</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = decoders.size(); i &lt; size; i++) &#123;     ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);     <span class="hljs-keyword">try</span> &#123;       <span class="hljs-comment">//数据解析器</span>       DataType data = rewinder.rewindAndGet();       <span class="hljs-keyword">if</span> (decoder.handles(data, options)) &#123;         data = rewinder.rewindAndGet();         result = decoder.decode(data, width, height, options);       &#125;     &#125; <span class="hljs-keyword">catch</span> (IOException | RuntimeException | OutOfMemoryError e) &#123;     &#125;     <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;       <span class="hljs-keyword">break</span>;     &#125;   &#125;   <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlideException(failureMessage, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(exceptions));   &#125;   <span class="hljs-keyword">return</span> result; &#125;</code></pre><p><code>LoadPath.load()</code>通过调用<code>loadWithExceptionList()</code>，循环获取<code>DecodePath</code>对象，然后调用其自身的<code>decode()</code>进行数据解析。<code>DecodePath</code>与<code>LoadPath</code>逻辑相似，最终在<code>DecodePath.decodeResourceWithList()</code>中循环获取<code>ResourceDecoder</code>对象，通过<code>DateRewinder.rewindAndGet()</code>获取要解析数据的格式(比如<code>ByteBuffer，InputStream</code>)，然后调用<code>decoder.decode</code>继续解析数据。</p><h5 id="获取数据格式"><a href="#获取数据格式" class="headerlink" title="获取数据格式"></a>获取数据格式</h5><p>由上述流程可知，我们能获得的数据类型为<code>InputStream</code>和<code>ByteBuffer</code>，对应的就会有两种<code>DataRewinder</code></p><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RecyclableBufferedInputStream bufferedStream;<span class="hljs-meta">@NonNull</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">rewindAndGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    bufferedStream.reset();    <span class="hljs-keyword">return</span> bufferedStream;  &#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title">rewindAndGet</span><span class="hljs-params">()</span> </span>&#123;  buffer.position(<span class="hljs-number">0</span>);  <span class="hljs-keyword">return</span> buffer;&#125;</code></pre><p>将传进来的data可以转换成对应的数据格式。</p><h5 id="根据格式转换相应类型"><a href="#根据格式转换相应类型" class="headerlink" title="根据格式转换相应类型"></a>根据格式转换相应类型</h5><p>得到对应数据格式后，就需要通过<code>ResourceDecoder.decode()</code>去解析数据。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResourceDecoder</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">Z</span>&gt; </span>&#123;  <span class="hljs-comment">//判断这两个组合参数是否能进行解析</span>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">handles</span><span class="hljs-params">(@NonNull T source, @NonNull Options options)</span> <span class="hljs-keyword">throws</span> IOException</span>;   */  <span class="hljs-meta">@Nullable</span>  <span class="hljs-function">Resource&lt;Z&gt; <span class="hljs-title">decode</span><span class="hljs-params">(@NonNull T source, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, @NonNull Options options)</span>      <span class="hljs-keyword">throws</span> IOException</span>;&#125;</code></pre><p><code>T</code>代表需要被解析的类型(例如InputStream、ByteBuffer)，<code>Z</code>代表解析的结果类型(例如Bitmap、Drawable)。</p><p><code>ResourceDecoder</code>在原码中有很多实现类，<code>StreamBitmapDecoder</code>、<code>ButeBufferBitmapDecoder</code>，此处拿出常用的<code>StreamBitmapDecoder</code>进行分析。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">handles</span><span class="hljs-params">(@NonNull InputStream source, @NonNull Options options)</span> </span>&#123;  <span class="hljs-keyword">return</span> downsampler.handles(source);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Resource&lt;Bitmap&gt; <span class="hljs-title">decode</span><span class="hljs-params">(@NonNull InputStream source, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height,    @NonNull Options options)</span>    <span class="hljs-keyword">throws</span> IOException </span>&#123;  <span class="hljs-comment">// Use to fix the mark limit to avoid allocating buffers that fit entire images.</span>  <span class="hljs-keyword">final</span> RecyclableBufferedInputStream bufferedStream;  <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> ownsBufferedStream;  <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> RecyclableBufferedInputStream) &#123;    bufferedStream = (RecyclableBufferedInputStream) source;    ownsBufferedStream = <span class="hljs-keyword">false</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    bufferedStream = <span class="hljs-keyword">new</span> RecyclableBufferedInputStream(source, byteArrayPool);    ownsBufferedStream = <span class="hljs-keyword">true</span>;  &#125;  ExceptionCatchingInputStream exceptionStream =      ExceptionCatchingInputStream.obtain(bufferedStream);  MarkEnforcingInputStream invalidatingStream = <span class="hljs-keyword">new</span> MarkEnforcingInputStream(exceptionStream);  UntrustedCallbacks callbacks = <span class="hljs-keyword">new</span> UntrustedCallbacks(bufferedStream, exceptionStream);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">return</span> downsampler.decode(invalidatingStream, width, height, options, callbacks);  &#125; <span class="hljs-keyword">finally</span> &#123;    exceptionStream.release();    <span class="hljs-keyword">if</span> (ownsBufferedStream) &#123;      bufferedStream.release();    &#125;  &#125;&#125;</code></pre><p><code>ResourceDecode.decode()</code>内部是通过<code>Downsampler.decode()</code>进行解析</p><pre><code class="hljs java"> <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"resource"</span>, <span class="hljs-string">"deprecation"</span>&#125;) <span class="hljs-function"><span class="hljs-keyword">public</span> Resource&lt;Bitmap&gt; <span class="hljs-title">decode</span><span class="hljs-params">(InputStream is, <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight,     Options options, DecodeCallbacks callbacks)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   ...   <span class="hljs-keyword">try</span> &#123;     Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,         downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,         requestedHeight, fixBitmapToRequestedDimensions, callbacks);     <span class="hljs-keyword">return</span> BitmapResource.obtain(result, bitmapPool);   &#125; <span class="hljs-keyword">finally</span> &#123;     releaseOptions(bitmapFactoryOptions);     byteArrayPool.put(bytesForOptions);   &#125; &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> Bitmap <span class="hljs-title">decodeFromWrappedStreams</span><span class="hljs-params">(InputStream is,     BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,     DecodeFormat decodeFormat, <span class="hljs-keyword">boolean</span> isHardwareConfigAllowed, <span class="hljs-keyword">int</span> requestedWidth,     <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">boolean</span> fixBitmapToRequestedDimensions,     DecodeCallbacks callbacks)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;       Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);     callbacks.onDecodeComplete(bitmapPool, downsampled);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">decodeStream</span><span class="hljs-params">(InputStream is, BitmapFactory.Options options,     DecodeCallbacks callbacks, BitmapPool bitmapPool)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;   ...   TransformationUtils.getBitmapDrawableLock().lock();   <span class="hljs-keyword">try</span> &#123;     result = BitmapFactory.decodeStream(is, <span class="hljs-keyword">null</span>, options);   &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;     ...     <span class="hljs-keyword">throw</span> bitmapAssertionException;   &#125; <span class="hljs-keyword">finally</span> &#123;     TransformationUtils.getBitmapDrawableLock().unlock();   &#125;  ... &#125;</code></pre><p><code>Downsampler.decode()</code>内部主要实现依靠<code>decodeFromWrapperStreams()</code>，内部主要是配置<code>BitmapFactory.Options</code>。去控制图片的缩放(scale)、旋转(rotate)、复用(inBitmap)等方面配置。最后通过<code>decodeStream</code>解析输入流，最后生成Bitmap对象返回。</p><h5 id="获取图片后继续处理-例如圆角"><a href="#获取图片后继续处理-例如圆角" class="headerlink" title="获取图片后继续处理(例如圆角)"></a>获取图片后继续处理(例如圆角)</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Resource&lt;Transcode&gt; <span class="hljs-title">decode</span><span class="hljs-params">(DataRewinder&lt;DataType&gt; rewinder, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height,    @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback)</span> <span class="hljs-keyword">throws</span> GlideException </span>&#123;  <span class="hljs-comment">//上述步骤已完成</span>  Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);  <span class="hljs-comment">//加载完成的回调 调用Transform</span>  Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);  <span class="hljs-keyword">return</span> transcoder.transcode(transformed, options);&#125;</code></pre><p><code>decodeResource</code>最终会调到<code>DecodeJob.onResourceDecoded()</code>进行<code>Transform</code>处理。</p><pre><code class="hljs java"> &lt;Z&gt; <span class="hljs-function">Resource&lt;Z&gt; <span class="hljs-title">onResourceDecoded</span><span class="hljs-params">(DataSource dataSource,      @NonNull Resource&lt;Z&gt; decoded)</span> </span>&#123;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    Class&lt;Z&gt; resourceSubClass = (Class&lt;Z&gt;) decoded.get().getClass();    Transformation&lt;Z&gt; appliedTransformation = <span class="hljs-keyword">null</span>;    Resource&lt;Z&gt; transformed = decoded;    <span class="hljs-keyword">if</span> (dataSource != DataSource.RESOURCE_DISK_CACHE) &#123;      <span class="hljs-comment">//获取到的是 RequestOptions.getTransformations()这个集合</span>      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);      transformed = appliedTransformation.transform(glideContext, decoded, width, height);    &#125;    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make this the responsibility of the Transformation.</span>    <span class="hljs-keyword">if</span> (!decoded.equals(transformed)) &#123;      decoded.recycle();    &#125;<span class="hljs-keyword">if</span> (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,        encodeStrategy)) &#123;      <span class="hljs-keyword">if</span> (encoder == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Registry.NoResultEncoderAvailableException(transformed.get().getClass());      &#125;      <span class="hljs-keyword">final</span> Key key;      <span class="hljs-keyword">switch</span> (encodeStrategy) &#123;        <span class="hljs-keyword">case</span> SOURCE:          key = <span class="hljs-keyword">new</span> DataCacheKey(currentSourceKey, signature);          <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> TRANSFORMED:          key =              <span class="hljs-keyword">new</span> ResourceCacheKey(                  decodeHelper.getArrayPool(),                  currentSourceKey,                  signature,                  width,                  height,                  appliedTransformation,                  resourceSubClass,                  options);          <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unknown strategy: "</span> + encodeStrategy);      &#125;    ...    &#125;    <span class="hljs-keyword">return</span> result;  &#125;</code></pre><blockquote><p>从这里可看出 保存原图和保存转换后图片的缓存key是不一致的。</p><p>缓存原图用的是<code>DataCacheKey</code>，保存转换后图片用的是<code>ResourceCacheKey</code></p></blockquote><p>上述数据处理完毕后，层层回溯到达了<code>decodeFromRetrievedData</code>()</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decodeFromRetrievedData</span><span class="hljs-params">()</span> </span>&#123;    ...    Resource&lt;R&gt; resource = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;      resource = decodeFromData(currentFetcher, currentData, currentDataSource);    &#125; <span class="hljs-keyword">catch</span> (GlideException e) &#123;      e.setLoggingDetails(currentAttemptingKey, currentDataSource);      throwables.add(e);    &#125;    <span class="hljs-comment">//这时Resource已经赋值完毕</span>    <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;      notifyEncodeAndRelease(resource, currentDataSource);    &#125; <span class="hljs-keyword">else</span> &#123;      runGenerators();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyEncodeAndRelease</span><span class="hljs-params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;    <span class="hljs-keyword">if</span> (resource <span class="hljs-keyword">instanceof</span> Initializable) &#123;      ((Initializable) resource).initialize();    &#125;    notifyComplete(result, dataSource);    <span class="hljs-comment">//加载完毕后 回到初始状态</span>    stage = Stage.ENCODE;    ...  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyComplete</span><span class="hljs-params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;    setNotifiedOrThrow();    callback.onResourceReady(resource, dataSource);  &#125;</code></pre><p>经过解析数据那一套流程下来后，数据已经加载完成，然后回到<code>DecodeJob.decodeFromRetrieveData()</code>，这时Resource对象不为空，向下继续调用<code>notifyEncodeAndRelease()</code>，内部调用到<code>notifyComplete()</code>再回调到<code>EngineJob.onResourceReady()</code>。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResourceReady</span><span class="hljs-params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;    <span class="hljs-keyword">this</span>.resource = resource;    <span class="hljs-keyword">this</span>.dataSource = dataSource;  &#125;  notifyCallbacksOfResult();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyCallbacksOfResult</span><span class="hljs-params">()</span> </span>&#123;  ResourceCallbacksAndExecutors copy;  Key localKey;  EngineResource&lt;?&gt; localResource;  listener.onEngineJobComplete(<span class="hljs-keyword">this</span>, localKey, localResource);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;    entry.executor.execute(<span class="hljs-keyword">new</span> CallResourceReady(entry.cb));  &#125;  decrementPendingCallbacks();&#125;</code></pre><p><code>EngineJob.onResourceReady()</code>资源加载完成后，通过<code>notifyCallbacksOfResulr()</code>调用到<code>Engine.onEngineJobComplete()</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEngineJobComplete</span><span class="hljs-params">(    EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource)</span> </span>&#123;  <span class="hljs-comment">// A null resource indicates that the load failed, usually due to an exception.</span>  <span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;    resource.setResourceListener(key, <span class="hljs-keyword">this</span>);    <span class="hljs-keyword">if</span> (resource.isCacheable()) &#123;      activeResources.activate(key, resource);    &#125;  &#125;  jobs.removeIfCurrent(key, engineJob);&#125;</code></pre><p>加载完成后，把对应资源插入到<code>ActiveResources</code>中作为活动资源。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Glide-硬盘缓存.png" srcset="/img/loading.gif" class="full-image" alt="Glide-硬盘缓存" title="Glide-硬盘缓存"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="Glide高级用法"><a href="#Glide高级用法" class="headerlink" title="Glide高级用法"></a>Glide高级用法</h2><p>处理带有后缀的图片类型，可能为了保证安全，不同的用户获取的图片除了图片地址外还会有一段标识用户的token。而且token并不一定是固定的，这样我们再去加载图片时，由于缓存key不一致，导致重复加载。</p><p>这里涉及到了<a href="#缓存key">缓存key</a>的生成，其中有一个重要参数为远程图片加载地址，对于上述情况，因为地址的变化，key不同则查找缓存时也无法命中，解决这个情况就需要排除掉变化的部分。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGlideUrl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GlideUrl</span></span>&#123;    <span class="hljs-keyword">private</span> String mUrl;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyGlideUrl</span><span class="hljs-params">(String url)</span> </span>&#123;        <span class="hljs-keyword">super</span>(url);        mUrl = url;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCacheKey</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mUrl.replace(replaceTokenParam(),<span class="hljs-string">""</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">replaceTokenParam</span><span class="hljs-params">()</span></span>&#123;        String tokenParam=<span class="hljs-string">""</span>;        <span class="hljs-keyword">int</span> tokenIndex = mUrl.contains(<span class="hljs-string">"?.token"</span>) ? mUrl.indexOf(<span class="hljs-string">"?token"</span>):mUrl.indexOf(<span class="hljs-string">"&amp;token"</span>);        <span class="hljs-keyword">if</span>(tokenIndex!=-<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">int</span> nextAndIndex = mUrl.indexOf(<span class="hljs-string">"&amp;"</span>,tokenIndex+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (nextAndIndex!=-<span class="hljs-number">1</span>)&#123;                tokenParam = mUrl.substring(tokenIndex+<span class="hljs-number">1</span>,nextAndIndex+<span class="hljs-number">1</span>);            &#125;<span class="hljs-keyword">else</span>&#123;                tokenParam = mUrl.substring(tokenIndex);            &#125;        &#125;        <span class="hljs-keyword">return</span> tokenParam;    &#125;&#125;Glide.with(mContext).load(MyGlideUrl(imgUrl)).into(imageView);</code></pre><h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5c31fbdff265da610e803d4e#heading-14" target="_blank" rel="noopener">Glide主流源码分析</a></p><p><a href="https://juejin.im/post/5c2dffa8f265da611d66c8b6#heading-2" target="_blank" rel="noopener">Glide4.8源码拆解（二）核心加载流程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Study Plan IX - ClassLoaderß</title>
    <link href="/2018/03/18/Android-Study-Plan-IX/"/>
    <url>/2018/03/18/Android-Study-Plan-IX/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：Android中的ClassLoader<br>1、Android中有哪几种ClassLoader？它们的作用和区别是什么？<br>2、简述ClassLoader的双亲委托模型<br>3、简述双亲委托模型在热修复领域的应用</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="1-Android中有哪几种ClassLoader？它们的作用和区别是什么？"><a href="#1-Android中有哪几种ClassLoader？它们的作用和区别是什么？" class="headerlink" title="1.Android中有哪几种ClassLoader？它们的作用和区别是什么？"></a>1.Android中有哪几种ClassLoader？它们的作用和区别是什么？</h2><blockquote><p>在Android程序中，.dex文件就是一群.class文件。</p></blockquote><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/android_classloader.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="SingleTop"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><p><strong>BootClassLoader</strong></p><blockquote><p>BootClassLodaer是ClassLoader内部实现类，是只能包内可见，我们是无法调用的。在无父构造器传入的情况下，默认构建一个PathClassLoader且父构造器为BootClassLoader</p></blockquote> <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ClassLoader <span class="hljs-title">createSystemClassLoader</span><span class="hljs-params">()</span> </span>&#123;        String classPath = System.getProperty(<span class="hljs-string">"java.class.path"</span>, <span class="hljs-string">"."</span>);        String librarySearchPath = System.getProperty(<span class="hljs-string">"java.library.path"</span>, <span class="hljs-string">""</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());    &#125;</code></pre></li><li><p><strong>URLClassLoader</strong></p><blockquote><p>只能用于加载jar文件，但是在dalvik（Android5.0之前的虚拟机）无法直接识别jar，所以Android中无法使用这个加载器。</p></blockquote></li><li><p><strong>BaseDexClassLoader</strong></p><blockquote><p>用于加载各种dex中的类</p></blockquote> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseDexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseDexClassLoader</span><span class="hljs-params">(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Stub!"</span>);    &#125;    ...&#125;</code></pre><blockquote><p>主要构造函数介绍：</p><ul><li>dexPath：指<code>目标类所在的apk、dex或jar文件的路径，也可以是SD卡的路径</code>，类加载器从该路径加载目标类。如果包含多个路径，路径之间必须用特定的分隔符去分隔，特定的分隔符从<code>System.getProperty(&quot;path.separtor&quot;)</code>获取（默认分割符为”:”）。最终将路径上的文件ODEX优化到optimizedDirectory，然后进行加载。</li><li>optimizedDirectory：解压出的dex文件路径，这个路径必须为内部路径，一般情况下的路径为<code>/data/data/&lt;Package_Name&gt;/</code></li><li>librarySearchPath：存放目标类中使用的native文件库，也以”:”分割</li><li>parent：父加载器，在Android中以<code>context.getClassLoader</code>作为父加载器。</li></ul></blockquote></li><li><p><strong>DexClassLoader</strong></p><blockquote><p>继承自BaseDexClassLoader，支持加载包含classes.dex的jar、apk，zip文件，可以是SD卡的路径。是实现热修复的关键。<strong>注意不要把优化后的文件放在外部存储，可能导致注入攻击。</strong></p></blockquote></li><li><p><strong>PathClassLoader</strong></p><blockquote><p>用来加载Android系统类和应用程序的类，<strong>在dalvik上只能加载已安装apk的dex(/data/app目录)，在ART虚拟机上则没有这个限制</strong>。</p></blockquote>  <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PathClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDexClassLoader</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, ClassLoader parent)</span> </span>&#123;      <span class="hljs-keyword">super</span>((String)<span class="hljs-keyword">null</span>, (File)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, (ClassLoader)<span class="hljs-keyword">null</span>);      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Stub!"</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;      <span class="hljs-keyword">super</span>((String)<span class="hljs-keyword">null</span>, (File)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, (ClassLoader)<span class="hljs-keyword">null</span>);      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Stub!"</span>);  &#125;&#125;</code></pre><blockquote><p>在PathDexClassLoader的构造方法中optimizedDirectory为null，因为默认参数为<code>/data/dalvik-cache</code>目录。</p></blockquote></li><li><p><strong>InMemoryDexClassLoader</strong></p><blockquote><p>用于加载内存中的dex文件(在API26中添加)</p></blockquote> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InMemoryDexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDexClassLoader</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InMemoryDexClassLoader</span><span class="hljs-params">(ByteBuffer[] dexBuffers, ClassLoader parent)</span> </span>&#123;       <span class="hljs-keyword">super</span>((String)<span class="hljs-keyword">null</span>, (File)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, (ClassLoader)<span class="hljs-keyword">null</span>);       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Stub!"</span>);   &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InMemoryDexClassLoader</span><span class="hljs-params">(ByteBuffer dexBuffer, ClassLoader parent)</span> </span>&#123;        <span class="hljs-keyword">super</span>((String)<span class="hljs-keyword">null</span>, (File)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, (ClassLoader)<span class="hljs-keyword">null</span>);        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Stub!"</span>);    &#125;&#125;</code></pre></li><li><p><strong>DelegateClassLoader</strong></p><blockquote><p>是一个先查找在委托的类加载器(API27添加)，按照以下顺序实现加载：</p><ol><li>首先判断该类是否被加载</li><li>搜索此类的类加载器是否加载过这个类</li><li>使用当前加载器去尝试加载类</li><li>最后委托给父加载器加载</li></ol></blockquote></li></ul><h2 id="2-简述ClassLoader的双亲委托模型"><a href="#2-简述ClassLoader的双亲委托模型" class="headerlink" title="2.简述ClassLoader的双亲委托模型"></a>2.简述ClassLoader的双亲委托模型</h2><a href="/2018/04/16/JVM相关及其拓展-三/" title="JVM相关及其拓展(三) -- 虚拟机类加载器">JVM相关及其拓展(三) -- 虚拟机类加载器</a><h2 id="3-简述双亲委托模型在热修复领域的应用"><a href="#3-简述双亲委托模型在热修复领域的应用" class="headerlink" title="3.简述双亲委托模型在热修复领域的应用"></a>3.简述双亲委托模型在热修复领域的应用</h2><p>一个ClassLoader文件可以有多少Dex文件，每个Dex文件是一个Element，多个Dex文件组成一个有序数组DexElements，当找类的时候会按照顺序遍历Dex文件，然后在当前遍历的Dex文件中找出类。由于双亲委托模型机制的存在，只要找到类就会停止检索并返回，找不到就会查询下一个Dex，所以只要我们先找到并加载修复Bug的文件，则有bug的Dex文件不会被加载。</p><p>注意点：假设有个A类，引用了B类。发布过程中发现B类有bug，若想要发个新的B类，需要阻止A加上这个类标志CLASS_ISPREVERIFIED。</p><h2 id="4-基本热修复代码实现"><a href="#4-基本热修复代码实现" class="headerlink" title="4. 基本热修复代码实现"></a>4. 基本热修复代码实现</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Study Plan VIII - Java引用类型</title>
    <link href="/2018/03/18/Android-Study-Plan-VIII/"/>
    <url>/2018/03/18/Android-Study-Plan-VIII/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：Java基础知识学习<br>1、Java中有哪几种引用？它们的含义和区别是什么？<br>2、请用Java实现一个线程安全且高效的单例模式。</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="1-Java中有哪几种引用？它们的含义和区别是什么？"><a href="#1-Java中有哪几种引用？它们的含义和区别是什么？" class="headerlink" title="1. Java中有哪几种引用？它们的含义和区别是什么？"></a>1. Java中有哪几种引用？它们的含义和区别是什么？</h2><ul><li>强引用（StrongReference）：<code>无论内存是否充足，都不会被回收</code>强引用指的是在代码中普遍存在的类似<code>Object object=new Object();</code>这类的引用，只要有这类的存在，垃圾回收器永远不会回收该对象，这也是导致OOM异常出现的主要原因。若想中断强引用可以把对象置为<code>null</code>。</li><li><p>弱引用（WeakReference）：<code>内存不足时，会被回收</code>弱引用用来修饰非必需对象，弱引用所关联的对象生命周期只到下一次垃圾回收前，无论内存是否充足都会被回收关联对象。</p><pre><code class="hljs java">String s=<span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);WeakReference&lt;String&gt; weakReference=<span class="hljs-keyword">new</span> WeakReference&lt;&gt;(s);<span class="hljs-comment">//当内存回收时 调用weakRefrence=null 并且 System.gc();</span></code></pre></li><li><p>软引用（SoftReference）：<code>无论内存是否充足，都会被回收</code>软引用用来修饰一些有用但非必需的对象，软引用所关联的对象将会在系统即将发生OOM前，会把对象进行二次回收，若回收完内存还是不足则会发生OOM异常。<code>可实现内存敏感的高速缓存</code></p><pre><code class="hljs java">String s=<span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);SoftReference&lt;String&gt; softReference=<span class="hljs-keyword">new</span> SoftReference&lt;&gt;(s);<span class="hljs-comment">//当内存不足时 会调用 softRefrence=null  并且 System.gc();</span></code></pre></li><li><p>虚引用（PhantomReference）：<code>任何时候都会被回收</code>虚引用不会决定对象的生命周期，虚引用关联的对象任何时候都可能被垃圾回收器回收。虚引用的作用是：跟踪对象被垃圾回收器回收的活动，虚引用本身加入引用队列中，记录引用对象是都被回收。</p></li></ul><h2 id="2-请用Java实现一个线程安全且高效的单例模式。"><a href="#2-请用Java实现一个线程安全且高效的单例模式。" class="headerlink" title="2. 请用Java实现一个线程安全且高效的单例模式。"></a>2. 请用Java实现一个线程安全且高效的单例模式。</h2><blockquote><p>单例：一个类有且仅有一个实例，并且自行实例化向整个系统提供。目的为</p><ul><li>减少内存的占用</li><li>阻止对象实例化自己的单例对象副本，从而确保所有对象访问统一实例</li><li><p>控制了实例化过程所以可以灵活化控制实例过程。</p><p>线程安全：再多线程访问时采用加锁机制，当一个线程访问该数据时，其他线程不能访问该数据，直到读取完毕才可以访问。不会出现数据不一致和数据污染。</p></li></ul></blockquote><blockquote><p>双重校验锁（DCL）</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton mInstance;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) &#123;                    mInstance = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> mInstance;    &#125;&#125;</code></pre><blockquote><p>在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则<code>mInstance = new Singleton();</code>可能出现<code>mInstance</code>尚未被初始化的异常。<br><code>mInstance = new Singleton();</code>包括三步：<code>为对象分配内存</code>，<code>执行构造方法，初始化实例对象</code>，<code>把mInstance的引用指向分配的内存空间</code>。在JVM的执行过程中并不是原子性的。<br>保护序列化与反序列化安全的写法：<br><pre><code class="hljs java"><span class="hljs-comment">/***反序列化提供的一个特殊方法，可以控制对象的反序列化。*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> mInstance;<span class="hljs-comment">//返回实例对象</span>    &#125;</code></pre></p></blockquote><blockquote><p>静态内部类：</p><p><code>为何可以保证线程安全？</code>虚拟机可以保证一个类的类构造器 <code>&lt;clinit&gt;()</code>在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。<strong>同一个类加载器下，一个类型只会被初始化一次。</strong></p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> SingletonHolder.sInstance;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton sInstance = <span class="hljs-keyword">new</span> Singleton();    &#125;&#125;</code></pre><blockquote><p>枚举写法（在Android中不推荐使用，对内存的消耗较大）<br>枚举法的好处：1.实例创建线程安全 2.防止被反射创建多个实例 3. 没有序列化的问题</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Singleton&#123;    INSTANCE;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-comment">//do sth</span>    &#125;&#125;</code></pre><h2 id="3-拓展知识"><a href="#3-拓展知识" class="headerlink" title="3. 拓展知识"></a>3. 拓展知识</h2><ul><li><p>Kotlin实现的单例模式：<code>object Singleton{}</code>，本质是饿汉加载，在类加载时就会创建单例。问题在于构造方法过多时，初始化会变慢以及资源的浪费。</p></li><li><p>Kotlin实现懒汉式加载：</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>()&#123;    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;        <span class="hljs-keyword">val</span> instance: Singleton <span class="hljs-keyword">by</span> lazy &#123; Singleton() &#125;    &#125;&#125;</code></pre></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Study Plan VI</title>
    <link href="/2018/03/18/Android-Study-Plan-VI/"/>
    <url>/2018/03/18/Android-Study-Plan-VI/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：关于Gradle的知识<br>1、如何理解Gradle？Grade在Android的构建过程中有什么作用？<br>2、实践如下问题。</p><p>问题：我们都知道，Android中时常需要发布渠道包，需要将渠道信息附加到apk中，然后在程序启动的时候读取渠道信息。<br>动态指定一个渠道号（比如1001），那么构建的apk中，请在它的AndroidManifest.xml文件里面的application节点下面添加如下meta-data，请写一段Gradle脚本来自动完成：<br><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">android:allowBackup</span>=<span class="hljs-string">"false"</span> <span class="hljs-attr">android:supportsRtl</span>=<span class="hljs-string">"true"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">“channel</span>" <span class="hljs-attr">android:value</span>=<span class="hljs-string">“1001</span>" /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span></code></pre></p><p>要求：当通过如下命令来构建渠道包的时候，将渠道号自动添加到apk的manifest中。<br>./gradlew clean assembleRelease -P channel=1001</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Study Plan V</title>
    <link href="/2018/03/18/Android-Study-Plan-V/"/>
    <url>/2018/03/18/Android-Study-Plan-V/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：关于View的知识</p><p>1、View的getWidth()和getMeasuredWidth()有什么区别吗？<br>2、如何在onCreate中拿到View的宽度和高度？</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="1-View的getWidth-和getMeasuredWidth-有什么区别吗？"><a href="#1-View的getWidth-和getMeasuredWidth-有什么区别吗？" class="headerlink" title="1. View的getWidth()和getMeasuredWidth()有什么区别吗？"></a>1. View的getWidth()和getMeasuredWidth()有什么区别吗？</h2><ul><li><p><code>getWidth()</code>通过<code>setFrame</code>方法来决定四个顶点位置，初始化<code>mLeft,mTop,mRight,mBottom</code>四个参数，这四个值固定则位置确定。必须在layout过程结束才有值。</p><pre><code class="hljs java"> <span class="hljs-comment">/**     * Return the width of the your view.     *     * <span class="hljs-doctag">@return</span> The width of your view, in pixels.     * 利用屏幕上的右坐标减去左边的坐标      */</span>    <span class="hljs-meta">@ViewDebug</span>.ExportedProperty(category = <span class="hljs-string">"layout"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mRight - mLeft;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123; ...            mLeft = left;            mTop = top;            mRight = right;            mBottom = bottom;...  &#125;</code></pre></li><li><p><code>getMeasuredWidth</code>是在view的绘制流程中的<code>measure</code>结束后有值，获取的是view的测量宽高。<code>mMeasuredWidth</code>是在<code>setMeasuredDimensionRaw</code>方法中赋值的</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MEASURED\_SIZE\_MASK = <span class="hljs-number">0x00ffffff</span>;  <span class="hljs-comment">/**     * Like &#123;<span class="hljs-doctag">@link</span> #getMeasuredWidthAndState()&#125;, but only returns the     * raw width component (that is the result is masked by     * &#123;<span class="hljs-doctag">@link</span> #MEASURED_SIZE_MASK&#125;).     *     * <span class="hljs-doctag">@return</span> The raw measured width of this view.     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMeasuredWidth</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;<span class="hljs-comment">//与任何数字的运算得到的结果是mMeasuredWidth</span>    &#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMeasuredDimensionRaw</span><span class="hljs-params">(<span class="hljs-keyword">int</span> measuredWidth, measuredHeight)</span> </span>&#123;        mMeasuredWidth = measuredWidth;        mMeasuredHeight = measuredHeight;         mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;    &#125;</code></pre></li><li><p>一般情况下 <code>getMeasuredWidth</code>和<code>getWidth</code>的值是相同的，从源码中可以看出<code>setMeasuredDimensionRaw</code>会对<code>mMeasuredWidth</code>进行赋值，当调用了<code>onMeasure</code>，会调用到<code>setMeasuredDimensionRaw</code>则获取的结果将会不相同</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;  <span class="hljs-keyword">boolean</span> optical = isLayoutModeOptical(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;Insets insets = getOpticalInsets();   <span class="hljs-keyword">int</span> oWidth  = insets.left + insets.right;<span class="hljs-keyword">int</span> oHeight = insets.top  + insets.bottom;widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);&#125; ...  <span class="hljs-keyword">if</span> (forceLayout || needsLayout) &#123;<span class="hljs-comment">// first clears the measured dimension flag</span>mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;   resolveRtlPropertiesIfNeeded();<span class="hljs-keyword">int</span> cacheIndex = forceLayout ? -<span class="hljs-number">1</span> : mMeasureCache.indexOfKey(key);<span class="hljs-keyword">if</span> (cacheIndex &lt; <span class="hljs-number">0</span> || sIgnoreMeasureCache) &#123;<span class="hljs-comment">// measure ourselves, this should set the measured dimension flag back</span>onMeasure(widthMeasureSpec, heightMeasureSpec);   mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);<span class="hljs-comment">// Casting a long to int drops the high 32 bits, no mask needed</span>   setMeasuredDimensionRaw((<span class="hljs-keyword">int</span>) (value &gt;&gt; <span class="hljs-number">32</span>), (<span class="hljs-keyword">int</span>) value);mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;&#125;<span class="hljs-comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span><span class="hljs-comment">// an exception to warn the developer</span><span class="hljs-keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"View with id "</span> + getId() + <span class="hljs-string">": "</span>   + getClass().getName() + <span class="hljs-string">"#onMeasure() did not set the"</span>+ <span class="hljs-string">" measured dimension by calling"</span>+ <span class="hljs-string">" setMeasuredDimension()"</span>);&#125;mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;  &#125;  ...  &#125;</code></pre></li><li><p>view的绘制流程<code>measure</code> <code>layout</code> <code>draw</code></p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/view_process.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><code>measure</code>为了计算出控件树中的各个控件要显示的内容以及大小，起点为<code>ViewRootImpl 的 measureHierarchy ()</code>。<ul><li>SpecMode : <code>EXACTLY(确切大小)</code> <code>AT_MOST(子view的大小不得超过SpecSize)</code> <code>UNSPECIFIED(对子view尺寸不做限制)</code> <pre><code class="hljs java"><span class="hljs-comment">/**         * Measure specification mode: The parent has not imposed any constraint         * on the child. It can be whatever size it wants.         */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNSPECIFIED = <span class="hljs-number">0</span> &lt;&lt; MODE_SHIFT;        <span class="hljs-comment">/**         * Measure specification mode: The parent has determined an exact size         * for the child. The child is going to be given those bounds regardless         * of how big it wants to be.         */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> EXACTLY     = <span class="hljs-number">1</span> &lt;&lt; MODE_SHIFT;        <span class="hljs-comment">/**         * Measure specification mode: The child can be as large as it wants up         * to the specified size.         */</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> AT_MOST     = <span class="hljs-number">2</span> &lt;&lt; MODE_SHIFT;</code></pre></li></ul></li></ul></li><li><p><code>layout</code> 从根view开始，递归的完成控件树的布局工作，确定view的位置。先递归的对子view进行布局，在完成父布局的位置设置</p><ul><li><code>draw</code> 从根view开始进行绘制，利用<code>Viwe.draw()</code></li></ul></li></ul><h2 id="2-如何在onCreate中拿到View的宽度和高度？"><a href="#2-如何在onCreate中拿到View的宽度和高度？" class="headerlink" title="2.如何在onCreate中拿到View的宽度和高度？"></a>2.如何在onCreate中拿到View的宽度和高度？</h2><ul><li><p>在 Activity#onWindowFocusChanged 回调中获取宽高。</p></li><li><p>view.post(runnable)，在 runnable 中获取宽高。<br>  <code>利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。</code></p></li><li>ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。<br>  <code>监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露</code></li><li>调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高。</li></ul><h2 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h2><ul><li>matchParent无法measure(在view的measure过程中，需要知道parentSize即父容器的剩余空间，所以无法得出measure的大小)</li><li><a href="https://www.cnblogs.com/jycboy/p/6219915.html#autoid-7-1-0" target="_blank" rel="noopener">深入理解View绘制流程</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Study Plan IV</title>
    <link href="/2018/03/18/Android-Study-Plan-IV/"/>
    <url>/2018/03/18/Android-Study-Plan-IV/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p> 话题：关于startActivityForResult<br>1、startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode以及intent含义是什么？<br>2、Activity A启动B的时候，在B中何时该执行setResult ？setResult可以位于Activity的finish方法之后吗？</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="1-startActivityForResult-使用场景是什么？-requestCode、-resultCode-含义是什么？"><a href="#1-startActivityForResult-使用场景是什么？-requestCode、-resultCode-含义是什么？" class="headerlink" title="1.  startActivityForResult 使用场景是什么？ requestCode、 resultCode 含义是什么？"></a>1.  startActivityForResult 使用场景是什么？ requestCode、 resultCode 含义是什么？</h2><h3 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1  使用场景"></a>1.1  使用场景</h3><ul><li>用户开始新的活动，并且希望得到新活动的某些信息。比如选择照片、选择联系人、选择收货地址、进行某块数据编辑工作等。</li></ul><h3 id="1-2-requestCode"><a href="#1-2-requestCode" class="headerlink" title="1.2  requestCode"></a>1.2  requestCode</h3><ul><li>解决的是「区分多个异步任务」的问题。与其他异步 API 的设计类似，如果没有这个信息，那么 Activity 在收到响应时会进入混乱的状态。比如他不知道自己得到的是选择照片还是选择联系人的结果。</li><li>该信息会发送到 AMS 那边的 ActivityRecord.requestCode 变量进行记录，Client 端新 Activity 并不知道这个信息。</li><li><p>为什么 <code>requestCode</code>\&lt; 0 时收不到结果？</p><ul><li>ActivityStarter 收到 startActivityLocked 时，写入ActivityRecord.resultTo 变量为空<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#266" target="_blank" rel="noopener">对应源码</a><pre><code class="hljs java">ActivityRecord sourceRecord = <span class="hljs-keyword">null</span>;ActivityRecord resultRecord = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (resultTo != <span class="hljs-keyword">null</span>) &#123;    sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);    <span class="hljs-keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,            <span class="hljs-string">"Will send result to "</span> + resultTo + <span class="hljs-string">" "</span> + sourceRecord);    <span class="hljs-keyword">if</span> (sourceRecord != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (requestCode &gt;= <span class="hljs-number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;            resultRecord = sourceRecord;        &#125;    &#125;&#125;</code></pre></li></ul></li><li><p>在 ActivityStack 收到 finishActivityResultsLocked 时，读取 ActivityRecord.resultTo 变量为空，结果数据不会添加到源 ActivityRecord.results 变量</p></li><li>在 ActivityStack 收到 resumeTopActivityInnerLocked 时，读取 ActivityRecord.results 数组为空，不会分发结果数据，这样源 Activity 也就没有结果回调了</li></ul><h3 id="1-3-resultCode"><a href="#1-3-resultCode" class="headerlink" title="1.3 resultCode"></a>1.3 resultCode</h3><ul><li>异步调用结果码，告诉调用者成功/失败/其它信息</li><li>该信息由被调用 Activity / framework 写入，并经过 AMS 传递给源 Activity</li><li><code>RESULT_CANCELED=0</code> <code>RESULT_OK=-1</code> <code>RESULT_FIRST_USER=1</code><h3 id="1-4-intent"><a href="#1-4-intent" class="headerlink" title="1.4 intent"></a>1.4 intent</h3></li><li>用于存储需要传递的数据</li><li>大小不得大于1M</li></ul><h2 id="2-A-启动-B-，B-中何时执行-setResult-setResult-是否可以位于-finish-之后？"><a href="#2-A-启动-B-，B-中何时执行-setResult-setResult-是否可以位于-finish-之后？" class="headerlink" title="2. A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？"></a>2. A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？</h2><h3 id="2-1-setResult-在-finish-之前执行，只是把数据记录在-Activity-mResultCode-和-Activity-mResultData-变量中"><a href="#2-1-setResult-在-finish-之前执行，只是把数据记录在-Activity-mResultCode-和-Activity-mResultData-变量中" class="headerlink" title="2.1 setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中"></a>2.1 setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中</h3><p>Activity 构造器阶段<br>大部分在显示调用finish()或者onBackPressed()<br>    <pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resultCode, Intent data)</span> </span>&#123;<span class="hljs-comment">//进行赋值</span>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;           mResultCode = resultCode;          mResultData = data;       &#125;    &#125; <span class="hljs-comment">// Home 键 + 不保留后台 Activity 可触发 onDestroy</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="hljs-string">"onDestroy "</span> + <span class="hljs-keyword">this</span>);        mCalled = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// dismiss any dialogs we are managing.</span>        <span class="hljs-keyword">if</span> (mManagedDialogs != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> numDialogs = mManagedDialogs.size();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numDialogs; i++) &#123;                <span class="hljs-keyword">final</span> ManagedDialog md = mManagedDialogs.valueAt(i);                <span class="hljs-keyword">if</span> (md.mDialog.isShowing()) &#123;                    md.mDialog.dismiss();                &#125;            &#125;            mManagedDialogs = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// close any cursors we are managing.</span>        <span class="hljs-keyword">synchronized</span> (mManagedCursors) &#123;            <span class="hljs-keyword">int</span> numCursors = mManagedCursors.size();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCursors; i++) &#123;                ManagedCursor c = mManagedCursors.get(i);                <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;                    c.mCursor.close();                &#125;            &#125;            mManagedCursors.clear();        &#125;        <span class="hljs-comment">// Close any open search dialog</span>        <span class="hljs-keyword">if</span> (mSearchManager != <span class="hljs-keyword">null</span>) &#123;            mSearchManager.stopSearch();        &#125;        <span class="hljs-keyword">if</span> (mActionBar != <span class="hljs-keyword">null</span>) &#123;            mActionBar.onDestroy();        &#125;        getApplication().dispatchActivityDestroyed(<span class="hljs-keyword">this</span>);    &#125; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> finishTask)</span> </span>&#123;        <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">int</span> resultCode;            Intent resultData;            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                resultCode = mResultCode;                resultData = mResultData;            &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>) Log.v(TAG, <span class="hljs-string">"Finishing self: token="</span> + mToken);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (resultData != <span class="hljs-keyword">null</span>) &#123;                    resultData.prepareToLeaveProcess(<span class="hljs-keyword">this</span>);                &#125;                <span class="hljs-keyword">if</span> (ActivityManager.getService()                        .finishActivity(mToken, resultCode, resultData, finishTask)) &#123;                    mFinished = <span class="hljs-keyword">true</span>;                &#125;            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;                <span class="hljs-comment">// Empty</span>            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            mParent.finishFromChild(<span class="hljs-keyword">this</span>);        &#125;    &#125;</code></pre></p><h3 id="2-2-否"><a href="#2-2-否" class="headerlink" title="2.2 否"></a>2.2 否</h3><ul><li>如果位于 finish 之后执行，信息已经无法放到传递的数据中</li><li>从代码可以看出 setResult 和 finish 类似生产者/消费者模型，setResult 负责写入数据，finish 负责读取数据</li></ul><h3 id="2-3-线程安全问题"><a href="#2-3-线程安全问题" class="headerlink" title="2.3 线程安全问题"></a>2.3 线程安全问题</h3><ul><li>Activity.mResultCode 和 Activity.mResultData 变量由 Activity 对象的锁进行保护</li><li>支持后台线程和 UI 线程分别进行 setResult 和 finish</li><li>但是为什么需要加锁保护这两个信息？需要「解决什么问题」？</li></ul><h3 id="2-4-API-设计-数据组装问题"><a href="#2-4-API-设计-数据组装问题" class="headerlink" title="2.4 API 设计/数据组装问题"></a>2.4 API 设计/数据组装问题</h3><ul><li>底层 AMS 提供的接口的参数是 setResult 和 finish 的参数的组合形式，但是 Activity 为什么把一个接口拆分成两个接口给开发者使用？</li></ul><ul><li>使用方便。很多情况下调用者只关心 finish ，不需要理解太多的信息</li></ul><h3 id="2-5-启动模式冲突"><a href="#2-5-启动模式冲突" class="headerlink" title="2.5 启动模式冲突"></a>2.5 启动模式冲突</h3><ul><li>5.0以上 singleTask和singleInstance失效，重复启动时会重新创建实例</li><li>以下 则会直接收到<code>RESULT_CANCELED</code></li></ul><h2 id="3-API-内部原理-数据处理流程"><a href="#3-API-内部原理-数据处理流程" class="headerlink" title="3. API 内部原理/数据处理流程"></a>3. API 内部原理/数据处理流程</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/study_plan_4.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>关键节点：</p><ul><li>Client 端通过 AMP 把数据发送给 Server 端 AMS Binder 实体</li><li>AMS 把数据包装成 ActivityResult 并保存在源 ActivityRecord 的 results 变量中</li><li>AMS 通过 ApplicationThreadProxy 向 Client 端发送 pause 信息让栈顶 Activity 进入 paused 状态，并等待 Client 端回复或超时</li><li>AMS 接收 Client 端已 paused 信息，恢复下一个获取焦点的 Activity ，读取之前保存在 ActivityRecord.results 变量的数据派发给 Client 端对应的 Activity</li><li>Client 端数据经过 ApplicationThread 对象、ActivityThread 对象的分发最后到达 Activity</li></ul></blockquote><h2 id="4-startActivityForResult-和-singleTask-导致源-Activity-收不到正确结果问题"><a href="#4-startActivityForResult-和-singleTask-导致源-Activity-收不到正确结果问题" class="headerlink" title="4. startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题"></a>4. startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题</h2><h3 id="4-1-基本原则"><a href="#4-1-基本原则" class="headerlink" title="4.1 基本原则"></a>4.1 基本原则</h3><blockquote><p>源 Activity 和目标 Activity 无法在跨 Task 情况下通过 onActivityResult 传递数据</p></blockquote><h3 id="4-2-Android-5-0-以上-AMS-在处理-manifest-xml-文件中的-singleTask-和-singleInstance-信息「不会」创建新的-Task，因此可以收到正常回调"><a href="#4-2-Android-5-0-以上-AMS-在处理-manifest-xml-文件中的-singleTask-和-singleInstance-信息「不会」创建新的-Task，因此可以收到正常回调" class="headerlink" title="4.2 Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调"></a>4.2 Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调</h3><p> <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#1196" target="_blank" rel="noopener">源码链接</a></p><h3 id="4-3-Android-4-4-4-以下-AMS-在处理-manifest-xml-文件中的-singleTask-和-singleInstance-信息「会」创建新的-Task，因此在-startActivity-之后立即收到取消的回调"><a href="#4-3-Android-4-4-4-以下-AMS-在处理-manifest-xml-文件中的-singleTask-和-singleInstance-信息「会」创建新的-Task，因此在-startActivity-之后立即收到取消的回调" class="headerlink" title="4.3 Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调"></a>4.3 Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调</h3><p><a href="http://androidxref.com/4.4.4_r1/xref/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java#1399" target="_blank" rel="noopener">源码链接</a>   </p><h3 id="4-4-通过-dumpsys-activity-activities-命令查看-AMS-状态，验证两个-Activity-是否属于不同的-Task"><a href="#4-4-通过-dumpsys-activity-activities-命令查看-AMS-状态，验证两个-Activity-是否属于不同的-Task" class="headerlink" title="4.4 通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task"></a>4.4 通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Study Plan II - Service</title>
    <link href="/2018/03/18/Android-Study-Plan-II/"/>
    <url>/2018/03/18/Android-Study-Plan-II/</url>
    
    <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：清晰地理解Service。<br>1、Service的start和bind状态有什么区别？<br>2、同一个Service，先startService，然后再bindService，如何把它停止掉？<br>3、你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？<br>4、Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/service_lifecycle.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="Service生命周期"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="1-Service的start和bind状态有什么区别？"><a href="#1-Service的start和bind状态有什么区别？" class="headerlink" title="1.Service的start和bind状态有什么区别？"></a>1.Service的start和bind状态有什么区别？</h2><p>start启动Service,service有独立的生命周期，不依赖启动组件；<br>多次调用start方法，会重复调用onStartCommand方法；（判断service是否正在运行以避免多次调用）<br>start启动的Service，需要stopService或stopSelf来停止（IntentService会自动调用）。</p><blockquote><p>生命周期:onCreate()->onStartCommand()->onDestory()</p></blockquote><p>bind绑定的Service，依赖于启动组件，销毁后随之消失；<br>多次bind，只会调用一次onBind方法</p><blockquote><p>生命周期:onCreate()->onBind()->onUnBind()->onDestory()</p></blockquote><h2 id="2-同一个Service，先startService，然后再bindService，如何把它停止掉？"><a href="#2-同一个Service，先startService，然后再bindService，如何把它停止掉？" class="headerlink" title="2.同一个Service，先startService，然后再bindService，如何把它停止掉？"></a>2.同一个Service，先startService，然后再bindService，如何把它停止掉？</h2><p>调用stopService和unbindService方法，顺序无关，当最后一次调用时，会进入Service的onDestory方法</p><h2 id="3-你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？"><a href="#3-你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？" class="headerlink" title="3.你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？"></a>3.你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？</h2><p>4种返回值<br><pre><code class="hljs java"><span class="hljs-comment">//版本兼容，在Service被杀死后，并不保证onStartCommand会被再一次调用</span><span class="hljs-comment">//Service被kill后，Service被重建，即会调用onCreate()</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> START_STICKY_COMPATIBILITY = <span class="hljs-number">0</span>;<span class="hljs-comment">/**在Service被杀死后，系统会尝试重启Service但不保存intent，会用一个null对象调用  onStartCommand方法（注意intent判空），除非有一些被发送的Intent对象在等待   Service被kill后，Service被重建、重启，即会调用onCreate()&gt;onStartCommand()，intent对象为null。启动服务，试用于媒体播放器之类，无限期等待*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> START_STICKY = <span class="hljs-number">1</span>;<span class="hljs-comment">/**常规操作，除非被杀死之前还有组件调用startService，否则不保留状态并重启Service  直到接受到新的Intent对象，这个服务才会被重新创建Service被kill后，Service没有重启*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> START_NOT_STICKY = <span class="hljs-number">2</span>;<span class="hljs-comment">/**Service被杀死后，系统将会组织一次重启Service，在杀死前的最后一次传递的intent会被重新执行，不会传递空的intent  任意等待中的Intent对象会依次被发送。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。 */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> START_REDELIVER_INTENT = <span class="hljs-number">3</span>;</code></pre></p><h2 id="4-Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？"><a href="#4-Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？" class="headerlink" title="4.Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？"></a>4.Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？</h2><p>Service默认运行在主线程，所以生命周期的方法都会运行在主线程</p><h2 id="5-Service种类"><a href="#5-Service种类" class="headerlink" title="5.Service种类"></a>5.Service种类</h2><blockquote><p>按运行地点分类：<code>本地服务</code>和<code>远程服务</code><br>本地服务：依附主进程，主进程被kill后就会自动销毁<br>远程服务：运行在一个独立进程，需要利用AIDL通信需要占用一定资源而且是常驻形式</p></blockquote><blockquote><p>按运行类型分类：<code>前台服务</code>和<code>后台服务</code><br>前台服务：会在通知栏显示相关通知，当服务终止时通知栏消息即消失起到一定通知作用<br>后台服务：不会显示在前台，用户无感知，服务终止也不会有任何提示</p></blockquote><blockquote><p>按使用方式分类：<code>startService</code>，<code>bindService</code>和<code>混合使用</code><br>startService：用于启动服务执行后台任务，不需要通信，停止需要stopService<br>bindService：启动的服务需要进行通信，unbindService停止<br>混合使用：停止服务需同时调用stopService，unbindService</p></blockquote><h2 id="6-IntentService介绍"><a href="#6-IntentService介绍" class="headerlink" title="6.IntentService介绍"></a>6.IntentService介绍</h2><p>继承Service的一个异步请求类，在IntentService有一个工作进程处理耗时操作，启动方式和普通Service一样。任务执行完毕后，IntentService会自动关闭。每次只会执行一个而不至于堵塞UI线程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识</title>
    <link href="/2018/01/17/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2018/01/17/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<!--Java多态，重载和重写，分别应用场景，多态的原理--><!--内部类为什么可以访问外部类变量--><!--构造方法，代码块，静态代码块，静态变量，非静态变量在父子类中的加载顺序--><!--软引用当内存不足是一定能回收吗？--><!--javafinal--><!----><blockquote><p>如何理解Java的多态？其中，重载和重写有什么区别？</p></blockquote><p>多态是同一个行为具有多个不同表现形式或形态的能力，多态是同一个接口，使用不同的实例而执行不同操作。多态就是程序运行期才确定，一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法。</p><p>多态存在的三个必要条件是：<code>继承，重写，向上转型(需要将子类的引用赋值给父类对象，只有这样该引用才能具备调用父类的方法和子类的方法)</code>。</p><p>多态的三个实现方式：<code>重写、接口、抽象类和抽象方法</code>。</p><p>继承链中对象方法的调用优先级：</p><pre><code class="hljs java"><span class="hljs-keyword">this</span>.show(O) -&gt; <span class="hljs-keyword">super</span>.show(o) -&gt; <span class="hljs-keyword">this</span>.show((<span class="hljs-keyword">super</span>)O) -&gt; <span class="hljs-keyword">super</span>.show((<span class="hljs-keyword">super</span>)O)   当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。</code></pre><table><thead><tr><th>区别点</th><th>重载 Oberload</th><th>重写 Override</th></tr></thead><tbody><tr><td>参数类型</td><td>必须修改</td><td>不能修改</td></tr><tr><td>返回类型</td><td>可以修改</td><td>不能修改</td></tr><tr><td>异常</td><td>可以修改</td><td>可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td>访问</td><td>可以修改</td><td>一定不能做严格的限制</td></tr></tbody></table><blockquote><p>面向对象编程四大特性及含义</p></blockquote><ul><li>抽象：对现实世界的事物进行概括</li><li>封装：将某事物的属性和行为包装到对象中，构成一个不可分割的实体，数据被保护在抽象数据类型的内部。只保留一些借口使之与外部发生联系。</li><li>继承：子类继承父类，不仅可以有父类原有的方法和属性，也可以增加自己或者重写父类的方法及属性。</li><li>多态：允许不同类的对象对同一消息作出的各自响应。</li></ul><blockquote><p>Object的<code>equals()</code>和<code>==</code>的区别</p></blockquote><p><code>equals()</code>：Object的公有方法，默认情况下是<strong>引用比较</strong>，不过有些类对其进行了重写，大部分是进行<strong>值比较</strong>。</p><p><code>==</code>：针对不同的类型，会有不同的比较方式</p><ul><li>基本类型：比较值是否相同</li><li>引用类型：比较引用是否相同即内存地址是否相同</li></ul><blockquote></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见算法题整理 - 来自《剑指Offer》</title>
    <link href="/2018/01/16/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2018/01/16/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>数据结构</th><th>算法</th><th>概念</th></tr></thead><tbody><tr><td>链表</td><td>广度优先搜索</td><td>位操作</td></tr><tr><td>树、单词查找树、图</td><td>深度优先搜索</td><td>内存（堆、栈）</td></tr><tr><td>栈和队列</td><td>二分查找</td><td>递归</td></tr><tr><td>堆</td><td>归并排序</td><td>动态规划</td></tr><tr><td>向量、数组列表</td><td>快排</td><td>时间、空间复杂度</td></tr><tr><td>散列表</td><td></td></tr></tbody></table><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。(要求线性时间复杂度，即$O(1)$)</p><p>实例：输入：[1,2,3,2,1] 输出：3</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : nums)&#123;        result = result ^ x; <span class="hljs-comment">//利用异或位运算 实现 同则为0 不同则为 1</span>    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>给定一个正整数，如何判断该数是否为2的幂次方？</p><p>实例：输入 32 输出 true</p><p>​      输入 25 输出 false</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;  <span class="hljs-keyword">return</span> num &amp; (num -<span class="hljs-number">1</span> ) == <span class="hljs-number">0</span>；&#125;</code></pre><p>输入一颗二叉树，求树的深度 <em>利用递归实现</em></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span></span>&#123;  <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;  TreeNode left = <span class="hljs-keyword">null</span>;  TreeNode right = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;    <span class="hljs-keyword">this</span>.val = val;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode root)</span></span>&#123;    <span class="hljs-keyword">if</span>(root ==<span class="hljs-keyword">null</span>)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(TreeDepth(root.left),TreeDepth(root.right));  &#125;&#125;</code></pre><p>不用加减乘除实现 加法 减法 </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(num2==<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> num1;        &#125;        <span class="hljs-keyword">int</span> res = num1 ^ num2;        <span class="hljs-keyword">int</span> res2 = (num1&amp;num2) &lt;&lt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> Add(res,res2);    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span></span>&#123;      &#125;&#125;</code></pre><p>二叉树镜像</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode root)</span></span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)      <span class="hljs-keyword">return</span>;    swap(root);    Mirror(root.left);    Mirror(root.right);  &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(TreeNode root)</span></span>&#123;    TreeNode node = root.left;    root.left= root.right;    root.right = node;  &#125;&#125;</code></pre><blockquote><p> 两个栈实现队列</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  Stack&lt;Integer&gt; in = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();  Stack&lt;Integer&gt; out = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span></span>&#123;    in.push(node);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span>(out.isEmpty())&#123;      <span class="hljs-keyword">while</span>(!in.isEmpty())&#123;        out.push(in.pop());      &#125;    &#125;        <span class="hljs-keyword">return</span> out.pop();  &#125;&#125;</code></pre><blockquote><p>两个队列实现一个栈</p></blockquote><pre><code class="hljs java"></code></pre><p>获取链表倒数第K个节点</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode head,<span class="hljs-keyword">int</span> k)</span> </span>&#123;     <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>     &#125;      ListNode first = head;     <span class="hljs-keyword">while</span>(first!=<span class="hljs-keyword">null</span> &amp;&amp; k--&gt;<span class="hljs-number">0</span>)&#123;       first = first.next;     &#125;     <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">0</span>)&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;     &#125;     ListNode kNode = head;     <span class="hljs-keyword">while</span>(first!=<span class="hljs-keyword">null</span>)&#123;       first = first.next;       kNode = kNode.next;     &#125;     <span class="hljs-keyword">return</span> kNode;        &#125;&#125;</code></pre><p>反转链表并输出表头</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode head)</span></span>&#123;    ListNode reverseList = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);    <span class="hljs-keyword">while</span>(head!=<span class="hljs-keyword">null</span>)&#123;      ListNode next = head.next;      head.next = reverseList.next;      reverseList.next = head;      reverseList = next;    &#125;    <span class="hljs-keyword">return</span> reverseList.next;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">ReverseList1</span><span class="hljs-params">(ListNode head)</span></span>&#123;    ListNode pre = <span class="hljs-keyword">null</span>;    ListNode cur = head;    ListNode next = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-keyword">null</span>)&#123;      next = cur.next;      cur.next = pre;      pre = cur;      cur = next;    &#125;        <span class="hljs-keyword">return</span> pre;  &#125;&#125;</code></pre><p>LeetCode 24：交换链表中节点</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span></span>&#123;    <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span> || head.next ==<span class="hljs-keyword">null</span>)      <span class="hljs-keyword">return</span> head;        ListNode next = head.next;    head.next = swapPairs(next.next);    next.next = head;    reyurn next;  &#125;&#125;</code></pre><p>实现一个包含<code>min()</code>的栈，可以返回栈中的最小值</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="hljs-keyword">new</span> Stack();  <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; inputStack = <span class="hljs-keyword">new</span> Stack();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span></span>&#123;    inputStack.push(node);    <span class="hljs-comment">//与顶端进行比较 取小</span>    minStack.push(minStack.isEmpty()?node:Math.min(minStack.peek(),node));  &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;    inputStack.pop();    minStack.pop();  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> inputStack.peek();  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> minStack.peek();  &#125;&#125;</code></pre><p>斐波那契数列</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">return</span> n;  &#125;  <span class="hljs-keyword">int</span>[] fib = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];    fib[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;      fib[i] = fib[i-<span class="hljs-number">1</span>]+fib[i-<span class="hljs-number">2</span>];    &#125;    <span class="hljs-keyword">return</span> fib[n];  &#125;&#125;</code></pre><p>重建二叉树</p><ul><li><p>已知前序遍历和中序遍历</p><p>> 例如 前序遍历为 {1,2,4,7,3,5,6,8} //根节点在前方<br>\><br>> ​    中序遍历为{4,7,2,1,5,3,8,6} //根节点左侧为 左子树  右侧为 右子树</p></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  <span class="hljs-keyword">private</span> HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rootIndex ;  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pre,<span class="hljs-keyword">int</span>[] in)</span></span>&#123;    <span class="hljs-keyword">int</span> len = in.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;      map.put(in[i],i);    &#125;    rootIndex = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> buildTree(pre,<span class="hljs-number">0</span>,len-<span class="hljs-number">1</span>);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pre,<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">if</span>(start&gt;end)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    TreeNode rootNode = <span class="hljs-keyword">new</span> TreeNode(pre[rootIndex++])    <span class="hljs-keyword">int</span> index = map.get(rootNode.val);        rootNode.left = buildTree(pre,start,index-<span class="hljs-number">1</span>);    rootNode.right = buildTree(pre,index+<span class="hljs-number">1</span>,end);    <span class="hljs-keyword">return</span> rootNode;  &#125;&#125;</code></pre><ul><li>已知中序遍历和后序遍历</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  <span class="hljs-keyword">private</span> HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rootIndex;  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">BuildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] post,<span class="hljs-keyword">int</span>[] in)</span></span>&#123;    <span class="hljs-keyword">int</span> len = in.length;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;      map.put(in[i],i);    &#125;    rootIndex = len-<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> buildTree(post,<span class="hljs-number">0</span>,len-<span class="hljs-number">1</span>);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] post ,<span class="hljs-keyword">int</span> start ,<span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">if</span>(start&gt;end)      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    TreeNode rootNode = <span class="hljs-keyword">new</span> TreeNode(post[rootIndex--]);    <span class="hljs-keyword">int</span> index = map.get(rootNode.val);    <span class="hljs-comment">//先计算右子树</span>    rootNode.right = buildTree(post,index+<span class="hljs-number">1</span>,end);    rootNode.left = buildTree(post,start,index-<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> rootNode;      &#125;&#125;</code></pre><ul><li>二叉树的遍历</li></ul><p>- </p><p>判断链表是否成环，若成环找出入口点</p><ol><li>判断next是否为null，不为null则成环</li><li>利用<code>Set</code>存储每个节点，每到新节点判断是否出现重复。时间复杂度<code>O(n)</code></li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode head)</span></span>&#123;    <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span>)      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    ListNode fast = head;    ListNode slow = head;    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-keyword">null</span> &amp;&amp; fast.next!=<span class="hljs-keyword">null</span>)&#123;      fast = fast.next.next;      slow = slow.next;      <span class="hljs-comment">//表明链表成环</span>      <span class="hljs-keyword">if</span>(fast==slow)&#123;        ListNode result = head;        <span class="hljs-keyword">while</span>(head!=slow)&#123;          result = result.next;          slow = slow.next;        &#125;        <span class="hljs-keyword">return</span> result;      &#125;    &#125;  &#125;&#125;</code></pre><p>删除链表中重复的节点</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode head)</span></span>&#123;      <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next ==<span class="hljs-keyword">null</span>)        <span class="hljs-keyword">return</span> head;      ListNode next = head.next;      <span class="hljs-keyword">if</span>(head.val == next.val)&#123;        <span class="hljs-keyword">while</span>(next!=<span class="hljs-keyword">null</span> &amp;&amp; head.val == next.val)          next = next.next;        <span class="hljs-keyword">return</span> deleteDuplication(next);      &#125;<span class="hljs-keyword">else</span>&#123;        head.next = deleteDuplication(next);        <span class="hljs-keyword">return</span> head;      &#125;    &#125;&#125;</code></pre><p>判断是否为平衡二叉树</p><blockquote><p>平衡二叉树：左子树和右子树高度相差不到1</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isBalanced = <span class="hljs-keyword">true</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode node)</span></span>&#123;        <span class="hljs-keyword">return</span> isBalanced;  &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTreeHeight</span><span class="hljs-params">(TreeNode node)</span></span>&#123;    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span> || !isBalanced)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> left = getTreeHeight(node.left);    <span class="hljs-keyword">int</span> right = getTreeHeight(node.right);    <span class="hljs-keyword">if</span>(Math.abs(left-right)&lt;<span class="hljs-number">1</span>)&#123;      isBalanced = <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+Math.max(left,right);  &#125;&#125;</code></pre><blockquote><p>字符流中第一个不重复字符串<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap();    <span class="hljs-keyword">char</span> firstChar = <span class="hljs-string">"#"</span>.charAt(<span class="hljs-number">0</span>);        <span class="hljs-comment">//Insert one char from stringstream</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span>    </span>&#123;       <span class="hljs-keyword">if</span> (map.containsKey(ch)) &#123;            map.put(ch, <span class="hljs-number">0</span>);              &#125; <span class="hljs-keyword">else</span> &#123;            map.put(ch, <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123;            <span class="hljs-keyword">if</span> (entry.getValue() == <span class="hljs-number">1</span>) &#123;                firstChar = entry.getKey();                <span class="hljs-keyword">break</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                firstChar = <span class="hljs-string">"#"</span>.charAt(<span class="hljs-number">0</span>);            &#125;        &#125;    &#125;  <span class="hljs-comment">//return the first appearence once char in current stringstream</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">FirstAppearingOnce</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-keyword">return</span> firstChar;    &#125;&#125;</code></pre></p></blockquote><blockquote><p>二叉搜索树的后序遍历序列<br>后序遍历过程： 左->右->中<br><code>二叉搜索树</code>：设x是树中的一个节点，如果y是x左子树中的一个节点，那么y\&lt;=x，如果y是x右子树的一个节点，那么y>=x<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">boolean</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] sequence)</span> </span>&#123;        <span class="hljs-keyword">if</span>(sequence.length ==<span class="hljs-number">0</span> || sequence==<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">if</span>(sequence.length == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> search(sequence,<span class="hljs-number">0</span>,sequence.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array ,<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;        <span class="hljs-keyword">if</span>(start &gt; end)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">int</span> i = end;        <span class="hljs-comment">//向前倒序寻找到左子树</span>        <span class="hljs-keyword">while</span>(i&gt;start &amp;&amp; array[i-<span class="hljs-number">1</span>] &gt; array[end])&#123;            i--;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i-<span class="hljs-number">1</span>;j&gt;=start;j--)&#123;            <span class="hljs-keyword">if</span>(array[j] &gt; array[end])&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> search(array,start,i-<span class="hljs-number">1</span>) &amp;&amp; search(array,i+<span class="hljs-number">1</span>,end-<span class="hljs-number">1</span>);    &#125;&#125;</code></pre></p></blockquote><blockquote><p>二叉树中和为某一值的路径<br><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="hljs-keyword">int</span> target) &#123;        arrayLists.clear();        addPath(root,<span class="hljs-keyword">new</span> ArrayList(),<span class="hljs-number">0</span>,target);        <span class="hljs-keyword">return</span> arrayLists;    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPath</span><span class="hljs-params">(TreeNode root, ArrayList&lt;Integer&gt; path, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        num += root.val;        path.add(root.val);        <span class="hljs-comment">//递归完毕</span>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (num == target) &#123;                arrayLists.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            addPath(root.left, path, num, target);            addPath(root.right, path, num, target);        &#125;        path.remove(path.size() - <span class="hljs-number">1</span>);    &#125;&#125;</code></pre></p></blockquote><p>实现一个LFU算法</p><blockquote><p>淘汰一定时期内被访问次数最少的元素</p></blockquote><pre><code class="hljs java"></code></pre><p>Leetcode 703</p><blockquote><p>采用优先队列机制实现，比较第K大元素问题<br>优先队列采用 小顶堆 小的数据放在根节点，这样在插入节点时只要与根节点比较即可<br><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KthLargest</span> </span>&#123;    PriorityQueue&lt;Integer&gt; priorityQueue;    <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">this</span>.maxSize = k;        priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue&lt;Integer&gt;(k);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-keyword">var</span> : nums) &#123;            add(<span class="hljs-keyword">var</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (priorityQueue.size() &lt; maxSize) &#123;            priorityQueue.offer(val);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (priorityQueue.peek() &lt; val) &#123;            priorityQueue.poll();            priorityQueue.offer(val);        &#125;        <span class="hljs-keyword">return</span> priorityQueue.peek();    &#125;&#125;</code></pre></p></blockquote><p>Leetcode 239：Sliding Window Maximum</p><p>Leetcode 15: 3Sum</p><blockquote><p>Given array nums = [-1, 0, 1, 2, -1, -4],</p><p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><p>解题思路：</p><p>先对数组进行排序，按照从小到大的顺序。将排序后的数组全部放入到<code>HashMap</code>中</p><p>题目中要求<code>a+b+c=0 ==&gt; c=-a-b</code>即 在Map中找到<code>-a-b</code>对应的值并取出即可</p></blockquote><pre><code class="hljs java">时间复杂度：`O(n2)`<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        HashMap&lt;Integer, Integer&gt; set = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>)            <span class="hljs-keyword">return</span> result;        <span class="hljs-comment">// 排序</span>        Arrays.sort(nums);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            set.put(nums[i], i);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])                <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;                <span class="hljs-comment">// </span>                <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">if</span> (nums[j] == nums[j - <span class="hljs-number">1</span>] &amp;&amp; j != i + <span class="hljs-number">1</span>)                    <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span> (set.containsKey(-nums[i] - nums[j]) &amp;&amp; set.get(-nums[i] - nums[j]) &gt; j) &#123;                    List&lt;Integer&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();                    l.add(nums[i]);                    l.add(nums[j]);                    l.add(-nums[i] - nums[j]);                    result.add(l);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>优化解法</p><blockquote><p>还是先进行排序，固定首位数据<code>a</code>，然后在剩下的数据内，设置下一位为<code>b</code>，数组最后一位为<code>c</code>，如果<code>a+b+c=0</code>直接取出对应值，</p><ul><li>若&gt;0，则c向左移</li><li>若&lt;0，则b向右移</li></ul></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">3</span>)            <span class="hljs-keyword">return</span> result;        <span class="hljs-comment">// 排序</span>        Arrays.sort(nums);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])                <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">int</span> low = i + <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> high = len - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (low &lt; high) &#123;                <span class="hljs-keyword">int</span> resultNum = nums[i] + nums[low] + nums[high];                <span class="hljs-keyword">if</span> (resultNum == <span class="hljs-number">0</span>) &#123;                    List&lt;Integer&gt; l = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();                    l.add(nums[i]);                    l.add(nums[low]);                    l.add(nums[high]);                    result.add(l);                    <span class="hljs-comment">//此处为了防止 因为重复数据导致问题 </span>                    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; nums[low] == nums[low + <span class="hljs-number">1</span>]) low++;                    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; nums[high] == nums[high - <span class="hljs-number">1</span>]) high--;                    low++;                    high--;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (resultNum &gt; <span class="hljs-number">0</span>) &#123;                    high--;                &#125; <span class="hljs-keyword">else</span> &#123;                    low++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fragment相关</title>
    <link href="/2018/01/10/Fragment%E7%9B%B8%E5%85%B3/"/>
    <url>/2018/01/10/Fragment%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<!--Activity和Fragment数据交互 Fragment初始化参数调用哪个方法？ Fragment懒加载怎么实现？Fragment重叠问题--><blockquote><p>Android中展示界面一般是通过<code>Activity</code>去实现的，当要实现类似商城类的首页时，就会拿出<code>Fragment</code>去实现对应的每个标签页，由<code>Activity</code>进行管理。</p></blockquote><h2 id="Fragment介绍"><a href="#Fragment介绍" class="headerlink" title="Fragment介绍"></a>Fragment介绍</h2><p><code>Fragment</code>存在必须依附于<code>FragmentActivity</code>使用，并且与<code>FragmentActivity</code>一样，拥有自己独立生命周期，同时可以处理用户的交互动作。并且可以在一个<code>Activity</code>中动态的添加、替换，移除不同的<code>Fragment</code>，同样<code>Fragment</code>也可以拥有多个子<code>Fragment</code>并对他们进行控制，对于信息的显示有很大的便利性。</p><h2 id="Fragment使用方式"><a href="#Fragment使用方式" class="headerlink" title="Fragment使用方式"></a>Fragment使用方式</h2><h3 id="Fragment初始化"><a href="#Fragment初始化" class="headerlink" title="Fragment初始化"></a>Fragment初始化</h3><p>默认提供两种初始化方式：</p><ul><li><p><code>new XXFragment()</code></p><pre><code class="hljs java">DemoFragment fragment = <span class="hljs-keyword">new</span> DemoFragment()</code></pre></li><li><p><code>xml 引入</code></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">fragment</span>          <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>          <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>          <span class="hljs-attr">class</span>=<span class="hljs-string">"com.demo.fragment.DemoFragment"</span>/&gt;</span></code></pre></li></ul><p>主流使用的是第一种方法，但是并不是推荐的标准用法，如果需要有参数传入的情况下。</p><p>在<code>Fragment</code>中添加<code>newInstance()</code>，然后方法里面传入参数，以后获取Fragment就调用该方法，不要使用<code>new</code>方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DemoFragment <span class="hljs-title">newInstance</span><span class="hljs-params">(Bundle args)</span> </span>&#123;    DemoFragment f = <span class="hljs-keyword">new</span> DemoFragment();    f.setArguments(args);    <span class="hljs-keyword">return</span> f;&#125;</code></pre><pre><code class="hljs java">Bundle args = <span class="hljs-keyword">new</span> Bundle();args.putString(text,Hello);MyFragment f = MyFragment.newInstance(args)</code></pre><blockquote><p>Fragment会被重新销毁(可能因为内存不足、手机发生了配置变化)，重新创建时会默认调用无参构造函数。</p><p>通过<code>setArguments()</code>传递的Bundle也会被保留下来。</p></blockquote><h3 id="操作Fragment"><a href="#操作Fragment" class="headerlink" title="操作Fragment"></a>操作Fragment</h3><pre><code class="hljs java"><span class="hljs-comment">//获取FragmentManager对象 这是Activity方式</span>FragmentManager fragmentManager = getSupportFragmentManager();<span class="hljs-comment">//从Fragment中获取 FragmentManager</span>FragmentManager fragmentManager = getChildFragmentManager()<span class="hljs-comment">//开启事务，通过 FragmentTransaction 进行add()、remove()等操作</span>FragmentTransaction ft = fragmentManager.beginTransaction();<span class="hljs-comment">//添加Fragment</span>ft.add(R.id.fragment,DemoFragment.newInstance());<span class="hljs-comment">//提交事务</span>ft.commit();</code></pre><p>涉及到了以下类：</p><p><code>FragmentManager</code></p><p>在Activity通过<code>getSupportManager</code>获取该对象，在<code>Fragment</code>中通过<code>getChildFragmentManager()</code>获取</p><p><code>FragmentTransaction</code>：Fragment操作事务</p><p>通过<code>beginTransaction()</code>开启事务，事务开启后就可以对<code>Fragment</code>进行操作</p><p>以下为几种常用的操作方法：</p><p><code>add()</code>：添加Fragment到Activity或Fragment中</p><p><code>hide()/show()</code>：隐藏和显示Fragment</p><p><code>remove()</code>：移除指定Fragment</p><p><code>replace()</code>：内部实质是调用<code>remove()</code>和<code>add()</code>完成Fragment修改过程</p><p><code>addToBackStack()</code>：添加当前Fragment到回退栈中，当按下返回键时可以根据回退栈进行操作</p><p><code>commit()</code>：提交事务，对Fragment进行操作后都需要<code>commit()</code>完成提交后可以生效</p><p><code>commitAllowingStateLoss()</code>：也是提交事务的一种，但是不会在其中抛出异常，只是跳过了检测<code>mStateSaved</code>是否进行了保存</p><blockquote><p>确保<code>commit()</code>在<code>Activity.onPostResume()</code>或者<code>FragmentActivity.onResumeFragments()</code>内调用，而且不要随意使用<code>commitAllowingStateLoss()</code>进行代替，不能滥用该方法。因为忽略状态丢失，Activity意外崩溃时就无法还原之前保存的数据。</p></blockquote><p>添加Fragment有两种方法：</p><p>通过<code>replace()</code></p><pre><code class="hljs java">ft.replace(R.id.fragment,DemoFragment.newInstance())</code></pre><p>通过<code>add()</code>配合<code>show()、hide()</code></p><pre><code class="hljs java">ft.add(R.id.fragment,DemoFragment.newInstance());<span class="hljs-comment">//显示时调用</span>ft.show();<span class="hljs-comment">//显示其他Fragment时调用</span>ft.hide()</code></pre><blockquote><p><code>replace()</code>不会保留Fragment的状态，会销毁视图并重新加载，调用时保存的数据都会消失。</p><p><code>hide()/show()</code>只是对Fragment进行隐藏/显示，不会影响存储的数据</p></blockquote><h2 id="Fragment生命周期"><a href="#Fragment生命周期" class="headerlink" title="Fragment生命周期"></a>Fragment生命周期</h2><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Fragment生命周期.png" srcset="/img/loading.gif" class="full-image" alt="Fragment生命周期" title="Fragment生命周期"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>onAttach()</code>：Fragment和Activity绑定时调用。<strong>Fragment附加到Activity之后，无法再次调用<code>setArguments()</code></strong></p><p><code>onCreate()</code>：此时可以获取到<code>setArguments()</code>传递过来的参数，通过Bundle获取</p><p><code>onCreateView()</code>：在Fragment加载布局时调用</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">return</span> inflater.inflate(getLayoutResId(), container, <span class="hljs-keyword">false</span><span class="hljs-comment">/*不要把View主动添加到container,这个是自动关联的*/</span>);&#125;</code></pre><p><code>onActivityCreated()</code>：当Activity的<code>onCreate()</code>执行完成后调用</p><p><code>onDestoryView()</code>：Fragment中布局被移除时调用</p><p><code>onDetach()</code>：Fragmen和Activity解绑时调用</p><p>其中还有一个<code>setRetainInstance()</code>当调用到该方法时，在Actiivity重新创建时可以完全不销毁<code>Fragment</code>，以便Fragment中恢复数据。调用了</p><p><code>setRetainInstance(true)</code>后，Fragment恢复时就会跳过<code>onCreate()</code>、<code>onDestroy()</code>生命周期回调，因此在使用该方法时，<code>onCreate()</code>中不要做初始化逻辑。</p><blockquote><p>当因为设备配置发生变化时，<code>FragmentManager</code>首先销毁队列中的fragment的视图，接着<code>FragmentManager</code>会检查<code>Fragment</code>中的<code>retainInstance</code>属性，如果为false，直接销毁Fragment实例；若设置为true，fragment的视图会被销毁，但fragment本身不会被销毁，处于短暂的保留状态。当Activity需要时会对其进行恢复。</p></blockquote><h2 id="Fragment通信"><a href="#Fragment通信" class="headerlink" title="Fragment通信"></a>Fragment通信</h2><h3 id="Fragment与Activity通信"><a href="#Fragment与Activity通信" class="headerlink" title="Fragment与Activity通信"></a>Fragment与Activity通信</h3><ol><li><p>如果Activity中包含自己管理的Fragment的引用，可以通过该引用直接访问所有public方法</p></li><li><p>Activity中未保存任何Fragment的引用，通过给每个Fragment设置<code>Tag或ID</code>，后面通过调用<code>FragmentManager.findFragmentByTag()或FragmentManager.findFragmentById()</code>获取对应Fragment实例</p></li><li><p>在Fragment通过<code>getActivity()</code>获取Activity实例，然后执行操作。</p><p>通过<code>getActivity()</code>获取Activity实例，可能会返回<code>null</code>导致异常。该方法返回结果只会在<code>onAttach()</code>及<code>onDetach()</code>会非空，其他时候都有可能为空，所以可以先使用<code>getContext()</code>去进行替代，这样比较安全。</p><p>还有一种就是定义一个全局变量，当触发<code>onAttach()</code>进行赋值，后续调用直接使用该全局变量</p><pre><code class="hljs java">Context context ;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAttach</span><span class="hljs-params">(Context context)</span></span>&#123;  <span class="hljs-keyword">super</span>.onAttach(context);  <span class="hljs-keyword">this</span>.context = context;&#125;</code></pre></li></ol><ol start="4"><li><p><strong>使用接口方式(推荐做法)</strong></p><pre><code class="hljs java"><span class="hljs-comment">//Fragment中定义接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ShowMsgListener</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showMsg</span><span class="hljs-params">(String str)</span></span>;    &#125;<span class="hljs-keyword">private</span> ShowMsgListener msgListener; <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAttach</span><span class="hljs-params">(Activity activity)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onAttach(activity);        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span>(activity!=<span class="hljs-keyword">null</span>)&#123;                <span class="hljs-comment">//获取Activity中实现的接口</span>                msgListener=(DemoActivity)activity;            &#125;        &#125; <span class="hljs-keyword">catch</span> (ClassCastException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassCastException(activity.toString()                    + <span class="hljs-string">" must implement showMsgListener"</span>);        &#125;    &#125;<span class="hljs-comment">//调用接口</span>msgListener.showMsg(<span class="hljs-string">"From fragment"</span>)；</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> DemoActivity extends FragmentActivity implements ShowMsgListener&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMsg</span><span class="hljs-params">(String str)</span></span>&#123;    <span class="hljs-comment">//拿来做事</span>  &#125;&#125;</code></pre></li><li><p>Fragment从Activity获取数据</p></li></ol><h3 id="Fragment与Fragment通信"><a href="#Fragment与Fragment通信" class="headerlink" title="Fragment与Fragment通信"></a>Fragment与Fragment通信</h3><blockquote><p>Fragment之间的通信需要通过Activity进行关联，不应该是直接的进行通信。</p></blockquote><p>实现通信步骤主要有以下三步：</p><ol><li>定义接口</li><li>Activity实现接口</li><li>在接口方法中Activity调用对应Fragment</li></ol><h2 id="Fragment常见问题"><a href="#Fragment常见问题" class="headerlink" title="Fragment常见问题"></a>Fragment常见问题</h2><h3 id="Fragment重叠"><a href="#Fragment重叠" class="headerlink" title="Fragment重叠"></a>Fragment重叠</h3><p>当<code>宿主Activity</code>因为被系统回收或者配置发生改变导致销毁重建时，会重新执行<code>onCreate()</code>，就有可能重新执行一次<code>Fragment</code>创建过程，然后又会新建一个<code>Fragment</code>。</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>&#123;  <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);  setContentView(R.layout.act_demo);  FragmentManager fm = getSupportFragmentManager();  FragmentTransaction ft = fm.beginTransaction();  DemoFragment demoFragment;    <span class="hljs-comment">//可能触发 内存重启</span>  <span class="hljs-keyword">if</span>(savedInstanceState!=<span class="hljs-keyword">null</span>)&#123;    List&lt;Fragment&gt; fragmentList = getSupportFragmentManager().getFragments();    <span class="hljs-keyword">for</span>(Fragment fragment : fragmentList)&#123;      <span class="hljs-keyword">if</span>(fragment <span class="hljs-keyword">instanceof</span> DemoFragment)      demoFragment = (DemoFragment)fragment    &#125;    <span class="hljs-comment">//直接显示已存在的fragment</span>    ft.show(demoFragment).commit();  &#125;<span class="hljs-keyword">else</span>&#123;    demoFragment = DemoFragment.newInstance();    ft.add(R.id.fragment,demoFragment);    ft.commit();  &#125;&#125;</code></pre><h3 id="Fragment懒加载"><a href="#Fragment懒加载" class="headerlink" title="Fragment懒加载"></a>Fragment懒加载</h3><blockquote><p>懒加载：只在要使用时才去加载数据，而不是在初始化时就加载完毕。</p></blockquote><p>在加载数据前需要先判断三种状态：</p><ul><li>数据是否已经加载过</li><li>Fragment是否已经调用到<code>onCreate()</code></li><li>界面对于用户是否可见</li></ul><h3 id="Fragment-startActivityForResult"><a href="#Fragment-startActivityForResult" class="headerlink" title="Fragment.startActivityForResult()"></a>Fragment.startActivityForResult()</h3><h4 id="Fragment启动，Activity获取结果"><a href="#Fragment启动，Activity获取结果" class="headerlink" title="Fragment启动，Activity获取结果"></a>Fragment启动，Activity获取结果</h4><pre><code class="hljs java">getActivity().startActivityForResult(...)</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode,<span class="hljs-keyword">int</span> resultCode,Intent data)</span></span>&#123;  <span class="hljs-keyword">super</span>.onActivityResult(requestCode,resultCode,data);&#125;</code></pre><h4 id="Fragment启动，Fragment获取结果"><a href="#Fragment启动，Fragment获取结果" class="headerlink" title="Fragment启动，Fragment获取结果"></a>Fragment启动，Fragment获取结果</h4><pre><code class="hljs java">startActivityForResult()  <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode,<span class="hljs-keyword">int</span> resultCode,Intent data)</span></span>&#123;  <span class="hljs-keyword">super</span>.onActivityResult(requestCode,resultCode,data);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> requestCode,<span class="hljs-keyword">int</span> resultCode,Intent data)</span></span>&#123;  <span class="hljs-keyword">super</span>.onActivityResult(requestCode,resultCode,data);&#125;</code></pre><blockquote><p>要求父Activity必须覆写了<code>onActivityResult()</code>且调用了<code>super.onActivityResult()</code>。</p></blockquote><h3 id="Fragment配合ViewPager使用"><a href="#Fragment配合ViewPager使用" class="headerlink" title="Fragment配合ViewPager使用"></a>Fragment配合ViewPager使用</h3><p>一般类似资讯类、新闻类App首页都会分成多个标签，在不同的标签会有不同的内容，这个时候就需要配合ViewPager来实现内容展示，关键在于对应的fragment是否需要进行销毁。</p><p>可用的Adapter分为两种：</p><ul><li><code>FragmentPagerAdapter</code>：对于不再需要的fragment，选择调用<code>detach()</code>，仅销毁视图并不会销毁fragment实例。</li><li><code>FragmentStatePagerAdapter</code>：再切换不同fragment的时候，会把前面的fragment进行销毁，但是在系统销毁前，会存储其Fragment的Bundle，倒是需要重新创建Fragment时，可以从<code>onSaveInstanceState()</code>获取保存的数据。</li></ul><p>使用<code>FragmentStatePagerAdapter</code>比较省内存，但是销毁重建的过程也是需要时间的，如果页面较少可以使用<code>FragmentPageAdapter</code>，很多的话还是推荐<code>FragmentStatePagerAdapter</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
