<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>include、merge及ViewStub相关</title>
      <link href="/2019/01/03/include%E3%80%81merge-ViewStub%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/01/03/include%E3%80%81merge-ViewStub%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="主要解析include、merge及ViewStub"><a href="#主要解析include、merge及ViewStub" class="headerlink" title="主要解析include、merge及ViewStub"></a>主要解析include、merge及ViewStub</h1><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/布局优化之xml方面.png" class="full-image" alt="布局优化之xml方面" title="布局优化之xml方面"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><blockquote><p>主要为了解决重复定义相同布局的问题。把一套布局封装起来，需要使用时使用<include>标签引入。提高代码复用性</include></p><p>使用注意事项：</p><ol><li>如若我们在<include>中设置了android:id属性，这个id会覆盖原先`<include>中layout设置的布局id，所以在引用该id时需要注意</include></include></li><li>如果需要在<include>中需要使用andrdoid:**属性，必须要设置layout_width以及layout_height属性</include></li></ol></blockquote><p>源码分析：</p><p>从Activity创建开始，调用<code>setContentView()</code>传入对应xml文件，然后开始解析并绘制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/app/Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span></span>&#123;</span><br><span class="line">  <span class="comment">//getWindow() 对应的就是PhoneWindow </span></span><br><span class="line">  getWindow().setContentView(layoutResID);</span><br><span class="line">  initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ../com/android/internal/policy/PhoneWindow.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">        <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">        <span class="comment">// before this happens.</span></span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//初始化 DecorView</span></span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                    getContext());</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//渲染传进来的xml</span></span><br><span class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParent.requestApplyInsets();</span><br><span class="line">        <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ../android/view/LayoutInflater.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, root != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">        <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parser.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">          ...</span><br><span class="line">            <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">            <span class="comment">//如果是merge标签</span></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></span><br><span class="line">                                + <span class="string">"ViewGroup root and attachToRoot=true"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              ...</span><br><span class="line">                    rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析所有子控件</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rInflateChildren</span><span class="params">(XmlPullParser parser, View parent, AttributeSet attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">        rInflate(parser, parent, parent.getContext(), attrs, finishInflate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">            AttributeSet attrs, <span class="keyword">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> depth = parser.getDepth();</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="keyword">boolean</span> pendingRequestFocus = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">                parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">                pendingRequestFocus = <span class="keyword">true</span>;</span><br><span class="line">                consumeChildElements(parser);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_TAG.equals(name)) &#123;</span><br><span class="line">                parseViewTag(parser, parent, attrs);</span><br><span class="line">              <span class="comment">//解析到&lt;include&gt;标签</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;include /&gt; cannot be the root element"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">//解析include中包含的布局</span></span><br><span class="line">                parseInclude(parser, context, parent, attrs);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; must be the root element"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> View view = createViewFromTag(parent, name, context, attrs);</span><br><span class="line">                <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line">                <span class="keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</span><br><span class="line">                rInflateChildren(parser, view, attrs, <span class="keyword">true</span>);</span><br><span class="line">                viewGroup.addView(view, params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pendingRequestFocus) &#123;</span><br><span class="line">            parent.restoreDefaultFocus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//当系统解析完View之后调用</span></span><br><span class="line">        <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">            parent.onFinishInflate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseInclude</span><span class="params">(XmlPullParser parser, Context context, View parent,</span></span></span><br><span class="line"><span class="function"><span class="params">            AttributeSet attrs)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">      <span class="comment">// include标签必须在ViewGroup中使用</span></span><br><span class="line">      <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">         ...</span><br><span class="line">           <span class="comment">//解析android:layout 属性</span></span><br><span class="line">           <span class="keyword">int</span> layout = attrs.getAttributeResourceValue(<span class="keyword">null</span>, ATTR_LAYOUT, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (layout == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> String value = attrs.getAttributeValue(<span class="keyword">null</span>, ATTR_LAYOUT);</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"You must specify a layout in the"</span></span><br><span class="line">                            + <span class="string">" include tag: &lt;include layout=\"@layout/layoutID\" /&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                layout = context.getResources().getIdentifier(</span><br><span class="line">                        value.substring(<span class="number">1</span>), <span class="string">"attr"</span>, context.getPackageName());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (layout == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> String value = attrs.getAttributeValue(<span class="keyword">null</span>, ATTR_LAYOUT);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"You must specify a valid layout "</span></span><br><span class="line">                        + <span class="string">"reference. The layout ID "</span> + value + <span class="string">" is not valid."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (TAG_MERGE.equals(childName)) &#123;</span><br><span class="line">              rInflate(childParser, parent, context, childAttrs, <span class="keyword">false</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//继续渲染子布局</span></span><br><span class="line">              rInflateChildren(childParser, view, childAttrs, <span class="keyword">true</span>);</span><br><span class="line">              <span class="comment">//覆盖原有id</span></span><br><span class="line">              <span class="keyword">if</span> (id != View.NO_ID) &#123;</span><br><span class="line">                      view.setId(id);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          ...</span><br><span class="line">          group.addView(view);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>若存在<code>&lt;include&gt;</code>标签，会去解析<code>&lt;include&gt;</code>标签中的layout，解析完成后，会把解析得到的View加回到原有布局中。</p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><blockquote><p>减少层级布局，可以将<merge>标签下的子View直接添加到<merge>标签的parent中，可以减少不必要的层级。添加的子View遵循父布局的布局方式。</merge></merge></p><p><code>&lt;merge&gt;</code>标签一般和<code>&lt;include&gt;</code>标签搭配使用，<code>&lt;merge&gt;</code>标签不支持设置<code>android:**</code>属性，因为它不是View，只是声明了一些View。</p><p><em>使用<code>LayoutInflate.inflate(resId,viewroot,attachToRoot)</code>渲染时，第二个viewroot必须设置，且第三个参数必须为true。</em></p><p><strong><merge>标签最好是替代FlameLayout或者与父布局方向一致的LinearLayout</merge></strong></p></blockquote><p>上述源码中，<code>inflate()</code>执行时判断<code>name</code>为<code>TAG_MERGE</code>时就会直接调用<code>rInflate()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在普通xml中引用merge布局都是 通过include引用的 </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseInclude</span><span class="params">(XmlPullParser parser, Context context, View parent,</span></span></span><br><span class="line"><span class="function"><span class="params">            AttributeSet attrs)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">               <span class="keyword">final</span> View view = createViewFromTag(parent, name, attrs);  </span><br><span class="line">               <span class="comment">// 获取merge标签的parent  </span></span><br><span class="line">               <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;  </span><br><span class="line">               <span class="comment">// 获取布局参数  </span></span><br><span class="line">               <span class="keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);  </span><br><span class="line">               <span class="comment">// 递归解析每个子元素  </span></span><br><span class="line">               rInflate(parser, view, attrs, <span class="keyword">true</span>);  </span><br><span class="line">               <span class="comment">// 将子元素直接添加到merge标签的parent view中  </span></span><br><span class="line">               viewGroup.addView(view, params);  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码分析中可得 <merge>标签对应的View会直接添加至父容器中，减少一层布局。</merge></p><p>拓展：</p><ol><li>如果Activity布局的根节点为<code>FlameLayout</code>，可以直接替换为<code>&lt;merge&gt;</code>标签，执行<code>setContentView()</code>后可以减少一层布局</li><li>自定义View如果继承<code>LinearLayout</code>，可以把自定义View的布局文件根节点设置为<code>&lt;merge&gt;</code></li></ol><h2 id="ViewStub"><a href="#ViewStub" class="headerlink" title="ViewStub"></a>ViewStub</h2><blockquote><p>ViewStub继承了View，非常轻量级且宽高都为0，因为本身不参与任何的布局和绘制过程。主要用于 一些不常出现的界面可以按需加载，提高加载效率。</p></blockquote><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/ViewStub.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewStub</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//初始化ViewStub</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">ViewStub</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(attrs,</span><br><span class="line">                R.styleable.ViewStub, defStyleAttr, defStyleRes);</span><br><span class="line">        mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID);</span><br><span class="line">        mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, <span class="number">0</span>);</span><br><span class="line">        mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID);</span><br><span class="line">        a.recycle();</span><br><span class="line">        <span class="comment">//默认隐藏</span></span><br><span class="line">        setVisibility(GONE);</span><br><span class="line">        <span class="comment">//阻止View的绘制</span></span><br><span class="line">        setWillNotDraw(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">//设置宽高为0</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        setMeasuredDimension(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//空实现 不会绘制任何内容</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisibility</span><span class="params">(<span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInflatedViewRef != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//如果已经渲染完成 与普通View逻辑相同</span></span><br><span class="line">            View view = mInflatedViewRef.get();</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                view.setVisibility(visibility);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"setVisibility called on un-referenced view"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.setVisibility(visibility);</span><br><span class="line">            <span class="keyword">if</span> (visibility == VISIBLE || visibility == INVISIBLE) &#123;</span><br><span class="line">                <span class="comment">//需要渲染View</span></span><br><span class="line">                inflate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//渲染代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ViewParent viewParent = getParent();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (viewParent != <span class="keyword">null</span> &amp;&amp; viewParent <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mLayoutResource != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ViewGroup parent = (ViewGroup) viewParent;</span><br><span class="line">                <span class="comment">//添加并渲染View</span></span><br><span class="line">                <span class="keyword">final</span> View view = inflateViewNoAdd(parent);</span><br><span class="line">                <span class="comment">//移除原来定义的ViewStub 替换渲染的View上去</span></span><br><span class="line">                replaceSelfWithView(view, parent);</span><br><span class="line"></span><br><span class="line">                mInflatedViewRef = <span class="keyword">new</span> WeakReference&lt;&gt;(view);</span><br><span class="line">                <span class="keyword">if</span> (mInflateListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//监听渲染完成</span></span><br><span class="line">                    mInflateListener.onInflate(<span class="keyword">this</span>, view);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> view;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ViewStub must have a valid layoutResource"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ViewStub must have a non-null ViewGroup viewParent"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> View <span class="title">inflateViewNoAdd</span><span class="params">(ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LayoutInflater factory;</span><br><span class="line">        <span class="keyword">if</span> (mInflater != <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = mInflater;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            factory = LayoutInflater.from(mContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//渲染View</span></span><br><span class="line">        <span class="keyword">final</span> View view = factory.inflate(mLayoutResource, parent, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mInflatedId != NO_ID) &#123;</span><br><span class="line">          <span class="comment">//赋值设置的id到ViewStub渲染的View上</span></span><br><span class="line">            view.setId(mInflatedId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceSelfWithView</span><span class="params">(View view, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = parent.indexOfChild(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//移除本身存在的ViewStub</span></span><br><span class="line">        parent.removeViewInLayout(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">        <span class="comment">//以ViewStub自身设置的 LayoutParams为准 </span></span><br><span class="line">        <span class="keyword">if</span> (layoutParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.addView(view, index, layoutParams);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.addView(view, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述源码发现，<code>inflate()</code>只可以调用一次，否则会因移除ViewStub出错。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 布局优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Activity启动过程</title>
      <link href="/2019/01/02/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/01/02/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Java - 泛型</title>
      <link href="/2019/01/02/Java-%E6%B3%9B%E5%9E%8B/"/>
      <url>/2019/01/02/Java-%E6%B3%9B%E5%9E%8B/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>自定义ViewGroup实践</title>
      <link href="/2019/01/02/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/01/02/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h1 id="自定义ViewGrouop-FlowLayout"><a href="#自定义ViewGrouop-FlowLayout" class="headerlink" title="自定义ViewGrouop - FlowLayout"></a>自定义ViewGrouop - FlowLayout</h1>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义View实践</title>
      <link href="/2019/01/02/%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/01/02/%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h1 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h1><!--实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展-->]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>位运算</title>
      <link href="/2018/12/27/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2018/12/27/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>View的事件体系</title>
      <link href="/2018/12/25/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
      <url>/2018/12/25/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</url>
      <content type="html"><![CDATA[<!--MeasureSpec是什么？有什么作用？，自定义View/ViewGroup需要注意什么？invalidate()和postInvalidate()的区别？,invalidate和postInvalidate的区别及使用 Requestlayout，onlayout，onDraw，DrawChild区别与联系 View刷新机制 View绘制流程 计算一个view的嵌套层级 onMeasure的具体过程，先measure子view还是自己 onDraw的具体过程，先draw子view还是自己 实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展 view的工作原理及measure、layout、draw流程。哪一个流程可以放在子线程中去执行？draw方法中需要注意的问题？Invalidate、postInvalidate、requestLayout应用场景--><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View的事件体系.png" class="full-image" alt="View的事件体系" title="View的事件体系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h1 id="View的事件体系"><a href="#View的事件体系" class="headerlink" title="View的事件体系"></a>View的事件体系</h1><blockquote><p>在Android中任何一个与用户交互或者展示内容的控件都是由View拓展实现的。</p></blockquote><h2 id="View的基础知识"><a href="#View的基础知识" class="headerlink" title="View的基础知识"></a>View的基础知识</h2><p>View是Android中所有控件的基类，也包括ViewGroup。ViewGroup可以理解为View的组合，内部可以包含很多View以及ViewGroup，通过这种关系就形成了一个View树。</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View-Tree.png" class="full-image" alt="ViewTree" title="ViewTree"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>上层的控件主要负责测量与绘制下层的控件，并传递交互事件。</p><h3 id="1-View的位置参数"><a href="#1-View的位置参数" class="headerlink" title="1. View的位置参数"></a>1. View的位置参数</h3><h4 id="1-Android坐标系"><a href="#1-Android坐标系" class="headerlink" title="1.Android坐标系"></a>1.Android坐标系</h4><blockquote><p>在Android中，将屏幕左上角的顶点作为坐标原点，向右为X轴增大方向，向下为Y轴增大方向</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Android-Position.png" class="full-image" alt="Android坐标系" title="Android坐标系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="2-View坐标系"><a href="#2-View坐标系" class="headerlink" title="2.View坐标系"></a>2.View坐标系</h4><blockquote><p>View的位置由它的四个顶点决定，分别对应View的4个属性：<code>left(左上角横坐标)、top(左上角纵坐标)、right(右下角横坐标)，bottom(右下角纵坐标)</code>。</p><p><strong>这些坐标都是相对于View的父容器决定的。</strong></p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View-Position.png" class="full-image" alt="View坐标系" title="View坐标系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Left = getLeft();</span><br><span class="line">Right = getRight();</span><br><span class="line">Top = getTop();</span><br><span class="line">Bottom = getBottom();</span><br><span class="line">width = Right - Left;</span><br><span class="line">height = Bottom - Top;</span><br></pre></td></tr></table></figure><p>在Android3.0之后添加了几个新参数<code>x,y,translationX,translationY</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//X对应左上角横坐标 translationX指代x轴偏移量</span></span><br><span class="line">x = left + translationX;</span><br><span class="line"><span class="comment">//y对应左上角纵坐标 translationY指代y轴偏移量</span></span><br><span class="line">y = top + translationY;</span><br></pre></td></tr></table></figure><p><code>left是View的初始坐标，不会改变的；x是View偏移后的坐标，偏移后就会发生变化</code></p><p>Android系统也提供了相应的方法可以直接获取对应参数。但是，不能在初始时就去获取，由于那时View还没有开始绘制，获取的都是0；</p><p>如何获取可以参考这个 <a href="/2018/03/18/Android-Study-Plan-V/" title="Android Study Plan V">Android Study Plan V</a></p><h3 id="2-View触控"><a href="#2-View触控" class="headerlink" title="2.View触控"></a>2.View触控</h3><h4 id="1-MotionEvent"><a href="#1-MotionEvent" class="headerlink" title="1.MotionEvent"></a>1.MotionEvent</h4><p><code>MotionEvent</code>：提供点击事件的事件行为以及事件发生的x,y坐标，典型事件由：</p><ul><li><strong>ACTION_DOWN</strong>：监听用户手指按下的操作，一次按下标志触摸事件的开始。</li><li><strong>ACTION_MOVE</strong>：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。</li><li><strong>ACTION_UP</strong>：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。</li><li><strong>ACTION_CANCEL</strong>：当用户保持按下操作，并把手指移动到了控件外部局域时且父View处理事件触发。</li></ul><blockquote><p>事件列：从手指接触屏幕到离开屏幕，产生的一系列事件。</p><p>任何事件列都是<strong>从ACTION_DOWN开始到ACTION_UP结束，中间会穿插着ACTION_MOVE事件</strong></p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View-Touch-Position.png" class="full-image" alt="Android触摸点坐标系" title="Android触摸点坐标系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getX 以及 getY 返回当前触摸点距离View左上角的x，y坐标 -- 相对坐标</span><br><span class="line">getRawX 以及 getRawY 返回当前触摸点距离整个屏幕的x,y坐标 -- 绝对坐标</span><br></pre></td></tr></table></figure><h4 id="2-TouchSlop"><a href="#2-TouchSlop" class="headerlink" title="2.TouchSlop"></a>2.TouchSlop</h4><p><code>TouchSlop</code>：系统所能识别的被人误是<strong>滑动的最小距离</strong>。当手指在屏幕上滑动时，如果滑动的距离小于这个值，就不会认为在进行滑动操作。</p><p>利用<code>ViewConfiguration.get(getContext()).getScaledTouchSlop()</code>获取该常亮</p><h4 id="3-VelocityTracker"><a href="#3-VelocityTracker" class="headerlink" title="3.VelocityTracker"></a>3.VelocityTracker</h4><p><code>VelocityTracker</code>：速度追踪，用于追踪在手指滑动过程中的速度，包括水平和垂直方向的速度</p><p>样例演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建速度追踪对象</span></span><br><span class="line">VelocityTracker velocityTracker = VelocityTracker.obtain();</span><br><span class="line">velocityTracker.addMovement(event);</span><br><span class="line"><span class="comment">//计算速度</span></span><br><span class="line">velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//获取水平速度</span></span><br><span class="line"><span class="keyword">float</span> xVelocity = velocityTracker.getXVelocity();</span><br><span class="line"><span class="comment">//获取垂直速度</span></span><br><span class="line"><span class="keyword">float</span> yVelocity = velocityTracker.getYVelocity();</span><br><span class="line"><span class="comment">//重置并回收内存</span></span><br><span class="line">velocityTracker.clear();</span><br><span class="line">velocityTracker.recycle();</span><br></pre></td></tr></table></figure><h4 id="4-GestureDetector"><a href="#4-GestureDetector" class="headerlink" title="4.GestureDetector"></a>4.GestureDetector</h4><p><code>GestureDetector</code>：手势检测，用于辅助检测用户的单击、滑动、长按，双击等行为。</p><p>样例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector mGestureDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>);<span class="comment">//实例化一个GestureDetector对象</span></span><br><span class="line">mGestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);<span class="comment">// 解决长按屏幕后无法拖动的现象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接管目标View的onTouchEvent事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> consume = mGestureDetector.onTouchEvent(event);</span><br><span class="line">    <span class="keyword">return</span> consume</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><blockquote><p>Android由于手机屏幕比较小，为了呈现更多的内容就需要滑动来展示。</p></blockquote><h3 id="1-使用scrollTo-scrollBy"><a href="#1-使用scrollTo-scrollBy" class="headerlink" title="1.使用scrollTo()/scrollBy()"></a>1.使用scrollTo()/scrollBy()</h3><blockquote><p><code>scrollTo()</code>以及<code>scrollBy()</code>是由View本身提供的滑动方法。<strong>只对View的内容进行滑动，而不能使View本身滑动。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scrollTo(x,y)</code>表示移动到一个具体的坐标点 绝对滑动</p><p><code>scrollBy(x,y)</code>表示移动的增量为x,y，即在原有位置上移动x,y的距离 相对滑动</p><p><code>mScrollX和mScrollY分别表示View在X,Y方向的滚动距离。</code></p><p><code>mScrollX</code>：View的左边缘减去View的内容的左边缘  <strong>从右向左为正，反之为负</strong></p><p><code>mScrollY</code>：View的上边缘减去View的内容的上边缘  <strong>从下向上为正，反之为负</strong> </p><h3 id="2-使用动画"><a href="#2-使用动画" class="headerlink" title="2.使用动画"></a>2.使用动画</h3><blockquote><p>通过动画给View增加平移效果。通过改变View自身的<code>translationX</code>和<code>translationY</code>属性达到滑动效果。</p></blockquote><p>普通动画：新建<code>translate.xml</code>动画文件，定义好tranlate属性即可实现滑动动画。</p><p>普通动画并不能修改View的位置参数，只是执行了一个动画，实际位置还是初始地方。</p><p>属性动画：<code>ObjectAnimator.ofFloat(view,&quot;translationX&quot;,0,300).setDuration(1000).start();</code>即可实现动画</p><p>属性动画真正对View的位置参数进行修改，所以对应时间都是跟随的。</p><h3 id="3-改变布局参数"><a href="#3-改变布局参数" class="headerlink" title="3.改变布局参数"></a>3.改变布局参数</h3><blockquote><p>改变View的<code>LayoutParams</code>使得View重新布局。</p></blockquote><p>滑动时，可以对<code>LaqyoutParams</code>的<code>margin</code>相关参数进行加减就可以实现滑动。</p><h3 id="4-弹性滑动"><a href="#4-弹性滑动" class="headerlink" title="4.*弹性滑动"></a>4.*弹性滑动</h3><blockquote><p>上述提到的方案除了动画，滑动都是很生硬的，就是闪烁过去的。所以需要实现弹性滑动(渐进式滑动)。</p></blockquote><h4 id="1-Scroller"><a href="#1-Scroller" class="headerlink" title="1. *Scroller"></a>1. *<code>Scroller</code></h4><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Scroller scroller = <span class="keyword">new</span> Scroller(mContext); <span class="comment">//实例化一个Scroller对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> dstX, <span class="keyword">int</span> dstY)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> scrollX = getScrollX();<span class="comment">//View的左边缘到其内容左边缘的距离</span></span><br><span class="line">  <span class="keyword">int</span> scrollY = getScrollY();<span class="comment">//View的上边缘到其内容上边缘的距离</span></span><br><span class="line">  <span class="keyword">int</span> deltaX = dstX - scrollX;<span class="comment">//x方向滑动的位移量</span></span><br><span class="line">  <span class="keyword">int</span> deltaY = dstY - scrollY;<span class="comment">//y方向滑动的位移量</span></span><br><span class="line">  scroller.startScroll(scrollX, scrollY, deltaX, deltaY, <span class="number">1000</span>); <span class="comment">//开始滑动</span></span><br><span class="line">  invalidate(); <span class="comment">//刷新界面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span><span class="comment">//计算一段时间间隔内偏移的距离，并返回是否滚动结束的标记</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (scroller.computeScrollOffset()) &#123; </span><br><span class="line">    scrollTo(scroller.getCurrX(), scroller.getCurY());</span><br><span class="line">    postInvalidate();<span class="comment">//通过不断的重绘不断的调用computeScroll方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作原理：</p><p>构造<code>Scroller</code>对象时，内部没有做什么，只是保存了我们传递的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scroller</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scroller</span><span class="params">(Context context, Interpolator interpolator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, interpolator,</span><br><span class="line">                context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scroller</span><span class="params">(Context context, Interpolator interpolator, <span class="keyword">boolean</span> flywheel)</span> </span>&#123;</span><br><span class="line">        mFinished = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (interpolator == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInterpolator = <span class="keyword">new</span> ViscousFluidInterpolator();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInterpolator = interpolator;</span><br><span class="line">        &#125;</span><br><span class="line">        mPpi = context.getResources().getDisplayMetrics().density * <span class="number">160.0f</span>;</span><br><span class="line">        mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction());</span><br><span class="line">        mFlywheel = flywheel;</span><br><span class="line"></span><br><span class="line">        mPhysicalCoeff = computeDeceleration(<span class="number">0.84f</span>); <span class="comment">// look and feel tuning</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>保存完参数后，就需要调用<code>Scroller</code>的<code>startScroll()</code>方法，传入对应参数进行滑动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        mMode = SCROLL_MODE;</span><br><span class="line">        mFinished = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//滑动持续时间</span></span><br><span class="line">        mDuration = duration;</span><br><span class="line">        <span class="comment">//滑动开始时间</span></span><br><span class="line">        mStartTime = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">        <span class="comment">//滑动起点</span></span><br><span class="line">        mStartX = startX;</span><br><span class="line">        mStartY = startY;</span><br><span class="line">        <span class="comment">//滑动终点</span></span><br><span class="line">        mFinalX = startX + dx;</span><br><span class="line">        mFinalY = startY + dy;</span><br><span class="line">        <span class="comment">//滑动距离</span></span><br><span class="line">        mDeltaX = dx;</span><br><span class="line">        mDeltaY = dy;</span><br><span class="line">        mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用<code>startScroll()</code>后，我们调用了<code>invalidate()</code>导致View进行了重绘，重绘过程中调用了<code>draw()</code>方法，<code>draw()</code>中调用了对应的<code>computeScroll()</code>方法。<code>computeScroll()</code>中又调用了<code>Scroller</code>的<code>computeScrollOffset()</code>方法，使<code>Scroller</code>对应的<code>mCurrX以及mCurrY</code>发生变化，配合View自身的<code>scrollTo()</code>产生滑动事件。后续继续调用了<code>postInvalidate()</code>使View重绘，按照上述流程继续执行，直到动画完成为止。</p><p><strong>关键方法为<code>startScroll()</code>及<code>computeScroll()</code></strong></p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Scroller-Process.png" class="full-image" alt="Scroller工作机制" title="Scroller工作机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>总结一下原理：<strong>Scroller并不能使View进行滑动，他需要配合View的computeScroll()方法才能完成滑动效果。在computeScroll()中不断让View进行重绘，每次重绘需要计算滑动持续的时间，根据这个时间计算出应该滑动到的位置，然后调用了View本身的scrollTo()配合位置进行滑动，多次的短距离滑动形成了弹性滑动的效果。</strong></p><h4 id="2-动画"><a href="#2-动画" class="headerlink" title="2. 动画"></a>2. 动画</h4><p><a href="#2-使用动画">动画</a></p><h4 id="3-延时策略"><a href="#3-延时策略" class="headerlink" title="3. 延时策略"></a>3. 延时策略</h4><blockquote><p>通过发生一系列延时消息而达到一种渐进式的效果，具体可以使用<code>Handler,View.postDelayed()或者Thread.sleep()</code>实现</p></blockquote><p><em>如果要求精确的话，不建议使用延时策略实现。</em></p><h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><blockquote><p>View的事件分发本质就是<strong><a href="#1-MotionEvent">MotionEvent</a>事件的分发过程</strong>。当一个MotionEvent产生后，系统需要把该事件传递给一个具体的View.</p></blockquote><h3 id="点击事件传递规则"><a href="#点击事件传递规则" class="headerlink" title="点击事件传递规则"></a>点击事件传递规则</h3><p>点击事件的传递顺序为：<strong>Activity(Window) –&gt; ViewGroup –&gt; View</strong></p><p>事件分发过程中有3个重要的方法:</p><ul><li><p><code>dispathTouchEvent(MotionEvent event)</code></p><p>用来进行事件的分发。</p></li><li><p><code>onInterceptTouchEvent(MotionEvent event)</code></p><p>用来进行事件的拦截，在<code>dispatchOnTouchEvent()</code>内部中调用，返回结果表明是否拦截事件，<em>View中是没有该方法的</em></p></li><li><p><code>onTouchEvent(MotionEvent event)</code></p><p>用来处理点击事件，在<code>dispatchOnTouchEvent()</code>内部中调用，返回结果表明是否消耗当前事件</p></li></ul><blockquote><p>在Android系统中，可以处理事件传递的类有以下三种：</p><ul><li><strong>Activity</strong>：包含<code>dispatchTouchEvent</code>，<code>onTouchEvent</code>方法</li><li><strong>ViewGroup</strong>：包含<code>dispatchTouchEvent</code>，<code>onInterceptTouchEvent</code>，<code>onTouchEvent</code></li><li><strong>View</strong>：包含<code>dispatchTouchEvent</code>，<code>onTouchEvent</code>方法</li></ul></blockquote><p>可以用如下伪代码体现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(onInterceptTouchEvent(ev))&#123;</span><br><span class="line">        <span class="comment">//被拦截调用自身的onTouchEvent()处理点击事件</span></span><br><span class="line">        consume = onTouchEvent(event);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//没有拦截继续放行，执行子View的dispatchTouchEvent()</span></span><br><span class="line">        consume = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/TouchEvent-Transmit.png" class="full-image" alt="事件分发" title="事件分发"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><code>super</code>：调用父类方法</li><li><code>true</code>：消费事件，即事件不会往下传递</li><li><code>false</code>：不消费事件，事件继续往下传递(<code>onInterceptTouchEvent()</code>)/交由父布局处理事件(<code>onTouchEvent</code>，<code>dispatchTouchEvent</code>)</li></ul><p>简单的总结一下流程：<strong>Activity.dispatchTouchEvent() -&gt; ViewGroup.dispatchTouchEvent() -&gt; ViewGroup.onInterceptTouchEvent() -&gt; View.dispatchTouchEvent() -&gt;  View.onTouch() -&gt; View.onTouchEvent() -&gt; View.onClick()</strong></p><h3 id="事件分发的源码解析"><a href="#事件分发的源码解析" class="headerlink" title="事件分发的源码解析"></a>事件分发的源码解析</h3><h4 id="Activity的事件分发机制"><a href="#Activity的事件分发机制" class="headerlink" title="Activity的事件分发机制"></a>Activity的事件分发机制</h4><p>当一个点击事件发生时，事件最先传递到的就是<code>Activity.dispatchTouchEvent(MotionEvent ev)</code>中进行事件分发。<em>具体工作是由Activity的Window来完成的。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..android/app/Activity.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若dispatchTouchEvent返回true，事件到此结束，返回false，继续向下传递</span></span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当activity在栈顶时，点击，触摸或者点击通知栏都会触发 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserInteraction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ../com/android/internal/policy/PhoneWindow.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* getWindow().superDispatchTouchEvent(ev)</span></span><br><span class="line"><span class="comment">* getWindow()指向的是Window对象的一个实例，在Android中Window的唯一实现就是PhoneWindow</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//mDecor 是DecorView的一个实例，DecoeView就是顶层View中的实例对象</span></span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//../com/android/internal/policy/DecorView.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  mDecor.superDispatchTouchEvent(event)</span></span><br><span class="line"><span class="comment">*  mDecor 是DecorView的一个实例对象，DecorView是PhoneView的一个内部类，并且继承自FrameLayout</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用父类的方法即FrameLayout.dispatchTouchEvent = ViewGroup.dispatchTouchEvent()，由父类去处理事件分发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>onUserInteraction()</code>用户点击屏幕时最先被触发。</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Activity-Dispatch.png" class="full-image" alt="Activity事件分发" title="Activity事件分发"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>总结一下：按照上述流程图，当一个点击事件进来时，Activity上的事件流程如下：</p><ul><li>调用<code>Activity.dispatchTouchEvent()</code>，然后调用<code>onUserInteraction()</code></li><li>调用<code>getWindow()即PhoneWindow.superDispatchTouchEvent()</code></li><li>调用<code>mDecor即DecorView。superDispatchTouchEvent()</code></li><li>调用DecorView父类即<strong><code>ViewGroup.dispatchTouchEvent()</code></strong> 在这里实现了事件从Activity传递至ViewGroup</li></ul><h4 id="ViewGroup事件分发机制"><a href="#ViewGroup事件分发机制" class="headerlink" title="ViewGroup事件分发机制"></a>ViewGroup事件分发机制</h4><p>上述Activity事件分发，后面会走到<code>ViewGroup.dispatchTouchEvent()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"><span class="comment">//---- ViewGroup会在ACTION_DOWN时重置GroupFlags以免影响后续对ACTION_DOWN事件的处理----</span></span><br><span class="line">     <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                resetTouchState();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//--------</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//----判断当前事件是否需要拦截----   </span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">      <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN  <span class="comment">//必须是ACTION_DOWN事件，若为其他UP或MOVE事件不触发拦截机制</span></span><br><span class="line">                    || mFirstTouchTarget != <span class="keyword">null</span>) &#123; <span class="comment">//mFirstTouchTarget 若当前事件被拦截，则该值为null 反之不会空</span></span><br><span class="line">                <span class="comment">//FLAG_DISALLOW_INTERCEPT：禁止ViewGroup拦截除了DOWN以外的事件</span></span><br><span class="line">                <span class="comment">//可由View调用requestDisallowInterceptTouchEvent设置标记</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">                <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">                intercepted = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//--------    </span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//----ViewGroup不拦截分发事件，事件向下分发交由子View进行处理----        </span></span><br><span class="line">                           <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                        <span class="comment">//遍历当前ViewGroup下的所有子View 遍历为倒序，意味着从外到内遍历</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                    childrenCount, i, customOrder);</span><br><span class="line">                            <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                    preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">                            <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">                            <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">                            <span class="comment">// safer given the timeframe.</span></span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                                i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"><span class="comment">//如果View不可见或触摸点的坐标不在子View范围内，跳过本次循环</span></span><br><span class="line">                            <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                    || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            newTouchTarget = getTouchTarget(child);</span><br><span class="line">                            <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                                <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            resetCancelNextUpFlag(child);</span><br><span class="line"><span class="comment">//事件传递下来后，调用dispatchTransformedTouchEvent，事件就会传递到View中                     </span></span><br><span class="line">                            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                                <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                                <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                            mLastTouchDownIndex = j;</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mLastTouchDownX = ev.getX();</span><br><span class="line">                                mLastTouchDownY = ev.getY();</span><br><span class="line"><span class="comment">//返回true的话                                </span></span><br><span class="line">                                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                                alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">                            <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//如果 mfirstTouchTarget为空，ViewGroup默认拦截同一时间序列中的所有事件        </span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            <span class="comment">//child默认为空，直接调用父类的 dispatchTouchEvent()</span></span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否拦截事件分发</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//触发条件需要有 鼠标输入触发 正常操作都是触摸方式 所以可以看做默认false</span></span><br><span class="line">        <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件向下分发 子View或者子ViewGroup</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></span><br><span class="line">        <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有子View，向上回溯调用父类的dispatchTouchEvent</span></span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//包含子View，调用子类的dispatchTouchEvent</span></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mFirstTouchTarget其实是一种单链表结构</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(@NonNull View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">        target.next = mFirstTouchTarget;</span><br><span class="line">        mFirstTouchTarget = target;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ViewGroup-Dispatch.png" class="full-image" alt="ViewGroup事件分发" title="ViewGroup事件分发"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据上述流程图，总结一下：</p><ul><li>点击事件从上层传递到ViewGroup，先调用<code>ViewGroup.dispatchTouchEvent()</code></li><li>判断<code>ViewGroup.onInterceptTouchEvent()</code>是否拦截点击事件<ul><li>默认不拦截，则将事件继续向子View传递，然后调用<code>View.dispatchTouchEvent()</code></li><li>被拦截返回<code>true</code>，调用<code>super.dispatchTouchEvent()</code>返给父布局处理，并且ViewGroup自身也处理事件，比如<code>onTouch(),onClick(),onTouchEvent()</code>等事件</li></ul></li></ul><h4 id="View事件分发机制"><a href="#View事件分发机制" class="headerlink" title="View事件分发机制"></a>View事件分发机制</h4><p>上述ViewGroup事件分发后，就会调用到<code>View.dispatchTouchEvent()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> </span><br><span class="line">                &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span> <span class="comment">//View设置了onTouch事件</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED <span class="comment">//View是可操作状态的 isEnable=true</span></span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)<span class="comment">//View的onTouch返回为true</span></span><br><span class="line">               )&#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果result为true即上述条件通过 这个if条件就不会向下执行意味着onTouchEvent()不会被调用</span></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">     <span class="comment">//只要设置了点击事件 clickable = true</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line">     <span class="comment">//当View点击事件被禁止时，直接消耗点击事件</span></span><br><span class="line">     <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                setPressed(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">            <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">            <span class="comment">// events, it just doesn't respond to them.</span></span><br><span class="line">            <span class="keyword">return</span> clickable;</span><br><span class="line">        &#125;</span><br><span class="line">     ...</span><br><span class="line">      <span class="comment">//监听点击事件，并且需要配置Click事件才可以触发</span></span><br><span class="line">      <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">          <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                  <span class="comment">//当手指从屏幕离开时，触发对应的点击事件</span></span><br><span class="line">              <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                  <span class="comment">//没有配置点击事件的话 直接返回</span></span><br><span class="line">                  <span class="keyword">if</span> (!clickable) &#123;</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">                        mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                        mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                        <span class="comment">// take focus if we don't have it already and we should in</span></span><br><span class="line">                        <span class="comment">// touch mode.</span></span><br><span class="line">                        <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Only perform take click actions if we were in the pressed state</span></span><br><span class="line">                            <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                                <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                                <span class="comment">// performClick directly. This lets other visual state</span></span><br><span class="line">                                <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                                <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                    performClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际点击事件的触发位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">        <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">            <span class="comment">//调用对应的点击事件</span></span><br><span class="line">            li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">        notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View-Dispatch.png" class="full-image" alt="View事件分发" title="View事件分发"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据上述流程图，总结一下：</p><ul><li>点击事件从ViewGroup传递到View，调用<code>View.dispatchTouchEvent()</code></li><li>判断当前View是否设置<code>OnTouchListener</code>，并且设置了<code>onTouch()</code>返回值，默认返回false<ul><li>返回<code>true</code>，代表事件被<code>onTouch()</code>消费，不会继续往下传递</li><li>返回<code>false</code>，事件继续向下传递，调用<code>View.onTouchEvent()</code>，后续若设置点击事件，则继续调用<code>performClick()</code>，最后执行<code>onClick()</code>事件</li></ul></li></ul><p>拓展：</p><blockquote><ol><li>如果有一个控件是<code>DISABLED</code>，注册的<code>onTouch()</code>事件不会被执行。若要监听点击事件，只能实现它的<code>onTouchEvent()</code></li><li>点击事件优先级： <code>onTouch()</code> &gt; <code>onTouchEvent()</code> &gt; <code>performClick()</code> &gt; <code>onClick()</code> </li></ol></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>点击事件传递从<code>dispatchTouchEvent()</code>开始，在不修改默认返回值时，事件会按照嵌套层次由外向内传递，到达最内层View时，由最内层View<code>onTouchEvent()</code>处理</li><li>事件在传递过程中，返回参数设为<code>true</code>，事件会被提前消费，不向下继续传递</li><li>View的点击事件触发顺序为  <code>onTouch()</code> &gt; <code>onTouchEvent()</code> &gt; <code>performClick()</code> &gt; <code>onClick()</code> </li></ol><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol><li><em>Touch事件的后续(例如<code>ACTION_MOVE</code>,<code>ACTION_UP</code>)层级传递</em><ul><li>若<code>dispatchTouchEvent()</code>返回true，那么能收到<code>ACTION_DOWN</code>的函数也可以收到后续事件</li><li>若<code>onTouchEvent()</code>返回true，那么其他事件不再往下传递，而是直接传给自己的<code>onTouchEvent()</code>并结束本次事件传递</li></ul></li></ol><h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2><h3 id="滑动冲突场景"><a href="#滑动冲突场景" class="headerlink" title="滑动冲突场景"></a>滑动冲突场景</h3><h4 id="外部滑动和内部滑动方向不一致"><a href="#外部滑动和内部滑动方向不一致" class="headerlink" title="外部滑动和内部滑动方向不一致"></a>外部滑动和内部滑动方向不一致</h4><p><em>外层ViewGroup是可以横向滑动的，内层View是可以竖向滑动的。</em>例如：ViewPager嵌套ListView</p><h4 id="外部滑动和内部滑动方向一致"><a href="#外部滑动和内部滑动方向一致" class="headerlink" title="外部滑动和内部滑动方向一致"></a>外部滑动和内部滑动方向一致</h4><p><em>外层ViewGroup是可以竖向滑动的，内层View是也可以竖向滑动的。</em>例如：ScrollView嵌套ListView</p><h4 id="两种情况的嵌套"><a href="#两种情况的嵌套" class="headerlink" title="两种情况的嵌套"></a>两种情况的嵌套</h4><h3 id="滑动冲突处理规则"><a href="#滑动冲突处理规则" class="headerlink" title="滑动冲突处理规则"></a>滑动冲突处理规则</h3><h4 id="内外滑动方向不一致-处理规则"><a href="#内外滑动方向不一致-处理规则" class="headerlink" title="内外滑动方向不一致 处理规则"></a>内外滑动方向不一致 处理规则</h4><p><strong>根据滑动是水平滑动还是竖直滑动来判断由谁来拦截事件。</strong>可以得到滑动过程中两个点的坐标，依据滑动路径与水平方向形成的夹角(<code>斜率</code>)判断，或者水平和竖直方向滑动的距离差进行判断。<em>在ViewPager中当斜率小于0.5时判断为水平滑动。</em></p><h4 id="内外滑动方向一致-处理规则"><a href="#内外滑动方向一致-处理规则" class="headerlink" title="内外滑动方向一致 处理规则"></a>内外滑动方向一致 处理规则</h4><p>一般从业务上找突破点。根据业务需求，规定何时让外部View拦截事件何时由内部View拦截事件。</p><h4 id="嵌套滑动-处理规则"><a href="#嵌套滑动-处理规则" class="headerlink" title="嵌套滑动 处理规则"></a>嵌套滑动 处理规则</h4><p>滑动规则更复杂，所以还是要从业务代码上下手。</p><h3 id="滑动冲突解决方案"><a href="#滑动冲突解决方案" class="headerlink" title="滑动冲突解决方案"></a>滑动冲突解决方案</h3><h4 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h4><blockquote><p>点击事件都先经过<strong>父容器的拦截处理</strong>，如果父容器需要此事件就拦截，不需要就放行</p></blockquote><p>需要重写父容器的<code>onInterceptTouchEvent()</code>，在方法内部做相应的拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>)ev.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>)ev.getY();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span>(ev.getAction())&#123;</span><br><span class="line">        <span class="comment">//ACTION_DOWN必须返回false，否则后续事件无法向下传递</span></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">        <span class="keyword">if</span>(父容器需要处理该事件)&#123;</span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//ACTION_UP事件必须返回false，否则子容器无法相应 onClick事件</span></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否拦截需要在<code>ACTION_MOVE</code>中进行判断，父容器需要拦截事件返回true，反之返回false。</p><h4 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h4><blockquote><p>父容器不拦截任何事件，所有事件交由子容器进行处理，如果子容器需要就消耗事件，不需要就返给父容器处理。</p></blockquote><p>需要同时重写父容器的<code>onInterceptTouchEvent()</code>以及子容器的<code>dispatchTouchEvent()</code>。需要配合<strong><code>requestDisallowInterceptTouchEvent</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子View</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x= (<span class="keyword">int</span>)ev.getX();</span><br><span class="line">    <span class="keyword">int</span> y= (<span class="keyword">int</span>)ev.getY();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">switch</span>(ev.getAction())&#123;</span><br><span class="line">        <span class="comment">//ACTION_DOWN必须返回false，否则后续事件无法向下传递</span></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">//使父布局跳过所有拦截事件</span></span><br><span class="line">        parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">          <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y- mLastY ;</span><br><span class="line">    <span class="keyword">if</span>(父容器需要处理事件)&#123;</span><br><span class="line">        parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//ACTION_UP事件必须返回false，否则子容器无法相应 onClick事件</span></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父容器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">    <span class="keyword">if</span>(action == MotionEvent.ACTION_DOWN)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方法相比较而言，<code>外部拦截法</code>相比<code>内部拦截法</code>实现起来更加简单，而且符合View的事件分发，推荐使用<code>外部拦截法</code>。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-简单实现Router功能</title>
      <link href="/2018/12/24/Android-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0Router%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/12/24/Android-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0Router%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>BockingQueue阻塞队列</title>
      <link href="/2018/12/24/BockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>/2018/12/24/BockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Android-线程相关</title>
      <link href="/2018/12/21/Android-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/12/21/Android-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<!--AsyncTask 内部实现--><h1 id="Android中的线程"><a href="#Android中的线程" class="headerlink" title="Android中的线程"></a>Android中的线程</h1><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Android-Thread-Type.png" class="full-image" alt="Android线程" title="Android线程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>在Android中进程一般指代App，线程又分为</p><ul><li>主线程：进程所拥有的线程，默认情况下一个进程只有一个线程，这个线程就是主线程。Android中对应UI线程</li><li>子线程：工作线程，除主线程以外的线程都是工作线程。Android中的子线程的作用是处理耗时任务，比如网络请求，IO操作。</li></ul><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><a href="/2018/12/19/Java多线程基础/" title="Java多线程基础">Java多线程基础</a><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><blockquote><p>轻量级的异步任务，可以在线程池中执行后台任务，</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构-红黑树</title>
      <link href="/2018/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2018/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>RecycleView简析</title>
      <link href="/2018/12/20/RecycleView%E7%AE%80%E6%9E%90/"/>
      <url>/2018/12/20/RecycleView%E7%AE%80%E6%9E%90/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Android性能优化</title>
      <link href="/2018/12/20/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/12/20/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReenTrantLock关键字分析</title>
      <link href="/2018/12/19/ReenTrantLock%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/19/ReenTrantLock%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="ReenTrantLock"><a href="#ReenTrantLock" class="headerlink" title="ReenTrantLock"></a>ReenTrantLock</h1><blockquote><p>一个可重入的互斥锁，具备一样的线程重入特性</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>尝试获得锁</li><li>获取到锁的线程能够相应中断</li></ul><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><blockquote><p>在Java中锁是用来控制多个线程访问共享资源的方式。在Java SE5.0之后新增Lock接口。提供了与<code>synchronized</code>关键字类似的同步功能，只是在使用时需要显式的获取和释放锁，缺点就是无法像<code>synchronized</code>可以隐式的释放锁，但是可以自由操作获取锁和释放锁。</p></blockquote><p><code>void lock()</code>：执行时，如果锁处于空闲状态，当前线程将获得锁。如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获得锁。</p><p><code>boolean tryLock()</code>：如果锁可用，则获取锁，并返回true，否则返回false。该方法只是试图获取锁，如果锁已被其他线程持有，当前线程不会被禁用，会继续向下执行代码。</p><p><code>void unlock</code>：当前线程将释放持有锁，<strong>锁只能由持有者释放，如果线程并不持有锁，执行该方法，可能导致异常的发生。</strong></p><p><code>Condition newCondition()</code>：条件对象，获取等待通知组件。该组件会与当前锁绑定，当前线程只有获取了锁，才能调用组件的<code>await()</code>方法，调用后，线程释放锁。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReenTrantLockTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得同步锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            System.err.println(<span class="string">"获取锁"</span> + System.currentTimeMillis());</span><br><span class="line">            condition.await();</span><br><span class="line">            System.err.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (</span><br><span class="line">                InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放同步锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReenTrantLockTest test = <span class="keyword">new</span> ReenTrantLockTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.err.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比<code>synchronized</code>增加了一些高级功能：</p><ul><li><p><strong>等待可中断</strong>：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，去操作其他事情。</p></li><li><p><strong>公平锁</strong>：<code>多个线程在等待同一个锁时，必须按照申请锁的时间来依次获得锁。</code> <code>synchronized</code>是非公平锁，即<code>在锁被释放时，任何一个等待锁的线程都有机会获得锁。</code>这样就有可能会产生 <strong>饥饿现象(有些线程可能永远无法获得锁)</strong>。<code>ReenTrantLock</code>默认非公平锁，在构造时修改参数即可变为公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFairTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//true为公平锁  false为非公平锁 默认false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    AtomicInteger iii = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iii.get() &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            iii.getAndIncrement();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + <span class="string">"获得锁"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockFairTest test = <span class="keyword">new</span> LockFairTest();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(test);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">公平锁：</span><br><span class="line">Thread-<span class="number">0</span>获得锁</span><br><span class="line">Thread-<span class="number">1</span>获得锁</span><br><span class="line">Thread-<span class="number">2</span>获得锁</span><br><span class="line">Thread-<span class="number">3</span>获得锁</span><br><span class="line">非公平锁：</span><br><span class="line">Thread-<span class="number">2</span>获得锁</span><br><span class="line">Thread-<span class="number">2</span>获得锁</span><br><span class="line">Thread-<span class="number">2</span>获得锁</span><br><span class="line">Thread-<span class="number">2</span>获得锁</span><br></pre></td></tr></table></figure></li><li><p><strong>锁绑定多个条件</strong>：一个<code>ReenTrantLock</code>对象可以通过多次调用<code>newCondition()</code>同时绑定多个<code>Condition</code>对象。在<code>synchronized</code>只能实现一个隐含的条件，要多关联只能额外添加锁。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Lock类可以实现线程同步，获得锁需要执行<code>lock</code>，释放锁使用<code>unlock</code></li><li>Lock分为公平锁(按照顺序)和不公平锁(不按顺序)</li><li>Lock还有读锁和写锁</li></ul><h2 id="自定义重入锁"><a href="#自定义重入锁" class="headerlink" title="自定义重入锁"></a>自定义重入锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomReetrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    Thread lockedBy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lockedCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread callThread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (isLocked &amp;&amp; lockedBy != Thread.currentThread()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">        lockedCount++;</span><br><span class="line">        lockedBy = callThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == <span class="keyword">this</span>.lockedBy) &#123;</span><br><span class="line">            lockedCount--;</span><br><span class="line">            <span class="keyword">if</span> (lockedCount == <span class="number">0</span>) &#123;</span><br><span class="line">                isLocked = <span class="keyword">false</span>;</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM相关及其拓展(七) — 线程安全与锁优化</title>
      <link href="/2018/12/19/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%83/"/>
      <url>/2018/12/19/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%83/</url>
      <content type="html"><![CDATA[<h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><blockquote><p>首先需要并发的正确性，然后在此基础上实现高效。</p></blockquote><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</p></blockquote><p>线程安全的代码必须具备一个特征：<strong>代码本身封装了所有必要的正确保障性手段，令调用者无需关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。</strong></p><p>线程安全的“安全程度”由强至弱分为以下5类：</p><ul><li><h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><blockquote><p>只要一个不可变的对象被正确的构建出来，那其外部的可见状态永远不会改变</p><p><code>不发生 this引用逃逸 情况下成立 -- 在构造函数返回之前，其他线程已经取得了该对象的引用。</code></p></blockquote><p>实现方案：</p><ul><li>如果共享数据是一个<code>基本数据类型</code>，只要在定义时用<code>final</code>修饰</li><li>如果共享数据是一个<code>对象</code>，最简单的就是 吧对象中带有状态的变量都声明为final</li></ul><p>符合不可变要求的类型：<code>String、枚举类(Enum)、Long，Double以及BigInteger等大数据类型</code></p></li><li><h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><blockquote><p>完全满足线程安全的定义，即达到”不管运行环境如何，调用者都不需要任何额外的同步措施。”</p></blockquote></li><li><h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><blockquote><p>保证对这个对象单独的操作是线程安全的，调用时不需做额外的保障措施，但是对于一些特定顺序的连续调用，就需要在调用端使用额外的同步手段保证调用的正确性。</p></blockquote><p>大部分的线程安全类都属于这种类型，例如<code>Vector,HashTable,synchronizedCollection()</code></p></li><li><h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><blockquote><p>对象本身并非线程安全，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全的使用。</p></blockquote><p>例如<code>ArrayList,HashMap</code></p></li><li><h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><blockquote><p>无论调用端是否采取了同步措施，都无法在多线程环境中并发使用。<strong>应当尽量避免</strong></p></blockquote><p>例如<code>Thread中的suspend()和resume()</code>。</p></li></ul><h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><blockquote><p>①通过代码实现线程安全 ②通过虚拟机本身实现同步与锁</p></blockquote><h3 id="互斥同步-阻塞同步"><a href="#互斥同步-阻塞同步" class="headerlink" title="互斥同步 (阻塞同步)"></a>互斥同步 (阻塞同步)</h3><blockquote><p><strong>同步</strong>：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只能被一个线程使用。</p><p><strong>互斥</strong>：实现同步的一种手段，<code>临界区、互斥量和信号量都是主要的互斥实现方法</code></p></blockquote><p><strong>互斥是因，同步是果；互斥是方法，同步是目的</strong></p><p><strong>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），就会出现问题，无论共享数据是否真的会出现数据竞争，都要进行加锁。</strong></p><p>实现手段：</p><ul><li><p><strong>synchronized</strong></p><a href="/2018/12/18/synchorized关键字分析/" title="synchronized关键字分析">synchronized关键字分析</a></li><li><p><strong>ReentrantLock</strong></p><a href="/2018/12/19/ReenTrantLock关键字分析/" title="ReenTrantLock关键字分析">ReenTrantLock关键字分析</a></li></ul><p><code>synchronized</code>和<code>ReentrantLock</code>的异同：</p><ul><li><p>两者都是<strong>可重入锁</strong>  <!--自己实现一个可重入锁--></p><blockquote><p><strong>可重入锁</strong>：当一个线程得到一个对象锁后，再次请求该对象锁时是可以再次得到该对象锁的。<strong>自己可以再次获得自己的内部锁。</strong></p></blockquote></li><li><p><code>synchronized</code>依赖于JVM而<code>ReentrantLock</code>依赖于API</p><p><code>synchronized</code>底层用<strong>Mutex(互斥量)</strong>实现，<code>ReentrantLock</code>继承自<code>Lock接口</code>,Lock接口又依赖于AQS实现</p></li><li><p><code>synchronized</code>的锁状态无法在代码中判断，<code>ReentrantLock</code>通过<code>isLocked()</code>判断</p></li><li><p><code>synchronized</code>非公平锁，另一个可以是公平也可以是非公平的</p></li><li><p><code>synchronized</code>不可被中断，另一个调用<code>lockInterrupbity()</code>即可中断</p></li><li><p><code>ReentrantLock</code>可以提高多个线程的读操作的效率</p></li></ul><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><blockquote><p>基于冲突检测的乐观并发策略，即先进性操作，若无其他线程争用共享数据，操作成功；反之，产生了冲突再去采用其他的补偿措施（<strong>最常见自旋——不停重试，直到成功为止</strong>）。</p></blockquote><p>为了保证<strong>操作和冲突检测</strong>具备原子性，需要用到硬件指令集，比如：</p><ul><li>测试并设置</li><li>获取并增加</li><li>交换</li><li><strong><em>比较并交换(CAS)</em></strong></li><li>加载链接/条件存储</li></ul><a href="/2018/12/18/Atomic原子操作类分析/" title="CAS操作&Atomic原子操作类分析">CAS操作&Atomic原子操作类分析</a><h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><blockquote><p>不用同步的方式保证线程安全，因为有些天生就是安全的。</p></blockquote><p>有以下两类：</p><ul><li><h4 id="可重入代码-纯代码-Reentrant-Code-Pure-Code"><a href="#可重入代码-纯代码-Reentrant-Code-Pure-Code" class="headerlink" title="可重入代码/纯代码(Reentrant Code/Pure Code)"></a>可重入代码/纯代码(Reentrant Code/Pure Code)</h4><blockquote><p>在代码执行的时候在任何时刻去中断，再去执行另外的代码，在控制权返回后，原来的程序不会出现任何的错误。</p></blockquote><p><strong>可重入性是它的基本特征，满足可重入性的代码一定是线程安全的，反之，满足线程安全的代码不一定是可重入的。</strong></p><p>共同特征：不依赖存储在堆上的数据和公用的系统资源、用到的状态栏都由参数中传入、不调用非可重入的方法等</p><p>判定依据：<strong>返回结果是可预测的，只要是输入了相同的数据就能返回相同的结果，就满足可重入性的要求。</strong></p></li><li><h4 id="线程本地存储-Thread-Local-Storage"><a href="#线程本地存储-Thread-Local-Storage" class="headerlink" title="线程本地存储(Thread Local Storage)"></a>线程本地存储(Thread Local Storage)</h4><blockquote><p>把共享数据的可见范围限制在同一个进程之内，无须同步也可以保证线程之间不出现数据争用的情况。</p></blockquote><p>使用<code>ThreadLocal</code>类可实现本地存储的功能。</p></li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><blockquote><p>锁优化是为了在线程之间更高效的共享数据，以及解决竞争性问题。</p><p>锁的状态共分为4种：<strong>无锁状态、偏向锁、轻量级锁和重量级锁</strong>。锁随着竞争情况可以升级，<strong>但升级后不能降级</strong>。</p><p><code>无锁状态-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</code></p></blockquote><h3 id="1-自旋锁与适应性自旋"><a href="#1-自旋锁与适应性自旋" class="headerlink" title="1. 自旋锁与适应性自旋"></a>1. 自旋锁与适应性自旋</h3><p>互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，影响系统的并发性能。同时，共享数据的锁定状态只会持续很短的一段时间，不值得去挂起和恢复线程。</p><p><strong>自旋锁</strong>：若物理机器有一个以上的处理器，能使多个线程同时并行执行，让后面的请求锁线程(通过自旋——<strong>CPU忙循环执行空指令</strong>)等待，但不放弃处理器的执行时间，看看持有锁的线程是否很快释放锁。</p><p><code>自旋等待不能代替阻塞，虽然避开了线程切换的开销，但要占用处理器时间，因此自旋等待必须有一定的上限，若超过了次数没有成功，就需要去挂起线程。</code></p><p><strong>自适应自旋锁</strong>：自旋时间不固定，由该锁上次的自旋时间及锁的拥有者状态决定。</p><ul><li>对于某个锁，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，JVM就会认为这次自旋也会再次成功获得锁，进而允许等待持续相对更长的时间</li><li>对于某个所，自选很少成功获得锁，以后再获取这个锁时可能忽略自旋过程，以避免浪费处理器资源。</li></ul><h3 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2. 锁消除"></a>2. 锁消除</h3><blockquote><p>JVM即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p></blockquote><p>判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为他们是线程私有的，同步加锁操作自然就无须进行。</p><p>例如<code>StringBuffer</code>对象的连续<code>append()</code></p><h3 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3. 锁粗化"></a>3. 锁粗化</h3><blockquote><p>JVM探测到一串零碎的操作都对同一对象进行加锁，将会把加锁同步的范围扩展（<strong>粗化</strong>）到整个操作序列的外代码</p></blockquote><h3 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="4. 轻量级锁"></a>4. 轻量级锁</h3><blockquote><p>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。<strong>轻量级锁并不是用来代替重量级锁的</strong></p></blockquote><p>必须先了解 HotSpot虚拟机的对象(<strong>对象头部分</strong>)的内存布局：分为两部分</p><ul><li><strong><em>Mark Word</em></strong>：存储自身的运行时数据，如：<code>HashCode、GC分代年龄和锁信息</code>，这部分数据的长度在32和64位中的JVM中分别为32bit和64bit。<strong>它是实现轻量级锁和偏向锁的关键。</strong></li><li>存储指向方法区对象类型数据的指针，如果是数组对象的话，额外会存储数据的长度。</li></ul><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/MarkWord.png" class="full-image" alt="Mark Word" title="Mark Word"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>加锁过程</p></blockquote><p>代码进入同步块时，如果同步对象未锁定(标记位为<code>01</code>)，虚拟机会在当前线程的栈帧中建立一个<code>锁记录(Lock Record)</code>的空间，用于存储对象目前的<code>Mark Word</code>拷贝（<strong>Displaced Mark Word</strong>）。</p><p>然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。</p><ul><li>更新成功，那么当前线程拥有了该对象的锁，且对象Mark Word的锁标志位为<code>00</code> ，处于轻量级锁定状态。</li><li>更新失败，JVM首先会检查对象的Mark Word是否指向当前线程的栈帧<ul><li>已指向表明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行</li><li>没指向表明该对象已被其他线程抢占。</li></ul></li></ul><p><strong>如果有两条以上的线程竞争同一个锁，轻量级锁就无法使用，需要膨胀为重量级锁，Mark Word的锁标志位变为<code>10</code>,存储的是指向重量级的指针，后面等待锁的也会进入阻塞状态。</strong></p><blockquote><p>解锁过程</p></blockquote><p>若对象的Mark Word仍然指向线程的Lock Record，那就用CAS操作把对象当前的Mark Word和Displaced Mark Word替换回来</p><ul><li>替换成功，就完成了整个同步过程</li><li>替换失败，说明有其他线程尝试获取锁，就要在释放锁的同时，唤醒被挂起的线程</li></ul><blockquote><p><code>栈帧</code>：用于支持虚拟西进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址信息。第一个方法从调用开始到执行完成，就是一个栈帧从入栈到出栈的过程。</p></blockquote><h3 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5. 偏向锁"></a>5. 偏向锁</h3><blockquote><p>消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。<strong>提高一个对象在很长一段时间内都只被一个线程用做锁对象场景下的性能。</strong></p><p><em>偏向锁可以提高带有同步但无竞争的程序性能。</em></p></blockquote><p>这个锁会偏向于第一个获得它的线程，如果后续该锁没有被其他线程获取，则持有偏向锁的线程将永远不会进行同步。</p><blockquote><p>加锁过程</p></blockquote><p>JVM启用了<code>偏向锁</code>模式，当锁对象第一次被线程获取的时候，JVM会把锁标记位置为<code>01</code>,即偏向模式。使用CAS操作记录锁的线程ID到Mark Word中。</p><ul><li>CAS操作成功。持有偏向锁的线程在每次进入和退出同步块是，只要比较一下Mark Word存储的线程ID是否相同。<ul><li>相同代表线程已经获得了锁，不需要再用CAS操作加锁和解锁</li><li>不同，就需要CAS操作竞争锁，竞争成功，替换Mark Word中的ThreadID为当前竞争线程的ID</li></ul></li></ul><blockquote><p>解锁过程</p></blockquote><p>当有另一个线程去尝试获取偏向锁时，CAS替换ThreadID失败，就要撤销偏向锁。(撤销偏向锁，需要等待原持有偏向锁的线程到达全局安全点<code>所有线程都是暂停的，没有字节码正在执行</code>，暂停线程，并检查状态)。判断原持有偏向锁的线程是否处于活动状态</p><ul><li>无活动则置为无锁状态(锁标志为<code>01</code>，是否偏向锁状态<code>0</code>)</li><li>还处于活动状态，则升级为轻量锁(标志位为<code>00</code>)</li></ul><blockquote><p>关闭偏向锁模式</p></blockquote><p>使用JVM参数 <code>-XX:BlasedLockingStartupDelay=0</code>可以关闭延迟，因为偏向锁需要应用启动后过几秒激活</p><p><code>-XX:UseBlasedLocking=false</code>关闭偏向锁</p><p>三种锁的升级</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/lock-upgrade.png" class="full-image" alt="锁的升级，锁的升级"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>三种锁的比较</p><table><thead><tr><th style="text-align:center">锁</th><th>优点</th><th>缺点</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">偏向锁</td><td>加锁和解锁不需要额外的消耗，与执行非同步方法相比仅存在纳秒级的差距</td><td>线程间存在锁竞争，需要带来额外锁撤销的消耗</td><td style="text-align:center">只有一个线程访问同步块场景</td></tr><tr><td style="text-align:center">轻量级锁</td><td>竞争的线程不会阻塞，提高程序的相应速度</td><td>始终得不到锁竞争的线程，会使用自旋消耗CPU资源</td><td style="text-align:center">追求相应时间，同步块执行速度非常快</td></tr><tr><td style="text-align:center">重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢</td><td style="text-align:center">追求吞吐量，同步块执行时间较长</td></tr></tbody></table><blockquote><p><strong>重量级锁</strong>：本质上是依赖操作系统的<code>Mutex Lock</code>互斥量来实现同步操作。由于线程间的切换需要从用户态转向核心态，转换成本较高，耗时相对较长。</p></blockquote><p><em>一个线程如何判断自己是否取得锁？</em></p><blockquote><p>线程在获取锁之前会判断对象的<code>Mark Word</code>中是否存放自己的<code>threadId</code>，存放且相同则重入；不同，则使用CAS进行切换，锁升级为<code>轻量级锁</code>，释放偏向锁，清空<code>Mark Word</code>，线程开始竞争，竞争成功的就存入自己的<code>ThreadId</code>，失败的开始自旋。</p></blockquote><h2 id="其他锁类型及其概念"><a href="#其他锁类型及其概念" class="headerlink" title="其他锁类型及其概念"></a>其他锁类型及其概念</h2><h3 id="1-乐观锁"><a href="#1-乐观锁" class="headerlink" title="1.乐观锁"></a>1.乐观锁</h3><blockquote><p>由于在进程挂起和恢复执行过程中需要很大的开销进行切换。所以有了乐观锁概念。</p><p>每次去拿数据的时候都认为别人不会修改，但在更新的时候会去判断在此期间是否数据发生修改，没有被修改则进行数据更新。如果因为修改过产生冲突就失败就重试到成功为止(<strong>自旋</strong>)。</p></blockquote><p>实例：例如<code>Atomic原子类</code></p><p>使用场景：适合读取操作比较频繁的场景</p><h3 id="2-悲观锁"><a href="#2-悲观锁" class="headerlink" title="2.悲观锁"></a>2.悲观锁</h3><blockquote><p>每次获取数据的时候，担心数据被修改，所以每次都要加锁，确保操作过程中数据不会发生改变，操作完成后再解锁让其他线程操作。</p><p>在某个资源不可用的时候，就将CPU让出，把当前等待的线程切换为阻塞状态。等到资源可用，将阻塞线程唤醒，进入Runnable状态等待CPU调度。</p></blockquote><p>实例：例如<code>synchronized</code> </p><p>使用场景：比较适合写入操作频繁的场景</p><h3 id="3-互斥锁"><a href="#3-互斥锁" class="headerlink" title="3.互斥锁"></a>3.互斥锁</h3><blockquote><p>通过<code>排他性</code>，同时只允许一个访问者对其进行访问来保证资源的有效同步，但无法限制线程对该资源的访问顺序</p></blockquote><h3 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.<strong>死锁</strong></h3><blockquote><p>两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，他们都将无法推进下去。</p></blockquote><p>死锁形成必须要求四个条件：</p><ul><li><p><strong>互斥条件</strong>：一个资源每次只能被一个线程使用</p></li><li><p><strong>请求与保持条件</strong>：一个线程引请求资源而阻塞时，对已获得的资源保持不放</p></li><li><strong>不剥夺条件</strong>：线程已获得的资源，在未使用完之前，不能强行剥夺</li><li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><p>常见死锁类型：</p><ul><li><p><strong>静态的锁顺序死锁</strong> <code>所有需要多个锁的线程，都要以相同的顺序获得锁</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lockB)&#123;</span><br><span class="line">                System.out.println(<span class="string">"func A"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lockA)&#123;</span><br><span class="line">                System.out.println(<span class="string">"func b"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>动态的锁顺序死锁</strong> <code>自定义锁的顺序，确保所有线程以相同的顺序获得锁</code></p></li><li><p><strong>协作对象之间发生的死锁</strong> <code>避免在持有锁的情况下调用外部的方法</code></p></li></ul><p>死锁预防：</p><ul><li><p>以确定的顺序获得锁</p><p>将所有的锁都按照特定顺序进行获取，防止死锁发生。</p><blockquote><p><strong>银行家算法</strong>：允许进程动态的申请资源，但在系统进行资源分配之前，先计算此次资源分配的安全性，若分配不会导致进入不安全状态，则分配；否则等待。</p></blockquote></li><li><p>超时放弃</p><blockquote><p>例如<code>synchronized</code>只要线程没有获得锁，就会永远等待下去，<code>Lock</code>提供了<code>tryLock()</code>可以实现超时放弃</p></blockquote></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java多线程基础</title>
      <link href="/2018/12/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/12/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<!--生成者-消费者模式 创建线程 为什么要使用多线程？会有什么问题 线程池概念以及实现原理、四种初始化方案 开线程影响那块区域 进程与线程 多线程断点续传 线程关闭以及防止线程的内存泄漏 线程池上限 为什么要有线程 并发 线程模型 wait和sleep的区别 控制允许并发访问的个数 自己实现线程安全类--><h1 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>操作系统结构的基础，是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单位。<code>进程就是程序的实体</code></p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>线程是进程的一个实体，是CPU调度和分配的基本单位，线程是一个比进程更小的执行单位，一个进程在执行期间可以产生多个线程。<code>一个进程至少一个线程</code>。一般应用于高并发场景，可以提高CPU的利用率。</p></blockquote><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><blockquote><p>每个进程都拥有自己独立的资源，多个进程可在单核处理器上并发执行，在多核处理器并行执行。</p></blockquote><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote><p>一个进程可由多个线程组成，多个线程共享进程内资源，多个线程可在单核处理器上并发执行，在多核处理器并行执行。解决多任务同时执行的需求，合理使用CPU资源。<strong>多线程具有不稳定性</strong></p></blockquote><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><blockquote><p>在一段时间内多个任务同时执行，或者说在一段时间内可以执行多条指令，微观上看起来就是同时运行多个进程。<strong>偏重于多个任务交替执行，有可能串行执行</strong></p></blockquote><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><blockquote><p>在同一时刻内多个任务同时执行，多核处理器才可以做到。<strong>偏重于同时执行。</strong></p></blockquote><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h3><p>两者的区别：</p><ul><li>多个进程间的内部数据和状态都是完全独立的，而多线程是共享一块内存空间和一组系统资源，有可能互相影响</li><li>线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以<strong>线程的切换负担比进程的切换负担小</strong></li><li>进程是重量级的任务，需要分配给他们独立的地址空间，进程间通信以及切换时很复杂的。</li></ul><h3 id="2-线程的实现"><a href="#2-线程的实现" class="headerlink" title="2. 线程的实现"></a>2. 线程的实现</h3><p>线程的实现一般有以下3中方法，前面两种比较常见：</p><ul><li><h4 id="继承Thread类，重写run-方法"><a href="#继承Thread类，重写run-方法" class="headerlink" title="继承Thread类，重写run()方法"></a>继承Thread类，重写<code>run()</code>方法</h4><blockquote><p><code>Thread</code>本质上是实现了<code>Runnable</code>接口的一个实例。<strong>调用<code>start()</code>后并不是立即执行代码，而是是线程的状态变为<code>Runnable</code>可运行态，何时运行由操作系统决定。</strong></p></blockquote><p>主要步骤：</p><ol><li>定义Thread类的子类，重写<code>run()</code>方法，<code>run()</code>方法内部代表了线程需要完成的任务，所以该方法又称<code>执行体</code></li><li>创建Thread类子类实例，即创建线程对象</li><li>调用线程对象的<code>start()</code>启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：</p><p>只调用<code>run()</code>和执行普通方法是一致的。</p></li><li><h4 id="实现Runnable接口，并实现run-方法"><a href="#实现Runnable接口，并实现run-方法" class="headerlink" title="实现Runnable接口，并实现run()方法"></a>实现Runnable接口，并实现<code>run()</code>方法</h4><p>主要步骤：</p><ol><li>自定义类实现<code>Runnable</code>，实现<code>run()</code>方法</li><li>创建Thread类子类实例，即创建Thread对象</li><li>调用实例的<code>start()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        RunnableTest runnable = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="实现Callable接口，重写call-方法需配合Future或者FutureTask"><a href="#实现Callable接口，重写call-方法需配合Future或者FutureTask" class="headerlink" title="实现Callable接口，重写call()方法需配合Future或者FutureTask"></a>实现Callable接口，重写<code>call()</code>方法需配合<code>Future</code>或者<code>FutureTask</code></h4><p>主要步骤：</p><ol><li>创建<code>Callable</code>接口实现类，并实现<code>call()</code>方法</li><li>创建<code>Callable</code>实现类的实例，使用<code>FutureTask</code>包装<code>Callable</code>对象</li><li>使用<code>FutureTask</code>对象作为Thread对象的target创建并启动新线程</li><li>调用<code>FutureTask</code>对象的<code>get()</code>方法获得子线程执行结束后的返回值，<strong>调用<code>get()</code>会阻塞线程</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello Callable"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyTestCallable myTestCallable = <span class="keyword">new</span> MyTestCallable();</span><br><span class="line">        <span class="comment">//利用futuretask </span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(myTestCallable);</span><br><span class="line">        Thread t =<span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.err.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用ExecutorService产生一个线程 结合future</span></span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        Future future = executorService.submit(myTestCallable);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.err.println(future.get());</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用ExecutorService产生一个线程 结合futureTask</span></span><br><span class="line">        executorService.submit(futureTask);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.err.println(futureTask.get());</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Runnable</code>与<code>Callable</code>不同点：</p><ul><li><code>Runnable</code>不返回执行结果，<code>Callable</code>可返回结果</li><li><code>Callable</code>可以抛出异常</li><li><code>Runnable</code>可直接由<code>Thread构造</code>或者<code>EXecutorService.submit()</code>执行</li></ul><p>运行<code>Callable</code>可以得到一个Future对象，表示异步计算的结果。提供了检查计算是否完成的方法以等待计算的完成，并检查计算结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//试图取消任务的执行。mayInterruptIfRunning确定是否应该以试图停止任务的方式中断执行任务流程。true 直接中断 false等待执行完成 </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">//任务正常完成前将其取消，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//任务已完成或者因为正常终止、异常，取消而完成，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//等待计算结果的返回，如果被取消则抛出异常</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="comment">//设定执行时间，超过时间则抛出Timeout异常</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三种方法的比较"><a href="#三种方法的比较" class="headerlink" title="三种方法的比较"></a>三种方法的比较</h4></li></ul><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread类</td><td>编写简单，可以使用<code>this</code>直接访问当前线程</td><td>1.受限于Java类的单继承，无法继承其他类；<br>2.多个线程之间无法共享方法或实例变量</td></tr><tr><td>实现Runnable接口</td><td>多个线程可共享一个实现了<code>Runnable</code>接口的类，非常适合多个线程处理同一任务</td><td>1.<code>run()</code>没有返回值<br>2.不能直接捕获运行过程中的异常，需要使用<code>setDefaultUncaughtExceptionHandler()</code>捕获子线程的异常</td></tr><tr><td>实现Callable接口</td><td>多个线程可共享一个实现了<code>Callable</code>接口的类，非常适合多个线程处理同一任务；可以有返回值；可以抛出异常</td><td>编写略微复杂，要访问当前线程需要使用<code>Thread.currentThread()</code></td></tr></tbody></table><h4 id="线程创建的内存代价"><a href="#线程创建的内存代价" class="headerlink" title="线程创建的内存代价"></a>线程创建的内存代价</h4><blockquote><p>每当有线程创建时，JVM就需要在内存中分配<code>虚拟机栈</code>和<code>本地方法栈</code>来记录调用方法的内容，分配<code>程序计数器</code>记录指令执行的位置，这样的<code>内存消耗</code>就是创建线程的内存代价。</p></blockquote><h3 id="3-线程的状态"><a href="#3-线程的状态" class="headerlink" title="3. 线程的状态"></a>3. 线程的状态</h3><p>Java线程在运行的生命周期中可能处于6种不同的状态：</p><ul><li><h4 id="New-创建"><a href="#New-创建" class="headerlink" title="New(创建)"></a>New(创建)</h4><p>线程被创建，还没有调用<code>start()</code>，还没有运行</p></li><li><h4 id="Runnable-可运行"><a href="#Runnable-可运行" class="headerlink" title="Runnable(可运行)"></a>Runnable(可运行)</h4><p>一旦调用<code>start()</code>，线程处于<code>Runnable</code>状态，一个可运行的线程可能处于正在运行或没有运行状态，这取决与操作系统给系统提供运行的时间</p></li><li><h4 id="Blocked-阻塞"><a href="#Blocked-阻塞" class="headerlink" title="Blocked(阻塞)"></a>Blocked(阻塞)</h4><p>表示线程被锁阻塞而等待监事锁(<code>monitor</code>)，暂时不能活动</p></li><li><h4 id="Waiting-等待"><a href="#Waiting-等待" class="headerlink" title="Waiting(等待)"></a>Waiting(等待)</h4><p>线程暂时不活动，并不运行任何代码，消耗最少资源并等待线程调度器重新激活它。</p></li><li><h4 id="Timed-Waiting-超时等待"><a href="#Timed-Waiting-超时等待" class="headerlink" title="Timed Waiting(超时等待)"></a>Timed Waiting(超时等待)</h4><p>在指定等待时间内等待另一个线程执行特定的方法的线程状态</p></li><li><h4 id="Terminated-终止"><a href="#Terminated-终止" class="headerlink" title="Terminated(终止)"></a>Terminated(终止)</h4><p>表示当前线程已执行完毕。导致线程处于终止态有两种情况：</p><ul><li><code>run()</code>执行完毕正常退出</li><li>一个没有捕获的异常终止了<code>run()</code>，导致线程终止</li></ul></li></ul><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Thread-State.png" class="full-image" alt="线程状态" title="线程状态"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="4-线程的分类"><a href="#4-线程的分类" class="headerlink" title="4. 线程的分类"></a>4. 线程的分类</h3><ul><li><h4 id="普通线程-用户线程"><a href="#普通线程-用户线程" class="headerlink" title="普通线程(用户线程)"></a>普通线程(用户线程)</h4><p>运行在前台，执行具体的任务，如程序的主线程，链接网络的子线程都是用户线程</p></li><li><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>运行在后台，为其他线程提供服务，如果所有的前台线程都死亡，守护线程也随之死亡。当整个虚拟机只剩下后台线程，虚拟机也就退出了。</p><p>应用：JVM虚拟机启动后的后台检测线程，数据库连接池中的检测线程</p><p>最常见的守护线程：<code>虚拟机中的垃圾回收线程</code></p></li></ul><h3 id="5-线程中的常见方法"><a href="#5-线程中的常见方法" class="headerlink" title="5. 线程中的常见方法"></a>5. 线程中的常见方法</h3><ul><li><h4 id="start"><a href="#start" class="headerlink" title="start()"></a><code>start()</code></h4><p><code>start()</code>方法执行后，表示该线程到达了<code>Runnable</code>状态，何时运行还要等待线程调度器调度</p><p><strong>线程死亡后，不可再次调用<code>start()</code>，只能对<code>New</code>状态的线程调用且只能调用一次<code>start()</code></strong></p></li><li><h4 id="run"><a href="#run" class="headerlink" title="run()"></a><code>run()</code></h4><p>直接调用<code>run()</code>，只是调用线程中的代码，多个线程无法并发执行</p></li><li><h4 id="join"><a href="#join" class="headerlink" title="*join()"></a>*<code>join()</code></h4><p>主要作用是<strong>等待该线程终止</strong>。<code>主线程需要等待子线程执行完成之后再结束，也就是在子线程调用了join()方法后面的代码只有子线程结束了才可以执行。</code> </p></li><li><h4 id="sleep-long-mills"><a href="#sleep-long-mills" class="headerlink" title="*sleep(long mills)"></a>*<code>sleep(long mills)</code></h4><p>主动放弃占用的处理器资源，进入<code>Blocked</code>。使当前执行的线程以指定的毫秒数休眠（<code>暂时停止执行</code>），具体取决于定时器和调度程序的精度和准确性。当超过了指定的睡眠时间后，线程进入<code>Runnable</code>，等待线程调度器调用。</p></li><li><h4 id="yield"><a href="#yield" class="headerlink" title="*yield()"></a>*<code>yield()</code></h4><p>主动放弃占用的处理器资源，进入<code>Runnable</code>状态，等待线程调度器调用。<strong>放弃的时间不确定，可能一会就回重新获取CPU，线程调度器重新调用。</strong></p></li><li><h4 id="interrupt-和isInterrupted"><a href="#interrupt-和isInterrupted" class="headerlink" title="*interrupt()和isInterrupted()"></a>*<code>interrupt()</code>和<code>isInterrupted()</code></h4><p><code>interrupted()</code>：请求线程终止，实际线程并不一定会终止，执行后可以将中断标识位设置为false。线程会时不时的检测中断标识位，以判断线程是否应该被中断。</p><p><code>isInterrupted()</code>：检测当前线程是都已经是中断状态，检测中断标识位</p></li><li><h4 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority()"></a><code>setPriority()</code></h4><p>设置线程的优先级，<strong>理论上说：线程优先级高的更容易被执行，但也要结合具体的系统。</strong></p><p>使用<code>getPriority()</code>可以查看当前线程的优先级。</p></li><li><h4 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a><code>isAlive()</code></h4><p>检查线程是否处于活动状态，如果线程处于<code>Runnable(就绪或运行),Blocked(阻塞)</code>返回<code>true</code>，若处于<code>New(新建),Terminated(终止)</code>返回<code>false</code></p></li><li><h4 id="wait-wait-long-mills"><a href="#wait-wait-long-mills" class="headerlink" title="*wait()/wait(long mills)"></a>*<code>wait()/wait(long mills)</code></h4><p>导致线程进入等待状态，并释放锁。<code>mills</code>为等待时间，超过这个时间没有对当前线程进行唤醒(调用<code>notify()/notifyAll()</code>)即会自动唤醒。未设置<code>mills</code>，则直到被唤醒为止。<strong>只能在同步方法或者同步块内调用，例如<code>synchronized(lockobj) {...}</code></strong></p></li><li><h4 id="notify"><a href="#notify" class="headerlink" title="*notify()"></a>*<code>notify()</code></h4><p>让当前线程通知那些处于等待(<code>Waiting</code>)的线程，当前线程执行完毕后释放锁，随机选择一个在该对象上调用<code>wait()</code>的线程，解除其阻塞状态。<strong>只能在同步方法或者同步块内调用，例如<code>synchronized(lockobj) {...}</code></strong></p></li><li><h4 id="notifyAll"><a href="#notifyAll" class="headerlink" title="*notifyAll()"></a>*<code>notifyAll()</code></h4><p>让当前线程通知那些处于等待(<code>Waiting</code>)的线程，当前线程执行完毕后释放锁，唤醒所有在该对象上调用<code>wait()</code>的线程，解除其阻塞状态。<strong>只能在同步方法或者同步块内调用，例如<code>synchronized(lockobj) {...}</code></strong></p></li></ul><blockquote><p><code>wait()</code>和<code>sleep()</code>的区别</p><ul><li><code>sleep()</code>来自于Thread类方法，<code>wait()</code>来自Object类</li><li><p><code>sleep()</code>不会释放锁，<code>wait()</code>释放锁，使得其他线程可以使用同步控制块或者方法</p></li><li><p><code>sleep()</code>让当前正在执行的线程休眠，等待一定的时间之后，会重新进入<code>Runnable</code>。<code>wait()</code>使实体所处线程暂停运行，直到被<code>notify()/notifyAll()</code>唤醒或者<code>wait()</code>的时间到达。</p></li></ul></blockquote><h3 id="6-线程安全中断"><a href="#6-线程安全中断" class="headerlink" title="6. 线程安全中断"></a>6. 线程安全中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//第一种 判定当前线程的中断标识位是否为true</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            System.err.println(<span class="string">"l = "</span> + l);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">"线程已经停止"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//第二种 自己设置中断标识位 on</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(on)&#123;</span><br><span class="line">            l++;</span><br><span class="line">            System.err.println(<span class="string">"l = "</span> + l);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">"线程已经停止"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        on = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InterruptThreadTest thread = <span class="keyword">new</span> InterruptThreadTest();</span><br><span class="line">            thread.start();</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//第一种 调用interrupt设置中断标识位为 true</span></span><br><span class="line">            thread.interrupt();</span><br><span class="line">            <span class="comment">//第二种 自己设置中断标识位</span></span><br><span class="line">            cancel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-线程优先级"><a href="#7-线程优先级" class="headerlink" title="7.线程优先级"></a>7.线程优先级</h3><blockquote><p>线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使用哪个线程进入运行状态。<em>低优先级的线程并不意味着不会被运行，只是运行几率会变小。</em></p><p>线程优先级具有<strong>继承特性</strong>，比如A线程启动B线程，则B线程与A线程优先级一致</p><p>线程优先级具有<strong>随机性</strong>，线程优先级高的不一定每次都先执行完。</p><p>优先级从<code>1-10</code>，10为最高级，1为最低级</p></blockquote><h3 id="8-线程调度策略"><a href="#8-线程调度策略" class="headerlink" title="8. 线程调度策略"></a>8. 线程调度策略</h3><ul><li><h4 id="抢占式调度策略"><a href="#抢占式调度策略" class="headerlink" title="抢占式调度策略"></a>抢占式调度策略</h4><p>如果一个优先级比其他任何处于可运行状态的线程都高的线程都进入就绪状态，那么运行时系统就会选择该线程运行。</p></li><li><h4 id="时间片轮转调度策略"><a href="#时间片轮转调度策略" class="headerlink" title="时间片轮转调度策略"></a>时间片轮转调度策略</h4><p>从所有处于就绪状态的线程中优先选择优先级最高的线程分配一定的CPU时间运行，该时间过后再去选择其他线程运行。<code>只有当线程运行结束或者放弃等原因进入阻塞状态，低优先级的线程才有机会执行。</code>若优先级相同，则调度程序以轮转的方式选择运行的线程。</p></li></ul><h2 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-多线程的优缺点"><a href="#1-多线程的优缺点" class="headerlink" title="1. 多线程的优缺点"></a>1. 多线程的优缺点</h3><p>优点：</p><blockquote><ol><li>资源利用率好</li><li>提高程序的执行效率(多个线程同时执行)</li><li>程序响应更快</li></ol></blockquote><p>缺点：</p><blockquote><ol><li><p>设计更复杂</p><p>多线程程序在访问共享数据时需要小心处理，否则会出现难以修复的bug。线程之间的交互往往非常复杂，不正确的线程同步产生的错误难以被发现并修复(由于线程调度的无序性，可能依赖于某种特殊的线程执行序列)。</p></li><li><p>上下文切换的开销</p><p>线程是由CPU进行调度的，CPU的一个时间片内只执行一个线程上下文内的线程。<strong>上下文切换</strong>(<code>当CPU从执行一个线程切换到执行另一个线程时，需要先存储当前线程的本地数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后开始执行另一个线程。</code>)这个过程并不廉价，如果没有必要，要尽量减少<code>上下文切换</code>的发生。</p></li><li><p>更多的资源消耗</p><p>除了CPU执行<code>上下文切换</code>的消耗外，线程的执行还有其他的资源消耗。例如<strong>内存同步的开销(线程需要一些内存维持本地栈去存储线程专用数据)</strong>、<strong>创建线程和终止的开销</strong>，<strong>线程调度的开销</strong>等。</p></li></ol></blockquote><p>拓展：</p><ul><li><p>引起<strong>上下文切换</strong>的原因</p><ul><li>时间片用完，CPU正常调度下一个任务</li><li>被其他线程优先级更高的任务抢占</li><li>执行任务遇到阻塞，调度器挂起当前任务，切换执行另一个任务</li><li>用户主动挂起线程(<code>yield()</code>,<code>sleep()</code>)</li><li>多任务抢占资源，没有抢到被挂起</li><li>硬件中断</li></ul></li><li><p>线程切换的性能代价</p><blockquote><p>JVM需要先保存起被挂起线程的上下文环境：将线程执行位置保存在<code>程序计数器</code>中，调用方法的信息保存到<code>栈</code>中，待执行线程的<code>程序计数器</code>和<code>栈</code>中信息写入到处理器中。维护线程隔离数据区中的内容在<strong>处理器中的导入导出</strong>，就是线程切换的性能代价。</p></blockquote><p>减少线程上下文切换的方法：</p><ul><li>使用基于CAS的非拥塞算法</li><li>无锁并发编程，尽量使用<code>ThreadLocal</code>或者不变量，而不是用锁 <a href="https://www.jianshu.com/p/bb36fee3e55c" target="_blank" rel="noopener">安全共享策略</a></li><li>使用<code>线程池+等待队列</code>的方式，控制线程数目</li></ul></li></ul><h3 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h3><blockquote><p>如果两个线程竞争统一资源时，并且每一个线程都调用了修改该对象的方法，这种情况通常称为<strong>竞态条件</strong>。导致竞态条件发生的代码区称为<strong>临界区</strong>。</p><p>若一个资源的创建、使用，销毁都在同一个线程内，且不会脱离该线程的控制，则无需同步。</p></blockquote><ul><li><h4 id="同步方法-synchronized方法锁"><a href="#同步方法-synchronized方法锁" class="headerlink" title="同步方法 synchronized方法锁"></a>同步方法 <code>synchronized</code>方法锁</h4></li><li><h4 id="同步代码块-synvhronized类锁"><a href="#同步代码块-synvhronized类锁" class="headerlink" title="同步代码块 synvhronized类锁"></a>同步代码块 <code>synvhronized</code>类锁</h4></li><li><h4 id="wait-和notify"><a href="#wait-和notify" class="headerlink" title="wait()和notify()"></a>wait()和notify()</h4></li><li><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4></li><li><h4 id="重入锁-Lock"><a href="#重入锁-Lock" class="headerlink" title="重入锁 Lock"></a>重入锁 <code>Lock</code></h4></li><li><h4 id="局部变量-ThreadLocal"><a href="#局部变量-ThreadLocal" class="headerlink" title="局部变量 ThreadLocal"></a>局部变量 <code>ThreadLocal</code></h4></li><li><h4 id="阻塞队列-BlockingQueue"><a href="#阻塞队列-BlockingQueue" class="headerlink" title="阻塞队列 BlockingQueue"></a>阻塞队列 <code>BlockingQueue</code></h4></li></ul><h3 id="3-线程通信"><a href="#3-线程通信" class="headerlink" title="3. 线程通信"></a>3. 线程通信</h3><blockquote><p>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p></blockquote><ul><li><h4 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait()/notify()"></a>wait()/notify()</h4><p>在<code>synchronized</code>修饰的同步方法或者同步代码块中使用Object类提供的<code>wait()、notify()，notifyAll()</code>这三个方法进行线程通信</p></li><li><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>当程序使用<code>Lock</code>类同步，系统不存在隐式的同步监视器，只能用Condition控制线程通信</p></li><li><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><code>BlockingQueue</code>提供了<code>put(E e)</code>和<code>take()</code>支持阻塞的方法。</p></li></ul><p>体现在<code>生产者-消费者模式</code></p><p>生产者-消费者模式的实现</p><ol><li><p>wait()/notify()实现</p></li><li><p>Condition()</p></li><li><p>BlockingQueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCustomerBlockQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(queueSize,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ProductCustomerBlockQueue blockQueue = <span class="keyword">new</span> ProductCustomerBlockQueue();</span><br><span class="line">        Producter producter = blockQueue.new Producter();</span><br><span class="line">        Customer customer = blockQueue.new Customer();</span><br><span class="line"></span><br><span class="line">        producter.start();</span><br><span class="line">        customer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    System.err.println(<span class="string">"消费哦"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                    System.err.println(<span class="string">"生产哦"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><a href="/2018/05/31/Android-Study-Plan-XVII/" title="Android-线程池 ThreadPool 专题详解">Android-线程池 ThreadPool 专题详解</a>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM相关及其拓展(六) -- Java与线程</title>
      <link href="/2018/12/18/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%85%AD/"/>
      <url>/2018/12/18/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%85%AD/</url>
      <content type="html"><![CDATA[<h1 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h1><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程间既可以共享进程资源，又可以独立调度(<code>线程是CPU调度的基本单位</code>)。</p><p>实现线程主要有三种方式：</p><ul><li><h3 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h3><blockquote><p>直接由操作系统内核支持的线程。</p><p>由内核来完成切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。</p></blockquote><p><code>多线程内核</code>：有能力处理多件事情，支持多线程的内核</p><p><code>轻量级进程</code>：内核线程的一种高级接口。<code>只有先支持内核线程，才能有轻量级进程</code></p><ul><li>优点：每个轻量级进程都是一个独立的调度单元，即使有一个在系统调用中堵塞了，也不影响整个进程继续工作。</li><li>缺点：各种线程操作都需要进行系统调用，代价相对高，需要在<strong>用户态和内核态</strong>中来回切换。另外轻量级进程的数量是有限的。</li><li>轻量级进程与内核线程是1:1的关系</li></ul></li><li><h3 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h3><blockquote><p>广义：一个线程只要不是内核线程，就可以认为是用户线程</p><p>狭义：完全建立在用户空间的线程库上，而系统内核不能感知线程存在的实现</p></blockquote><ul><li>优点：线程的建立、同步、销毁和调度都在用户态中完成，不需要内核参与，所以操作时非常快速且低消耗，还支持更大的线程数量</li><li>缺点：没有系统内核的支持，所有线程操作都需要用户程序自己处理，实现较复杂</li><li>进程与用户线程之间是1:N的关系</li></ul></li><li><h3 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h3><blockquote><p>既存在用户线程，也存在轻量级进程。</p></blockquote><ul><li>优点：用户线程还是在用户空间中，还可以支持大规模的用户线程并发；轻量级进程可以作为内核线程和用户线程之间的桥梁，用户线程的系统调用需要轻量级进程来完成，大大降低了系统被阻塞的危险。</li><li>采用多对多的线程模型。</li></ul></li></ul><p>Java线程的实现是不能确定的。<strong>由于操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的。</strong></p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><blockquote><p>系统为线程分配处理器使用权的过程。</p></blockquote><p>主要调度方式有两种：</p><ul><li><h3 id="协同式线程调度"><a href="#协同式线程调度" class="headerlink" title="协同式线程调度"></a>协同式线程调度</h3><blockquote><p>线程的执行时间有 <strong>线程本身</strong> 控制，线程把自己的工作执行完后，要主动通知系统切换到另一个线程上。</p></blockquote><ul><li>优点：实现简单，切换操作可知，基本不存在线程同步问题</li><li>缺点：线程执行时间不可控</li></ul></li><li><h3 id="抢占式线程调度"><a href="#抢占式线程调度" class="headerlink" title="抢占式线程调度"></a>抢占式线程调度</h3><blockquote><p>每个线程由系统分配执行时间，线程的切换不由线程本身决定</p></blockquote><ul><li><p>线程执行时间是可控的，不存在因为一个线程而堵塞整个系统的问题</p></li><li><p>可以设置<strong>线程优先级</strong>，优先级越高的线程越容易被系统选择执行</p><p><code>线程优先级并不是太靠谱，一方面线程调度还是取决于操作系统，优先级的实现不会太一致。另一方面优先级会被系统自行改变。</code></p></li></ul></li></ul><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><blockquote><p>在任意时间点，一个线程有且只有一个状态</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Thread-State.png" class="full-image" alt="线程状态转换" title="线程状态转换"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><blockquote><p>线程创建后尚未启动的线程状态</p></blockquote></li><li><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><blockquote><p>包括正在执行和等待着CPU为它分配执行时间</p></blockquote></li><li><h3 id="无限期等待"><a href="#无限期等待" class="headerlink" title="无限期等待"></a>无限期等待</h3><blockquote><p>不会被分配CPU执行时间，要等待被其他线程显示的唤醒。以下方法会让线程陷入无限期的等待状态：</p><ol><li>没有设置Timeout参数的<code>Object,wait()</code></li><li>没有设置Timeout参数的<code>Thread.join()</code></li><li><code>LockSupport.park()</code></li></ol></blockquote></li><li><h3 id="限期等待"><a href="#限期等待" class="headerlink" title="限期等待"></a>限期等待</h3><blockquote><p>不会被分配CPU执行时间，但在一定时间后会被系统唤醒。以下方法会让线程进入限期等待状态：</p><ol><li><code>Thread.sleep()</code></li><li>设置Timeout参数的<code>Object,wait()</code></li><li>设置Timeout参数的<code>Thread.join()</code></li><li><code>LockSupport.parkNanos()</code></li><li><code>LockSupport.parkUntil()</code></li></ol></blockquote></li><li><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><blockquote><p>线程被阻塞了 在程序等待进入同步区域的时候进入这种状态。</p><p><strong>阻塞状态</strong>：等待着获取到一个<strong>排他锁</strong>，将在另一个线程放弃这个锁的时候发生</p><p><strong>等待状态</strong>：在等待一段时间或者唤醒动作的发生</p></blockquote></li><li><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><blockquote><p>线程已经结束执行</p></blockquote></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>synchronized关键字分析</title>
      <link href="/2018/12/18/synchorized%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/18/synchorized%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><blockquote><p><code>synchronized</code>可作用于一段代码或方法，既可以保证可见性也可以保证原子性。</p><p><strong>可见性</strong>：通过<code>synchronized</code>能保证同一个时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前将会对变量的修改刷新到主存中。</p><p><strong>原子性</strong>：要么不执行，要么执行到底。</p><p>锁类型为：<strong>可重入锁，非公平锁，独占锁，互斥锁</strong></p></blockquote><h2 id="synchronized作用"><a href="#synchronized作用" class="headerlink" title="synchronized作用"></a><code>synchronized</code>作用</h2><ul><li>确保线程互斥的访问代码块，同一时刻只有一个方法进入临界区</li><li>保证共享变量的修改能即时可见</li><li>有效解决重排序问题</li></ul><h2 id="synchronized使用"><a href="#synchronized使用" class="headerlink" title="synchronized使用"></a><code>synchronized</code>使用</h2><h3 id="修饰实例方法，锁的是当前对象实例-this"><a href="#修饰实例方法，锁的是当前对象实例-this" class="headerlink" title="修饰实例方法，锁的是当前对象实例(this)"></a>修饰实例方法，锁的是当前对象实例(this)</h3><blockquote><p>一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMethodTest</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">"method1 finish"</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">"method2 finish"</span>+ System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SynchronizedMethodTest test =<span class="keyword">new</span> SynchronizedMethodTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">method1 finish <span class="number">1545188801152</span></span><br><span class="line">method2 finish <span class="number">1545188803157</span></span><br></pre></td></tr></table></figure><h3 id="修饰静态方法，锁的是当前Class对象-静态方法属于类，而不是对象"><a href="#修饰静态方法，锁的是当前Class对象-静态方法属于类，而不是对象" class="headerlink" title="修饰静态方法，锁的是当前Class对象(静态方法属于类，而不是对象)"></a>修饰静态方法，锁的是当前Class对象(静态方法属于类，而不是对象)</h3><blockquote><p>由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedStaticMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">"method1 finish"</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">"method2 finish"</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(SynchronizedStaticMethodTest::method1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(SynchronizedStaticMethodTest::method2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">method1 finish <span class="number">1545189344322</span></span><br><span class="line">method2 finish <span class="number">1545189346327</span></span><br></pre></td></tr></table></figure><h3 id="修饰代码块，锁的是括号里的对象"><a href="#修饰代码块，锁的是括号里的对象" class="headerlink" title="修饰代码块，锁的是括号里的对象"></a>修饰代码块，锁的是括号里的对象</h3><blockquote><p>修饰代码块 其中普通代码块 如<code>synchronized（obj）</code> 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。<br>Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。<br>Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。</p><p><strong>就是 Synchronized代码块更加灵活精确。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCodeBlockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.err.println(<span class="string">"method1 finish"</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.err.println(<span class="string">"method2 finish"</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SynchronizedCodeBlockTest test =<span class="keyword">new</span> SynchronizedCodeBlockTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test::method2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">method1 finish <span class="number">1545189694303</span></span><br><span class="line">method2 finish <span class="number">1545189696308</span></span><br></pre></td></tr></table></figure><h2 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a><code>synchronized</code>原理</h2><p>JVM基于进入和退出<code>monitor</code>对象来实现<strong>代码块同步</strong>和<strong>方法同步</strong>。</p><ul><li><p><strong>代码块同步</strong></p><p>在编译后通过<code>monitorenter</code>插入到同步代码的开始处，将<code>monitorexit</code>插入到代码结束处和异常处，反编译字节码时就可以看到相关指令。<strong>JVM要保证每个monitorenter必须有对应的monitorexit。</strong></p><p><code>monitorenter</code>：每个对象都有一个监视器锁(<code>monitor</code>)，当某个monitir被某个线程占用时就会处于锁定状态，线程执行<code>monitorenter</code>指令时会尝试获取<code>monitor</code>的所有权，尝试获取对象的锁。</p><ul><li>monitor进入数为0，则该进程进入monitor，然后将进入数置为1，该进程即为monitor的持有者</li><li>如果线程已占有monitor，只是重新进入，则monitor进入数+1</li><li>如果其他线程已占用monitor，则该线程处于堵塞状态，直至monitor进入数为0，在尝试重新获取monitor的所有权</li></ul><p><code>monitorexit</code>：执行<code>monitorexit</code>的线程必须是objectref所对应的monitor持有者。指令执行时，monitor进入数-1，如果-1后进入数为0，则线程退出monitor，不再是monitor持有者。其他被这个monitor阻塞的线程就可以尝试去获取monitor。</p><blockquote><p>反编译命令 <code>javap -v **.class</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span>: monitorenter</span><br><span class="line"> 4: ldc2_w        #16                 // long 2000l</span><br><span class="line"> 7: invokestatic  #4                  // Method java/lang/Thread.sleep:(J)V</span><br><span class="line">  ...</span><br><span class="line"><span class="number">45</span>: aload_1</span><br><span class="line"><span class="number">46</span>: monitorexit</span><br><span class="line"><span class="number">47</span>: goto          <span class="number">55</span></span><br><span class="line"><span class="number">50</span>: astore_3</span><br><span class="line"><span class="number">51</span>: aload_1</span><br><span class="line"><span class="number">52</span>: monitorexit</span><br></pre></td></tr></table></figure></li><li><p><strong>方法同步</strong></p><p><code>synchronized</code>在<code>method_info</code>会添加<code>ACC_synchronized</code>标记，线程执行会识别该标记，获取对应的锁。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">4</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc2_w        #16                 // long 2000l</span><br><span class="line">         3: invokestatic  #4                  // Method java/lang/Thread.sleep:(J)V</span><br></pre></td></tr></table></figure></li></ul><p>两者实现细节不同，<strong>本质上都是对一个对象的监视器(monitor)获取，任意一个对象都拥有自己的监视器。</strong>当这个对象由代码块同步或者方法同步调用时，<strong>执行方法的线程必须先获取对象的监视器才能进入同步块或同步方法，没有获取到对象监视器的线程就会被堵塞在入口处，变为Blocked堵塞状态。当成功获取监视器线程释放了锁后，会唤醒堵塞的同步队列的线程，使其重新尝试获取监视器。</strong></p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/synchronized-monitor.png" class="full-image" alt="同步方法关系" title="同步方法关系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>理解Java中的synchronized关键字。<br>指标：理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。</p><p>有如下一个类A</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建两个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="keyword">new</span> A();</span><br><span class="line">A a2 = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure><p>然后在两个线程中并发访问如下代码：<br>Thread1                       Thread2<br>a1.a();                       a2.a();</p><p>请问二者能否构成线程同步？</p><p>如果A的定义是下面这种呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><p>Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。</p><blockquote><p>Synchronized作用:</p></blockquote><ul><li>确保线程互斥的访问同步代码块</li><li>保证共享变量的修改能够及时可见</li><li>有效解决重排序问题</li></ul><blockquote><p>wait(),notify(),notifyAll(),sleep()作用</p></blockquote><ul><li>wait 调用线程 释放锁，然后进入休眠</li><li>sleep thread的一个操作方法，不释放锁直接进入休眠</li><li>notify 唤醒等待队列中的第一个相关进程</li><li>notifyAll 唤醒所有</li></ul><blockquote><p>Synchronized主修修饰对象为以下三种：</p></blockquote><ol><li>修饰普通方法 一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。</li><li>修饰静态方法 由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。</li><li>修饰代码块 其中普通代码块 如Synchronized（obj） 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。<br>Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。<br>Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。</li></ol><p>简单来说 就是 Synchronized代码块更加灵活精确。</p><blockquote><p>示例代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.err.println(Thread.currentThread().getName() + <span class="string">" "</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">       Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">"sync1"</span>);</span><br><span class="line">       Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">"sync2"</span>);</span><br><span class="line">       thread1.start();</span><br><span class="line">       thread2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>访问的同一个对象时，同一时刻只能有一个线程执行，执行代码块是会锁定当前对象，所以需要执行完才能释放，下一个线程才能继续执行并锁定对象</p><blockquote><p>运行结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sync1 0</span><br><span class="line">sync1 1</span><br><span class="line">sync1 2</span><br><span class="line">sync1 3</span><br><span class="line">sync1 4</span><br><span class="line">sync2 5</span><br><span class="line">sync2 6</span><br><span class="line">sync2 7</span><br><span class="line">sync2 8</span><br><span class="line">sync2 9</span><br></pre></td></tr></table></figure><h1 id="修饰对象"><a href="#修饰对象" class="headerlink" title="修饰对象"></a>修饰对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SyncThread(), <span class="string">"sync1"</span>);</span><br><span class="line">       Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SyncThread(), <span class="string">"sync2"</span>);</span><br><span class="line">       thread1.start();</span><br><span class="line">       thread2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这时创建了两个SyncThread对象，线程1执行对象1中的同步代码，线程2执行的是对象2的代码，这时两把锁分别锁定SyncThread1和SyncThread2对象，两把锁互不干扰也不互斥，所以同时执行。</p><blockquote><p>运行结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sync1 0</span><br><span class="line">sync2 1</span><br><span class="line">sync1 2</span><br><span class="line">sync2 3</span><br><span class="line">sync1 4</span><br><span class="line">sync2 5</span><br><span class="line">sync1 6</span><br><span class="line">sync2 7</span><br><span class="line">sync1 8</span><br><span class="line">sync2 9</span><br></pre></td></tr></table></figure><p>问题1 ：不能同步</p><ul><li>a1.a()锁是a1 a2.b()锁是a2 不是同一把锁 所以不同步<br>问题2：能同步</li><li>锁都为A.class对象，是统一把锁</li></ul>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CAS操作&amp;Atomic原子操作类分析</title>
      <link href="/2018/12/18/Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/18/Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="CAS操作-amp-Atomic原子操作类"><a href="#CAS操作-amp-Atomic原子操作类" class="headerlink" title="CAS操作 &amp; Atomic原子操作类"></a>CAS操作 &amp; Atomic原子操作类</h1><h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><blockquote><p>CAS是乐观锁技术，当多个线程尝试使用CAS更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程不会被挂起，而是告知竞争失败，并尝试再次发起请求。</p></blockquote><p>CAS指令需要有三个操作数：</p><ul><li><strong>内存位置(V)</strong>：简单的理解为变量的内存地址</li><li><strong>旧的预期值(A)</strong></li><li><strong>新值(B)</strong></li></ul><p>执行CAS操作，当且仅当<code>V</code>符合旧预期<code>A</code>时，处理器就会更新<code>B</code>到<code>V</code>上。否则处理器不做任何操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码实现</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwap</span><span class="params">(V,A,B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(V!=A)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//CAS操作失败</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        V=B;<span class="comment">//替换内存中的值为新值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//CAS操作成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><blockquote><p><code>compareAndSet()</code>内部是调用Java本地方法<code>compareAndSwapInt()</code>实现的，虚拟机内部对这些方法做了特殊处理，借助C来调用CPU的底层指令保证硬件层面实现原子操作。</p><p>Intel CPU 利用<strong>cmpxchg</strong>指令实现CAS</p></blockquote><h3 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h3><ul><li><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>因为CAS需要在操作值的时候检查值是否发生变化，如果没有发生变化则更新，但如果一个值原来是A，变成了B，再变成了A，对于CAS检查而言就是没有发生过变化，实际已经发生变化。</p><p>解决思路就是利用版本号，在变量前添加版本号，并每次更新时加1，则A-&gt;B-&gt;A 会变为 1A-&gt;2B-&gt;3A。</p><p>可以利用<code>AtomicStampedReference</code>来解决，它内部的<code>compareAndSwap()</code>首先会去检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，全部相等才会替换值。</p></li><li><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>CAS是非阻塞同步，不会将线程挂起，会进行自旋（<code>死循环</code>），时间过长会对性能造成很大的消耗。<code>Pause</code>指令</p></li><li><h4 id="只能保证一个变量的原子操作"><a href="#只能保证一个变量的原子操作" class="headerlink" title="只能保证一个变量的原子操作"></a>只能保证一个变量的原子操作</h4><p>当对多个变量进行操作时，CAS无法保证原子性操作，这时可以用锁或者<code>AtomicReference</code>保证引用对象之间的原子性，就可以把多个变量放在一个对象里进行操作。</p></li></ul><h2 id="Atomic原子操作类"><a href="#Atomic原子操作类" class="headerlink" title="Atomic原子操作类"></a>Atomic原子操作类</h2><blockquote><p>方便在多线程环境下，无锁的进行原子操作。<strong>提供非阻塞的线程安全编程</strong></p></blockquote><h3 id="类摘要"><a href="#类摘要" class="headerlink" title="类摘要"></a>类摘要</h3><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>AtomicInteger</td><td>更新int</td></tr><tr><td>AtomicBoolean</td><td>更新boolean</td></tr><tr><td>AtomicLong</td><td>更新long</td></tr><tr><td>AtomicIntegerArray</td><td>更新int数组</td></tr><tr><td>AtomicIntegerFieldUpdater</td><td>基于反射，可以对指定类的指定<code></code>volatile int`字段进行更新</td></tr><tr><td>AtomicLongArray</td><td>更新long数组</td></tr><tr><td>AtomicLongFieldUpdater</td><td>基于反射，可以对指定类的指定<code>volatile long</code>字段进行更新</td></tr><tr><td>AtomicMarkableReference</td><td>维护带有标记的对象引用，可以更新</td></tr><tr><td>AtomicReference</td><td>更新对象引用</td></tr><tr><td>AtomicReferenceArray</td><td>更新对象引用数组</td></tr><tr><td>AtomicReferenceFieldUpdater</td><td>基于反射，可以对指定类的指定volatile 字段进行更新</td></tr><tr><td>AtomicStampedReference</td><td>维护带有整数标志的对象引用，可以更新</td></tr></tbody></table><p>Java 8之后新增了4个新的原子操作类</p><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>LongAdder</td><td>更新long</td></tr><tr><td>DoubleAdder</td><td>更新double</td></tr><tr><td>LongAccumulator</td><td>更新long</td></tr><tr><td>DoubleAccumulator</td><td>更新double</td></tr></tbody></table><p>上述四个类引用<code>多段锁</code>的概念。<strong>通过CAS保证原子性，通过自旋保证当次修改的最终修改成功，通过降低锁粒度（多段锁）增加并发性能。</strong> 他们<strong>属于原子累加器，适用于数据统计以及高并发环境，不适用于其他粒度的应用。</strong></p><blockquote><p><code>原子累加器</code>使用了<strong>热点分离</strong>思想</p><p><strong>热点分离</strong>：①将竞争的数据进行分解成多个单元，在每个单元中分别进行数据处理 ②各单元处理完成后，通过<code>Hash算法</code>进行求和，从而得到最终结果</p><p><code>热点分离</code>减小了锁的粒度，提供并发环境下的吞吐量，但需要额外空间存储数据，增大空间消耗。</p></blockquote><h3 id="如何保证原子操作"><a href="#如何保证原子操作" class="headerlink" title="如何保证原子操作"></a>如何保证原子操作</h3><p>内部都实现了一个<code>compareAndSet()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"> <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用volatile修饰 value 保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset<span class="comment">/*V 内存地址*/</span>, expect<span class="comment">/*A 旧的预期值*/</span>, update<span class="comment">/*B 修改值*/</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>compareAndSwap()</code>涉及了两个重要对象，一个是<code>unsafe</code>另一个是<code>valueOffset</code>。</p><p><code>unsafe</code>是JVM提供的一个后门，用来执行 <strong>硬件级别的原子操作</strong>。</p><p><code>valueOffset</code>是通过<code>unsafe</code>获取到的，代表 <strong>AtomicInteger对象value成员变量在内存中的偏移量</strong>。可以简单的认为是<em>value变量的内存地址</em>。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>volatile关键字分析</title>
      <link href="/2018/12/17/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/17/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p><strong><em>volatile的主要作用是保证可见性以及有序性，不一定保证原子性。</em></strong></p><!--缓存一致性 指令重排序概念--><blockquote><p>JVM提供的最轻量级的同步机制。</p></blockquote><p>当一个变量被<code>volatile</code>关键字修饰后，就会具备两层语义：</p><ul><li><strong>保证此变量对所有线程的可见性，这里指  当一条线程修改了这个变量的值，新值对于其他线程来说是立即可得知的。</strong></li><li><strong>禁止进行指令重排序</strong></li></ul><blockquote><p>volatile 保证可见性</p></blockquote><p>在使用<code>volatile</code>关键字修饰一个变量后，该变量在一个线程中被修改后，会发生如下事情：</p><ol><li>修改后，修改的变量值会强制立即写入主内存中</li><li>然后强制过期其他线程中工作内存中的缓存，使缓存无效</li><li>由于缓存无效，其他线程需要读取该变量值时，会强制重新从主内存中读取</li></ol><blockquote><p>当访问共享变量时，多个线程也会在自己的工作内存中有一份共享变量的副本。当某个线程更改了自己工作内存中的数据时，由于某些原因（线程阻塞）没有及时的刷新数据至主内存，然后其他线程的工作内存中的数据还是老数据。就会导致<code>缓存一致性</code>问题。</p><p><strong>缓存一致性</strong>：当其他线程读取该变量时，发现该缓存是无效的，就会从主内存中重新读取。</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/volatile-process.png" class="full-image" alt="volatile可见性" title="volatile可见性"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>volatile 保证有序性</p></blockquote><p><code>volatile</code>禁止指令重排序，可以在一定程度上保证有序性。</p><p><strong>指令重排序</strong>：JVM为了优化指令，提高程序运行效率，在不影响<strong>单线程</strong>执行结果的前提下，尽可能的提高并行度。</p><p>volatile关键字通过提供“<strong>内存屏障(重排序时不能把后面的指令重排序到内存屏障之前的位置)</strong>”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<code>加入volatile关键字的代码会多出一个lock前缀指令</code>。</p><p>内存屏障提供如下功能：</p><ul><li>重排序时不会把后面的指令重排序到内存屏障之前的位置—<code>有序性</code></li><li>本CPU的Cache立即写入内存，并且会引起别的CPU或者别的内核无效化其Cache，可以是对volatile变量的修改对其他CPU可见—<code>可见性</code></li></ul><blockquote><p>volatile不保证原子性</p></blockquote><p><code>volatile</code>只能保证对单个volatile变量的读/写具有原子性，但是对于<code>volatile++</code>这样的复合操作没办法。</p><p>自增操作 <code>volatile++</code>实际执行了三步：</p><ol><li>读取变量的初始值</li><li>在CPU中加1</li><li>重新写入工作内存，在写入主内存</li></ol><p>要想保证原子性，只能借助于<code>synchronized、Lock和java.util.concurrent.atomic包下的原子操作类</code>保证这些操作时原子性操作。</p><blockquote><p>volatile应用场景</p></blockquote><p><code>volatile</code>由于无法保证原子性，所以要使用必须具备以下两个条件：</p><ul><li><p>对变量的写操作不依赖于当前值 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span> ;</span><br><span class="line">a = a * <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>该变量没有包含在具有其他变量的不变式中</p></li></ul><p>  <strong><em>在多线程场景下，这两种情况即时使用<code>volatile</code>修饰，也有可能会有同步问题。</em></strong></p><blockquote><p>volatile 使用实例</p></blockquote><ol><li><p>状态量标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> bool flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        doSth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单例模式的实现(DCL)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton sInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstence</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Sineleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>volatile</code> 和 <code>synchronized</code>区别</p></blockquote><ul><li><code>volatile</code>仅能使用在变量级别，<code>synchronized</code>适用于变量、方法和类</li><li><code>volatile</code>仅能实现变量修改可见性，不保证原子性；<code>synchronized</code>可以保证可见性及原子性</li><li><code>volatile</code>不会造成线程的阻塞；<code>synchronized</code>会造成阻塞(<code>阻塞同步</code>)</li><li><code>volatile</code>由于禁止指令重排序，不会被编译器优化；<code>synchronized</code>会被优化</li></ul>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DiskLruCache源码分析</title>
      <link href="/2018/12/17/DiskLruCache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/17/DiskLruCache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>实现自定义图片加载框架</title>
      <link href="/2018/12/17/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/12/17/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>View的工作原理</title>
      <link href="/2018/12/14/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2018/12/14/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h1><!--MeasureSpec是什么？有什么作用？，自定义View/ViewGroup需要注意什么？invalidate()和postInvalidate()的区别？,invalidate和postInvalidate的区别及使用 Requestlayout，onlayout，onDraw，DrawChild区别与联系  View刷新机制  View绘制流程  计算一个view的嵌套层级（递归）  onMeasure的具体过程，先measure子view还是自己  onDraw的具体过程，先draw子view还是自己  实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展 view的工作原理及measure、layout、draw流程。哪一个流程可以放在子线程中去执行？draw方法中需要注意的问题？Invalidate、postInvalidate、requestLayout应用场景--><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View工作原理.png" class="full-image" alt="View工作原理" title="View工作原理"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="ViewRoot以及DecorView的概念和何时关联"><a href="#ViewRoot以及DecorView的概念和何时关联" class="headerlink" title="ViewRoot以及DecorView的概念和何时关联"></a>ViewRoot以及DecorView的概念和何时关联</h2><h3 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a>ViewRoot</h3><p><em>ViewRoot对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程均需通过ViewRoot完成。</em></p><h3 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h3><p><strong>DecorView是整个Window界面的最顶层View。</strong> <em>可以使用Android Studio自带的Layout Inspector查看页面层级</em></p><p>一般情况下<code>DecorView</code>会包含一个竖直方向的LinearLayout，该LinearLayout分为上下两个部分，上面是标题栏(<code>titlebar</code>)，下面是内容栏(<code>继承自FrameLayout 且id为content</code>)。因此我们设置Activity的布局方法叫做<code>setContentView()</code>，因为他们都被加进了<code>id为content的FrameLayout</code>中。</p><p>我们可以利用<code>ViewGroup content = findViewById(R.android.id.content)</code>获取conetnt。使用<code>content.getChildAt(0)</code>获取设置的Activity布局。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/app/Activity.java</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends View&gt; <span class="function">T <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从Window中去获取View</span></span><br><span class="line">        <span class="keyword">return</span> getWindow().findViewById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ../android/view/Window.java</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends View&gt; <span class="function">T <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从DecorView获取View</span></span><br><span class="line">        <span class="keyword">return</span> getDecorView().findViewById(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所有的View都会从DecorView中开始检索，所以<strong>View层的事件都会先经过DecorView，再传递到我们定义的View上</strong>。</p><h3 id="如何关联"><a href="#如何关联" class="headerlink" title="如何关联"></a>如何关联</h3><p>当Activity创建时，最终是调用到<code>ActivityThread</code>的<code>handleLaunchActivity</code>来创建Activity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">      <span class="comment">//创建一个Activity 会调用到onCreate()方法 从而完成DecroView的创建</span></span><br><span class="line">      Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">            reportSizeConfigurations(r);</span><br><span class="line">            Bundle oldState = r.state;</span><br><span class="line">            </span><br><span class="line">            handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法后续调用到了<code>handleResumeActivity()</code>,在这个方法中调用到了<code>WindowManager.addView()</code>将View传递至WindowManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">         ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        <span class="keyword">if</span> (!checkAndUpdateLifecycleSeq(seq, r, <span class="string">"resumeActivity"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line">        mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里会调用到生命周期中的onResume方法</span></span><br><span class="line">        r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">if</span>(r!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//获得当前Activty的Window对象</span></span><br><span class="line">                r.window = r.activity.getWindow();</span><br><span class="line">                <span class="comment">//获得当前Window的DecorView</span></span><br><span class="line">                View decor = r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                <span class="comment">//获得当前Activity的WindowManager对象</span></span><br><span class="line">                ViewManager wm = a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">                a.mDecor = decor;</span><br><span class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |= forwardBit;</span><br><span class="line">                <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">                    ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                    <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        impl.notifyChildRebuilt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                        a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//将DecorView添加到PhoneWindow中</span></span><br><span class="line">                        wm.addView(decor, l);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        a.onWindowAttributesChanged(l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the window has already been added, but during resume</span></span><br><span class="line">            <span class="comment">// we started another activity, then don't yet make the</span></span><br><span class="line">            <span class="comment">// window visible.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                    TAG, <span class="string">"Launch "</span> + r + <span class="string">" mStartedActivity set"</span>);</span><br><span class="line">                r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后续调用到了<code>wm.addView()</code>。将对应的DecorView传递进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/WindowManagerImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Window mParentWindow;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        <span class="comment">//调用到了WindowManagerGlobal中的addView</span></span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ../android/view/WindowManagerGlobal.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ViewRootImpl root;</span><br><span class="line">        View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//创建了ViewRootImpl实例</span></span><br><span class="line">            root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">            view.setLayoutParams(wparams);</span><br><span class="line">            mViews.add(view);</span><br><span class="line">            mRoots.add(root);</span><br><span class="line">            mParams.add(wparams);</span><br><span class="line">            <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用setView 将传进来的DecorView添加到PhoneWindow中。 </span></span><br><span class="line">                root.setView(view, wparams, panelParentView);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述流程走完后，就把DecorView加载到了Window中。<strong>这个流程中将ViewRootImpl对象与DecorView进行了关联</strong>。</p><h2 id="View绘制流程"><a href="#View绘制流程" class="headerlink" title="View绘制流程"></a>View绘制流程</h2><p>上节中，调用了<code>ViewRootImpl.setView(decorView)</code>将DecorView与ViewRootImpl进行了关联。View的绘制流程就是从ViewRoot开始的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">         <span class="comment">//传进来的DecorView作为全局变量使用</span></span><br><span class="line">          mView = view;</span><br><span class="line">         ...</span><br><span class="line">          <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">                <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">                <span class="comment">// any other events from the system.</span></span><br><span class="line">          <span class="comment">//绘制整个布局</span></span><br><span class="line">          requestLayout();   </span><br><span class="line">         ...</span><br><span class="line">     &#125;   </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求刷新整个布局</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//添加同步屏障</span></span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//移除同步屏障</span></span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(<span class="string">"ViewAncestor"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里开始View的绘制流程</span></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ViewRootImpl.setView()</code>中最后调用到了<code>performTraversals()</code>在这个方法中开始View的绘制流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">   <span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">      <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">  <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">if</span>(layoutRequested)&#123;</span><br><span class="line">          <span class="comment">//开始Measure过程，定义View的宽高</span></span><br><span class="line">          performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span>(didLayout)&#123;</span><br><span class="line">        <span class="comment">//开始Layout过程，决定View的位置</span></span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始Draw过程，决定了View的显示，这个过程结束才可以看到内容</span></span><br><span class="line">            performDraw();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上流程分析：<strong>View的绘制流程是从<code>ViewRootImpl</code>中开始的，先调用<code>performTraversals()</code>开始绘制，随后调用内部的<code>performMeasure()</code>开始Measure过程，调用<code>performLayout()</code>，开始Layout过程，最后调用<code>performDraw()</code>开始Draw，完成后就可以现在在屏幕上。</strong></p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View绘制流程.png" class="full-image" alt="View绘制流程" title="View绘制流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>如上图所示，<code>performTraversals()</code>依次调用<code>performMeasure()，performLayout(),performDraw()</code>完成View的绘制。</p><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><blockquote><p>MeasureSpec代表一个32位int值，高2位代表SpecMode(测量模式)，低30位代表SpecSize(某种测量模式下的规格大小)。</p></blockquote><p>作用：父控件提供给子View的一个参数，作为设定自身大小参考，实际大小还是有子View自身决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MeasureSpec</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">       <span class="meta">@IntDef</span>(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)</span><br><span class="line">       <span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">       <span class="keyword">public</span> <span class="meta">@interface</span> MeasureSpecMode &#123;&#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(@IntRange(from = <span class="number">0</span>, to = (<span class="number">1</span> &lt;&lt; MeasureSpec.MODE_SHIFT)</span> - 1) <span class="keyword">int</span> size,</span></span><br><span class="line"><span class="function">                                         @MeasureSpecMode <span class="keyword">int</span> mode) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">               <span class="keyword">return</span> size + mode;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">           &#125;</span><br><span class="line">         </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeSafeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> makeMeasureSpec(size, mode);</span><br><span class="line">       &#125;</span><br><span class="line">         </span><br><span class="line">     <span class="meta">@MeasureSpecMode</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//noinspection ResourceType</span></span><br><span class="line">           <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">       &#125;</span><br><span class="line">         </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><code>MeasureSpec</code>涉及到了很多的位运算，会新开一篇文章介绍。<a href="/2018/12/27/位运算/" title="位运算">位运算</a></p><p><code>SpecMode</code>分为三类：</p><ul><li>UNSPECIFIED：未指定模式。父控件不对子控件家人和我束缚，子元素可以为任意大小，一般用于系统内部的测量。比如ScrollView</li><li>EXACTLY：精确模式。父控件为子View指定精确大小，希望子View完全按照自己给的尺寸处理大小。一般是设置了明确的值或是<code>MATCH_PARENT</code></li><li>AT_MOST：最大模式。父控件为子View指定最大尺寸，希望子View不要超过这个尺寸。一般对应<code>WRAP_CONTENT</code></li></ul><h3 id="MeasureSpec与LayoutParams的对应关系"><a href="#MeasureSpec与LayoutParams的对应关系" class="headerlink" title="MeasureSpec与LayoutParams的对应关系"></a>MeasureSpec与LayoutParams的对应关系</h3><p>每一个View，都持有一个MeasureSpec，里面保存了View的尺寸。我们也可以使用<code>LayoutParams</code>指定View的尺寸。所以在View测量的时候，系统会将<code>LayoutParams</code>在父容器的约束下转换成<code>MeasureSpec</code>，然后根据转换后的值确定宽高。</p><p><strong>转换后的MeasureSpec是由LayoutParams和父容器的MeasureSpec一起决定的。</strong></p><h4 id="DecorView转换MeasureSpec"><a href="#DecorView转换MeasureSpec" class="headerlink" title="DecorView转换MeasureSpec"></a>DecorView转换MeasureSpec</h4><blockquote><p>DecorView的转换由Window的尺寸和自身的LayoutParams决定。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">       <span class="comment">//DecorView Measure过程</span></span><br><span class="line">       <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">       <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">       performMeasure(childWidthMeasureSpec,childHeightMeasureSpec)</span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在方法中生成了DecoeView的MeasureSpec 根据Window的尺寸和自身的LayoutParams</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize<span class="comment">/*Window尺寸*/</span>, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> measureSpec;</span><br><span class="line">        <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">            <span class="comment">//MeasureSpec中的specSize就是窗口尺寸,specMode为EXACTLY 精确模式</span></span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">            <span class="comment">//MeasureSpec中的specSize为窗口尺寸,specMode为aT_MOST 最大模式，最大值为窗口尺寸</span></span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//MeasureSpec中的specSize为固定尺寸,specMode为EXACTLY 精确模式</span></span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> measureSpec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="普通View转换MeasureSpec"><a href="#普通View转换MeasureSpec" class="headerlink" title="普通View转换MeasureSpec"></a>普通View转换MeasureSpec</h4><blockquote><p>普通View的MeasureSpec由父容器的MeasureSpec和自身的LayoutParams决定。</p></blockquote><table><thead><tr><th>下：childLayoutParams 右：parentSpecMode</th><th>EXACTLY</th><th>AT_MOST</th><th>UNSPECIFIED</th></tr></thead><tbody><tr><td>固定大小</td><td>Exactly<br>childSize</td><td>Exactly<br>childSize</td><td>Exactly<br>childSize</td></tr><tr><td>match_parent</td><td>Exactly<br>parentSize(父容器剩余空间)</td><td>AT_MOST<br>parentSize(最大父容器剩余空间)</td><td>UNSPECIFIED<br>0</td></tr><tr><td>wrap_content</td><td>AT_MOST<br>parentSize(最大父容器剩余空间)</td><td>AT_MOST<br>parentSize(最大父容器剩余空间)</td><td>UNSPECIFIED<br>0</td></tr></tbody></table><p>根据<code>ViewGroup.getChildMeasureSpec()</code>得出上表。</p><h2 id="View工作流程"><a href="#View工作流程" class="headerlink" title="View工作流程"></a>View工作流程</h2><blockquote><p>主要是指<code>measure(测量)</code>,<code>layout(布局)</code>,<code>draw(绘制)</code>三大流程。</p></blockquote><h3 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h3><p>measure过程分为两种。</p><h4 id="View的measure过程"><a href="#View的measure过程" class="headerlink" title="View的measure过程"></a>View的measure过程</h4><p>主要是由<code>measure()</code>方法完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个类是final的，所以子类无法重新该方法</span></span><br><span class="line">    ...</span><br><span class="line">    onMeasure(widthMeasureSpec,heightMeasureSpec);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>measure()</code>中调用<code>onMeasure()</code>去进行实际的测量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//../android/view/View.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        setMeasuredDimension(</span><br><span class="line">            getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置View的宽高</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMeasuredDimension</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">            Insets insets = getOpticalInsets();</span><br><span class="line">            <span class="keyword">int</span> opticalWidth  = insets.left + insets.right;</span><br><span class="line">            <span class="keyword">int</span> opticalHeight = insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">            measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">            measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回View的MeasureSpec中的specSize</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = size;</span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="comment">//这段代码中可以分析得出 一个直接继承View的自定义View 定义为wrap_content和match_parent大小都是一致的.</span></span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果View没有设置背景，返回minWidth值，默认为0。若设置了背景就取背景宽度和最小宽度中的最大值返回。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// ../android/graphics/drawable/Drawable.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumWidth</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> intrinsicWidth = getIntrinsicWidth();</span><br><span class="line">    <span class="keyword">return</span> intrinsicWidth &gt; <span class="number">0</span> ? intrinsicWidth : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View-Measure.png" class="full-image" alt="View的Measure过程" title="View的Measure过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>结合上述流程图，简单分析View的Measure过程</p><ul><li>系统在绘制开始时回去调用<code>View.measure()</code>，这个类是final的们无法被重写</li><li>后续调用<code>View.onMeasure()</code>,自定义View时可以按照自己的需求对这个方法进行重写</li><li><code>onMeasure()</code>中调用到<code>setMeasureDimension()</code>对View进行宽高的设置</li><li>需要使用<code>getDefaultSize()</code>去获取最终显示出的宽高</li><li>在<code>getDefaultSize()</code>中需要对传进来的<code>MeasureSpec</code>进行分析处理<ul><li>SpecMode若为<code>UNSPECIFIED</code>，则最终尺寸为传进来的<code>SpecSize</code></li><li>SpecMode为<code>AT_MOST</code>,<code>EXACTLY</code>，还需要额外判断View是否有背景<ul><li>有背景，最终尺寸就为View的最小尺寸和背景尺寸的最大值</li><li>没背景，最终尺寸就为View的最小尺寸</li></ul></li></ul></li><li>取到最终尺寸后，数据回溯到<code>onMeasure()</code>中，即完成测量(<code>Measure</code>)过程</li></ul><p>在上述分析中，自定义View中使用<code>wrap_content</code>时，specMode为<code>AT_MOST</code>，尺寸为父控件剩余大小，效果与使用<code>match_parent</code>一致。这也是自定义View中常碰到的问题 <em>为何自定义View是wrap_content无效？</em> 解决方法就是 自己重写<code>onMeasure()</code>对<code>wrap_content</code>特殊处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec,<span class="keyword">int</span> heightMeasureSpec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec,heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(widthSpecMode = MeasureSpec.AT_MOST &amp;&amp; heightSpecMode = MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasureDimension(mWidth,mHeight);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(widthSpecMode = MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasureDimension(mWidth,heightSpecSize);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(heightSpecMode = MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        setMeasureDimension(widthSpecSize,mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ViewGroup的measure过程"><a href="#ViewGroup的measure过程" class="headerlink" title="ViewGroup的measure过程"></a>ViewGroup的measure过程</h4><blockquote><p>除了完成自身的measure过程之外，还要去遍历调用所有子元素的measure方法，各个子元素再去递归执行这个过程。</p><p><strong>先Measure子View，再Measure自己</strong></p></blockquote><p>ViewGroup中没有定义<code>onMeasure()</code>，定义了一个<code>measureChildren()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/ViewGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">        <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = children[i];</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">                <span class="comment">//遍历对每一个子元素进行测量过程</span></span><br><span class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>循环调用<code>measureChild()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/ViewGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获得子View的LayoutParams</span></span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">                mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">                mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//子View的MEasureSpec由父View的MEasureSpec以及自身的LayoutParams共同决定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//padding代指父View已占用的空间，子View无法使用，所以子View的空间需要减去padding部分</span></span><br><span class="line">        <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">                <span class="comment">// bigger than us.</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">                <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">                <span class="comment">// bigger than us.</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">                <span class="comment">// be</span></span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">                <span class="comment">// big it should be</span></span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//noinspection ResourceType</span></span><br><span class="line">        <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于ViewGroup有不同布局的需要，很难统一，所以没有提供统一的<code>onMeasure()</code>方法，而是让子类自己去实现<code>onMeasure()</code>。</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ViewGroup-Measure.png" class="full-image" alt="ViewGroup测量过程" title="ViewGroup测量过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据上述流程图，简单总结一下：</p><ul><li>ViewGroup调用自身的<code>measureChildren()</code>，里面遍历自己的子View</li><li>遍历后调用<code>measureChild()</code>，准备给每一个子View计算它的<code>MeasureSpec</code></li><li>调用<code>getChildMeasureSpec()</code>计算子View的<code>MeasureSpec</code>，需要结合父布局的<code>MeasureSpec</code>以及子View的<code>LayoutParams</code>共同得出结果</li><li><p>调用子View的<code>measure()</code>，完成子View的测量过程。</p></li><li><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><ol><li>在Activity启动时获取View的尺寸？<ul><li>在 Activity#onWindowFocusChanged 回调中获取宽高。<br><code>当Activity得到焦点或失去焦点的时候，这个方法都会被频繁调用</code></li><li>view.post(runnable)，在 runnable 中获取宽高。<br><code>利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。</code></li><li>ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。<br><code>监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露</code></li><li>调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高<br><code>手动对view进行measure来得到View的尺寸。</code></li></ul></li></ol></li></ul><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><blockquote><p>ViewGroup用来确定子元素的位置，当ViewGroup位置被确定后，在<code>onLayout()</code>中遍历所有子View，并调用其<code>layout()</code>。</p><p><strong>先layout自身后layout子元素。</strong></p></blockquote><h4 id="View的layout过程"><a href="#View的layout过程" class="headerlink" title="View的layout过程"></a>View的layout过程</h4><p>主要是由View的<code>layout()</code>方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/View.java   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左上角顶点距父容器左边的距离</span></span><br><span class="line">        <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">        <span class="comment">//左上角顶点距父容器上边的距离</span></span><br><span class="line">        <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">        <span class="comment">//右下角顶点距父容器上边的距离</span></span><br><span class="line">        <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">        <span class="comment">//右下角顶点距父容器上边的距离</span></span><br><span class="line">        <span class="keyword">int</span> oldR = mRight;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于子View下是没有子类了，所以该方法内不没有任何代码实现 一般自定义View是不需要重写该方法的</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setOpticalFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        Insets parentInsets = mParent <span class="keyword">instanceof</span> View ?</span><br><span class="line">                ((View) mParent).getOpticalInsets() : Insets.NONE;</span><br><span class="line">        Insets childInsets = getOpticalInsets();</span><br><span class="line">        <span class="comment">//根据特效边框重新计算四个顶点的位置，然后调用setFrame重新计算</span></span><br><span class="line">        <span class="keyword">return</span> setFrame(</span><br><span class="line">                left   + parentInsets.left - childInsets.left,</span><br><span class="line">                top    + parentInsets.top  - childInsets.top,</span><br><span class="line">                right  + parentInsets.left + childInsets.right,</span><br><span class="line">                bottom + parentInsets.top  + childInsets.bottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remember our drawn bit</span></span><br><span class="line">            <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">            <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">            <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">            <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">            <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invalidate our old position</span></span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            <span class="comment">//重新计算View的四个顶点距父布局左上边框的距离</span></span><br><span class="line">            mLeft = left;</span><br><span class="line">            mTop = top;</span><br><span class="line">            mRight = right;</span><br><span class="line">            mBottom = bottom;</span><br><span class="line">            mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前View是否存在阴影或者外发光等边框效果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLayoutModeOptical</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> ViewGroup &amp;&amp; ((ViewGroup) o).isLayoutModeOptical();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View-Layout.png" class="full-image" alt="View的Layout过程" title="View的Layout过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>按照流程图总结一下：</p><ul><li>View调用<code>layout()</code>开始布局过程(<code>确定最终宽高以及四个顶点的位置</code>)</li><li>根据是否有边缘效果(<code>例如发光，阴影</code>)<ul><li>有边缘效果，调用<code>setOpticalFrame()</code>去除边缘的影响，最终还是调用<code>setFrame()</code>设立自己的四个顶点</li><li>无边缘效果，调用<code>setFrame()</code>设立自己的四个顶点</li></ul></li><li>最后调用<code>onLayout()</code>最终确立宽高以及四点坐标。</li></ul><h4 id="ViewGroup的layout过程"><a href="#ViewGroup的layout过程" class="headerlink" title="ViewGroup的layout过程"></a>ViewGroup的layout过程</h4><p>当有子View存在的时候，需要遍历子View进行<code>layout</code>过程。即需要在<code>onLayout()</code>方法实现子View的<code>layout</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码与上述相同 由于ViewGroup中所有子View的layout都需要实现，所以需要实现 onLayout() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed,<span class="keyword">int</span> left,<span class="keyword">int</span> top,<span class="keyword">int</span> right,<span class="keyword">int</span> bottom)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt;getChildCount();i++)&#123;</span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在这里可以添加 顶点变化逻辑</span></span><br><span class="line">        <span class="keyword">int</span> childTop = Top;</span><br><span class="line">        <span class="keyword">int</span> childLeft = Left;</span><br><span class="line">        <span class="keyword">int</span> childBottom = Bottom;</span><br><span class="line">        <span class="keyword">int</span> childRight = Right;</span><br><span class="line">         </span><br><span class="line">        ...</span><br><span class="line">        setChildFrame(child,childLeft,childTop,childRight,childBottom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildFrame</span><span class="params">(child,<span class="keyword">int</span> l,<span class="keyword">int</span> t,<span class="keyword">int</span> r,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//按照上一节流程走</span></span><br><span class="line">    child.layout(l,t,r,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ViewGroup-Layout.png" class="full-image" alt="ViewGroup的Layout过程" title="ViewGroup的Layout过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>按照流程图简单总结一下：</p><ul><li>先调用ViewGroup的<code>layout()</code>，先对ViewGroup进行布局过程</li><li>在ViewGroup的<code>onLayout()</code>中实现子View的遍历布局过程</li><li>对遍历的子View按照ViewGroup的要求进行顶点坐标的计算，计算完成后调用子View的<code>layout()</code></li></ul><p>拓展：</p><ol><li><p>View的测量宽/高(<code>getMeasureWidth()/getMeasureHeight()</code>)与最终得到的宽/高(<code>getWidth()/getHeight()</code>)有什么区别？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得View在测量过程中的宽</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获得View在测量过程中的高</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMeasuredHeight &amp; MEASURED_SIZE_MASK;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上节 measure 源码分析中就是调用了该方法 进行View的测量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获得View最终宽</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRight - mLeft;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获得View最终高</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBottom - mTop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>两者的比较</p></blockquote></li></ol><table><thead><tr><th style="text-align:left">类型</th><th>何时赋值</th><th>赋值方法</th><th>使用场景</th></tr></thead><tbody><tr><td style="text-align:left">View测量结束宽/高<br>getMeasureWidth()/getMeasureHeight()</td><td>View的<code>measure</code>过程</td><td><code>setMeasureDimension()</code></td><td>在<code>onLayout()</code>获取View的宽/高</td></tr><tr><td style="text-align:left">View最终宽/高<br>getWidth()/getHeight()</td><td>View的<code>layout</code>过程</td><td><code>layout()</code>对top,left,right,bottom进行操作</td><td><code>onLayout()</code>结束后获取最终宽/高</td></tr></tbody></table><p>   <strong>一般情况下，二者返回的数据是相同的，除非人为对View的<code>layout()</code>进行重写。</strong></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> t,<span class="keyword">int</span> r,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.layout(j,t,r+<span class="number">100</span>,b+<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   上述代码就会导致View最终结果与测量时不同。</p><h3 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h3><blockquote><p>draw作用主要将View绘制在屏幕上面</p><p><strong>draw过程，先draw自身再draw子View</strong></p></blockquote><h4 id="View的draw过程"><a href="#View的draw过程" class="headerlink" title="View的draw过程"></a>View的draw过程</h4><p>View的draw过程，从<code>View.draw()</code>开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//标记当前View是否需要绘制背景</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">                (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> saveCount;</span><br><span class="line">        <span class="comment">//1. 绘制背景</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">            drawBackground(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="comment">//是否有水平边缘</span></span><br><span class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//是否有竖直边缘</span></span><br><span class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!horizontalEdges &amp;&amp; !verticalEdges)&#123;</span><br><span class="line">       <span class="comment">// 3.绘制View本身</span></span><br><span class="line">          <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.绘制子View</span></span><br><span class="line">          dispatchDraw(canvas);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 6.绘制装饰 例如滚动条</span></span><br><span class="line">          onDrawForeground(canvas);</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">       <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有竖直边缘或者水平边缘 例如divide</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 保存当前Canvas层</span></span><br><span class="line">        saveCount = canvas.getSaveCount();</span><br><span class="line">        <span class="keyword">int</span> solidColor = getSolidColor();</span><br><span class="line">        <span class="keyword">if</span> (solidColor == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line">            <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, right, top + length, <span class="keyword">null</span>, flags);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">                canvas.saveLayer(left, bottom - length, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, left + length, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">                canvas.saveLayer(right - length, top, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 3.绘制View本身</span></span><br><span class="line">          <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.绘制子View</span></span><br><span class="line">          dispatchDraw(canvas);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// 5.绘制边缘效果 例如阴影</span></span><br><span class="line">        canvas.restoreToCount(saveCount);</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 6.绘制装饰 例如滚动条</span></span><br><span class="line">          onDrawForeground(canvas);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制View本身的背景</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Drawable background = mBackground;</span><br><span class="line">        <span class="keyword">if</span> (background == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置View的背景边界</span></span><br><span class="line">        setBackgroundBounds();</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</span><br><span class="line">        <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</span><br><span class="line">            background.draw(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将画布偏移 然后在偏移后的画布上进行背景绘制</span></span><br><span class="line">            canvas.translate(scrollX, scrollY);</span><br><span class="line">            background.draw(canvas);</span><br><span class="line">            canvas.translate(-scrollX, -scrollY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制View本身的内容</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认空实现 需要子类复写该方法以实现内容的绘制 ，自定义View中必须执行该方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制子View的内容</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于View不存在子View，所以不需要实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制装饰 例如滚动条 前景图片</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawForeground</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        onDrawScrollIndicators(canvas);</span><br><span class="line">        onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Drawable foreground = mForegroundInfo != <span class="keyword">null</span> ? mForegroundInfo.mDrawable : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (foreground != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mForegroundInfo.mBoundsChanged) &#123;</span><br><span class="line">                mForegroundInfo.mBoundsChanged = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">final</span> Rect selfBounds = mForegroundInfo.mSelfBounds;</span><br><span class="line">                <span class="keyword">final</span> Rect overlayBounds = mForegroundInfo.mOverlayBounds;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mForegroundInfo.mInsidePadding) &#123;</span><br><span class="line">                    selfBounds.set(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    selfBounds.set(getPaddingLeft(), getPaddingTop(),</span><br><span class="line">                            getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ld = getLayoutDirection();</span><br><span class="line">                Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),</span><br><span class="line">                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);</span><br><span class="line">                foreground.setBounds(overlayBounds);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            foreground.draw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View-Draw.png" class="full-image" alt="View的Draw流程" title="View的Draw流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>结合上述流程图分析Draw过程：</p><ul><li>先调用<code>View.draw()</code>方法开始Draw流程</li><li>如果需要<code>dirtyOpaque</code>，就绘制背景<code>drawBackground()</code></li><li>如果需要显示边缘效果，就进行保存画布<code>canvas.saveLayer()</code></li><li>如果需要<code>dirtyOpaque</code>，绘制自身的内容<code>onDraw()</code> – <strong>自定义View必须实现</strong></li><li>调用<code>dispatchDraw()</code>绘制子View</li><li>如果需要显示边缘效果，绘制后，还原画布<code>canvas.restore()</code></li><li>调用<code>drawForeground()</code>绘制装饰，例如滚动条或前景</li></ul><h4 id="ViewGroup的draw过程"><a href="#ViewGroup的draw过程" class="headerlink" title="ViewGroup的draw过程"></a>ViewGroup的draw过程</h4><p>ViewGroup的draw过程主要调整了上述源码中的<code>dispatchDraw()</code>，在其内部进行了子View的遍历以及绘制过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ../android/view/ViewGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</span><br><span class="line">                <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">                <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                        transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">                &#125;</span><br><span class="line">                transientIndex++;</span><br><span class="line">                <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">                    transientIndex = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">            <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制子View</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用子View的draw方法</span></span><br><span class="line">      <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ViewGroup-Draw.png" class="full-image" alt="ViewGroup的Draw流程" title="ViewGroup的Draw流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>结合上述流程图分析ViewGroup的Draw过程：</p><ul><li>draw过程与上述<code>View的draw过程一致</code></li><li><code>dispatchDraw()</code>默认实现，内部包含了子View的遍历以及绘制</li></ul><p>拓展：</p><ol><li><p><code>View.setWillNotDraw()</code>有什么意义?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWillNotDraw</span><span class="params">(<span class="keyword">boolean</span> willNotDraw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置 不需绘制 标记位</span></span><br><span class="line">    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="number">0</span>, DRAW_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个View不需要绘制任何内容，设置这个标记为<code>true</code>，系统就会进行相应优化。</p><p><strong><em>View默认不开启<code>willNotDraw</code>标记位，ViewGroup默认开启。</em></strong></p></li></ol><h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><blockquote><p>自定义View需要了解View的层次、View的事件分发机制以及View的工作流程。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="1-继承View重写onDraw"><a href="#1-继承View重写onDraw" class="headerlink" title="1.继承View重写onDraw()"></a>1.继承View重写<code>onDraw()</code></h4><blockquote><p>主要用于实现一些不规则的效果，不方便通过布局的组合方法可以直接实现，往往需要静态或者动态的显示一些不规则图形(圆形啥的)。</p><p>特殊形状的这种就需要重写<code>onDraw()</code>实现。<strong>一般需要额外支持wrtap_content，并且也需要处理padding方法。</strong></p></blockquote><h4 id="2-继承ViewGroup派生特殊的Layout"><a href="#2-继承ViewGroup派生特殊的Layout" class="headerlink" title="2.继承ViewGroup派生特殊的Layout"></a>2.继承ViewGroup派生特殊的Layout</h4><blockquote><p>主要用于实现自定义的布局，除了常用的一些布局外。实现的是几种View的组合形式</p><p><strong>实现稍微复杂，需要合适的处理ViewGroup的<code>onMeasure()，onLayout()</code>以及子View的<code>onMeasure()，onLayout()</code></strong></p></blockquote><h4 id="3-继承特定的View-例如TextView"><a href="#3-继承特定的View-例如TextView" class="headerlink" title="3.继承特定的View(例如TextView)"></a>3.继承特定的View(例如TextView)</h4><blockquote><p>这种比较常见，一般用于拓展已有View的功能。</p><p><strong>实现比较简单，无需自己处理wrap_content以及padding</strong></p></blockquote><h4 id="4-继承特定的ViewGroup-例如LinearLayout"><a href="#4-继承特定的ViewGroup-例如LinearLayout" class="headerlink" title="4.继承特定的ViewGroup(例如LinearLayout)"></a>4.继承特定的ViewGroup(例如LinearLayout)</h4><blockquote><p>比较常见，当某种效果看起来很像几种View组合在一起的时候</p><p><strong>实现比较简单，无需自己处理测量以及布局过程</strong></p></blockquote><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="1-让View支持wrap-content"><a href="#1-让View支持wrap-content" class="headerlink" title="1.让View支持wrap_content"></a>1.让View支持wrap_content</h4><blockquote><p>直接继承View或ViewGroup的控件，不重写<code>onMeasure()</code>并对<code>AT_MOST</code>进行处理，就无法达到需要的显示效果。</p></blockquote><h4 id="2-需要的话，让View支持padding"><a href="#2-需要的话，让View支持padding" class="headerlink" title="2.需要的话，让View支持padding"></a>2.需要的话，让View支持padding</h4><blockquote><p>直接继承View的控件，需要在<code>draw</code>过程处理padding属性，不然padding属性无法起作用。</p><p>直接继承ViewGroup的控件，需要在<code>onMeasure()，onLayout()</code>处理自身的padding以及子View的margin</p></blockquote><h4 id="3-尽量不要在View中使用Handler"><a href="#3-尽量不要在View中使用Handler" class="headerlink" title="3.尽量不要在View中使用Handler"></a>3.尽量不要在View中使用Handler</h4><blockquote><p>View内部提供了<code>post</code>方法，可以替代Handler使用</p></blockquote><h4 id="4-View中如果有线程或动画，需要及时停止"><a href="#4-View中如果有线程或动画，需要及时停止" class="headerlink" title="4.View中如果有线程或动画，需要及时停止"></a>4.View中如果有线程或动画，需要及时停止</h4><blockquote><ol><li>不处理有可能造成内存泄漏，View不可见时也需要停止线程和动画</li><li>包含View的Activity启动时，View的<code>onAccachedToWindow()</code>会调用</li><li>包含View的Activity退出或当前View被移除时，调用<code>View.onDetachedFromWindow()</code>时关闭线程和动画</li></ol></blockquote><h4 id="5-View若有滑动冲突情况，需要处理"><a href="#5-View若有滑动冲突情况，需要处理" class="headerlink" title="5.View若有滑动冲突情况，需要处理"></a>5.View若有滑动冲突情况，需要处理</h4><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><a href="/2019/01/02/自定义View实践/" title="自定义View实践">自定义View实践</a><a href="/2019/01/02/自定义ViewGroup实践/" title="自定义ViewGroup实践">自定义ViewGroup实践</a><h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><h3 id="Invalidate、postInvalidate、requestLayout源码及应用场景"><a href="#Invalidate、postInvalidate、requestLayout源码及应用场景" class="headerlink" title="Invalidate、postInvalidate、requestLayout源码及应用场景"></a>Invalidate、postInvalidate、requestLayout源码及应用场景</h3><h4 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h4><blockquote><p><code>invalidate()</code>必须在主线程调用，用于请求View的重绘，意味着只影响View的<code>draw</code>过程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/View.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        invalidate(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(<span class="keyword">boolean</span> invalidateCache)</span> </span>&#123;</span><br><span class="line">        invalidateInternal(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//View不可见或者在移动中 不进行重绘</span></span><br><span class="line">     <span class="keyword">if</span> (skipInvalidate()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">                || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">                || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class="line">                || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class="line">            <span class="comment">//需要全部重绘</span></span><br><span class="line">            <span class="keyword">if</span> (fullInvalidate) &#123;</span><br><span class="line">                mLastIsOpaque = isOpaque();</span><br><span class="line">                <span class="comment">//修改绘制完成标记</span></span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DRAWN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//修改正在绘制标记</span></span><br><span class="line">            mPrivateFlags |= PFLAG_DIRTY;</span><br><span class="line">            <span class="comment">//清除缓存</span></span><br><span class="line">            <span class="keyword">if</span> (invalidateCache) &#123;</span><br><span class="line">                mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate the damage rectangle to the parent view.</span></span><br><span class="line">            <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">            <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">                <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">                damage.set(l, t, r, b);</span><br><span class="line">                <span class="comment">//设置重绘区域 并把自身传递到父布局</span></span><br><span class="line">                p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Damage the entire projection receiver, if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (mBackground != <span class="keyword">null</span> &amp;&amp; mBackground.isProjected()) &#123;</span><br><span class="line">                <span class="keyword">final</span> View receiver = getProjectionReceiver();</span><br><span class="line">                <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    receiver.damageInParent();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码修改标记完成后，调用父类的<code>invalidateChild()</code>将需要重绘的区域(<code>脏区域</code>)传入。(<code>ViewGroup以及ViewRootImpl都继承自ViewParent类</code>)</p><blockquote><p>脏区域：<em>为了保证绘制的效率，控件树仅对需要绘制的区域进行重绘，需要重绘的区域成为<code>脏区域</code></em>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//../android/view/VireGroup.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">        <span class="comment">//需要在开启硬件加速的情况下 会调用新的重绘方案</span></span><br><span class="line">        <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span> &amp;&amp; attachInfo.mHardwareAccelerated) &#123;</span><br><span class="line">            <span class="comment">// HW accelerated fast path</span></span><br><span class="line">            onDescendantInvalidated(child, child);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">          ...</span><br><span class="line">            <span class="comment">//开始遍历循环 从当前View不断向上调用父布局的绘制方法</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                View view = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 当前父布局还为ViewGroup</span></span><br><span class="line">                <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                    view = (View) parent;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 当前父布局到了ViewRootImpl</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (drawAnimation) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ViewRootImpl) &#123;</span><br><span class="line">                        ((ViewRootImpl) parent).mIsAnimating = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If the parent is dirty opaque or not dirty, mark it dirty with the opaque</span></span><br><span class="line">                <span class="comment">// flag coming from the child that initiated the invalidate</span></span><br><span class="line">                <span class="comment">// 父布局为实心 就需要设置 privateFlag标记</span></span><br><span class="line">                <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            view.getSolidColor() == <span class="number">0</span>) &#123;</span><br><span class="line">                        opaqueFlag = PFLAG_DIRTY;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</span><br><span class="line">                        view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//递归调用父布局的重绘方法</span></span><br><span class="line">                parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">                <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Account for transform on current parent</span></span><br><span class="line">                    Matrix m = view.getMatrix();</span><br><span class="line">                    <span class="keyword">if</span> (!m.isIdentity()) &#123;</span><br><span class="line">                        RectF boundingRect = attachInfo.mTmpTransformRect;</span><br><span class="line">                        boundingRect.set(dirty);</span><br><span class="line">                        m.mapRect(boundingRect);</span><br><span class="line">                       <span class="comment">//将子View的脏区域 转换 父布局中的一块区域</span></span><br><span class="line">                        dirty.set((<span class="keyword">int</span>) Math.floor(boundingRect.left),</span><br><span class="line">                                (<span class="keyword">int</span>) Math.floor(boundingRect.top),</span><br><span class="line">                                (<span class="keyword">int</span>) Math.ceil(boundingRect.right),</span><br><span class="line">                                (<span class="keyword">int</span>) Math.ceil(boundingRect.bottom));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将子视图坐标位置转化为当前视图的显示位置 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[] location, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// either DRAWN, or DRAWING_CACHE_VALID</span></span><br><span class="line">            <span class="comment">//ViewGroup中没有动画在执行 或者 已完成</span></span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE))</span><br><span class="line">                    != FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class="line">                dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,</span><br><span class="line">                        location[CHILD_TOP_INDEX] - mScrollY);</span><br><span class="line">                <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    dirty.union(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> top = mTop;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!dirty.intersect(<span class="number">0</span>, <span class="number">0</span>, mRight - left, mBottom - top)) &#123;</span><br><span class="line">                        dirty.setEmpty();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                location[CHILD_LEFT_INDEX] = left;</span><br><span class="line">                location[CHILD_TOP_INDEX] = top;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</span><br><span class="line">                    dirty.set(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// in case the dirty rect extends outside the bounds of this container</span></span><br><span class="line">                    dirty.union(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">                &#125;</span><br><span class="line">                location[CHILD_LEFT_INDEX] = mLeft;</span><br><span class="line">                location[CHILD_TOP_INDEX] = mTop;</span><br><span class="line"></span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DRAWN;</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">            <span class="keyword">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">                mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当<code>parent</code>不为View时，说明已经到达了最顶层即<code>ViewRootImpl</code></p><blockquote><p>为什么最顶层会是<code>ViewRootImpl</code>?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在ViewRoot与DecorView关联时讲到最后 WindowManagerGlobal 调用了 ViewRootImpl.setView() 传递进去DecorView</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">&gt;    <span class="comment">//设置当前ViewRootImpl为DecorView的parent</span></span><br><span class="line">&gt;    view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">//给当前View设置父布局</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">assignParent</span><span class="params">(ViewParent parent)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt;             mParent = parent;</span><br><span class="line">&gt;         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt;             mParent = <span class="keyword">null</span>;</span><br><span class="line">&gt;         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"view "</span> + <span class="keyword">this</span> + <span class="string">" being added, but"</span></span><br><span class="line">&gt;                     + <span class="string">" it already has a parent"</span>);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>不断向上回溯的过程中，最终走到DecorView <code>getParent()</code>就为ViewRootImpl</p></blockquote><p>走到最后调用到了ViewRootImpl的<code>invalidateChild</code>方法，内部实现为<code>invalidateChildInParent()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/ViewRootImpl.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, Rect dirty)</span> </span>&#123;</span><br><span class="line">        invalidateChildInParent(<span class="keyword">null</span>, dirty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前线程是否与View线程相同</span></span><br><span class="line">        checkThread();</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DRAW) Log.v(mTag, <span class="string">"Invalidate child: "</span> + dirty);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dirty == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//整个窗口重绘</span></span><br><span class="line">            invalidate();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</span><br><span class="line">            <span class="comment">//需要重绘区域为空 就不管了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置 重绘区域偏移</span></span><br><span class="line">        <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span> || mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTempRect.set(dirty);</span><br><span class="line">            dirty = mTempRect;</span><br><span class="line">            <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span>) &#123;</span><br><span class="line">                dirty.offset(<span class="number">0</span>, -mCurScrollY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateRectInAppWindowToScreen(dirty);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mScalingRequired) &#123;</span><br><span class="line">                dirty.inset(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invalidateRectOnScreen(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在屏幕上找到对应的重绘区域进行重绘</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invalidateRectOnScreen</span><span class="params">(Rect dirty)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Rect localDirty = mDirty;</span><br><span class="line">        <span class="keyword">if</span> (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;</span><br><span class="line">            mAttachInfo.mSetIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">            mAttachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the new dirty rect to the current one</span></span><br><span class="line">        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);</span><br><span class="line">        <span class="comment">// Intersect with the bounds of the window to skip</span></span><br><span class="line">        <span class="comment">// updates that lie outside of the visible region</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> appScale = mAttachInfo.mApplicationScale;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intersected = localDirty.intersect(<span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                (<span class="keyword">int</span>) (mWidth * appScale + <span class="number">0.5f</span>), (<span class="keyword">int</span>) (mHeight * appScale + <span class="number">0.5f</span>));</span><br><span class="line">        <span class="keyword">if</span> (!intersected) &#123;</span><br><span class="line">            localDirty.setEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">            <span class="comment">//真正执行绘制的地方</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终调用到了<code>scheduleTraversals()</code>，在上面讲到<code>View的绘制流程</code>时，有提到最初就是从<code>performTraversals()</code>开始，这里的<code>scheduleTraversals()</code>就是去触发一次<code>performTraversals()</code>开始一次绘制流程。</p><blockquote><p>由于<code>scheduleTraversals</code>是在主线程执行的，所以调用<code>invalidate()</code>时由于请求还未处理该消息，当多次调用重绘请求时，重绘也不会发生多次，提升效率。</p><p>调用到<code>performTraversals()</code>按道理会重新走一遍绘制流程即<code>measure-&gt;layout-&gt;draw</code>，由于重绘时，设置<code>layoutRequested为false</code>就不会重新触发<code>measure及layout</code>流程。</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/View-Invalidate.png" class="full-image" alt="View的重绘流程" title="View的重绘流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据上述流程图，简单总结：</p><ul><li>View调用<code>invalidate()</code>时，会调用父布局的<code>invalidateChild()</code>并传入自身View以及需要重绘区域</li><li>ViewGroup接收到传参时，会开启循环(<code>条件为直到没有父布局为止</code>)，调用自身的<code>invalidateChildInParent()-主要功能为将子布局区域转换成当前布局的区域</code>向父布局层层传递</li><li>当父布局不为ViewGroup时，意味着已经到了最顶层的DecorView(<code>因为它的parent为ViewRootImpl</code>)，所以最终会执行到<code>ViewRootImpl.invalidateChild()</code></li><li>ViewRootImpl执行<code>invalidateChild()</code>最终调用到的就是<code>performTraversals()</code>进行View的绘制流程(<code>draw</code>)，由于设置了<code>mLayoutRequested</code>限制了<code>measure,layout</code>的执行，所以只会发生<code>draw</code></li></ul><h4 id="postInvalidate"><a href="#postInvalidate" class="headerlink" title="postInvalidate"></a>postInvalidate</h4><blockquote><p><code>postInvalidate</code>就是可以在子线程重绘View。实际的实现还是调用<code>invalidate()</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/View.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postInvalidateDelayed(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postInvalidate</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        postInvalidateDelayed(<span class="number">0</span>, left, top, right, bottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postInvalidateDelayed</span><span class="params">(<span class="keyword">long</span> delayMilliseconds, <span class="keyword">int</span> left, <span class="keyword">int</span> top,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We try only with the AttachInfo because there's no point in invalidating</span></span><br><span class="line">        <span class="comment">// if we are not attached to our window</span></span><br><span class="line">        <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">        <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.obtain();</span><br><span class="line">            info.target = <span class="keyword">this</span>;</span><br><span class="line">            info.left = left;</span><br><span class="line">            info.top = top;</span><br><span class="line">            info.right = right;</span><br><span class="line">            info.bottom = bottom;</span><br><span class="line"></span><br><span class="line">            attachInfo.mViewRootImpl.dispatchInvalidateRectDelayed(info, delayMilliseconds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ../android/view/ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchInvalidateDelayed</span><span class="params">(View view, <span class="keyword">long</span> delayMilliseconds)</span> </span>&#123;</span><br><span class="line">    Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);</span><br><span class="line">    mHandler.sendMessageDelayed(msg, delayMilliseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ViewRootHandler mHandler = <span class="keyword">new</span> ViewRootHandler();</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  ..</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_INVALIDATE:</span><br><span class="line">                <span class="comment">//最终调用到了 invalidate </span></span><br><span class="line">                ((View) msg.obj).invalidate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h4><blockquote><p>强制重新布局，重新走一遍View的绘制流程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../android/view/View.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Only trigger request-during-layout logic if this is the view requesting it,</span></span><br><span class="line">            <span class="comment">// not the views in its parent hierarchy</span></span><br><span class="line">            ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">            <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mAttachInfo.mViewRequestingLayout = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置强制刷新标记</span></span><br><span class="line">        mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">        mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">            <span class="comment">//向父布局继续请求刷新布局</span></span><br><span class="line">            mParent.requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</span><br><span class="line">            mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不断向父布局请求重新布局，逐层传递直到ViewRootImpl层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        <span class="comment">//设置标记 重新布局</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文中提到<code>mLayoutRequested</code>就是防止<code>invalidate</code>重新走一遍绘制流程，这里设置为<code>true</code>，意味着需要走一遍<code>measure,layout</code>。</p><p>由于<code>measure</code>过程设置了<code>mPrivateTags PFLAG_LAYOUT_REQUIRED</code>所以会往下继续执行<code>layout</code>过程。</p><blockquote><p><code>requestLayout</code>是否会触发<code>draw</code>过程？</p><p>按照流程来说<code>layout</code>之后就是<code>draw</code>，所以可以从<code>layout</code>过程中查看相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在上文中说到 View的layout过程 会调用到 layout 后续是 setFrame 确定顶点，最后onLayout执行</span><br><span class="line">&gt; <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&gt;    <span class="comment">//意味着 如果布局的坐标发生了改变 就需要重新绘制</span></span><br><span class="line">&gt;  <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">&gt;             changed = <span class="keyword">true</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="comment">// Remember our drawn bit</span></span><br><span class="line">&gt;             <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">&gt;             <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">&gt;             <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">&gt;             <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">&gt;             <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="comment">// Invalidate our old position</span></span><br><span class="line">&gt;             invalidate(sizeChanged);</span><br><span class="line">&gt;             ...</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    ...</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>综上所述，如果layout的布局有变化还是会触发<code>draw</code>过程的</p></blockquote><h3 id="include、merge、ViewStub作用以及实现"><a href="#include、merge、ViewStub作用以及实现" class="headerlink" title="include、merge、ViewStub作用以及实现"></a>include、merge、ViewStub作用以及实现</h3><a href="/2019/01/03/include、merge-ViewStub相关/" title="include、merge及ViewStub相关">include、merge及ViewStub相关</a><h3 id="View的层级计算"><a href="#View的层级计算" class="headerlink" title="View的层级计算"></a>View的层级计算</h3><p>由于View是树形结构，代码的话可以利用<code>getParent()</code>实现 ，直到返回值为null，说明已经到了最高层。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java--反射</title>
      <link href="/2018/12/14/Java-%E5%8F%8D%E5%B0%84/"/>
      <url>/2018/12/14/Java-%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>LruCache原理</title>
      <link href="/2018/12/14/LRUCache%E5%8E%9F%E7%90%86/"/>
      <url>/2018/12/14/LRUCache%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h1><blockquote><p>一般来说，缓存的策略主要包含缓存的<code>添加、获取和删除</code>。但由于缓存的大小都是有上限的。缓存慢了之后，要想继续添加 ，就需要删除一些旧的缓存以提供空间。</p><p>所以使用到了<code>LruCache</code>缓存算法，即<strong>最近最少使用</strong>算法，当缓存满时，会优先淘汰掉 最近最少使用的缓存对象。</p></blockquote><p><strong>LruCache的核心原理就是利用了LinkedHashMap</strong>。</p><blockquote><p>LruCache的使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>)(Runtime.getRuntime().totalMemory()/<span class="number">1024</span>);</span><br><span class="line"><span class="comment">//设置LruCache缓存的大小</span></span><br><span class="line"><span class="keyword">int</span> cacheSize = maxMemory/<span class="number">8</span>;</span><br><span class="line">LruCache memoryCache = <span class="keyword">new</span> LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(@NonNull String key, @NonNull Bitmap value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重写sizeof方法，计算需要缓存的图片大小</span></span><br><span class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight() / <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>LruCache的实现原理</p></blockquote><p><code>LruCache内部需要维护好一个缓存对象列表，其中对象的排列方式应该按照访问顺序排列的，即一直没访问的对象，要放在队尾，最近访问的对象就会放在对头，最晚被淘汰。</code></p><p>查看源码中发现内部是利用了<code>LinkedHashMap</code>去缓存对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LruCache构造方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;K, V&gt; map;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">            <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap(<span class="number">0</span>, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="comment">/*map初始化大小*/</span><span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">/*初始负载因子*/</span><span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="comment">/*accessOrder意为访问顺序，若为true按照访问顺序排列，false则为插入顺序排列*/</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>LruCache</code>构造方法中，设置了<code>maxSize</code>以及创建一个<code>LinkedHashMap</code>对象用来存储对象。</p><p><code>LruCache</code>中需要移除最近最少使用的对象，即为优先删除访问最早对象，所以应该按照访问顺序排列，为true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LruCache获取key对应的value </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V mapValue;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//返回不为null，就将其移到队列头部</span></span><br><span class="line">            mapValue = map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                hitCount++;</span><br><span class="line">                <span class="keyword">return</span> mapValue;</span><br><span class="line">            &#125;</span><br><span class="line">            missCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当获取不到value的时候，会调用create()</span></span><br><span class="line">        V createdValue = create(key);</span><br><span class="line">        <span class="keyword">if</span> (createdValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            createCount++;</span><br><span class="line">            mapValue = map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// There was a conflict so undo that last put</span></span><br><span class="line">                map.put(key, mapValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                size += safeSizeOf(key, createdValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entryRemoved(<span class="keyword">false</span>, key, createdValue, mapValue);</span><br><span class="line">            <span class="keyword">return</span> mapValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            trimToSize(maxSize);</span><br><span class="line">            <span class="keyword">return</span> createdValue;</span><br><span class="line">        &#125; </span><br><span class="line">   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>LruCache的<code>get()</code>实际调用的就是<code>LinkedHashMap</code>对应的<code>get(key)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果按照访问顺序排列 则需要将该get对象移到尾部</span></span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMapEntry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMapEntry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">//将节点移到双端链表的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;。 </span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先调用<code>getNode()</code>获取key对应节点，如果不存在则返回null。若存在并且需要按照访问顺序排列，就把找到的节点移到双端链表的尾部。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V previous;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            putCount++;</span><br><span class="line">            <span class="comment">//增加已有缓存大小</span></span><br><span class="line">            size += safeSizeOf(key, value);</span><br><span class="line">            <span class="comment">//返回关键过这个key的对象</span></span><br><span class="line">            previous = map.put(key, value);</span><br><span class="line">            <span class="comment">//若存在已关联对象 则恢复原先缓存大小</span></span><br><span class="line">            <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">                size -= safeSizeOf(key, previous);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entryRemoved(<span class="keyword">false</span>, key, previous, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次put后，需要重新调整缓存大小避免超过上限</span></span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        <span class="keyword">return</span> previous;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在调用<code>put</code>过后，需要调用一次<code>trimToSize()</code>调整缓存对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.size &lt; <span class="number">0</span> || <span class="keyword">this</span>.map.isEmpty() &amp;&amp; <span class="keyword">this</span>.size != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="keyword">this</span>.getClass().getName() + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//直到缓存大小size&lt;=最大缓存值maxSize</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.size &lt;= maxSize || <span class="keyword">this</span>.map.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出双链表中的头元素</span></span><br><span class="line">            Entry&lt;K, V&gt; toEvict = (Entry)<span class="keyword">this</span>.map.entrySet().iterator().next();</span><br><span class="line">            key = toEvict.getKey();</span><br><span class="line">            value = toEvict.getValue();</span><br><span class="line">            <span class="comment">//移除头部元素</span></span><br><span class="line">            <span class="keyword">this</span>.map.remove(key);</span><br><span class="line">            <span class="keyword">this</span>.size -= <span class="keyword">this</span>.safeSizeOf(key, value);</span><br><span class="line">            ++<span class="keyword">this</span>.evictionCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.entryRemoved(<span class="keyword">true</span>, key, value, (Object)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理总结：</p><p>内部是利用了<code>LinkedHashMap</code>来实现一个<code>最近最少使用算法</code>，在每次调用<code>put</code>和<code>get</code>时，都会算作一次对<code>LinkedHashMap</code>的访问，当设置<code>accessOrder</code>为<code>true</code>时，就会按照访问顺序排列，就会把每次访问的元素放在尾部，当缓存值达到阈值<code>maxSzie</code>后，就会去删除<code>LinkedHashMap</code>的首部元素，来降低内存占用。</p><p><code>LinkedHashMap</code>在<code>HashMap</code>基础上使用了一个双端链表维持有序的节点。</p>]]></content>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式--基本原则</title>
      <link href="/2018/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
      <url>/2018/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h1 id="设计模式六大基本原则"><a href="#设计模式六大基本原则" class="headerlink" title="设计模式六大基本原则"></a>设计模式六大基本原则</h1><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><blockquote><p>单一职责原则英文名称为<code>Single Responsibility Principle</code>,简称SRP。</p></blockquote><p>优点：</p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义</li><li>可读性提高，复杂性降低</li><li>可维护性高</li></ul><p>对于开发过程来说，<strong>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化</strong>。</p><h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><blockquote><p>所有引用父类的地方都必须能透明的使用其子类的对象。简单的说就是 <strong>父类能出现的地方子类就可以出现。</strong></p></blockquote><p>里氏替换原则为良好的继承定义了一个规范，主要包含了4个含义：</p><ul><li><strong>子类必须完全实现父类的方法</strong>：<code>如果子类不能完整的实现父类的方法，或者父类方法在子类中已无法实现，建议断开父子继承关系，采用依赖、聚集，组合等方法代替继承。</code></li><li><strong>子类可以有自己的个性</strong>：<code>里氏替换原则可以正着用，但不能反过来用。子类出现的地方，父类未必可以使用。</code></li><li><strong>覆盖或实现父类的方法时输入参数可以被放大</strong>：<code>子类中的方法前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松。</code></li><li><strong>覆写或实现父类的方法时输出结果可以被缩小</strong></li></ul><p>在开发过程中尽量避免子类的”个性“，有了之后，与父类的关系就难调和。</p><h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><blockquote><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖于抽象</li></ul><p><strong>面向接口编程</strong></p></blockquote><p>本质就是通过抽象（接口或者抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的送耦合。</p><h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><blockquote><p>接口分为两种：实例接口 和 类接口</p><p>接口尽量细化，同时接口中的方法要尽量少。尽量使用多个专门的接口。</p></blockquote><p>接口隔离原则是对接口进行规范约束，包含以下4层含义：</p><ul><li>接口要尽量小 <strong>不能违反单一职责原则</strong></li><li>接口要高内聚：<code>高内聚就是提高接口、类，模块的处理能力，减少对外的交互</code></li><li>定制服务：<strong>只提供访问者需要的方法，减少可能引起的风险</strong></li><li>接口设计是有限度的：<code>接口的设计粒度越小，系统越灵活，但是会增加结构复杂度以及开发难度</code></li></ul><p>在开发过程中可以按照如下规则设计：</p><ul><li>一个接口只服务于一个子模块或业务逻辑</li><li>通过业务逻辑压缩接口中的public方法</li><li>已经被污染的接口尽量去修改</li><li>根据每个项目或产品去制定拆分标准</li></ul><h2 id="迪米特法则（LoD）–最少知识原则-LKP"><a href="#迪米特法则（LoD）–最少知识原则-LKP" class="headerlink" title="迪米特法则（LoD）–最少知识原则(LKP)"></a>迪米特法则（LoD）–最少知识原则(LKP)</h2><blockquote><p>一个对象应该对其他对象有最少的了解</p></blockquote><p>迪米特法则对类的低耦合提出了明确的要求，包含以下4个含义：</p><ul><li>只和朋友交流：<strong>在类的一个方法中尽量不引入一个类中不存在的对象</strong></li><li>朋友间也是有距离的：<strong>尽量不对外公布太多的public方法和非静态的public变量，尽量内敛</strong></li><li>是自己的就是自己的：<strong>如果一个方法放在本类中，既不增加类间关系，也不会对本类产生负面影响，就可以放置在本类中</strong></li><li>谨慎使用Serializable：<strong>在进行传输对象时需要进行序列化，当修改了属性时，会导致反序列化失败</strong></li></ul><p>迪米特法则核心观念就是<strong>类间解耦，弱耦合</strong>。</p><h2 id="开闭原则（OCP）—最基础的原则"><a href="#开闭原则（OCP）—最基础的原则" class="headerlink" title="开闭原则（OCP）—最基础的原则"></a>开闭原则（OCP）—最基础的原则</h2><blockquote><p>软件实体应该对扩展开放，对修改关闭。<code>一个软件实体应该通过扩展来实现变化，而不是去修改已有代码。</code></p></blockquote><p><strong>开闭原则并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合</strong></p><p>开闭原则的重要性：</p><ul><li>减少测试工作量</li><li>提高复用性</li><li>提高可维护性</li><li>面向对象开发</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式--单例模式</title>
      <link href="/2018/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote><p>一个类只能产生一个对象。确保某一个只有一个实例，而且自行实例化并向整个系统提供这个实例且构造函数私有化。</p></blockquote> <span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Pattern-Singleton.png" class="full-image" alt="单例模式" title="单例模式"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式通用代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式优点"><a href="#单例模式优点" class="headerlink" title="单例模式优点"></a>单例模式优点</h2><ol><li>由于单例模式只存在一个实例，减少了内存开支</li><li>减少了系统的开销</li><li>避免对资源的多重占用</li><li>在系统设置全局访问点，优化和共享资源访问</li><li>允许可变数目的实例，基于单例模式可以进行拓展，可以获得指定个数的对象实例，既节省系统资源，又解决单例对象过多的性能损耗</li></ol><h2 id="单例模式缺点"><a href="#单例模式缺点" class="headerlink" title="单例模式缺点"></a>单例模式缺点</h2><ol><li>单例模式一般没有接口，扩展很困难。</li><li>单例模式对测试是不利的，因为单例模式没有完成时，是不能进行测试的。</li><li>与单一职责原则有冲突</li></ol><h2 id="单例模式使用场景"><a href="#单例模式使用场景" class="headerlink" title="单例模式使用场景"></a>单例模式使用场景</h2><ol><li>要求生成唯一序列号的环境</li><li>在整个项目中需要一个共享访问点或共享数据</li><li>创建一个对象需要的消耗资源过多，如访问IO和数据库</li><li>需要定义大量的静态常亮和静态方法</li></ol><h2 id="单例模式的实现条件"><a href="#单例模式的实现条件" class="headerlink" title="单例模式的实现条件"></a>单例模式的实现条件</h2><ol><li><code>构造函数私有</code></li><li><code>有一个该类的静态私有对象</code></li><li><code>有一个静态的公用函数用于创建或获取本身静态私有对象</code></li><li><strong>线程同步</strong></li></ol><h2 id="单例模式注意事项"><a href="#单例模式注意事项" class="headerlink" title="单例模式注意事项"></a>单例模式注意事项</h2><ol><li>在高并发情况下，注意单例模式的线程同步问题</li><li>考虑对象的复制情况</li></ol><h2 id="单例模式实现实例"><a href="#单例模式实现实例" class="headerlink" title="单例模式实现实例"></a>单例模式实现实例</h2><ul><li><p>双重校验锁（DCL）–Java5之后可以安心使用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton mInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//反序列化提供的一个特殊方法，可以控制对象的反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mInstance;<span class="comment">//返回实例对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则<code>mInstance = new Singleton();</code>可能出现<code>mInstance</code>尚未被初始化的异常。</p><p><code>mInstance = new Singleton();</code>包括三步：<code>为对象分配内存</code>，<code>执行构造方法，初始化实例对象</code>，<code>把mInstance的引用指向分配的内存空间</code>。在JVM的执行过程中并不是原子性的。</p></blockquote></li><li><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为何可以保证线程安全？<code>虚拟机可以保证一个类的类构造器</code><clinit>()`在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。<strong>同一个类加载器下，一个类型只会被初始化一次。</strong></clinit></p></blockquote></li><li><p>枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>防止反序列化重新创建新对象，在Android中不建议使用枚举，大概会增加4倍消耗。</p></blockquote></li></ul><h2 id="单例模式在Android中的体现"><a href="#单例模式在Android中的体现" class="headerlink" title="单例模式在Android中的体现"></a>单例模式在Android中的体现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//../android/view/inoputmethod/InputMethodManager.java </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputMethodManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (InputMethodManager.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sInstance = <span class="keyword">new</span> InputMethodManager(Looper.getMainLooper());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ServiceNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Binder系列-ContentProvide</title>
      <link href="/2018/12/13/Binder%E7%B3%BB%E5%88%97-ContentProvide/"/>
      <url>/2018/12/13/Binder%E7%B3%BB%E5%88%97-ContentProvide/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Binder系列-ServiceManager相关</title>
      <link href="/2018/12/12/Binder%E7%B3%BB%E5%88%97-ServiceManager%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/12/12/Binder%E7%B3%BB%E5%88%97-ServiceManager%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Binder及AIDL</title>
      <link href="/2018/12/11/Binder%E5%8F%8AAIDL/"/>
      <url>/2018/12/11/Binder%E5%8F%8AAIDL/</url>
      <content type="html"><![CDATA[<h1 id="主要分析IPC机制，Binder框架以及AIDL原理"><a href="#主要分析IPC机制，Binder框架以及AIDL原理" class="headerlink" title="主要分析IPC机制，Binder框架以及AIDL原理"></a>主要分析IPC机制，Binder框架以及AIDL原理</h1><h2 id="1-IPC机制"><a href="#1-IPC机制" class="headerlink" title="1.IPC机制"></a>1.IPC机制</h2><blockquote><p>IPC是Inter-Process Communication的缩写。含义为进程间通信或者跨进程通信，指代两个进程间进行数据交换的过程、</p></blockquote><p>还需要理解进程以及线程的区别和联系</p><blockquote><p>进程：一般指一个执行单元，在设备上一般代指应用程序。</p><p>线程：CPU调度的最小单元且线程是有限资源。</p><p>一个进程可以包含多个线程，即一个应用内部可以执行多个任务。在Android中就会区分为<code>主线程(UI线程)</code>和<code>子线程</code>，一般会在子线程上做耗时操作，主线程不可。</p></blockquote><p>由于IPC的使用场景是在多进程模式下。多进程的使用情况主要分为两种：<code>一个应用因为某些原因需要采用多进程模式来实现，比如获取更大内存空间</code>,<code>当前应用需要向其他应用来获取数据</code>。</p><h3 id="1-多进程模式"><a href="#1-多进程模式" class="headerlink" title="1.  多进程模式"></a>1.  多进程模式</h3><ol><li><p>开启多进程模式</p><ul><li>通过JNI在native层fork一个新的进程</li><li>在<code>AndroidManifest.xml</code>中给四大组件指定属性<code>android:process</code>。</li></ul></li><li><p>进程名的命名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">"com.wxy.test.AActivity"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:process</span>=<span class="string">":remote"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">"com.wxy.text.BActivity"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:process</span>=<span class="string">"com.wxy.test.remote"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码为两种命名方案</p><ul><li>省略包名以:开头：代指进程名为<code>com.wxy.test:remote</code>为<strong>私有进程</strong>，其他进程的组件不可以和他跑到同一个进程中</li><li>完整命名：如上述<code>com.wxy.test.remote</code>为<strong>全局进程</strong>，其他应用可以通过<code>ShareUID方式与他在同一进程中运行。</code></li></ul><p>Android系统会为每一个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。</p><p>上述通过ShareUID将两个应用跑在同一个进程间是有要求的，<strong>必须是两个应用具有相同的ShareUID且签名相同才可以</strong>。达成上述要求时就可以 <strong>共享两者间的data目录、组件信息以及内存数据</strong>。</p><p>拓展知识：当两者签名不同时，会触发安装错误[INSTALL_FAILED_SHARED_USER_INCOMPATIBLE]</p></li><li><p>查看进程信息</p><p><code>adb shell ps|greb $packageName</code></p></li><li><p>运行机制</p><p>Android为每一个应用分配了一个独立的虚拟机，或者说为了每一个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上就会有不同的地址空间，就会导致不同的虚拟机访问同一个类的对象会产生多分副本。</p><p><strong>所有运行在不同进程的四大组件，只要他们通过内存共享数据，就会共享失败。</strong></p></li><li><p>多进程造成的问题</p><ul><li>静态成员变量和单例模式完全失效</li><li>线程同步机制失败</li><li>SharedPreferences的可靠性下降 <code>不支持多进程读写</code></li><li>Application会多次创建<code>分配了独立的虚拟机</code></li></ul><p>一个应用内的多进程：<strong>相当于两个不同的应用采用了ShareUId模式</strong>。虽说不能直接共享内存数据，但是可以通过跨进程通信来实现数据交互。</p></li></ol><h3 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2. 序列化"></a>2. 序列化</h3><blockquote><p> 当我们需要跨进程通信时，传递的数据就需要进行序列化传递，然后接受方在反序列化得到传递数据</p></blockquote><blockquote><p>什么是序列化？</p><p>将对象转化为可以传输的二进制流的过程，就可以通过序列化，转化为可以在网络传输或者保存到本地的流，从而进行传输数据。反序列化即为从二进制流转化为对象的过程。</p><p>也为了解决对象的持久化问题。当你在程序中声明一个类后，程序关闭则释放对象，持久化就是为了应用关闭后类的内容依然存在。</p></blockquote><ol><li><p><code>Serializable</code></p><blockquote><p>由Java提供的一个序列化接口，为对象提供标准的序列化以及反序列化操作。</p></blockquote><p>使用方式相当简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">//该参数是用来辅助序列化以及反序列化的过程，原则上该值相同才可以进行序列化以及反序列化的操作.</span></span><br><span class="line">    <span class="comment">//不指定时 系统也会自动生成 但是容易因为变量的数量和类型发生改变而导致序列化失败。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">123123L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点：使用简单但是效率较低，在序列化(ObjectOutputStream)以及反序列化(ObjectInputStream)类调用中会有大量的I/O操作。</p><p>适用场景：将对象类序列化存储到设备或者需要网络传输。</p></li><li><p><code>Parcelable</code></p><blockquote><p>Android提供的序列化接口，使用起来较为繁琐</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Creator&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化功能由<code>writeToParcel</code>实现，反序列化由<code>Parcel的read</code>实现。</p><p>优缺点：传递效率高效使用较为繁琐，主要序列化都在内存上进行。由于Parcelabel是Android提供的方法，可能会由于版本更新而会有些许改动。</p><p>适用场景：在内存的序列化中使用。</p></li></ol><h3 id="3-IPC方式"><a href="#3-IPC方式" class="headerlink" title="3. IPC方式"></a>3. IPC方式</h3><blockquote><p>本节主要讲述各种跨进程通信方式，目前有以下六种：</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/IPC-mode.png" class="full-image" alt="IPC方式" title="IPC方式"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>上述方式实际都是通过Binder来实现的</p></blockquote><h4 id="1-Bundle"><a href="#1-Bundle" class="headerlink" title="1.Bundle"></a>1.Bundle</h4><blockquote><p>支持在<code>Activity、Service和Receiver</code>之间通过Intent来传递Bundle数据(调用<code>intent.putExtra()</code>)，由于Bundle实现了Parcelable接口，所以可以方便的在不同进程间传递(<code>传输的数据必须可以被序列化，不然无法进行传递</code>)。可以看做为一个特殊的Map类型。</p><p><strong>最简单的进程间通信方式。</strong></p></blockquote><p>拓展：当A进程计算后的结果无法通过Bundle传递至B进程时，可以将计算的过程用B进程的一个Service进行操作，然后在回调给B进程。</p><h4 id="2-文件共享"><a href="#2-文件共享" class="headerlink" title="2.文件共享"></a>2.文件共享</h4><blockquote><p><strong>两个进程间通过读/写一个文件来进行数据传递</strong>，适用于对数据同步要求不高的进程间通信，并且需要对<strong>并发读/写</strong>进行妥善处理</p></blockquote><p>拓展：Android中的SharedPreferences也是文件共享方案的一种，但由于系统提供了一种缓存策略(内存中会有一份该文件的缓存)，导致它在多进程模式下，读/写并不可靠，甚至丢失数据。</p><h4 id="3-Messenger"><a href="#3-Messenger" class="headerlink" title="3.Messenger"></a>3.Messenger</h4><blockquote><p>轻量级的IPC方案，可以在不同的进程间传递Message对象。调用<code>Messenger.send(Message message)</code>传递Message对象。</p><p>Messager的底层实现是<code>AIDL</code>。它对AIDL做了封装，由于它一次只可以处理一个请求<strong>（串行请求）</strong>，因此不需考虑线程同步的问题。不过不能直接调用服务端的方法，只能通过传递消息处理。</p><p>由于主要传递的都是Message对象，导致无法实现远程调用。</p></blockquote><p>Messenger的构造函数分以下两种：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span></span>&#123;</span><br><span class="line">    mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span></span>&#123;</span><br><span class="line">    mTarget = target.getImessenger();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>拓展：<strong>Handler主要用于线程间通信，Messenger用于进程间通信</strong></p></blockquote><p>实现一个Messenger需要以下两步：</p><ul><li><p><strong>服务端进程</strong>：</p><p>①创建一个Service来处理客户端的连接请求</p><p>②创建一个Handler并由他构造一个Messenger对象</p><p>③然后在Service的onBind方法中返回该Messenger对象中的Binder。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MessengerServcice.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHanler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//处理返回的Message消息</span></span><br><span class="line">            ...</span><br><span class="line">                <span class="comment">//获取Client返回的Messenger对象</span></span><br><span class="line">                    Messenger client = msg.replyTo;</span><br><span class="line">                    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//拼接数据 发送消息</span></span><br><span class="line">                    &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过Handler构造一个Messenger对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHanler());</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回IBinder对象 将消息交由对应Handler处理</span></span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>客户端进程</strong>：</p><p>①绑定服务端Service –<code>bindService</code></p><p>②绑定后使用Service返回的IBinder对象创建一个Messenger对象</p><p>③通过Messenger对象向服务端发送Message  <strong>完成单向通信</strong></p><p>④创建一个Handler由此创建一个Messenger对象，然后将Messenger对象放入Message的<strong>replyTo</strong>字段传递给Server。  <strong>完成双向通信</strong></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_messenger);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class);</span><br><span class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger mService;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            Message msg = Message.obtain(<span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">            Bundle data = <span class="keyword">new</span> Bundle();</span><br><span class="line">            data.putString(<span class="string">"msg"</span>, <span class="string">"it is from client"</span>);</span><br><span class="line">            msg.setData(data);</span><br><span class="line">            <span class="comment">//若存在则形成了双向通信</span></span><br><span class="line">            msg.replyTo = mGetReplyMessenger;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mService.send(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messenger mGetReplyMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHanler());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHanler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//处理消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//取消绑定service</span></span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Messenger的工作原理：</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Messenger-principle.png" class="full-image" alt="Messenger工作原理" title="Messenger工作原理"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h4 id="4-AIDL"><a href="#4-AIDL" class="headerlink" title="4.AIDL"></a>4.AIDL</h4><p><a href="#3-AIDL相关">AIDL相关</a></p><h4 id="5-ContentProvider"><a href="#5-ContentProvider" class="headerlink" title="5.ContentProvider"></a>5.ContentProvider</h4><blockquote><p>ContentProvider是专门用于不同应用间进行数据共享的方式，底层同样是由Binder实现。<strong>主要是提供了一个统一的接口为了存储和获取数据。</strong></p></blockquote><p><a href="https://www.jianshu.com/p/9048b47bb267" target="_blank" rel="noopener">ContentProvide</a></p><h4 id="6-Socket"><a href="#6-Socket" class="headerlink" title="6.Socket"></a>6.Socket</h4><blockquote><p>Socket也称为”套接字”，是网络通信中的概念，分为流式套接字(<code>基于TCP协议，采用流的方式提供可靠的字节流服务</code>)和用户数据报套接字（<code>基于UDP协议，采用数据报文提供数据打包发送的服务</code>）两种。<strong>Socket不仅可以跨进程通信还可以跨设备通信。</strong></p></blockquote><p><code>TCP协议是面向连接的协议，提供稳定的双向通信功能，因为连接的建立需要经过&#39;三次握手&#39;才能完成，由于本身提供了超时重传机制，因此具有很高的稳定性。</code></p><p><code>UDP是无连接的，提供不稳定的单向通信功能，在性能上拥有良好的效率，但数据不一定能够有效传输。</code></p><ol><li><p>实现方法：</p><p>服务端：</p><ul><li>创建一个Service，在线程中建立TCP服务，监听相应的端口等待客户端连接请求</li><li>与客户端连接时，会生成新的Socket对象，利用它可与客户端进行数据传输</li><li>断开连接时，关闭相应的socket并结束线程</li></ul><p>客户端：</p><ul><li>开启一个线程，通过Socket发起连接请求</li><li>连接成功后，读取服务端消息</li><li>断开连接，关闭Socket</li></ul></li><li><p>注意事项：</p><ul><li>需要声明网络权限</li></ul></li></ol><p>以上6种IPC方式比较：</p><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Bundle</td><td>简单易用</td><td>只能传输Bundle支持的数据类型</td><td>四大组件的进程间通信</td></tr><tr><td>文件共享</td><td>简单易用</td><td>不适合高并发场景，且无法做到实时通信</td><td>无并发访问情形，数据简单且实时性不高</td></tr><tr><td>AIDL</td><td>功能强大，支持一对多并发通信，支持实时通信</td><td>使用稍复杂，需要处理好线程同步</td><td>一对多通信且支持远程调用</td></tr><tr><td>Messenger</td><td>功能强大，支持一对多串行通信，支持实时通信</td><td>不能很好处理高并发场景，数据只能通过Message进行传输</td><td>低并发的一对多即时通信，并且不需要返回结果，不需要远程调用</td></tr><tr><td>ContentProvider</td><td>在数据访问方面功能强大，支持一对多数据共享，可通过Call方法扩展其他操作</td><td>受约束的AIDL实现，主要提供对数据的CRUD操作</td><td>一对多的进程间数据共享</td></tr><tr><td>Socket</td><td>功能强大，可以通过网络传输字节流，支持一对多并发通信</td><td>实现细节稍微麻烦</td><td>网络数据交换</td></tr></tbody></table><h2 id="2-Binder机制"><a href="#2-Binder机制" class="headerlink" title="2.Binder机制"></a>2.Binder机制</h2><blockquote><p>在Linux中，为了避免一个进程对其他进程的干扰，进程之间是相互独立的。</p><p>Android的进程间通信采用了Binder出于两个方面的考虑：性能和安全。</p><p>性能：在移动设备上对性能的要求是比较严苛的，在Linux上通信方式例如管道，Socket都需要复制两次数据，Binder只需一次。</p><p><code>对于消息队列、Socket和管道而言，数据先从发送方的缓存区拷贝到内核开辟的缓存区中，再从内核缓存区拷贝至接收方缓存区，需要两次拷贝过程；Binder是从发送方缓存区到内核的缓存区，而接受方的缓存区与内核缓存区映射在同一块物理地址上，节省了一次数据拷贝的过程。</code></p><p>安全：传统的Linux通信是不包含通信双方的身份验证的，Binder自带身份验证，提高了安全性。</p><p><code>Android提供了UID机制，可以有效的鉴别用户身份。</code></p></blockquote><p>概念：</p><ul><li>直观来说，Binder是Android中的一个类，实现了IBinder接口。</li><li>IPC角度来说，Binder是Android中的一种跨进程通信方式。</li><li>Android Framework角度来说，Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁。</li><li>应用层来说，Binder是客户端和服务端进行通信的媒介。</li></ul><h3 id="1-Binder框架"><a href="#1-Binder框架" class="headerlink" title="1.Binder框架"></a><strong>1.Binder框架</strong></h3><p>Binder通信采用了<strong>C/S架构</strong>。在Android系统的Binder机制中，由一系列系统组件组成，分别是</p><ul><li><code>Client</code> 客户端进程</li><li><code>Server</code> 服务端进程</li><li><code>Service Manager</code> 管理系统中的各种服务 提供注册、查询和返回代理服务对象的功能</li><li><code>Binder 驱动</code> 负责建立进程见得Binder连接，进程间的数据交互等底层操作</li></ul><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/IPC-Binder.jpg" class="full-image" alt="Binder架构图" title="Binder架构图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>Client,Server,Service Manager处于用户空间，Binder驱动位于内核空间。</p><p>下面介绍四个组成部分的作用：</p><ul><li><p><strong>Service Manager：</strong>服务的管理者，指代的是Native层的ServiceManager(C++)，是整个Binder通信机智的大管家，是Android进程间通信机制的守护进程。将Binder的名字转换为Client中对该Binder的引用，使得Client可以通过Binder名字来获取Service中的引用。<a href="/2018/12/12/Binder系列-ServiceManager相关/" title="Binder系列-ServiceManager相关">Binder系列-ServiceManager相关</a></p></li><li><p><strong>Binder驱动：</strong>主要是驱动设备的<strong>初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)</strong>。</p><p>和硬件设备没有任何关系。它工作于内核态，以misc设备注册在设备目录/dev下，用户可以通过/dev/binder访问它。负责进程之间binder通信的建立、传递、计数管理和数据的传递交互等底层支持。主要功能由<code>ioctl()/*主要负责在两个进程间收发IPC和IPC reply数据，常用命令为BINDER_WRITE_READ*/</code>实现。</p></li><li><p><strong>Client&amp;Service：</strong>在Binder驱动和Service Manager提供的基础设施上进行C-S之间的通信。<code>Server进程启动时，将在本进程内运行的Service注册到Service Manager中，并且启动一个Binder线程池，用来接收Clien请求。然后Client进程向Service Manager查询所需要的Service，并获得一个Binder代理对象，通过该代理对象向Service发出请求。</code></p></li></ul><p>四大组件彼此之间不是直接交互的，都是通过Binder驱动进行交互，从而实现IPC通信方式。<strong>系统需要启动了Service Manager之后，Client端和Server端需要现获取了Service Manager接口后，才可以开始通信服务。</strong></p><h3 id="2-Binder工作机制"><a href="#2-Binder工作机制" class="headerlink" title="2.Binder工作机制"></a>2.<strong>Binder工作机制</strong><!--需要结合对应的客户端代码分析--></h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Binder-workflow.png" class="full-image" alt="Binder工作机制" title="Binder工作机制"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li>在Server端创建好一个Binder对象后，内部就会开启一个线程用于接收Binder驱动发送的消息，收到消息后就会执行<code>onTransact()</code>,然后按照参数执行不同的服务端代码。</li><li>在服务端成功Binder对象后，Binder驱动会创建一个<code>mRemote</code>对象，客户端可以借助它调用<code>transcat()</code>向服务端发送消息</li><li>客户端要访问Binder的远程服务，就要获取远程服务的Binder对象在Binder驱动中的<code>mRemote</code>引用，获取到引用后既可以调用相关方法。</li></ul><p><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder相关</a></p><h3 id="3-Binder连接池"><a href="#3-Binder连接池" class="headerlink" title="3.Binder连接池"></a>3.Binder连接池</h3><blockquote><p>首先回顾一下AIDL的使用方式：①创建一个Service和AIDL接口②创建一个类继承自AIDL接口中的Stub类并实现Stub中的抽象方法③在Service的onBind中返回这个类的对象④客户端绑定Service后就可以直接访问服务端的方法。</p><p>当业务需求越来越多时，上述的创建方式就会产生很多Service类，导致系统资源耗费颜值、应用过度重量级的问题。所以产生了<code>Binder连接池</code>的概念。</p></blockquote><blockquote><p>主要作用为 <strong>将每个业务模块的Binder请求统一转发到远程Service上去执行，从而避免重复创建Service</strong>。   </p></blockquote><p>工作原理：</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/BinderPool.png" class="full-image" alt="BinderPool工作原理" title="BinderPool工作原理"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>每个业务模块创建自己的AIDL接口并实现，然后向服务端传递自己的<strong>唯一标识(BinderCode)及对应的Binder对象</strong>。服务端只要一个Service，然后实现<code>queryBinder()</code>接口，根据唯一标识返回对应的Binder对象。</p><p>实现方式：</p><ul><li>创建对应的AIDL文件并有具体实现</li><li>创建BinderPool.java以及IBinderPool.aidl文件</li><li>实现远程服务BinderPoolService，并在onBind()中返回实例化的BinderPool对象</li><li>实现BinderPool方法，并在<code>queryBinder()</code>中做好对应处理</li><li>客户端调用BinderPoolService</li></ul><h2 id="3-AIDL相关"><a href="#3-AIDL相关" class="headerlink" title="3.AIDL相关"></a>3.AIDL相关</h2><blockquote><p>在Messenger中讲到它是基于AIDL的，但是只能处理串行的消息，如果有大量的消息同时发送进来，也只能一个个处理，而且不支持跨进程调用服务端的方法，就需要用到AIDL来处理上述情况。</p><p><strong>AIDL默认是同步调用的，若需要异步调用–可以添加一个异步回调接口执行结果异步回调给调用方，需要使用RemoteCallbackList</strong></p><p><strong>AIDL本质上就是系统为我们提供了一种快速实现Binder的工具，我们可以不依赖于AIDL，自己去完全实现一个Binder。</strong></p></blockquote><h3 id="1-AIDL支持的数据类型"><a href="#1-AIDL支持的数据类型" class="headerlink" title="1.AIDL支持的数据类型"></a>1.AIDL支持的数据类型</h3><ul><li>基本数据类型：<code>byte、int、long、float、double、boolean，char</code></li><li>String 和 CharSequence</li><li>ArrayList，HashMap(<strong>包括key，每个元素必须可以被AIDL支持</strong>)</li><li>实现了Parcelabe接口的对象 <strong>必须要显示Import进来</strong></li><li>所有AIDL接口本身也会被调用<strong>必须要显示Import进来</strong></li></ul><h3 id="2-定向tag"><a href="#2-定向tag" class="headerlink" title="2.定向tag"></a>2.定向tag</h3><blockquote><p>除了基本数据类型，其他类型的参数必须加上方向 <strong>in,out,inout</strong>，用于表示在跨进程通信中的数据流向。</p></blockquote><ul><li><code>in</code>：表示数据只能由客户端流向服务端。服务端会收到这个对象的完整数据，<strong>但在服务端对对象进行修改不会对客户端传递进来的对象造成影响。</strong></li><li><code>out</code>：表示数据只能由服务端传递到客户端。服务端会接受到这个对象的空对象，<strong>但在服务端接收到的空对象有任何修改之后客户端会同步发生变化。</strong></li><li><code>inout</code>：表示数据可以在服务端和客户端之间双向流通。服务端会收到这个对象的完整数据，<strong>且客户端会同步服务端对该对象的任何改动。</strong></li></ul><h3 id="3-关键类和方法"><a href="#3-关键类和方法" class="headerlink" title="3.关键类和方法"></a>3.关键类和方法</h3><blockquote><p>添加完AIDL文件之后，会自动生成对应的Java文件，这个是关键所在。</p></blockquote><p><code>DESCRIPTOR</code>：Binder的唯一标识，一般用当前Binder的类名表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.example.wxy.ipc.IBookManager"</span>;</span><br></pre></td></tr></table></figure><p><code>asInterface(android.os.IBinder obj)</code>：用于将服务端的Binder对象转换成客户端需要的AIDL接口类型的对象，不过是要区分进程的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.example.wxy.ipc.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="comment">//位于同一进程则返回服务端Stub对象本身</span></span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.wxy.ipc.IBookManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.example.wxy.ipc.IBookManager) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则返回封装后的Stub.proxy对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.example.wxy.ipc.IBookManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>asBinder()</code>：返回当前Binder对象</p><p><code>Proxy</code>：这个类运行在客户端，客户端调用这个类来调用服务端的代码(涉及到了<strong>代理模式</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">wxy</span>.<span class="title">ipc</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> com.example.wxy.ipc.<span class="function">Book <span class="title">addBookInout</span><span class="params">(com.example.wxy.ipc.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                com.example.wxy.ipc.Book _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="comment">//在定向tag为out时 没有这个if</span></span><br><span class="line">                    <span class="comment">//判断传入参数是否为空 ，为空则不写入，不为空则写入_data流</span></span><br><span class="line">                    <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addBookInout, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">                        _result = com.example.wxy.ipc.Book.CREATOR.createFromParcel(_reply);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _result = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//在定向tag 为in时 没有这个if</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">                        book.readFromParcel(_reply);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析上述生成的代码：</p><ul><li><code>_data _reply</code>：<code>_data</code>存储传参的数据，<code>_reply</code>存储方法的返回值数据</li><li><code>transcat(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags)</code>：客户端和服务端通信的核心方法。调用后会挂起当前线程，等候服务端执行任务完成通知并接受返回的<code>_reply</code>数据。<ul><li><code>code</code>：分配的方法ID是自动生成的</li></ul></li></ul><p>工作流程为：</p><ol><li>生成<code>_data</code> 和<code>_reply</code>数据，在<code>_data</code>中存入客户端数据</li><li>调用<code>transcat()</code>传递数据至服务端，并调用服务端中<code>onTranscat()</code>的指定方法</li><li>接收<code>_reply</code>数据，取出服务端返回的数据使用</li></ol><p><code>onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)</code>：运行在服务器端的Binder线程池中，客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法处理。参数介绍：</p><ul><li><p><code>code</code>：可以确定客户端所请求的方法是哪个</p></li><li><p><code>data</code>：取出目标方法所需参数</p></li><li><p><code>reply</code>：里面填写请求的返回值</p></li><li><p><code>flags</code>：设置进行IPC的模式，0双向流通 1单向流通 **AIDL生成的.java文件均设置0</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_addBookInout: &#123;</span><br><span class="line">                    data.enforceInterface(descriptor);</span><br><span class="line">                    com.example.wxy.ipc.Book _arg0;</span><br><span class="line">                    <span class="comment">//定向tag为in时有这段if 从_data中读取book对象并赋值</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.example.wxy.ipc.Book.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    com.example.wxy.ipc.Book _result = <span class="keyword">this</span>.addBookInout(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">if</span> ((_result != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        reply.writeInt(<span class="number">1</span>);               _result.writeToParcel(reply,android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        reply.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//定向tag为out时有这段if 若服务端对传参进行过修改 都会同步到_reply中</span></span><br><span class="line">                    <span class="keyword">if</span> ((_arg0 != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        reply.writeInt(<span class="number">1</span>);                     _arg0.writeToParcel(reply,android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        reply.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析上述生成的代码：</p><p>处理完由客户端调用的<code>transcat()</code>传递进来的<code>_data</code>，再将处理完的数据写入到<code>_reply</code>中。</p><p>工作流程为：</p><ol><li>获取由<code>transcat()</code>传入的数据，根据对应的<code>code</code>执行相应方法</li><li>执行方法后，解析对应传递过来的数据<code>_data</code></li><li>将需要回传的数据写入<code>_reply</code>中，传回给客户端</li></ol><p>整套AIDL实现的流程如下：</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/AIDL-IPC.png" class="full-image" alt="AIDL实现IPC流程" title="AIDL实现IPC流程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>拓展：</p><ol><li><p>可能会产生ANR</p><p>由于客户端在调用远程服务方法时，客户端线程会被挂起，如果服务端的方法执行比较耗时，就会导致客户端ANR，或者在<code>onServiceConnected</code>和<code>onServiceDisconnected</code>中调用了服务端的耗时方法也会导致ANR。</p><p>当服务端调用客户端的listener方法时，该方法会运行在客户端的<code>binder线程池中</code>，若调用了耗时方法，也会导致ANR。</p></li><li><p>AIDL解注册失败</p><blockquote><p>服务端无法找到注册时使用的listener而导致解注册失败。<strong>因为Binder客户端会把传递过来的对象重新转化并生成一个新的对象，而且对象是不能跨进程传输的，对象跨进程传输的本质就是序列化和反序列化的过程。</strong></p></blockquote><p>这时需要用到<code>RemoteCallBackList</code>，是系统专门提供用于删除跨进程的listener的接口，而且内部实现了线程同步的功能<strong>(内部使用了<code>synchronized</code>)</strong>。使用注意事项:<strong><code>beginBroadcast</code>和<code>finishBroadcast</code>必须要配对使用。</strong></p></li><li><p>性能损耗较大</p><blockquote><p>客户端频繁调用服务端方法，就需要实现一个<strong>观察者模式</strong>，当客户端的数据发生变化时再去通知服务端操作，减少频繁查询。</p></blockquote></li></ol><h3 id="4-权限验证"><a href="#4-权限验证" class="headerlink" title="4.权限验证"></a>4.权限验证</h3><blockquote><p>默认情况下，远程服务所有人都可以进行连接并调用，所以应该需要加入权限验证系统来保证安全。</p></blockquote><ul><li><p>在<code>onBind</code>中进行验证，不通过直接返回null，导致客户端无法绑定。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在AndroidManifest.xml中定义该权限    </span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"com.example.wxy.permission.checkBook"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line">//如果注册了该权限，则可以绑定成功 否则失败</span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.example.wxy.permission.checkBook"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在配置Service时 设置<code>&lt;intent-filter&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".service.AIDLService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.wxy"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android需要的必备知识</title>
      <link href="/2018/12/09/Android%E9%9C%80%E8%A6%81%E7%9A%84%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/12/09/Android%E9%9C%80%E8%A6%81%E7%9A%84%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="1-Binder原理、AIDL的使用、多进程的定义和特性"><a href="#1-Binder原理、AIDL的使用、多进程的定义和特性" class="headerlink" title="1.Binder原理、AIDL的使用、多进程的定义和特性"></a>1.Binder原理、AIDL的使用、多进程的定义和特性</h1><h1 id="2-View的measure、layout和draw，View的工作原理"><a href="#2-View的measure、layout和draw，View的工作原理" class="headerlink" title="2.View的measure、layout和draw，View的工作原理"></a>2.View的measure、layout和draw，View的工作原理</h1><h1 id="3-事件分发原理和规则"><a href="#3-事件分发原理和规则" class="headerlink" title="3.事件分发原理和规则"></a>3.事件分发原理和规则</h1><h1 id="4-Handler、Looper、Thread三者之间的关系；"><a href="#4-Handler、Looper、Thread三者之间的关系；" class="headerlink" title="4.Handler、Looper、Thread三者之间的关系；"></a>4.Handler、Looper、Thread三者之间的关系；</h1><h1 id="5-Activity"><a href="#5-Activity" class="headerlink" title="5.Activity"></a>5.Activity</h1><h1 id="6-Service"><a href="#6-Service" class="headerlink" title="6.Service"></a>6.Service</h1>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThreadLocal原理分析</title>
      <link href="/2018/12/09/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/09/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="ThreadLocal详解"><a href="#ThreadLocal详解" class="headerlink" title="ThreadLocal详解"></a>ThreadLocal详解</h1><blockquote><p>在前几节Handler详解中介绍 如何获取Looper对象时提及了是利用ThreadLocal来进行Looper的存储与获取。</p></blockquote><h2 id="1-初步理解ThreadLocal"><a href="#1-初步理解ThreadLocal" class="headerlink" title="1.初步理解ThreadLocal"></a>1.初步理解ThreadLocal</h2><p>ThreadLocal的定义为：<strong>用于提供线程变量，在多线程环境中可以保证各个线程的变量独立于其他线程里的变量。</strong>主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量不会互相干扰，适用于<code>高并发状态下实现无状态的调用即各个线程依赖不同的变量完成操作</code>。</p><blockquote><p>ThreadLocal保证的是多线程环境下的独立性，同步机制则保证多线程下数据的一致性。</p></blockquote><h2 id="2-使用样例"><a href="#2-使用样例" class="headerlink" title="2.使用样例"></a>2.使用样例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String label;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        label = <span class="string">"main"</span>;</span><br><span class="line">        threadLocal.set(<span class="string">"main"</span>);</span><br><span class="line">        <span class="comment">//new Thread</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                label = <span class="string">"new"</span>;</span><br><span class="line">                threadLocal.set(<span class="string">"new"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"label = "</span> + label);</span><br><span class="line">        System.err.println(<span class="string">"threadLocal = "</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log</span></span><br><span class="line">label = <span class="keyword">new</span></span><br><span class="line">threadLocal = main</span><br></pre></td></tr></table></figure><p>对于ThreadLocal中的变量，在一个线程中修改它的值，并不会影响到在其他线程中的值。<strong>ThreadLocal中的值在每个线程中都是独立的。</strong></p><h2 id="3-深入理解ThreadLocal"><a href="#3-深入理解ThreadLocal" class="headerlink" title="3.深入理解ThreadLocal"></a>3.深入理解ThreadLocal</h2><p>ThreadLocal类中提供了以下几个方法来进行变量的操作：</p><ul><li><code>public T get()</code>获取ThreadLocal在当前线程中保存的变量副本</li><li><code>public void set(T value)</code>设置当前线程中的变量副本</li><li><code>public void remove()</code>移除当前线程中的变量副本</li><li><code>protected T initialValue()</code>设置ThreadLocal的初始值，该方法为延迟加载</li></ul><p>接下来具体查看上述方法的内部实现。加深理解</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回当前线程中存储的变量副本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取到持有变量副本的map</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//map存在则返回存储值</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//该map key为ThreadLocal 故获取value用的是this</span></span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不存在则返回默认值</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="set-T-value"><a href="#set-T-value" class="headerlink" title="set(T value)"></a><code>set(T value)</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置当前线程的变量副本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//map不为null 则保存value</span></span><br><span class="line">    <span class="keyword">if</span>(map!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则创建一个ThreadLocalMap后保存value</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        createMap(t,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a><code>remove()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除保存的变量副本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ThreadLocalMap map = getMap(Thread.currentThread);</span><br><span class="line">    <span class="comment">//map不为空 则移除当前ThreadLocal对应的变量副本</span></span><br><span class="line">    <span class="keyword">if</span>(map!=<span class="keyword">null</span>)</span><br><span class="line">        map.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue()"></a><code>initialValue()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类可重写该方法 进行默认值的设置</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">对应有setInitialValue()</span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">   T value = initialValue();</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span>(map!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>,value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        createMap(t,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述四个方法中都会涉及到一个类<strong><code>ThreadLocalMap</code></strong>，该类是ThreadLocal的核心机制实现。<code>在使用ThreadLocal的方法对存储变量进行操作时都需要获得当前线程对应的ThreadLocalMap来对变量进行操作</code>。<strong>每个线程都会有专属的ThreadLocalMap，其中维护的value也是对应当前线程的。就保证了ThreadLocal中存储的变量都是相互独立的，不会受到多线程环境的影响。</strong></p><p><strong><code>ThreadLocalMap</code></strong></p><blockquote><p>该类为ThreadLocal中的内部类，没有实现Map接口，内部自己实现了Map的功能。</p></blockquote><ol><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">           table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">           <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">           table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">           size = <span class="number">1</span>;</span><br><span class="line">           setThreshold(INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>初始对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始容量，必须是 2 的幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储数据的哈希表</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// table 中已存储的条目数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示一个阈值，当 table 中存储的对象达到该值时就会扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 threshold 的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由内部实现了一套Map机制</p></li><li><p>Entry</p><blockquote><p>table中存储的都为Entry对象，用于保存K-V数据结构</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">   </span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry继承自<code>WeakRefrence&lt;ThreadLocal&lt;?&gt;&gt;</code>为弱引用类型并且限制了<code>K</code>只能为ThreadLocal对象，但是对应的<code>V</code>为强引用类型，则可能导致<strong>内存泄漏</strong>。</p></li><li><p>保存key-value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用set方法将 key-value类型进行存储</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="comment">//计算要存储的索引位置</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//判断要存储的索引位置是否已经存在Entry 存在则继续向下</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="comment">//key相同则更新</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//key为空 代表该位置对应的Entry已失效，需要直接进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若不存在 则将Entry保存到该位置</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="comment">//超过当前负载 则需进行扩容机制 重新调整table</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>使用当前的ThreadLocal中对应的threadLocalHashCode来计算该键值对要存储的索引位置。该值是由ThreadLocal对象自动生成的，创建时就会进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment">     * zero.</span></span><br><span class="line"><span class="comment">     * 使用AtomicInteger用来保证多线程环境下不会受到影响</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment">     * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment">     * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next hash code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当table中的条目超出阈值时就需要进行扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容是 新table的容量为原先的两倍 触发条件为table中的条目数超出了阈值的3/4</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;oldLen;++j)&#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span>(e!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           ThreadLocal&lt;?&gt; k =e.get();</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="keyword">null</span>)&#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//重新计算扩容后的Hash值</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span>(newTab[h]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    h = nextIndex(h,newLen);</span><br><span class="line">                &#125;</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新设定当前容量</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取Entry对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据传递进来的ThreadLocal 获取对应的entry</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//重新计算threadLocal对应的index</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="comment">//entry不为空且对应位置key相同 则返回Entry</span></span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则 寻找临近的位置是否存在对应的值</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">//当前传递的entry不为空 则开始循环</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="comment">//相同则返回对应的 entry</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//key消失 则移除对应的Entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//继续向下寻找</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>getEntryAfterMiss()</code>时，大部分由于哈希冲突(<code>Hash slot</code>)导致的。由于ThreadLocalMap没有使用链表的方式实现,所以解决Hash冲突的方式也只能使用一种<strong>线性探测</strong>的方式。<code>线性探测意为根据初始key的hashcode来确定元素在表中的位置，若发现位置已被占用，则会利用固定算法找到下一个位置，直到找到可以存放的位置。</code></p><p>ThreadLocalMap解决Hash冲突的方法就是 <code>步长+1或-1</code>,寻找下一个相邻的位置。</p></li><li><p>移除指定的Entry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据threadLocal移除对应位置的Entry</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他知识点</p><p>在上述<code>set(),get(),remove()</code>方法中都涉及到了一个点，都会去进行一次判断当前位置的Entry是否无效并清除的操作，主要是为了<strong>降低内存泄漏发生的可能性</strong>。</p><p>上面分析中就有提到ThreadLocalMap的key为弱引用型，而value为强引用型，就可能导致内存泄漏发生。</p><p><strong>所以当我们使用ThreadLocal时，每次使用完毕都需要主动调用一次remove()方法来防止内存泄漏的发生。</strong></p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>每个ThreadLocal中只能保存一个变量副本，如果需要多个则需创建多个ThreadLocal</li><li>由于ThreadLocal内部中ThreadLocalMap的key实现为弱引用，可能导致内存泄漏，使用完成后需要及时调用<code>remove()</code>来避免泄漏</li><li>使用ThreadLocal时，需要先<code>set()</code>再<code>get()</code>避免发生空指针异常，若重写了<code>initialValue()</code>该方法，则没问题</li><li>ThreadLocal的适用场景为无状态且副本变量独立后不影响业务逻辑的高并发场景。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Handler机制源码解析(二)</title>
      <link href="/2018/10/07/Handler%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C/"/>
      <url>/2018/10/07/Handler%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h1 id="主要包括Handler其他使用知识点"><a href="#主要包括Handler其他使用知识点" class="headerlink" title="主要包括Handler其他使用知识点"></a>主要包括Handler其他使用知识点</h1><h2 id="1-子线程创建Handler对象"><a href="#1-子线程创建Handler对象" class="headerlink" title="1. 子线程创建Handler对象"></a>1. 子线程创建Handler对象</h2><blockquote><p>不可以直接在子线程创建Handler对象，因为Handler对象必须要绑定一个Looper，才可以使用。</p><p>若在子线程需要使用Handler，则需要先创建一个Looper对象即执行<code>Looper.prepare()</code>然后再创建Handler对象时调用<code>Looper.myLooper()</code>获取Looper对象传入方法，最后调用<code>Looper.loop()</code>开始运行。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">Activity&#123;</span></span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> mThread: MyThread</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> mHandler: MyHandler</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.act_main)</span><br><span class="line">        <span class="comment">//初始化子线程</span></span><br><span class="line">        mThread = Mythread()</span><br><span class="line">        mThread.start()</span><br><span class="line">        <span class="comment">//需要发出的消息</span></span><br><span class="line">        <span class="keyword">val</span> message = Message.obtain()</span><br><span class="line">        message.obj = <span class="string">"test"</span></span><br><span class="line">        <span class="comment">//初始化Handler</span></span><br><span class="line">        mHandler = MyHandler(<span class="keyword">this</span>, mThread.childLooper)</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        mHandler.sendMessage(message)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//子线程</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> : <span class="type">Thread</span></span>() &#123;</span><br><span class="line">        <span class="keyword">var</span> childLooper: Looper? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            Looper.prepare()</span><br><span class="line">            childLooper = Looper.myLooper()</span><br><span class="line">            Looper.loop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//安全的Handler写法</span></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span></span>(activity: MyActivity, looper: Looper?) : Handler(looper) &#123;</span><br><span class="line">        <span class="keyword">var</span> mWeakRe: WeakReference&lt;MyActivity&gt; = WeakReference(activity)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            <span class="keyword">val</span> activity: MyActivity? = mWeakRe.<span class="keyword">get</span>()</span><br><span class="line">            <span class="keyword">if</span> (activity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//添加handlerMessage需要处理的逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行完毕后就可以在子线程调用Handler对象。</p><p><strong>但是，在多次执行过程中，会有<font color="red">java.lang.NullPointerException: Attempt to read from field ‘android.os.MessageQueue android.os.Looper.mQueue’ on a null object reference</font>空指针导致应用崩溃。</strong>调试过程中发现是由于Looper对象为空导致的异常。由于<strong>在子线程<code>run()</code>初始化了Looper对象，Handler对象的初始化依然继续执行，Looper对象此时尚未初始化好，导致空指针异常。</strong></p><p>由于这种情况的出现是随机的，不是百分百重现，为了保证应用的运行就需要引入<code>HandlerThread</code>这个类，可以帮我们解决这个问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HandlerThread示例代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">Activity&#123;</span></span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> mHandler: MyHandler</span><br><span class="line">    <span class="keyword">var</span> mHandlerThread: HandlerThread?=<span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.act_main)</span><br><span class="line">        <span class="comment">//初始化HandlerThread并指定线程名字为test</span></span><br><span class="line">        mHandlerThread = HandlerThread(<span class="string">"test"</span>,Process.THREAD_PRIORITY_BACKGROUND)</span><br><span class="line">        mHandlerThread?.start()</span><br><span class="line">        <span class="comment">//需要发出的消息</span></span><br><span class="line">        <span class="keyword">val</span> message = Message.obtain()</span><br><span class="line">        message.obj = <span class="string">"test"</span></span><br><span class="line">        <span class="comment">//初始化Handler</span></span><br><span class="line">        mHandler = MyHandler(<span class="keyword">this</span>, mHandlerThread?.looper)</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        mHandler.sendMessage(message)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//安全的Handler写法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span></span>(activity: MyActivity, looper: Looper?) : Handler(looper) &#123;</span><br><span class="line">        <span class="keyword">var</span> mWeakRe: WeakReference&lt;MyActivity&gt; = WeakReference(activity)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            <span class="keyword">val</span> activity: MyActivity? = mWeakRe.<span class="keyword">get</span>()</span><br><span class="line">            <span class="keyword">if</span> (activity!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//添加handlerMessage需要处理的逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        <span class="comment">//结束时停止thread</span></span><br><span class="line">        mHandlerThread?.quit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行完毕后即在HandlerThread可以调用Handler对象。</p><p>我们需要从源码去分析为什么使用<code>HandlerThread</code>可以避免上述异常，是怎样一个机制实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码位置:../core/java/android/os/HandlerThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">//设置线程优先级 优先级主要分为UI线程和后台线程(Background)</span></span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="comment">//默认标准App线程优先级</span></span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以重写这个方法，在内部新建Handler对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到线程ID</span></span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        <span class="comment">//创建对应的Looper，MessageQueue对象</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//对mLooper进行赋值</span></span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            <span class="comment">//唤醒等待Looper赋值而阻塞的所有线程</span></span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前线程是否存活 关闭则返回空</span></span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//mLooper==null表明当前Looper对象尚未初始化</span></span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//调用线程等待 直至初始化完成 阻塞其他线程</span></span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回Looper对象</span></span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内嵌一个可以直接引用的Handler对象，外部可以直接使用</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getThreadHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHandler = <span class="keyword">new</span> Handler(getLooper());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//HandlerThread退出 同步于Looper.quit()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//HandlerThread退出 同步于Looper.quitSafely()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>HandlerThread</code>内嵌了Handler,Looper,MessageQueue对象</li><li><code>HandlerThread</code>内部使用<code>wait(),notifyAll()</code>等线程同步方式保证<code>mLooper</code>对象不会为空，<code>wait()</code>当Looper对象尚未初始化完成时阻塞其他线程，<code>notifyAll()</code>当mLooper对象不为空时，通知其他线程使用mLooper。</li></ul><h2 id="2-IdleHandler"><a href="#2-IdleHandler" class="headerlink" title="2. IdleHandler"></a>2. IdleHandler</h2><blockquote><p>当Looper里面的Message暂时处理完毕即<strong>全部消息处理完毕或者阻塞等待新消息</strong>时会调用<code>IdleHandler</code>这个类去处理一些空闲时间的消息。</p><p>继承<code>IdleHandler</code>这个接口，需要设置<code>queueIdle()</code>的返回值。若返回<code>false</code>则调用一次后会移除，为<code>true</code>则继续持有，空闲时依然会调用。</p><p>概括就是：<strong>优先级别较低的<code>Message</code>，只有当<code>Looper</code>中没有消息要处理时，才会去处理<code>IdleHandler</code>。</strong></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用示例代码</span></span><br><span class="line"><span class="keyword">val</span> message = Message.obtain()</span><br><span class="line">message.obj = <span class="string">"1234"</span></span><br><span class="line">handler.sendMessage(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> delayMessage=Message.obtain()</span><br><span class="line">delayMessage.obj=<span class="string">"12344"</span></span><br><span class="line">handler.sendMessageDelayed(delayMessage,<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程添加IdleHandler 限制API23以上使用</span></span><br><span class="line">mHandlerThread?.looper?.queue?.addIdleHandler(OnceIdleHandler())</span><br><span class="line">mHandlerThread?.looper?.queue?.addIdleHandler(ForeverIdleHandler())</span><br><span class="line"><span class="comment">//主线程添加IdleHandler</span></span><br><span class="line">Looper.myQueue().addIdleHandler(OnceIdleHandler())</span><br><span class="line">Looper.myQueue().addIdleHandler(ForeverIdleHandler())</span><br><span class="line"></span><br><span class="line"><span class="comment">//只使用一次的IdleHandler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnceIdleHandler</span> : <span class="type">MessageQueue.IdleHandler &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">queueIdle</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        LogUtils.e(<span class="string">"idle once"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一直持续存在的IdleHandler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForeverIdleHandler</span> : <span class="type">MessageQueue.IdleHandler &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">queueIdle</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        LogUtils.e(<span class="string">"idle forever"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要移除IdleHandler 调用</span></span><br><span class="line"> Looper.myQueue().removeIdleHandler(OnceIdleHandler())</span><br><span class="line"> Looper.myQueue().removeIdleHandler(ForeverIdleHandler())</span><br></pre></td></tr></table></figure><p>集成上述代码即可测试IdleHandler的使用，接下来要分析源码的实现以及使用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码位置:../core/java/android/os/MessageQueue.java</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IdleHandler定义</span></span><br><span class="line"><span class="comment">     * Callback interface for discovering when a thread is going to block</span></span><br><span class="line"><span class="comment">     * waiting for more messages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Called when the message queue has run out of messages and will now</span></span><br><span class="line"><span class="comment">         * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class="line"><span class="comment">         * to have it removed.  This may be called if there are still messages</span></span><br><span class="line"><span class="comment">         * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class="line"><span class="comment">         * after the current time.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//mIdleHandlers 是ArrayList型 故可以重复添加</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line">   <span class="comment">//往MessageQueue中添加一个IdleHandler对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addIdleHandler</span><span class="params">(@NonNull IdleHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Can't add a null IdleHandler"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//添加IdleHandler是线程安全的 </span></span><br><span class="line">            mIdleHandlers.add(handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//移除一个IdleHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeIdleHandler</span><span class="params">(@NonNull IdleHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mIdleHandlers.remove(handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用上述方法往mIdleHandlers添加或移除IdleHandler对象后 需要在next()方法中 去使用mIdleHandlers中的对象</span></span><br><span class="line">   <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//无限循环</span></span><br><span class="line">       <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">           ...</span><br><span class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 判断当前没有空闲线程可执行 则继续堵塞</span></span><br><span class="line">                    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// Run the idle handlers.</span></span><br><span class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取继承接口定义的queueIdle()返回值 判定后续是否需要继续执行</span></span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="comment">//不需要继续执行 则自动移除对象</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-Handler常见问题"><a href="#3-Handler常见问题" class="headerlink" title="3. Handler常见问题"></a>3. Handler常见问题</h2><h3 id="1-消息机制中的主要引用对象及其关系"><a href="#1-消息机制中的主要引用对象及其关系" class="headerlink" title="1. 消息机制中的主要引用对象及其关系"></a>1. 消息机制中的主要引用对象及其关系</h3><blockquote><p><code>Looper ，MessageQueue，Message，ThreadLocal，Handler</code></p></blockquote><ol><li>Looper对象有一个MessageQueue,MessgaeQueue为一个消息队列来存储Message</li><li>Message中带有一个Handler对象，从Looper中取出消息后，可以直接调用到Handler的相关方法</li><li>Handler发送消息时会把自身封装进Message  <code>Message.ontain(Handler h ,int what,int arg1,int arg2,Object onj)</code></li><li>Handler通过获取Looper对象中的MessageQueue插入消息来发送Message</li><li>Looper创建对象时会把自己保存至ThreadLocal中，并提供一个<code>public static Looper myLooper()</code>方法来返回一个Looper对象</li></ol><h3 id="2-Android主线程不会因为Looper-loop-死循环卡死"><a href="#2-Android主线程不会因为Looper-loop-死循环卡死" class="headerlink" title="2. Android主线程不会因为Looper.loop()死循环卡死"></a>2. Android主线程不会因为<code>Looper.loop()</code>死循环卡死</h3><p>简单来说就是<strong>循环里有阻塞<code>阻塞的原理是利用Linux的管道机制(PIPE/EPOLL)机制实现</code>，所以死循环不会一直执行，由于大部分时间都是没有消息的，所以主线程大部分处于休眠状态，也不会过度消耗CPU资源导致卡死。</strong></p><p>先说明进程和线程的区别：</p><blockquote><p><strong>进程</strong>：每个app运行时首先会创建一个进程，该进程是由zygote fork出来的，用于承载运行app上的Activity/Service等组件。进程对于上层应用来说是完全透明的，目的是为了<code>让App都运行在Android Runtimr</code>。大多数情况下一个App运行在一个线程中，除非配置了<code>Android:Process</code>属性，或者通过native fork 进程。</p><p><strong>线程</strong>：线程比较常见，每次<code>new Thread().start()</code>都会创建一个新线程。并且与当前App所在进程之间资源共享。<code>在CPU看来进程或线程无非是一段可执行的代码，CPU采用CFS调度算法，保证每个task尽可能公平享有CPU时间片</code>。</p><p>拓展知识：CFS调度算法是一种完全公平调度算法，基本设计思路是根据各个进程的权重来分配运行时间**。</p></blockquote><p>当进入死循环时又该如何处理其他事务呢？<strong>需要创建新的线程去处理</strong>。</p><p>主线程进入Looper的死循环后，需要处理 activity的各个生命周期的回调函数执行(<code>在同一个线程下，代码是按顺序执行的，如果死循环堵塞了，后续该如何执行</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码地址 android/app/ActivityThread.java </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Looper初始化</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="comment">//new 一个ActivityThread并调用了attach方法</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">       Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">             LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">       Looper.loop();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中在初始化ActivityThread时也会初始化一个<code>H类型的成员，它继承了Handler</code>。</p><p>源码中调用<code>thread.attach(false)</code>时,<strong>回去创建一个Binder进程（具体代指ApplicationThread,Binder的服务端，用于接收系统AMS发出来的事件），由Handler线程发送Message至主线程。</strong></p><p>所以在主线程开启Looper死循环之前，就已经启动了一个Binder线程并且准备了<code>H 这一个Handler类</code>，就可以用于处理一些死循环之外的事务。<code>仅需通过Binder线程向H发送消息即可</code>。</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/activity_binder.png" class="full-image" alt="App运行过程" title="App运行过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><strong>system_server进程即为系统进程</strong>，里面运行了大量的系统服务，比如上图提供了<code>ApplicationThreadProxy以及ActivityManagerService</code>，这两者都基于IBinder接口，都是Binder线程。</p><p><strong>App进程即为我们常说的应用程序</strong>，主线程主要负责Activity等组件的生命周期以及UI绘制。每个App进程中至少会包括两个binder线程:<code>ApplicationThread和ActivityManagerProxy</code>。</p><p><strong>Binder用于不同进程间的通信，由一个进程的Binder客户端向另一个进程的服务端发送事务。</strong></p><p><strong>Handler则用于同一进程间不同线程的通信。</strong></p><h3 id="3-主线程的消息模型"><a href="#3-主线程的消息模型" class="headerlink" title="3.主线程的消息模型"></a>3.主线程的消息模型</h3><p>上图中绘制出主线程(ActivityThread)是如何循环的,简单的文字表达就是</p><blockquote><p><code>ActivityManagerService(AMS)</code> ==直接调用==&gt;<code>ApplicationThreadProxy(ATP)</code>==Binder==&gt;<code>ApplicationThread</code>==Handler方式==&gt;<code>ActivityThread</code></p><p>主线程(ActivityThread)通过<code>ApplicationThread</code>和<code>ActivityManagerService</code>进行进程间通信，AMS以进程间通信的方式完成<code>ActivityThread</code>的请求后回调<code>ApplicationThread</code>中的Binder方法。然后由<code>ApplicationThread</code>向<code>ActivityThread</code>中的<code>H</code>发送消息，然后收到消息后 把处理逻辑发送至<code>ActivityThread</code>中去执行。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-RemoteViews</title>
      <link href="/2018/08/26/Android-Study-Plan-RemoteViews/"/>
      <url>/2018/08/26/Android-Study-Plan-RemoteViews/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-RecyclerView以及ConstrainLayout</title>
      <link href="/2018/08/26/Android-Study-Plan-RecyclerView%E4%BB%A5%E5%8F%8AConstrainLayout/"/>
      <url>/2018/08/26/Android-Study-Plan-RecyclerView%E4%BB%A5%E5%8F%8AConstrainLayout/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-动态权限</title>
      <link href="/2018/08/26/Android-Study-Plan-%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/"/>
      <url>/2018/08/26/Android-Study-Plan-%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-设计模式基本原则</title>
      <link href="/2018/08/26/Android-Study-Plan-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
      <url>/2018/08/26/Android-Study-Plan-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-XX</title>
      <link href="/2018/06/25/Android-Study-Plan-XX/"/>
      <url>/2018/06/25/Android-Study-Plan-XX/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><h2 id="大尺寸图片加载问题：给定一个1000px-2000px的大图，如何进行正常加载且不会导致OOM。"><a href="#大尺寸图片加载问题：给定一个1000px-2000px的大图，如何进行正常加载且不会导致OOM。" class="headerlink" title="大尺寸图片加载问题：给定一个1000px*2000px的大图，如何进行正常加载且不会导致OOM。"></a>大尺寸图片加载问题：给定一个1000px*2000px的大图，如何进行正常加载且不会导致OOM。</h2>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-XIX</title>
      <link href="/2018/06/12/Android-Study-Plan-XIX/"/>
      <url>/2018/06/12/Android-Study-Plan-XIX/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><h2 id="AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。"><a href="#AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。" class="headerlink" title="AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。"></a>AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。</h2>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构-树</title>
      <link href="/2018/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
      <url>/2018/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>计算机网络基础</title>
      <link href="/2018/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<!--TCP三次握手、四次挥手。 http请求报文结构、响应报文，状态码。 http2.0相比于http1.0的新特性，推送、多路复用、消息头压缩等 。Https的原理？Tcp和Udp的区别？Http的报文结构？cookie是用来干嘛的？有哪些响应码，分别都代表什么意思？有自己实现过Socket协议吗？互联网的实现主要分为几层，http、ftp、tcp、ip分别位于哪一层。http和https的区别为什么tcp要经过三次握手，四次挥手socket了解过吗-->]]></content>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-XVIII -- 基础网络原理</title>
      <link href="/2018/05/31/Android-Study-Plan-XVIII/"/>
      <url>/2018/05/31/Android-Study-Plan-XVIII/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><h2 id="网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。"><a href="#网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。" class="headerlink" title="网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。"></a>网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。</h2>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-线程池 ThreadPool 专题详解</title>
      <link href="/2018/05/31/Android-Study-Plan-XVII/"/>
      <url>/2018/05/31/Android-Study-Plan-XVII/</url>
      <content type="html"><![CDATA[<h2 id="线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？"><a href="#线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？" class="headerlink" title="线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？"></a>线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？</h2><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ThreadPool-Structure.png" class="full-image" alt="线程池脑图" title="线程池脑图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li><strong>线程</strong>：进程中负责执行的执行单元，一个进程中至少有一个线程,<strong>操作系统能够进行调度的最小单位</strong></li><li><strong>进程</strong>：一个执行中的程序的实例</li><li><strong>多线程</strong>：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU确定，因此多线程具有不确定性</li><li><strong>线程池</strong>： 基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象回归池中，避免反复创建线程对象所带来的性能开销，节省系统资源。</li></ul><h3 id="1-线程池的概念"><a href="#1-线程池的概念" class="headerlink" title="1. 线程池的概念"></a>1. 线程池的概念</h3><p>在执行一个异步任务或并发任务时，往往会通过<code>new Thread()</code>方法去开启一个子线程去执行任务，等到子线程操作完成后在利用<code>Handler</code>切换至主线程。但是利用这种方法我们无法对自己创建的子线程进行有效的管理，然后由于过多的创建子进程，他们之间相互竞争会导致资源的过度占用。线程池的出现就是为了来对子进程进行管理。</p><h3 id="2-线程池的实现原理"><a href="#2-线程池的实现原理" class="headerlink" title="2. 线程池的实现原理"></a>2. 线程池的实现原理</h3><p><code>Executors</code>提供了基础的四类线程池方法，最终都是通过<code>ThreadPoolExecutor</code>类完成。对于这个类的描述<code>他维护了一个线程池，对于提交Executor中的任务，不是创建新的线程而是使用池内的线程来执行任务。可以显著减少对于任务执行的开销。</code></p><ol><li><p>ThreadPoolExecutor构造函数介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>参数介绍：</p><ul><li><p><strong><code>corePoolSize 核心线程数</code></strong> 表示线程池中的基本线程数量即核心线程数量。一般情况下核心线程会一直存活在线程池中，即便他们处于闲置状态。只有在<code>ThreadPoolExecutor的allowCoreThreadTimeOut设置为true</code>的时候，会有一个超时策略（超过设置好的超时时间，闲置的核心线程会被终止）。<strong>当创建的线程数小于corepoolSize时，不管有没有空闲线程都会创建新的线程</strong>。</p></li><li><p><strong><code>maximumPoolSize 最大线程数</code></strong>  表示线程池中允许的最大创建线程数，当活动的线程数达到数值后，后续新任务会被阻塞。<strong>使用有界队列时，未达到该值则会创建新的线程，使用无界队列时该值无效。</strong></p></li><li><p><strong><code>keepAliveTime 非核心线程闲置时的超时时长</code></strong> 表示空闲非核心线程的最大存活时间，一旦超过即被销毁。**当<code>ThreadPoolExecutor的allowCoreThreadTimeOut设置为true</code>的时候，该参数也可作用于核心线程</p></li><li><p><strong><code>unit 存活时间的时间单位</code></strong> 用于指定keepAliveTime参数的时间单位，为一个枚举类型。包含下列参数：<code>NANOSECONDS（纳秒）</code>,<code>MICROSECONDS（微秒）</code>,<code>MILLSECONDS（毫秒）</code>,<code>SECONDS（）秒</code>,<code>MINUTES（分）</code>,<code>HOURS（时）</code>,<code>DAYS（天）</code></p></li><li><p><strong><code>workQueue 线程池中的任务队列</code></strong> 该队列是<code>java.util.BlockingQueue&lt;E&gt;</code>的一个实例，是一种阻塞队列用来存放等待执行的任务。通过<code>execute()</code>方法将提交的Runnable对象存储进去。根据具体实现类的不同可以分为以下三种队列策略：</p><ul><li><code>容量为0即直接提交策略--SynchronousQueue</code>：等待队列容量为0 ，所有需要阻塞的任务必须等待池内的某个线程有空闲才可以继续执行，否则阻塞。<code>CachedThreadPool</code>使用该队列策略。</li><li><code>容量无限即无界队列策略--LinkedBlockingQueue</code>：等待队列的长度无穷大，在这种策略下不会出现多余corePoolSize的线程被创建，所以maximumPoolSize以及handler无效，因为不存在队列满的情况。不过也有缺点：<strong>线程的执行速度会比提交速度慢，会导致无界队列快速增长，直到系统资源耗尽。</strong><code>fixedThreadPool</code>采用了这种队列策略。</li><li><code>容量有限即有界队列策略--指定了容量的任何BlockingQueue</code>：等待队列的长度为限制长度，指定了容量后可以<strong>防止过多的资源被消耗</strong>。 </li></ul></li><li><p><strong><code>threadFactory 线程工厂</code></strong>：是一个接口可以为线程池提供新线程的创建。由同一个threadFactory创建的线程同属于一个ThreadGroup，优先级都为Thread.NORM_PRIORITY，以及为非进程守护状态。默认都是采用<code>Executors.defaultThreadFactory()</code>返回值。</p></li><li><p><strong><code>handler 拒绝策略</code></strong>：当<strong>使用有界队列时且队列任务被填满后并且线程数也达到了最大值，就会触发拒绝策略</strong>。如果任务被拒绝执行，则会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法，默认调用<code>AbortPolicy</code>拒绝策略，也可以由用户自定义。JDK中定义了4种拒绝策略：</p><ul><li><p><code>AbortPolicy</code><strong>处理程序遭到拒绝则直接抛出<code>RejectedExecutionException</code>异常然后丢弃该任务。</strong></p><p>实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                                <span class="string">" rejected from "</span> +</span><br><span class="line">                                                e.toString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>样例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">        TestRunnable(<span class="keyword">int</span> id) &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName()+<span class="string">" 当前线程id="</span>+ <span class="keyword">this</span>.id);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">abortPolicyDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">1</span>));</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">2</span>));</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">3</span>));</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：添加进程时直接抛出异常但是没有影响后续的进行</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@<span class="number">4</span>b1210ee rejected from java.util.concurrent.ThreadPoolExecutor@<span class="number">4</span>d7e1886[Running, pool size = <span class="number">1</span>, active threads = <span class="number">1</span>, queued tasks = <span class="number">1</span>, completed tasks = <span class="number">0</span>]</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2047</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">823</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1369</span>)</span><br><span class="line">    at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:<span class="number">112</span>)</span><br><span class="line">    at threadpool.ThreadPoolDemo.abortPolicyDemo(ThreadPoolDemo.java:<span class="number">140</span>)</span><br><span class="line">    at threadpool.ThreadPoolDemo.main(ThreadPoolDemo.java:<span class="number">13</span>)</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p><code>CallerRunsPolicy</code><strong>在调用<code>execute</code>方法的调用者所在线程来执行被拒绝的任务，提供简单的反馈控制机制，可以减缓新任务的提交速度。</strong></p><p>实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>样例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callerRunsPolicyDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">1</span>));</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">2</span>));</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">3</span>));</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：task2执行在了主线程，由于被拒绝执行所以在调用者线程执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">1</span></span><br><span class="line">main 当前线程id=<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p><code>DiscardPolicy</code><strong>被拒绝即无法执行的任务被直接删除</strong></p><p>实现源码：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>样例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">discardPolicyDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>), <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">1</span>));</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">2</span>));</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">3</span>));</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：由于被拒绝执行在该策略下被直接抛弃</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p><code>DiscardOldestPolicy</code><strong>判断线程池是否被关闭，没有则丢弃最老的一个请求，再尝试提交当前任务。</strong></p><p>实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">             <span class="comment">/**</span></span><br><span class="line"><span class="comment">              * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                     e.getQueue().poll();</span><br><span class="line">                     e.execute(r);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>样例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">discardOldestPolicyDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1</span>), <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">1</span>));</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">2</span>));</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">3</span>));</span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> TestRunnable(<span class="number">4</span>));</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：???</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">4</span></span><br></pre></td></tr></table></figure></li><li><p><code>CustomRejectPolicy 自定义拒绝策略</code><strong>可以用来记录运行日志或者记录无法处理的任务</strong></p><p>样例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义拒绝策略，实现RejectedExecutionHandler接口即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRejectedPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!executor.isShutdown())&#123;</span><br><span class="line">                    System.err.println(<span class="string">"自定义异常日志记录:  "</span>+  r.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">customPolicyDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">1</span>, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>), <span class="keyword">new</span> CustomRejectedPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用execute是因为使用submit时会被封装成RunnableFuture对象</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> TestRunnable(<span class="number">1</span>));</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> TestRunnable(<span class="number">2</span>));</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> TestRunnable(<span class="number">3</span>));</span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> TestRunnable(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：由于<span class="number">4</span>号被拒绝，记录日志</span><br><span class="line">自定义异常日志记录:  java.util.concurrent.FutureTask@<span class="number">4</span>b1210ee</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 当前线程id=<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>额外参数扩展 <code>allowCoreThreadTimeOut 允许核心线程过期</code>默认值为false（线程池已不被使用，但是其中还有活着的线程，则该线程池无法被回收，会造成内存泄露）。所以用户可以显式调用<code>shutDown()</code>或者该值设置为true，则会被回收。</p></li></ul></li></ul></li><li><p>ThreadPoolExecutor的使用</p><p>向线程池提交一个任务的方式有两种：</p><ul><li><p><code>execute</code>：这种方法提交任务，是没有返回值的即无法判断在线程池中是否完成该任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(<span class="keyword">new</span> TestRunnable(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li><li><p><code>submit</code>：使用<code>submit</code>方法提交任务时，会返回一个future，可以通过这个future来判断任务是否执行成功也可以根据<code>future的get()</code>方法获取返回值。<strong>若子线程任务没完成，<code>get()</code>方法会阻塞直到任务完成，若使用<code>get(long timeout,TimeUnit unit)</code>则会阻塞一段时间后返回，可能尚未完成任务。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Integer&gt; future = fixedThreadPool.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">     </span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   System.err.println(Thread.currentThread().getName() + <span class="string">" , index = "</span> + index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">     </span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               System.err.println(<span class="string">"Future return :"</span> + future.get().toString());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>线程池的关闭</p><p>线程池关闭方法有两种：</p><ul><li><p><code>shutdown()</code>：将线程池的状态置为SHUTDOWN状态，然后中断没有正在执行的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>shutdownNow()</code>：将线程池的状态设为STOP状态，中断所有任务包括执行中的线程，并返回等待执行的任务列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            advanceRunState(STOP);</span><br><span class="line">            interruptWorkers();</span><br><span class="line">            tasks = drainQueue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>中断线程需要采用<code>interrput</code>方法，<strong>无法响应中断的任务可能永远无法终止。</strong></p><p>当需要立即中断所有线程并且不在乎任务是否执行完成时，可以使用<code>shutdownNow</code>方法。</p></li></ul></li><li><p>线程池的拓展</p><p><code>ThreadPoolExecutor</code>默认提供三个空方法，可以通过重写这三个方法来监控线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务执行前 记录任务开始前时间</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//任务执行后 记录任务结束时间</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//线程池关闭 记录线程池关闭事件以及执行过的线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>样例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">            System.err.println(<span class="string">"beforeExecute"</span>+r.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">            System.err.println(<span class="string">"afterExecute"</span>+r.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.terminated();</span><br><span class="line">            System.err.println(<span class="string">"线程关闭"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-为什么要使用线程池"><a href="#3-为什么要使用线程池" class="headerlink" title="3. 为什么要使用线程池"></a>3. 为什么要使用线程池</h3><ul><li><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li><strong>提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就可以立即执行</li><li><strong>提高线程的可管理性。</strong>线程是稀缺资源，大量创建会导致系统资源过度消耗且会降低系统的稳定性，线程池可以有效控制线程数，并进行统一的分配、调优和监控。</li></ul><h3 id="4-线程池的分类以及各自的特性"><a href="#4-线程池的分类以及各自的特性" class="headerlink" title="4. 线程池的分类以及各自的特性"></a>4. 线程池的分类以及各自的特性</h3><p>利用<code>Executors</code>类提供了四种不同的线程池，他们都是直接或者间接配置<code>ThreadPoolExecutor</code>来实现功能。下面分别介绍着四个线程池</p><p> <code>newFixedThreadPool</code> </p><blockquote><p>创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就不会发生变化，如果某个线程因为异常而结束，则会补充一个新进程。</p><p>由于只设置核心线程大小，所以可以<strong>更快的响应外界请求</strong></p><p>线程池的大小设置，可以使用<code>Runtime.getRuntime().availableProcessors()</code></p></blockquote><ul><li><p>实现源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置了核心线程，并且没有超时机制，使用LinkedBlockingQueue则任务队列大小是无上限的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>样例演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fixedThreadPoolDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService fixedThreadPool= Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index=i;</span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.err.println(Thread.currentThread().getName()+<span class="string">" , index = "</span>+index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：整个过程都在pool-<span class="number">1</span>的线程池中运行,然后复用线程</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> , index = <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> , index = <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> , index = <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> , index = <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>适用场景</p><p>用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。</p></li></ul><p><code>newCachedThreadPool</code></p><blockquote><p>可根据需要创建新线程的线程池，但是在一起构造的线程可用时将重用他们。对于很多短期异步任务的程序而言，这类线程池可以提高性能。</p><p>如果现有线程没有可用的，则会创建一个新的线程并添加到池中，终止并从缓存中移除那些超过60s没有使用的线程。<strong>因此，长时间保持空闲的newCachedThreadPool线程池是不存在任何线程的，所以这时候几乎不占用系统资源。</strong></p></blockquote><ul><li><p>实现源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 核心线程数为0 线程最大为Int的最大值所以可以认定为线程池最大线程无限大，设置了超时时间为60s。任务队列采用了阻塞队列(必须池内有空闲线程才可以执行)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>样例演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cachedThreadPoolDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService cachedThreadPool= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index=i;</span><br><span class="line">            cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.err.println(Thread.currentThread().getName()+<span class="string">" , index = "</span>+index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：整个过程都在同一个线程pool-<span class="number">1</span>-thread-<span class="number">1</span>中执行，后面线程复用前面的线程</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>适用场景</p><p>并发执行大量短期的小任务，或者负载较轻的服务器</p><p><code>newScheduledThreadPool</code></p></li></ul><blockquote><p>创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p></blockquote><ul><li><p>实现源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 核心线程数固定，非核心线程数为无限大，当非核心数处于闲置状态的时候会被立即回收</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>样例演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleThreadPoolDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">     <span class="comment">//延迟一定时间后执行Runnable任务</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + <span class="string">" delay 2s"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">     <span class="comment">//延迟一定时间后执行Callable任务</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">     <span class="comment">//延迟一定时间（initialDelay）后,以(period)时间间隔执行任务</span></span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + <span class="string">" every 3s"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">     <span class="comment">//延迟一定时间（initialDelay）后,以(delay即上一个任务执行结束到下一个任务开始的间隔)执行</span></span><br><span class="line">        scheduledThreadPool.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + <span class="string">" delay 3s"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> every <span class="number">3</span>s</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> delay <span class="number">3</span>s</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> delay <span class="number">3</span>s <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> every <span class="number">3</span>s</span><br></pre></td></tr></table></figure></li><li><p>适用场景</p><p>用于需要多个后台线程执行周期任务，同时需要限制线程数量</p><p><code>newSingleThreadExecutor</code></p></li></ul><blockquote><p>创建一个单线程池，该线程池中只有一个线程在工作，其他任务都会依次在任务中排列中等候依次执行，任务是串行执行的。此线程池保证所有的任务的执行顺序按照任务提交顺序执行(FIFO-先进先出)。</p></blockquote><ul><li><p>实现源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 只有一个核心线程，对任务队列没有大小限制，将所有外界任务统一到一个线程执行所有我们不需要处理线程同步的问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>样例演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">singleThreadPoolDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.err.println(Thread.currentThread().getName() + <span class="string">" , index = "</span> + index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：所有的任务都是在pool-<span class="number">1</span>-thread-<span class="number">1</span>中依次运行</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> , index = <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>适用场景</p><p>用于串行执行任务的场景，每个任务需要顺序执行</p></li></ul><h3 id="5-线程池的执行流程"><a href="#5-线程池的执行流程" class="headerlink" title="5. 线程池的执行流程"></a>5. 线程池的执行流程</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/threadpool_process.png" class="full-image" alt="线程池执行流程图" title="线程池执行流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ol><li>判断corePoolSize(核心线程数)是否已到达，没到达则可以创建一个新线程执行任务</li><li>判断工作队列是否已满，没满则添加入队列等待执行</li><li>判断maximum(最大线程数)是否已到达，没到达则创建一个新线程执行任务。已满则执行拒绝策略。</li></ol><h3 id="6-线程池的使用注意"><a href="#6-线程池的使用注意" class="headerlink" title="6. 线程池的使用注意"></a>6. 线程池的使用注意</h3><ol><li><p>线程池不要用<code>Executors</code>的方式去创建，应该利用<code>ThreadPoolExecutor</code>的方式，这样可以帮助更好理解实现方式以及避免资源消耗过度的问题。</p><p><strong><code>fixThreadPool以及singleThreadPool</code>,由于设置的等待队列长度为Integer.MAX_VALUE，导致大量请求堆积，消耗大量资源。</strong></p><p><strong><code>cachedThreadPool以及scheduledThreadPool</code>,由于运行允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的请求，消耗大量资源。</strong></p></li><li><p>针对具体情况去配置线程池参数，不同的任务类别应采用不同规模的线程池，任务类别分为3种：</p><ul><li><p><strong><code>CPU密集型任务(需要进行大量计算，处理)</code></strong>：线程池中线程个数尽量少，不应大于CPU核心数，避免出现每个线程都需要长时间使用但是线程过多去抢占资源。</p></li><li><p><strong><code>IO密集型任务(主要时间都在IO，CPU空闲时间比较多)</code></strong>：线程池可以配置尽量多的线程，由于CPU大部分时间空闲，可以提高CPU的利用率。</p></li><li><p><strong><code>混合型任务</code></strong>：如果可以拆分，则拆分成一个CPU密集型以及IO密集型任务，只要执行任务效率相差不大。若相差太大则没必要拆分。</p></li></ul></li></ol><h3 id="7-补充知识"><a href="#7-补充知识" class="headerlink" title="7.补充知识"></a>7.补充知识</h3><ol><li><p><code>submit()</code>和<code>execute()</code>区别</p><p><code>submit()</code>返回一个<code>future</code>，根据<code>future</code>可以判断任务是否完成–实现<code>Callable</code>接口</p><p><code>execute()</code>无返回值。只是执行了任务，不知道结果如何 – 实现<code>Runnable</code>接口</p></li></ol><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3OTU0MzI4MQ==&amp;mid=2247486818&amp;idx=1&amp;sn=5d5f87cceadb062c3502cd7a1e2d3e0a&amp;chksm=eb4761fcdc30e8ea3de28eca8c16ce305336852534dbd23edb348b5c1e02334dee025ea8f7bf&amp;mpshare=1&amp;scene=23&amp;srcid=12117GQN5ZAnFwJRhSpKAcO1%23rd" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Handler机制源码解析</title>
      <link href="/2018/05/14/Handler%E6%9C%BA%E5%88%B6%E5%8D%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/05/14/Handler%E6%9C%BA%E5%88%B6%E5%8D%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="主要的内容包括Handler的机制以及四个组成部分和源码的分析"><a href="#主要的内容包括Handler的机制以及四个组成部分和源码的分析" class="headerlink" title="主要的内容包括Handler的机制以及四个组成部分和源码的分析"></a>主要的内容包括Handler的机制以及四个组成部分和源码的分析</h1><p><a href="https://juejin.im/post/5bb7007af265da0acf0af6c7" target="_blank" rel="noopener"><img src="https://badge.juejin.im/entry/5bb7044ce51d450e7210d9f8/likes.svg?style=plastic" alt=""></a></p><blockquote><p>下面的代码分析都是基于Android8.0 - Oreo的源代码</p></blockquote><h2 id="1-消息机制简介"><a href="#1-消息机制简介" class="headerlink" title="1.  消息机制简介"></a>1.  消息机制简介</h2><p>在应用启动时，会执行<code>main()</code>方法，<code>main()</code>会创建一个Looper对象，然后开启一个死循环，目的是<strong>不断从消息队列<code>MessageQueue</code>里面取出<code>Message</code>对象并处理。</strong></p><p>在Android中使用消息机制，会优先想到的是Handler。Handler可以轻松的将一个任务切换到Handler所在的线程去执行。在多线程的应用场景中，<strong>可以将工作线程中需要更新UI的操作信息传递到主线程去执行</strong>，从而实现工作线程更新UI的操作，最终实现异步消息的处理。</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/handler_process.png" class="full-image" alt="Handler执行流程图" title="Handler执行流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span> <h2 id="2-Handler机制模型"><a href="#2-Handler机制模型" class="headerlink" title="2. Handler机制模型"></a>2. Handler机制模型</h2><p>消息机制主要包含<strong>Handler、Message、MessageQueue，Looper</strong>这四个类。</p><ul><li><strong>Handler</strong>：消息辅助类。主要功能将<code>Message</code>对象发送到<code>MessageQueue</code>中，同时将自己的引用赋值给<code>Message#target</code>(Handler.sendMessage())。也可以实现<code>handleMessage()</code>方法处理回调。</li><li><strong>Message</strong>：消息实体。需要传递的消息也可以传递数据。</li><li><strong>MessageQueue</strong>：消息队列。<strong>内部实现并不是队列，而是利用单链表去实现因为在插入和删除数据有优势。</strong>用于存储Handler发给来的消息(<code>Message</code>)以及取出。<code>内部使用单链表实现</code></li><li><strong>Looper</strong>：与线程绑定，不止局限于主线程，绑定的线程来处理<code>Message</code>。不断循环执行<code>Looper.loop()</code>，从<code>MessageQueue</code>中读取<code>Message</code>，按分发机制将消息分发出去给目标处理(将<code>Message</code>发到<code>Handler.dispatchMessage</code>方法去处理)。</li></ul><h2 id="3-Handler运行流程"><a href="#3-Handler运行流程" class="headerlink" title="3. Handler运行流程"></a>3. Handler运行流程</h2><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/handler_run_process.png" class="full-image" alt="Handler运行流程图" title="Handler运行流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span> <p>工作流程：<strong>异步通信准备==&gt;消息入队==&gt;消息循环==&gt;消息处理</strong></p><ol><li><p><strong>异步通信准备</strong></p><blockquote><p>假定在主线程创建Handler，则会直接在主线程中创建<code>Looper</code>,<code>MessageQueue</code>和<code>Handler</code>对象。<strong>Looper和MessageQueue对象均属于其<code>创建线程</code>（由主线程创建则属于主线程）。</strong>创建<code>Looper</code>时会自动创建<code>MessageQueue</code>对象，创建好<code>MessageQueue</code>对象后，<code>Looper</code>自动进入循环。<code>Handler</code>自动绑定<code>Looper</code>以及<code>MessageQueue</code>。</p><p><code>Looper</code>对象的创建方法一般通过<code>Looper.prepareMainLooper()</code>和<code>Looper.prepare()</code>方法。</p></blockquote></li><li><p><strong>消息入队</strong></p><blockquote><p>工作线程通过<code>Handler</code>发送<code>Message</code>到<code>MessageQueue</code>中。消息内容一般是UI操作，通过<code>Handler.sendMessage(Message message)</code>或<code>Handler.post(Runable r)</code>发送。加入<code>MessageQueue</code>一般通过<code>MessageQueue.enqueueMessage(Message msg,long when)</code>操作。</p></blockquote></li><li><p><strong>消息循环</strong></p><blockquote><p>分为<strong>消息出队</strong>和<strong>消息分发</strong>两个步骤</p><ul><li>消息出队：<code>Looper</code>从<code>MessageQueue</code>中循环取出<code>Message</code></li><li>消息分发：<code>Looper</code>将取出的<code>Message</code>分发给创建消息的<code>Handler</code></li></ul><p><strong>消息循环过程中，<code>MessageQueue</code>为空，则线程堵塞</strong></p></blockquote></li><li><p><strong>消息处理</strong></p><blockquote><p><code>Handler</code>接受发过来的<code>Message</code>并处理。</p></blockquote></li></ol><h2 id="4-Handler使用过程的注意点"><a href="#4-Handler使用过程的注意点" class="headerlink" title="4. Handler使用过程的注意点"></a>4. Handler使用过程的注意点</h2><ol><li><p>在工作线程中创建自己的消息队列时必须要调用<code>Looper.prepare()</code>,并且<strong>在一个线程中只可以调用一次</strong>，然后需要调用<code>Looper.loop()</code>,开启消息循环。</p><blockquote><p>在开发过程中基本不会调用上述方法，因为默认会调用主线程的Looper，然后一个线程中只能有一个Looper对象和一个MessageQueue。</p></blockquote></li><li><p><strong>要注意Handler可能引起的内存泄漏</strong>(在下面会介绍到为何会引发泄漏)。</p><p>错误的写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> Handler()&#123;        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p><strong>非静态的内部类和匿名内部类都会隐式的持有其外部类的引用，而静态内部类不会持有外部类的引用。</strong></p><p>正确的写法：</p><blockquote><p>继承<code>Handler</code>时候要么放在单独的类文件中，要么直接使用静态内部类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要在静态内部类中调用外部类时，可以直接使用  `弱引用`  进行处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MyActivity&gt; mWeakReference；</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MyActivity activity)</span></span>&#123;</span><br><span class="line">         mWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handlerMessage(msg);</span><br><span class="line">        MyActivity activity = mWeakReference.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="keyword">private</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="5-Handler源码解析"><a href="#5-Handler源码解析" class="headerlink" title="5. Handler源码解析"></a>5. Handler源码解析</h2><ol><li><p><strong>创建循环器对象（<code>Looper</code>）和创建消息队列对象(<code>MessageQueue</code>)</strong></p><blockquote><p>创建Looper对象主要有两个方法：<code>Looper.prepareMainLooper()</code>和<code>Looper.prepare()</code></p><p>创建MessageQueue对象方法：<strong>创建Looper对象时会自动创建MessageQueue</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码位置:../core/java/android/os/Looper.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br><span class="line"><span class="comment">//Looper对象创建时会自动创建一个MessageQueue对象。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">     mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">     mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为当前线程(子线程)创建一个Looper对象 需要在子线程中主动调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断sThreadLocal是否为null，不为空则直接跑出异常 可以保证一个线程只可以调用一次prepare方法</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为主线程创建一个Looper对象 该方法会在主线程创建时自动调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><p>创建<code>Looper</code>对象时会自动创建<code>MessageQueue</code>对象</p></li><li><p>主线程的Looper对象是自动生成的，而子线程需要调用<code>Looper.prepare()</code>创建<code>Looper</code>对象</p><blockquote><p>创建主线程是调用了<code>ActivityThread</code>的<code>main()</code>方法。</p><p>然后按照流程调用了<code>Looper.prepareMainLooper()</code>和<code>Looper.loop()</code>。所以主线程不需要调用代码生成Looper对象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置: ../core/java/android/app/ActivityThread.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">      Looper.prepareMainLooper();</span><br><span class="line">      Looper.loop();</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Handler的主要作用是(<code>在主线程更新UI</code>)，所以<strong>Handler主要是在主线程创建的</strong>。</p></li><li><p>Looper与Thread是通过<code>ThreadLocal</code>关联的。由于<code>ThreadLocal</code>是与线程直接关联的，参考<code>prepare()</code>。</p></li><li><p>子线程创建Handler对象:无法在子线程直接调用Handler无参构造方法<strong>Handler创建时需要绑定Looper对象</strong>  。需要使用<code>HandlerThread</code>。</p></li></ol></li><li><p><strong>开启Looper即消息循环</strong></p><blockquote><p>创建了<code>Looper和MessageQueue</code>对象后，自动进入消息循环，使用<code>Looper.loop()</code>方法开始消息循环。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：../core/java/android/os/Looper.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//现获取Looper实例，保证调用loop时已有Looper，否则抛出异常</span></span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//获取对应Looper实例创建的MessageQueue对象</span></span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">//开启消息循环-无限循环   </span></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//从MessageQueue取出Message对象</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="comment">//取出消息为null，则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">//把Message分发给相应的target</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">//释放消息占据的资源</span></span><br><span class="line">          msg.recycleUnchecked();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建Handler对象</strong></p><blockquote><p>创建Handler对象即可以进行消息的发送与处理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：.../core/java/android/os/Handler.java </span></span><br><span class="line"><span class="comment">//Handler默认构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从当前线程的ThreadLocal获取Looper对象</span></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前Looper的消息队列</span></span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        <span class="comment">//设置消息是否为异步处理方式</span></span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Handler的无参构造方法会默认关联当前线程的Looper对象和MessageQueue对象，设置callback回调方法为null，且消息处理方式为同步处理。</code></p></li><li><p><strong>创建消息对象</strong></p><blockquote><p>Handler发送Message并且进入MessageQueue循环，创建方式分为两种<code>new Message()</code>和<code>Message.obtain()</code>。通常使用<code>Message.obtain()</code>。这种方式<strong>有效避免创建重复Message对象</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建消息对象</span></span><br><span class="line">Message msg = Message.obtain();</span><br><span class="line">msg.what = <span class="number">1</span>;</span><br><span class="line">msg.obj = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码位置 .../core/java/android/os/Message.java</span></span><br><span class="line">    <span class="comment">/** Constructor (but the preferred way to get a Message is to call &#123;<span class="doctag">@link</span> #obtain() Message.obtain()&#125;).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//new Message 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//维护一个Message池，用于复用Message对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="comment">//obtain方法 直接从池内获取Message对象，避免new占用内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="comment">//直接从池中取出</span></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无可复用对象，则重新new获取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>发送消息(Message)</strong></p><blockquote><p>Handler主要有以下几种发送消息的方式:</p><ul><li><code>sendMessage(Message msg)</code></li><li><code>sendMessageDelayed(int what, long delayMillis)</code></li><li><code>post(Runnable r)</code></li><li><code>postDelayed(Runnable r, long delayMillis)</code></li><li><code>sendMessageAtTime(Message msg, long uptimeMillis)</code></li></ul><p>最终都是会调用到<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>然后继续调用到<code>enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</code>放入MessageQueue</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：.../core/java/android/os/Handler.java </span></span><br><span class="line"><span class="comment">//post方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, Object token, <span class="keyword">long</span> uptimeMillis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//利用post()方式发送消息，需要转换为Message向下传递</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r, Object token)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.obj = token;</span><br><span class="line">        <span class="comment">//将runnable赋值到callback上 以便后续判断是post还是sendMessage方式发送的消息</span></span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sendMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的发送消息有关方法 都会调用到这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取MessageQueue对象 </span></span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="comment">//获取对象为空 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对象不为空 调用enqueueMessage方法</span></span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法为了 向MessageQueue插入Message</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把当前的Handler设置为 消息标记位 即把消息派发给相对应的Handler实例</span></span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用MessageQueue的enqueueMessage方法</span></span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：..core/java/android/os/MessageQueue.java</span></span><br><span class="line"><span class="comment">//内部是一个单链表有序序列，由 Message.when 作为排序依据，该值为一个相对时间。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//正在退出 回收Message</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="comment">// p == null判断当前队列中是否有消息，插入消息作为队列头 </span></span><br><span class="line">            <span class="comment">// when == 0||when &lt; p.when 队列当前处于等待状态 唤醒队列</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                <span class="comment">//当前队列有消息，按照消息创建时间插入到队列中</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="comment">//从对列头部开始遍历</span></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="comment">//循环到队列尾部或者出现一个when小于当前Message的when</span></span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>发送消息时<code>Message.when</code>表示期望该消息被分发的时间即<code>SystemClock.uptimeMillis() + delayMillis</code>。<code>SystemClock.uptimeMills</code>代表自系统开机到调用到该方法的时间差。</li><li><code>Message.when</code>利用时间差来表达期望事件分发的时间，所以使用的是一个相对时间。</li></ul></li><li><p><strong>获取消息</strong></p><blockquote><p>发送了消息后，MessageQueue维护了消息队列，在Looper中通过<code>loop()</code>不断获取Message。通过<code>next()</code>获取Message.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：..core/java/android/os/MessageQueue.java</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//该参数用于确定消息队列中是否有消息 下一个消息到来前需要等待的时长</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该方法位于native层 若nextPollTimeoutMillis为-1 代表消息队列处于等待状态 阻塞操作</span></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                 Message msg = mMessages;</span><br><span class="line">                 <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Got a message.</span></span><br><span class="line">                        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//标记消息使用状态 flag |= FLAG_IN_USE</span></span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        <span class="comment">//返回一条消息</span></span><br><span class="line">                        <span class="keyword">return</span> msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// No more messages.</span></span><br><span class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//消息正在退出</span></span><br><span class="line">                <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>分发消息</strong></p><blockquote><p>分发消息到对应的Handler实例并根据传入的Message做对应的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：.../core/java/android/os/Handler.java </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//若callback不为空，则代表使用了post(Runnable r)方式发送了消息，执行handleCallback方法</span></span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//代表使用了sendMessage()方式发送了消息，调用handleMessage方法</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Handler实例时复写 自定义消息处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接回调runnable对象的run()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>msg.target.dispatchMessage(msg)</code>中<code>msg.target</code>指向的就是对应Handler实例，</li><li>消息分发的优先级：<ol><li>Message的回调方法<code>message.callback.run()</code></li><li>Handler中Callback的回调方法<code>mCallback,handleMessage(msg)</code></li><li>Handler的默认方法<code>handleMessage()</code></li></ol></li></ul></li><li><p><strong>Message回收</strong></p><blockquote><p>上面讲到了新建Message推荐使用<code>obtain()</code>，因为可以有效的复用消息，其中里面复用的就是<code>sPool</code>变量，它是在Message回收的时候进行赋值的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置 .../core/java/android/os/Message.java</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInUse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正在使用 无法回收</span></span><br><span class="line">        <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                        + <span class="string">"is still in use."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">        <span class="comment">// Clear out all other details.</span></span><br><span class="line">        <span class="comment">//置为使用标记</span></span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = <span class="number">0</span>;</span><br><span class="line">        arg1 = <span class="number">0</span>;</span><br><span class="line">        arg2 = <span class="number">0</span>;</span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        replyTo = <span class="keyword">null</span>;</span><br><span class="line">        sendingUid = -<span class="number">1</span>;</span><br><span class="line">        when = <span class="number">0</span>;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">        callback = <span class="keyword">null</span>;</span><br><span class="line">        data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Message放在了列表里，缓存的对象由obtain()拿出来复用</span></span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = <span class="keyword">this</span>;</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Looper退出</strong></p><blockquote><p><code>Looper.loop()</code>内部由一个无限循环组成，默认情况下不会退出循环。需要退出就需要调用<code>quit()</code>或者<code>quitSafely()</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置 .../core/java/android/os/Looper.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQueue.quit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQueue.quit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码位置 .../core/java/android/os/MessageQueue.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removeAllMessagesLocked();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">            <span class="comment">//唤醒等待线程</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接移除MessageQueue中的所有消息</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAllMessagesLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            <span class="comment">//回收未被处理的消息</span></span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于消息为null 则return 出无限循环</span></span><br><span class="line">        mMessages = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接移除未处理的消息 已经在执行的继续处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAllFutureMessagesLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//还未处理的Message</span></span><br><span class="line">            <span class="keyword">if</span> (p.when &gt; now) &#123;</span><br><span class="line">                removeAllMessagesLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message n;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    n = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (n.when &gt; now) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = n;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不接收后续消息</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    p = n;</span><br><span class="line">                    n = p.next;</span><br><span class="line">                    p.recycleUnchecked();</span><br><span class="line">                &#125; <span class="keyword">while</span> (n != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android中的GC分析-Dalvik和ART虚拟机</title>
      <link href="/2018/05/13/Android%E4%B8%AD%E7%9A%84GC%E5%88%86%E6%9E%90-Dalvik%E5%92%8CART%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2018/05/13/Android%E4%B8%AD%E7%9A%84GC%E5%88%86%E6%9E%90-Dalvik%E5%92%8CART%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-XV -- 四大组件</title>
      <link href="/2018/05/13/Android-Study-Plan-XV/"/>
      <url>/2018/05/13/Android-Study-Plan-XV/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><h2 id="Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？"><a href="#Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？" class="headerlink" title="Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？"></a>Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？</h2><h3 id="Android四大组件："><a href="#Android四大组件：" class="headerlink" title="Android四大组件："></a>Android四大组件：</h3><ol><li><p><strong><code>Activity</code></strong></p><blockquote><p>Activity的主要作用是展示一个界面并和用户直接交互。</p></blockquote><p>activity的启动由Intent触发（<strong>需要在AndroidManifest.xml中注册</strong>）。Intent分为两种：</p><ul><li><p>显示Intent：直接跳转至指定的Activity类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法中直接传入Component</span></span><br><span class="line">Intent intent=<span class="keyword">new</span> Intent(<span class="keyword">this</span>,Activity.class);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用SetComponent方法</span></span><br><span class="line">ComponentName componentName=<span class="keyword">new</span> Component(<span class="keyword">this</span>,Activity.class);</span><br><span class="line">Intent intent=<span class="keyword">new</span> Intent();</span><br><span class="line">intent.setComponentName(componentName);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用setClass方法</span></span><br><span class="line">Intent intent=<span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClassName(<span class="keyword">this</span>,Activity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li><li><p>隐式Intent：不明确指定启动哪个Activity，而是利用Activity配置的Action，Data，Category来让系统进行选择(<code>筛选是根据所有的&lt;intent-filter&gt;来筛选</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &lt;activity android:name=<span class="string">".MainActivity"</span>&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"TestActivity"</span> /&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setAction方法</span></span><br><span class="line">Intent intent=<span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"TestActivity"</span>);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接构造Action</span></span><br><span class="line">Intent intent=<span class="keyword">new</span> Intent(<span class="string">"TestActivity"</span>);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在使用隐式调用时需要注意该Action是否存在,所以需要做try-catch防止异常发生</span></span><br><span class="line"><span class="comment">//利用这个方法可以判断是否有处理该Action的Activity存在</span></span><br><span class="line">intent.resolveActivity(getPackageManager())</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>Service</code></strong></p><p>Service主要用于在后台执行一系列需要耗时的任务，需要单独的线程去完成，因为Service本身是运行在主线程的。Service不会与UI进行交互，其他的组件也可以启动Service，即便用户切换了应用，Service依然后台运行。（<strong>需要在AndroidManifest.xml中注册</strong>），Service有两种启动方式：</p><ul><li><code>startService</code>：启动一个Service，系统回调<code>onStartCommand()方法</code>，需要调用<code>stopService()</code>来停止Service</li><li><code>bindService</code>：绑定一个Service，调用<code>unBindService()</code>来取消绑定，或者关闭绑定的组件也可以停止</li></ul></li><li><p><strong><code>BroadcastReceiver</code></strong></p><p><a href="https://www.jianshu.com/p/ca3d87a4cdf3" target="_blank" rel="noopener">完整介绍</a></p><p>广播主要用于在不同的组件甚至不用的应用间进行消息传递，不与用户产生交互，工作在系统内部。</p><p>广播的注册方式有两种：</p><ul><li><p>静态注册 （<strong>需要在AndroidManifest.xml中注册</strong>）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line">&lt;!--此broadcastReceiver能否接收其他App的发出的广播--&gt;</span><br><span class="line">//默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false</span><br><span class="line">    android:exported=["true" | "false"]</span><br><span class="line">    android:label="string resource"</span><br><span class="line"><span class="comment">&lt;!--具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收--&gt;</span></span><br><span class="line">    android:permission="string"</span><br><span class="line">          &gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.test"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>动态注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最好在onResume中注册广播  </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onResume();</span><br><span class="line">      </span><br><span class="line">      mBroadcastReceiver=<span class="keyword">new</span> BroadcastReceiver();</span><br><span class="line">      IntentFilter intentFilter=<span class="keyword">new</span> IntentFilter();</span><br><span class="line">      intentFilter.addAction(<span class="string">"com.test"</span>);</span><br><span class="line">      <span class="keyword">this</span>.registerReceiver(mBroadcastReceiver,intentFilter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在onPause中取消注册</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>ContentProvider</code></strong></p><p><a href="https://www.jianshu.com/p/ea8bc4aaf057" target="_blank" rel="noopener">相关链接</a></p><p>主要用于给不同的应用提供共享数据,（<strong>需要在AndroidManifest.xml中注册</strong>）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">"wxy.provider.MyContentProvider"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:authorities</span>=<span class="string">"wxy.provider"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span> </span></span><br><span class="line">          &lt;!--是否可被其他应用使用 --&gt;</span><br><span class="line">          &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ContentProvider默认执行在主线程，需要实现以下方法</p><ul><li><code>onCreate()</code>：初始化Provider</li><li><code>query()</code>：查询数据 <strong>需异步操作</strong></li><li><code>insert()</code>：插入数据</li><li><code>update()</code>：更新Provider的数据</li><li><code>delete()</code>：删除Provider的数据</li><li><code>getType()</code>：返回指定Uri中的数据MIME类型</li></ul><p>相关的操作可能会被多个线程并发调用需要注意线程安全。</p></li></ol><h3 id="开启多进程"><a href="#开启多进程" class="headerlink" title="开启多进程"></a>开启多进程</h3><p>Android的四大组件都可以开启多进程，只要在AndroidManifest.xml中配置<code>android:process=&quot;any&quot;</code>，需要配置<code>android:exported</code>属性</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM相关及其拓展(五) -- Java内存模型</title>
      <link href="/2018/05/09/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%94/"/>
      <url>/2018/05/09/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%94/</url>
      <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><blockquote><p>屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到的一致的内存访问效果。</p></blockquote><p>主要目标：</p><p><strong>定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。变量包括了实例字段、静态字段和构成对象的元素，但不包括局部变量和方法参数（他们为线程私有，不被共享）。</strong></p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><blockquote><p>Java内存模型规定了所有的变量都存储在<code>主内存(Main Memory)</code>中，每条线程还有自己的<code>工作内存(Work Memory)</code>。工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取，赋值等)必须在工作内存中进行，不能直接读取主内存的变量。<strong>不同线程之间也无法直接访问对方工作内存中的变量，线程间传递变量均需通过主内存完成。</strong></p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/JVM-JMM.png" class="full-image" alt="线程-主内存-工作内存的交互关系" title="线程-主内存-工作内存的交互关系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。</p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><blockquote><p>关于主内存与工作内存具体的交互协议，<strong>即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，JMM中定义了8种操作来完成.</strong></p><p><code>每种操作都是原子、不可再分</code></p></blockquote><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Lock(锁定)</td><td>作用于主内存的变量，把一个变量表示为一条线程独占的状态</td></tr><tr><td>Unlock(解锁)</td><td>作用于主内存的变量，把一个锁定状态的变量释放出来</td></tr><tr><td>Read(读取)</td><td>作用于主内存的变量，一个变量值从主内存传输到线程的工作内存中</td></tr><tr><td>Load(载入)</td><td>作用于工作内存的变量，从read操作中得到的值放入工作内存的变量副本中</td></tr><tr><td>Use(使用)</td><td>作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行</td></tr><tr><td>Assign(赋值)</td><td>作用于工作内存的变量，把接收到的值赋值给工作内存中的变量，遇到需要赋值的情况会执行</td></tr><tr><td>Store(存储)</td><td>作用于工作内存的变量，把工作内存中的变量值传到主内存中</td></tr><tr><td>Write(写入)</td><td>作用于主内存的变量，把store操作中得到的工作内存中的变量的值放入主内存的变量中</td></tr></tbody></table><blockquote><p>如果要把一个变量从主内存复制到工作内存，就要顺序执行<code>read</code>和<code>load</code>操作，如果要从工作内存同步回主内存，就要顺序的执行<code>store</code>和<code>write</code>操作。</p></blockquote><h2 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h2><blockquote><p>Java内存模型就是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。这也是并发编程的三大概念。</p></blockquote><h3 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h3><blockquote><p><strong>对基本数据类型的读取和赋值都是原子操作</strong>，所谓原子性操作就代指这些<strong>操作是不可中断</strong>的，要么做完，要么就不执行。</p></blockquote><p>Java内存模型只保证了基本读取和赋值是原子操作。如果要实现更大范围操作的原子性，就需要通过<code>synchronized</code>和<code>lock</code>实现。</p><blockquote><p> Java中的原子操作包括：</p><ul><li>除long和double之外的基本数据类型赋值操作 <em>long和double占用的字节数是8即64bit，在32位操作系统上去读写数据需要两步完成，每一步取32位数据。需要添加volatile关键字保证</em></li><li>所有引用reference的赋值操作</li><li><code>java.concurrent.Atomic.*</code> 包下所有类的操作</li></ul></blockquote><h3 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性(Visibility)"></a>可见性(Visibility)</h3><blockquote><p>当一个线程修改了共享变量的值，其他线程能够立即得知这个值的修改。</p></blockquote><p>Java内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式实现可见性。</p><p><strong>当一个共享变量被volatile修饰时，他会保证修改的值会立即更新到主内存，当有其他线程需要读取时，会立即从主内存中读取新值。</strong></p><p>通过<code>synchronized</code>和<code>lock</code>也可保证可见性，<strong>保证同一时刻只有一个线程获取锁然后执行代码，并且在释放锁之前会将变量的修改刷新到主内存中，保证可见性。</strong></p><p>拓展：<code>final</code>也可以实现可见性，final修饰字段一旦初始化完成，在其他线程中就可以看到fianl的值。</p><h3 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性(Ordering)"></a>有序性(Ordering)</h3><blockquote><p>程序执行的顺序按照代码的先后顺序执行</p></blockquote><p>Java内存模型允许编译器和处理器对指令进行重排序，但是规定了<code>as-if-serial</code>（不管怎么重排序，程序的执行结果不能改变）。</p><p><strong>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</strong></p><p><code>volatile</code>本身包含了禁止指令重排序的语义，而<code>synchronized</code>通过<strong>一个变量在同一个时刻只允许一条线程对其lock操作</strong>实现有序性。</p><p><strong><em>要想并发程序正确的执行，必须要保证原子性、可见性和有序性，只要有一个没有被保证，就有可能导致程序运行不正确。</em></strong></p><h2 id="先行发生原则-happens-before"><a href="#先行发生原则-happens-before" class="headerlink" title="先行发生原则(happens-before)"></a>先行发生原则(happens-before)</h2><blockquote><p>JMM具备一些先天的<code>有序性</code>。<strong>不需要通过任何手段就可以保证有序性，称之为<code>先行发生原则</code>。如果两个操作的执行次序无法从先行发生原则推导出来，他们之间就没有顺序性保障，就不能保证有序性。</strong></p></blockquote><p>主要有以下规则：</p><ul><li><strong>程序次序规则</strong>：写在前面的代码先行发生于写在后面的(按照控制流顺序而不是代码顺序)</li><li><strong>管程锁定规则</strong>：一个解锁操作先行于时间后面发生的同一个线程的加锁操作</li><li><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于读操作</li><li><strong>线程启动规则</strong>：Thread对象的<code>start()</code>优先于该线程的任意操作</li><li><strong>传递性</strong>：如果操作A早于B，B又早于C，则A早于C</li><li><strong>线程中断规则</strong>：线程<code>interrupt()</code>调用早于该线程的中断检测。<code>Thread.interrupted()</code></li><li><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检测。<code>Thread.join()或者Thread.isAlive()</code></li><li><strong>对象终结规则</strong>：一个对象的初始化完成早于<code>finalize()</code></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构--HashMap实现原理及解析</title>
      <link href="/2018/05/09/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/05/09/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<!--主要是对HashMap，ArrayMap，ConcurrentHashmap--><!-- HashMap和HashTable的区别 , HashMap和ConcurrentHashMap的区别，HashMap的底层源码,HashMap的原理,ConcurrentHashMap，SparseArray,hashmap线程不安全，请问为什么线程不安全,--><!-- https://juejin.im/post/59e86f9351882521ad0f4147, https://juejin.im/post/5a7592f4f265da4e8d42ded2 --><!-- hashmap实现的数据结构，数组、桶等。hashmap的哈希冲突解决方法：拉链法等。拉链法的优缺点。hashmap的参数及影响性能的关键参数：加载因子和初始容量。Resize操作的过程。hashmap容量为2次幂的原因。hashtable线程安全、synchronized加锁。hashtable和hashmap异同。为什么hashtable被弃用？-->]]></content>
      
      
        <tags>
            
            <tag> Java源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM相关及其拓展(四) -- 垃圾收集器与内存分配策略</title>
      <link href="/2018/05/04/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%9B%9B/"/>
      <url>/2018/05/04/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%9B%9B/</url>
      <content type="html"><![CDATA[<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p><strong>垃圾收集(Garbage Collection,GC)：自动管理回收不再引用的内存数据</strong>需要完成的三件事情：</p><ul><li>哪些内存需要回收</li><li>什么时候回收</li><li>如何回收</li></ul><blockquote><p> Java语言会自动管理和回收不再引用的内存数据，由垃圾回收机制来完成。Java自身提供了内存管理机制，应用程序不需要去关注内存如何释放，内存用完后，GC会去自动进行处理，不需要人为干预出现错误。</p></blockquote><p>在<a href="/2018/04/10/JVM相关及其拓展/" title="JVM相关及其拓展（一）-- JVM内存区域">JVM相关及其拓展（一）-- JVM内存区域</a>章节中介绍了JVM的内存区域。</p><p><strong>其中<code>程序计数器</code>、<code>虚拟机栈</code>，<code>本地方法栈</code>随线程而生，随线程而灭</strong>。栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作，因此每一个栈帧分配多少内存基本是在类结构确定下来就已经是已知的。<strong>因此这几个区域的内存分配和回收都具备确定性。所以不需要过多考虑回收的问题，在方法结束或者线程结束后，内存就随着回收了，也就实现了内存的自动清理。</strong></p><p><strong>而<code>Java堆</code>和<code>方法区</code>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序运行期间才知道会创建哪些对象，这部分的内存分配和回收是动态的。垃圾收集器关注的就是这部分的内存。</strong></p><h3 id="2-判断对象是否可以回收"><a href="#2-判断对象是否可以回收" class="headerlink" title="2.判断对象是否可以回收"></a>2.判断对象是否可以回收</h3><blockquote><p> 在堆里面存放着几乎所有的对象实例，垃圾收集器在回收前需要去判断对象是否还被引用来决定是否回收，即找到那些不再被任何途径使用的对象。</p></blockquote><ul><li><p><strong>引用计数算法(Refrence Counting)</strong></p><blockquote><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时候计数器为0的对象是不能再被引用的，可以被当做垃圾收集。</p><p>优点：实现简单，判断效率高<br>缺点：无法检测出对象之间相互循环引用，开销大（会发生频繁且大量的引用变化，带来大量的额外运算）。</p></blockquote></li><li><p><strong>可达性分析算法(Reachability Analysis)</strong></p><blockquote><p>通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的节点为引用链，当一个对象到GC Roots没有任何引用链相连（从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p></blockquote></li></ul><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_reachability_analysis.png" class="full-image" alt="可达性分析算法" title="可达性分析算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>在Java语言中，可作为GC Roots的对象包括以下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li><p>本地方法栈中JNI引用的对象（Native对象）</p><blockquote><p>优点：更加精确严谨可以分析出循环引用的情况</p><p>缺点：实现复杂，效率低，分析过程中需要GC停顿（因为应用关系不能发生改变，需要停止所有Java线程）</p></blockquote></li></ul><h3 id="3-对象是生存还是死亡"><a href="#3-对象是生存还是死亡" class="headerlink" title="3.对象是生存还是死亡"></a>3.对象是生存还是死亡</h3><blockquote><p>真正宣告一个对象死亡，至少要经历两次标记过程 </p></blockquote><ul><li><p><strong>第一次标记</strong>：</p><p>对象在进行可达性分析算法后没有发现与GC Roots相连接的引用链，将会被第一次标记并进行第一次筛选。筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。</p><ul><li><p>没必要执行</p><p>对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已被虚拟机调用过。</p></li><li><p>有必要执行</p><p>对象会被放置在一个F-Queue的队列中，稍后会由一个JVM自动建立的、低优先级的Finalizer线程去执行。</p></li></ul></li><li><p><strong>第二次标记：</strong></p><p>GC对F-Queue中的对象进行第二次小规模的标记，<code>finalize()</code>是对象摆除被回收的最后方法</p><ul><li>若对象要避免自己被回收，需要重新与引用链上的任何一个对象建立关系即可，譬如把自己（this）赋值给某个变量或者对象的成员变量，那就会移除被回收的集合</li><li>如果没有摆除，则基本上会被回收。任何一个对象的<code>finalize()</code>方法只会被系统自动调用一次，再次调用<code>finalize()</code>方法则不会再次执行。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"It is live"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.err.println(<span class="string">"finalize is executed"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">"It is over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将对象的引用链重新置为null，则拯救失败</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">"It is over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>finalize()</code></strong></p><p>运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</p></li></ul><h3 id="4-回收方法区"><a href="#4-回收方法区" class="headerlink" title="4.回收方法区"></a>4.回收方法区</h3><blockquote><p>永久代的垃圾收集主要分为两部分：<strong>废弃常量和无用的类</strong></p><p><strong>废弃常量</strong>：假如常量池中存在一个常量，但是没有任何对象引用该常量，在发生回收的时候，该常量就会被系统清理出常量池，常量池中的其他类（接口）、方法、字段的符号引用类似。</p><p><strong>无用的类</strong>：需要同时满足以下条件</p><ol><li>该类的所有实例已被回收，Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader已被回收</li><li>该类对应的Class对象没有在任何地方被引用，也无法在任何地方通过反射访问到该类的方法</li></ol></blockquote><h3 id="5-垃圾收集算法"><a href="#5-垃圾收集算法" class="headerlink" title="5.垃圾收集算法"></a>5.垃圾收集算法</h3><ol><li><p><strong>标记-清除算法(Mark-Sweep)  最基础的收集算法</strong></p><blockquote><p>算法分为<code>标记</code>和<code>清除</code>两个阶段，<strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</strong>。主要不足有两个：一个是效率问题（<code>标记和清除两个过程的效率都不高</code>）；另一个是空间问题（<code>标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作</code>）。</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_mark_sweep.png " class="full-image" alt="标记-清除算法" title="标记-清除算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li><li><p><strong>复制算法(Copying)</strong></p><blockquote><p>将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象移到另一块上面，然后把已使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时就不需考虑内存碎片等情况。</p><p>缺点：可用内存会减少一半；效率会随存活对象的升高而降低（当对象存活率较高的时候，需要更多的copy操作，导致效率降低）</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_copying.png" class="full-image" alt="整理算法" title="整理算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>现在的商业虚拟机都采用这种收集算法来回收新生代。</p><p>提供了改良算法（基于<strong>弱代理论①</strong>）：不是按照1:1的比例去划分内存空间，而是分为较大的Eden空间和两块较小的Survivor空间，在回收时将Eden和Survivor存活的对象移至到另一块Survivor空间上。<strong>HotSpot中Eden和Survivor的大小比例为8:1。</strong><code>在一般场景下足够使用，当Survivor空间不够使用时，需要依赖其他内存(代指老年代)进行分配担保②</code>。</p><blockquote><p>①<strong>弱代理论</strong>：1. 大多数分配了内存的对象存活不会太久，在年轻代就会死掉；2. 很少有对象从年老代变成年轻代。</p><p>②<strong>分配担保</strong>：如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。</p></blockquote></li><li><p><strong>标记-整理算法(Mark-Compact)</strong></p><blockquote><p>标记过程与“标记-清除”算法一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理端边界以外的内存。</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_mark_compact.png" class="full-image" alt="标记-整理算法" title="标记-整理算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>优点：1. 效率不随对象存活率升高而降低。 2. 不像标记-清除算法会产生大量的内存碎片（因为会进行一次整理，将存活对象集中到一端）。</p><p>缺点：除了需要进行标记，还需要整理过程，执行效率更低。</p></blockquote></li><li><p><strong>分代收集算法(Generational Collection)</strong></p><blockquote><p>根据对象存活周期的不同将内存划分为几块，一般是把Java堆分成新生代和老年代<del>和持久代(JDK8中移除)</del>，这样就可以根据各个年代的特点采用最适当的收集算法。<br><strong>新生代</strong>中每次垃圾收集都会有大量的对象被回收，只有少量存活，就可以使用复制算法。</p><p><strong>老年代</strong>中因为对象存活率较高，没有额外空间进行分配担保，所以必须使用“标记-清理”或者“标记-整理”算法。</p></blockquote></li></ol><ul><li><strong>新生代(Young Generation)</strong>：所有新生对象都会放在新生代，新生代的目标是尽快收集生命周期短的对象，每次GC过后只有少量存活。新生代发生的GC叫做<strong><code>Minor GC（频率较高，新生代Eden区满才触发）</code></strong>。新生代细分为<code>Eden、From Survivor、To Survivor</code>三块空间（三块空间大小并非均分，默认比例为8:1:1）。</li><li><strong>老年代(Tenured Generation)</strong>：新生代发生几次GC后依然存活的对象会放到老年代中，所以老年代中的对象生命周期较长。内存也比新生代大很多（大概2:1）,当老年代内存满时会触发<strong><code>Full GC/Major GC(针对新生代和老年代触发，经常会伴随至少一次的Minor GC，收集频率较低且耗时长，一般慢10倍以上)</code></strong>。</li><li><del><strong>持久代(Permanent Generation)</strong></del>：用于存放静态文件，如Java类，方法等，对GC没有影响。</li><li><strong>拓展</strong>：别处也有介绍   Full GC针对整个堆空间（包含新生代，老年代，永久代（如果包含））的回收。而Major GC是针对老年代的内存回收。</li><li><strong>Minor GC</strong>：新生代是堆的一部分，对象首先在新生代中分配。新生代填满时，垃圾收集器会暂停所有的应用程序，回收新生代空间。不再使用的对象会被回收，仍然使用的对象移动至其他地方。</li><li><strong>Full GC:</strong> 对象不断地移至老年代，最终老年代也被填满，JVM需要找到老年代不再使用的对象并进行回收。会导致长时间停顿。</li></ul><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_java_heap_memory.png" class="full-image" alt="Java堆内存" title="Java堆内存"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h3 id="6-垃圾收集器"><a href="#6-垃圾收集器" class="headerlink" title="6.垃圾收集器"></a>6.垃圾收集器</h3><blockquote><p>收集算法是内存回收的方法论，垃圾收集器就为内存回收的具体实现。</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_collectors.png" class="full-image" alt="垃圾收集器" title="垃圾收集器"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>根据上图分析新生代收集器主要是：<strong>Serial收集器,ParNew收集器,Parallel Scavenge收集器和G1收集器</strong>。老年代收集器为<strong>CMS收集器，Serial Old收集器，Parallel收集器和G1收集器</strong>。</p><p>在两个收集器之间存在连线，则意味着他们之间可以搭配使用。</p><ul><li><p><code>Serial收集器</code></p><blockquote><p>该收集器是最基本、发展历史最悠久的收集器。这个收集器是一个<strong>单线程</strong>收集器（<code>不仅是他只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是他在进行垃圾收集时必须停止其他的工作线程(Stop The World)，直到收集结束。进行Full GC时，还会对老年代空间对象进行压缩整理。</code>）。</p></blockquote><p>是虚拟机运行在Client端的默认新生代收集器</p><p>有着优于其他收集器的地方：</p><ul><li><strong>简单而高效</strong></li><li><strong>没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集效率</strong></li></ul><p>关键控制参数：</p><ul><li>-XX:SurvivorRatio：设置两个Survivor区和Eden区的比值(<strong>8表示 1:1:8</strong>)</li><li>-XX:PretenureSizeThreshold：设定对象超过多少岁时进入老年代</li><li>-XX:HandlePromotionFailure：设置是否允许担保失败</li></ul></li></ul><ul><li><p><code>ParNew收集器</code></p><blockquote><p>ParNew收集器其实是Serial收集器的多线程版本。除了使用多线程进行垃圾收集之外，其他科Serial收集器完全一样。</p></blockquote><p>该收集器是运行在Server模式下的虚拟机中的首选的新生代收集器，其中有一个重要的原因就是：<strong>除了Serial收集器外，目前只有它能和CMS收集器配合工作。</strong>随着可以使用的CPU数量增加，GC时系统资源的有效利用还是有好处的。<strong>默认开启的收集线程数与CPU的数量相同</strong></p><blockquote><p><strong>并行（Parallel）</strong>：指多条垃圾收集器线程并行工作，但此时用户线程仍处于等待状态</p><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集器同时执行，用户程序仍继续运行，而垃圾收集器执行于另一个CPU上。</p></blockquote><p>关键控制参数：</p><ul><li>-XX:UserParNewGC：是否开启ParNew收集器</li></ul></li><li><p><code>Parallel Scavenge收集器</code></p><blockquote><p>Parallel Scavenge收集器是一个新生代收集器，使用了复制算法以及并行的多线程收集器。</p></blockquote><p>该收集器的目标是：<strong>达到一个可控制的吞吐量（ThroughPut）</strong>①。</p><p>停顿时间越短越适合需要与用户交互的程序，良好的响应速度可以提升用户体验，高吞吐量就可以高效率的利用CPU时间，主要适合在后台运算而不需要太多交互的任务。</p><blockquote><p><code>吞吐量</code>：CPU用于运行用户代码时间与CPU总消耗时间的比值。</p></blockquote><p>关键控制参数：</p><ul><li>-XX:UseAdaptiveSizePolicy：开关参数，当打开时就不需要去指定新生代大小以及Eden与Survivor比例，晋升老年代对象岁数大小等参数，触发<strong>GC自适应调节策略</strong>(<code>虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数已提供最适合的停顿时间或者最大的吞吐量</code>)</li></ul></li><li><p><code>Serial Old收集器</code></p><blockquote><p>是Serial收集器的老年代版本，同样是一个单线程收集器。使用“标记-整理算法”</p></blockquote><p>该收集器主要为了给Client模式下的虚拟机使用。如果在Server模式下，还有以下用途：</p><ul><li>在JDK1.5及之前的版本搭配Paraller Scavenge收集器</li><li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li></ul></li><li><p><code>Parallel Old收集器</code></p><blockquote><p>是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”。</p></blockquote><p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑<code>Parallel Scavenge +  Parallel Old</code>组合。</p></li><li><p><strong><code>CMS收集器（Concurrent Mark Sweep）</code></strong></p><blockquote><p>以获取最短回收停顿时间为目标的收集器。基于“<strong>标记-清除算法</strong>”实现。整体上来说内存回收过程是与用户线程一起并发执行的。</p></blockquote><p>运作过程比较复杂，分为4个步骤：</p><ul><li><strong>初始标记</strong>：仅仅标记一下GC Roots能关联到的对象，速度很快  <code>触发Stop The World</code></li><li><strong>并发标记</strong>：进行GC Roots Tracing的过程</li><li><strong>重新标记</strong>：修正并发标记期间因用户程序继续运做而导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记长一些，但短于并发标记时间  <code>触发Stop The World</code></li><li><strong>并发清除</strong>：可以和用户线程一起工作</li></ul><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_collectors_CMS.png" class="full-image" alt="CMS" title="CMS"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>CMS收集器有3个明显的缺点：</p><ol><li><p><strong>对CPU资源非常敏感</strong></p><p><strong>面向并发设计的程序都对CPU资源比较敏感</strong>。在并发阶段，虽然不会导致用户线程停顿，但是会因为占了一部分CPU资源而导致线程变慢，吞吐量会降低。<code>CMS默认启动的回收线程数量为(CPU数量+3)/4</code></p></li><li><p><strong>无法处理浮动垃圾（Floating Garabge）</strong></p><p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就有新的垃圾产生，即<code>浮动垃圾(这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉他们，只能留到下一次GC进行清理)</code>。</p><p>因此CMS收集器不能像其他收集器一样等到老年代几乎完全满了在进行收集，需要预留一部分空间提供并发收集时使用。</p><p>JDK1.5默认设置下，CMS收集器到老年代到了68%即会激活，到1.6时提高到了92%。</p><p>要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<code>Concurrent Mode Failure</code>失败，虚拟机将会启动后备预案：<strong>临时启用Serial Old收集器来重新进行老年代的垃圾收集，停顿时间就会变得很长了。</strong></p></li><li><p><strong>产生的空间碎片</strong></p><p>由于CMS是基于“标记-清除”算法实现的收集器。这种方式会产生大量的空间碎片，碎片过多时将会给对象分配来很大麻烦，往往会出现老年代还有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p></li></ol><p>关键控制参数：</p><ul><li>-XX:CMSInitiatingOccupancyFraction：设置CMS触发阈值即老年代对象占用空间</li></ul></li><li><p><strong><code>G1收集器</code></strong></p><blockquote><p>全称Garbage-First收集器，通过-XX:+UseG1GC参数来启用，在JDK9中，被提议为默认收集器。<code>在JDK10中，把单线程的Full GC改良为了多线程Full GC</code></p></blockquote><p>G1收集器是一款面向服务端的垃圾收集器，设计目标是为了取代CMS收集器。具备如下特点：</p><ul><li><strong>并行与并发</strong>：使用多个CPU来缩短停顿时间，也会通过并发的方式让Java程序继续运行</li><li><strong>分代收集</strong>：分代概念在G1中得以保留，可以不需要其他的收集器配合管理整个堆，可以采用不同的方式去处理新创建的对象和旧对象。</li><li><strong>空间整合</strong>：整体基于“标记-整理”算法，局部（两个Region之间）采用“复制”算法实现</li><li><strong>可预测的停顿</strong>：除了追求低停顿外，还可建立可预测的时间停顿模型，用户可以指定期望停顿的时间</li></ul><h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h4><p>在G1收集器之前其他收集器进行收集的范围都是整个新生代或者老年代，而G1可以通用。使用G1收集器，Java堆的内存布局就与其他收集器不同，将整个Java堆划分为多个大小相等的独立区域（Region），虽然保留了新生代老年代的概念，但他们都变成了一部分Region的集合。</p><h4 id="可停顿的时间模型"><a href="#可停顿的时间模型" class="headerlink" title="可停顿的时间模型"></a>可停顿的时间模型</h4><p>可以实现有计划的避免在整个Java堆中进行全区域的垃圾收集。跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region空间。可以保证G1收集器在有限时间内获得尽可能高的收集效率。</p><h4 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h4><p>Region不可能是独立的，由于可能会被其他对象引用。在G1中，Region之间的对象引用以及其他收集器中的新生代老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。每一个Region都会对应一个Remembered Set，虚拟机发现在对Reference进行读写操作时，产生一个<code>Write Barrier</code>暂时中断写操作，检查对象引用是否位于不同的Region中，若是则通过<code>CardTable</code>记录相关引用信息到Remembered Set中。<strong>在进行内存回收时，在GC Roots中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</strong></p><h4 id="stop-the-world"><a href="#stop-the-world" class="headerlink" title="stop-the-world"></a><strong>stop-the-world</strong></h4><p>概念：<strong>除GC所需线程外，多有线程都要进如等待状态，直到GC任务完成。</strong></p><p>解决方法：使用多个CPU来缩短停顿时间。</p><h4 id="G1运作步骤"><a href="#G1运作步骤" class="headerlink" title="G1运作步骤"></a>G1运作步骤</h4><ul><li><strong>初始标记</strong>：标记一下GC Roots能直接关联的对象，需要停顿线程</li><li><strong>并发标记</strong>：从GC Roots开始进行可达性分析，找出存活的对象耗时较长</li><li><strong>最终标记</strong>：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，需要停顿线程，可并行执行</li><li><strong>筛选回收</strong>：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间来指定回收计划。</li></ul><p><strong>如果应用追求吞吐量，那并不会带来特别的好处</strong></p></li><li><p><code>ZGC收集器</code></p><blockquote><p>在Java11 中引入的新型收集器</p></blockquote></li></ul><h3 id="7-内存分配与回收策略"><a href="#7-内存分配与回收策略" class="headerlink" title="7.内存分配与回收策略"></a>7.内存分配与回收策略</h3><p><strong>对象的内存分配，就是在堆上进行分配。</strong></p><blockquote><p>对象优先在Eden分配,就是在JVM的堆上进行内存分配</p></blockquote><blockquote><p>大对象直接进入老年代</p></blockquote><p>大对象代指 <strong>需要连续内存空间的Java对象</strong></p><blockquote><p>长期存活的对象将进入老年代</p></blockquote><p>当Eden区满了，在创建对象会触发Minor GC(<strong>执行Minor GC时，Eden空间存活的对象会被复制到To Survivor·空间，并且之前经过一次Minor GC在From Survivor存活并年轻的对象也会被复制到To Survivor空间。如果存活对象的分代年龄超过阈值，则会晋升到老年代。</strong>)</p><blockquote><p>动态对象年龄判定</p></blockquote><p>为了更好的适应不同程序的内存状况，并不需要永远要求对象年龄必须达到<code>maxTenuringThreshold</code>才可以晋升老年代，<strong>若在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</strong></p><blockquote><p>空间分配担保</p></blockquote><p><strong>如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。</strong></p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构-链表</title>
      <link href="/2018/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="数据结构-链表"><a href="#数据结构-链表" class="headerlink" title="数据结构-链表"></a>数据结构-链表</h1><blockquote><p>链表是一种基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)，简单来说链表并不像数组存储在一个连续的内存地址空间里，他们可以是不连续的因为他们每个节点保存着下一个节点的引用（地址），所以较之数组来说这是一个优势。</p></blockquote><h2 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1.单链表"></a>1.单链表</h2><blockquote><p>单链表是链表的一种，由节点组成，每个节点包含到下一个节点的指针。</p></blockquote><blockquote><p>单链表特点：</p><ul><li>链表增删元素时间复杂度度为O(1)，查找一个元素复杂度为O(n)</li><li>单链表不需要预先分配空间，避免空间浪费</li><li>单链表不能进行回溯操作，例如读取倒数几个节点的值</li></ul></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/structures/single_linkedlist.png" class="full-image" alt="单链表" title="单链表"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 表示一个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="comment">//下一节点</span></span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h3><ul><li><p>链表添加元素</p><ul><li>添加头部</li><li>添加尾部</li></ul></li><li><p>链表删除元素</p><ul><li>删除指定位置</li><li>删除倒数第K个节点</li></ul></li><li><p>链表查询元素</p><ul><li>指定索引</li><li>查询倒数第K个节点</li></ul></li><li><p>其他操作</p><ul><li><p>寻找链表中间元素</p></li><li><p>旋转单链表</p></li><li><p>翻转单链表</p></li><li><p>单链表排序</p><ul><li>冒泡排序</li><li>插入排序</li></ul></li><li><p>链表相加求和</p></li><li><p>删除重复元素</p></li></ul></li></ul><h2 id="2-双循环链表"><a href="#2-双循环链表" class="headerlink" title="2.双循环链表"></a>2.双循环链表</h2>]]></content>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM相关及其拓展(三) -- 虚拟机类加载器</title>
      <link href="/2018/04/16/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%89/"/>
      <url>/2018/04/16/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%89/</url>
      <content type="html"><![CDATA[<h1 id="1-虚拟机类加载器"><a href="#1-虚拟机类加载器" class="headerlink" title="1.虚拟机类加载器"></a>1.虚拟机类加载器</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>在类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码块称为“类加载器”。</p><p>例如：编写的是.java文件，代码运行后变成.class文件，类加载器就是加载.class文件。</p><h2 id="Java类加载器分类："><a href="#Java类加载器分类：" class="headerlink" title="Java类加载器分类："></a>Java类加载器分类：</h2><h3 id="1-系统提供的类加载器"><a href="#1-系统提供的类加载器" class="headerlink" title="1.系统提供的类加载器"></a>1.系统提供的类加载器</h3><ul><li><p><strong>Bootstrap ClassLoader(启动类加载器)</strong>：由C/C++实现的加载器，用于加载虚拟机运行时所需要的系统类，如<code>java.lang.*、java.uti.*</code>等系统类。它负责将存放在&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。</p><p>这个加载器由于是C实现的，所以无法被Java程序直接引用。并且不继承<code>java.lang.ClassLoader</code>。</p></li><li><p><strong>Extension ClassLoader(扩展类加载器)</strong>：这个加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的，或者被<code>javax.ext.dirs</code>系统变量所指定的路径中的所有类库。</p></li><li><p><strong>Application ClassLoader(应用程序类加载器)</strong>：这个加载器由sun.misc.Launcher$AppClassLoader实现。可以加载用户类路径上的指定类库，通过<code>ClassLoader.getSystemClassLoader()</code>方式获取，没有定义过自己的类加载器，则默认是这个。</p></li><li><p><strong>Custom ClassLoader(自定义加载器)</strong>：通过集成<code>java.lang.ClassLoader</code>来实现自己的加载器。</p></li><li><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/parent_loader.png" class="full-image" alt="alt" title="双亲委派模型"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul><h3 id="2-双亲委托模型"><a href="#2-双亲委托模型" class="headerlink" title="2.双亲委托模型"></a>2.双亲委托模型</h3><ul><li><p>工作流程：如果一个类加载器收到了类加载的请求，不会自己去尝试加载这个类，而把这个请求委派给父类加载器去完成，每一层都是如此，依次向上递归，直到委托到最顶层的<code>Bootstrap ClassLoader</code>，若父加载器无法处理加载请求（它的搜索范围内没有找到所需的类时），则交由子加载器去加载。</p><blockquote><p>简单流程介绍</p><ol><li>自定义类加载器先从缓存中查看Class文件是否被加载，如果加载则返回Class，没有加载则委托给父类加载</li><li>一直委托到<code>Bootstrap ClassLoader</code>,在<code>Bootstrap ClassLoader</code>没有找到Class文件，则在自己的规定路径&lt;JAVA_HOME&gt;\lib或者-Xbootclasspath选项指定路径的jar包进行查询，找到则返回Class，没有就交由子加载器去加载。</li><li>最后交由我们自定义的类加载器去加载，还找不到则抛出<code>ClassNotFoundException</code>异常。</li></ol></blockquote></li><li>代码模型实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">           <span class="comment">// 检查请求的类是否已被加载过</span></span><br><span class="line">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">           <span class="comment">//对应的类已被加载则不会往下进行</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//父加载器不为null，调用父加载器的load方法</span></span><br><span class="line">                       c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//父加载器为null，则调用系统的BootstrapClassLoader</span></span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                   <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                   <span class="comment">//父类加载器无法加载则抛出ClassNotFoundException异常</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                   <span class="comment">// to find the class.</span></span><br><span class="line">                   <span class="comment">//父类加载器无法加载则调用本身的findClass()方法去加载</span></span><br><span class="line">                   <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                   c = findClass(name);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>好处：<ul><li>避免重复加载，若该Class已加载则从缓存中直接读取</li><li>更加安全，例如<code>java.lang.Object</code>，无论哪一个类加载器去加载这个类，最终都会委派给Bootstrap ClassLoader去进行加载，所以我们自定义的Object类并不会被加载而导致系统中出现多个Object类。</li></ul></li></ul><h3 id="3-破坏双亲委托模型"><a href="#3-破坏双亲委托模型" class="headerlink" title="3.破坏双亲委托模型"></a>3.破坏双亲委托模型</h3><p>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载实现方式。</p><ul><li>在JDK1.2发布之前，还没有双亲委托机制</li><li>由模型自身缺陷所导致的</li><li>用户对于程序动态性导致的，例如代码热替换，模块热部署</li></ul><h3 id="4-自定义ClassLoader"><a href="#4-自定义ClassLoader" class="headerlink" title="4.自定义ClassLoader"></a>4.自定义ClassLoader</h3><ul><li><p>自定义需要加载的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jobs</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"自定义加载器加载"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义完成后需调用<code>javac Jobs.java</code>去生成对应的<code>Jobs.class</code>文件以用来加载。</p></li><li><p>实现自定义的ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiskClassLoader</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//用来将获取的字节码数组转为class的实例</span></span><br><span class="line">            clazz = defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得class文件的字节码数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        String fileName = getFileName(name);</span><br><span class="line">        File file = <span class="keyword">new</span> File(path, fileName);</span><br><span class="line">        System.err.println(fileName);</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                byteArrayOutputStream.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//读取流后需要关闭，以免造成内存泄露</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (byteArrayOutputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    byteArrayOutputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFileName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = name.indexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">".class"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name.substring(index + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的ClassLoader需要读取对应Class的字节流数组，以便产生实例。注意不要忘记对流的关闭。</p></li><li><p>使用自定义的ClassLoader去加载类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoaderTest</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      DiskClassLoader diskClassLoader = <span class="keyword">new</span> DiskClassLoader(<span class="string">"需要加载的class的地址"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对class文件进行加载</span></span><br><span class="line">            Class c = diskClassLoader.loadClass(<span class="string">"Jobs"</span>);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object object = c.newInstance();</span><br><span class="line">                    System.err.println(object.getClass().getClassLoader());</span><br><span class="line">                    Method method = c.getDeclaredMethod(<span class="string">"say"</span>, <span class="keyword">null</span>);</span><br><span class="line">                    method.invoke(object, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对应的文件夹下是否已存在Jobs.java文件：</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存在要加载的Java文件</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">自定义加载器加载</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不存在对应的Java文件</span></span><br><span class="line">DiskClassLoader<span class="meta">@d</span>716361</span><br><span class="line">自定义加载器加载</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>​          以上就为自定义ClassLoader的基本步骤，也是热修复框架中ClassLoader的雏形。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-XIV</title>
      <link href="/2018/04/16/Android-Study-Plan-XIV/"/>
      <url>/2018/04/16/Android-Study-Plan-XIV/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>##用过RxJava和RxAndroid吗？RxAndroid切换线程是怎么实现的？</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVC,MVP,MVVM的理解</title>
      <link href="/2018/04/15/MVC-MVP-MVVM%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/04/15/MVC-MVP-MVVM%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="1-MVC模式"><a href="#1-MVC模式" class="headerlink" title="1.MVC模式"></a>1.MVC模式</h1><p>MVC(Model-View-Controller，模型-视图-控制器)是20世纪80年代出现的一种设计模式。他用一种业务逻辑、数据、界面显示分离的方法组织代码。在Android中MVC的角色定义如下：</p><ul><li><p>Model(模型层)：针对业务模型，建立的数据结构和相关的类，就可以理解为Model。与View无关，与业务相关。</p></li><li><p>View(视图层)：一般采用XML文件或者Java代码进行界面的描述。</p></li><li><p>Controller(控制器)：Android的控制层一般在Activity，Fragment中或者在由他们控制的其他业务类中。</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/pattern/mvc_pattern.png" class="full-image" alt="MVC" title="MVC"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul><p>缺点：</p><ul><li>在Android开发中，Activity不是一个标准的Controller，首要职责为加载应用的布局和初始化界面，并接受用户的请求。随着界面以及代码逻辑的复杂，Activity会越来越庞大。</li><li>view层和model层是相互感知的，意味之间存在很大的耦合。</li></ul><h1 id="2-MVP模式"><a href="#2-MVP模式" class="headerlink" title="2.MVP模式"></a>2.MVP模式</h1><p>MVP(Model-View-Presenter)是MVC的演化版本，对于Android来说，Model层和MVC模式是一种概念，activity或者fragment对应的就是View层，所有用户相关事件处理由Presenter处理。</p><ul><li><p>Model：主要提供数据的存取功能。</p></li><li><p>View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件</p></li><li><p>Presenter：作为View和Model沟通的桥梁，从Model层检索数据并返回给View层，使得View和Model层完全解耦。Presenter与View可以通过接口来实现通信，只要View层去实现定义好的接口。</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/pattern/mvp_pattern.png" class="full-image" alt="MVP" title="MVP"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul><p>缺点：</p><ul><li>View层和Presenter层会交互过于频繁，若Presenter过多的渲染了View，往往导致过于紧密，若View发生改动，Presenter也要发生变更。</li></ul><h1 id="3-MVVM模式"><a href="#3-MVVM模式" class="headerlink" title="3.MVVM模式"></a>3.MVVM模式</h1><p>MVVM(Model-View-ViewModel)是2015由微软提出的一个UI架构概念。将Presenter改为ViewModel，同时实现View和ViewModel的双向绑定（View的变动，自动反映在ViewModel，反之亦然）。</p><ul><li><p>Model：主要提供数据的存储过程</p></li><li><p>View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件</p></li><li><p>ViewModel：功能和Presenter类似，与View和Model双向绑定</p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/pattern/mvvm_pattern.png" class="full-image" alt="MVC" title="MVC"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul><p>优点：</p><ul><li>低耦合。View可以独立于Model变化和修改，ViewModel可以绑定不同的View</li><li>可重用性。把许多的试图逻辑处理放在一个ViewModel中，许多View可以使用该ViewModel</li><li>独立开发。开发人员可以专注于逻辑和数据的处理</li><li>可测试性。可以直接针对ViewModel进行单独测试。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>进程保活介绍</title>
      <link href="/2018/04/12/%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/04/12/%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h1><p>进程保活的方式分为两个层面：<code>提高进程优先级，降低被杀死的概率</code>,<code>在进程被杀死后，进行拉活</code>。</p><h2 id="1-进程的优先级"><a href="#1-进程的优先级" class="headerlink" title="1. 进程的优先级"></a>1. 进程的优先级</h2>  <span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/process_level.webp" class="full-image" alt="alt" title="进程优先级"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><a href="/2018/04/03/日常细节记录/" title="日常细节记录">日常细节记录</a><h2 id="2-Android进程回收策略"><a href="#2-Android进程回收策略" class="headerlink" title="2. Android进程回收策略"></a>2. Android进程回收策略</h2><p>对于进程的回收，依靠LowmemoryKiller完成，按照OOM_ADJ的阈值级别触发对应的内存回收。<br> <span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/oom_adj.webp" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><br>红色代表易被杀死的进程，绿色不易被杀死。LowmemoryKiller会优先杀死OOM_ADJ较大的进程，优先级相同则进一步受到进程所占内存和进程存活时间的影响。</p><h2 id="3-提升进程优先级"><a href="#3-提升进程优先级" class="headerlink" title="3. 提升进程优先级"></a>3. 提升进程优先级</h2><ul><li><strong>利用Activity提升权限</strong>：<code>监控手机锁屏解锁事件，在屏幕锁定时启动一个一像素的Activity，解锁时销毁。</code><strong>需把Activity设置成用户无感知</strong></li><li><strong>利用Notification提升权限</strong>：<code>Service的优先级为4，使用setForeground可以设置前台Service，提升进程的优先级，降低被杀的概率。</code><ul><li><strong>注意点</strong>：设置为前台Service时，在通知栏会显示一条通知。</li><li><strong>应对措施</strong>：可以去实现一个内部Service，在LiveService和其内部Service中同时发送相同ID的Notification，然后结束内部Service。内部Service被结束时，Notification也会消失，但是进程的优先级不会发生变化。</li></ul></li></ul><h2 id="4-进程死后拉活的方案"><a href="#4-进程死后拉活的方案" class="headerlink" title="4. 进程死后拉活的方案"></a>4. 进程死后拉活的方案</h2><ul><li><strong>利用系统广播拉活</strong>：在发生特定事件是，系统会发送相应的广播，可以在AndroidManifest中静态注册对应的广播监听器，即可在对应事件发生时拉活应用。以下是常见的拉活广播事件：<ul><li>开机广播：RECEIVE_BOOT_COMPLETED</li><li>网络变化：CHANGE_NETWORK_STATE,CHANGE_WIFI_STATE…</li><li>文件挂载：MOUNT_UNMOUNT_FILESYSTEMS</li><li>屏幕亮灭：SCREEN_ON,SCREEN_OFF</li><li>锁屏解锁：RECEIVE_USER_PRESENT</li><li>应用安装卸载：PACKAGE_ADDED,PACKAGE_REMOVED<br>缺点：</li><li>广播接收器容易被系统的管理软件通过“自启管理”禁用场景，从而无法处理</li><li>系统广播事件不可控，只能保证有对应事件是拉活进程，但不能保证能否立即拉活。</li></ul></li><li><strong>利用第三方应用广播拉活</strong>：该方案接受第三方应用的广播，反编译一些第三方应用，找到他们发送的广播，在自己应用内进行监听，当这些应用发送广播时，即可拉活自己的应用。<br>  缺点：<ul><li>需要反编译较多应用来确保效果</li><li>第三方应用的广播可能会在日后更新中修改或删除</li></ul></li><li><strong>利用系统Service机制拉活</strong>：把Service设置为<code>START_STICKY</code>，这个参数可以在Service被杀死后，利用系统机制尝试拉活。<br>  缺点：<ul><li>Service第一次被异常杀死后会在5秒内重启，第二层被杀死10秒内重启，第三次会在20秒内重启，一旦被杀死达到5次，则系统不会再重新拉活。</li><li>进程被Root权限的工具杀死活forcestop，无法重启。</li></ul></li><li><strong>利用Native进程拉活</strong>：利用Linux中的fork机制创建Native进程，在Native进程中监控主进程的存活，当主进程挂掉后，在Native进程中立即对主进程拉活。（该进程的生命周期不受Android的管理）。<br>  适用范围：<ul><li>在Android5.0以下版本手机效果很好，不受forcestop影响</li><li>在5.0以上的手机，Native进场也会被forcestop杀死，假如逻辑跑的比系统快，依然可以拉活。</li></ul></li><li><p><strong>利用JobScheduler机制拉活</strong>：系统在Android5.0以上版本提供了JobScheduler接口，系统会定时调用该进程使应用处理一些操作。<br>  适用范围：Android5.0以上系统手机，在部分小米手机可能无法拉活。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeepLiveService</span> <span class="keyword">extends</span> <span class="title">JobService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG=<span class="string">"KeepLive"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Service mKeepLiveService= <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(JobParameters jobParameters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters jobParameters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startJobscheduler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> jobId=<span class="number">1</span>;</span><br><span class="line">            JobInfo.Builder builder=<span class="keyword">new</span> JobInfo.Builder(jobId,</span><br><span class="line">                    <span class="keyword">new</span> ComponentName(MyApplication.getApplicationContext(),</span><br><span class="line">                            KeepLiveService.class));</span><br><span class="line">            builder.setPeriodic(<span class="number">10</span>);<span class="comment">//设置时间间隔</span></span><br><span class="line">            builder.setPersisted(<span class="keyword">true</span>);<span class="comment">//重启后需要继续执行</span></span><br><span class="line">            JobScheduler js = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line">            js.schedule(builder.build());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>利用账号同步进制拉活</strong>：Android系统的账号同步进制会定期同步执行，可以利用同步机制进行进程的拉活。<br>  适用范围：适用于所有的Android版本，在Android N中进行了一些变动，该方案失效。</p></li><li><strong>其他方案</strong>：<ul><li>利用系统通知权限进行拉活</li><li>利用辅助功能拉活，将应用加入厂商白名单</li><li>利用推送进行拉活（如小米、华为推送）</li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM相关及其拓展(二) -- 虚拟机类加载机制</title>
      <link href="/2018/04/12/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%8C/"/>
      <url>/2018/04/12/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><code>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</code></p><h2 id="2-类的生命周期"><a href="#2-类的生命周期" class="headerlink" title="2.类的生命周期"></a>2.类的生命周期</h2><p>  类从被加载到虚拟机内存中开始，到卸载除内存为止，生命周期包括：<strong>加载(Loading)</strong>、<strong>验证(Verification)</strong>、<strong>准备(Preparation)</strong>、<strong>解析(Resolution)</strong>、<strong>初始化(Initialization)</strong>、<strong>使用(Using)</strong>、<strong>卸载(Unloading)</strong>。其中<code>验证</code>、<code>准备</code>、<code>解析</code>统称为<strong>连接(Linking)</strong><br><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/class_lifecycle.png" class="full-image" alt="类的生命周期" title="类的生命周期"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><br>  加载、验证、准备、初始化和卸载阶段执行顺序为确定的，类的加载过程必须按照这个顺序开始。解析阶段不一定：在某些情况下可以在初始化阶段之后开始，为了支持Java语言的运行时绑定。<br>  初始化阶段，虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”：</p><ul><li>遇到<code>new ,getstatic,putstatic或invokestatic</code>指令时，类没有进行初始化，则需要先触发初始化。最常见的Java代码场景：使用new关键字实例化对象、读取或设置一个类的静态字段、调用一个类的静态方法。</li><li>使用<code>java.lang.reflect</code>进行反射调用的时候。</li><li>初始化一个类时，发现父类还没有初始化，先触发父类初始化方法。</li><li>虚拟机启动时，用户指定一个要执行的主类(包含<code>main()</code>方法的类)，先初始化该类。</li><li>使用动态语言支持时，若<code>java.lang.invoke,MethodHandle</code>实例最后解析结果为<code>REF_getStatic,REF_putStatic,REF_invokeStatic</code>的方法句柄，并且该类没有进行初始化。  </li></ul><h2 id="3-类加载的过程"><a href="#3-类加载的过程" class="headerlink" title="3.类加载的过程"></a>3.类加载的过程</h2><ul><li><strong>加载</strong><br>虚拟机需要完成以下3件事情：<ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li></ol></li></ul><p>并没有指定一个二进制字节流要从一个Class文件中获取</p><ul><li><p><strong>验证</strong>（若代码被反复验证和使用过，可以使用<code>-Xverify:none</code>来关闭大部分的类验证措施，缩短虚拟机加载时间）</p><p>验证是连接阶段的第一步，这一阶段的目的是为了<strong>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</strong>。<br>验证阶段大致需要完成以下4个阶段的检验动作：</p><ol><li><p><strong>文件格式验证</strong><br>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。<br><code>主要目的是保证输入的字节流能正确的解析并存储于方法区之内，格式上符合描述一个Java类信息的要求。在这个阶段字节流进入内存中的方法区后续不再操作字节流。</code></p></li><li><p><strong>元数据验证</strong><br>对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范</p></li><li><p><strong>字节码验证</strong><br>通过数据流和控制流分析，确定程序语义是合法且符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机的安全的事件。</p></li><li><p><strong>符号引用验证</strong><br>发生在虚拟机将符号引用转化为直接引用的时候，这个转化发生在解析阶段。对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验。<code>确保解析动作能正常执行</code></p></li></ol></li><li><p><strong>准备</strong></p><p><strong>准备阶段是正式为变量分配内存并设置类初始变量初始值的阶段</strong>，这些变量所使用的内存都将在方法区中进行分配。这个时候进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量。<br>初始值<code>通常情况</code>下是数据类型的零值，如</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;<span class="comment">//在准备阶段过程中初始值为0，而不是123。</span></span><br></pre></td></tr></table></figure><p>  <code>特殊情况</code>：若类字段的属性表中有ConstantValue属性，那么准备阶段value就会初始化为ConstantValue指定的值，如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;<span class="comment">//在准备阶段过程中初始值为123。</span></span><br></pre></td></tr></table></figure></p><ul><li><p><strong>解析</strong><br>  <strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。解析阶段中会涉及到<code>直接引用</code>(直接指向目标的指针、相对偏移量或者是一个能直接定位到目标的句柄)，<code>符号引用</code>(以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可)。<br>  解析动作主要针对<code>类或接口（CONSTANT_Class_info）</code>、<code>字段（CONSTANT_Fieldref_info）</code>、<code>类方法（CONSTANT_Methodref_info）</code>、<code>接口方法（CONSTANT_InterfaceMethodref_info）</code>、<code>方法类型（CONSTANT_MethodType_info）</code>、<code>方法句柄（CONSTANT_MethodHandle_info）</code>、<code>调用点限定符（CONSTANT_InvokeDynamic_info）</code>。</p></li><li><p><strong>初始化</strong><br>  初始化是类加载过程的最后一步。<strong>到这里才真正开始执行类中定义的Java程序代码</strong>。<br>  执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><ul><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</li><li><code>&lt;clinit&gt;()</code>方法与类的构造函数不同，他不需要显示的调用父类构造器，因此虚拟中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是<code>java.long.object</code>。</li><li><strong>初始化过程就是对变量进行赋值及执行静态代码块。</strong></li></ul></li></ul><h2 id="4-类的卸载"><a href="#4-类的卸载" class="headerlink" title="4.类的卸载"></a>4.类的卸载</h2><p>类卸载的触发条件：</p><ul><li>该类所有的实例都已经被GC，也就是在JVM中不存在该类的任何实例</li><li>加载该类的ClassLoader也被GC</li><li>该类的java.lang.Class对象没有在任何地方呗引用，如反射都无法访问该类</li></ul><p>类卸载过程：</p><p>在方法区内的二进制数据会被卸载。</p><p><strong>若卸载后还需要使用，那么就需要去重新加载，然后在Java的虚拟机堆区上重新生成实例。</strong></p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM相关及其拓展（一）-- JVM内存区域</title>
      <link href="/2018/04/10/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/"/>
      <url>/2018/04/10/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/</url>
      <content type="html"><![CDATA[<h1 id="1-JVM内存区域"><a href="#1-JVM内存区域" class="headerlink" title="1. JVM内存区域"></a>1. JVM内存区域</h1><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/jvm_data.png" class="full-image" alt="JVM运行时数据区" title="JVM运行时数据区"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>JVM在执行Java程序的过程中会把管理的内存分为若干个数据局域。</p><ul><li><strong>程序计数器(Program Counter Register)</strong>：一块较小的内存空间，可看作为<strong>当前线程所执行的字节码的行号指示器</strong>。每条线程都需要一个独立的程序计数器，所以为线程私有区域。<code>没有规定任何OutOfMemoryError情况的区域</code>。<code>线程执行Java方法，则记录正在执行的虚拟机字节码指令地址，若为Native方法，则计数器值则为Undefined</code></li><li><strong>Java虚拟机栈(VM Stack)</strong>：虚拟机栈是线程私有的，生命周期与线程相同。描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行时都会创建一个栈帧用于存储局部变量表(存放编译器可知的各种基本数据类型<code>boolean,byte,char,int,long,float,double,short</code>,对象引用和returnAddress类型)，操作树栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。这个区域存在两种异常情况：<code>StackOverflowError：请求栈深度大于虚拟机所允许的深度</code>，<code>OutOfMemoryError：无法申请到足够的内存</code></li><li><strong>本地方法栈(Native Method Stack)</strong>：本地方法栈是线程私有的，虚拟机执行Native方法的服务，和虚拟机栈类似存在两个异常情况。</li><li><strong>Java堆(Heap)</strong>：JVM管理内存中最大的一块。是被所有线程共享的一块区域，在虚拟机启动时创建。唯一目的<code>存放对象实例</code>，几乎所有对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为”GC堆”。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，则抛出OutOfMemoryError异常。</li><li><strong>方法区(Method Area)</strong>：方法区与Java堆一样，是各个线程共享的内存区域。<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。同Java堆一样会抛出OutOfMemoryError异常。</li><li><strong>运行时常量池(Runtime Constant Pool)</strong>：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一个是常量池（存放编译器生成的各种字面量和符号引用）。有一个重要特征是具有动态性，运行期也可以将新的常量放入池中。受到方法区内存的限制，也会抛出OutOfMemoryError异常。</li><li><strong>直接内存(Direct Memory)</strong>：不属于虚拟机运行时数据区的一部分。</li></ul><blockquote><p>拓展：</p><ul><li>程序计数器，虚拟机栈，本地方法栈随着线程生命周期变化，生则生，死则死。</li><li>程序计数器，虚拟机栈，本地方法栈不需要过多考虑内存回收问题，随着方法结束或者线程结束时，内存随着就会回收。</li></ul></blockquote><p>简述：JVM的内存区域主要有以下5类：</p><ol><li>程序计数器：线程私有，当前线程所执行的字节码的行号指示器</li><li>虚拟机栈：线程私有，存放基本数据类型、对象引用和returnAddress类型，会发生内存溢出异常</li><li>本地方法栈：线程私有，为JVM中用到的Native方法服务，会发生内存溢出异常</li><li>Java堆：线程共享，存放对象的实例，也是GC回收管理器的主要区域，会发生内存溢出异常</li><li>方法区：线程共享，存储已被JVM加载的类信息、常亮、静态变量、即时编译后的代码等数据，会发生内存溢出异常</li></ol><h1 id="2-HotSpot虚拟机对象创建，布局以及访问"><a href="#2-HotSpot虚拟机对象创建，布局以及访问" class="headerlink" title="2.HotSpot虚拟机对象创建，布局以及访问"></a>2.HotSpot虚拟机对象创建，布局以及访问</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>   在语言层面上，创建对象只需要一个<code>new</code>关键字。<br>   在虚拟机中，分为以下几步：</p><ul><li><strong>遇到一条new指令时，先去检查指令对应参数是否在常量池中可以定位到一个符号的引用，并且检查指令的参数是否已被加载、解析和初始化过。若无则需要执行相应的类加载过程。</strong></li><li><strong>类加载检查通过后，将为新生对象分配内存。</strong>对象所需的内存大小在类加载完成后便可确定，这块内存由Java堆中划分出来。内存的分配方式由Java堆中内存是否规整决定（<code>已使用的内存和空闲内存是否相互交错</code>）。规整则使用 <strong>指针碰撞</strong>（<code>把指针向空闲空间挪动对象大小的距离</code>），不规整则使用<strong>空闲列表</strong>（<code>虚拟机内维护一个列表用来记录内存块中的可用区域，然后找到一块足够大的空间划分给对象实例</code>）。</li><li><strong>处理并发安全问题。</strong>除了如何分配内存，还需要考虑虚拟机中对象创建是非常频繁的行为，就会涉及到线程安全。解决这个问题有两种方案：<ul><li>对分配内存空间的行为进行同步处理</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<code>本地线程分配缓存(TLAB)</code>。哪个线程需要分配内存就在哪个TLAB上分配，只有TLAB用完了，才同步申请另一块内存。</li></ul></li><li><strong>内存分配完成后，虚拟机将需要分配到的内存空间都初始化为零值（不包括对象头）。</strong>这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>虚拟机对对象进行设置，将<code>类的元数据信息、对象的哈希码、对象的GC分代年龄信息</code>存入对象头中。</strong></li><li><strong>执行init方法初始化。</strong>从虚拟机角度来说，对象已经产生完成，从Java方面来说才刚刚开始，要等到new指令执行并\&lt;init>方法执行后，把对象按照意愿初始化后，真正可用的对象生成完毕。</li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：<code>对象头(Header)</code>、<code>实例数据(Instance Data)</code>和<code>对齐填充(Padding)</code></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><strong>存储自身的运行时数据</strong></p><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>膨胀</td></tr><tr><td>空，不需要记录信息</td><td>11</td><td>GC标记</td></tr><tr><td>偏向线程ID，偏向时间戳，对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table><p><strong>类型指针</strong><br>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象为一个Java数组，则对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>里面是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。在分配策略中，相同宽度的字段总是会被分配在一起。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>并非必然存在的，也没有特别的含义。仅仅起着占位符的作用。当实例数据部分没有对齐时，需要对齐填充来补全。</p><h2 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h2><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式是<code>句柄访问</code>和<code>直接指针访问</code>。</p><ul><li>使用句柄访问：Java堆中会划分出一块内存来作为句柄池，<code>refrence中存储的对象就是对象的句柄地址</code>，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<br>  <strong>句柄访问的最大好处是refrence中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，refrence本身不会有修改。</strong><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/get_object_by_handle.png" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li><li>使用直接指针访问：Java堆对象需要考虑如何放置访问类型数据的相关信息，而<code>refrence中存储的直接就是对象地址</code>。<br>  <strong>直接访问的最大好处是速度快，节省了一次指针定位的时间开销，在Java HotSpot虚拟机中很常用。</strong><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/get_object_direct.png" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式--静态代理模式和动态代理模式原理及实现</title>
      <link href="/2018/04/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/04/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="代理模式（委托模式）"><a href="#代理模式（委托模式）" class="headerlink" title="代理模式（委托模式）"></a>代理模式（委托模式）</h1><blockquote><p><strong>为其他对象提供一种代理以控制对这个对象的访问</strong>。引入<strong>代理对象</strong>来间接访问<strong>目标对象</strong></p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Pattern-Proxy.png" class="full-image" alt="代理模式" title="代理模式"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>代理模式优点：</p><ul><li>职责清晰：真实的角色就是实现实际的业务逻辑，不需关心其他非本职责的事务</li><li>高扩展性：代理类可以在不做任何修改的情况下继续使用</li><li>智能化：动态代理演示</li></ul><p>代理模式缺点：</p><ol><li>在客户端和真实对象之间添加了代理，会造成请求的处理速度变慢</li><li>实现代理模式比较复杂，需要额外的工作</li></ol><p>代理模式的扩展：</p><ol><li><p>普通代理</p><blockquote><p>客户端只能访问代理角色，而不能直接访问真实角色。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//屏蔽了GamePlayer的真实角色访问</span></span><br><span class="line">        GamePlayerProxy gamePlayerProxy = <span class="keyword">new</span> GamePlayerProxy(<span class="string">"wxy"</span>);</span><br><span class="line">        gamePlayerProxy.login(<span class="string">"wxy"</span>,<span class="string">"124"</span>);</span><br><span class="line">        gamePlayerProxy.killBoss();</span><br><span class="line">        gamePlayerProxy.upgrade();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client只是调用了<code>GamePlayerProxy</code>代理角色，而不知道真实角色是谁。<strong>非常适合扩展性要求较高的场景。</strong></p></li><li><p>强制代理</p><blockquote><p>通过真实角色来找到代理角色，否则不能访问。<strong>由真实角色来管理代理角色。不允许直接访问真实角色</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//必须是真实角色的代理对象才可以使用</span></span><br><span class="line">        IGamePlayer gamePlayerProxy = <span class="keyword">new</span> GamePlayer(<span class="string">"wxy"</span>).getProxy();</span><br><span class="line">        <span class="comment">//直接生成代理对象无效</span></span><br><span class="line">        <span class="comment">//GamePlayerProxy gamePlayerProxy = new GamePlayerProxy(new GamePlayer("wzr5"));</span></span><br><span class="line">        gamePlayerProxy.login(<span class="string">"wxy"</span>,<span class="string">"124"</span>);</span><br><span class="line">        gamePlayerProxy.killBoss();</span><br><span class="line">        gamePlayerProxy.upgrade();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理是有个性的</p><blockquote><p>一个类可以实现多个接口，完成不同任务的整合。<strong>代理类不仅可以实现主题接口，也可以实现其他接口完成不同的任务。</strong></p></blockquote></li><li><p><strong>动态代理</strong></p><blockquote><p>不需要<strong>显式实现与目标对象类相同的接口</strong>，将这种实现推迟到程序运行时由JVM实现。</p></blockquote><p>原理：通过Java反射机制的<code>method.invoke()</code>调用动态代理类对象方法，从而自动调用目标对象的方法。</p><p>优点：1. 只需要一个代理类就可以解决创建多个静态代理的问题，避免重复代码。2. 更加灵活</p><p>缺点：1. 效率低 <code>需要通过反射机制，间接调用目标对象方法</code> 2.应用场景局限<code>只能针对接口创建代理类，即只能动态代理实现了接口的类</code></p><p>应用场景：</p><ul><li><p>需要代理对象数量较多的情况下使用</p></li><li><p><code>AOP</code>-面向切面编程</p><blockquote><p>可以通过预编译的方式在运行期动态代理实现程序功能的统一维护，有效降低业务之间的耦合度，提供程序的可用性并提高了开发的效率。开发中主要用在日志收集，性能分析等。</p></blockquote></li></ul><p>使用方法：</p><ol><li><p>声明调用代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayIH</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理实例</span></span><br><span class="line">    T obj ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayIH</span><span class="params">(T _obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = _obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = method.invoke(<span class="keyword">this</span>.obj, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明目标对象类的抽象接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGamePlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String pwd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明目标对象类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class GamePlayer implements IGamePlayer &#123;</span><br><span class="line">    private String name = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public GamePlayer(String _name) &#123;</span><br><span class="line">        this.name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void login(String user, String pwd) &#123;</span><br><span class="line">            System.err.println(&quot;登录名为：&quot; + user + &quot;  用户名为：&quot; + this.name + &quot;登录游戏&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void killBoss() &#123;</span><br><span class="line">           System.err.println(this.name + &quot;打Boss&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void upgrade() &#123;</span><br><span class="line">            System.err.println(this.name + &quot;升级了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过动态代理对象，调用目标方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">"wxy"</span>);</span><br><span class="line">        <span class="comment">//创建调用处理对象</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> GamePlayIH&lt;&gt;(player);</span><br><span class="line">        <span class="comment">//指定产生代理对象的类加载器</span></span><br><span class="line">        ClassLoader cl = player.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//创建动态代理对象</span></span><br><span class="line">        IGamePlayer gamePlayerProxy = (IGamePlayer) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;IGamePlayer.class&#125;, handler);</span><br><span class="line">        <span class="comment">//调用动态代理对象方法</span></span><br><span class="line">        gamePlayerProxy.login(<span class="string">"wxy"</span>, <span class="string">"124"</span>);</span><br><span class="line">        gamePlayerProxy.killBoss();</span><br><span class="line">        gamePlayerProxy.upgrade();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android触摸事件分发</title>
      <link href="/2018/04/09/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
      <url>/2018/04/09/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
      <content type="html"><![CDATA[<h1 id="1-触摸事件的类型"><a href="#1-触摸事件的类型" class="headerlink" title="1.触摸事件的类型"></a>1.触摸事件的类型</h1><p>对应的类是<code>MotionEvent</code>，主要有以下三个类型：</p><ul><li><strong>ACTION_DOWN</strong>：监听用户手指按下的操作，一次按下标志触摸事件的开始。</li><li><strong>ACTION_MOVE</strong>：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。</li><li><strong>ACTION_UP</strong>：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。</li><li><strong>ACTION_CANCEL</strong>：当用户保持按下操作，并把手指移动到了控件外部局域时且父View处理事件触发。</li></ul><h1 id="2-事件传递的三个阶段"><a href="#2-事件传递的三个阶段" class="headerlink" title="2.事件传递的三个阶段"></a>2.事件传递的三个阶段</h1><ul><li><p><strong>分发（Dispatch）</strong>：事件的分发对应着<code>dispatchTouchEvent</code>方法，所有触摸事件由这个方法进行分发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br></pre></td></tr></table></figure><p>在这个方法中，根据当前视图的需求来进行事件的分发给子视图还是直接消费不往下传递，返回<code>true</code>表示事件被消费，不往下传递。返回值为<code>super.dispatchTouchEvent</code>表示继续往下传递。</p></li><li><p><strong>拦截（Intercept）</strong>:事件的拦截对应着<code>onInterceptTouchEvent</code>方法，这个事件只在ViewGroup及其子类中存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br></pre></td></tr></table></figure><p>根据具体的逻辑，返回<code>true</code>表示拦截该事件，不继续把事件分发给子视图，交由自身的<code>onTouchEvent</code>进行处理，返回值为<code>false或super.onInterceptTouchEvent</code>表示继续往下传递。</p></li><li><p><strong>消费（Consume）</strong>：事件的消费对应着<code>onTouchEvent</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br></pre></td></tr></table></figure><p>返回值为<code>true</code>时，表示当前视图可以处理事件，不会向上传递给父视图；返回值为<code>false</code>表示当前视图不处理这个事件，事件传递给父视图的<code>onTouchevent</code>进行处理。</p></li></ul><blockquote><p>在Android系统中，可以处理事件传递的类有以下三种：</p><ul><li><strong>Activity</strong>：包含<code>dispatchTouchEvent</code>，<code>onTouchEvent</code>方法</li><li><strong>ViewGroup</strong>：包含<code>dispatchTouchEvent</code>，<code>onInterceptTouchEvent</code>，<code>onTouchEvent</code></li><li><strong>View</strong>：包含<code>dispatchTouchEvent</code>，<code>onTouchEvent</code>方法</li></ul></blockquote><h1 id="3-View的事件传递机制"><a href="#3-View的事件传递机制" class="headerlink" title="3.View的事件传递机制"></a>3.View的事件传递机制</h1><p>View包括TextView，ImageView等子类，不包括ViewGroup。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Custom TextView with touchevent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTextView</span> <span class="keyword">extends</span> <span class="title">AppCompatTextView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG=<span class="string">"MyTextView"</span>;</span><br><span class="line">    ...</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_DOWN"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_UP"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_MOVE"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_CANCEL"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);②</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_DOWN"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_UP"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_MOVE"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_CANCEL"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);④</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG=<span class="string">"MainActivity"</span>;</span><br><span class="line">    MyTextView mtv;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mtv= (MyTextView) findViewById(R.id.mtv);</span><br><span class="line">        mtv.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                Log.e(TAG,<span class="string">"MyTextView_onclick"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        mtv.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View view, MotionEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                        Log.e(TAG,<span class="string">"MyTextView_onTouch_ACTION_DOWN"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                        Log.e(TAG,<span class="string">"MyTextView_onTouch_ACTION_UP"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                        Log.e(TAG,<span class="string">"MyTextView_onTouch_ACTION_MOVE"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                        Log.e(TAG,<span class="string">"MyTextView_onTouch_ACTION_CANCEL"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;③</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserInteraction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onUserInteraction();</span><br><span class="line">        Log.e(TAG,<span class="string">"onUserInteraction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_DOWN"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_UP"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_MOVE"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_CANCEL"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);①</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_DOWN"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_UP"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_MOVE"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_CANCEL"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>常规输出：(返回的都为默认值)</p><ul><li>点击MyTextView区域</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_DOWN</span><br><span class="line">E/MyTextView: onTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_UP</span><br><span class="line">E/MyTextView: onTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: MyTextView_onclick</span><br></pre></td></tr></table></figure><ul><li>点击MyTextView外部区域</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: onTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_MOVE</span><br><span class="line">E/MainActivity: onTouchEvent_ACTION_MOVE</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: onTouchEvent_ACTION_UP</span><br></pre></td></tr></table></figure></li><li><p>① <strong>Activity的dispatchTouchEvent()</strong><code>return true;或return false;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_MOVE</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_MOVE</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_UP</span><br></pre></td></tr></table></figure><blockquote><p>不会再继续分发触摸事件，及后续控件的触摸事件都不会响应。</p></blockquote></li><li><p>② <strong>View的dispatchTouchEvent()</strong><code>return true;</code>不会调用MyTextView的<code>onClick</code>事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_DOWN</span><br><span class="line">E/MyTextView: onTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_UP</span><br><span class="line">E/MyTextView: onTouchEvent_ACTION_UP</span><br></pre></td></tr></table></figure><p><strong>View的dispatchTouchEvent()</strong><code>return false;</code>只响应MyTextView的<code>ACTION_DOWN</code>事件，后续的处理由MainActivity的<code>onTouchEvent</code>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: onTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_MOVE</span><br><span class="line">E/MainActivity: onTouchEvent_ACTION_MOVE</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: onTouchEvent_ACTION_UP</span><br></pre></td></tr></table></figure></li><li><p>③<strong>Activity中View的onTouch()</strong><code>return true;</code>不往下分发事件及不会调用到<code>onClick</code>事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_DOWN</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_UP</span><br></pre></td></tr></table></figure></li><li><p>④ <strong>View的onTouchEvent()</strong><code>return true;</code>不触发<code>onClick</code>事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_DOWN</span><br><span class="line">E/MyTextView: onTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_UP</span><br><span class="line">E/MyTextView: onTouchEvent_ACTION_UP</span><br></pre></td></tr></table></figure><p><strong>View的onTouchEvent()</strong><code>return false;</code>只响应MyTextView的<code>ACTION_DOWN</code>事件，后续的处理由MainActivity的<code>onTouchEvent</code>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_DOWN</span><br><span class="line">E/MyTextView: onTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: onTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: onTouchEvent_ACTION_UP</span><br></pre></td></tr></table></figure></li></ul><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/Activity-View dispatch.png" class="full-image" alt="View的事件传递" title="View的事件传递"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>总结：</p><ul><li><p>触摸事件传递从dispatchTouchEvent开始，在不修改默认返回的数值时，事件会按照嵌套层次由外向内传递，到达最内层的View时，就由它的onTouchEvent处理。</p></li><li><p>若事件在传递过程中，返回参数设为true，则导致事件提前被消费，内层View无法处理事件</p></li><li><p>View的事件触发顺序为先执行onTouch方法，最后执行onClick方法。onTouch返回false，则会响应onClick，否则事件不会继续传递。</p></li><li><p>View的点击事件流程：</p><p><strong>Activity.dispatchTouchEvent() -&gt; View.dispatchTouchEvent()-&gt;View.onTouch()-&gt;View.onTouchEvent()-&gt;View.onClick()</strong></p></li></ul></blockquote><h1 id="4-ViewGroup事件传递机制"><a href="#4-ViewGroup事件传递机制" class="headerlink" title="4.ViewGroup事件传递机制"></a>4.ViewGroup事件传递机制</h1><p>ViewGroup作为View的容器存在，ViewGroup包括LinearLayout，RelativeLayout等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Custom ViewGroup with touchEvent</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRelativeLayout</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG=<span class="string">"MyRelativeLayout"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRelativeLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRelativeLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_DOWN"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_UP"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_MOVE"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                Log.e(TAG,<span class="string">"dispatchTouchEvent_ACTION_CANCEL"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                Log.e(TAG,<span class="string">"onInterceptTouchEvent_ACTION_DOWN"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                Log.e(TAG,<span class="string">"onInterceptTouchEvent_ACTION_UP"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                Log.e(TAG,<span class="string">"onInterceptTouchEvent_ACTION_MOVE"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                Log.e(TAG,<span class="string">"onInterceptTouchEvent_ACTION_CANCEL"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(event);⑥</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_DOWN"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_UP"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_MOVE"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                Log.e(TAG,<span class="string">"onTouchEvent_ACTION_CANCEL"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>常规模式（全为默认值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_DOWN</span><br><span class="line">E/MyTextView: onTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MyRelativeLayout: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MyRelativeLayout: onInterceptTouchEvent_ACTION_UP</span><br><span class="line">E/MyTextView: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: MyTextView_onTouch_ACTION_UP</span><br><span class="line">E/MyTextView: onTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: MyTextView_onclick</span><br></pre></td></tr></table></figure></li><li><p>ViewGroup.onInterceptTouchEvent()返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWN</span><br><span class="line">E/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: MyRelativeLayoutonTouch_ACTION_DOWN</span><br><span class="line">E/MyRelativeLayout: onTouchEvent_ACTION_DOWN</span><br><span class="line">E/MainActivity: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MyRelativeLayout: dispatchTouchEvent_ACTION_UP</span><br><span class="line">E/MainActivity: MyRelativeLayout_onTouch_ACTION_UP</span><br><span class="line">E/MyRelativeLayout: onTouchEvent_ACTION_UP</span><br></pre></td></tr></table></figure></li></ul><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/Activity-ViewGroup-View dispatch.png" class="full-image" alt="View的事件传递" title="View的事件传递"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>总结:</p><ul><li><p>对于一个包裹在ViewGroup中的View，点击发生的触摸流程为：</p><p><strong>Activity.dispatchTouchEvent()-&gt;ViewGroup.dispatchTouchEvent()-&gt;ViewGroup.onInterceptTouchEvent()-&gt;View.dispatchTouchEvent()-&gt;View.onTouch()-&gt;View.onTouchEvent()-&gt;View.onClick()</strong></p></li><li><p>dispatchTouchEvent事件分发逻辑如下：</p><p>如果 return true，事件会分发给当前 View 并由 dispatchTouchEvent 方法进行消费，同时事件会停止向下传递；<br>如果 return false，事件分发分为两种情况：<br>1.如果当前 View 获取的事件直接来自 Activity，则会将事件返回给 Activity 的 onTouchEvent 进行消费；<br>2.如果当前 View 获取的事件来自外层父控件，则会将事件返回给父 View 的  onTouchEvent 进行消费。</p></li><li><p>onInterceptTouchEvent 的事件拦截逻辑如下：<br> 如果 onInterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理；<br>  如果 onInterceptTouchEvent 返回 false或super.onInterceptTouchEvent(ev)，则表示将事件放行，当前 View 上的事件会被传递到子 View 上，再由子 View 的 dispatchTouchEvent 来开始这个事件的分发；</p></li><li>onTouchEvent 的事件响应逻辑如下：<br>   如果事件传递到当前 View 的 onTouchEvent 方法，而该方法返回了 false，那么这个事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，如果传递到上面的 onTouchEvent 也返回 false，这个事件就会“消失”，而且接收不到下一次事件。<br>   如果返回了 true 则会接收并消费该事件。<br>   如果返回 super.onTouchEvent(ev) 默认处理事件的逻辑和返回 false 时相同。</li></ul></blockquote><h1 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5.源码分析"></a>5.源码分析</h1><p>//TODO</p><h1 id="6-实例分析"><a href="#6-实例分析" class="headerlink" title="6.实例分析"></a>6.实例分析</h1>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>热修复基本原理</title>
      <link href="/2018/04/07/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/04/07/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gradle操作小记</title>
      <link href="/2018/04/03/Gradle%E6%93%8D%E4%BD%9C%E5%B0%8F%E8%AE%B0/"/>
      <url>/2018/04/03/Gradle%E6%93%8D%E4%BD%9C%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote><p>显示所有依赖关系解析树<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/gradlew app:dependencies</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>生成项目<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/gradlew clean assembleEnvTestReleaseChannels -PchannelList=default</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>清理项目</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>日常细节记录</title>
      <link href="/2018/04/03/%E6%97%A5%E5%B8%B8%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/04/03/%E6%97%A5%E5%B8%B8%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<ol><li>强引用置为null时，不会立即回收对象，帮助回收器加快回收。但是会帮助GC 等到下次回收周期时即会回收</li><li>死锁的四个必要条件：互斥，占有且等待，不可抢占，循环等待</li><li>CAS(原子操作)是乐观锁用到的主要机制，乐观锁是不用加锁去执行操作，如果产生冲突则失败重试，直到成功为止，也叫做“自旋”。与乐观锁相对应的是悲观锁，synchronized就是悲观锁，也叫“独占锁”需要加锁进行操作，并且加锁代码块中的只能有一个线程进行操作。 </li><li>点击App图标，系统最开始执行的是ActivityThread的main()方法</li><li>应用的启动方式：<ul><li>冷启动：启动应用时，后台没有该应用的进程。系统创建一个新的进程来进行重新分配。</li><li>热启动：启动应用时，后台已有该应用的进程。</li></ul></li><li>Application的生命周期：<code>onCreate()//应用开始时执行-&gt;onLowMemory()//内存低时执行-&gt;onTrimMemory()//关闭应用时执行  onTerminate()//在真机上不会调用</code> </li><li>进程相关： <code>优先级最低的进程首先被杀死、进程的等级会因为其他进程的依赖而提高一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低</code> 按重要性分类：<ul><li>前台进程：进程持有一个正在与用户交互的Activity或者和交互Activity绑定的Service，前台运行的Service（执行<code>startForeground()</code>）,执行<code>onReceive()</code>的BroadcastReceiver</li><li>可见进程：进程持有一个被用户可见但没有显示在最前端的Activity(调用到了<code>onPause()</code>)或者和可见Activity绑定的Service</li><li>服务进程：进程持有一个<code>startService()</code>启动的Service进程，例如播放音乐，下载文件等Service</li><li>后台进程：进程持有一个用户不可见的Activity(调用到<code>onStop()</code>没有到<code>onDestroy()</code>)，进程被存放在一个LRU列表中，即很长时间没用的Activity会被优先杀死</li><li>空进程：进程不包含任何活跃的应用组件，唯一的作用是<code>为了缓存需要，缩短下次启动的时间</code></li></ul></li><li>统计应用启动时间：<code>adb shell am start -W [packageName]/[packageName.MainActivity]</code></li><li><code>volatile</code>作用是<code>可见性</code>(当一个线程修改了某一个全局变量的值，其他线程能否知道这个修改)，<code>有序性</code>（禁止指令重排优化,防止代码执行指令被重新排序）。<code>volatile</code>并不能保证线程安全即保证不了线程间操作的原子性。</li><li>SharedPreference中<code>apply</code>和<code>commit</code>方法的区别：<code>commit</code>同步保存更改，<code>apply</code>异步保存到磁盘，原子提交，性能较高，但不保存结果。SharedPreference不支持多线程操作，<code>MODE_MULTI_PROCESS</code>这个标记位并没有实际作用。可以利用<code>ContentProvider</code>去实现多进程，<em>方案后续会有介绍</em>。</li><li>MD5不是加密算法，是一种散列算法。加密算法一般是对称加密算法</li><li>使用ADB启动Activity：<code>adb shell am start -n 包名/需启动Activity路径</code></li><li>Fragment中<code>replace</code>与<code>add</code>区别：<ul><li><code>replcae</code>：把容器内所有内容进行替换，都需要重新走一遍fragment的生命周期</li><li><code>add</code>：添加不会清空容器内的内容。</li></ul></li><li>在三星手机上，进行原生分享文件时需要设置mimeType</li><li><code>invalidate()</code>、<code>postInvalidate()</code>和<code>requestLayout()</code>的区别：<ul><li><code>invalidate()</code>：当子View调用invalidate方法时，会给View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递至ViewRootImpl中，最终触发performTraversals方法，进行View的重绘（即调用onDraw方法）。<strong>该方法只能在UI线程中调用</strong></li><li><code>postInvalidate()</code>：与invalidate作用一致，都是使View进行重绘，<strong>该方法是在非UI线程中调用的</strong>。内部主要实现是提供一个Handler实现，然后直接调用了invalidate方法，继续执行重绘流程。</li><li><code>requestLayout()</code>：调用了这个方法会重新执行View的绘制流程，即重新执行测量(<code>onMeasure</code>)，布局(<code>onLayout</code>)，绘制(<code>onDraw</code>)方法。<strong>利用责任链模式-不断向上传递该事件，直到找到能处理该事件的上级</strong>。</li></ul></li><li>Bitmap所占用的内存 = 图片长度 x 图片宽度 x （屏幕分辨率÷图片资源目录分辨率）²×一个像素点占用的字节数</li><li>HashMap扩容机制 在1.8之前只要达到负载就进行扩容，1.8之后是防止Hash冲突才进行扩容，如果不冲突不会触发扩容。</li><li>dp,px,sp相关概念：</li></ol>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-XII</title>
      <link href="/2018/04/01/Android-Study-Plan-XII/"/>
      <url>/2018/04/01/Android-Study-Plan-XII/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><h2 id="从源码的角度描述下Activity的启动过程"><a href="#从源码的角度描述下Activity的启动过程" class="headerlink" title="从源码的角度描述下Activity的启动过程"></a>从源码的角度描述下Activity的启动过程</h2>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Activity生命周期相关</title>
      <link href="/2018/04/01/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/04/01/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/activity_lifecycle.jpeg" class="full-image" alt="Activity生命周期" title="Activity生命周期"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/activity_lifecycle_2.jpg" class="full-image" alt="Activity生命周期" title="Activity简便生命周期"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><p>回调方法介绍</p><ul><li><strong>onCreate()</strong>：Activity创建时调用，用于初始化工作，例如加载xml布局文件等</li><li><strong>onStart()</strong>：Activity由不可见变为后台可见状态，不过还无法交互</li><li><strong>onResume()</strong>：用户从后台或者跳转后的Activity回到原Activity时调用，让Activity回归前台</li><li><strong>onPause()</strong>：启动新Activity时，原Activity会调用该方法并调用onStop方法<code>不可在此回调中实现耗时方法,会影响新Acticity的启动</code></li><li><strong>onStop()</strong>：Activity由可见变为完全不可见，若有对话框则依然可见，<code>在onStop和onPause过程中的Activity优先级较低，容易被回收</code></li><li><strong>onDestroy()</strong>：Activity即将被销毁，可在此做资源回收以及对象销毁的工作</li><li><strong>onRestart()</strong>：Activity由不可见变为完全可见过程调用，当Activity从onStop过程中回到前台可见时调用，并随后调用onStart方法。</li></ul><p>​     </p><ul><li><strong>onPostCreate()</strong>：在onCreate执行完毕之后的回调</li><li><strong>onUserInteraction()</strong>：所有在Activity上执行的触摸事件都会优先调用该方法</li><li><strong>onUserLeaveHint()</strong>：用户主动离开Activity会调用该方法，例如按Home键或者进入后台任务，系统事件导致的切换不会响应</li><li><strong>onContentChanged()</strong>：当Activity调用setContentView方法结束后会调用该方法</li><li><strong>onAttachedToWindow()</strong>：可以再方法中 进行Window窗口尺寸的修改</li></ul></li></ul><ul><li><p>Activity几种状态下的生命周期变化</p><ul><li>启动Activity:<code>onCreate()-&gt;onStart()-&gt;onResume()</code></li><li>Activity被覆盖或者锁屏时：<code>onPause()</code></li><li>Activity回到运行状态时:<code>onResume()</code></li><li>当前Activity跳转到新的Activity或者Home键回到桌面时:<code>onPause()-&gt;onStop()</code></li><li>后退回到上一Activity时：<code>onRestart()-&gt;onStart()-&gt;onResume()</code></li><li>退出当前Activity：<code>onPause()-&gt;onStop()-&gt;onDestroy()</code></li><li>下拉状态栏 对生命周期没有影响(捕捉下拉状态栏事件，使用<code>onWindowFouceChanged()</code>)</li><li>弹出Dialog：自己创造的Dialog不会有周期变化，其他创造的Dialog会执行<code>onPause()</code></li><li><strong>当发生Activity切换时，总是切换前的Activity先调用onPause方法，后执行其他方法。</strong></li><li>新Activity主题为透明时，旧Activity不会走<code>onStop()</code>。</li></ul></li><li><p>Activity被回收或者改变屏幕方向时信息的保存和恢复</p><ul><li><code>onSaveInstanceState()</code>保存信息<ul><li>在被覆盖或者位于后台运行时，因为内存不足被回收时调用</li><li>屏幕发生旋转时会被调用</li><li>当前Activity发生跳转或者Home键响应导致应用位于后台</li><li>非主动销毁才会被调用</li><li>利用<code>onSaveInstanceState()</code>保存数据，执行于<code>onPause()，onStop()</code>之前</li></ul></li><li><code>onRestoreInstaceState()</code>恢复信息<ul><li>在Activity被回收时，用户重新回到Activity</li><li>屏幕旋转Activity重建时</li><li>利用<code>onRestoreInstanceState()</code>恢复数据，执行于<code>onStart()</code> 之后</li></ul></li></ul></li><li><p>Activity任务栈</p><ul><li>程序创建时就会创建一个Activity任务栈，存储当前程序的Activity，当前程序所有的Activity都是一个任务栈</li><li>任务栈是Activity的集合，只有位于栈顶的Activity可以和用户交互</li><li>任务栈可以移动到后台并保留了Activity的状态</li><li>退出应用程序时，要清理任务栈所有Activity，程序退出</li></ul></li><li><p>Activity LaunchMode</p><ul><li><a href="/2018/03/18/Android-Study-Plan-III/" title="Android Study Plan III - Activty">Android Study Plan III - Activty</a></li></ul></li><li><p>Activity启动过程</p><ul><li>从Context的startActivity，调用ContextImpl的startActivity，内部实现由Instrumentation尝试启动Activity，这是一个跨进程的过程。继续调用AMS(ActivityManagerService)的startActivity方法，当校验完Activity的合法性后，利用ApplicationThread回调到我们自己的进程，这也是一个跨进程的过程，ApplicationThread就是一个Binder。回调逻辑在Binder线程池中完成，所以需要通过Handler将其切回UI线程，第一个消息时LAUNCH_ACTIVITY，对应着handleLaunchActivity，在这个方法里面完成Activity的创建和启动。接着在onResume中，Activity的内容渲染在Window上面，然后开始绘制流程。</li><li><a href="https://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener">Activity启动流程分析</a></li></ul></li><li><p>Activty行为标志和属性</p><ul><li><p><strong>亲和性</strong><code>默认情况下，应用程序中的所有Activity，都有一个对于其他Activity的亲和性，这是一个对于同一个任务中的其他Activity的优先权，然后通过&lt;activity&gt;元素的taskAffinity属性可以分别为每一个activity设置亲和性。</code>不同应用程序定义的activity可以共享一个亲和性，或者同一个应用程序定义的activity可以指定不同的亲和性。亲和性在两种情况下发挥作用：</p><ul><li><p><strong>启动一个包含<code>FLAG_ACTIVITY_NEW_TASK</code>标志的activity</strong></p><p>新的Activity默认情况下，被加载进调用<code>startActivity()</code>方法的activity对象所在的任务中，被压入和调试者同一个栈中，但是如果传递了<code>FLAG_ACTIVITY_NEW_TASK</code>标志，系统会创建一个不同的任务栈容纳该Activity。若已经存在一个和该Activity亲和性相同的任务栈，该activity就会被加载进去，没有则重新创建任务栈。</p></li><li><p><strong>activity的<code>allowTaskReparenting属性设置为true</code></strong></p><p>该activity可以从启动时所在的任务移动到另一个出现在前台的任务。举个栗子：</p><ul><li>有一个activity负责展示数据，他作为一个数据展示应用程序的一部分，它和该应用中的其他activity有同样的亲和性，然后一个外部app调起了该activity，则该activity和外部app具有亲和性即在同一任务栈中。但是，当数据展示应用运行时，该activity会重新分配回到数据展示应用中。</li></ul></li></ul></li><li><p><strong>清理栈</strong><code>用户离开一个任务很长时间，系统将清除除了根Activity之外的所有Activity，当用户重新回到应用中时，像是用户离开了它，只剩最初的Activity。</code>考虑到过了一段时间用户可能会放弃之前做的所有事情，回到任务去做新的事情。有一些相关属性可以控制和修改机制：</p><ul><li><p><strong>android:alwaysRetainTaskState</strong></p><p>标记应用的task是否保持原来的状态，<code>true</code>总是保持,<code>false</code>则不能保证。若为true，则系统会保留所有的activity，例如在browser应用，可以替用户保留很多的tab。</p></li><li><p><strong>android:clearTaskOnLaunch</strong></p><p>标记是否从task清除除根activity之外的所有activity，<code>true</code>表示清除，<code>false</code>表示不清除。若为true，每次用户重启这个应用时，都只会看到根activity，即无论离开多久用户重新回归都只能看到根activity。特例：<code>在我们应用中引用了其他应用的activity，且activity设置了allowTaskReparenting为true，则他们会被重新宿主到有共同affinity的task中。</code></p></li><li><p><strong>android:finishOnTaskLaunch</strong></p><p>作用与clearTaskOnLaunch类似，不过是作用于单个Activity，而非整个任务。可以设置任何Actiivty离开，即用户返回应用时，设置为true的Actiivty会消失。</p><p>特例：如果这个特性和<code>allowTaskReparenting</code>都为true，则该属性优先，Activity的affinity忽略。这个Activity不会重新宿主，但会被销毁。</p></li><li><p><strong>其他方案</strong></p><p>启动一个包含<code>FLAG_ACTIVITY_CLEAR_TOP</code>标志的Activity，则会清理所有栈中位于该实例之上的Activity。</p><p>​</p></li></ul></li></ul></li><li><p>查看当前任务栈方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activities</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Activity,Window,View的关联与理解</title>
      <link href="/2018/04/01/Activity-Window-View%E7%9A%84%E5%85%B3%E8%81%94%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
      <url>/2018/04/01/Activity-Window-View%E7%9A%84%E5%85%B3%E8%81%94%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="Activity-Window-View相关"><a href="#Activity-Window-View相关" class="headerlink" title="Activity,Window,View相关"></a>Activity,Window,View相关</h1><h2 id="1-什么是Activity-Window-View以及职能简介"><a href="#1-什么是Activity-Window-View以及职能简介" class="headerlink" title="1. 什么是Activity,Window,View以及职能简介"></a>1. 什么是Activity,Window,View以及职能简介</h2><ul><li>Activity：不负责视图控制，只是控制生命周期和处理事件，真正控制视图的是Window，一个Activity包含一个Window，Window真正代表一个窗口。<code>Activity是一个控制器，控制视图的添加与显示以及通过回调方法来进行Window与View的交互。</code></li><li>Window：Window是视图的承载器，内部持有一个DecorView，DecorView才是view的根布局，Window为抽象类，实际是Activity中的其子类PhoneWindow，其中有个内部类DecorView，通过创建DecorView来加载<code>R.layout.*</code>，Window通过WindowManager加载DecorView，并将DecorView和ViewRoot关联，进行视图控制与交互。</li><li>View：DecorView继承自FrameLayout,DecorView作为顶级View，一般其内部包含一个竖直方向的LinearLayout，里面包含ViewStub，标题栏（titleView），内容栏（contentView）。Activity通过<code>setContentView()</code>将布局文件加载进内容栏中。</li><li>ViewRoot：ViewRoot的实现类是ViewRootImpl，是WindowService和DecorView之间的纽带。ViewRoot不属于View节点，和View之间没有直接联系，不过实现了ViewParent接口。<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/activity_window_view.png" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></li></ul><h2 id="2-Activity，Window，View的关系"><a href="#2-Activity，Window，View的关系" class="headerlink" title="2. Activity，Window，View的关系"></a>2. Activity，Window，View的关系</h2><blockquote><p>基本关系是：Activity中展示元素通过Window实现，Window可以理解为一个容器，里面装载着一个个的View，来执行显示工作。</p></blockquote><h2 id="3-Activity如何和Window，View关联（附源码）"><a href="#3-Activity如何和Window，View关联（附源码）" class="headerlink" title="3. Activity如何和Window，View关联（附源码）"></a>3. Activity如何和Window，View关联（附源码）</h2><blockquote><p>Activity和Window关联</p></blockquote><blockquote></blockquote><h2 id="4-View和Window有什么联系"><a href="#4-View和Window有什么联系" class="headerlink" title="4. View和Window有什么联系"></a>4. View和Window有什么联系</h2>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础排序算法介绍</title>
      <link href="/2018/03/20/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/03/20/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="基础排序算法介绍"><a href="#基础排序算法介绍" class="headerlink" title="基础排序算法介绍"></a>基础排序算法介绍</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点:"></a>知识点:</h2><ul><li>排序算法稳定性的定义：简单的介绍就是排序前相等的数据先后顺序在排序后的先后顺序位置相同</li><li><p>基本交换算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>时间复杂度：执行算法所需要的计算工作量 $ O(1) $ 意味没有循环即只执行单条语句 $ O(n) $ 执行没有嵌套的循环 $ O(n^2) $ 双重嵌套循环</p></li><li>空间复杂度：算法在运行工程中临时占用存储空间的量度</li></ul><table><thead><tr><th>算法</th><th style="text-align:center">平均时间</th><th style="text-align:center">最好</th><th style="text-align:center">最差</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(n) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">稳定</td></tr><tr><td>直接插入排序</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(n) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">稳定</td></tr><tr><td>折半插入排序</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">稳定</td></tr><tr><td>希尔排序</td><td style="text-align:center">$ O(nlogn) $ - $ O(n^2) $</td><td style="text-align:center">$ O(n^1.3) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">不稳定</td></tr><tr><td>选择排序</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">不稳定</td></tr><tr><td>快速排序</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(n^2) $</td><td style="text-align:center">$ O(nlogn) $ - $ O(n^2) $</td><td style="text-align:center">不稳定</td></tr><tr><td>归并排序</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(n) $</td><td style="text-align:center">稳定</td></tr><tr><td>堆排序</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">$ O(1) $</td><td style="text-align:center">不稳定</td></tr></tbody></table><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>在要排序的一组数中，对当前范围内还未排列好的数据由上而下进行比较，即每当相邻的数与要求的排序方式相反时将数据进行互换<br>改进版的写法就是利用标记法减少循环次数</p></blockquote><blockquote><p>基本写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; size - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</span><br><span class="line">                    swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>改进写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">advancedBubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.length;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//设置标记位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; size - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>)<span class="comment">//没有发生数据交换则意味着排序已经结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>再一次遍历过程中找到最小值放在排序数据中的首位，每次寻找剩余中最小的直到结束为止。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><blockquote><p>按照顺序选定元素从后往前找，插入一个顺序数列中即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> size = array.length;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> temp = array[i];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; array[j]; j--) &#123;<span class="comment">//从该元素所在位置 向前移动 直到该元素位于 递增顺序</span></span><br><span class="line">               array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">               array[j - <span class="number">1</span>] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><blockquote><p>再往前寻找位置的过程中利用二分法寻找位置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertBinarySort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[i - <span class="number">1</span>]) &#123;<span class="comment">//前比后大</span></span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                <span class="keyword">int</span> low = <span class="number">0</span>, high = i - <span class="number">1</span>, mid;</span><br><span class="line">                <span class="keyword">while</span> (low &lt;= high) &#123;<span class="comment">//直到相交或者相反</span></span><br><span class="line">                    mid = (low + high) / <span class="number">2</span>;<span class="comment">//折中取点</span></span><br><span class="line">                    <span class="keyword">if</span> (temp &lt; array[mid]) &#123;<span class="comment">//小于中点则位于中点左侧</span></span><br><span class="line">                        high = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        low = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; low; j--) &#123;</span><br><span class="line">                    array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                array[low] = temp;<span class="comment">//低点使用temp</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>先取<code>d</code>为间隔，将原始数组分为d个序列，将间隔的数组放在一个子序列利用插入排序法进行排序 然后缩小间隔<code>d</code> 重复上述操作，知道<code>d</code>为1时，则排序完成</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = size / <span class="number">2</span>; d &gt; <span class="number">0</span>; d /= <span class="number">2</span>) &#123;<span class="comment">//设置步长</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i += d) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= d &amp;&amp; temp &lt; array[j - d]; j -= d) &#123;</span><br><span class="line">                    array[j] = array[j - d];</span><br><span class="line">                &#125;</span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><blockquote><p>讲一组元素进行桶分配，按照每位数的大小进行排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = array.length;</span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];<span class="comment">//数组中的最大数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">            max = array[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">0</span>;<span class="comment">//最大位数</span></span><br><span class="line">    <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        time++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//索引</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;<span class="comment">//位值</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;<span class="comment">//第几位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][size];</span><br><span class="line">    <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m &lt;= time) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> arr : array) &#123;</span><br><span class="line">            <span class="keyword">int</span> lsd = (arr / n) % <span class="number">10</span>;</span><br><span class="line">            temp[lsd][order[lsd]] = arr;</span><br><span class="line">            order[lsd]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (order[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; order[i]; j++) &#123;</span><br><span class="line">                    array[k] = temp[i][j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            order[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n *= <span class="number">10</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>通过排序将待排序记录分成两部分，其中一部分记录的关键字均比另一部分小，然后分别对这两部分进行排序，直到整个序列有序。<strong>快速排序在元素很少时，效率很低</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p=getMiddle(arr,l,r);<span class="comment">//取出中点</span></span><br><span class="line">    quickSort(arr,l,p-<span class="number">1</span>);<span class="comment">//对左侧进行排序</span></span><br><span class="line">    quickSort(arr,p+<span class="number">1</span>,r);<span class="comment">//对右侧进行排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMiddle</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[l];<span class="comment">//定义左侧为基点</span></span><br><span class="line">        <span class="keyword">int</span> middle = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = middle + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; temp) &#123;</span><br><span class="line">                swap(arr, middle + <span class="number">1</span>, i);</span><br><span class="line">                middle++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, l, middle);</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>把待排序序列分成若干个有序子序列，然后再把子序列合并成一个有序序列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        mergeSort(arr, l, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        merge(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//左指针</span></span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="comment">//右指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//把较小的数 移动到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            temp[index++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把左边剩余的数移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[index++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把右边剩余的数移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[index++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到新的数据 覆盖原有部分</span></span><br><span class="line">    System.arraycopy(temp, <span class="number">0</span>, arr, low, temp.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>将数组构成大堆二叉树，即父节点比子节点大的二叉树，然后每次将根节点放在最后一位，循环遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//预先构建一次大堆二叉树</span></span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        maxHeap(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        maxHeap(arr, length, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建大堆二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> length, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxIndex = node;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; length &amp;&amp; arr[left] &gt; arr[maxIndex]) &#123;</span><br><span class="line">        maxIndex = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; length &amp;&amp; arr[right] &gt; arr[maxIndex]) &#123;</span><br><span class="line">        maxIndex = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是父节点最大，则找到最大的子节点进行调换</span></span><br><span class="line">    <span class="keyword">if</span> (maxIndex != node) &#123;</span><br><span class="line">        swap(arr, node, maxIndex);</span><br><span class="line">        maxHeap(arr, length, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android-Study-Plan-XI</title>
      <link href="/2018/03/19/Android-Study-Plan-XI/"/>
      <url>/2018/03/19/Android-Study-Plan-XI/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：Okhttp和Retrofit</p><p>1、介绍这两个框架的作用和联系<br>PS：这个问题几乎Android面试必问</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Glide源码解析要点</title>
      <link href="/2018/03/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%A6%81%E7%82%B9/"/>
      <url>/2018/03/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%A6%81%E7%82%B9/</url>
      <content type="html"><![CDATA[<blockquote><p>该源码解析是基于最新的Glide 4.6.0进行的</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Study Plan IX - ClassLoaderß</title>
      <link href="/2018/03/18/Android-Study-Plan-IX/"/>
      <url>/2018/03/18/Android-Study-Plan-IX/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：Android中的ClassLoader<br>1、Android中有哪几种ClassLoader？它们的作用和区别是什么？<br>2、简述ClassLoader的双亲委托模型<br>3、简述双亲委托模型在热修复领域的应用</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="1-Android中有哪几种ClassLoader？它们的作用和区别是什么？"><a href="#1-Android中有哪几种ClassLoader？它们的作用和区别是什么？" class="headerlink" title="1.Android中有哪几种ClassLoader？它们的作用和区别是什么？"></a>1.Android中有哪几种ClassLoader？它们的作用和区别是什么？</h2><blockquote><p>在Android程序中，.dex文件就是一群.class文件。</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/android_classloader.png" class="full-image" alt="alt" title="SingleTop"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><p><strong>BootClassLoader</strong></p><blockquote><p>BootClassLodaer是ClassLoader内部实现类，是只能包内可见，我们是无法调用的。在无父构造器传入的情况下，默认构建一个PathClassLoader且父构造器为BootClassLoader</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader <span class="title">createSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String classPath = System.getProperty(<span class="string">"java.class.path"</span>, <span class="string">"."</span>);</span><br><span class="line">        String librarySearchPath = System.getProperty(<span class="string">"java.library.path"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>URLClassLoader</strong></p><blockquote><p>只能用于加载jar文件，但是在dalvik（Android5.0之前的虚拟机）无法直接识别jar，所以Android中无法使用这个加载器。</p></blockquote></li><li><p><strong>BaseDexClassLoader</strong></p><blockquote><p>用于加载各种dex中的类</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主要构造函数介绍：</p><ul><li>dexPath：指<code>目标类所在的apk、dex或jar文件的路径，也可以是SD卡的路径</code>，类加载器从该路径加载目标类。如果包含多个路径，路径之间必须用特定的分隔符去分隔，特定的分隔符从<code>System.getProperty(&quot;path.separtor&quot;)</code>获取（默认分割符为”:”）。最终将路径上的文件ODEX优化到optimizedDirectory，然后进行加载。</li><li>optimizedDirectory：解压出的dex文件路径，这个路径必须为内部路径，一般情况下的路径为<code>/data/data/&lt;Package_Name&gt;/</code></li><li>librarySearchPath：存放目标类中使用的native文件库，也以”:”分割</li><li>parent：父加载器，在Android中以<code>context.getClassLoader</code>作为父加载器。</li></ul></blockquote></li><li><p><strong>DexClassLoader</strong></p><blockquote><p>继承自BaseDexClassLoader，支持加载包含classes.dex的jar、apk，zip文件，可以是SD卡的路径。是实现热修复的关键。<strong>注意不要把优化后的文件放在外部存储，可能导致注入攻击。</strong></p></blockquote></li><li><p><strong>PathClassLoader</strong></p><blockquote><p>用来加载Android系统类和应用程序的类，<strong>在dalvik上只能加载已安装apk的dex(/data/app目录)，在ART虚拟机上则没有这个限制</strong>。</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在PathDexClassLoader的构造方法中optimizedDirectory为null，因为默认参数为<code>/data/dalvik-cache</code>目录。</p></blockquote></li><li><p><strong>InMemoryDexClassLoader</strong></p><blockquote><p>用于加载内存中的dex文件(在API26中添加)</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InMemoryDexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">InMemoryDexClassLoader</span><span class="params">(ByteBuffer[] dexBuffers, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InMemoryDexClassLoader</span><span class="params">(ByteBuffer dexBuffer, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>DelegateClassLoader</strong></p><blockquote><p>是一个先查找在委托的类加载器(API27添加)，按照以下顺序实现加载：</p><ol><li>首先判断该类是否被加载</li><li>搜索此类的类加载器是否加载过这个类</li><li>使用当前加载器去尝试加载类</li><li>最后委托给父加载器加载</li></ol></blockquote></li></ul><h2 id="2-简述ClassLoader的双亲委托模型"><a href="#2-简述ClassLoader的双亲委托模型" class="headerlink" title="2.简述ClassLoader的双亲委托模型"></a>2.简述ClassLoader的双亲委托模型</h2><a href="/2018/04/16/JVM相关及其拓展-三/" title="JVM相关及其拓展(三) -- 虚拟机类加载器">JVM相关及其拓展(三) -- 虚拟机类加载器</a><h2 id="3-简述双亲委托模型在热修复领域的应用"><a href="#3-简述双亲委托模型在热修复领域的应用" class="headerlink" title="3.简述双亲委托模型在热修复领域的应用"></a>3.简述双亲委托模型在热修复领域的应用</h2><p>一个ClassLoader文件可以有多少Dex文件，每个Dex文件是一个Element，多个Dex文件组成一个有序数组DexElements，当找类的时候会按照顺序遍历Dex文件，然后在当前遍历的Dex文件中找出类。由于双亲委托模型机制的存在，只要找到类就会停止检索并返回，找不到就会查询下一个Dex，所以只要我们先找到并加载修复Bug的文件，则有bug的Dex文件不会被加载。</p><p>注意点：假设有个A类，引用了B类。发布过程中发现B类有bug，若想要发个新的B类，需要阻止A加上这个类标志CLASS_ISPREVERIFIED。</p><h2 id="4-基本热修复代码实现"><a href="#4-基本热修复代码实现" class="headerlink" title="4. 基本热修复代码实现"></a>4. 基本热修复代码实现</h2>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Study Plan VIII - Java引用类型</title>
      <link href="/2018/03/18/Android-Study-Plan-VIII/"/>
      <url>/2018/03/18/Android-Study-Plan-VIII/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：Java基础知识学习<br>1、Java中有哪几种引用？它们的含义和区别是什么？<br>2、请用Java实现一个线程安全且高效的单例模式。</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="1-Java中有哪几种引用？它们的含义和区别是什么？"><a href="#1-Java中有哪几种引用？它们的含义和区别是什么？" class="headerlink" title="1. Java中有哪几种引用？它们的含义和区别是什么？"></a>1. Java中有哪几种引用？它们的含义和区别是什么？</h2><ul><li>强引用（StrongReference）：<code>无论内存是否充足，都不会被回收</code>强引用指的是在代码中普遍存在的类似<code>Object object=new Object();</code>这类的引用，只要有这类的存在，垃圾回收器永远不会回收该对象，这也是导致OOM异常出现的主要原因。若想中断强引用可以把对象置为<code>null</code>。</li><li><p>弱引用（WeakReference）：<code>内存不足时，会被回收</code>弱引用用来修饰非必需对象，弱引用所关联的对象生命周期只到下一次垃圾回收前，无论内存是否充足都会被回收关联对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference=<span class="keyword">new</span> WeakReference&lt;&gt;(s);</span><br><span class="line"><span class="comment">//当内存回收时 调用weakRefrence=null 并且 System.gc();</span></span><br></pre></td></tr></table></figure></li><li><p>软引用（SoftReference）：<code>无论内存是否充足，都会被回收</code>软引用用来修饰一些有用但非必需的对象，软引用所关联的对象将会在系统即将发生OOM前，会把对象进行二次回收，若回收完内存还是不足则会发生OOM异常。<code>可实现内存敏感的高速缓存</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference=<span class="keyword">new</span> SoftReference&lt;&gt;(s);</span><br><span class="line"><span class="comment">//当内存不足时 会调用 softRefrence=null  并且 System.gc();</span></span><br></pre></td></tr></table></figure></li><li><p>虚引用（PhantomReference）：<code>任何时候都会被回收</code>虚引用不会决定对象的生命周期，虚引用关联的对象任何时候都可能被垃圾回收器回收。虚引用的作用是：跟踪对象被垃圾回收器回收的活动，虚引用本身加入引用队列中，记录引用对象是都被回收。</p></li></ul><h2 id="2-请用Java实现一个线程安全且高效的单例模式。"><a href="#2-请用Java实现一个线程安全且高效的单例模式。" class="headerlink" title="2. 请用Java实现一个线程安全且高效的单例模式。"></a>2. 请用Java实现一个线程安全且高效的单例模式。</h2><blockquote><p>单例：一个类有且仅有一个实例，并且自行实例化向整个系统提供。目的为</p><ul><li>减少内存的占用</li><li>阻止对象实例化自己的单例对象副本，从而确保所有对象访问统一实例</li><li><p>控制了实例化过程所以可以灵活化控制实例过程。</p><p>线程安全：再多线程访问时采用加锁机制，当一个线程访问该数据时，其他线程不能访问该数据，直到读取完毕才可以访问。不会出现数据不一致和数据污染。</p></li></ul></blockquote><blockquote><p>双重校验锁（DCL）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton mInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则<code>mInstance = new Singleton();</code>可能出现<code>mInstance</code>尚未被初始化的异常。<br><code>mInstance = new Singleton();</code>包括三步：<code>为对象分配内存</code>，<code>执行构造方法，初始化实例对象</code>，<code>把mInstance的引用指向分配的内存空间</code>。在JVM的执行过程中并不是原子性的。<br>保护序列化与反序列化安全的写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*反序列化提供的一个特殊方法，可以控制对象的反序列化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mInstance;<span class="comment">//返回实例对象</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>静态内部类：</p><p><code>为何可以保证线程安全？</code>虚拟机可以保证一个类的类构造器 <code>&lt;clinit&gt;()</code>在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。<strong>同一个类加载器下，一个类型只会被初始化一次。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举写法（在Android中不推荐使用，对内存的消耗较大）<br>枚举法的好处：1.实例创建线程安全 2.防止被反射创建多个实例 3. 没有序列化的问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//do sth</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-拓展知识"><a href="#3-拓展知识" class="headerlink" title="3. 拓展知识"></a>3. 拓展知识</h2><ul><li><p>Kotlin实现的单例模式：<code>object Singleton{}</code>，本质是饿汉加载，在类加载时就会创建单例。问题在于构造方法过多时，初始化会变慢以及资源的浪费。</p></li><li><p>Kotlin实现懒汉式加载：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> instance: Singleton <span class="keyword">by</span> lazy &#123; Singleton() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Study Plan VI</title>
      <link href="/2018/03/18/Android-Study-Plan-VI/"/>
      <url>/2018/03/18/Android-Study-Plan-VI/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：关于Gradle的知识<br>1、如何理解Gradle？Grade在Android的构建过程中有什么作用？<br>2、实践如下问题。</p><p>问题：我们都知道，Android中时常需要发布渠道包，需要将渠道信息附加到apk中，然后在程序启动的时候读取渠道信息。<br>动态指定一个渠道号（比如1001），那么构建的apk中，请在它的AndroidManifest.xml文件里面的application节点下面添加如下meta-data，请写一段Gradle脚本来自动完成：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:allowBackup</span>=<span class="string">"false"</span> <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">“channel</span>" <span class="attr">android:value</span>=<span class="string">“1001</span>" /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>要求：当通过如下命令来构建渠道包的时候，将渠道号自动添加到apk的manifest中。<br>./gradlew clean assembleRelease -P channel=1001</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Study Plan V</title>
      <link href="/2018/03/18/Android-Study-Plan-V/"/>
      <url>/2018/03/18/Android-Study-Plan-V/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：关于View的知识</p><p>1、View的getWidth()和getMeasuredWidth()有什么区别吗？<br>2、如何在onCreate中拿到View的宽度和高度？</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="1-View的getWidth-和getMeasuredWidth-有什么区别吗？"><a href="#1-View的getWidth-和getMeasuredWidth-有什么区别吗？" class="headerlink" title="1. View的getWidth()和getMeasuredWidth()有什么区别吗？"></a>1. View的getWidth()和getMeasuredWidth()有什么区别吗？</h2><ul><li><p><code>getWidth()</code>通过<code>setFrame</code>方法来决定四个顶点位置，初始化<code>mLeft,mTop,mRight,mBottom</code>四个参数，这四个值固定则位置确定。必须在layout过程结束才有值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the width of the your view.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The width of your view, in pixels.</span></span><br><span class="line"><span class="comment">     * 利用屏幕上的右坐标减去左边的坐标 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">"layout"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRight - mLeft;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">            mLeft = left;</span><br><span class="line">            mTop = top;</span><br><span class="line">            mRight = right;</span><br><span class="line">            mBottom = bottom;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getMeasuredWidth</code>是在view的绘制流程中的<code>measure</code>结束后有值，获取的是view的测量宽高。<code>mMeasuredWidth</code>是在<code>setMeasuredDimensionRaw</code>方法中赋值的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MEASURED\_SIZE\_MASK = <span class="number">0x00ffffff</span>;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Like &#123;<span class="doctag">@link</span> #getMeasuredWidthAndState()&#125;, but only returns the</span></span><br><span class="line"><span class="comment">     * raw width component (that is the result is masked by</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #MEASURED_SIZE_MASK&#125;).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The raw measured width of this view.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;<span class="comment">//与任何数字的运算得到的结果是mMeasuredWidth</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, measuredHeight)</span> </span>&#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line"> </span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>一般情况下 <code>getMeasuredWidth</code>和<code>getWidth</code>的值是相同的，从源码中可以看出<code>setMeasuredDimensionRaw</code>会对<code>mMeasuredWidth</code>进行赋值，当调用了<code>onMeasure</code>，会调用到<code>setMeasuredDimensionRaw</code>则获取的结果将会不相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">Insets insets = getOpticalInsets();</span><br><span class="line">   <span class="keyword">int</span> oWidth  = insets.left + insets.right;</span><br><span class="line"><span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</span><br><span class="line">widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</span><br><span class="line">heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">&#125;</span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line"><span class="comment">// first clears the measured dimension flag</span></span><br><span class="line">mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">   resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cacheIndex = forceLayout ? -<span class="number">1</span> : mMeasureCache.indexOfKey(key);</span><br><span class="line"><span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line"><span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">   mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line"><span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">   setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></span><br><span class="line"><span class="comment">// an exception to warn the developer</span></span><br><span class="line"><span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span></span><br><span class="line">   + getClass().getName() + <span class="string">"#onMeasure() did not set the"</span></span><br><span class="line">+ <span class="string">" measured dimension by calling"</span></span><br><span class="line">+ <span class="string">" setMeasuredDimension()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>view的绘制流程<code>measure</code> <code>layout</code> <code>draw</code></p><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/view_process.png" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><ul><li><code>measure</code>为了计算出控件树中的各个控件要显示的内容以及大小，起点为<code>ViewRootImpl 的 measureHierarchy ()</code>。<ul><li>SpecMode : <code>EXACTLY(确切大小)</code> <code>AT_MOST(子view的大小不得超过SpecSize)</code> <code>UNSPECIFIED(对子view尺寸不做限制)</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Measure specification mode: The parent has not imposed any constraint</span></span><br><span class="line"><span class="comment">         * on the child. It can be whatever size it wants.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Measure specification mode: The parent has determined an exact size</span></span><br><span class="line"><span class="comment">         * for the child. The child is going to be given those bounds regardless</span></span><br><span class="line"><span class="comment">         * of how big it wants to be.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Measure specification mode: The child can be as large as it wants up</span></span><br><span class="line"><span class="comment">         * to the specified size.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>layout</code> 从根view开始，递归的完成控件树的布局工作，确定view的位置。先递归的对子view进行布局，在完成父布局的位置设置</p><ul><li><code>draw</code> 从根view开始进行绘制，利用<code>Viwe.draw()</code></li></ul></li></ul><h2 id="2-如何在onCreate中拿到View的宽度和高度？"><a href="#2-如何在onCreate中拿到View的宽度和高度？" class="headerlink" title="2.如何在onCreate中拿到View的宽度和高度？"></a>2.如何在onCreate中拿到View的宽度和高度？</h2><ul><li><p>在 Activity#onWindowFocusChanged 回调中获取宽高。</p></li><li><p>view.post(runnable)，在 runnable 中获取宽高。<br>  <code>利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。</code></p></li><li>ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。<br>  <code>监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露</code></li><li>调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高。</li></ul><h2 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h2><ul><li>matchParent无法measure(在view的measure过程中，需要知道parentSize即父容器的剩余空间，所以无法得出measure的大小)</li><li><a href="https://www.cnblogs.com/jycboy/p/6219915.html#autoid-7-1-0" target="_blank" rel="noopener">深入理解View绘制流程</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Study Plan IV</title>
      <link href="/2018/03/18/Android-Study-Plan-IV/"/>
      <url>/2018/03/18/Android-Study-Plan-IV/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p> 话题：关于startActivityForResult<br>1、startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode以及intent含义是什么？<br>2、Activity A启动B的时候，在B中何时该执行setResult ？setResult可以位于Activity的finish方法之后吗？</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="1-startActivityForResult-使用场景是什么？-requestCode、-resultCode-含义是什么？"><a href="#1-startActivityForResult-使用场景是什么？-requestCode、-resultCode-含义是什么？" class="headerlink" title="1.  startActivityForResult 使用场景是什么？ requestCode、 resultCode 含义是什么？"></a>1.  startActivityForResult 使用场景是什么？ requestCode、 resultCode 含义是什么？</h2><h3 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1  使用场景"></a>1.1  使用场景</h3><ul><li>用户开始新的活动，并且希望得到新活动的某些信息。比如选择照片、选择联系人、选择收货地址、进行某块数据编辑工作等。</li></ul><h3 id="1-2-requestCode"><a href="#1-2-requestCode" class="headerlink" title="1.2  requestCode"></a>1.2  requestCode</h3><ul><li>解决的是「区分多个异步任务」的问题。与其他异步 API 的设计类似，如果没有这个信息，那么 Activity 在收到响应时会进入混乱的状态。比如他不知道自己得到的是选择照片还是选择联系人的结果。</li><li>该信息会发送到 AMS 那边的 ActivityRecord.requestCode 变量进行记录，Client 端新 Activity 并不知道这个信息。</li><li><p>为什么 <code>requestCode</code>\&lt; 0 时收不到结果？</p><ul><li>ActivityStarter 收到 startActivityLocked 时，写入ActivityRecord.resultTo 变量为空<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#266" target="_blank" rel="noopener">对应源码</a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">            <span class="string">"Will send result to "</span> + resultTo + <span class="string">" "</span> + sourceRecord);</span><br><span class="line">    <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">            resultRecord = sourceRecord;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在 ActivityStack 收到 finishActivityResultsLocked 时，读取 ActivityRecord.resultTo 变量为空，结果数据不会添加到源 ActivityRecord.results 变量</p></li><li>在 ActivityStack 收到 resumeTopActivityInnerLocked 时，读取 ActivityRecord.results 数组为空，不会分发结果数据，这样源 Activity 也就没有结果回调了</li></ul><h3 id="1-3-resultCode"><a href="#1-3-resultCode" class="headerlink" title="1.3 resultCode"></a>1.3 resultCode</h3><ul><li>异步调用结果码，告诉调用者成功/失败/其它信息</li><li>该信息由被调用 Activity / framework 写入，并经过 AMS 传递给源 Activity</li><li><code>RESULT_CANCELED=0</code> <code>RESULT_OK=-1</code> <code>RESULT_FIRST_USER=1</code><h3 id="1-4-intent"><a href="#1-4-intent" class="headerlink" title="1.4 intent"></a>1.4 intent</h3></li><li>用于存储需要传递的数据</li><li>大小不得大于1M</li></ul><h2 id="2-A-启动-B-，B-中何时执行-setResult-setResult-是否可以位于-finish-之后？"><a href="#2-A-启动-B-，B-中何时执行-setResult-setResult-是否可以位于-finish-之后？" class="headerlink" title="2. A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？"></a>2. A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？</h2><h3 id="2-1-setResult-在-finish-之前执行，只是把数据记录在-Activity-mResultCode-和-Activity-mResultData-变量中"><a href="#2-1-setResult-在-finish-之前执行，只是把数据记录在-Activity-mResultCode-和-Activity-mResultData-变量中" class="headerlink" title="2.1 setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中"></a>2.1 setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中</h3><p>Activity 构造器阶段<br>大部分在显示调用finish()或者onBackPressed()<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(<span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;<span class="comment">//进行赋值</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           mResultCode = resultCode;</span><br><span class="line">          mResultData = data;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Home 键 + 不保留后台 Activity 可触发 onDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="string">"onDestroy "</span> + <span class="keyword">this</span>);</span><br><span class="line">        mCalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dismiss any dialogs we are managing.</span></span><br><span class="line">        <span class="keyword">if</span> (mManagedDialogs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> numDialogs = mManagedDialogs.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDialogs; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ManagedDialog md = mManagedDialogs.valueAt(i);</span><br><span class="line">                <span class="keyword">if</span> (md.mDialog.isShowing()) &#123;</span><br><span class="line">                    md.mDialog.dismiss();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mManagedDialogs = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// close any cursors we are managing.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mManagedCursors) &#123;</span><br><span class="line">            <span class="keyword">int</span> numCursors = mManagedCursors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCursors; i++) &#123;</span><br><span class="line">                ManagedCursor c = mManagedCursors.get(i);</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c.mCursor.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mManagedCursors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close any open search dialog</span></span><br><span class="line">        <span class="keyword">if</span> (mSearchManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSearchManager.stopSearch();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mActionBar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mActionBar.onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getApplication().dispatchActivityDestroyed(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">int</span> finishTask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> resultCode;</span><br><span class="line">            Intent resultData;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                resultCode = mResultCode;</span><br><span class="line">                resultData = mResultData;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(TAG, <span class="string">"Finishing self: token="</span> + mToken);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    resultData.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ActivityManager.getService()</span><br><span class="line">                        .finishActivity(mToken, resultCode, resultData, finishTask)) &#123;</span><br><span class="line">                    mFinished = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">// Empty</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mParent.finishFromChild(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-2-否"><a href="#2-2-否" class="headerlink" title="2.2 否"></a>2.2 否</h3><ul><li>如果位于 finish 之后执行，信息已经无法放到传递的数据中</li><li>从代码可以看出 setResult 和 finish 类似生产者/消费者模型，setResult 负责写入数据，finish 负责读取数据</li></ul><h3 id="2-3-线程安全问题"><a href="#2-3-线程安全问题" class="headerlink" title="2.3 线程安全问题"></a>2.3 线程安全问题</h3><ul><li>Activity.mResultCode 和 Activity.mResultData 变量由 Activity 对象的锁进行保护</li><li>支持后台线程和 UI 线程分别进行 setResult 和 finish</li><li>但是为什么需要加锁保护这两个信息？需要「解决什么问题」？</li></ul><h3 id="2-4-API-设计-数据组装问题"><a href="#2-4-API-设计-数据组装问题" class="headerlink" title="2.4 API 设计/数据组装问题"></a>2.4 API 设计/数据组装问题</h3><ul><li>底层 AMS 提供的接口的参数是 setResult 和 finish 的参数的组合形式，但是 Activity 为什么把一个接口拆分成两个接口给开发者使用？</li></ul><ul><li>使用方便。很多情况下调用者只关心 finish ，不需要理解太多的信息</li></ul><h3 id="2-5-启动模式冲突"><a href="#2-5-启动模式冲突" class="headerlink" title="2.5 启动模式冲突"></a>2.5 启动模式冲突</h3><ul><li>5.0以上 singleTask和singleInstance失效，重复启动时会重新创建实例</li><li>以下 则会直接收到<code>RESULT_CANCELED</code></li></ul><h2 id="3-API-内部原理-数据处理流程"><a href="#3-API-内部原理-数据处理流程" class="headerlink" title="3. API 内部原理/数据处理流程"></a>3. API 内部原理/数据处理流程</h2><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/study_plan_4.png" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>关键节点：</p><ul><li>Client 端通过 AMP 把数据发送给 Server 端 AMS Binder 实体</li><li>AMS 把数据包装成 ActivityResult 并保存在源 ActivityRecord 的 results 变量中</li><li>AMS 通过 ApplicationThreadProxy 向 Client 端发送 pause 信息让栈顶 Activity 进入 paused 状态，并等待 Client 端回复或超时</li><li>AMS 接收 Client 端已 paused 信息，恢复下一个获取焦点的 Activity ，读取之前保存在 ActivityRecord.results 变量的数据派发给 Client 端对应的 Activity</li><li>Client 端数据经过 ApplicationThread 对象、ActivityThread 对象的分发最后到达 Activity</li></ul></blockquote><h2 id="4-startActivityForResult-和-singleTask-导致源-Activity-收不到正确结果问题"><a href="#4-startActivityForResult-和-singleTask-导致源-Activity-收不到正确结果问题" class="headerlink" title="4. startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题"></a>4. startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题</h2><h3 id="4-1-基本原则"><a href="#4-1-基本原则" class="headerlink" title="4.1 基本原则"></a>4.1 基本原则</h3><blockquote><p>源 Activity 和目标 Activity 无法在跨 Task 情况下通过 onActivityResult 传递数据</p></blockquote><h3 id="4-2-Android-5-0-以上-AMS-在处理-manifest-xml-文件中的-singleTask-和-singleInstance-信息「不会」创建新的-Task，因此可以收到正常回调"><a href="#4-2-Android-5-0-以上-AMS-在处理-manifest-xml-文件中的-singleTask-和-singleInstance-信息「不会」创建新的-Task，因此可以收到正常回调" class="headerlink" title="4.2 Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调"></a>4.2 Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调</h3><p> <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#1196" target="_blank" rel="noopener">源码链接</a></p><h3 id="4-3-Android-4-4-4-以下-AMS-在处理-manifest-xml-文件中的-singleTask-和-singleInstance-信息「会」创建新的-Task，因此在-startActivity-之后立即收到取消的回调"><a href="#4-3-Android-4-4-4-以下-AMS-在处理-manifest-xml-文件中的-singleTask-和-singleInstance-信息「会」创建新的-Task，因此在-startActivity-之后立即收到取消的回调" class="headerlink" title="4.3 Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调"></a>4.3 Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调</h3><p><a href="http://androidxref.com/4.4.4_r1/xref/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java#1399" target="_blank" rel="noopener">源码链接</a>   </p><h3 id="4-4-通过-dumpsys-activity-activities-命令查看-AMS-状态，验证两个-Activity-是否属于不同的-Task"><a href="#4-4-通过-dumpsys-activity-activities-命令查看-AMS-状态，验证两个-Activity-是否属于不同的-Task" class="headerlink" title="4.4 通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task"></a>4.4 通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task</h3>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Study Plan III - Activty</title>
      <link href="/2018/03/18/Android-Study-Plan-III/"/>
      <url>/2018/03/18/Android-Study-Plan-III/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：理解Activity的启动模式。<br>1、Activity的启动模式有哪几种，分别用于什么场景？<br>2、清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="1-Activity的启动模式有哪几种，分别用于什么场景"><a href="#1-Activity的启动模式有哪几种，分别用于什么场景" class="headerlink" title="1. Activity的启动模式有哪几种，分别用于什么场景"></a>1. Activity的启动模式有哪几种，分别用于什么场景</h2><blockquote><p>standard:标准模式<br>多实例模式，每次启动一个Activity都会重新创建新的实例，若启动者是除Activity之外的context则需指定<code>FLAG_ACTIVITY_NEW_TASK</code>标记位，创建新栈，不然报出异常<br> <code>android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag.</code></p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/launchmode_standard.png" class="full-image" alt="alt" title="Standard"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>singleTop:栈顶复用模式 (<code>FLAG_ACTIVITY_SINGLE_TOP</code>)<br>若Activity实例已经存在栈顶，则启动时不会创建新的实例而是回调<code>onNewIntent()</code>方法,若不在栈顶则会创建新的实例。<code>onResume()</code>会被调用</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/launchmode_singletop.png" class="full-image" alt="alt" title="SingleTop"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote><p>singleTask:栈内复用模式 (<code>FLAG_ACTIVITY_NEW_TASK</code>)<br>栈内只要存在Activity实例，再次启动都不会重新创建实例，只会回调<code>onNewIntent()</code>方法,并从栈内弹出所有实例之上的所有。适合作为入口点，作为主页面，因为只会启动一次。</p></blockquote><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/launchmode_singletask1.png" class="full-image" alt="alt" title="SingleTask"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/launchmode_singletask2.png" class="full-image" alt="alt" title="SingleTask"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p><code>taskAffinity</code>代指Activity希望进入的Task栈，默认是应用包名<br><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study_plan/launchmode_singletask3.png" class="full-image" alt="alt" title="SingleTask"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span></p><blockquote><p>singleInstance:单实例模式<br>具有singleTask所有特性，不过单独存在一个任务栈中。启动时会新开一个任务栈，并直接创建实例，压入新开的任务栈中。</p></blockquote><h2 id="2-清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？"><a href="#2-清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？" class="headerlink" title="2. 清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？"></a>2. 清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？</h2><blockquote><p>onNewIntent</p><ul><li>singleTop模式下启动的Activity并在任务栈中存在</li><li>singleTask模式启动的Activity并在任务栈中存在</li><li>singleInstance模式启动的Activity并存在一个包含实例的栈</li><li>可以通过<code>setIntent(intent)</code>刷新intent数据</li></ul></blockquote><blockquote><p>onConfigurationChanged</p><ul><li>当系统配置信息发生变化时，系统调用该方法。需在AndroidManifests文件中处理了configChanges属性，才会被调用。默认会销毁当前Activity并重新创建一次来加载最新的配置信息。</li><li>若配置了configChanges 则不会重启Activity，若改变的配置不在你配置的选项中，则依然会重启，则不调用方法</li><li>configChanges常用取值<ul><li>locale：选择一种新的语言</li><li>touchscreen：更换手机屏幕</li><li>keyboard：键盘类型发生改变</li><li>keyboardHidden：键盘是否显示</li><li>navigation：导航栏发生变化</li><li>screenLayout：手机屏幕布局发生变化</li><li>fontScale：手机字体大小发生改变</li><li>orientation：手机屏幕切换（运行在Api13以上，需要添加screenSize）</li><li>screenSize：可用屏幕大小发生改变</li><li>layoutDirection：手机屏幕左右或上下互换</li></ul></li></ul></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Study Plan II - Service</title>
      <link href="/2018/03/18/Android-Study-Plan-II/"/>
      <url>/2018/03/18/Android-Study-Plan-II/</url>
      <content type="html"><![CDATA[<h1 id="Android学习计划"><a href="#Android学习计划" class="headerlink" title="Android学习计划"></a>Android学习计划</h1><p>话题：清晰地理解Service。<br>1、Service的start和bind状态有什么区别？<br>2、同一个Service，先startService，然后再bindService，如何把它停止掉？<br>3、你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？<br>4、Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？</p><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/study\_plan/service\_lifecycle.png" class="full-image" alt="alt" title="Service生命周期"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h2 id="1-Service的start和bind状态有什么区别？"><a href="#1-Service的start和bind状态有什么区别？" class="headerlink" title="1.Service的start和bind状态有什么区别？"></a>1.Service的start和bind状态有什么区别？</h2><p>start启动Service,service有独立的生命周期，不依赖启动组件；<br>多次调用start方法，会重复调用onStartCommand方法；（判断service是否正在运行以避免多次调用）<br>start启动的Service，需要stopService或stopSelf来停止（IntentService会自动调用）。</p><blockquote><p>生命周期:onCreate()->onStartCommand()->onDestory()</p></blockquote><p>bind绑定的Service，依赖于启动组件，销毁后随之消失；<br>多次bind，只会调用一次onBind方法</p><blockquote><p>生命周期:onCreate()->onBind()->onUnBind()->onDestory()</p></blockquote><h2 id="2-同一个Service，先startService，然后再bindService，如何把它停止掉？"><a href="#2-同一个Service，先startService，然后再bindService，如何把它停止掉？" class="headerlink" title="2.同一个Service，先startService，然后再bindService，如何把它停止掉？"></a>2.同一个Service，先startService，然后再bindService，如何把它停止掉？</h2><p>调用stopService和unbindService方法，顺序无关，当最后一次调用时，会进入Service的onDestory方法</p><h2 id="3-你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？"><a href="#3-你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？" class="headerlink" title="3.你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？"></a>3.你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？</h2><p>4种返回值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本兼容，在Service被杀死后，并不保证onStartCommand会被再一次调用</span></span><br><span class="line"><span class="comment">//Service被kill后，Service被重建，即会调用onCreate()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_STICKY_COMPATIBILITY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**在Service被杀死后，系统会尝试重启Service但不保存intent，会用一个null对象调用  </span></span><br><span class="line"><span class="comment">onStartCommand方法（注意intent判空），除非有一些被发送的Intent对象在等待   Service被kill后，Service被重建、重启，即会调用onCreate()&gt;onStartCommand()，intent对象为null。</span></span><br><span class="line"><span class="comment">启动服务，试用于媒体播放器之类，无限期等待*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_STICKY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**常规操作，除非被杀死之前还有组件调用startService，否则不保留状态并重启Service  </span></span><br><span class="line"><span class="comment">直到接受到新的Intent对象，这个服务才会被重新创建</span></span><br><span class="line"><span class="comment">Service被kill后，Service没有重启*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_NOT_STICKY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**Service被杀死后，系统将会组织一次重启Service，在杀死前的最后一次传递的intent会被重新执行，不会传递空的intent  </span></span><br><span class="line"><span class="comment">任意等待中的Intent对象会依次被发送。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_REDELIVER_INTENT = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><h2 id="4-Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？"><a href="#4-Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？" class="headerlink" title="4.Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？"></a>4.Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？</h2><p>Service默认运行在主线程，所以生命周期的方法都会运行在主线程</p><h2 id="5-Service种类"><a href="#5-Service种类" class="headerlink" title="5.Service种类"></a>5.Service种类</h2><blockquote><p>按运行地点分类：<code>本地服务</code>和<code>远程服务</code><br>本地服务：依附主进程，主进程被kill后就会自动销毁<br>远程服务：运行在一个独立进程，需要利用AIDL通信需要占用一定资源而且是常驻形式</p></blockquote><blockquote><p>按运行类型分类：<code>前台服务</code>和<code>后台服务</code><br>前台服务：会在通知栏显示相关通知，当服务终止时通知栏消息即消失起到一定通知作用<br>后台服务：不会显示在前台，用户无感知，服务终止也不会有任何提示</p></blockquote><blockquote><p>按使用方式分类：<code>startService</code>，<code>bindService</code>和<code>混合使用</code><br>startService：用于启动服务执行后台任务，不需要通信，停止需要stopService<br>bindService：启动的服务需要进行通信，unbindService停止<br>混合使用：停止服务需同时调用stopService，unbindService</p></blockquote><h2 id="6-IntentService介绍"><a href="#6-IntentService介绍" class="headerlink" title="6.IntentService介绍"></a>6.IntentService介绍</h2><p>继承Service的一个异步请求类，在IntentService有一个工作进程处理耗时操作，启动方式和普通Service一样。任务执行完毕后，IntentService会自动关闭。每次只会执行一个而不至于堵塞UI线程。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
