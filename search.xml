<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客导读</title>
    <url>/2019/03/14/%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[
> 对博客内的文章提供快速入口，按照分类进行查看。

其中主要涉及了以下几大模块

## Android学习路线

**Android高级进阶** {%post_link Android需要的必备知识%}

## 计算机网络相关

**HTTP的原理和工作机制** {% post_link HTTP的原理和工作机制%}

**TCP/IP协议相关** {% post_link TCP-IP协议相关%}

## JVM相关

**JVM相关合集整理** {% post_link JVM相关合集整理%}

**JVM内存区域** {% post_link JVM相关及其拓展%}

**类加载机制** {% post_link JVM相关及其拓展-二%}

Java ClassLoader {% post_link JVM相关及其拓展-三%}

**GC相关** {% post_link JVM相关及其拓展-四%}

Java内存模型 {% post_link JVM相关及其拓展-五%}

**Java线程** {% post_link JVM相关及其拓展-六%}

线程安全与锁优化 {% post_link JVM相关及其拓展-七%}

静态与动态分派 {% post_link JVM相关及其拓展-八%}

## Java相关

**Java线程相关合集整理** {% post_link Java线程相关合集整理%}

基础知识 {%post_link Java-基础知识%}

引用类型 {%post_link Android-Study-Plan-VIII%}

**线程池** {%post_link Java-线程池%}

CAS {% post_link Atomic原子操作类分析%}

BlockingQueue阻塞队列 {% post_link Java-BockingQueue阻塞队列%} 

ReentrantLock原理及解析{% post_link Java-ReentrantLock原理及解析%}[待完成]

CountDownLatch原理及解析{% post_link Java-CountDownLatch原理及解析%}[待完成]

AbstractQueuedSynchronizer原理及解析{% post_link Java-AbstractQueuedSynchronizer简介%}

Condition原理及解析{% post_link Java-AQS-Condition原理及解析%}[待完成]

final {% post_link final关键字%} [待完成]

static {% post_link static关键字分析%}

**synchronized** {% post_link Java-synchronized关键字分析 %}

**volatile** {% post_link volatile关键字分析%}

**ThreadLocal原理分析** {% post_link ThreadLocal原理分析%}

**Java-反射** {%post_link Java-反射%}

Java-泛型 {%post_link Java-泛型%}

Java-注解 {% post_link Java-注解%}

**Java字节码学习** {% post_link Java字节码学习 %}

**Java字节码学习-操作指令** {% post_link Java字节码学习-操作指令 %}

**Java字节码学习-应用场景** {% post_link Java字节码学习-应用场景 %}

## 数据结构相关

**排序算法** {% post_link 基础排序算法介绍%}

**红黑树** {% post_link 数据结构-红黑树%}

链表 {% post_link 数据结构-链表%}

树 {% post_link 数据结构-树%}

**ArrayList** {%post_link ArrayList实现原理及简析%}

Android-ArrayMap {% post_link ArrayMap简析%}

Android-SparseArray {%post_link SparseArray分析%}

**ConcurrentHashMap** {% post_link Java-ConcurrentHashMap原理及解析%}

CopyOnWriteArrayList {% post_link Java-CopyOnWriteArrayList实现原理及简析 %}

**HashMap** {%post_link HashMap实现原理及解析%}

LinkedHashMap {% post_link LinkedHashMap简析%} [待完成]

## Android源码相关

Window相关 {% post_link 理解Window及WindowManager%}

**WindowManagerService** {%post_link WindowManagerService简析%} [待完成]

Activity-Window-View {% post_link Activity-Window-View相关%}

Activity生命周期及启动模式 {% post_link Activity的生命周期和启动模式%}

**Activity启动过程** {% post_link Activity启动过程%}

Service工作过程 {% post_link Service工作过程%}

Android补间动画  {% post_link Android-动画分析%}

Android动画-属性动画 {% post_link Android动画-属性动画%}

Android-Drawable  {% post_link Android-Drawable相关%}

Android中的线程`AsyncTask、IntentService、HandlerThread` {% post_link Android-线程相关%}

**Android触摸事件** {% post_link Android触摸事件分发%}

**Android中的IPC机制** {% post_link Binder及AIDL%}

**Android-Binder** {%post_link Binder系列-Binder%}

**Android-Handler** {%post_link Handler机制即源码解析%}

**Handler拓展知识** {%post_link Handler机制源码解析-二%}

**ListView** {%post_link ListView简析%}

**RecyclerView** {%post_link RecycleView简析%}

SharedPreferences简析 {%post_link SharesPreference简析%}

**View工作原理** {%post_link View的工作原理%}

**View事件体系** {% post_link View的事件体系%}

**View刷新机制** {% post_link View的刷新机制%}

**Android Dex学习** {% post_link Android-Dex文件学习%}

## Android三方库源码分析

**组件间通信** {% post_link 组件间通信——LiveDataBus%}

组件间跳转  {% post_link Android-简单实现Router功能%}[待完成]

**LruCache** {% post_link LRUCache原理%}

DiskLruCache {% post_link DiskLruCache源码分析%}[待完成]

**Glide源码解析** {% post_link Glide源码解析要点%}

**OkHttp源码解析** {%post_link OkHttp简析%}

**RxJava源码解析** {% post_link RxJava-使用及解析%}

AAC-Lifecycle {% post_link Jetpack-Lifecycle简析%}

AAC-LiveData {% post_link Jetpack-LiveData简析%}

AAC-ViewModel {% post_link Jetpack-ViewModel简析%}



## Android其他知识

**计算机网络** {% post_link 计算机网络基础%}

**进程保活** {% post_link 进程保活介绍%}

**WebView相关知识** {% post_link WebView相关知识%}

**热修复** {% post_link 热修复基本原理及其实现%}

插件化 {% post_link 插件化实现原理简析%}

Hook技术 {%post_link Hook技术简析%}

自定义View {% post_link 自定义View实践%}

自定义ViewGroup {% post_link 自定义ViewGroup实践%}

组件化 {% post_link 组件化原理及实践%}

Service基本使用 {}

**Android性能优化** {% post_link Android性能优化%}

**Android布局优化** {% post_link include、merge-ViewStub相关%}

Dalvik&ART {% post_link Android中的GC分析-Dalvik和ART虚拟机%}

**ANR分析** {% post_link ANR分析%}

**Bitmap分析** {%post_link Bitmap分析%}

Fragment {% post_link Fragment相关%}

MVC、MVP、MVVM的选择 {% post_link MVC-MVP-MVVM的理解%}

## Kotlin学习笔记

《Kotlin核心编程》读书笔记-基础语法 {% post_link 《Kotlin核心编程》读书笔记-基础语法%}

《Kotlin核心编程》读书笔记-面向对象 {% post_link 《Kotlin核心编程》读书笔记-面向对象%}

Kotlin-拓展函数[待完成]

Kotlin-协程及原理[待完成]  {% post_link Kotlin协程体验 %}

Kotlin-委托相关知识[待完成] {% post_link Kotlin-委托相关知识 %}

## 算法题相关

**剑指Offer** {% post_link 常见算法题整理%}[待完成]

位运算 {% post_link 位运算%}[待完成]

## 设计模式相关

基本原则 {% post_link 设计模式-基本原则%}

单例模式 {% post_link 设计模式-单例模式%}

工厂模式 {% post_link 设计模式-工厂模式%}[待完成]

代理模式 {% post_link 动态代理模式原理及实现%}

责任链模式 {% post_link 设计模式-责任链模式%}

装饰模式 {% post_link 设计模式-装饰模式%}

## Gradle学习笔记

**Gradle相关** {% post_link Gradle操作小记%}[待完成]

Gradle学习笔记-Groovy {% post_link Gradle学习笔记-Groovy%}

Gradle学习笔记-Task {% post_link Gradle学习笔记-Task%}[待完成]

Gradle学习笔记-Project {% post_link Gradle学习笔记-Project %}[待完成]

Gradle学习笔记-自定义插件[待完成]

Gradle学习笔记-Android中的自定义插件[待完成]



## AOP学习笔记

AOP学习笔记-基础概念[待完成]

AOP学习笔记-APT[待完成] 包含基础概念的理解以及实例代码

AOP学习笔记-AspectJ[待完成] 需要针对Kotlin对应的进行原理分析

AOP学习笔记-ASM[待完成] 与Gradle中的Transform协同使用

AOP学习笔记-AST[待完成]



## Flutter学习笔记

学习大纲 {% post_link Flutter学习大纲%}[待完成]





## TypeScript学习笔记

]]></content>
      <tags>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Dex文件学习</title>
    <url>/2019/09/24/Android-Dex%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[
<!--https://source.android.com/devices/tech/dalvik/dex-format dex组成 dex如何转换机器码 dex到odex过程 dex2oat过程分析-->

## Dex文件







## Dex转换过程











## 参考链接

[Android Developer Dex文档](https://source.android.com/devices/tech/dalvik/dex-format)

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>常见算法题整理 - 来自《剑指Offer》</title>
    <url>/2018/01/16/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[


| 数据结构           | 算法         | 概念             |
| ------------------ | ------------ | ---------------- |
| 链表               | 广度优先搜索 | 位操作           |
| 树、单词查找树、图 | 深度优先搜索 | 内存（堆、栈）   |
| 栈和队列           | 二分查找     | 递归             |
| 堆                 | 归并排序     | 动态规划         |
| 向量、数组列表     | 快排         | 时间、空间复杂度 |
| 散列表             |              |                  |



给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。(要求线性时间复杂度，即$O(1)$)

实例：输入：[1,2,3,2,1] 输出：3

```java
    public int singleNumber(int[] nums) {
        int result = 0;
        for(int x : nums){
            result = result ^ x; //利用异或位运算 实现 同则为0 不同则为 1
        }
        return result;
    }
```



给定一个正整数，如何判断该数是否为2的幂次方？

实例：输入 32 输出 true

​      输入 25 输出 false

```java
public boolean isMi(int num){
  return num & (num -1 ) == 0；
}
```



输入一颗二叉树，求树的深度 *利用递归实现*

```java
public class TreeNode{
  int val = 0;
  TreeNode left = null;
  TreeNode right = null;
  
  public TreeNode(int val){
    this.val = val;
  }
}

public class Solution{
  public int TreeDepth(TreeNode root){
    if(root ==null){
      return 0;
    }
    return 1 + Math.max(TreeDepth(root.left),TreeDepth(root.right));
  }
}
```



不用加减乘除实现 加法 减法 

```java
public class Solution {
    public int Add(int num1,int num2) {
        if(num2==0){
            return num1;
        }
        int res = num1 ^ num2;
        int res2 = (num1&num2) << 1;
        return Add(res,res2);
    }
  
   public int minus(int num1,int num2){
    
  }
}
```



二叉树镜像

```java
public class Solution{
  public void Mirror(TreeNode root){
    if(root == null)
      return;
    swap(root);
    Mirror(root.left);
    Mirror(root.right);
  }
  
  private void swap(TreeNode root){
    TreeNode node = root.left;
    root.left= root.right;
    root.right = node;
  }
}
```



>  两个栈实现队列

```java
public class Solution{
  Stack<Integer> in = new Stack<Integer>();
  Stack<Integer> out = new Stack<Integer>();
  
  public void push(int node){
    in.push(node);
  }
  
  public int pop(){
    if(out.isEmpty()){
      while(!in.isEmpty()){
        out.push(in.pop());
      }
    }
    
    return out.pop();
  }
}
```



> 两个队列实现一个栈

```java

```





获取链表倒数第K个节点

```java
public class Solution{
   public ListNode FindKthToTail(ListNode head,int k) {
     if(head == null){
       return null
     } 
     ListNode first = head;
     while(first!=null && k-->0){
       first = first.next;
     }
     if(k>0){
       return null;
     }
     ListNode kNode = head;
     while(first!=null){
       first = first.next;
       kNode = kNode.next;
     }
     return kNode;
     
   }
}
```



反转链表并输出表头

```java
public class Solution{
  public ListNode ReverseList(ListNode head){
    ListNode reverseList = new ListNode(-1);
    while(head!=null){
      ListNode next = head.next;
      head.next = reverseList.next;
      reverseList.next = head;
      reverseList = next;
    }
    return reverseList.next;
  }
  
  public ListNode ReverseList1(ListNode head){
    ListNode pre = null;
    ListNode cur = head;
    ListNode next = null;
    while(cur!=null){
      next = cur.next;
      cur.next = pre;
      pre = cur;
      cur = next;
    }
    
    return pre;
  }
}
```



LeetCode 24：交换链表中节点

```java
public class Solution{
  public ListNode swapPairs(ListNode head){
    if(head==null || head.next ==null)
      return head;
    
    ListNode next = head.next;
    head.next = swapPairs(next.next);
    next.next = head;
    reyurn next;
  }
}
```





实现一个包含`min()`的栈，可以返回栈中的最小值

```java
public class Solution{
  private Stack<Integer> minStack = new Stack();
  private Stack<Integer> inputStack = new Stack();
  
  public void push(int node){
    inputStack.push(node);
    //与顶端进行比较 取小
    minStack.push(minStack.isEmpty()?node:Math.min(minStack.peek(),node));
  } 
  
  public void pop(){
    inputStack.pop();
    minStack.pop();
  }
  
  public int top(){
    return inputStack.peek();
  }
  
  public int min(){
    return minStack.peek();
  }
}
```



斐波那契数列

```java
public class Solution{
  public int Fibonacci(int n) {
  if(n<=1){
    return n;
  }
  int[] fib = new int[n+1];
    fib[1] = 1;
    for(int i=2;i<=n;i++){
      fib[i] = fib[i-1]+fib[i-2];
    }
    return fib[n];
  }
}
```



重建二叉树

- 已知前序遍历和中序遍历

  \> 例如 前序遍历为 {1,2,4,7,3,5,6,8} //根节点在前方
  \\\>
  \> ​	中序遍历为{4,7,2,1,5,3,8,6} //根节点左侧为 左子树  右侧为 右子树

```java
public class Solution{
  private HashMap<Integer,Integer> map = new HashMap<>();
  private int rootIndex ;
  public TreeNode buildTree(int[] pre,int[] in){
    int len = in.length;
    for(int i=0;i<len;i++){
      map.put(in[i],i);
    }
    rootIndex = 0;
    return buildTree(pre,0,len-1);
  }
  
  public TreeNode buildTree(int[] pre,int start,int end){
    if(start>end){
      return null;
    }
    TreeNode rootNode = new TreeNode(pre[rootIndex++])
    int index = map.get(rootNode.val);
    
    rootNode.left = buildTree(pre,start,index-1);
    rootNode.right = buildTree(pre,index+1,end);
    return rootNode;
  }
}
```

- 已知中序遍历和后序遍历

```java
public class Solution{
  private HashMap<Integer,Integer> map = new HashMap<>();
  private int rootIndex;
  public TreeNode BuildTree(int[] post,int[] in){
    int len = in.length;
    for(int i=0;i<len;i++){
      map.put(in[i],i);
    }
    rootIndex = len-1;
    return buildTree(post,0,len-1);
  }
  
  public TreeNode buildTree(int[] post ,int start ,int end){
    if(start>end)
      return null;
    TreeNode rootNode = new TreeNode(post[rootIndex--]);
    int index = map.get(rootNode.val);
    //先计算右子树
    rootNode.right = buildTree(post,index+1,end);
    rootNode.left = buildTree(post,start,index-1);
    return rootNode;
    
  }
}
```

- 二叉树的遍历

\- 

判断链表是否成环，若成环找出入口点

1. 判断next是否为null，不为null则成环
2. 利用`Set`存储每个节点，每到新节点判断是否出现重复。时间复杂度`O(n)`

```java
public class Solution{
  public ListNode EntryNodeOfLoop(ListNode head){
    if(head==null)
      return null;
    ListNode fast = head;
    ListNode slow = head;
    while(fast!=null && fast.next!=null){
      fast = fast.next.next;
      slow = slow.next;
      //表明链表成环
      if(fast==slow){
        ListNode result = head;
        while(head!=slow){
          result = result.next;
          slow = slow.next;
        }
        return result;
      }
    }
  }
}
```

删除链表中重复的节点

```java
public class Solution{
    public ListNode deleteDuplication(ListNode head){
      if(head == null || head.next ==null)
        return head;
      ListNode next = head.next;
      if(head.val == next.val){
        while(next!=null && head.val == next.val)
          next = next.next;
        return deleteDuplication(next);
      }else{
        head.next = deleteDuplication(next);
        return head;
      }
    }
}
```



判断是否为平衡二叉树

> 平衡二叉树：左子树和右子树高度相差不到1

```java
public class Solution{
  private boolean isBalanced = true;
  public boolean IsBalanced_Solution(TreeNode node){
    
    return isBalanced;
  }
  
  private int getTreeHeight(TreeNode node){
    if(node == null || !isBalanced){
      return 0;
    }
    int left = getTreeHeight(node.left);
    int right = getTreeHeight(node.right);
    if(Math.abs(left-right)<1){
      isBalanced = false;
    }
    return 1+Math.max(left,right);
  }
}
```

> 字符流中第一个不重复字符串
```java
public class Solution {
    HashMap<Character,Integer> map = new LinkedHashMap();
    char firstChar = "#".charAt(0);
    
    //Insert one char from stringstream
    public void Insert(char ch)
    {
       if (map.containsKey(ch)) {
            map.put(ch, 0);      
        } else {
            map.put(ch, 1);
        }

        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            if (entry.getValue() == 1) {
                firstChar = entry.getKey();
                break;
            }else{
                firstChar = "#".charAt(0);
            }
        }
    }
  //return the first appearence once char in current stringstream
    public char FirstAppearingOnce()
    {
        return firstChar;
    }
}
```

> 二叉搜索树的后序遍历序列
> 后序遍历过程： 左-\>右-\>中
> `二叉搜索树`：设x是树中的一个节点，如果y是x左子树中的一个节点，那么y\<=x，如果y是x右子树的一个节点，那么y\>=x
```java
public class Solution {
 public static  boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence.length ==0 || sequence==null){
            return false;
        }
        if(sequence.length == 1){
            return true;
        }
        return search(sequence,0,sequence.length-1);
    }

    private static boolean search(int[] array ,int start,int end){
        if(start > end){
            return true;
        }
        int i = end;
        //向前倒序寻找到左子树
        while(i>start && array[i-1] > array[end]){
            i--;
        }
        for(int j = i-1;j>=start;j--){
            if(array[j] > array[end]){
                return false;
            }
        }
        return search(array,start,i-1) && search(array,i+1,end-1);
    }
}
```

> 二叉树中和为某一值的路径
```java
public class Solution {
    private static ArrayList<ArrayList<Integer>> arrayLists = new ArrayList<>();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        arrayLists.clear();
        addPath(root,new ArrayList(),0,target);
        return arrayLists;
    }
    
    private static void addPath(TreeNode root, ArrayList<Integer> path, int num, int target) {
        if (root == null) {
            return;
        }
        num += root.val;
        path.add(root.val);
        //递归完毕
        if (root.left == null && root.right == null) {
            if (num == target) {
                arrayLists.add(new ArrayList<>(path));
            }
        } else {
            addPath(root.left, path, num, target);
            addPath(root.right, path, num, target);
        }
        path.remove(path.size() - 1);
    }
}
```



实现一个LFU算法

> 淘汰一定时期内被访问次数最少的元素

```java

```


Leetcode 703
> 采用优先队列机制实现，比较第K大元素问题
> 优先队列采用 小顶堆 小的数据放在根节点，这样在插入节点时只要与根节点比较即可
```java
class KthLargest {
    PriorityQueue<Integer> priorityQueue;
    int maxSize = 0;

    public KthLargest(int k, int[] nums) {
        this.maxSize = k;
        priorityQueue = new PriorityQueue<Integer>(k);
        for (int var : nums) {
            add(var);
        }

    }

    public int add(int val) {
        if (priorityQueue.size() < maxSize) {
            priorityQueue.offer(val);
        } else if (priorityQueue.peek() < val) {
            priorityQueue.poll();
            priorityQueue.offer(val);
        }
        return priorityQueue.peek();
    }
}
```

Leetcode 239：Sliding Window Maximum





Leetcode 15: 3Sum

> Given array nums = [-1, 0, 1, 2, -1, -4],
>
> A solution set is:
> [
>   [-1, 0, 1],
>   [-1, -1, 2]
> ]
>
> 解题思路：
>
> 先对数组进行排序，按照从小到大的顺序。将排序后的数组全部放入到`HashMap`中
>
> 题目中要求`a+b+c=0 ==> c=-a-b`即 在Map中找到`-a-b`对应的值并取出即可

```java
时间复杂度：`O(n2)`

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        HashMap<Integer, Integer> set = new HashMap<>();
        int len = nums.length;
        if (nums.length < 3)
            return result;
        // 排序
        Arrays.sort(nums);

        for (int i = 0; i < len; i++) {
            set.put(nums[i], i);
        }

        for (int i = 0; i < len; i++) {
            if (i != 0 && nums[i] == nums[i - 1])
                continue;

            for (int j = i + 1; j < len; j++) {
                // 
                if (nums[i] > 0)
                    break;
                if (nums[j] == nums[j - 1] && j != i + 1)
                    continue;
                if (set.containsKey(-nums[i] - nums[j]) && set.get(-nums[i] - nums[j]) > j) {
                    List<Integer> l = new ArrayList<Integer>();
                    l.add(nums[i]);
                    l.add(nums[j]);
                    l.add(-nums[i] - nums[j]);
                    result.add(l);
                }
            }
        }
        return result;
    }
}

```

优化解法

> 还是先进行排序，固定首位数据`a`，然后在剩下的数据内，设置下一位为`b`，数组最后一位为`c`，如果`a+b+c=0`直接取出对应值，
>
> - 若>0，则c向左移
> - 若<0，则b向右移

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();

        int len = nums.length;
        if (nums.length < 3)
            return result;
        // 排序
        Arrays.sort(nums);

        for (int i = 0; i < len - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            int low = i + 1;
            int high = len - 1;
            while (low < high) {
                int resultNum = nums[i] + nums[low] + nums[high];
                if (resultNum == 0) {
                    List<Integer> l = new ArrayList<Integer>();
                    l.add(nums[i]);
                    l.add(nums[low]);
                    l.add(nums[high]);
                    result.add(l);
                    //此处为了防止 因为重复数据导致问题 
                    while (low < high && nums[low] == nums[low + 1]) low++;
                    while (low < high && nums[high] == nums[high - 1]) high--;
                    low++;
                    high--;
                } else if (resultNum > 0) {
                    high--;
                } else {
                    low++;
                }
            }
        }
        return result;
    }
}
```



]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>日常细节记录</title>
    <url>/2018/04/03/%E6%97%A5%E5%B8%B8%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[
1. 强引用置为null时，不会立即回收对象，帮助回收器加快回收。但是会帮助GC 等到下次回收周期时即会回收

2. 死锁的四个必要条件：互斥，占有且等待，不可抢占，循环等待

3. CAS(原子操作)是乐观锁用到的主要机制，乐观锁是不用加锁去执行操作，如果产生冲突则失败重试，直到成功为止，也叫做“自旋”。与乐观锁相对应的是悲观锁，synchronized就是悲观锁，也叫“独占锁”需要加锁进行操作，并且加锁代码块中的只能有一个线程进行操作。

4. 点击App图标，系统最开始执行的是ActivityThread的main()方法

5. 应用的启动方式：
  2. 冷启动：启动应用时，后台没有该应用的进程。系统创建一个新的进程来进行重新分配。
  3. 热启动：启动应用时，后台已有该应用的进程。
	
6. Application的生命周期：`onCreate()//应用开始时执行->onLowMemory()//内存低时执行->onTrimMemory()//关闭应用时执行  onTerminate()//在真机上不会调用`

7. 进程相关： `优先级最低的进程首先被杀死、进程的等级会因为其他进程的依赖而提高一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低` 按重要性分类：
  2. 前台进程：进程持有一个正在与用户交互的Activity或者和交互Activity绑定的Service，前台运行的Service（执行`startForeground()`）,执行`onReceive()`的BroadcastReceiver
  3. 可见进程：进程持有一个被用户可见但没有显示在最前端的Activity(调用到了`onPause()`)或者和可见Activity绑定的Service
  4. 服务进程：进程持有一个`startService()`启动的Service进程，例如播放音乐，下载文件等Service
  5. 后台进程：进程持有一个用户不可见的Activity(调用到`onStop()`没有到`onDestroy()`)，进程被存放在一个LRU列表中，即很长时间没用的Activity会被优先杀死
  6. 空进程：进程不包含任何活跃的应用组件，唯一的作用是`为了缓存需要，缩短下次启动的时间`
	
8. 统计应用启动时间：`adb shell am start -W [packageName]/[packageName.MainActivity]`

9. `volatile`作用是`可见性`(当一个线程修改了某一个全局变量的值，其他线程能否知道这个修改)，`有序性`（禁止指令重排优化,防止代码执行指令被重新排序）。`volatile`并不能保证线程安全即保证不了线程间操作的原子性。

10. SharedPreference中`apply`和`commit`方法的区别：`commit`同步保存更改，`apply`异步保存到磁盘，原子提交，性能较高，但不保存结果。SharedPreference不支持多线程操作，`MODE_MULTI_PROCESS`这个标记位并没有实际作用。可以利用`ContentProvider`去实现多进程，\_方案后续会有介绍\_。

11. MD5不是加密算法，是一种散列算法。加密算法一般是对称加密算法

12. 使用ADB启动Activity：`adb shell am start -n 包名/需启动Activity路径`

13. Fragment中`replace`与`add`区别：
	- `replcae`：把容器内所有内容进行替换，都需要重新走一遍fragment的生命周期
	- `add`：添加不会清空容器内的内容。
14. 在三星手机上，进行原生分享文件时需要设置mimeType

15. `invalidate()`、`postInvalidate()`和`requestLayout()`的区别：
	- `invalidate()`：当子View调用invalidate方法时，会给View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递至ViewRootImpl中，最终触发performTraversals方法，进行View的重绘（即调用onDraw方法）。**该方法只能在UI线程中调用**
	- `postInvalidate()`：与invalidate作用一致，都是使View进行重绘，**该方法是在非UI线程中调用的**。内部主要实现是提供一个Handler实现，然后直接调用了invalidate方法，继续执行重绘流程。
	- `requestLayout()`：调用了这个方法会重新执行View的绘制流程，即重新执行测量(`onMeasure`)，布局(`onLayout`)，绘制(`onDraw`)方法。**利用责任链模式-不断向上传递该事件，直到找到能处理该事件的上级**。
16. Bitmap所占用的内存 = 图片长度 x 图片宽度 x （屏幕分辨率÷图片资源目录分辨率）²×一个像素点占用的字节数

17. HashMap扩容机制 在1.8之前只要达到负载就进行扩容，1.8之后是防止Hash冲突才进行扩容，如果不冲突不会触发扩容。

18. `px转换为dp`：**px/(DPI/160) = dp**，例如`1920 * 1080 , 480dpi`，最终转化就会得到360dp

19. 内部类可以访问外部类 `private`变量。在内部类需要引用外部类的`private`变量时，会默认生成一个`access$XXX()`，内部会返回当前对象

20. Java与Dart一样都是采用了**值传递**的`求值策略`：

	| 求值策略     | 求值时间 | 传值方式           |
	| ------------ | -------- | ------------------ |
	| **值传递**   | 调用前   | 值的结果(值的副本) |
	| **引用传递** | 调用前   | 原始值             |
	| **名传递**   | 调用后   | 与值无关的一个名   |

	其中最常见的是**值传递**(主要应用于Java、Dart、OC等)，然后是**引用传递**(C、C++、C#)。

	这两者主要的区别如下：

	> `值传递`：调用函数时将参数**复制**一份传递到函数中，函数中对参数进行修改，也不会影响到实际参数
	> `引用传递`：调用函数时传递的是**实际参数的地址**，函数中对参数进行修改时，也会影响到实际参数的值

	`值传递`无论参数类型是`值类型或引用类型`，都会调用栈上创建的一个副本。

	- 对于`值类型`，栈上的副本是**整个原始值的复制**
	- 对于`引用类型`，由于`引用类型`的实例在堆上，栈上的副本是**该变量在堆上的引用地址**


21. `UncaughtExceptionHandler`在`uncaughtException()`中接收应用所发生的异常，如果在该方法内再次发生异常**就会导致进入无限崩溃状态**。

22. `build.gradle`中`compileSdkVersion`,`minSdkVersion`,**`targetSdkVersion`**这三个参数的说明：

  `compileSdkVersion`：编译应用使用的SDK版本，单纯在编译时使用。*使用最新的编译SDK的好处就在于可以及时了解到API的状态例如弃用并可以提前使用新的API。*此处需要注意一点：**如果使用最新的`support library`，compileSdkVersion的版本至少要大于support的版本以保证编译通过。**

  `minSdkVersion`：**应用可以运行的最低版本**。*主要可以用于在应用使用高于该版本的api时进行提示，避免运行过程出现崩溃。*当依赖多个Module都制定了`minSdkVersion`时，自身推荐使用依赖库中最大的`minSdkVersion`避免出现问题。如果使用了比依赖库小的版本号，可以使用`tools:overrideLibrary`标志避免提示。

  `targetSdkVersion`：**应用向前兼容的主要依据。**为了保证老Apk在新版本系统上的兼容性，只要老Apk的`targetSdkVersion`版本不发生变化，在新系统依然会保持老系统上的行为。
Android系统通过获取`apk配置的targetSdkVersion`在调用系统对应Api时进行版本判断去执行不同的逻辑。

这三者的大小顺序应该为** minSdkVersion <= targetSdkVersion <= compileSdkVersion**这个是比较合理的顺序。

23. `==`与`equals()`的区别

	- `==`：所以基本类型比较的是**值是否相等**，所以引用类型比较的是**两者在内存中存放的地址(堆内存地址)**。
	- `equals()`：默认比较的是**对象的内存地址值**，如果重写了`equals()`，则按照重写规则比较(例如String 重写了`equals()`这样就变成值比较)。
	  - `hashcode()`：在比较`equals()`之前会先比较`hashcode`，如果不同则表示两个值不相等，若相同再进行`equals()`比较
	
24. 自动装箱/拆箱相关知识

   以下拿`int`，`Integer`举例：`int`就是原始类型，`Integer`就是包装类型。

   `自动装箱`：**将原始类型转换为包装类型** ── `Interger x = 1000`=>`Integer x = Integer.valueOf(1000);`转换成如下代码

   `自动拆箱`：**将包装类型转换为原始类型**──`Integer x = 1000;System.out.println(x)`=>`System.out.println(x.intValue())`转换成如下代码

   拓展知识：

   `Integer`的缓存策略：`Integer`中存在一个缓存池(`IntegetCache`)将使用频繁的值进行缓存避免创建过多对象提高性能。默认缓存池范围为`-128~127`，如果在该范围内返回的就是 `IntegerCache`中的对象，否则返回`new Integer(XX)`。

   ```java
   Integer a = 127;
   Integer a1 = 127;
     
   Integer b = 128;
   Integer b1 = 128;
   
   System.out.println(a==a1); //true 返回的实际上是缓存池的对象
   System.out.println(a.equals(a1)); //true
   System.out.println(b==b1); //false 重新new Integer
   System.out.println(b.equals(b1)); //true
   ```

   

25. Linux中的`epoll、select、inotify`机制简析

   都是`IO多路复用机制`，一个进程可以监视多个描述符，一旦某个描述符就位，就会通知系统回写。

   > `IO多路复用`：内核一旦发现进程指定的一个或者多个IO条件准备读取，就会通知该进程。
   >
   > 优势在于系统开销小，系统不需要创建进程/线程，也无需维护。

   - `inotify`：允许监控程序打开一个独立文件描述符，并针对事件集监控一个或多个文件，例如：打开、关闭、重命名、创建、删除等功能。（用于``FileObserver`监听对应文件的打开、修改、创建等事件）
     
     - `inotify_init()`创建一个监听文件变动的inotify实例,并返回指向该实例的文件描述符（fd）
     - `inotify_add_watch`增加对文件或目录的监控，并指定监控事件
     - `inotify_rm_watch`移除对文件或目录的监控
     
   - `select`：允许进程指示内核等待多个事件的任何一个发送，并只有在一个或多个事件发生或经历一段指定的时间后才唤醒。

     `select`需要遍历所有句柄才可以获取到哪个句柄有事件通知，并且最多支持1024个句柄，超过则可能导致溢出异常。

   - `epoll`：epoll使用一个文件描述符管理多个文件描述符，将用户关系的文件描述符的事件存放到一个内核的事件表中。

     - `epoll_create(int size)`：告诉内核需要监听的文件描述符个数

     - `epoll_ctl(int epfd,int op,int fd,struct epoll_event *event)`：对指定文件描述符进行`op`操作

       - epfd：epoll_create 返回的文件描述符

       - op：1)EPOLL_CTL_ADD 增加监听事件

         ​      2)EPOLL_CTL_DEL 删除监听事件

         ​      3)EPOLL_CTL_MOD 修改监听事件

       - fd：需要监听的文件描述符

       - event：告诉内核需要监听的事件

     - `epoll_wait()`：等待epfd的监听回调

       `epoll`对于句柄事件的选择不是遍历的，当事件响应时会通知到epoll。

       `epoll`有两种工作模式：

       - LT模式-水平触发(默认模式)：`epoll_wait`检测到描述符事件时会通知到应用程序，应用程序可以不立即处理该事件，等待下次`epoll_wait`时会继续发出通知。**效率较低但是不用担心数据丢失。**
       - ET模式-边缘触发：`epoll_wait`检测到描述符事件时会通知到应用程序，应用程序必须立即处理该事件，等待下次`epoll_wait`时不会继续发出通知。**效率最高但是需要对每个请求进行处理，避免丢失事件造成影响。必须使用非阻塞套接口，避免堵塞造成任务堵死。**

[Linux IO模式及 select、poll、epoll详解](https://segmentfault.com/a/1190000003063859)

26. MarkDown在嵌套`<html></html>`时会产生多余的`<br>`，需要使用 `{% raw %} {% endraw %} 包html table`

27. `i++`与`++i`的区别？

   **1、 i++ 返回原来的值，++i 返回加1后的值。**
   **2、 i++ 不能作为左值，而++i 可以。**


   **首先解释下什么是左值**（以下两段引用自中文维基百科『右值引用』词条）。

   > 左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。

   一般来说，**左值是可以放到赋值符号左边的变量**。但

   > 能否被赋值不是区分左值与右值的依据。比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。**左值与右值的根本区别在于是否允许取地址&运算符获得对应的内存地址。**

   `i++`的字节码表示为：

   ```java
       		37: lload         9
           39: dup2 //复制栈顶数据并压入栈顶，此时压入为i
           40: lconst_1
           41: ladd
           42: lstore        9
   ```

   

   `++i`的字节码表示为：

   ```java
           37: lload         9
           39: lconst_1
           40: ladd
           41: dup2  //复制栈顶数据并压入栈顶，此时压入为i+1
           42: lstore        9
   ```

  

28. `Boolean`在数组中占到了一个字节，在单独变量中等价于`int`占用了4个字节。

29. `快速失败(fast-fail)`与`安全失败(safe-fail)`的概念

    ` 快速失败`：迭代器遍历集合时，在过程中对集合的内容进行了修改（增加、删除、修改），则会抛出`ConcurrentModificationException`

    因为遍历过程中会使用一个`modCount`变量，遍历期间如果内容发生了变化，`modCount`会发生改变，迭代器在执行`hasNext()/next()`时，都会检测该值是否发生变化，发生变化则终止遍历并抛出异常。

    `java.util`下的类都是`快速失败`的！

    `安全失败`：迭代器遍历的不是原有集合，而是原有集合的复制集合

    因为遍历的是复制集合，所以遍历期间原有集合发生变化不会影响到遍历过程，就不会触发异常抛出。**由于遍历的是复制集合，导致遍历时无法获取最新的修改。**

    `java.util.concurrent`下的类都是`安全失败`的！

30. `Class.forName()`与`ClassLoader.class`的区别

    `Class.forName()`

    ``````
    public static Class<?> forName(String name, /*要加载的Class名字*/
    										 boolean initialize,/*是否需要初始化-调用静态代码快及静态变量初始化*/
                                   ClassLoader loader/*指定ClassLoader进行加载*/)
                                    
    ``````

    执行时默认会调用静态代码块`static{...}`，以及分配静态变量存储空间

    `ClassLoader.loadClass()`

    ``````
    protected Class<?> loadClass(String name, boolean resolve)
    ``````

    执行时不会对类进行初始化，只是将类加载到了虚拟机中。

31. 编译期Debug

    配置编译命令终端输入  `./gradlew :app:clean :app:assembleDebug -Dorg.gradle.daemon=false -Dorg.gradle.debug=true`，此时进入等待状态

    配置`Run/Debug Configurations`，新增一个`Remote`配置，使用默认配置即可

    切换到`Remote`配置，点击Debug按钮，然后debug attach成功

    此时运行`Make Project`等待断点执行到

32. JNI抛出Java异常

    ```c++
    void throwException(JNIEnv *env, char *msg) {
        jclass exClass;
        char *className = "java/lang/NullPointerException";
        exClass = env->FindClass(className);
      	//调用ThrowNew 抛出异常
        env->ThrowNew(exClass, msg);
    }
    ```

    `ThrowNew`的实现方法在`jni_interal.cc`

    ```c
    int ThrowNewException(JNIEnv* env, jclass exception_class, const char* msg, jobject cause)
        REQUIRES(!Locks::mutator_lock_) {
      // Turn the const char* into a java.lang.String.
      ScopedLocalRef<jstring> s(env, env->NewStringUTF(msg));
      if (msg != nullptr && s.get() == nullptr) {
        return JNI_ERR;
      }
    
      // Choose an appropriate constructor and set up the arguments.
      jvalue args[2];
      const char* signature;
      if (msg == nullptr && cause == nullptr) {
        signature = "()V";
      } else if (msg != nullptr && cause == nullptr) {
        signature = "(Ljava/lang/String;)V";
        args[0].l = s.get();
      } else if (msg == nullptr && cause != nullptr) {
        signature = "(Ljava/lang/Throwable;)V";
        args[0].l = cause;
      } else {
        signature = "(Ljava/lang/String;Ljava/lang/Throwable;)V";
        args[0].l = s.get();
        args[1].l = cause;
      }
      jmethodID mid = env->GetMethodID(exception_class, "<init>", signature);
      if (mid == nullptr) {
        ScopedObjectAccess soa(env);
        LOG(ERROR) << "No <init>" << signature << " in "
            << mirror::Class::PrettyClass(soa.Decode<mirror::Class>(exception_class));
        return JNI_ERR;
      }
    
      ScopedLocalRef<jthrowable> exception(
          env, reinterpret_cast<jthrowable>(env->NewObjectA(exception_class, mid, args)));
      if (exception.get() == nullptr) {
        return JNI_ERR;
      }
      ScopedObjectAccess soa(env);
      soa.Self()->SetException(soa.Decode<mirror::Throwable>(exception.get()));
      return JNI_OK;
    }
    
    //thread.cc
    void Thread::SetException(ObjPtr<mirror::Throwable> new_exception) {
      CHECK(new_exception != nullptr);
      // TODO: DCHECK(!IsExceptionPending());
      //此处设置了 jni插入的异常信息 ,会触发ART的checkPoint的检测，检测到该信息时抛出对应异常
      tlsPtr_.exception = new_exception.Ptr();
    }
    ```

    插入位置在**方法调用**或**循环**处。

33. 使用Gradle命令更新 dependenices

    ```groovy
    ./gradlew --configure-on-demand
    ```

    

34. Markdown常用操作

    ```markdown
    [显示内容](#标题) 锚点跳转
    
    {%post_link 文章标题%}  文章跳转
    ```

    

35. 设置hexo的博客置顶规则，按照tops进行配置

    ```js
    var posts = locals.posts.data.sort(function (a, b) {
    //两个post都定义了top
    if (a.top && b.top) {
    //按日期将降序
    if (a.top == b.top) return b.date - a.date;
    //按top排序
    else return b.top - a.top;
    }
    //定义了top的排前面
    else if (a.top && !b.top) {
    return -1;
    }
    else if (!a.top && b.top) {
    return 1;
    }
    //没有定义top就按照日期降序
    else return b.date - a.date;
    });
    ```

    需要配置在`node-modules/hexo-generator-index2/lib/generator.js`里面

36. kotlin中的`inline`、`noinline`、`crossinline`的作用、

    `inline`：函数进行内联，将`inline fun`直接插入到调用函数的代码内，优化代码结构，从而减少函数类型对象的创建。

    ```kotlin
    fun main(args:Array<String>){
      testInline()
      print("world")
    }
    
    inline fun testInline(){
      print("Hello")
    }
    
    输出结果：
    HelloWorld
    
    实际编译结果：
    fun main(args:Array<String>){
      print("Hello")
      print("world")
    }
    ```

    

    `noinline`：局部关掉函数内联优化，摆脱`inline不能使用函数类型的参数当对象用`的限制。作用于**函数的参数且参数必须为函数类型**

    ```kotlin
    inline fun test(noinline a : Int) {
       //Modifier 'noinline' is allowed only for function parameters of an inline function
       //错误使用方法 `noinline`只能使用在函数参数上
    }
    
    inline fun test(a: Int,  b: (Int) -> Unit): (Int) -> Unit {
        return b
      //Illegal usage of inline-parameter 'b' 
      //错误使用方法 不能直接返回 函数类型，因为经过内联后，函数类型无法被调用，失去了存在意义
      //这种错误写法，编译器可以直接检测出来
    }
    
    inline fun test(a:Int , noinline b :(String)->Unit) : (String) -> Unit {
      println(a)
      b("World")
      return b
    }
    
    fun main(args:Array<String>){
      println("Hello")
      test(3){ it->
        println(it)
      }
    }
    
    输出结果：
    Hello
    3
    World
    
    实际编辑结果：
    fun main(args:Array<String>){
      println("Hello")
      println(3)
      b.invoke("World")
    }
    ```

    

    `crossinline`：局部加强函数内联优化，将内联函数里的函数类型参数可以当作对象使用。

    首先声明两个概念：

    - Lambda表达式不允许使用`return`，可以使用`return@XX`来指定返回位置

      ```kotlin
      fun test(a:()->Unit){
        ...
      }
      
      fun main(args:Array<String>){
       test {
         ...
         return //这个是不被允许使用的
       //return@test 这个是可以的  
       } 
      }
      ```

      

    - 只有被`inline`修饰的内联函数的`Lambda表达式`可以使用return。在`间接调用`是被禁止的操作

      ```kotlin
      inline fun test(action:()->Unit){
        println("Hello")
        action()
      }
      
      fun main(args:Array<String>){
        test{
          println("World")
          return //是被允许这么做的
        }
      }
      ```

    `crossinline`实质为了**声明函数参数的`lambda`不能写`return`，避免lambda中的return影响外部的执行流程**。

    使用`inline`修饰函数时需要注意以下几点：

    - `inline`修饰函数，最好函数参数也是`函数类型`，否则无法获得性能提升

    - **避免内联大型函数**，因为`inline`会增加代码的生成量

    - `inline`修饰的函数不持有函数的对象引用，也不能将函数参数传递给另一个函数

      ```kotlin
      fun test123(a:()->Unit){
      
      }
      
      inline fun test12(a:()->Unit){
          test123(a) //无法编译
      }
      ```

      

37. 匿名内存(Ashmem)

    以Android Q为目标平台(`targetVersion 29`)的应用无法直接使用`ashmem`，必须通过NDK的`AsharedMemory`来访问共享内存，也无法直接使用`ioctl`，必须改为`AShredMemory`来创建共享内存区域。

38. 当出现`您的连接不是私密连接`时，点击高级后，并直接输入**thisisunsafe**关键字并回车。

39. ```java
    class A{
      void test(){
        B b = new B;
      }
    }
    ```

    此时调用`A`类，是否触发`B`的加载？

    

    
    
40. 

]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动过程</title>
    <url>/2019/01/02/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[
<!--ams是怎么找到启动的那个activity 从framework的角度讲activity的启动流程(冷启动) Application attach之前干了些什么？APP启动进程的时候，会处理些什么？ onResume的时候，已经是第一帧绘制了吗？如果不是，那什么时候是呢？-->

> 下列源码分析是基于 Android 8.0源码

Activity的启动过程分为两种：

- **根Activity的启动过程**  -  指代根Actiivty的启动过程也可以认为是应用程序的启动过程
- **普通Activity的启动过程**  -  除启动应用程序启动的第一个Activity之外Activity的启动过程

## 根Activity启动过程

{% fullimage /images/根Activity启动过程.png,根Activity启动过程-冷启动,根Activity启动过程-冷启动%}

> 点击桌面的应用程序图标就是启动根Activity的入口，当我们点击某个应用程序图标时，就会通过Launcher请求AMS来启动该应用程序。
>
> 其中涉及了三个进程间的通信：`Launcher组件`，`AMS`，`Activity组件`。

### Launcher请求AMS过程

当我们在应用程序启动器Launcher上点击一个应用的图标时，Launcher组件就会调用`startActivitySafely()`启动该App的根Activity。

配置根Activity，需要在AndroidManifest.xml中配置 相关属性

```xml
 <activity
            android:name=".MainActivity"
            android:label="@string/app_name"
            android:theme="@style/AppTheme.NoActionBar">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

```

Launcher组件中`startActivitySafely()`相关操作

```java
// packages/apps/Launcher3/src/com/android/Launcher3/Launcher.java
public boolean startActivitySafely(View v,Intent intent,ItemInfo item){
  ...
  
  intent.addFlags(Intent.FFLAG_ACTIVITY_NEW_TASK);
  try{
    if(Utilities.ATLEAST_MARSHMELLOW
      &&(item instanceof ShortcutInfo)
      &&(item.itemType == Favorites.ITEM_TYPE_SHORTCUT
      ||item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT)
       && !((ShortcutInfo)item).isPromise()){
      startShortcutIntentSafely(intent,optsBundle,item);
    } else if(user ==null || user.equals(Process.myUserHandle())){
      startActivity(intent,optsBundle);
    } else{
      LauncherAppsCompat.getInstance(this).startActivityForProfile(intent.getComponent(),
                                    user,intent.getSourceBounds(),optsBundle)；
    }
    return true;
  }catch(ActivityNotFoundException|SecurityException e){
    ...
  }
  return false;
}
```

设置启动Acticvity为`FLAG_ACTIVITY_NEW_TASK`保证根Activity在一个新任务栈中启动。`Launcher.java`继承了`Activity`接下来就到了`Acticvity.startActivity()`中

```java
// ../android/app/Activity.java
    @Override
    public void startActivity(Intent intent, @Nullable Bundle options) {
        if (options != null) {
            startActivityForResult(intent, -1, options);
        } else {
            startActivityForResult(intent, -1);
        }
    }
```

接下来会走到`startActivityFroResult()`，第二个参数设为` -1 `表明*Launcher不需要知道返回结果*

```java
// ../android/app/Activity.java
 Activity mParent;

 public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
            @Nullable Bundle options) {
        if (mParent == null) {
            options = transferSpringboardActivityOptions(options);
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, 
              mMainThread.getApplicationThread(), /*ApplicationThread*/
              mToken, 
              this,
                    intent, requestCode, options);
          ...
        }else{
          ...
        }
   ...
 }
```

`mParent`代表当前Activity的父类，由于`根Activity`还未创建出来，所以`mParent==null`成立。后续向下走就会调用到`Instrumentation.execStartActivity()`去继续启动Activity组件。

> Instrumentation用于监控应用程序和系统间的交互。

```java
// ../android/app/    .java
public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
        ...
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
            int result = ActivityManager.getService()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
            //检查启动Activity是否存在
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
            throw new RuntimeException("Failure from system", e);
        }
        return null;
    }
```

<!--`contenxtThread`是一个`IBinder对象`，实际指向的是`ApplicationThread`，用于进程间通信的Binder对象，可以-->

`ActivityManager.getService()`用于获取`AMS`的代理对象。实质上是把启动过程转移到了`AMS`上去执行

```java
// ../android/app/ActivityManager.java
    public static IActivityManager getService() {
        return IActivityManagerSingleton.get();
    }

    private static final Singleton<IActivityManager> IActivityManagerSingleton =
            new Singleton<IActivityManager>() {
                @Override
                protected IActivityManager create() {
                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                    return am;
                }
            };

//../android/util/Singleton.java
public abstract class Singleton<T> {
    private T mInstance;

    protected abstract T create();

    public final T get() {
        synchronized (this) {
            if (mInstance == null) {
                mInstance = create();
            }
            return mInstance;
        }
    }
}

```

第一次调用到`getService()`时，就会调用到`IActivityManagerSingleton.get()`，由源码可知，该类是一个单例类。

在其中先去获取名为`activity`的一个代理对象(`IBinder`)，后续实现利用了`AIDL`，根据`asInterface()`可以获得`IActivityManager`对象，他是AMS在本地的代理对象。然后就可以直接调用到`AMS`的`startActivity()`。

{% fullimage /images/Launcher请求AMS时序图.png,Launcher请求AMS时序图,Launcher请求AMS时序图%}

总结：

- 用户点击桌面图标触发`startActivitySafely()`开始调用打开根Activity流程。
- `Launcher组件`会调用到`Activity.startActivity()`后调用到`Activity.startActivityForResult()`
- 由于从Launcher启动，根Activity尚未建立，就会走到`Instrumentation.execStartActivity()`中
- 在`Instrumentation.execStartActivity()`中，实际调用的是`ActivityManager.getService()`去继续启动Activity
- 跟踪到`ActivityManager.getService()`实际返回的是一个`AMS`的本地代理对象`IActivityManager`，由前面学到的Binder机制中，这个代理对象是可以直接调用到`AMS`中的方法，所以`execStartActivity()`最终指向的是`AMS.startActivity()`

### AMS到ApplicationThread的调用过程

Launcher请求到AMS后，后续逻辑由AMS继续执行。继续执行的是`AMS.startActivity()`

```java
// ../core/java/com/android/server/am/ActivityManagerService.java
    public final int startActivity(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions,
                UserHandle.getCallingUserId()/*获取调用者的UserId*/);
    }

    //检测调用是否合法
    @Override
    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        //判断调用者进程是否被隔离
        enforceNotIsolatedCaller("startActivity");
        //检测调用者权限
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, "startActivity", null);
        // TODO: Switch to user app stacks here.
        return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,
                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
                profilerInfo, null, null, bOptions, false, userId, null, null,
                "startActivityAsUser");
    }

    void enforceNotIsolatedCaller(String caller) {
        if (UserHandle.isIsolated(Binder.getCallingUid())) {
            throw new SecurityException("Isolated process not allowed to call " + caller);
        }
    }
```

进入到`AMS.startActivity()`中，会调用到`startActivityAsUser()`，在这个方法中需要去判断调用是否合法。需要先`检测调用者进程是否被隔离`以及`调用者权限是否正确`。

前面都通过的话，就会调用到`ActivityStarter.startActivityMayWait()`。没有通过校验的话就会抛出`SecurityException`异常。

```java
// ../core/java/com/android/server/am/ActivityStarter.java
 final int startActivityMayWait(IApplicationThread caller, int callingUid,
            String callingPackage, Intent intent, String resolvedType,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int startFlags,
            ProfilerInfo profilerInfo, WaitResult outResult,
            Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId,
            IActivityContainer iContainer, TaskRecord inTask/*Activity所在任务栈*/, String reason/*启动理由*/) {
   ...
                 //指向 startActivityLocked 方法
                 int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                    aInfo, rInfo, voiceSession, voiceInteractor,
                    resultTo, resultWho, requestCode, callingPid,
                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                    options, ignoreTargetSecurity, componentSpecified, outRecord, container,
                    inTask, reason);
   ...
   
 }

 int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
            TaskRecord inTask, String reason) {
        //判断启动理由不可为空
        if (TextUtils.isEmpty(reason)) {
            throw new IllegalArgumentException("Need to specify a reason.");
        }
        mLastStartReason = reason;
        mLastStartActivityTimeMs = System.currentTimeMillis();
        mLastStartActivityRecord[0] = null;
        //指向 startActivity 方法
        mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,
                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,
                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,
                container, inTask);

        if (outActivity != null) {
            // mLastStartActivityRecord[0] is set in the call to startActivity above.
            outActivity[0] = mLastStartActivityRecord[0];
        }
        return mLastStartActivityResult;
    }


```

`ActivityStarter`是Android7.0新加入的类，他是加载Activity的控制类，会收集所有的逻辑来决定如何将`Intent和Flags`转换为Activity，并将Activity和Task以及Stark相关联。

调用`startActivityLocked()`之后继续走向`ActivityStarter.startActivity()`过程

```java
    /** DO NOT call this method directly. Use {@link #startActivityLocked} instead. */
    private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
            TaskRecord inTask) {
        int err = ActivityManager.START_SUCCESS;
        // Pull the optional Ephemeral Installer-only bundle out of the options early.
        final Bundle verificationBundle
                = options != null ? options.popAppVerificationBundle() : null;
        ProcessRecord callerApp = null;
        //这个caller是一直从Launcher启动时就传下来的
        if (caller != null) {
            callerApp = mService.getRecordForAppLocked(caller);
            if (callerApp != null) {
                callingPid = callerApp.pid;
                callingUid = callerApp.info.uid;
            } else {
                Slog.w(TAG, "Unable to find app for caller " + caller
                        + " (pid=" + callingPid + ") when starting: "
                        + intent.toString());
                err = ActivityManager.START_PERMISSION_DENIED;
            }
         }
    ...
        
        ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,
                callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),
                resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null,
                mSupervisor, container, options, sourceRecord);
        if (outActivity != null) {
            outActivity[0] = r;
        }
    ...
        doPendingActivityLaunchesLocked(false);
        return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true,
                options, inTask, outActivity);
    }
```

第16行代码 `caller!=null` 这个`caller`对象是从Launcher启动时就一直传递下来的，指向的是`Launcher所在的应用程序进程的ApplicationThread对象`。

第17行代码 `mService.getRecordForAppLocked(caller)` 得到的就是一个`ProgreeRecord`对象(`用于描述一个应用程序进程`)。该对象指的就是 *Launcher组件所运行的应用程序进程*。

第30行代码 `new ActivityRecord()` `ActivityRecord用来记录一个Activity的所有信息。`在这里`ActivityRecord`指的就是将要启动的Activity即根Activity。

第39行代码 继续调用`startActivity()`并传递当前记录的Activity信息。

```java
    private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,
            ActivityRecord[] outActivity) {
        int result = START_CANCELED;
        try {
            mService.mWindowManager.deferSurfaceLayout();
            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,
                    startFlags, doResume, options, inTask, outActivity);
        } finally {
            if (!ActivityManager.isStartResultSuccessful(result)
                    && mStartActivity.getTask() != null) {
                mStartActivity.getTask().removeActivity(mStartActivity);
            }
            mService.mWindowManager.continueSurfaceLayout();
        }
        
       
        postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId,  mSourceRecord,
                mTargetStack);

        return result;
    }

    private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,
            ActivityRecord[] outActivity) {
      ...
        if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask
                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {
            //如果是使用 singleTask模式启动 会新建一个任务栈用来存储Activity
            newTask = true;
            result = setTaskFromReuseOrCreateNewTask(
                    taskToAffiliate, preferredLaunchStackId, topStack);
        } else if (mSourceRecord != null) {
            result = setTaskFromSourceRecord();
        } else if (mInTask != null) {
            result = setTaskFromInTask();
        } else {
            // This not being started from an existing activity, and not part of a new task...
            // just put it in the top task, though these days this case should never happen.
            setTaskToCurrentTopOrCreateNewTask();
        }
        if (result != START_SUCCESS) {
            return result;
        }  
      
      ...
         if (mDoResume) {
            final ActivityRecord topTaskActivity =
                    mStartActivity.getTask().topRunningActivityLocked();
            if (!mTargetStack.isFocusable()
                    || (topTaskActivity != null && topTaskActivity.mTaskOverlay
                    && mStartActivity != topTaskActivity)) {
                mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
                mWindowManager.executeAppTransition();
            } else {
                if (mTargetStack.isFocusable() && !mSupervisor.isFocusedStack(mTargetStack)) {
                    mTargetStack.moveToFront("startActivityUnchecked");
                }
                mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                        mOptions);
            }
        } else {
            mTargetStack.addRecentActivityLocked(mStartActivity);
        }
      ...
    }
```

第30行代码 由于我们从Launcher启动根Activity时，设置启动标志为`FLAG_ACTIVITY_NEW_TASK`，所以就会走到`setTaskFromReuseOrCreateNewTask()`，这个方法主要是*管理任务栈，如果没有就会创建一个新的任务栈。*

第62代码 最终调用`ActivityStackSupervisor.resumeDocusedStackTopActivityLocked()`继续启动Activity的流程。

```java
// ../core/java/com/android/server/am/ActivityStackSupervisor.java
    boolean resumeFocusedStackTopActivityLocked(
            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {
        //判断当前的任务栈是否相同
        if (targetStack != null && isFocusedStack(targetStack)) {
            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
        }
        //获取要启动Activity的所在栈的栈顶Activity且不处于停止状态
        final ActivityRecord r = mFocusedStack.topRunningActivityLocked();
        //由于Activity尚未启动 满足要求
        if (r == null || r.state != RESUMED) {
            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);
        } else if (r.state == RESUMED) {
            // Kick off any lingering app transitions form the MoveTaskToFront operation.
            mFocusedStack.executeAppTransition(targetOptions);
        }
        return false;
    }

```

由于要启动的Activity尚未启动，所以会继续调用`ActivityStack.resumeTopActivityUncheckedLocked()`

```java
// ../core/java/com/android/server/am/ActivityStack.java
    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {
        if (mStackSupervisor.inResumeTopActivity) {
            // Don't even start recursing.
            return false;
        }

        boolean result = false;
        try {
            // Protect against recursion.
            mStackSupervisor.inResumeTopActivity = true;
            result = resumeTopActivityInnerLocked(prev, options);
        } finally {
            mStackSupervisor.inResumeTopActivity = false;
        }
        mStackSupervisor.checkReadyForSleepLocked();

        return result;
    }

   private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
     ...
       //需要启动Activity
       mStackSupervisor.startSpecificActivityLocked(next, true, true);
     ...
     return true;
   }
```



```java
// ../core/java/com/android/server/am/ActivityStackSupervisor.java


    void startSpecificActivityLocked(ActivityRecord r,
            boolean andResume, boolean checkConfig) {
        // 获取即将启动Activity所在的应用程序进程
        ProcessRecord app = mService.getProcessRecordLocked(r.processName,
                r.info.applicationInfo.uid, true);

        r.getStack().setLaunchTime(r);

        if (app != null && app.thread != null) {
           //进程已经启动
            try {
                if ((r.info.flags&ActivityInfo.FLAG_MULTIPROCESS) == 0
                        || !"android".equals(r.info.packageName)) {
                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                            mService.mProcessStats);
                }
                realStartActivityLocked(r, app, andResume, checkConfig);
                return;
            } catch (RemoteException e) {
                Slog.w(TAG, "Exception when starting activity "
                        + r.intent.getComponent().flattenToShortString(), e);
            }
        }
        //启动应用进程
        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
                "activity", r.intent.getComponent(), false, false, true);
    }


```



{% fullimage /images/AMS-应用程序进程通信.png,AMS-应用程序进程通信,AMS-应用程序进程通信%}

这一节主要是从`ActivityManagerService`经过层层调用到达`ApplicationThread`的Activity启动方法。

{% fullimage /images/AMS-ApplicationThread调用过程.png,AMS-ApplicationThread调用过程,AMS-ApplicationThread调用过程%}

`ActivityStack`:Activity的任务栈，从中获取需要进行操作的`ActivityRecord`进行操作。*在启动过程中，它的作用是检测当前栈顶Activity是否为要启动的Activity,不是就启动新Activity，是的话就重启，在这之前需要标记一下前Activity处于Pause状态。*

`ActivityStackSupervisor`:管理整个手机任务栈，管理着所有的`ActivityStack`。*在启动过程，它负责检查是否已有对应的应用进程在运行，如果有就直接启动Actiivty，没有的话则需新建一个应用进程。*

总结：

- 调用`AMS.startActivity()`实质调用其内部的`startActivityAsUser()`并在方法内部进行验证，判定*调用者进程是否隔离以及调用者权限是否正确*
- 通过验证后，就到了`ActivityStarter.startActivityMayWait()`,并设置启动理由为`startActivityAsUser`
- 向下调用到了`startActivityLocked()`，方法内部会去判定`reason`是否为空
- 不为空则走到`startActivity()`，该方法中主要*caller(`指向Launcher组件所运行的进程的ApplicationThread对象`)*，*callerApp(`指向Launcher组件所允许的应用程序进程`)*，基于`callerApp`生成对应的`ActivityRecord(记录即将要启动的Activity)`并存入`Activityrecord[]`中备用。
- 对应参数传入`startActivity()`的重载函数中，向下继续调用`startActivityUnchecked()`
- `startActivityUnchecked()`主要是 创建新的`TaskRecord(记录任务栈信息)`
- 向下切换到`ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()`，这个方法主要实现的是`寻找需要回复的栈顶Activity`
- 内部实现由`ActivityStack.resumeTopActivityUncheckedLocked()`实现，这里又继续调用到`resumeTopActivityInnerLocked()`
- 后续又切换回到`ActivityStackSupervisor.startSpecificActivityLocked()`，在该方法中`获取即将启动的Activity所在应用程序进程`，已启动的话调用`realStartActivityLocked()`，未启动的话就调用`startProcessLocked()`去启动进程

### AMS启动应用进程

由于启动是根Activity，这时应用进程尚未启动，需要通过`AMS.startProcessLocked()`创建一个应用程序进程

```java
// ../core/java/com/android/server/am/ActivityManagerService.java
    final ProcessRecord startProcessLocked(String processName,
            ApplicationInfo info, boolean knownToBeDead, int intentFlags,
            String hostingType, ComponentName hostingName, boolean allowWhileBooting,
            boolean isolated, boolean keepIfLarge) {
        return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,
                hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge,
                null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */,
                null /* crashHandler */);
    }  

    final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,
            boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,
            boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,
            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) {
        long startTime = SystemClock.elapsedRealtime();
        ProcessRecord app;
        ...
        startProcessLocked(
             app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
    }    


    private final void startProcessLocked(ProcessRecord app, String hostingType,
            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
      ...
        //
        boolean isActivityProcess = (entryPoint == null);
            if (entryPoint == null) entryPoint = "android.app.ActivityThread";
          
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " +
                    app.processName);
            checkTime(startTime, "startProcess: asking zygote to start proc");
            ProcessStartResult startResult;
            if (hostingType.equals("webview_service")) {
                startResult = startWebView(entryPoint,
                        app.processName, uid, uid, gids, debugFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, null, entryPointArgs);
            } else {
                startResult = Process.start(entryPoint,
                        app.processName, uid, uid, gids, debugFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, invokeWith, entryPointArgs);
            }
      ...
    }
```

调用到`Process`的静态成员函数`start()`启动一个新的应用进程，指定了该进程的入口函数为`ActivityThread.main()`；因此创建应用进程结束时，逻辑就转移到了`ActivityThread.main()`上。

```java 
Process.start() => ZygoteProcess.start() == LocalSocket连接 => ZygoteServer.runSelectLoop() => ZygoteConnection.processOneCommand() => 
// 源码路径：java/com/android/internal/os/ZygoteConnection.java
Runnable processOneCommand(ZygoteServer zygoteServer) {
...
  //从Zygote孵化一个新进程并赋予 pid
          pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,
                parsedArgs.instructionSet, parsedArgs.appDataDir);

        try {
            if (pid == 0) {
                // in child
                zygoteServer.setForkChild();

                zygoteServer.closeServerSocket();
                IoUtils.closeQuietly(serverPipeFd);
                serverPipeFd = null;

                return handleChildProc(parsedArgs, descriptors, childPipeFd,
                        parsedArgs.startChildZygote);
            } else {
                // In the parent. A pid < 0 indicates a failure and will be handled in
                // handleParentProc.
                IoUtils.closeQuietly(childPipeFd);
                childPipeFd = null;
                handleParentProc(pid, descriptors, serverPipeFd);
                return null;
            }
        } finally {
            IoUtils.closeQuietly(childPipeFd);
            IoUtils.closeQuietly(serverPipeFd);
        }
}
  
=> ZygoteConnection.handleChildProc()
  
private Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors,
            FileDescriptor pipeFd, boolean isZygote) {
  ...
             if (!isZygote) {
                return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,
                        null /* classLoader */);
            } else {
                return ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,
                        parsedArgs.remainingArgs, null /* classLoader */);
            }
}

=> ZygoteInit.zygoteInit()
  
    public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {
        if (RuntimeInit.DEBUG) {
            Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from zygote");
        }

        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ZygoteInit");
        RuntimeInit.redirectLogStreams();

        RuntimeInit.commonInit();
        ZygoteInit.nativeZygoteInit();
        
        return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
    }

=> RuntimeInit.applicationInit()
  
 protected static Runnable applicationInit(int targetSdkVersion, String[] argv,
            ClassLoader classLoader) {
 ...
           // Remaining arguments are passed to the start class's static main
        return findStaticMain(args.startClass, args.startArgs, classLoader);
}

=> RuntimeInit.findStaticMain()//此时完成了对   android.app.ActivityThread.main()的反射调用

      protected static Runnable findStaticMain(String className, String[] argv,
            ClassLoader classLoader) {
        Class<?> cl;
        try {
            cl = Class.forName(className, true, classLoader);
        } catch (ClassNotFoundException ex) {
            throw new RuntimeException(
                    "Missing class when invoking static main " + className,
                    ex);
        }

        Method m;
        try {
            m = cl.getMethod("main", new Class[] { String[].class });
        } catch (NoSuchMethodException ex) {
            throw new RuntimeException(
                    "Missing static main on " + className, ex);
        } catch (SecurityException ex) {
            throw new RuntimeException(
                    "Problem getting static main on " + className, ex);
        }
  ...
}
  
```

拓展：为什么不用Binder而是采用Socket进行 ZygoteProcess与AMS间的通信。

1. `Socket`的调用是root,group是system，相对是安全的
2. `fork()`不支持多线程，可能导致binder调用的时候，多个service发起fork请求，导致部分service创建失败

> Zygote进程孵化出新的应用进程后，通过反射执行`ActivityThread.main()`，在该方法中会事先准备好`Looper以及MessageQueue`，继续调用`attach()`用进程绑定到`AMS`，然后开始消息循环，不断读取队列消息，并分发消息。

```java
// ../android/app/ActivityThread.java
	public static void main(String[] args) {
        //准备主线程Looper 以便Handler调用
        Looper.prepareMainLooper();
        //创建主进程的 ActivityThread
        ActivityThread thread = new ActivityThread();
        //将该进程进行绑定
        thread.attach(false);

        if (sMainThreadHandler == null) {
            //保存进程对应的主线程Handler
            sMainThreadHandler = thread.getHandler();
        }

        // End of event ActivityThreadMain.
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        //主线程开始消息循环
        Looper.loop();
    
  }
  final ApplicationThread mAppThread = new ApplicationThread();
  private void attach(boolean system) {
      ...
        if (!system) {
          ...
            final IActivityManager mgr = ActivityManager.getService();
            try {
                mgr.attachApplication(mAppThread);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        }else{
          ...
        }
      ...
  }
```

`AMS`attach的是`ActivityThread`的代理对象`ApplicationThread`，然后`AMS`就可以通过代理对象对主线程进行操作。

**至此，应用进程创建完毕，并且已建立主线程完毕并开启了消息循环。**

### 创建并绑定Application

这时应用进程以及主线程已经创造完毕，接下来就是要创建`Application`

```java
// ../core/java/com/android/server/am/ActivityManagerService.java
    @Override
    public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
            //获取当前进程的id
            int callingPid = Binder.getCallingPid();
            final long origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid);
            Binder.restoreCallingIdentity(origId);
        }
    }

    private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) {
        
        ProcessRecord app;
        long startTime = SystemClock.uptimeMillis();
        if (pid != MY_PID && pid >= 0) {
            synchronized (mPidsSelfLocked) {
                app = mPidsSelfLocked.get(pid);
            }
        } else {
            app = null;
        }
       // 如果获取进程信息为空 直接杀死进程并退出
       if (app == null) {
            if (pid > 0 && pid != MY_PID) {
                killProcessQuiet(pid);
            } else {
                try {
                    thread.scheduleExit();
                } catch (Exception e) {
                    // Ignore exceptions.
                }
            }
            return false;
        }
        //创建死亡代理，被kill后可以通知AMS
        try {
            AppDeathRecipient adr = new AppDeathRecipient(
                    app, pid, thread);
            thread.asBinder().linkToDeath(adr, 0);
            app.deathRecipient = adr;
        } catch (RemoteException e) {
            app.resetPackageList(mProcessStats);
            startProcessLocked(app, "link fail", processName);
            return false;
        }
      
        try {
         ...
           if (app.instr != null) {
                //绑定Application
                thread.bindApplication(processName, appInfo, providers,
                        app.instr.mClass,
                        profilerInfo, app.instr.mArguments,
                        app.instr.mWatcher,
                        app.instr.mUiAutomationConnection, testMode,
                        mBinderTransactionTrackingEnabled, enableTrackAllocation,
                        isRestrictedBackupMode || !normalMode, app.persistent,
                        new Configuration(getGlobalConfiguration()), app.compat,
                        getCommonServicesLocked(app.isolated),
                        mCoreSettingsObserver.getCoreSettingsLocked(),
                        buildSerial);
            } else {
                thread.bindApplication(processName, appInfo, providers, null, profilerInfo,
                        null, null, null, testMode,
                        mBinderTransactionTrackingEnabled, enableTrackAllocation,
                        isRestrictedBackupMode || !normalMode, app.persistent,
                        new Configuration(getGlobalConfiguration()), app.compat,
                        getCommonServicesLocked(app.isolated),
                        mCoreSettingsObserver.getCoreSettingsLocked(),
                        buildSerial);
            }
        }catch(Exception e){
          ...
          //启动失败 重启当前进程
          startProcessLocked(app, "bind fail", processName);
          return false;
        }
        //准备启动根Activity
         try {
                if (mStackSupervisor.attachApplicationLocked(app)) {
                    didSomething = true;
                }
            } catch (Exception e) {
                Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
                badApp = true;
         }
      
       //绑定Service以及BroadCast的Application
       ...
       if (badApp) {
            //如果以上组件启动出错，则需要杀死进程并移除记录
            app.kill("error during init", true);
            handleAppDiedLocked(app, false, true);
            return false;
        }

        //如果以上没有启动任何组件，那么didSomething为false
        if (!didSomething) {
            //调整进程的oom_adj值， oom_adj相当于一种优先级
            //如果应用进程没有运行任何组件，那么当内存出现不足时，该进程是最先被系统“杀死”
            updateOomAdjLocked();
        }
        return true;

    }

```

在`AMS.attachApplicationLocked()`主要做了两步：

- `thread.bindApplication()`：绑定Application到ActivityThread上

  ```java
  // ../android/app/ActivityThread.java
  public final void bindApplication(String processName, ApplicationInfo appInfo,
                  List<ProviderInfo> providers, ComponentName instrumentationName,
                  ProfilerInfo profilerInfo, Bundle instrumentationArgs,
                  IInstrumentationWatcher instrumentationWatcher,
                  IUiAutomationConnection instrumentationUiConnection, int debugMode,
                  boolean enableBinderTracking, boolean trackAllocation,
                  boolean isRestrictedBackupMode, boolean persistent, Configuration config,
                  CompatibilityInfo compatInfo, Map services, Bundle coreSettings,
                  String buildSerial) {
  
              if (services != null) {
                  // Setup the service cache in the ServiceManager
                  ServiceManager.initServiceCache(services);
              }
  
              setCoreSettings(coreSettings);
  
              AppBindData data = new AppBindData();
              //设置Data参数
              ...
              sendMessage(H.BIND_APPLICATION, data);
          }
  
  private class H extends Handler {
      public static final int BIND_APPLICATION         = 110;
    ...
      public void handleMessage(Message msg) {
              if (DEBUG_MESSAGES) Slog.v(TAG, ">>> handling: " + codeToString(msg.what));
              switch (msg.what) {
                   case BIND_APPLICATION:
                      Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication");
                      AppBindData data = (AppBindData)msg.obj;
                      handleBindApplication(data);
                      Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                      break;
                  ...
              }
      ...
  }
  ```

  > `H`相当于`ApplcationThread`与`ActivityThread`的中间人，其中`AMS与ActivityThread通信靠 ApplicationThread，ActivityThread与ApplicationThread通信靠Handler`。
  >
  > 这里涉及的就是**`Android的主线程消息循环模型`**。

  在`ApplicationThread`发送`BIND_APPLICATION`标识的消息时，`H`接收到消息，调用`handleBindApplication()`

  ```java
  Instrumentation mInstrumentation;
  private void handleBindApplication(AppBindData data) {
    ...
    //获取LoaderApk对象
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    //创建进程对应的Android运行环境ContextImpl
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
    
    final InstrumentationInfo ii;
     if (ii != null) {
       ...
     }else{
       //Activity中所有的生命周期方法都会被Instrumentation监控
       //只要是执行Activity生命周期的相关方法前后一定会调用Instrumentation相关方法
       mInstrumentation = new Instrumentation();
     }
    
    try {
              //准备创建Application对象
              Application app = data.info.makeApplication(data.restrictedBackupMode, null);
              mInitialApplication = app;
              ...
               //加载对应进程中的ContentProvider
              installContentProviders(app, data.providers);
              try {
                  mInstrumentation.onCreate(data.instrumentationArgs);
              }
              catch (Exception e) {
                  throw new RuntimeException(
                      "Exception thrown in onCreate() of "
                      + data.instrumentationName + ": " + e.toString(), e);
              }
  
              try {
                  //调用Application的onCreate方法
                  mInstrumentation.callApplicationOnCreate(app);
              } catch (Exception e) {
                  if (!mInstrumentation.onException(app, e)) {
                      throw new RuntimeException(
                          "Unable to create application " + app.getClass().getName()
                          + ": " + e.toString(), e);
                  }
              }
          } finally {
              StrictMode.setThreadPolicy(savedPolicy);
          }
  }
  ```

  `handleBindApplicaiton()`主要是**为了让一个Java的进程可以加入到Android中**。

  主要执行步骤有以下几步：

  1. 设置进程的基本参数，例如进程名，时区等，配置资源以及兼容性设计。
  2. 创建进程对应的`ContextImpl、LoaderApk以及Application`对象，并初始化`ContentProvide以及Application`。
  3. 创建`Instrumentation`监听Activity的生命周期。(**一个进程对应一个Instrumentation实例**)

- `mStackSuperVisor.attachApplicationLocked()`：启动根Activity

  在该方法中`Application`已经绑定到进程上，接下来就是启动根Activity

  ```java
  // ../core/java/com/android/server/am/ActivityStackSupervisor.java
  boolean attachApplicationLocked(ProcessRecord app) throws RemoteException {
          final String processName = app.processName;
          boolean didSomething = false;
          //ActivityStackSupervisor里面 维护者所有ActiivtyStack
          //通过循环 找到前台任务栈顶端的Activity
          for (int displayNdx = mActivityDisplays.size() - 1; displayNdx >= 0; --displayNdx) {
              ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks;
              for (int stackNdx = stacks.size() - 1; stackNdx >= 0; --stackNdx) {
                  final ActivityStack stack = stacks.get(stackNdx);
                  if (!isFocusedStack(stack)) {
                      continue;
                  }
                  ActivityRecord hr = stack.topRunningActivityLocked();
                  if (hr != null) {
                      //前台待启动的Activity与当前新建的进程一致时，启动这个Actiivty
                      if (hr.app == null && app.uid == hr.info.applicationInfo.uid
                              && processName.equals(hr.processName)) {
                          try {
                              if (realStartActivityLocked(hr, app, true, true)) {
                                  didSomething = true;
                              }
                          } catch (RemoteException e) {
                              throw e;
                          }
                      }
                  }
              }
          }
          if (!didSomething) {
              ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
          }
          return didSomething;
      }
  ```

  需要启动的Activity所在进程已经启动时，开始准备启动根Activity `realStartActivityLocked()`

  ```java
  final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,
              boolean andResume, boolean checkConfig) throws RemoteException {    
    ...
  app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                      System.identityHashCode(r), r.info,
                      // TODO: Have this take the merged configuration instead of separate global and
                      // override configs.
                      mergedConfiguration.getGlobalConfiguration(),
                      mergedConfiguration.getOverrideConfiguration(), r.compat,
                      r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,
                      r.persistentState, results, newIntents, !andResume,
                      mService.isNextTransitionForward(), profilerInfo);
    ...
  }
  ```

  这里的`app.thread`的类型为`IApplicationThread`，它的实现是`ActivityThread`的内部类`ApplicationThread`。`app`指代的是要启动的Acttvity所在的应用进程。因此这段代码指的就是要在目标应用程序进程中启动Activity。

{% fullimage /images/AMS启动进程并绑定Application.png,AMS启动进程并绑定Application,AMS启动进程并绑定Application%}



### ActivityThread启动Activity过程

这时Activity的启动过程从`AMS`切换到了`ApplicationThread`中，最后是调用到了`ApplicationThread.scheduleLaunchActivity()`

```java
// ../android/app/ActivityThread.java        
@Override
        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,
                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,
                int procState, Bundle state, PersistableBundle persistentState,
                List<ResultInfo> pendingResults, List<ReferrerIntent> pendingNewIntents,
                boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {

            updateProcessState(procState, false);

            ActivityClientRecord r = new ActivityClientRecord();

            r.token = token;
            r.ident = ident;
            r.intent = intent;
            r.referrer = referrer;
            r.voiceInteractor = voiceInteractor;
            r.activityInfo = info;
            r.compatInfo = compatInfo;
            r.state = state;
            r.persistentState = persistentState;

            r.pendingResults = pendingResults;
            r.pendingIntents = pendingNewIntents;

            r.startsNotResumed = notResumed;
            r.isForward = isForward;

            r.profilerInfo = profilerInfo;

            r.overrideConfig = overrideConfig;
            updatePendingConfiguration(curConfig);

            sendMessage(H.LAUNCH_ACTIVITY, r);
        }
```

将需要启动Activity的参数封装成`ActivityClientRecord`，在调用`sendMessage()`设置类型为`LAUNCH_ACTIVITY`，并将`ActivityClientRecord`传递过去。

```java
final H mh = new H();
private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {
        if (DEBUG_MESSAGES) Slog.v(
            TAG, "SCHEDULE " + what + " " + mH.codeToString(what)
            + ": " + arg1 + " / " + obj);
        Message msg = Message.obtain();
        msg.what = what;
        msg.obj = obj;
        msg.arg1 = arg1;
        msg.arg2 = arg2;
        if (async) {
            msg.setAsynchronous(true);
        }
        mH.sendMessage(msg);
    }
```

这里的`mh`指的就是`H`，这个`H`是`ActivityThread`的内部类并继承自`Handler`，是主线程的消息管理类。因为`ApplicationThread`是一个Binder，它的调用逻辑是在`Binder线程池`中。所以这里就要把执行逻辑切换到主线程中，就使用了`Handler`。

```java
private class H extends Handler {
 public static final int LAUNCH_ACTIVITY         = 100;
  ...
    public void handleMessage(Message msg) {
            if (DEBUG_MESSAGES) Slog.v(TAG, ">>> handling: " + codeToString(msg.what));
            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");
                    //将传递过来的msg.obj转化为ActivityClientRecord
                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                    // 获得LoaderApk类型的对象并赋值到ActivityClientRecoed中
                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null, "LAUNCH_ACTIVITY");
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;
                ...
            }
    ...
}
```

> 每一个Android程序都是打包在一个Apk文件中的，一个Apk文件包含了一个Android程序中的所有资源。应用程序进程在启动一个Activity组件时，需要将它所属的Apk文件加载进来，以便访问内部资源。`ActivityThread`内部使用`LoaderApk`描述一个已加载的Apk文件。

继续向下调用到`handleLauncheActivity()`

```java
 private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
 ...
   //Window开始初始化
   WindowManagerGlobal.initialize();
   //准备启动Activity
   Activity a = performLaunchActivity(r, customIntent);

   if (a != null) {
            r.createdConfig = new Configuration(mConfiguration);
            reportSizeConfigurations(r);
            Bundle oldState = r.state;
            //将要启动的Activity状态设为 Resumed 标记待激活
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
            if (!r.activity.mFinished && r.startsNotResumed) {
                performPauseActivityIfNeeded(r, reason);
                if (r.isPreHoneycomb()) {
                    r.state = oldState;
                }
            }
        } else {
            // If there was an error, for any reason, tell the activity manager to stop us.
            try {
                //停止Activity启动
                ActivityManager.getService()
                    .finishActivity(r.token, Activity.RESULT_CANCELED, null,
                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        }   
 }
```

首先调用`performLaunchActivity()`开始准备启动Activity，内部会调用Activity的`Oncreate(),onStart(),onRestoreInstaceState()`

`performResumeActivity()`对应生命周期的`onResume()`，之后开始调用View的绘制，Activity的内容开始渲染到Window上面，直到我们看见绘制结果。

```java
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
  ...
}
```

`performLaunchActivity()`主要完成了如下几件事：

1. 从`ActivityClientRecord`中获取待启动的Activity的组件信息

   ```java
    ActivityInfo aInfo = r.activityInfo;
           if (r.packageInfo == null) {
               //获取LoadedApk对象
               r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                       Context.CONTEXT_INCLUDE_CODE);
           }
           //获取组件信息
           ComponentName component = r.intent.getComponent();
           if (component == null) {
               component = r.intent.resolveActivity(
                   mInitialApplication.getPackageManager());
               r.intent.setComponent(component);
           }
   
           if (r.activityInfo.targetActivity != null) {
               component = new ComponentName(r.activityInfo.packageName,
                       r.activityInfo.targetActivity);
           }
   ```

   `ComponentName`包含了`Activity组件的包名及类名。`

2. 通过`Instrumentation.newActivity()`使用类加载器创建Activity对象

   ```java
    Activity activity = null;
           try {
               java.lang.ClassLoader cl = appContext.getClassLoader();
               //用类加载器创建该Activity的实例
               activity = mInstrumentation.newActivity(
                       cl, component.getClassName(), r.intent);
               StrictMode.incrementExpectedActivityCount(activity.getClass());
               r.intent.setExtrasClassLoader(cl);
               r.intent.prepareToEnterProcess();
               if (r.state != null) {
                   r.state.setClassLoader(cl);
               }
           } catch (Exception e) {
             ...
           }
   ```

   ```java
   // ../android/app/Instrumentation.java   
   public Activity newActivity(ClassLoader cl, String className,
               Intent intent)
               throws InstantiationException, IllegalAccessException,
               ClassNotFoundException {
           return (Activity)cl.loadClass(className).newInstance();
       }
   ```

3. 通过`LoadedApk.makeApplication()`创建Application对象（*实际是判空*）

   ```java
   Application app = r.packageInfo.makeApplication(false, mInstrumentation);
   
   // ../android/app/LoaderApk.java
       public Application makeApplication(boolean forceDefaultAppClass,
               Instrumentation instrumentation) {
           if (mApplication != null) {
               return mApplication;
           }
         
         //新建Application
         try {
               java.lang.ClassLoader cl = getClassLoader();
               if (!mPackageName.equals("android")) {
                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,
                           "initializeJavaContextClassLoader");
                   initializeJavaContextClassLoader();
                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
               }
               ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
               app = mActivityThread.mInstrumentation.newApplication(
                       cl, appClass, appContext);
               appContext.setOuterContext(app);
           } catch (Exception e) {
               if (!mActivityThread.mInstrumentation.onException(app, e)) {
                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                   throw new RuntimeException(
                       "Unable to instantiate application " + appClass
                       + ": " + e.toString(), e);
               }
           }
           mActivityThread.mAllApplications.add(app);
           mApplication = app;
       }
   ```

   由于在前面`创建并绑定Application`过程中的`bindApplication()`就已经创建好了`Application`，所以这一步只是起到了预防作用，并且不会重复创建。

4. 创建`ContextImpl`对象，并通过`Activity.attach()`完成一些重要数据的初始化

   ```java
   ContextImpl appContext = createBaseContextForActivity(r);
   appContext.setOuterContext(activity);
                   activity.attach(appContext, this, getInstrumentation(), r.token,
                           r.ident, app, r.intent, r.activityInfo, title, r.parent,
                           r.embeddedID, r.lastNonConfigurationInstances, config,
                           r.referrer, r.voiceInteractor, window, r.configCallback);
   
   ```

   > `ContextImpl`是一个很重要的数据结构，它是`Context`的具体实现，Context中大部分逻辑都是由`ContextImpl`完成的。`ContextImpl`是通过`Activity.attach()`与Activity进行关联的。除此之外，在`attach()`中，**Activity还会完成Window的创建并建立关联**，这样当Window接收到外部输入事件以后就可以将事件传递给Activity。

5. 调用`Activity.oncreate()`加载用户界面

   ```java
   mInstrumentation.callActivityOnCreate(activity, r.state);
   
   mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
                                       r.persistentState);
   
   mInstrumentation.callActivityOnPostCreate(activity, r.state,
                                   r.persistentState);
   
   // ../android/app/Instrumentation.java  
   public void callActivityOnCreate(Activity activity, Bundle icicle) {
           prePerformCreate(activity);
           activity.performCreate(icicle);
           postPerformCreate(activity);
       }
   
   // ../android/app/Activity.java
   final void performCreate(Bundle icicle) {
           restoreHasCurrentPermissionRequest(icicle);
           onCreate(icicle);
           mActivityTransitionState.readState(icicle);
           performCreateCommon();
       }
   ```

   最终调用到`Activity.performCreate()`后续调用到`Activity.onCreate()`这时根Activity就启动了，完成了整个启动流程。

{% fullimage /images/ActivityThread启动Activity过程.png,ActivityThread启动Activity过程,ActivityThread启动Activity过程%}

### 根Activity启动过程中涉及的进程

根Activity启动过程中涉及四个进程：**Zygote进程、Launcher进程、AMS所在进程（System Server进程），应用程序进程。**

{% fullimage /images/根启动Activity过程中的进程切换.png,根启动Activity过程中的进程切换,根启动Activity过程中的进程切换%}

> 首先`Launcher进程`会向`AMS`发起`创建根Activity请求`，`AMS`会判断根Activity所需的应用程序进程是否存在并处于启动状态
>
> - `未启动`：请求`Zygote进程`创建应用程序进程
> - `已启动`：`AMS`直接启动Activity

###  总结

经过上述章节的描述，可以基本厘清`根Activity的启动过程`

> 当我们按下桌面上的应用程序快捷启动方式时，`Launcher`会调用`Activity.startActivity()`并设置启动FLAG为`FLAG_ACTIVITY_NEW_TASK`给根Activity设置任务栈，实质上是调用`Instrumentation.execStartActivity()`尝试启动Activity，这是一个跨进程的过程，利用`IActivityManager`与`AMS`进行通信。
>
> `AMS`就会记录下要启动的Activity信息，并且跨进程通知Launcher进入`pause`状态，`Launcher`进入`pause`状态后，跨进程通知`AMS`自己已被`pause`。`AMS`会回调用自身的`startActivty()`去继续启动根Activity，这一步需要校验(调用者是否有权限调用)，检验通过后，发现此时应用进程尚未启动，`AMS`就会启动新的进程，并且在新进程中创建`ActivityThread`对象并执行`main()`进程初始化。
>
> 应用进程启动完毕后，`AMS`通知主线程绑定`Application`并启动根Activity。这时`AMS`会通过`ApplicationThread`回调到我们的进程，这一步也是一个跨进程的过程，利用`ApplicationThread`这个Binder对象。由于回调逻辑是在`Binder线程池`中进行的，所以需要通过`Handler H`将其切回主线程，发出的消息是`LAUNCH_ACTIVITY`，对应调用`handleLaunchActivity`，在这个方法中完成了根Activity的创建以及启动。接着在`handleResumeActivity()`中开始Activity的内容绘制，直到绘制完成被我们看见。

## 普通Activity启动过程

{% fullimage /images/普通Activity启动过程.png,普通Activity启动过程,普通Activity启动过程%}

> 普通Activity启动过程相比于根Activity启动过程，只保留了两步：`AMS到Application的调用过程`,`ActivityThread启动Activity过程`。
>
> 涉及的进程也只剩：`AMS所在进程(System Server进程)，应用程序进程`。

### 相同进程的启动过程

> 例如LoadingActivity -> MainActivity

1. LoadingActivity组件会向`AMS`发送一个启动MainActivity的请求，其实就是内部通过`Instrumentation`尝试启动Activity(`execStartActivity`)，这是一个跨进程过程，会调用`AMS`的`startActivity()`
2. `AMS`会保存下来`MainActivity`的组件信息，然后向`LoadingActivity`发送一个进入中止状态的进程间通信请求。*这也就是为什么老Activity的`onPause()`会执行在新Activity的启动之前的原因。*
3. `LoadingActivity`进入中止状态后会通知到`AMS`继续向下执行`MainActivity`的启动，由于发现应用进程已经存在，所以`AMS`直接通过`ApplicationThread`回调到应用进程，这也是一个跨进程过程。
4. 由于`ApplicationThread`是一个Binder对象，回调逻辑在`Binder线程池`中完成，需要通过`Handler H`切回到主线程，并发出`LAUNCH_ACTIVITY`消息，对应调用`handleLaunchActivity`。
5. 继续向下完成`MainActivity`的创建和启动，然后在`handleResumeActivity()`中完成View的绘制，直到绘制完成展示在用户面前结束。

### 新进程的启动过程

> 例如LoadingActivity -> MainActivity设置了`android:process=":remote"`
>
> 类似根Activity的启动过程，不过起始点是从`LoadingActivity`开始

1. LoadingActivity组件会向`AMS`发送一个启动MainActivity的请求，其实就是内部通过`Instrumentation`尝试启动Activity(`execStartActivity`)，这是一个跨进程过程，会调用`AMS`的`startActivity()`
2. `AMS`会保存下来`MainActivity`的组件信息，然后向`LoadingActivity`发送一个进入中止状态的进程间通信请求。*这也就是为什么老Activity的`onPause()`会执行在新Activity的启动之前的原因。*
3. `LoadingActivity`进入中止状态后会通知到`AMS`继续向下执行`MainActivity`的启动，此时发现用来运行的`:remote`进程不存在，就会调用`AMS`去启动新的应用进程，并且在新进程中创建`ActrivityThread(*主进程*)`并执行`main()`进行初始化。
4. 应用进程启动完毕之后，向`AMS`发送一个启动完成的请求，`AMS`就会通知主线程`ActivityThread`去创建并绑定`Application`，绑定完成后，通知`AMS`绑定完成。`AMS`直接通过`ApplicationThread`回调到应用进程，这也是一个跨进程过程。
5. 由于`ApplicationThread`是一个Binder对象，回调逻辑在`Binder线程池`中完成，需要通过`Handler H`切回到主线程，并发出`LAUNCH_ACTIVITY`消息，对应调用`handleLaunchActivity`。
6. <!--App启动优化，如何检测启动耗时 -->





临时记录：

Andorid 9.0 源码添加了Sleeping状态，功能类似Stop

handleSleeping() 可能导致 onSaveInstanceState()存储异常]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity的生命周期和启动模式</title>
    <url>/2019/01/04/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[
# Activity的生命周期和启动模式

<!--standard，singleTop，singleTask，singleInstance  什么时候会用到singleTask？Activity之间的通信方式 横竖屏切换的时候，Activity 各种情况下的生命周期 Activity上有Dialog的时候按Home键时的生命周期 两个Activity 之间跳转时必然会执行的是哪几个方法？activity栈 下拉状态栏是不是影响activity的生命周期，如果在onStop的时候做了网络请求，onResume的时候怎么恢复-->



{% fullimage /images/Activity生命周期和启动模式.png,Activity生命周期和启动模式,Activity生命周期和启动模式 %}

<!-- more -->

## Activity的生命周期

{% fullimage /images/study_plan/activity_lifecycle.jpeg, Activity生命周期,Activity生命周期 %}

### 正常情况下的Activity生命周期

正常情况下，Activity会经历如下生命周期

#### onCreate(Bundle savedInstanceState) --创建

> **表示Activity正在被创建，是生命周期的第一个方法**
>
> 可以做一些初始化工作，调用`setContentView()`加载布局，初始化Activity需要的数据
>
> *onCreate 入参的 savedInstanceState其实就是 由于Activity异常销毁存储下来的数据*

#### onRestart() -- 重启

> **表示Activity正在重新启动，当当前Activity从不可见切换到可见时，就会触发**
>
> 随后就会调用到`onStart()`方法

#### onStart() -- 可见

> **表示Activity正在启动，这时Activity已经可见了，但没有出现在前台无法与用户交互**

#### onResume() --可交互

> **表示Activity已经可见了，并且出现在前台且可以与用户交互。**

#### onPause() -- 不可交互

> **表示Activity正在停止，此时可以做一些`存储数据、停止动画`等操作**
>
> *`onPause` 中不能执行过于耗时操作，会影响到下一个新Activity的显示。旧Activity必须执行完`onPause()`后，新Activity的`onResume()`才可以执行。*

#### onStop() -- 不可见

> **表示Activity即将停止，此时Activity已经不可见，可以做一些稍微重量级的回收工作(`取消网络连接，注销广播监听器等`)，同样不能太耗时。**
>
> *当新Activity为透明主题即旧Activity依然可见，或者弹出一个框，都不会执行旧Activity的`onStop()`*

#### onDestroy() -- 销毁

> **表示Activity即将被销毁，这时可以做一些回收工作以及资源的释放。**

拓展

*Activity在处于`onPause(),onStop(),onDestroy()`状态下，进程优先级较低，容易被回收，所以需要保存一些数据时，<font color = 'red'>必须在onPause中存储</font>，其他两个周期不一定能调用到。*

### Activity生命周期的阶段

可以分为以下3个阶段：

- 完整生命周期

  > 从`onCreate() 初始化`开始直到`onDestroy() 释放资源`结束

- 可见生命周期

  > 从`onStart() 可见`到`onStop() 不可见`结束

- 前台生命周期

  > 从`onResume() 可交互`到`onPause() 无法交互`结束

### Activity生命周期的切换过程

- 启动Activity

  `onCreate() -> onStart() -> onResume()`

- 打开新的Activity

  `旧Activity.onPause() -> Activity.onCreate() -> Activity.onStart() -> Activity.onResume()-> 旧Activity.onStop()`

- 返回上一个Activity

  `新Activity.onPause() -> 旧Activity.onRestart() -> 旧Activity.onStart() -> 旧Activity.onResume() -> 新Activity.onStop() -> 新Activity.onDestroy()`

- 弹出对话框

  - 自身调用弹出  `不会有生命周期变化`
  - 外部调用弹出  `当前Activity.onPause()`

- 关闭屏幕/按Home键

  - `onPause() -> onStop()`
  - 新Activity显示，旧Activity依然可见 `新Activity.onPause() -> 新Activity.onStop() -> 旧Activity.onStop()`

- 点亮屏幕/回到应用

  - `onRestart() -> onStart() -> onResume()`
  - 新Activity显示，旧Activity依然可见 `新Activity.onRestart() -> 新Acticvity.onStart() -> 旧Activity.onRestart() ->旧Activity.onStart() -> 新Activity.onResume()`

- 销毁Activity

  - `onPause() -> onStop() -> onDestroy()`
  - 新Activity显示，旧Activity依然可见，销毁新Acticvity `新Activity.onPause() -> 旧Activity.onResume() -> 旧Activity.onStop() -> 旧Activity.onDestroy()`

- 弹出对话框样式的Activity

  `旧Activity.onPause() -> 新Activity.onCreate() -> 新Activity.onStart() -> 新Activity.onResume()`

- 状态栏下拉

  `不会有生命周期变化,如果需要监听可以 使用 onWindowFocusChanged()`

- 横竖屏切换下的生命周期

  这是一个 销毁重建的过程

  `onPause() -> onStop() -> onDestroy() -> onCreate() -> onStart() -> onResume()`

### 异常情况下的生命周期分析

> Activity除了上述正常情况下执行的生命周期调度，还会有一些异常情况会导致Activity被杀死。
>
> 例如在执行到`onPause()`或`onStop()`时，Activity进入了Finish状态，表示被异常终止。

#### 由于资源相关的系统配置发生改变导致Activity被杀死并重新构建

例如：当Activity发生横竖屏切换时，发了系统配置的改变，在默认情况下Activity就会被销毁并重建。

> 如何避免配置改变导致Activity重新创建？
>
> 可以在`AndroidManifest.xml`中指定对应的系统属性，这样在触发对应改变时，不会再杀死并重建，会调用到`onConfigurationChanged()`，只需重写该方法即可。
>
> 例如配置了`android:configChanges="orientation"`，横竖屏切换时就不会触发重建。

#### 由于系统资源不足，导致优先级低的Activity被杀死

这里需要先了解Activity的优先级情况。按照从高到低分为以下三种：

1. **前台Activity**：正在和用户交互的Activity
2. **可见但非前台Activity**：前台的Activity弹出一个Dialog，导致无法交互
3. **后台Activity**：已经被暂停的Activity，比如切到后台或者切换应用

**当系统内存不足时，系统就会按照上述描述的优先级去杀死目标Activity所在进程。**

如果一个进程中没有四大组件在执行，进程很快被系统杀死。



当上述两种情况发生时，Activity的生命周期会发生如下变化：

- Activity被杀死：`onPause() -> onSaveInstanceState() -> onStop() -> onDestroy()`

  系统异常终止时，调用`onSaveInstanceState()`保存数据。该方法调用在`onStop()`之前。

  保存数据过程是利用一种`委托`的思想，上层委托下层。

- Activity重建：`onCreate() -> onStart() -> onRestoreInstanceState() -> onResume()`

  重新创建时，调用`onRestoreInstanceState()`，调用在`onStart()`之后，该方法会把`onSaveInstanceState()`存储的Bundle对象拿出来解析。

  *`onCreate和onRestoreInstanceState`都可以获取存储的对象，推荐使用`onRestoreInstanceState`不需要额外的去判断是否为空。*

**系统只有在异常终止的情况下才会调用`onSaveInstanceState和onRestoreInstanceState`进行存储和恢复数据。**

拓展：

1. 还有一些会在Activity运行过程中的触发方法，这里简单的提及一下：
   - `onPostCreate()`：在`onCreate()`执行完毕后回调
   - `onUserInteraction()`：所有Activity上的触摸事件 优先调用该方法
   - `onUserLeaveHint()`：用户主动离开Activity调用该方法，例如点击Home
   - `onContentChanged()`：Activity 调用`setContentView()`完成后调用

## Activity的启动模式

### Activity的任务栈

> 当我们多次启动一个Activity的时候，系统会创建多个实例并放入任务栈中，当我们触发`finish`时，Activity会一一回退。**任务栈是一种先进后出的栈结构。**
>
> 任务栈又分为`前台任务栈`和`后台任务栈`。`后台任务栈`中的Activity位于暂停状态.

- 程序在创建时就会创建一个Activity任务栈，存储当前程序的Activity
- 任务栈是Activity的集合，只有位于栈顶的Activity可以和用户交互
- 任务栈可以移动到后台并保留了Activity的状态
- 退出应用程序时，任务栈会被清空，然后会被系统回收。

利用`adb shell dumpsys activity`查看当前任务栈

### Activity的LaunchMode

> LaunchMode为了减少Activity实例的创建优化

使用方法：

- 在`AndroidManifest.xml`中给对应Activity配置属性 `android:launchMode="standard | singltTop | singleTask | singleInstance"`
- `startActivity`时添加`intent.addFlags(FLAG)`

#### standard 标准模式(默认这个)

> 每次启动一个新的Activity都会创建一个新的Activity实例。
>
> *若启动Activity的是除了Activity之外的context对象就需要指定`FLAG_ACTIVITY_NEW_TASK`标记位，创建一个新的任务栈。因为standard默认进入启动方的任务栈，由于他们是没有自身的任务栈，所以需要新建。*

{% fullimage /images/study_plan/launchmode_standard.png, alt,Standard %}

#### singleTop 栈顶复用模式

> 如果要启动的Activity位于栈顶，就不会重新创建，并且调用`onNewIntent(Intent intent)`取出当前请求的信息。
>
> *还会调用`onPause()以及onResume()`。*

{% fullimage /images/study_plan/launchmode_singletop.png, alt,SingleTop %}

A位于栈顶，B位于栈底。如果A的启动模式为`singleTop`，再次启动A，栈内情况不会发生变化，依然为AB

如果启动B，则会创建新的实例，不论是否为`singleTop`。

#### singleTask 栈内复用模式

> 栈内只要存在Activity实例，再次启动都不会重新创建实例，只会回调`onNewIntent()`，并从栈内弹出该实例上的所有Activity。
>
> 适合作为应用主入口，因为只会启动一次。

列举3个实例加深理解：

- {% fullimage /images/study_plan/launchmode_singletask3.png, alt, SingleTask %}

  目前S1中由ABC三个实例，这时D以`singleTask`模式请求启动且所需任务栈为`S2`，由于`S2`和`D`实例均不存在，所以系统会创建`S2`任务栈并把实例`D`入栈到`S2`。

- {% fullimage /images/study_plan/launchmode_singletask1.png, alt,SingleTask %}

  目前S1中由ABC三个实例，这时D以`singleTask`模式请求启动且所需任务栈为`S1`，由于`S1`已经存在，所以直接入栈并置于栈顶。

- {% fullimage /images/study_plan/launchmode_singletask2.png, alt, SingleTask %}

  目前S1中由ABCD四个实例，这时B以`singleTask`模式请求启动且所需任务栈为`S1`，此时B不会重新创建，将直接回调`onNewIntent()`并置于栈顶。*原先位于B实例上的CD都被清除，因为默认具有clear_top 效果，最终就变成了AB*

#### singleInstance 单实例模式

> 加强的singleTask模式，除了singleTask拥有的特性外，还加强了一点。使用了这个模式启动的Activity只能单独的位于一个任务栈中。启动时会新开一个任务栈并直接创建实例压入栈中。
>
> *即使设置了相同的任务栈名，也不能放在一个栈中。*

#### TaskAffinity -- 栈亲和性

> taskAffinity：标识了一个Activity所需要任务栈的名字，默认情况下，所有Activity所需的任务栈名字为应用的包名。我们也可以为每个Activity指定任务栈，利用`android:taskAffinity`属性标记。

- 配合`singleTask`使用

  新Activity启动时默认被加载进启动该Activity的对象所在任务栈中。如果给启动的Activity设置`FLAG_ACTIVITY_NEW_TASK`标记或者设置`singleTask`启动模式，再配合`taskAffinity`设置任务栈名字，该实例就会被加载进相同名字的任务栈中，如果不存在相同就创建新的任务栈并压入实例。

- 配合`allowTaskReparenting`使用

  > allowTaskReparenting 作用是 是否允许Activity更换从属任务。true表示可以更换，默认为false

  简单描述： 有两个APP，A和B，此时应用A去启动应用B中的一个Activity，并且该Activity设置`allowTaskReparenting = true`，此时这个Activity的任务栈就会位于应用A中，当去启动B时，会优先展示已被启动的Activity，由于设置了`allowTaskReparenting`该Activity的任务栈又回到了B中。

  <!--？？？ allowTaskReparenting = true 且两个Activity的TaskAffinity 相同会如何-->

> 拓展知识：
>
> 

### Activity的行为标志和属性

#### Activity的Flag

> 有些标记位可以设置启动模式，还有的可以影响Activity的运行状态。

##### FLAG_ACTIVITY_NEW_TASK

> 作用等同 `singleTask`启动模式

##### FLAG_ACTIVITY_SINGLE_TOP

> 作用等同`singleTop`启动模式

##### FLAG_ACTIVITY_CLEAR_TOP

> 当用这个标记启动对应Activity时，在同一个任务栈中的且位于它上面的Activity实例都会被消除。一般配合`singleTask`使用

##### FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS

> 对应的配置为在`AndroidManifest.xml`中使用`android:excludeFromRecents="true"`
>
> 具有这个标记的Activity不会出现在后台任务列表中

#### IntenFilter的匹配规则

> 启动Activity方法分为两种：`显式调用(可以清楚指出被启动组件的信息，例如类名)`，`隐式调用(没有明确的指出组件信息，通过IntentFilter找到符合要求的组件)`。

匹配规则：

1. 一个intent只有同时匹配某个Activity定义的`<intent-filter>`中定义的`action,category,data`才可以完全匹配，打开对应的Activity
2. 一个Activity可以定义多个<intent-filter>，只要匹配任意一组就可以启动该Activity

##### action匹配规则

> 只要传递过来的Intent中定义的`action`可以匹配`<intent-filter>`定义的任一`action`，必须要完全相同且区分大小写。

##### category匹配规则

> 传递过来的Intent中不包含`categroy`，那么就会启用默认的`categroy`，由于系统在启动Activity的时候默认会加上`android.intent.categroy.DEFAULT`属性
>
> 如果包含`categroy`，那必须匹配`<intent-filter>`定义的任一`categroy`

##### data匹配规则

> 传递过来的Intent定义的`data`可以匹配`<intent-filter>`定义的任一`data`

data主要分为两部分：

- `mimeType`：媒体类型，例如`text/plain`这类，还包括图片，视频类型
- `URL`：地址 包含了`host(主机名)，scheme(模式)，port(端口号)，path(路径信息)`等



*隐式启动时，如果无法找到要启动的组件，就会抛出异常。我们就可以利用`PackageManager.resolveActivity()`或者`Intent.resolveActivity()`避免异常出现。*

#### 清理任务栈

> 当用户离开一个任务时间很长时，系统将会清除除了根Activity之外的所有Activity，当用户重新回到应用时，只能看到根Activity。

系统提供了几种机制来调整这个规则：

- `android:alwaysRetainTaskState`

  标记应用的Task是否保持原来的状态，若为`true`，系统尝试保留所有Activity

- `android:clearTaskOnLaunch`

  标记是否从Task清除所有Activity除了根Activity，用户每次重新打开只会看到根Activity

- `android:finishOnTaskLaunch`

  只作用于单个Activity，若设置true，用户离开后回来就会消失



### 启动模式源码分析

> 关键节点在 `ActivityStarter.java`类下



### standard



### singleTop



### singleTask



### singleInstance



## 拓展

1. 何时会调用`onNewIntent()`?

   - LaunchMode设置为`singleTop`，且要启动的Activity已经处于栈顶
   - LaunchMode设置为`singleTask`或者`singleInstance`，且实例已存在

   需要注意的是：*当调用到`onNewIntent(intent)`的时候，需要在内部调用`setNewIntent(intent)`赋值给当前Activity的Intent，否则后续的getIntent()得到的都是老Intent*
   
2. 监控应用回到桌面或者应用退出

   ```java
    registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
               int createdActivityCount = 0;
               int startedActivityCount = 0;
   
               @Override
               public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
                   createdActivityCount++;
               }
   
               @Override
               public void onActivityStarted(Activity activity) {
                   startedActivityCount++;
               }
   
               @Override
               public void onActivityResumed(Activity activity) {
   
               }
   
               @Override
               public void onActivityPaused(Activity activity) {
   
               }
   
               @Override
               public void onActivityStopped(Activity activity) {
                   startedActivityCount--;
                   // isChangingConfigurations 避免因为应用配置变化导致的退出使统计失误
                   if (startedActivityCount == 0 && !activity.isChangingConfigurations() && !activity.isFinishing()) {
                       Log.e("Home", "回到桌面");
                   }
               }
   
               @Override
               public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
   
               }
   
               @Override
               public void onActivityDestroyed(Activity activity) {
                   createdActivityCount--;
                   if (createdActivityCount == 0 && !activity.isChangingConfigurations()) {
                       Log.e("Exit", "应用退出");
                   }
               }
           });
   ```

   

3. s]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程相关合集整理</title>
    <url>/2020/05/02/Java%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%90%88%E9%9B%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[
## 基础概念

### 进程

> 应用程序在内存中分配的空间，也就是正在运行的程序。进程是系统运行程序的基本单位。

CPU采用`时间片轮转`的方式运行进程：CPU为每个进程分配一个时间段，称作它的时间片。

如果在这个时间片结束进程还在进行，则暂停这个进程的运行，并且CPU会被分配到另一个进程(**上下文切换**)。

进程让操作系统的并发成为了可能。`进程就是程序的实体`。

### 线程

> 线程与进程类似，但线程比进程更小，是CPU调度和分配的基本单位。一个进程在其执行的过程中可以产生多个线程。

线程让进程内部并发成为了可能。

#### 与进程的区别

- `进程`是一个独立的运行环境，线程只是在进程中执行的一个任务。本质区别是**是否单独占有内存地址空间和其他系统资源。**
- `进程`间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互相不干扰；`线程`共享进程的数据，同步复杂。
- `进程`崩溃不会影响其他进程，不会影响主进程的稳定性；线程崩溃影响整个进程的稳定性，可靠性较低。
- `进程`创建和销毁需要保存`寄存器和栈信息`，还需要资源的回收和调度，开销较大；`线程`只需要保存`寄存器和栈信息`，开销较小。

### 多进程

> 每个进程拥有独立的资源，每个进程在单核处理器并发执行，在多核处理器并行执行。

### 多线程

> 一个进程可以包含多个线程，多个线程共享进程资源。可以合理利用CPU资源。

相比于`多进程`有如下好处：

- 进程间通信比较复杂，线程间的通信相对简单，通常情况下，进程共享资源的使用比较简单。
- 进程是重量级的，线程是轻量级的，系统开销更小。

### 并发

> 同一时间段，多个任务都在执行。`多个任务交替执行，也可能串行执行。`

### 并行

> 同一时间段，多个任务同时执行，只有多核处理器可以做到。



### 上下文切换

> CPU从一个进程(线程)切换到另一个进程(线程)，需要先存储当前进程(线程)的状态，然后载入另一个进程(线程)的数据，然后开始执行另一个进程(线程)。
>
> `上下文`指的就是切换时需要保存的数据，例如**本地数据，程序指针等**。

CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行完一个时间片后切换到下一个任务。*如果线程在时间片结束前阻塞或结束，则CPU立即进行切换。*

`上下文切换`通常是`计算密集型`的，意味着**消耗大量的CPU时间，线程越多造成的压力越大。**

#### 计算机密集型(CPU密集型)

> 进行大量的计算，消耗CPU资源。

#### IO密集型

> 涉及到网络、磁盘IO的任务较多，CPU消耗较少。





## 线程相关

### 使用线程

#### 继承Thread类

```Java
public class ThreadTest extends Thread{
    public void run(){
        System.out.println("Hello Thread");
    }
    
    public static void main(String[] args){
        Thread thread = new ThreadTest();
        thread.start();
    }
}
```

**调用`start()`后线程才算启动。**如果只调用`run()`就是普通的方法调用。

> 调用了`start()`后，虚拟机会先创建一个线程，当线程获取`时间片`后再调用`run()`。
>
> **不可多次调用`start()`，否则后续调用会抛出异常`java.lang.IllegalThreadStateException`。**

#### 实现Runnable接口

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}

public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
```

调用`start()`后线程才算启动。

#### 实现Callable接口

> 需要重写`call()`并配合`Future`或`FutureTask`使用。

```java
class Task implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        // 模拟计算需要一秒
        Thread.sleep(1000);
        return 2;
    }
    public static void main(String args[]){
        // 使用
        ExecutorService executor = Executors.newCachedThreadPool();
        Task task = new Task();
        Future<Integer> result = executor.submit(task);
        // 注意调用get方法会阻塞当前线程，直到得到结果。
        // 所以实际编码中建议使用可以设置超时时间的重载get方法。
        System.out.println(result.get()); 
    }
}
```

`Callable`一般配合`ExecutorService`来使用的，可以返回`call()`结果。



##### Future接口

```java
public interface Future<V> {
    //试图取消任务的执行。mayInterruptIfRunning确定是否应该以试图停止任务的方式中断执行任务流程。true 直接中断 false等待执行完成 
    boolean cancel(boolean mayInterruptIfRunning);
    //任务正常完成前将其取消，返回true
    boolean isCancelled();
    //任务已完成或者因为正常终止、异常，取消而完成，返回true
    boolean isDone();
    //等待计算结果的返回，如果被取消则抛出异常
    V get() throws InterruptedException, ExecutionException;
    //设定执行时间，超过时间则抛出Timeout异常
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

通过`Callable`可以得到一个`Future`对象，表示异步计算的结果。

##### FutureTask

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```

`FutureTask`实现了`RunnableFuture`接口，`FutureTask`可以简化使用。

| 方式             | 优点                                                         | 缺点                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 继承Thread类     | 编写简单，可以使用`this`直接访问当前线程                     | 1.受限于Java类的单继承，无法继承其他类；<br>2.多个线程之间无法共享方法或实例变量 |
| 实现Runnable接口 | 多个线程可共享一个实现了`Runnable`接口的类，非常适合多个线程处理同一任务 | 1.`run()`没有返回值<br/>2.不能直接捕获运行过程中的异常，需要使用`setDefaultUncaughtExceptionHandler()`捕获子线程的异常 |
| 实现Callable接口 | 多个线程可共享一个实现了`Callable`接口的类，非常适合多个线程处理同一任务；可以有返回值；可以抛出异常 | 编写略微复杂，要访问当前线程需要使用`Thread.currentThread()` |

### 线程状态

{% fullimage /images/Thread-State.png,线程状态,线程状态%}

如上图所示，线程共有6种状态

#### NEW(新建状态)

线程此时尚未启动，还未调用`Thread.start()`

> 反复调用`start()`会抛出`IllegalThreadStateException`，就算线程执行完毕，进入`Terminated`状态，也无法调用`start()`重新启动线程。
>
> ```java
> public synchronized void start() {
>   //第一次start之后，threadStatus不为0，后续再次调用出错
>     if (threadStatus != 0)
>         throw new IllegalThreadStateException();
> 
>     group.add(this);
> 
>     boolean started = false;
>     try {
>         start0();
>         started = true;
>     } finally {
>         try {
>             if (!started) {
>                 group.threadStartFailed(this);
>             }
>         } catch (Throwable ignore) {
> 
>         }
>     }
> }
> ```

#### RUNNABLE(可运行状态)

当前线程正在运行中，也可能等待其他系统资源(IO资源)，资源调度完成就进入运行状态。

**可以被运行，无法知道是否正在运行。**

包含`Ready`和`running`两个状态。



#### BLOCKED(阻塞状态)

当前线程被阻塞，等待其他线程释放锁(`monitor lock`)，暂时不能运行。



#### WAITING(无限期等待状态)

当前线程处于等待状态，需要其他线程显式唤醒。

与`BLOCKED`的区别在于，`阻塞`是被动的，`等待`是主动的。

调用如下方法可以进入`WAITING`状态

| 进入`WAITING`状态  | 退出`WAITING`状态                  |
| ------------------ | ---------------------------------- |
| Object.wait()      | Object.notify()/Object.notifyAll() |
| Thread.join()      | 被调用的线程执行完毕               |
| LockSupport.park() | LockSupport.unpark(thread)         |



#### TIMED_WAITING(超时等待状态)

当前线程等待一个具体时间，时间到后会被系统自动唤醒。

与`WAITING`的区别在于，`TIMED_WAITING`是有限时间的等待。

调用如下方法可以进入`TIMED_WAITING`状态

| 进入`TIMED_WAITING`状态              | 退出`TIMED_WAITING`状态                           |
| ------------------------------------ | ------------------------------------------------- |
| Thread.sleep(long mills)             | 时间结束                                          |
| Object.wait(long timeout)            | 时间结束<br>Object.notify()<br>Object.notifyAll() |
| Thread.join(long mills)              | 时间结束<br>调用线程执行完毕                      |
| LockSupport.parkNanos(long nanos)    | LockSupport.unpark(thread)                        |
| LockSupport.parkUntil(long deadline) | LockSupport.unpark(thread)                        |



#### TERMINATED(终止状态)

当前线程已经中止，可能是任务执行完毕或者发生了异常导致运行结束。



### 线程常见方法

#### `start`

线程启动，表示线程进入`RUNNABLE`状态，等待CPU时间片分配可以执行

#### `run`

只是调用线程中的执行代码

#### `join`

在线程中调用另一个线程的`join()`，会将当前线程挂起，而不是忙等待，直到目标线程结束。

`join(long)`设置等待时间

#### `sleep(long mills)`

主动放弃占用的CPU资源，进入`BLOCKED`状态，并进入休眠状态`mills`毫秒。当超过`mills`后，线程就会进入`RUNNABLE`状态，等待执行。

#### `yield()`

主动放弃占用的CPU资源，进入`RUNNABLE`状态，等待CPU时间片。

**建议让步给它优先级比它高或者相同的待运行(`RUNNABLE`)的线程运行。放弃的时间不确定，可能会自己获取CPU时间片继续执行任务。**

#### `interrupte()/interrupted()/isInterrupted()`

`interrupt()`：中断线程，不会立即停止线程，设置线程中断状态为`true`

如果该线程处于`BLOCKED、WAITING、TIMED_WAITING`状态，执行`interrupt()`会抛出`InterruptException`异常。

`interrupted()`：测试当前线程是否中断，线程的中断状态受到这个方法的影响。例如调用一次设置中断状态为`true`，设置两次为`false`。线程会去检测中断位，判断线程是否中断。

`isInterrupted()`：测试当前线程是否中断，调用这个方法不会影响线程中断状态。

> 线程中断只是设置线程中断状态为`true`，具体线程何时中断，由线程自己而定，可能不会发生中断。

#### `setPriority()`

设置线程的优先级。**高优先级的线程会更容易被执行，也需要视具体的系统决定。**

线程的调度策略采用**抢占式**，优先级高的线程比低的更大几率被执行。

线程优先级具有：

- `继承性`：A线程启动B线程，则B线程与A线程优先级一致
- `随机性`：优先级高的不一定先执行

优先级从`1~10`，越大优先级越高。

> 如果某个线程的优先级大于所属`线程组(ThreadGroup)`的最大优先级，就会采用`线程组`的最大优先级。

## 多线程

> 一个进程可以开启多个线程，多个线程共享进程资源，提高资源利用率。

优点：

- 资源利用率高
- 提高程序的执行效率(提高系统的整体的并发能力以及性能)
- 减少了线程`上下文切换`的开销(多个线程同时运行)

缺点：

- 设计更复杂

  线程间的执行是无序的，线程同步产生的错误是难以发现

- 线程死锁

- 更多的资源消耗

  除了`上下文切换`的开销，还有创建销毁线程的开销还有内存同步的开销



### 线程死锁

> 多个线程同时被阻塞，他们中的一个或多个都在等待某个资源释放，由于线程无限期堵塞，导致程序无法正常中止。

产生死锁的4个条件：

- 互斥条件：该资源任一时刻只能由一个线程占用
- 请求与保持条件：一个进程因请求资源阻塞时，对已获得的资源保持不放
- 不剥夺条件：线程获得的资源未使用完之前，无法被其他线程强行剥夺
- 循环等待条件：进程之间形成头尾相接的循环等待资源关系

```java
//死锁示例
public class DeadLockDemo{
  private static Object resource1 = new Object();
  private static Object resource2 = new Object();
  
  public static void main(String[] args){
             new Thread("线程1"){
            @Override
            public void run() {
                synchronized (resource1){
                    System.err.println("get resource1");
                    try {
                        Thread.sleep(1000);
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                    synchronized (resource2){
                        System.err.println("get resource2");
                    }
                }
            }
        }.start();

        new Thread("线程2"){
            @Override
            public void run() {
                synchronized (resource2){
                    System.err.println("get resource1");
                    try {
                        Thread.sleep(1000);
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                    synchronized (resource1){
                        System.err.println("get resource2");
                    }
                }
            }
        }.start();
  }
}
```

上述代码中的`线程1、线程2`都试图去获取对方的资源，进入`互相等待`的状态，也就会产生`死锁`。



#### 避免线程死锁

死锁产生的条件如上4种，只要破坏任意一个条件就可以解除死锁状态：

- 破坏`互斥条件`：无法达成，锁本身就是互斥的
- 破坏`请求与保持条件`：一次性申请所有资源
- 破坏`不剥夺条件`：占用部分资源的线程进一步申请资源时，如果申请不到，就主动释放资源
- 破坏`循环等待条件`：按序申请资源



### 线程安全

> 当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就表示这个对象是线程安全的。

线程安全有以下几种实现方式：

#### 不可变

**不可变得对象一定是线程安全的。**无论是对象的方法实现还是方法的调用者，都不需要进行任何线程安全保障措施。

不可变的类型：

- `final`关键字修饰的基本数据类型
- `String`用户调用方法，例如`subString()、replace()`都不会修改原值
- 枚举类型
- `Number`的部分子类，例如`Long、Double`等数值包装类型

对于集合类型，可以使用`Collections.unmodifiableXX()`获取一个不可变集合

```java
public class ImmutableExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        Map<String, Integer> unmodifiableMap = Collections.unmodifiableMap(map);//不可变map
        unmodifiableMap.put("a", 1);
    }
}
```

`Collections.unmodifiableXX()`本质是 对原始集合进行拷贝，当外部调用修改集合方法时，直接抛出异常`UnsupportedOperationException`。



#### 互斥同步

**最常见也是最主要的并发正确保障手段。**保证共享数据在同一时刻只被一条线程使用。

常用`互斥同步`手段如下：

##### synchronized

{%post_link synchorized关键字分析%}

##### ReentrantLock

{%post_link ReenTrantLock关键字分析%}



#### 非阻塞同步

`互斥同步`面临的主要问题是**线程阻塞和唤醒所带来的性能问题**，所以也被称为**阻塞同步**。

> 基于冲突检测的乐观并发策略：`先进行操作，如果没有其他线程争用共享资源，那就直接操作成功；否则不断重试，知道成功为止。`

上述的`操作`和`重试检测`都依赖于`硬件指令集`的发展，不需要将线程阻塞。

##### CAS

{%post_link Atomic原子操作类分析%}





#### 无同步



### 线程间通信



### *线程池



### 多线程开发良好实践

## 锁优化]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关合集整理</title>
    <url>/2020/05/02/JVM%E7%9B%B8%E5%85%B3%E5%90%88%E9%9B%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[
> 本章主要针对JVM基础知识的整理以及拓展

## JVM内存区域

<!--1.8前后有差异，需要列出来-->

> JVM在执行Java程序的过程中会把管理的内存分为若干个不同的数据区域。
>
> **JDK1.8前后分区略有不同**

<div align="center">
<img style="margin-right:30px" src="/images/jvm/jvm1.8前.jpg" width="35%" alt="JDK 1.8之前" ><img style="margin-left:30px" src="/images/jvm/jvm1.8.jpg" width="50%" alt="JDK1.8之后" >    
</div>



根据上述两图，运行时数据区域按照`线程是否私有`分为两部分：

- `线程私有`：程序计数器、虚拟机栈、本地方法栈
- `线程共享`：堆、方法区

### 程序计数器

> **线程私有**，当前线程所执行的字节码的`行号指示器`，记录当前线程执行的位置。

程序计数器主要有两个作用：

1. 字节码解释器通过改变`程序计数器`来依次读取指令，从而实现代码的流程控制
2. 在多线程的情况下，`程序计数器`用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到何处。
   - 线程执行Java方法时，计数器记录了`当前正在执行的字节码指令地址`。
   - 线程执行Native方法时，计数器值为`Undefined`。

**`程序计数器`是唯一一个不会出现`OutOfMemory`的内存区域，它的生命周期随着线程的创建而创建，随线程的结束而死亡。**

### 虚拟机栈

> **线程私有**，描述`Java方法执行的内存模型`，每次方法调用的数据都是通过栈传递的。

Java内存可以粗糙的分为**堆内存(Heap)**和**栈内存(Stack)**，栈内存位于虚拟机栈上。

**栈内存**：存储`局部变量`和`方法调用`

**堆内存**：存储`Java中的对象(无论成员变量、局部变量、类变量)`

*如果局部变量是`基本数据类型`，那局部变量的值存储于栈上；若局部变量是`对象`，该变量的引用存在于栈上，但是对象存储于堆中。*

> 基本数据类型：`boolean、byte、char、short、int、float、long、double`

</br>

#### 栈帧

`虚拟机栈`由一个个**栈帧**组成，`栈帧`也叫`过程活动记录`，是用于支持虚拟机调用/执行程序方法的数据结构，记录了每一个方法从调用直至执行完成的过程。*栈帧随着方法的调用而创建，执行完成而销毁。*

`栈帧`主要由以下四部分组成：

{% fullimage /images/jvm/栈帧结构.png,操作指令-异常指令,操作指令-异常指令%}

##### 局部变量表

> 用于存储方法参数和定义在方法体的局部变量，包含了编译器可知的各种基本数据类型、对象引用、returnAddress类型。

局部变量表的大小在编译期就已经确定了，对应了字节码中`Code属性表中的max_locals`。

##### 操作数栈

> 通过入栈、出栈操作来完成一次数据访问，本质是一个**临时数据存储区域**。
>
> 是一个后入先出栈(LIFO)

操作数栈的大小在编译期已经确定，对应字节码中的`Code属性表中的max_stacks`

##### 动态链接

> 为了支持方法调用过程中的动态连接，调用编译期无法被确定的方法。
>
> **在运行期将符号引用转换为所在内存地址的直接引用。**

静态链接：被调用的目标方法在编译期可知且运行期保持不变时，那么这种情况下调用方法的符号引用可以转换为直接引用。

##### 返回地址

> 记录方法被调用的位置，可以在方法执行结束后回到被调用处继续向下执行程序。

当一个方法开始执行后，只有两种方式可以退出这个方法：

- **正常退出**：方法中的代码正常执行完成，或者遇到任意一个方法返回的字节码指令(`return`)并退出，将返回值传递给上层的方法调用者，没有抛出任何异常。
- **异常退出**：执行方法过程中出现异常，并且没有处理该异常，导致方法退出。

一般方法退出正常值为`调用者的PC计数器数值`。

<br>

在`虚拟机栈`会出现两种异常情况：

- `StackOverflowError`：请求栈深度超出虚拟机栈说允许的深度时抛出
- `OutOfMemoryError`：无法申请到足够的内存时抛出

### 本地方法栈

> **线程私有**，虚拟机执行Native方法的服务，和`虚拟机栈`功能类似。

在`本地方法栈`会出现两种异常情况：

- `StackOverflowError`：请求栈深度超出虚拟机栈说允许的深度时抛出
- `OutOfMemoryError`：无法申请到足够的内存时抛出

### **Java堆**

> **线程共享**
>
> JVM所管理内存中的最大一块，该区域唯一目的是**存放对象实例**，几乎所有对象实例都在这里分配内存。
>
> 因此他也是垃圾收集管理的主要区域，因此也被称作`GC堆`。

由于现在基本都采用分代垃圾回收算法，按照对象存储时间的不同，还可以细分为`新生代(分为Eden和Survivor，大致比例为8:1:1)`和`老年代`。

{% fullimage /images/jvm/Java堆结构.jpg,Java堆结构,Java堆结构%}

在`Java堆`中会出现以下异常情况：

- `OutOfMemoryError`：无法申请到足够的内存时抛出

#### Tips

JVM堆内存溢出后，其他线程是否继续正常工作？

发生OOM之后会不会影响其他线程正常工作需要具体的场景分析。一般情况下，发生OOM的现场都会被终结，然后该线程持有的对象占用就会被GC，释放内存。

### 方法区(版本区别较大)

> **线程共享**
>
> 用于存储`已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据`。
>
> `方法区`还有一个别名叫做`Non-Heap`，可以与上述的`Java堆`进行区分。

#### JDK 1.8前

那时`方法区`也被称为`永久代`，GC在该区域是比较少出现的，但是不代表不进行GC操作。常见的异常为`java.lang.OutOfMemoryError:PermGen space`表示了`永久代异常信息`。

#### JDK 1.8

这时`永久代`已被移除，代替它的是`元空间(meta space)`，`元空间`位于`直接内存`中，因此`元空间`的最大占用就是系统的内存空间，用户可通过`-XX:MetaspaceSize`设置`元空间`最大占用，避免占用过量内存。

#### Why

- 由于`永久代`内存经常会溢出，导致OOM发生，因此JVM开发者希望这块内存可以被更灵活的管理，减少OOM错误的出现。
- `永久代`会为GC带来不必要的复杂度，并且回收效率偏低。
- `永久代`的大小难以确定，太小容易造成`方法区`发生OOM

在`方法区`会出现两种异常情况：

- `StackOverflowError`：请求栈深度超出虚拟机栈说允许的深度时抛出
- `OutOfMemoryError`：无法申请到足够的内存时抛出



#### Tips

如何使方法区发生OOM?

借助`CGLib`这类字节码技术，不断动态生成新类，新方法。或者使用不同的ClassLoader去加载同一个类(`不同的ClassLoader加载的同一个类也是不同的`)

- JDK1.8之前

  可以通过配置`-XX:Maxpermsize`设置一个较小的值

- JDK1.8

  上述方法由于移除了`永久代`无法生效，可以通过配置`-XX:MetaspaceSize`一个较小的值，也可以模拟这个异常。

### 常量池

<!--String.intern()来举例-->

> Java中常量池的概念主要有三个：
>
> - `字符串常量池`
> - `Class文件常量池`
> - `运行时常量池`
>
> 其中`Class文件常量池`存在于class文件中，不受JDK版本影响。
>
> `字符串常量池`在JDK1.6前位于`方法区`中，之后的版本存在于`Java堆`上
>
> `运行时常量池`在JDk1.7前位于`方法区`中，之后的版本存在于`元空间`上

#### Class文件常量池(`Class Constant Pool`)

> class文件除了包含`类的版本、字段、方法、接口等描述信息`外，还有一项信息就是`Class文件常量池`，用于存放编译器生成的`各种字面量和符号引用`。

##### 字面量

> 接近Java语言层面的常量

- 文本字符串

  ```java
  public String s = "abc";//其中abc为字面量
  
  对应字节码常量池数据为
  #31 = Utf8               abc
  ```

- 8种基本类型的值

  ```java
  public int value = 1;
  
  对应字节码常量池数据为
  #7 = Utf8               value
  #8 = Utf8               I
  ```

  常量池只保留了字段描述符(I)和字段名称(value)，字面量不存在于常量池中。

- 用`final`修饰的成员变量，包括`静态变量、实例变量，局部变量`

  ```java
  public final static int f = 2;//其中2为字面量
  
  对应字节码常量池数据为
  #11 = Integer               2
  ```

  

##### 符号引用

> 用一组符号描述所引用的目标，符号可以是任何形式的字面量。

- 类和接口的全限定名

  ```java
  public String s = "abc";
  
  对应字节码常量池数据为
  #5 = Class              #10            // java/lang/String
  #10 = Utf8              Ljava/lang/String;
  
  ```

  其中`String`对应全限定名为`java/lang/String`存储于常量池中

  **主要用于在运行时解析得到类的直接引用**

  

- 字段的名称和描述符

  字段：类或接口中声明的变量，包括类级别变量和实例级的变量

  ```java
  public int value = 1;
  
  对应字节码常量池数据为
  #4 = Fieldref           #5.#32         // JavaBasicKnowledge/JavaBean.value:I
   #5 = Class              #33            // JavaBasicKnowledge/JavaBean
   #32 = NameAndType       #7:#8          // value:I
  
   #7 = Utf8               value
   #8 = Utf8               I
  ```

  *对于方法中的局部变量名，class常量池中仅仅保存字段名*

  ```java
  public void XX(int v){
     int temp = 3;
  }
  
  对应字节码常量池数据为
   #23 = Utf8               v
   #24 = Utf8               temp
  
  ```

  

- 方法的名称和描述符

  保存的是`方法名、参数类型+返回值`

  ```java
  public void XX(int v){
  ...
  }
  
  对应字节码常量池数据为
    #21 = Utf8               XX  //方法名
    #22 = Utf8               (I)V //参数类型+返回值
  ```

  

#### 字符串常量池(`String Constant Pool`)

> 在JDK1.7及之后版本中，`字符串常量池`被移动到`Java堆`中(可能是因为方法区的内存空间太小)。
>
> - JDK1.7之前
>
>   `字符串常量池`的位置在`方法区`，此时存储的是**字符串对象**。
>
> - JDK1.7及之后
>
>   字符串常量池中的内容是在类加载完成，经过`验证、准备`阶段之后在`Java堆`中生成字符串对象实例，然后将该对象实例引用值存在`字符串常量池`中。**字符串常量池中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间进行存放的。**

在HotSpot VM里实现的`String Pool`对应一个`StringTable`类，实际是一个Hash表，默认值大小长度为`1009`(如果放入过多，导致Hash冲突使链表变长，导致查询性能大幅下降)。该`StringTable`在每个VM的实例只有一份，被所有的类共享。

在JDK1.7版本中，`StringTable`长度可以通过配置参数指定——`-XX:StringTableSize=${num}`指定长度。

##### 创建字符串对象

```java
// 编译期就已经确定该字面量，会直接进入class文件常量池中，在字符串常量池中会保存一个引用
String s0 = "Hello";
// 调用了String的构造函数，创建的字符串对象是在堆内存上
String s1 = new String("Hello");
```

##### 字面量何时进入常量池

1. 加载类的时候，那些字面量会进入到当前类的`运行时常量池`，不会进入全局的`字符串常量池`中
2. 当字面量赋值的时候，会翻译成字节码中的`ldc`指令，将常量从常量池中推送至栈顶。

#### 运行时常量池

> 在JDK1.7及之后的版本已将`运行时常量池`从`方法区`移了出来，在`Java堆`中开辟一块区域存放运行时常量池。
>
> 为了**存储class文件常量池中的符号信息**，在`解析`的时候会去查询`字符串常量池`，以保证运行时常量池所引用的字符串与`字符串常量池`中是一致的。

JVM在执行某个类的时候，必须经过**加载、链接(验证，准备，解析)、初始化**过程。

当类执行`加载`过程后，JVM将`class常量池`中的内容存放到`运行时常量池`中，已知`class文件常量池`中存储的内容是`字面量与符号引用`。

`准备`阶段在`Java堆`中生成字符串的实例对象，将生成的实例对象引用放置于`字符串常量池`。

`解析`阶段将`class文件常量池`中的`符号引用`翻译成`直接引用`也是存储于`运行时常量池`中。

##### 动态性

Java规范并不要求常量只在运行时才能产生，也就是表示*运行时常量池的内容不一定都来自于class文件常量池*，在运行时可以通过代码生成常量放置于`运行时常量池`中，例如`String.intern()`

##### String.intern()

> - JDK 1.7之前
>
>   `intern`的处理是：**先判断字符串是否存在于`字符串常量池`中，如果存在直接返回该常量；如果没有找到，则将字符串常量加入到`字符串常量池`中。**
>
> - JDK 1.7及之后
>
>   `intern`的处理是：先判断字符串是否存在于`字符串常量池`中，如果存在直接返回该常量；如果没找到，表示该字符串常量在堆中，然后把`Java堆`该对象的引用加入到`字符串常量池`中，以后别人拿到的就是该字符串常量的引用，实际字符串存在于堆中。

### 直接内存

> 直接内存并不是JVM的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，可能导致OOM的出现。

在JDK1.4新加入了`NIO`类，引入一种基于`通道(Channel)`和`缓冲区(Buffer)`的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存在`Java堆`的对象作为这块内存的应用进行操作。

## Java对象创建过程以及访问方式

### Java对象创建过程

在Java语言层面上，创建对象只需要调用`new`关键字。

在JVM中，实际需要执行以下几步：

#### 类加载检查

遇到一条`new`指令时，先检查指令对应的参数是否在`常量池`中可以定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，需要执行相应的`类加载过程`。

#### 分配内存

`类加载检查`通过后，JVM将为新生对象`分配内存`，对象所需大小在类加载完成后便可以确定。

这块内存由`Java堆`划分出来。内存的分配方式由**Java堆中内存是否规整**决定，而`内存是否规整`由**采用的垃圾收集器是否带有压缩整理功能决定**。

- **指针碰撞**

  > `Java堆内存规整`，把指针向空闲空间挪动对象大小的距离

  对应GC收集器：Serial、ParNew

  **关键看GC收集器采用了`标记-整理、标记-压缩、复制`算法进行回收**

- **空闲列表**

  > `Java堆内存不规整`，虚拟机维护一个列表记录内存块中的可用区域，在分配内存的时候，找到一块儿足够大的空间划分给对象实例

  对应GC收集器：CMS

  **关键看GC收集器采用了`标记-清除`算法进行回收**

##### 内存分配并发问题

创建对象是一个很频繁的事情，就会涉及一个很重要的问题——**线程安全**。作为虚拟机来讲，必须要保证线程安全，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试**

  > CAS是乐观锁的一种实现方式
  >
  > 乐观锁：假设没有冲突而去完成某项操作，若发生冲突就重试直到成功为止。

  采用这种方式可以保证更新操作的原子性。

- **TLAB**(本地线程分配缓存)

  > 每个线程预先在`Java堆`中分配一块内存，JVM在给对象分配内存时，首先在`TLAB`分配。如果分配的对象大于`TLAB`的剩余内存或`TLAB`内存已用尽时，再采用上述CAS方式进行内存分配。

#### 初始化零值

**内存分配完成时，虚拟机需要将分配到的内存空间初始化为零值(不包括对象头)。**这一步操作可以保证对象的实例字段在代码中可以不赋值就直接使用，程序也可以访问到这些字段的数据类型所对应的零值。

#### 设置对象头

`初始化零值`完成后，**虚拟机要对对象进行必要的设置**。将`类的元数据信息、对象的哈希码、对象的GC分代年龄`等信息，存放到`对象头`中。另外根据虚拟机运行状态的不同，如是否启用偏向锁等，对象头都会进行存储。

可以在`对象内存布局`这节看到对象头相关内容。

#### 执行`<init>`方法

从虚拟机角度来说，一个新的对象已经产生了。从代码角度来说，对象才刚开始创建，在执行`<init>`方法之前，所有的字段都还为零。一般执行完`new`指令后会接着执行`<init>`方法，把对象按照意愿进行初始化，这时就产生了一个真正可用的对象。



{%fullimage /images/Jvm对象创建过程.png,Jvm对象创建过程,Jvm对象创建过程%}



### 对象内存布局

对象内存布局分为以下三块区域：

#### 对象头(Header)

必须先了解 HotSpot虚拟机的对象(**对象头部分**)的内存布局：分为两部分

##### Mark Word

存储自身的运行时数据，如：`HashCode、GC分代年龄和锁信息`，这部分数据的长度在32和64位中的JVM中分别为32bit和64bit。**它是实现轻量级锁和偏向锁的关键。**

{% fullimage /images/MarkWord.png,Mark Word,Mark Word %}

##### 类型指针

存储指向方法区对象类型数据的指针，如果是数组对象的话，额外会存储数据的长度。JVM通过这个指针来确定该对象是哪个类的实例。

#### 实例数据(Instance Data)

对象真正存储的有效信息，即在代码里面所定义的各种类型的字段内容。

#### 对齐填充(Padding)

并非必然存在的，也没有特别的含义，仅仅起着**占位符**的作用。

### Java对象访问方式

Java程序通过栈上的refrence数据来操作堆上的具体对象。



#### 句柄访问

`Java堆`可能会划分一块内存作为句柄池，refrence存储的就是`对象的句柄地址`，句柄中包含了对象的实例数据与类型数据的各自具体地址信息。

 {% fullimage /images/jvm/get_object_by_handle.png, alt,流程图 %}

**refrence中存储的稳定句柄地址，在对象被移动时(例如GC时)只会改变句柄中的实例数据指针，refrence本身不需要修改。**

#### 直接访问

`Java堆`中对象的内存布局就必须考虑如何设置访问类型数据的相关信息，refrence直接存储的就是`对象地址`。

 {% fullimage /images/jvm/get_object_direct.png, alt,流程图 %}

**最大好处就是速度快，节省了一次指针定位的时间开销。**在HotSpot虚拟机中很常用。

## 类加载机制

> JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为虚拟机的类加载机制。

### 类的生命周期

一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历**加载、验证、准备、解析、初始化、使用、卸载**七个阶段，其中`准备、解析、初始化`称为**连接**。

{% fullimage /images/jvm/class_lifecycle.png, 类的生命周期,类的生命周期 %}

#### 类的卸载

> 由JVM自带的类加载器(`BootstrapClassLoader根加载器、ExtensionClassLoader拓展加载器、ApplicationClassLoader应用加载器`)所加载的类，在虚拟机的生命周期中，都不会被卸载。
>
> **只有由用户自定义的类加载器所加载的类是可以被卸载的。**

类卸载的触发条件：

- 该类所有的实例都已被GC，在JVM中不存在任何该类的实例
- 加载该类的ClassLoader也被GC
- 该类的Class对象没有被任何地方调用，反射也无法访问该类

执行类卸载后，在方法区的二进制数据会被卸载。

### 类加载过程

> 类加载过程包括上述的五步：`加载、验证、准备、解析、初始化`。

#### 加载

> JVM找到class文件问生成字节流，然后根据字节流创建java.lang.class对象的过程。

JVM在此过程需要完成三件事：

- 通过一个类的 `全限定名(包名+类名)`来查找.class文件，并生成二进制字节流(**使用ClassLoader进行加载**)。其中字节码来源不一定是.class文件，也可以是jar包、zip包，甚至是来源于网络的字节流。
- 将字节流所代表的静态存储结构转化为JVM的特定的数据结构，并存储在`方法区`
- 在内存中创建一个`java.lang.Class`类型的对象，作为方法区这个类的各种数据的访问入口。

一个非数组类的加载阶段(加载阶段获取二进制字节流的动作)是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式(重写类加载器的`findClass()`或`loadClass()`)。

对于数组类而言，数组类本身不通过类加载器创建，由JVM直接在内存中动态创建。



##### 加载时机

一个项目经过编译之后，往往会产生大量.class文件，程序运行时，JVM不会一次性将这些文件全部加载到内存中，而是有一定的加载时机去进行加载操作。

###### 隐式装载

在程序运行过程中，当碰到通过`new`生成对象时，系统会隐式调用ClassLoader装载对应class到内存中(`loadClass()`)

```jaba
protected Class<?> loadClass(String name, boolean resolve)
```



###### 显示装载

在编写源代码时，主动调用`Class.forName()`也会进行class装载操作。执行时会默认调用静态代码块`static{...}`以及分配静态变量存储空间

```java
public static Class<?> forName(String name, /*要加载的Class名字*/
										 boolean initialize,/*默认为true,是否需要初始化-调用静态代码快及静态变量初始化*/
                               ClassLoader loader/*指定ClassLoader进行加载*/)
```

#### 验证

> 确保.class文件的字节流中包含的信息符合虚拟机规范的全部要求，并且不会危及虚拟机本身的安全。

若代码被反复验证和使用过，可以通过配置`-XVerify:none`关闭大部分的验证措施，缩短加载时间

主要包含以下四个方面的验证：

##### 文件格式验证

> 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。

这一阶段可能包含以下验证点：

- 是否以魔数`0xCAFEBABE`开头
- 主次Java版本号是否在当前JVM接受范围内
- ...

##### 元数据验证

> 对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java语言规范的要求

这一阶段可能包含以下验证点：

- 这个类是否有父类(除了 java.lang.Object外，都应该有父类)
- 这个类是否继承了不允许被继承的类(被final修饰的类)
- ...

##### 字节码验证

> 通过数据流分析和控制流分析，确定程序语义是合法、符合逻辑的

这一阶段可能包含以下验证点：

- 任意时刻操作数栈的数据类型与指令代码序列都配合工作
- 任何跳转指令都不会跳到方法体以外的的字节码指令中
- ...



##### 符号引用验证

> 发生于JVM将`符号引用`转换`直接引用`的时候。
>
> 对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验。通俗来说就是，该类是否缺少或者被禁止访问她依赖的某些外部类、方法、字段等资源。

这一阶段可能包含以下验证点：

- 符号引中通过字符串描述的全限定名能否找到对应的类
- 在指定类是否存在符合方法的字段描述符及简单名称所描述的方法和字段
- ...



#### 准备

> 正式为类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置为变量初始值(`零值`)的阶段，不包括实例变量。

```java
public static int value = 100;
```

在准备阶段，JVM会为value分配内存，并将其设置为0。真正的100需要在初始化阶段进行设置。

| 数据类型  | 零值     |
| --------- | -------- |
| Int       | 0        |
| long      | 0L       |
| short     | (short)0 |
| char      | ‘\u0000’ |
| byte      | (byte)0  |
| boolean   | false    |
| float     | 0.0f     |
| double    | 0.0d     |
| reference | Null     |

以上是通常情况下初始值是`零值`，还是会存在一些特殊情况——静态常量。

```java
public static final int value = 100;
```

此时value的初始值就为100。

#### 解析

> 把常量池中的符号引用转换为直接引用，也就是具体的内存地址。JVM会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。

##### 符号引用

以一组符号描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。

##### 直接引用

直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。**对象真正的内存地址**



解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。

#### 初始化

> 类加载的最后一个步骤，直到这一步，JVM才真正开始执行类中编写的Java代码。
>
> **执行类构造器<clinit>()的过程，并真正初始化类变量(前面准备过程的零值在此时被赋予真正的值)**

##### 初始化执行时机

JVM规范严格规定类class初始化的时机，主要有以下几种情况：

- 虚拟机启动时，初始化包含`main()`的主类

- 遇到`new(创建对象实例)、getstatic(读取类静态字段)、putstatic(设置类静态字段)、invokestatic(调用类的静态方法)`这四条字节码指令时，如果目标对象没有经过初始化，需要执行初始化操作

- 当需要对类进行反射调用时，如果类型没有进行初始化，需要执行初始化操作

- 当初始化子类的时候，发现父类还没有进行初始化，需要执行父类的初始化操作

- 在第一次调用`java.lang.invoke.MethodHandle`实例时，需要初始化MethodHandle指向方法所在的类。*JDK7之后*

- 当一个接口中定义了JDK8新加入的默认方法(`default`关键字修饰)，如果实现了这个接口的类进行初始化，那么接口需要执行初始化操作

  ```java
  public interface DefaultInterface {
      //默认接口方法
      default void test(){
          System.err.println("Default Interface Method");
      }
  
      void test1();
  }
  ```

以上6种情况在JVM中被称为**主动引用**，除此之外的其他应用方式都被称为**被动引用**，不会出发Class的初始化操作。

例如以下几种情况：

- 通过子类调用父类的静态变量，不会导致子类初始化

  ```java
  public class Parent{
    public static int value = 1;
    static {
      System.out.println("Parent");
    }
  }
  
  public class Child extends Parent{
    static {
      System.out.println("Child");
    }
  }
  
  public class Test{
    public static void main(String[] args){
      Child.value = 2;
    }
  }
  
  日志输出
  java NonInitTest
  Parent
  ```

  只有直接定义这个字段的类才会被初始化，所以子类不会进行初始化。

- 静态常量引用时，不会触发定义常量类的初始化

  ```java
  public class ConstClass{
    static {
      System.out.println("Const");
    }
    
    public static final String value ="Value";
  }
  
  public class Test{
    public static void main(String[] args){
      System.out.println(ConstClass.value);
    }
  }
  
  日志输出
  Value
  ```

  常量实际在编译阶段直接存储在Test类的常量池中，已于ConstClass无关，所以不会导致初始化。



##### Class初始化和对象的创建顺序

在代码中使用`new`创建对象实例时，类中`静态代码块、非静态代码块、构造函数`之间的执行顺序是如何的？

```java
Parent.java
 
public class Parent {
    public static String value = "Parent";

    static {
        System.err.println("Parent Static Block");
    }

    {
        System.err.println("Parent non-static Block");
    }

    public Parent(){
        System.err.println("Parent Constructor");
    }
}


Child.java

public class Child extends Parent{
    static {
        System.err.println("Child Static Block");
    }

    {
        System.err.println("Child Non-Static Block");
    }

    public Child(){
        System.err.println("Child Constructor");
    }
}

Test.java

public class Test {
    public static void main(String[] args) {
        Parent p =new Child();
        System.err.println("~~~~~~~~~~");
        p = new Child();
    }
}
```

输出内容为

```java
Parent Static Block
Child Static Block
Parent non-static Block
Parent Constructor
Child Non-Static Block
Child Constructor
~~~~~~~~~~
Parent non-static Block
Parent Constructor
Child Non-Static Block
Child Constructor
```

按照上述输出内容，可以总结初始化顺序为：

```java
1.父类静态变量和静态代码块
2.子类静态变量和静态代码块
3.父类普通成员变量和普通代码块
4.父类的构造函数
5.子类普通成员变量和普通代码块
6.子类的构造函数
```

基础规则：**静态变量/静态代码块 -> 普通变量/普通代码块 -> 构造函数**。



特殊情况

```java
public class StaticTest {
    public static void main(String[] args) {
        staticFun();
    }
    //特殊之处
    static StaticTest st = new StaticTest();

    static {
        System.err.println("1");
    }

    {
        System.err.println("2");
    }

    StaticTest() {
        System.err.println("3");
        System.err.println("a" + a + " b" + b);
    }

    public static void staticFun() {
        System.err.println("4");
    }

    int a = 100;
    static int b = 100;
}

```

TODO：需要好好分析流程。

### 类加载器

<!--包括Android加载器-->

在Java程序启动的时候，并不会一次性加载程序中所有的.class文件，而是在程序运行的过程中，动态加载相应的类到内存中。

**同一个类使用不同的类加载器，得到的类也是不一样的。**

#### Java类加载器

- 启动类加载器(BootstrapClassLoader)

  由C/C++语言编写的，本身属于虚拟机的一部分，无法在Java代码获取他的引用。可以以`null`代表引导类加载器。

  负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定路径的类库

  

- 拓展类加载器(ExtensionClassLoader)/PlatformClassLoader(JDK9后改名)

  由Java语言编写，可以直接在程序中使用

  负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs所指定的路径中的所有类库

  

- 应用程序/系统类加载器(ApplicationClassLoader)

  负责加载用户类路径(`java.class.path`)上所有的类库，我们自己编写的代码以及使用的第三方jar通常由他进行加载。

  **若没有自定义类加载器，默认由他进行类加载。**

  

- 自定义类加载器(CustomClassLoader)

  上述三种加载器只能加载特定目录下的class文件，如果需要加载特殊位置下的jar包或类时(磁盘上的class)，就需要继承`java.lang.ClassLoader`去实现功能。

  自定义ClassLoader步骤如下：

  1. 自定义一个类继承`ClassLoader`
  2. 重写`findClass()`
  3. 在`findClass()`中，调用`defineClass()`将字节码转换成Class对象并返回

  伪代码如下：

  ```java
  Class CustomClassLoader extends ClassLoader{
    @Override
    Class findClass(String name){
      //获得字节码
      byte[] code = loadClassData(name);
      //根据字节码获得Class对象
      return defineClass(name,code);
    }
    
    //这里是获得Class的字节码数组
    byte[] loadClassData(String name){
      
    }
  }
  ```

#### 双亲委托模型

{% fullimage /images/jvm/parent_loader.png, alt,双亲委托模型 %}

> 当类加载器收到类加载请求时，通常都是先委托给父类加载器进行加载，因此所有的类加载请求最终都会传送到最顶层的`启动类加载器`中，只有当父加载器无法完成这个加载请求时，子加载器才会去进行类加载过程。

```java
private final ClassLoader parent; 
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 首先，检查请求的类是否已经被加载过
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {//父加载器不为空，调用父加载器loadClass()方法处理
                        c = parent.loadClass(name, false);
                    } else {//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                   //抛出异常说明父类加载器无法完成加载请求
                }

                if (c == null) {
                    long t1 = System.nanoTime();
                    //自己尝试加载
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

按照源码分析，双亲委托模型总共4步：

1. 判断class是否被加载，已加载直接返回class
2. class未被加载且`parent(父加载器)`不为空，父加载器进行加载class
3. `parent(父加载器)`为空，直接调用`BootstrapClassLoader`加载class
4. 如果`parent`或`Bootstrap`都未加载成功，则调用当前classLoader继续尝试加载class

##### 双亲委托模型好处

- **避免类的重复加载**，若class已被加载直接从缓存读取
- **保证类加载的安全**，避免核心API被篡改，无论哪一个类加载去加载核心类(例`java.lang.Object`)，最终都会由`BootstrapClassLoader`进行加载。

##### 破坏模型

> `双亲委托机制`只是Java推荐的机制，并不是强制的机制，可以通过一些手段破坏该模型

可以通过继承`java.lang.ClassLoader`实现自己的类加载器

- 保持`双亲委托模型`，只要重写`findClass()`
- 破坏`双亲委托模型`，需要重写`loadClass()`

#### Android类加载器

<!--dex2oat dexopt过程-->

> 本质上，Android和传统的JVM是一样，也要通过`ClassLoader`加载目标类到内存，但是加载细节略有差别。
>
> 基本运行方式：`传入dex文件，然后进行优化，保存优化后的dex文件(odex)到optimizedDirectory目录`

Android无法直接运行`.class文件`，会将所有的`.class文件`转换`.dex`文件，Android通过自定义的`BaseDexClassLoader`加载`dex文件`，也会通过继承`BaseDexClassLoader`实现特定功能的子类。

##### BaseDexClassLoader

```java
 public class BaseDexClassLoader extends ClassLoader {
     public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) {
         throw new RuntimeException("Stub!");
     }
     ...
 }
```

- dexPath

  包含目标类或资源的`apk,dex,jar文件的路径，也可以是SD卡的路径`，存在多个路径时使用`;`分割

- optimizedDirectory

  优化后dex文件(`odex`)存在的目录，可以为null，*Android8.0之后，该参数被废弃*

- librarySearchPath

  存放目标文件使用的native库，存在多个路径使用`;`分割

- parent

  父加载器



##### PathClassLoader

> 加载Android系统类和应用程序的类，在`Dalvik`只能加载已安装的apk的dex文件(`/data/app`)，在ART没有这个限制。
>
> **支持加载外部的dex/apk文件**

```java
public class PathClassLoader extends BaseDexClassLoader {
    public PathClassLoader(String dexPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
        ...
    }
  
      public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
        ...
    }
}
```

`PathClassLoader`传入的`optimizedDictory`为空，表示只能加载系统默认位置(`/data/dalvik-cache/`)的`odex`文件。



##### DexClassLoader

> **支持加载外部的dex/apk文件**，但是可以配置`optimizedDirectory`指定`odex`存放位置。

```java
public class DexClassLoader extends BaseDexClassLoader {
    public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
      ...
    }
}

```

可以支持`BaseDexClassLoader`配置的所有参数。

### Android类加载过程

{% post_link Android-Art类加载过程 %}



## JVM垃圾回收机制(GC)

> GC：自动管理回收不再引用的内存数据
>
> JVM内存运行时区域分为5部分，其中`程序计数器、虚拟机栈、本地方法栈`3个区域**随线程生而生，随线程灭而灭**，是不需要考虑内存回收的问题，内存自然会回收。`Java堆和方法区`不一样，只有在程序运行期间才知道创建哪些对象，这部分内存的分配和回收是动态的，主要在这两部分触发GC。

### 对象是否已死(什么是`垃圾`)

堆中几乎存放所有的对象实例，垃圾回收(GC)前的第一步是判断哪些对象已经死亡(不再被任何途径引用的对象)。

#### 引用计数法

> 给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；引用失效，计数器减1；任何时候计数器为0的对象就是不可能在被使用的。

`引用计数法`虽然需要占用额外的内存空间来进行计数，但是**原理简单，效率也高**。

但是主流的Java虚拟机里面都没有使用该方法，主要原因是**必须配合大量额外处理才能保证正确的工作，例如无法解决对象之间相互循环引用的问题**。

#### 可达性分析算法

> 通过一系列称为`GC Roots`的根对象作为起始点，从这些节点开始搜索，搜索过程走过的路径称为**引用链**，如果一个对象到`GC Roots`没有任何引用链相连的话，则证明此对象是不可用的。

{% fullimage /images/jvm/gc_reachability_analysis.png,可达性分析算法,可达性分析算法  %}

可以作为`GC Roots`的对象类型：

- 虚拟机栈中的引用对象(局部变量表)
- 方法区中静态属性引用的对象(字符串常量池中的引用)，常量引用的对象
- 本地方法栈中JNI所引用的对象



### 什么时候回收

一般会在以下两种情况下触发GC

1. `Allocation Failure`：如果内存剩余可用空间不足导致对象内存分配失败，系统会触发一次GC
2. `System.gc()`：开发者可主动调用该API触发一次GC

### 四大引用类型(Java堆)

| 引用类型 | GC时机                | 用途               |
| -------- | --------------------- | ------------------ |
| 强引用   | 不会被回收            | 对象一般状态       |
| 软引用   | 内存不足时(即将OOM时) | 内存敏感的高速缓存 |
| 弱引用   | 触发GC时              | 对象缓存           |
| 虚引用   |                       |                    |



#### 强引用`Strong Reference`

> 在程序代码间普遍存在的引用赋值。**无论何种情况，只要存在强引用关系，就永远不会被垃圾回收器回收。即使发生OOM。**
>
> **强引用也是造成Java内存泄露的原因之一。**

对于一个普通的对象，如果没有其他的引用关系，若显式的将对象赋值为null，就可以认为该对象可以被回收。

*设置对象为null，不代表对象会被立即回收，具体回收时机需要看垃圾收集策略。*

```java
public static void main(String[] args){
  Object o1 = new Object();
  Object o2 = o1;
  o1= null;
  System.gc();
  System.out.println(o1);  //null
  System.out.println(o2);  //java.lang.Object@XX
}
```



#### 软引用`Soft Reference`

> 描述一些还有用，但并未必需的对象。对于`软引用`关联的对象，在系统即将发生`OOM`之前，会把这些对象进行GC，如果GC完毕还没有充足空间，就抛出OOM异常。
>
> **实现内存敏感的高速缓存。**
>
> *只有系统内存不足时才会被回收，其他情况下等效强引用。*

```java
public static void main(String[] args){
   Object o1 = new Object();
   SoftReference<Object> s1 = new SoftReference<Object>(o1);
   System.out.println(o1);
   System.out.println(s1.get());

   o1 = null;
   System.gc();

   System.out.println(o1); // null
   System.out.println(s1.get()); //java.lang.Object@XX
}

//JVM配置`-Xms5m -Xmx5m`
//试图new一个大对象，使内存不足产生OOM，看软引用回收情况
...
  byte[] bytes = new byte[10*1024*1024]；
  ...
  
  此时会去试图回收软引用对象。
```



#### 弱引用`Weak Reference`

> 弱引用也是描述非必须对象，但强度比`软引用`更弱一些，被弱引用关联的对象只能生存在下一次GC前。
>
> **无论内存是否足够，弱引用关联的对象都会被回收。**

```java
public static void main(String[] args) {
        Object o1 = new Object();
        WeakReference<Object> w1 = new WeakReference<Object>(o1);

        System.out.println(o1);
        System.out.println(w1.get());

        o1 = null;
        System.gc();

        System.out.println(o1); //null
        System.out.println(w1.get()); //null
    }
```



`WeakHashMap`就是`弱引用`的一个使用实例

其中`key`为弱引用类型，当key不在引用时，对应的key/value也会被移除

```java
    public static void main(String[] args) {
        WeakHashMap<String,String> weakHashMap = new WeakHashMap<>();
        String key = new String("111");
        //String key ="111";

        String value= "value";

        weakHashMap.put(key,value);
        System.err.println(weakHashMap);// {111=value}

        key = null;
        System.gc();
        System.err.println(key); //null
        System.err.println(weakHashMap); //{}
    }
```

当使用`String key = “111”`时，本质引用的对象已经变成`字符串常量池`中的对象，这部分的回收无法被GC处理。也导致了`weakHashMap`对象不为空。



#### 虚引用`Phantom Reference`

> 最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对生存时间构成影响，也无法通过`虚引用`来取得一个对象实例。
>
> 主要用于`跟踪对象垃圾回收的状态，在这个对象被回收时可以收到一个系统通知或者后续添加进一步的处理。`

`虚引用`必须与`引用队列`联合使用，当准备回收一个对象时，发现对象存在`虚引用`，就会在回收对象之前把`虚引用`加入关联的`引用队列`中，可以根据`引用队列`是否已加入`虚引用`来判断被引用的对象是否要被回收。

```java
public static void main(String[] args) throws InterruptedException {
        Object o1 = new Object();
        ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
        PhantomReference<Object> phantomReference = new PhantomReference<Object>(o1,referenceQueue);

        System.out.println(o1); //java.lang.Object@xxx
        System.out.println(referenceQueue.poll()); //null
        System.out.println(phantomReference.get()); //null

        o1 = null;
        System.gc();
        Thread.sleep(3000);

        System.out.println(o1); //null 
        System.out.println(referenceQueue.poll()); //引用队列中 java.lang.PhantomReference@xxx
        System.out.println(phantomReference.get());//null
    }
```



#### 引用队列`Reference Queue`

> 配合引用工作的，当GC准备回收一个对象时，如果发现对象被`软引用或弱引用或虚引用`包装，就会在回收对象前将引用加入到`引用队列`中。
>
> **如果一个引用(软引用、弱引用、虚引用)存在引用队列中，则表示该引用指向的对象已被回收。**

```java
    public static void main(String[] args) {
        ReferenceQueue<String> referenceQueue = new ReferenceQueue<>();
        String s = new String("11");
        WeakReference<String> weakReference = new WeakReference<String>(s,referenceQueue);
        s= null;
        System.gc();
        System.err.println(s); //null
        //被回收了对象
        System.err.println(weakReference.isEnqueued()); //true
        System.err.println(referenceQueue.poll()); //java.lang.ref.WeakReference@5e481248
    }
```

`ReferenceQueue`是一个先进先出的队列。



#### 引用 `Reference`

上面的`弱引用、软引用、虚引用`都是`java.lang.ref.Reference`的直接子类。

`Reference`主要存在四种状态

- Active

  新创建的实例为`Active`状态

- Pending

  当实例等待进入`引用队列`时，处于`Pending`状态。未注册`引用队列`时永远不会处于此状态

- Enqueued

  当实例进入`引用队列`时，处于`Enqueued`状态。未注册`引用队列`时永远不会处于此状态

- Inactive

  该引用实例指向的实际对象一定已被回收。引用实例未注册`引用队列`直接从`Active`状态进入到`Inactive`状态。



#### 使用实例

例如`Leakcanary`，内部主要原理就是：`弱引用+引用队列`。

在一个Activity执行完`onDestroy()`后，用`WeakReference`引用`Activity`，再将引用对象与`ReferenceQueue`关联。这时再从`ReferenceQueue`中查看是否存在该弱引用对象

如果存在，执行一次手动GC，再次移除引用，如果弱引用不存在，则这次执行结束。

如果不存在，执行一次手动GC，再次查看是否存在弱引用对象，如果不存在则表示已发生内存泄露。





### 回收方法区

> 方法区的GC性价比比较低，方法区的回收条件比较苛刻，比较少用。

方法区的垃圾收集主要回收两部分内容：

#### 废弃常量

如果常量池中存在字符串`wxy`，但是当前没有任何String对象引用该字符串常量。就表示了当前这个常量处于废弃状态，当发生内存回收的时候而且有必要进行方法区回收，就会清理`wxy`出常量池。

#### 无用类

需要同时满足以下三个条件：

- 该类所有的实例都已被回收，Java堆中已不存在该类的任何实例
- 加载该类的类加载器已被回收，所以必须是**自定义加载器去加载**
- 该类对应的`java.lang.Class`对象没有在任何地方被引用，也无法在任何地方被反射访问。

GC可以对满足上述三个条件的无用类进行回收，但不是必然会进行回收。



### 垃圾收集算法



#### 标记-清除算法

> 最基础的收集算法

算法分为两个阶段：

- 标记(Mark)

  `标记所有需要回收的对象`。找到内存中所有的GC Root对象，然后找到与上述对象没有关联的对象(`需要回收的垃圾`)。

- 清除(Sweep)

  `回收掉所有被标记的对象`。

{% fullimage /images/jvm/gc_mark_sweep.png ,标记-清除算法,标记-清除算法%}

优点：

- 实现简单，不需要移动对象

缺点：

- `执行效率不稳定`。如果存在大部分需要回收的对象，导致标记、清除两个动作执行效率降低。
- `内存碎片问题`。清除过程后会产生大量不连续的内存碎片，导致下次分配大对象时没有连续内存导致再次触发GC。

#### 复制算法

将可用内存分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，将剩下的对象复制到另一块内存上。然后再清理已使用过的另一块内存，完成GC。

{% fullimage /images/jvm/gc_copying.png,整理算法,整理算法 %}

优点：

- 按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片

缺点：

- `可用内存减少一半`。对象存活率较高时会频繁进行复制。



#### 标记-整理算法

> `标记-清除算法`的升级版

算法分为两个阶段：

- 标记(Mark)

  `标记所有需要回收的对象`。找到内存中所有的GC Root对象，然后找到与上述对象没有关联的对象(`需要回收的垃圾`)。

- 整理(Compact)

  `移动剩余存活对象到内存的某一端`。然后直接清理边界外的内存对象。

{% fullimage /images/jvm/gc_mark_compact.png,标记-整理算法,标记-整理算法%}

优点：

- 避免内存碎片的产生 *相比于标记-清除算法*
- 高效利用内存空间 *相比于复制算法*

缺点：

- 移动对象的过程必须全程暂停用户应用程序(**STW-Stop The World**)，降低了效率。

#### *分代收集理论

> 主流JVM使用的垃圾收集算法

根据对象存活的周期不同，把堆内存划分几块，一般分为**新生代**和**老年代**。根据不同年代的特点使用不同的垃圾收集算法。

**对于新创建的对象会在`新生代`分配内存，此区域的对象生命周期一般较短。如果经过多次回收仍然存活下来，则将他们转移到`老年代`中。**

##### 新生代

> 新生成的对象优先存放`新生代`，新生代对象朝生夕死，存活率很低，所以回收效率很高。
>
> 新生代经常要进行一些复制操作，所以一般采用**复制算法**进行回收。

新生代继续分为3部分：`Eden、From Survivor、To Survivor`。这三部分并非均分，而是按照**8:1:1**的比例进行划分。

新生代GC过程如下：

1. 绝大多数新创建对象都会先存放在`Eden`区
2. 当`Eden`区满时，会执行一次GC(**Minor GC**)，清除`Eden`区的垃圾对象，将存活的对象复制到`From Survivor`区
3. 当`From Survivor`区满时，会执行一次`Minor GC`，将存活的对象复制到`To Survivor`区。*如果存在可以`晋升`的对象会直接放到`老年代`中。*
4. 将`From Survivor`与`To Survivor`区域进行切换。*每次切换过程中即GC过后，对象的年龄+1，直到达到`晋升年龄阈值(一般为15)`之后，对象被放到老年代。——`长期存活的对象直接进入老年代`*



`晋升年龄阈值`：该值的大小影响着对象在`新生代`中的停留时间，可以通过`-XX:MaxTenuringThreshold`配置数值。

##### 老年代

> 在新生代经历了N次(`晋升年龄阈值`)回收之后仍然存活的对象，就会放入`老年代`。
>
> `老年代`的内存一般比`新生代`大(大概比例为2:1)，可以存放更多的对象。
>
> *如果对象比较大(`升入老年代对象大小`)，并且新生代无法存放，则这个大对象会被直接分配`老年代`上。——`大对象直接进入老年代`。*
>
> `老年代`通常使用`标记-清除、标记-整理 `算法进行GC。

`升入老年代对象大小`：如果新生代的对象需要分配一块较大连续内存空间才可以存放，且该大小大于该值，则直接在`老年代`进行内存分配，可以通过`-XX:PretenureSizeThreshold`配置数值。

`老年代`发生的GC称为`Major GC`，针对`老年代`的GC操作，通常伴随一次`Minor GC`

在某些虚拟机中，还有`Full GC`，针对`新生代与老年代`的GC，回收整个堆的内存。发生时，会导致长时间停顿。

<br>

`老年代`有时候会引用`新生代`对象，当执行`Minor GC`时可能就需要查询`老年代`的引用情况。导致GC过程低效。

所以老年代会维护一个`Card table`，记录老年代所引用的新生代对象信息，在发生`Minor GC`时，只要检查`Card table`即可。

 

{% fullimage /images/jvm/gc_java_heap_memory.png,Java堆内存,Java堆内存 %}

### 垃圾收集器

{% fullimage /images/jvm/gc_collectors.png,垃圾收集器,垃圾收集器 %}

#### Serial收集器

> **最基本，发展历史最悠久的收集器。**
>
> 是一个`单线程`工作的收集器，只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是进行垃圾回收时，必须停止其他所有工作线程(`Stop The World`)，直到收集结束。

**新生代采用`复制算法`，老年代采用`标记-整理算法`。**

优点：

- 简单而高效
- 没有线程交互的开销，可以获得最高的单线程收集效率

缺点：

- Stop The World可能时间过长



#### ParNew收集器

> 其实就是`Serial收集器`的多线程版本，不同的就是使用多线程进行垃圾收集

**新生代采用`复制算法`，老年代采用`标记-整理算法`。**

除了`Serial收集器`以外，只有它可以和`CMS收集器`配合工作。

默认开启的收集线程数与CPU数一致。



#### *CMS收集器

> 以`获取最短回收停顿时间`为目标的收集器。
>
> 基于`标记-清除`算法实现。整体上来说是`内存回收线程`与`用户线程`并发执行。
>
> 应用于`老年代`的垃圾收集器。

运作过程比较复杂，分为以下4步：

1. `初始标记`

   暂停所有其他线程，并记录下与GC Roots关联的对象。**触发Stop-The-World**

2. `并发标记`

   从GC Roots直接关联对象开始遍历整个对象图的过程(`GC Roots Tracing`)。这个过程耗时较长但不用停顿用户线程，主要跟踪记录发生引用更新的地方。

3. `重新标记`

   为了修正`并发标记`期间，因用户线程继续运行而导致标记产生变动的对象的标记记录。**触发Stop-The-World**

4. `并发清除`

   清理删除掉在标记阶段判断的垃圾对象，可以与用户线程一起工作。

{% fullimage /images/jvm/gc_collectors_CMS.png,CMS,CMS %}

优点：

- 并发收集
- 低停顿

缺点：

- 对CPU资源非常敏感
- 无法处理`浮动垃圾`
- 产生大量内存碎片(由于`标记-清除算法`的实现)

#### *G1收集器

> 主要面向服务器的垃圾收集器，以极高概率满足GC、停顿时间要求的同时，还具备高吞吐量性能特征。

具备如下特点：

- **并行与并发**

  使用多个CPU缩短`STW`时间，还可以通过并发的方式让Java程序继续运行。

- **分代收集**

  分代概念在`G1收集器`中进行了保留，但`G1`可以直接管理新生代和老年代，然后采用不同的方式去管理。

- **空间整合**

  整体基于`标记-整理算法`，局部(两个Region之间)采用了`复制算法`

- **可预测的停顿**

  除了追求低停顿外，还可以建立可预测的时间模型，用户去指定期望停顿时间。



运作过程分为以下4步：

1. `初始标记`

   标记一下与GC Roots直接关联的对象。**需要停顿线程**

2. `并发标记`

   从GC Roots对象开始对堆中对象进行可达性分析，找出需要回收的对象。

3. `最终标记`

   修正`并发标记`期间因为用户线程继续运行导致标记发生变动的对象。**需要停顿线程**

4. `筛选回收`

   对各个Region的回收价值和成本进行排序，根据用户指定`期望停顿时间`制定回收计划。然后把决定回收的那部分Region存活对象复制到空Region中，再清理旧Region空间。

   **必须暂停用户线程，因为涉及到对象的移动。**



`Region`

Java堆的内存布局被划分为多个大小相等的区域(`Region`)，虽然保留了分代概念，但`新生代`与`老年代`都变成了`Region`的集合。

`G1收集器`认为大小超过`Region`容量一半的对象判定为`大对象`，存放于`Humongous`区域。

`可停顿的时间模型`

在后台维护了一个优先列表，每次根据用户设置的`期望停顿时间`，优先选择回收价值(`回收获得的空间大小以及回收所需时间的经验值`)最大的Region。

`记忆集(Remembered Set)`

每个`Region`都会存在一个`记忆集`，里面记录下别的`Region`指向自己的指针并标记这些指针分别在哪些页卡的范围之内。

通常约占Heap大小的20%或者更高。



#### ZGC收集器

> 在JDK 11中加入的低延迟垃圾收集器。

主要新增了两项新技术

- 着色指针

  将少量额外的信息存储在指针上，在对象的内存发生变化的时候，指针颜色就会发生变化。就能知道当前对象状态

- 读屏障

  由于`着色指针`的存在，程序访问对象的时候可以轻易知道对象的存储状态，若发现指针变色，则会触发`读屏障`，会更新指针并重新返回结果，虽然存在一定的耗费但是可以达到与用户线程并发的效果。



> 与标记对象的传统算法相比。ZGC在指针上做标记，并在访问指针时加入`读屏障`，比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就先把指针更新为有效地址再返回，永远只会有单个对象读取时有概率被减速(需要更新指针地址)，而不会再发生Stop-The-World。



## JVM内存分配策略

- 对象优先在`Eden区`分配

  > 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次`Minor GC`。
  >
  > 每次GC后，对象依然存在就会进入`两块Survivor区内`。

- 大对象直接进入`老年代`

  >  大对象：那种很长的字符串或者元素数量很多的数据。**需要连续内存空间的Java对象。**

- 长期存活的对象直接进入`老年代`

  > 每经过一次`Minor GC`仍然存活的对象，并且能被`Survivor`容纳，其对象年龄就会+1，当达到`晋升年龄阈值`对象就会晋升到`老年代`。
  >
  > `晋升年龄阈值`：默认为15，通过`-XX:MaxTenuringThreshold`进行配置。

- 动态对象年龄判定

  > 为了更好适应不同的内存情况，不一定对象达到年龄阈值才能晋升老年代。
  >
  > 如果在`survivor区`相同年龄的对象大小总和超过`Survivor`空间的一半，所有年龄大于或等于该年龄的对象都可以直接晋升老年代。

- 空间分配担保

  > 如果`survivor`没有足够空间存放在`Eden区`存活对象，这些对象将通过`分配担保机制`直接进入老年代。

## Java内存模型(JMM)

### CPU缓存一致性
#### 缓存一致性问题

线程是CPU调度的最小单位。

由于CPU的发展，执行速度越来越快，内存与CPU的执行差距会越来越大，导致数据的交互需要等待较长时间。

因此，为了提升CPU的使用效率，在CPU中添加了`高速缓存(cache)`作为内存与CPU之间的缓冲：*将运算需要的数据复制到Cache中，让运算能快速进行，当运算完成之后，将运算结果刷回主内存，这样CPU就无需等待内存读写完毕。*

由于每个CPU都有自己的`cache`，当多个CPU共同操作一块主内存时，可能导致各自`cache`中的数据不一致，发生**缓存一致性**问题。

为了解决`缓存一致性`的问题，需要各个处理器访问缓存时遵循一些协议，在读写时要根据协议来进行操作，这类协议有**MESI**、`MSI`、`MOSI`等。
####  MESI(缓存一致性协议)
>  当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态。
> 因此当其他CPU需要读取这个变量时，发现自己缓存变量的缓存行无效时，就需要从主内存中重新获取变量值。

上面介绍到*每个处理器都会去检测自己的缓存变量是否有效？*，这个检测机制就是通过**嗅探**来实现的。

`嗅探`：每个处理器都会去检测`主内存`上的数据来判断自己的缓存数据是否有效，当CPU发现缓存数据对应的内存地址发生修改时，就意味着缓存数据已经无效，需要做以下几步：

- 将当前CPU的缓存行设置无效
- 当CPU需要操作该数据时，就需要重新从主内存中读取数据
- 读取完毕后更新自己的缓存对象



`嗅探`需要持续的从主内存检测数据并且通过`CAS`进行循环获取，导致**占用的总线带宽较高**。这也被称之为**总线风暴**。

### 指令重排

为了使CPU的运算单元能够尽量被充分利用，CPU会对输入的代码进行重排序处理，也就是`处理器优化`。

#### `as-if-serial`

> 不管怎么重排序，都不允许单线程下的程序执行结果发生改变。

编译器、runtime和CPU都必须遵守`as-if-serial`协议。

一般重排序分为以下三种：

- 编译器优化的重排序
- 指令级并行的重排序
- 内存系统的重排序

### 概念

描述了Java程序中各种变量(`线程共享变量`)的访问规则，屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各种平台都能达到一致的内存访问效果。

### 主要目的

定义程序中各种变量的访问规则，关注的是`虚拟机中把变量值存储到内存中和从内存中取出变量值这样的底层细节`。

此处的`变量`指的是`实例字段、静态字段和构成诉诸对象的元素`，不包括`局部变量`。

### 主内存与工作内存

{%  fullimage /images/JVM-JMM.png,线程-主内存-工作内存的交互关系,线程-主内存-工作内存的交互关系%}

**主内存**：所有的变量都存储于此

**工作内存**：每条线程都存在自己的`工作内存`，保存了该线程使用`变量的主内存副本`。线程对变量所有的操作都必须在`工作内存`中进行，无法直接操作`主内存`数据。不同线程之间也不能互相访问`工作内存`中的变量，线程间传值都需要通过`主内存`中转完成。



### 原子性、可见性和有序性

> JMM模型具有以下特征：**原子性、可见性、有序性**。

#### 原子性

> 对基本数据类型的变量读取和赋值操作都是`原子性`操作，**这些操作不可被中断，要么执行，要么不执行。**

可以通过`synchronized`和`Lock`实现`原子性`，因为两者能够**保证同一时刻只有一个线程访问该代码块**。

`原子性`操作包括：

- 除`long`和`double`之外的基本数据类型赋值和读取操作，如果需要保证原子性需要加上`volatile`关键字修饰
- 所有引用`refrence`的赋值操作
- `java.util.concurrent.atomic.*`包下的操作，例如`AtomicInteger`

#### 可见性

> 当一个线程修改了共享变量的值，其他线程能够立即得知这个修改，**修改后的值立即更新到主内存中，在其他线程读取时，会重新从主内存获取值**。

`volatile`可以保证`可见性`，具体参考[volatile](#volatile)

`synchronized`和`Lock`也可以保证`可见性`，可以保证**同一时刻只有一个线程访问共享资源，并在其释放锁之前将修改变量更新到主内存中**。

`final`也可以实现`可见性`，对象一旦初始化完成，其他线程都可以该值。



#### 有序性

> 如果在本线程内观察，所有的操作都是有序的；——`as-if-serial`
>
> 如果其他线程观察，所有操作都是无序的。——`指令重排序`
>
> **程序代码按照先后顺序执行。**

`volatile`可以保证`有序性`，具体参考[volatile](#volatile)

`synchronized`和`Lock`也可以保证`有序性`，可以保证**同一时刻只有一个线程能执行同步代码，线程可以顺序执行代码**。



### Happens-Before(先行发生)原则

JMM天生具有一定的`有序性`，不需要任何手段保证有序性，通常这个称为**happens-before(先行发生)原则**。

> 用于描述两个操作的内存可见性，通过保证可见性的机制可以让应用程序免于数据竞争干扰。
>
> **如果一个操作的执行结果需要另一操作可见，那么这俩操作必须存在Happen-before关系。**

主要有以下几条规则：

#### 程序次序规则

按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。*需要考虑分支、循环等结构。*

#### 管程锁定规则

一个锁的`unlock`操作先行发生于`lock`操作

#### volatile变量规则

对`volatile`修饰的变量的写操作先行发生于读操作

#### 线程启动规则

`Thread`的`start()`先行发生于此线程的每一个动作。

#### 线程中断规则

`Thread`的`interrupt()`先行发生于线程中断检测代码`Thread.interrupted()`

#### 线程终止规则

`Thread`的所有操作都先行发生于此线程的终止检测，例如`Thread.join()，Thread.isAlive()`

#### 对象终结规则

对象的初始化完成先行发生于`finalize()`执行

> `finalize`：垃圾回收器准备释放内存的时候，会先调用`finalize()`，可以在执行的时候做点工作。

#### 传递性

如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

### volatile

{%post_link volatile关键字分析%}

## 线程

{%post_link Java线程相关合集整理%}





## Class文件结构(字节码)



## DVM&ART(Android虚拟机)



## 参考链接

[彻底弄懂Java中的常量池](https://cloud.tencent.com/developer/article/1450501)

[字符串常量池相关问题](https://www.cnblogs.com/gxyandwmm/p/9495923.html)

[Java四大引用](https://juejin.im/post/5ec73c99f265da770c0ee3b1#heading-8)

[Java应用的GC优化](https://tech.meituan.com/2017/12/29/jvm-optimize.html)

[ZGC基础概念](https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw)]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Binder</title>
    <url>/2020/05/19/%E9%87%8D%E5%AD%A6Binder/</url>
    <content><![CDATA[
<!--基于先前的学习内容，重新进行Binder理论知识的整理-->

## Linux传统的进程间通信原理

{% fullimage /images/Linux-IPC-Basics.png,Linux进程结构,Linux进程结构%}

### 进程隔离

> 保护系统中进程互不干扰。在操作系统中，进程之间数据是不互通的，相互之间无法访问数据，保证数据的安全星。

在`进程隔离`的条件下，需要通过`IPC(Inter Process Communication)机制`进行进程间的通信。

### 进程空间划分

> 操作系统的核心是**内核**，独立于普通的应用程序，可以访问受保护的内存空间以及底层的硬件设备。

为了使用户进程不能操作内核，保证内核的安全性。所以操作系统将虚拟空间划分为两部分：

- **内核空间**(一般占1GB)

  系统内核运行的空间

- **用户空间**(一般占3GB)

  用于用户程序执行的空间

**用户空间在不同进程之间不能共享，内核空间是各个进程之间共享的。**

### 系统调用

> 用户空间的权限低于内核空间，导致用户空间无法直接访问内核资源(例如文件操作、网络访问等)，就需要借助**系统调用**实现内核资源访问。

**系统调用**是用户空间访问内核的唯一方式，保证了所有资源访问都是在内核的控制下进行，避免用户程序对系统资源的越级访问，提升系统的安全和稳定性。

Linux采用两级保护机制：

- 0级供系统内核使用
- 3级供用户程序使用

当进程使用`系统调用`执行内核代码时，进程就进入了**内核态**，此时处理器处于`0级·`；当进程执行自己的代码时，进程就进入**用户态**，此时处理器位于`3级·`。

`系统调用`主要通过以下两个函数实现：

- `copy_from_user`：将数据从用户空间拷贝到内核空间
- `copy_to_user`：将数据从内核空间拷贝到用户空间



### 传统IPC功能实现

{% fullimage /images/Linux-IPC.png,Linux IPC,Linux IPC%}

1. 发送进程通过`系统调用 copy_from_user·`把自己的`内存缓存区(发送进程)`的数据拷贝到`内核缓存区`中
2. 内核程序通过`系统调用 copy_to_user`把内核缓存区的数据拷贝到接收进程的`内存缓存区`中

传统IPC通信过程中暴露了两个明显的缺点：

1. **性能低下**，需要经历两次数据拷贝过程：`发送进程内存缓存区 -> 内核缓存区 -> 接收进程内存缓存区`
2. **空间、时间浪费**，接收方需要事先开辟一块内存空间准备接受发送方的数据，由于不能确定数据的大小。所以只能开辟一块较大的空间(`空间浪费`)或者先行获取发送数据的大小(`时间浪费`)。



## Binder通信



]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder系列-Binder</title>
    <url>/2019/01/06/Binder%E7%B3%BB%E5%88%97-Binder/</url>
    <content><![CDATA[
# Android Binder机制相关以及AIDL介绍

{% fullimage /images/Android-Binder机制.png,Android-Binder机制,Android-Binder机制%}

> 在Linux中，为了避免一个进程对其他进程的干扰，进程之间是相互独立的。
>
> Android的进程间通信采用了Binder基于**性能,稳定和安全**方面的考虑：。
>
> 性能：在移动设备上对性能的要求是比较严苛的，在Linux上通信方式例如管道，Socket都需要复制两次数据，Binder只需一次。
>
> `对于消息队列、Socket和管道而言，数据先从发送方的缓存区拷贝到内核开辟的缓存区中，再从内核缓存区拷贝至接收方缓存区，需要两次拷贝过程；Binder是从发送方缓存区到内核的缓存区，而接受方的缓存区与内核缓存区映射在同一块物理地址上，节省了一次数据拷贝的过程。`
>
> 安全：传统的Linux通信是不包含通信双方的身份验证的，Binder自带身份验证，提高了安全性。
>
> `Android提供了UID机制，可以有效的鉴别用户身份。`
>
> 稳定：Binder基于C/S架构，Client有什么需求就丢给Server去完成，职责明确又独立，稳定性更好。

概念：

- 直观来说，Binder是Android中的一个类，实现了IBinder接口。
- IPC角度来说，Binder是Android中的一种跨进程通信方式。
- Android Framework角度来说，Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁。
- 应用层来说，Binder是客户端和服务端进行通信的媒介。

## 1.Linux下传统的进程间通信原理

> Binder通信原理也是基于Linux 下的IPC机制实现的。

### 基本概念

{% fullimage /images/Linux-IPC-Basics.png,Linux进程结构,Linux进程结构%}

上图展示的结构中涉及了一些基础概念：

#### 进程隔离

> 保护系统中进程互不干扰而设计的。在操作系统中，进程与进程间的内存是不共享的，进程1是无法直接访问进程2的数据，来保证数据的安全性。
>
> 进程隔离的条件下，进程之间传递数据就要依靠`IPC机制`进行进程间通信。

进程隔离的实现是利用了`虚拟地址空间`。

#### 进程空间划分

为了保护用户进程不能直接操作内核，保证内核的安全性，所以操作系统从逻辑上将虚拟空间划分为 *内核空间*，*用户空间*。

- **内核空间** 一般占1GB

  系统内核运行的空间，

- **用户空间** 一般占3GB

  用于用户程序执行的空间

*用户空间在不同进程之间是不能共享的，内核空间是各个进程之间共享的*。

#### 系统调用

由于用户空间的权限低于内核空间，但当用户空间需要访问内核资源时(文件操作，访问网络等)，就需要其他方式实现。

**唯一的方式就是通过操作系统提供的`系统调用`接口**。可以做到所有的资源访问都是在内核的控制下进行的，避免用户程序对系统资源的越权访问，提升系统安全和稳定性。

当一个进程执行`系统调用`使用内核代码时，该进程就进入了**内核态**，此时处理器处于特权最高的**0级**内核代码中执行。

当进程执行用户自己的代码时，进程就处于**用户态**。此时处理器处于**3级**用户代码中执行。

#### 传统IPC通信实现

{% fullimage /images/Linux-IPC.png,Linux IPC,Linux IPC%}

根据上述流程，传统IPC机制基本是以下两步：

- 发送方通过`系统调用 copy_from_user`把要发送的数据拷贝到`内核缓存区`中
- 接收方需要开辟一块内存空间，内核通过`系统调用 copy_to_user`将内核缓存区的数据拷贝至接收方开辟的空间中。

以上流程有两个明显的缺点：

1. 性能低下，因为数据需要经历`发送方内存缓存区 -> 内核缓存区 -> 接收方内存缓存区`，就需要两次拷贝过程。
2. 接收方需要开辟一块空间用于存储数据，但并不知道要开辟多大的空间存储数据。因此只能开辟尽量大的空间或者先行获取数据的大小，可能存在时间和空间上的浪费。



#### Linux中的进程通信手段

##### 管道

> 在创建时分配一个page大小的内存，缓存区大小比较有限

##### 消息队列

> 信息需要复制两次，带来额外的CPU消耗；不适合频繁或信息量大的通信

##### 共享内存

> 无需复制，共享缓冲区直接附加到进程的虚拟地址空间，速度快；**但是无法解决进程间同步问题**。

##### 套接字(Socket)

> 接口通用但是传输效率低，主要用于不同机器之间的通信。

##### 信号量

> 常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。**主要作为进程间以及不同线程线程间的数据同步手段。**

##### 信号

> 不适用于信息交换，更适用于进程中断控制，比如非法内存访问。

## 2.Binder基本原理

### Binder底层原理

#### 动态内核可加载模块和内存映射(`mmap()`)

传统的IPC机制例如`管道、Socket`都是内核的一部分，天生就是支持通过内核来实现进程间通信。Binder机制并不是内核中的一部分，这就依赖于`动态内核可加载模块`机制。

*由于模块是具有独立功能的程序，他可以被单独编译但无法独立运行。所以可以利用该机制，动态的将一个内核模块添加至内核空间内，用户进程之间就可以通过这个内核模块实现通信。*

> 在Android系统中，加载进内核空间的模块就是 **Binder驱动**。

Binder机制是如何利用这个模块`Binder驱动`进行进程间通信的呢？

这个时候就涉及到了另一个概念：**内存映射**。

`内存映射`是通过`mmap()`来实现的，`mmap()`是操作系统中的一种内存映射的方法。`内存映射`就是将用户空间内的一块内存区域映射进内核空间。当映射关系建立完成后，用户对这块区域的修改可以直接反映到内核空间，而内核空间对映射区域的修改也可以直接反馈至用户空间。

#### 实现原理

`Binder借助了内存映射的方法，建立内存映射后，发送方发过来的数据拷贝到内核缓存区数据后，对应用户空间的映射区域也能接收到传递的数据，相当于少了一次拷贝过程。`

{% fullimage /images/Binder-IPC.png,Binder IPC,Binder IPC%}

根据流程图分析：

1. `Binder驱动`首先会在内核空间创建一个`数据接收缓存区`
2. 内核空间中有一块`内核缓存区`，利用`内存映射`将`内核缓存区`与`数据接收缓存区`建立映射关系，以及建立与`接收方用户空间`的映射关系。
3. 发送进程将调用`系统调用 copy_from_user`将数据`copy`到`内核缓存区`，由于已经建立了映射关系，相当于数据直接`copy`进接收进程的用户空间。

## 3.Binder通信模型

Binder通信采用了**C/S架构**。在Android系统的Binder机制中，由一系列系统组件组成，分别是

- `Client` 需要自己实现，客户端进程
- `Server` 需要自己实现，服务端进程
- `Service Manager` 由系统提供，将字符形式的Binder名字转化为Client中对该Binder的引用，使得Client可以通过Binder名字获得Server中Binder实体的引用。
- `Binder 驱动` 由系统提供，负责建立进程间的Binder连接，将Client请求转发到具体的Server中执行，并将Server返回值传回给Client。还有进程间的数据交互等底层操作

{% fullimage /images/IPC-Binder.jpg, Binder架构图, Binder架构图 %}

Client,Server,Service Manager处于用户空间，Binder驱动位于内核空间。

下面介绍四个组成部分的作用：

- **Service Manager：**服务的管理者，指代的是Native层的ServiceManager(C++)，是整个Binder通信机制的大管家，是Android进程间通信机制的守护进程。将Binder的名字转换为Client中对该Binder的引用，使得Client可以通过Binder名字来获取Service中的引用。

  `ServiceManager`其实就是一个进程，里面维护了一张表，表里存储的是向它注册过的进程信息。

- **Binder驱动：**主要是驱动设备的**初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)**。

  和硬件设备没有任何关系。它工作于内核态，以misc设备注册在设备目录/dev下，用户可以通过/dev/binder访问它。负责进程之间binder通信的建立、传递、计数管理和数据的传递交互等底层支持。主要功能由`ioctl()/*主要负责在两个进程间收发IPC和IPC reply数据，常用命令为BINDER_WRITE_READ*/`实现。

- **Client&Service：**在Binder驱动和Service Manager提供的基础设施上进行C-S之间的通信。`Server进程启动时，将在本进程内运行的Service注册到Service Manager中，并且启动一个Binder线程池，用来接收Client请求。然后Client进程向Service Manager查询所需要的Service，并获得一个Binder代理对象，通过该代理对象向Service发出请求。`

四大组件彼此之间不是直接交互的，都是通过Binder驱动进行交互，从而实现IPC通信方式。**系统需要启动了Service Manager之后，Client端和Server端需要现获取了Service Manager接口后，才可以开始通信服务。**



## 4.Binder通信过程

1. 一个进程通过`BINDER_SET_CONTEXT_MGR`命令将自己注册成`ServiceManager`，`Binder驱动`就会给他创建一个Binder实体
2. `Server`通过`Binder驱动`向`ServiceManager`中注册Binder实体及其名字，声明可以对外提供服务。`Binder驱动`会为这个Binder创建位于内核中的实体节点以及`ServiceManager`中对实体的引用，将名字以及新建的引用打包给`ServiceManager`,`ServiceManager`将其填入查找表。
3. `Server`向`ServiceManager`中注册了Binder实体以及名字后，`Client`就可以通过`Binder驱动`请求`ServiceManager`根据名字获得`Server`的Binder引用。
4. 获得`Server`的Binder引用后，`Client`就可以通过`Binder驱动`直接和对应的Server通信。
5. `Server`接收请求后，需要通过`Binder驱动`将请求结果返回到`Client`中。

{%fullimage /images/Binder通信过程.png,Binder通信过程,Binder通信过程%}



## 5.Binder代理机制

`Client`通过`ServiceManager`拿到`Server`的Binder引用后，`Client`就可以向`Server`发起请求。

在这一步骤中，`Client`得到的`Server`的Binder引用，其实是一个`Object`，在这个`Object`实现了一些方法；`Client`拿到这个`Object`后就可以直接调用内部的方法了。

实际上，`Client`拿到的并不是`Server`在`ServiceManager`注册的Binder实体，由于经过了`Binder驱动`，在其中做了一次**对象转换**，将Binde实体包装成了一个代理对象(`ProxyObject`)，`ProxyObject`有着和`Object`一样的方法，但是这些方法的内部实现都是**空方法，唯一能做的就是把`Client`的请求参数交给`Binder驱动`。**

`Binder驱动`收到`ProxyObject`传递的方法以及参数后，会在`ServiceManager`中查询是否存在该方法，如果存在*`Binder驱动`就会把代理对象(`ProxyObject`)转换成实际`Server`对象(`Object`)*。然后调用对应的方法，经由`Binder驱动`把返回结果发回给`Client`。

上述流程就是`Binder的代理机制`。

{% fullimage /images/Binder代理机制.png,Binder代理机制,Binder代理机制%}



## 6.Binder完整定义

根据上述流程，可以对`Binder`进行一个简单的总结：*Binder是基于C/S结构的一种面向对象的IPC机制。包含`Client、Server、Binder驱动和ServiceManager`四大组成部分。*

在不同场景下，Binder有着不同的含义：

- 通常意义上来说，`Binder`指的就是Android的进程间通信机制
- 对于`Server`来说，Binder是提供具体实现的本地对象，在`ServiceManager`注册得到
- 对于`Client`来说，Binder是`Server`本地对象的一个引用，这个引用实际是是有`Binder驱动`进行`对象转换`得到的一个代理对象`ProxyObject`，`Client`通过`ProxyObject`访问`Server`的本地对象。
- 对于传输过程来说，Binder就是一个可以跨进程传输的对象。

## 7.Binder工作机制

> 需要配合客户端的实现分析，主要实现方式就是利用AIDL

### AIDL

> **Android接口定义语言 -- Android Interface Definition Language**
>
> 在Messenger中讲到它是基于AIDL的，但是只能处理串行的消息，如果有大量的消息同时发送进来，也只能一个个处理，而且不支持跨进程调用服务端的方法，就需要用到AIDL来处理上述情况。
>
> **AIDL默认是同步调用的，若需要异步调用--可以添加一个异步回调接口执行结果异步回调给调用方，需要使用RemoteCallbackList**
>
> **AIDL本质上就是系统为我们提供了一种快速实现Binder的工具，我们可以不依赖于AIDL，自己去完全实现一个Binder。**

#### 1.AIDL支持的数据类型

- 基本数据类型：`byte、int、long、float、double、boolean，char`
- String 和 CharSequence
- ArrayList，HashMap(**包括key，每个元素必须可以被AIDL支持**)
- 实现了Parcelabe接口的对象 **必须要显示Import进来**
- 所有AIDL接口本身也会被调用**必须要显示Import进来**

#### 2.定向tag

> 除了基本数据类型，其他类型的参数必须加上方向 **in,out,inout**，用于表示在跨进程通信中的数据流向。

- `in`：表示数据只能由客户端流向服务端。服务端会收到这个对象的完整数据，**但在服务端对对象进行修改不会对客户端传递进来的对象造成影响。**
- `out`：表示数据只能由服务端传递到客户端。服务端会接受到这个对象的空对象，**但在服务端接收到的空对象有任何修改之后客户端会同步发生变化。**
- `inout`：表示数据可以在服务端和客户端之间双向流通。服务端会收到这个对象的完整数据，**且客户端会同步服务端对该对象的任何改动。**

#### 3.关键类和方法

> 添加完AIDL文件后，会自动帮我们生成对应的Java文件。本质上是为我们提供了一种快速实现Binder的工具而已。

1. 定义一个AIDL文件

   ```java
   //Book.aidl
   //书的实体类
   parcelable Book;
   
   //IOnNewBookArrivedListener.aidl
   //监听新增书本事件
   import com.example.wxy.ipc.Book;
   interface IOnNewBookArrivedListener {
       void onNewBookArrived(in Book newBook);
   }
   
   //IBookManager.aidl
   //书籍管理类
   import com.example.wxy.ipc.Book;
   import com.example.wxy.ipc.IOnNewBookArrivedListener;
   interface IBookManager {
       //获取书本总数
       List<Book> getBookList();
       //插入新书
       Book addBook(in Book book);
       //注册监听
       void registerListener(IOnNewBookArrivedListener listener);
       //解注册监听
       void unregisterListener(IOnNewBookArrivedListener listener);
   }
   ```

   根据上述代码发现，aidl文件中引用到的AIDL接口或者Model对象，无论是否在同一个Package目录下，都必须**显示引用**。

2. AIDL文件定义完成后，会自动生成对应的Java文件，里面自动完成了Binder的逻辑。接下来进行结构分析

   `IBookManage` 主要声明了Client可以调用的Server方法

   ```java
   public interface IBookManager extends IInterafce{
     private static final java.lang.String DESCRIPTOR = "com.example.wxy.ipc.IBookManager";
     
     public java.util.List<com.example.wxy.ipc.Book> getBookList() throws android.os.RemoteException;
     public com.example.wxy.ipc.Book addBook(com.example.wxy.ipc.Book book) throws android.os.RemoteException;
     public void registerListener(com.example.wxy.ipc.IOnNewBookArrivedListener listener) throws android.os.RemoteException;
     public void unregisterListener(com.example.wxy.ipc.IOnNewBookArrivedListener listener) throws android.os.RemoteException;
     
     static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
     static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);
     static final int TRANSACTION_registerListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2);
     static final int TRANSACTION_unregisterListener = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3);
   }
   ```

   `Iinterface`代表的是Server进程需要具备什么功能，对应的就是 `Client`进程可以调用的方法

   `IBookManager.Stub` 实现一个跨进程调用对象`Stub`。`Stub`继承自`Binder`，说明它是一个`Server进程`的Binder本地对象。需要实现`Server进程`提供的能力。

   ```java
   public static abstract class Stub extends android.os.Binder implements com.example.wxy.ipc.IBookManager {
     public Stub() {
        this.attachInterface(this, DESCRIPTOR);
     }
     
      //返回当前Binder对象
      // IBinder 这个代表了一种跨进程通信的能力。只要实现了这个接口，这个对象就可以跨进程传输。Client和Server进程都要实现该接口。
      @Override
      public android.os.IBinder asBinder() {
               return this;
      }  
    
   }
   ```

   关键方法: 

   1. `asInterface()` 通常用在Client `bindService()`成功后即在`onServiceConnected()`中调用该方法，可以把返回的IBinder对象转换为具体的`IIntergace`接口，就可以直接调用`Server`提供的对用方法。

      ```java
      public static com.example.wxy.ipc.IBookManager asInterface(android.os.IBinder obj) {
                  if ((obj == null)) {
                      return null;
                  }
                  android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
                  if (((iin != null) && (iin instanceof com.example.wxy.ipc.IBookManager))) {
                      return ((com.example.wxy.ipc.IBookManager) iin);
                  }
                  return new com.example.wxy.ipc.IBookManager.Stub.Proxy(obj);
         }
      
      ```

      生成的代码中调用到了`queryLocalInterface()`去查找本地的Binder对象，

      - 如果找到了就证明`Client和Server`当前在统一进程内，直接就返回Binder对象。
      - 如果没找到意味`Client和Server`不在统一进程内，就会返回一个Binder代理对象，即`ProxyObject`。

      当`Client`端在创建与服务端之间的连接时，调用`bindService()`需要创建一个`ServiceConnection`对象作为入参。在对应方法的回调`onServiceConnected()`需要调用`asInterface()`获取到对应对象。

      ```java
      // Client端实现 对应Android中的Activity
          private ServiceConnection mConnection = new ServiceConnection() {
              @Override
              public void onServiceConnected(ComponentName name, IBinder service) {
                  //获取到对应的BookManager对象
                  mBookManager = IBookManager.Stub.asInterface(service);
                  try {
                      List<Book> list = mBookManager.getBookList();
                      mBookManager.registerListener(onNewBookArrivedListener);
                  } catch (RemoteException e) {
                      e.printStackTrace();
                  }
              }
      
              @Override
              public void onServiceDisconnected(ComponentName name) {
                  Log.e("Client", "绑定失败");
              }
          };
      ```

   2. `onTransact()` 运行在服务器端的Binder线程池中，客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法处理。参数介绍：

      - `code`：可以确定客户端所请求的方法是哪个
      - `data`：取出目标方法所需参数
      - `reply`：里面填写请求的返回值
      - `flags`：设置进行IPC的模式，0双向流通 1单向流通 **AIDL生成的.java文件均设置0

      ```java
      @Override
         public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {  
            switch (code) {
                      case INTERFACE_TRANSACTION: {
                          reply.writeString(descriptor);
                          return true;
                      }
                      case TRANSACTION_getBookList: {
                          data.enforceInterface(descriptor);
                          java.util.List<com.example.wxy.ipc.Book> _result = this.getBookList();
                          reply.writeNoException();
                          reply.writeTypedList(_result);
                          return true;
                      }
                      case TRANSACTION_addBook: {
                          data.enforceInterface(descriptor);
                          com.example.wxy.ipc.Book _arg0;
                          if ((0 != data.readInt())) {
                              _arg0 = com.example.wxy.ipc.Book.CREATOR.createFromParcel(data);
                          } else {
                              _arg0 = null;
                          }
                          //实际内部实现 就交由 Stub类的 子类实现
                          com.example.wxy.ipc.Book _result = this.addBook(_arg0);
                          reply.writeNoException();
                          if ((_result != null)) {
                              reply.writeInt(1);
                              _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                          } else {
                              reply.writeInt(0);
                          }
                          return true;
                      }
                ...
         }
      ```

      处理完由客户端调用的`transcat()`传递进来的`_data`，再将处理完的数据写入到`_reply`中。

      工作流程为：

      1. 获取由`transcat()`传入的数据，根据对应的`code`执行相应方法
      2. 执行方法后，解析对应传递过来的数据`_data`
      3. 将需要回传的数据写入`_reply`中，传回给客户端



      生成代码中 有调用到对应生成的`addBook()`等定义方法。这些方法的实际实现都要在`Server`端中实现。
    
      ```java
      // Server端  对应Android中的Service
      //需要注意并发处理
       private CopyOnWriteArrayList<Book> mBookList = new CopyOnWriteArrayList<>();
       private Binder mBinder = new IBookManager.Stub() {
              @Override
              public List<Book> getBookList() throws RemoteException {
                  return mBookList;
              }
      
              @Override
              public Book addBook(Book book) throws RemoteException {
                  book.setName("new Name in");
                  //实现了对应的 addBook方法
                  mBookList.add(book);
                  return book;
              }
         
              @Override
              public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException {
                  mListenList.register(listener);
              }
      
              @Override
              public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException {
                  mListenList.unregister(listener);
              }
          };
      ```



   `IBookManager.Stub.Proxy` 它并没有继承自Binder，而是包含了一个IBinder对象，这个对象其实是BinderProxy，说明它是Server在Client中的本地代理对象(`ProxyObject`)。这个类运行在`Client`，`Client`调用这个类来调用服务端的代码(涉及到了**代理模式**)

   ```java
    private static class Proxy implements com.example.wxy.ipc.IBookManager {
               private android.os.IBinder mRemote;
   
               Proxy(android.os.IBinder remote) {
                   mRemote = remote;
               }
   
               @Override
               public android.os.IBinder asBinder() {
                   return mRemote;
               }
   
               public java.lang.String getInterfaceDescriptor() {
                   return DESCRIPTOR;
               }
   
               /**
                * Demonstrates some basic types that you can use as parameters
                * and return values in AIDL.
                */
               @Override
               public java.util.List<com.example.wxy.ipc.Book> getBookList() throws android.os.RemoteException {
                   android.os.Parcel _data = android.os.Parcel.obtain();
                   android.os.Parcel _reply = android.os.Parcel.obtain();
                   java.util.List<com.example.wxy.ipc.Book> _result;
                   try {
                       _data.writeInterfaceToken(DESCRIPTOR);
                       mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0);
                       _reply.readException();
                       _result = _reply.createTypedArrayList(com.example.wxy.ipc.Book.CREATOR);
                   } finally {
                       _reply.recycle();
                       _data.recycle();
                   }
                   return _result;
               }
   
               @Override
               public com.example.wxy.ipc.Book addBookIn(com.example.wxy.ipc.Book book) throws android.os.RemoteException {
                   android.os.Parcel _data = android.os.Parcel.obtain();
                   android.os.Parcel _reply = android.os.Parcel.obtain();
                   com.example.wxy.ipc.Book _result;
                   try {
                       _data.writeInterfaceToken(DESCRIPTOR);
                       if ((book != null)) {
                           _data.writeInt(1);
                           book.writeToParcel(_data, 0);
                       } else {
                           _data.writeInt(0);
                       }
                       mRemote.transact(Stub.TRANSACTION_addBookIn, _data, _reply, 0);
                       _reply.readException();
                       if ((0 != _reply.readInt())) {
                           _result = com.example.wxy.ipc.Book.CREATOR.createFromParcel(_reply);
                       } else {
                           _result = null;
                       }
                   } finally {
                       _reply.recycle();
                       _data.recycle();
                   }
                   return _result;
               }
      ...
        
    }
   ```

   分析上述生成的代码：

   - `_data _reply`：`_data`存储传参的数据，`_reply`存储方法的返回值数据
   - `transcat(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags)`：客户端和服务端通信的核心方法。调用后会挂起当前线程，等候服务端执行任务完成通知并接受返回的`_reply`数据。
     - `code`：分配的方法ID是自动生成的

   工作流程为：

   1. 生成`_data` 和` _reply`数据，在`_data`中存入客户端数据
   2. 调用`transcat()`传递数据至服务端，并调用服务端中`onTranscat()`的指定方法
   3. 接收`_reply`数据，取出服务端返回的数据使用

结构拆分明确后，可以大概的理解内部的工作机制。

{% fullimage /images/Binder-workflow.png, Binder工作机制, Binder工作机制 %}

- **Client调用远程Binder代理对象，Client线程挂起，等待Server响应数据**

  客户端要访问Binder的远程服务，就要获取远程服务的Binder对象在Binder驱动中的`mRemote`引用，获取到引用后既可以调用相关方法。

- **Binder代理对象将请求发送给`Binder驱动`**

  在服务端成功Binder对象后，Binder驱动会创建一个`mRemote`对象，客户端可以借助它调用`transcat()`向服务端发送消息

- **`Binder驱动`将请求派发给Server端**

  在Server端创建好一个Binder对象后，内部就会开启一个线程用于接收Binder驱动发送的消息，收到消息后就会执行`onTransact()`,然后按照参数执行不同的服务端代码。

- **唤醒Client线程，返回结果**

  `onTranscat()`处理完成后，将结果写入`_reply`中并返回至`Binder驱动`，唤醒被挂起的Client线程。

#### 4.可能产生的问题

1. 可能会产生ANR

   由于客户端在调用远程服务方法时，客户端线程会被挂起，如果服务端的方法执行比较耗时，就会导致客户端ANR，或者在`onServiceConnected`和`onServiceDisconnected`中调用了服务端的耗时方法也会导致ANR。

   当服务端调用客户端的listener方法时，该方法会运行在客户端的`binder线程池中`，若调用了耗时方法，也会导致ANR。

   **客户端调用放在非UI线程**

2. AIDL解注册失败

   > 服务端无法找到注册时使用的listener而导致解注册失败。**因为Binder客户端会把传递过来的对象重新转化并生成一个新的对象，而且对象是不能跨进程传输的，对象跨进程传输的本质就是序列化和反序列化的过程。**

   这时需要用到`RemoteCallBackList`，是系统专门提供用于删除跨进程的listener的接口，而且内部实现了线程同步的功能**(内部使用了`synchronized`)**。使用注意事项:**`beginBroadcast`和`finishBroadcast`必须要配对使用。**

3. 性能损耗较大

   > 客户端频繁调用服务端方法，就需要实现一个**观察者模式**，当客户端的数据发生变化时再去通知服务端操作，减少频繁查询。

#### 5.拓展

1. 权限验证

   > 默认情况下，远程服务所有人都可以进行连接并调用，所以应该需要加入权限验证系统来保证安全。

   ```xml
   //在AndroidManifest.xml中定义该权限    
   <permission android:name="com.example.wxy.permission.checkBook"
                   android:protectionLevel="normal"/>
   //如果注册了该权限，则可以绑定成功 否则失败
   <uses-permission android:name="com.example.wxy.permission.checkBook"/>
   
   
   <service
       android:name=".service.AIDLService"
       android:exported="true">
           <intent-filter>
               <action android:name="com.example.wxy"/>
               <category android:name="android.intent.category.DEFAULT"/>
           </intent-filter>
   </service>
   ```

## 8.Binder连接池

> 首先回顾一下AIDL的使用方式：①创建一个Service和AIDL接口②创建一个类继承自AIDL接口中的Stub类并实现Stub中的抽象方法③在Service的onBind中返回这个类的对象④客户端绑定Service后就可以直接访问服务端的方法。
>
> 当业务需求越来越多时，上述的创建方式就会产生很多Service类，导致系统资源耗费颜值、应用过度重量级的问题。所以产生了`Binder连接池`的概念。

> 主要作用为 **将每个业务模块的Binder请求统一转发到远程Service上去执行，从而避免重复创建Service**。   

工作原理：

{% fullimage /images/BinderPool.png,BinderPool工作原理, BinderPool工作原理%}

每个业务模块创建自己的AIDL接口并实现，然后向服务端传递自己的**唯一标识(BinderCode)及对应的Binder对象**。服务端只要一个Service，然后实现`queryBinder()`接口，根据唯一标识返回对应的Binder对象。

实现方式：

- 创建对应的AIDL文件并有具体实现
- 创建BinderPool.java以及IBinderPool.aidl文件
- 实现远程服务BinderPoolService，并在onBind()中返回实例化的BinderPool对象
- 实现BinderPool方法，并在`queryBinder()`中做好对应处理
- 客户端调用BinderPoolService



## 9.Binder跨进程传输大文件

Intent传递数据是有大小限制的，







## 参考链接

[一次Binder通信最多可以传输多大的数据](https://www.jianshu.com/p/ea4fc6aefaa8)

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关及其拓展(五) -- Java内存模型</title>
    <url>/2018/05/09/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%94/</url>
    <content><![CDATA[
# Java内存模型

> 屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到的一致的内存访问效果。

主要目标：

**定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。变量包括了实例字段、静态字段和构成对象的元素，但不包括局部变量和方法参数（他们为线程私有，不被共享）。**

{% fullimage /images/Java内存模型.png,Java内存模型,Java内存模型%}

## 主内存与工作内存

> Java内存模型规定了所有的变量都存储在`主内存(Main Memory)`中，每条线程还有自己的`工作内存(Work Memory)`。工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取，赋值等)必须在工作内存中进行，不能直接读取主内存的变量。**不同线程之间也无法直接访问对方工作内存中的变量，线程间传递变量均需通过主内存完成。**

{%  fullimage /images/JVM-JMM.png,线程-主内存-工作内存的交互关系,线程-主内存-工作内存的交互关系%}

主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。

## 内存间交互操作

> 关于主内存与工作内存具体的交互协议，**即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，JMM中定义了8种操作来完成.**
>
> `每种操作都是原子、不可再分`
>
>

| 类型         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| Lock(锁定)   | 作用于主内存的变量，把一个变量表示为一条线程独占的状态       |
| Unlock(解锁) | 作用于主内存的变量，把一个锁定状态的变量释放出来             |
| Read(读取)   | 作用于主内存的变量，一个变量值从主内存传输到线程的工作内存中 |
| Load(载入)   | 作用于工作内存的变量，从read操作中得到的值放入工作内存的变量副本中 |
| Use(使用)    | 作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行 |
| Assign(赋值) | 作用于工作内存的变量，把接收到的值赋值给工作内存中的变量，遇到需要赋值的情况会执行 |
| Store(存储)  | 作用于工作内存的变量，把工作内存中的变量值传到主内存中       |
| Write(写入)  | 作用于主内存的变量，把store操作中得到的工作内存中的变量的值放入主内存的变量中 |

> 如果要把一个变量从主内存复制到工作内存，就要顺序执行`read`和`load`操作，如果要从工作内存同步回主内存，就要顺序的执行`store`和`write`操作。

## 原子性、可见性和有序性

> Java内存模型就是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。这也是并发编程的三大概念。

### 原子性(Atomicity)

> **对基本数据类型的读取和赋值都是原子操作**，所谓原子性操作就代指这些**操作是不可中断**的，要么做完，要么就不执行。

Java内存模型只保证了基本读取和赋值是原子操作。如果要实现更大范围操作的原子性，就需要通过`synchronized`和`lock`实现。

>  Java中的原子操作包括：
>
> - 除long和double之外的基本数据类型赋值操作 *long和double占用的字节数是8即64bit，在32位操作系统上去读写数据需要两步完成，每一步取32位数据。需要添加volatile关键字保证*
> - 所有引用reference的赋值操作
> - `java.concurrent.Atomic.*` 包下所有类的操作

### 可见性(Visibility)

> 当一个线程修改了共享变量的值，其他线程能够立即得知这个值的修改。

Java内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式实现可见性。

**当一个共享变量被volatile修饰时，他会保证修改的值会立即更新到主内存，当有其他线程需要读取时，会立即从主内存中读取新值。**

通过`synchronized`和`lock`也可保证可见性，**保证同一时刻只有一个线程获取锁然后执行代码，并且在释放锁之前会将变量的修改刷新到主内存中，保证可见性。**

拓展：`final`也可以实现可见性，final修饰字段一旦初始化完成，在其他线程中就可以看到fianl的值。

### 有序性(Ordering)

> 程序执行的顺序按照代码的先后顺序执行

Java内存模型允许编译器和处理器对指令进行重排序，但是规定了`as-if-serial`（不管怎么重排序，程序的执行结果不能改变）。

**指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。**

`volatile`本身包含了禁止指令重排序的语义，而`synchronized`通过**一个变量在同一个时刻只允许一条线程对其lock操作**实现有序性。

***要想并发程序正确的执行，必须要保证原子性、可见性和有序性，只要有一个没有被保证，就有可能导致程序运行不正确。***

## 先行发生原则(happens-before)

> JMM具备一些先天的`有序性`。**不需要通过任何手段就可以保证有序性，称之为`先行发生原则`。如果两个操作的执行次序无法从先行发生原则推导出来，他们之间就没有顺序性保障，就不能保证有序性。**

主要有以下规则：

- **程序次序规则**：写在前面的代码先行发生于写在后面的(按照控制流顺序而不是代码顺序)
- **管程锁定规则**：一个解锁操作先行于时间后面发生的同一个线程的加锁操作
- **volatile变量规则**：对一个volatile变量的写操作先行发生于读操作
- **线程启动规则**：Thread对象的`start()`优先于该线程的任意操作
- **传递性**：如果操作A早于B，B又早于C，则A早于C
- **线程中断规则**：线程`interrupt()`调用早于该线程的中断检测。`Thread.interrupted()`
- **线程终止规则**：线程中的所有操作都先行发生于对此线程的终止检测。`Thread.join()或者Thread.isAlive()`
- **对象终结规则**：一个对象的初始化完成早于`finalize()`





[JMM相关讨论](https://www.v2ex.com/t/671776#reply21)]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter学习大纲</title>
    <url>/2019/04/01/Flutter%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[
> `Flutter`是Google全新推出的跨平台应用开发框架，主打**跨平台、高保真、高性能**，需要通过`Dart`语言进行开发App，编写完成后即可实现 *一套代码运行多个平台*，目前只是支持了`Android及iOS`平台，后续还会拓展到PC上。

整套学习大纲会按照由表及里，由简到难的过程进行深入的学习`Flutter`。



- [ ] 搭建开发环境 
- [ ] 新建一个Flutter应用
- [ ] **Dart语言相关**
- [ ] 基础部件
- [ ] **Widget**
- [ ] 自定义Widget
- [ ] 事件处理与通知
- [ ] 文件操作与网络请求
- [ ] Flutter插件
- [ ] **Flutter性能优化**
- [ ] Flutter与Native的通信
- [ ] **Flutter布局原理**
- [ ] **Flutter界面绘制原理**
- [ ] **Flutter运行机制**
- [ ] **Flutter初始化流程**



上述章节的学习会在实现一个完整的App基础上进行，**学以致用**。

]]></content>
      <tags>
        <tag>Flutter学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化</title>
    <url>/2018/12/20/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[
<!--简要解释一下 ANR？为什么会发生 ANR？如何避免发生 ANR？如何定位 ANR？ANR发生条件？如何分析ANR-->

<!--bitmap高效加载，三级缓存等。-->

<!--android性能优化：布局优化、绘制优化、内存泄露优化、bitmap、内存泄露等。-->

<!--内存泄露的概念？android中发生的场景？怎么解决？讲了handler、动画等。-->

<!--Android性能优化工具使用（这个问题建议配合Android中的性能优化）-->

<!--App启动优化，如何检测启动耗时 -->

{% fullimage /images/Android性能优化.png,Android性能优化,Android性能优化%}

针对Android中的性能优化，主要有以下几个有效的优化方法：

> **布局优化、绘制优化、内存泄漏优化、响应速度优化、ListView/RecyclerView及Bitmap优化、线程优化、其他**

## 布局优化

> 核心思想就是：**减少布局文件的层级。**



### 删除布局中无用的控件和层次，其次有选择的使用性能比较低的ViewGroup。

可以使用RelativeLayout来减少嵌套，从而达到减少层级的目的。*如果层级相同的情况，可以使用LinearLayout相比更高效。*

> 如果LinearLayout需要实现`android:weight`那么就需要绘制两次，还是用RelativeLayout好。

<br>

### 采用`<include>、<merge>、ViewStub，Space`优化布局

`<include>`：主要用于布局复用

`<merge>`：一般和`<include>`配合使用，可以减少布局的层级

`ViewStub`：提供了按需加载的功能，提供初始化效率。

`Space`：主要用于进行空白占位，本身`onDraw()`不实现。

{% post_link include、merge-ViewStub相关%}

#### 尽可能少用`wrap_content`

会增加布局测量时的计算成本，应尽可能少用。

<br>



### 布局优化工具

#### Hierarchy Viewer

> Android SDK自带的可视化调试工具，用来检查布局嵌套和绘制的时间。

#### Android Lint

> 可以利用其中的 XML布局检查 ，是否出现布局层级问题。

## 绘制优化

> 核心思想是：
>
> - **避免在`View.onDraw()`执行大量操作。**
> - **避免过度绘制**

### `onDraw()`中不要创建新的局部对象

`onDraw()`会被频繁调用，就会在一瞬间产生大量的临时对象，占用过多的内存并且导致系统频繁的发生GC，降低系统的执行效率。

### `onDraw()`不要做耗时的任务或者执行大量的循环操作

Google官方推荐的标准是：**View的绘制帧率保证60fps**。尽量降低`onDraw()`的复杂度可以有效提高帧率。



### 避免过度绘制

> 在屏幕上某个像素在同一帧的时间的被绘制多次。在多层次重叠的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区被绘制多次，同时也会浪费大量的CPU和GPU资源。

产生这一情况主要有两个原因：

- 在XML布局中，控件有重叠且都设置了背景。
- View的`onDraw()`在同一区域绘制了多次

{% fullimage /images/GPU过度绘制.png,GPU过度绘制,GPU过度绘制%}

#### 过度绘制优化原则

- 一些过度绘制是无法避免的。例如文字和背景导致的过度绘制
- 尽可能将过度绘制控制在2次及以下，原色和蓝色最佳
- 尽可能避免粉色和红色，或者尽可能减少这些区域
- 不允许存在面积超过屏幕1/4区域的3次(`粉色`)及以上过度绘制

#### 过度绘制优化方法

1. 移除默认的Window背景

   > 需要在项目初期就做好，有可能因为某些界面忘记设置背景色，而导致显示了黑色的背景。

2. 移除不必要的背景

   > 例如在ListView中如果设置了ListView的背景色，且Item背景与其一致，就不需要去设置背景了。

3. 优化布局，减少层级

4. 自定义View中，在`onDraw()`利用`clipRect()及quickReject()`进行重叠布局的优化绘制

   > `clipRect()`：设置需要绘制的区域，当某个View的部分区域不可见时，就不进行绘制。
   >
   > `quickReject()`：判断是否和某个矩形相交，跳过相交局域减少绘制层级。

### 应用卡顿

> 在16ms内无法完成界面的渲染、计算和绘制，就会产生丢帧的现象，丢帧就会造成应用的卡顿。

造成应用卡顿的原因主要有以下几点：

- `过度绘制`：加重CPU与GPU渲染压力，导致渲染时间过长。
- `布局嵌套过多`：导致CPU与GPU压力变大
- `动画执行次数过多`：导致CPU与GPU压力变大
- `频繁GC`：执行GC，所有操作需要暂停，GC完成才可以继续操作。阻塞了渲染过程。
- `执行耗时操作`：会阻塞线程

### 绘制性能分析工具

#### Profile GPU Rendering

> 是Android系统提供的开发辅助功能，在屏幕上会显示出彩色的柱状图。

绿色的横线为警戒线，超过这条线就以为着渲染时间超过了16ms。**尽量要保持垂直彩色柱不要超过警戒线。**

#### TraceView

> Android SDK自带的工具，用于对Android的应用程序以及Frtamework层代码进行性能分析。

使用方式：

`在代码中加入调试语句`：在开始监控的地方调用`Debug.startMethodTracing()`，结束监控的地方调用`Debug.stopMethodTracing()`。系统会在SD卡生成trace文件，将trace文件导出SD卡中，通过`traceView`命令对trace文件进行分析。**注意设置内存卡访问权限。**

## 内存泄漏优化

> `内存泄漏(Memory Leak)`：程序在申请内存后，无法释放已申请的内存空间。是造成应用OOM的主要原因之一。
>
> `内存溢出(out of memory)`：程序在申请内存时，没有足够的内存空间可以使用。

### 内存泄漏的原因

#### `静态变量导致的内存泄漏`

> 一个静态变量又是非静态内部类会一直持有对外部类的引用，导致外部类Activity无法被回收。*例如静态context、静态View*

示例代码：

```java
public class MainActivity extends Activity {
  private static Context context;
  
  @Override
  protected void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    sContext = this;
  }
}
```

解决方法：可以将内部类设为静态内部类或独立出来；使用`context.getApplicationContext()`。

<br>

#### `单例模式导致的内存泄漏`

> 单例传入的参数来自Activity，使得持有对Activity的引用。

示例代码：

```java
public class SingleInstance {
  private static volatile SingleInstance sInstance;
  private Context context;
  
  private SingleInstance(Context _context){
    this.context = _context;
  }
  
  public SingleInstance getInstance(Context _context){
    if(sInstance==null){
      synchronized(SingleInstance.class){
        if(sInstance==null){
          sInstance= new SingleInstance(_context);
        }
      }
    }
  }
}
```

解决方法：传入的`context`修正成`ApplicationContext`。

<br>

#### `属性动画导致的内存泄漏`

> 在Activity中播放无限循环动画且没有在`onDestroy()`中去停止动画，使得View持有了Activity

示例代码：

```java
objectAnimator.setRepeatCount(ValueAnimator.InFINITE);

protected void onDestroy(){
  super.onDestroy();
}
```

解决方法：在`onDestroy()`或其他时机调用`animator.cancel()`及时取消动画。

<br>

#### `Handler导致的内存泄漏`

> Handler的`Message`被存储在`MessageQueue`中，有些`Message`并不能马上被处理，就会存在的时间很长。导致Handler无法被回收。
>
> Handler又是非静态的匿名内部类的实例，会隐式持有对外部类Activity的引用，使得引用关系会持续到消息被全部处理，导致内存泄漏。

示例代码：

```java
public class HandlerActivity extends Activity{
  
  @Override 
  protected void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    setContentView(R.layout.act_handler);
    Button button = findViewById(R.id.btn);
    final Handler mHandler = new Hnadler() {
      @Override
      public void handleMessage(Message msg){
        super.handleMessage(msg);
      }
    }
    btn.setOnClickListener(new View.OnClickListener(){
      @Override
      public void onClick(View v){
        mHandler.sendEmptyMessage(1);
      }
    })
  }
}
```

解决方法：

- `使用静态内部类+WeakReference弱引用`

  ```java
  private static class MyHandler extends Handler {
    private final WeakReference<HandlerActivity> mActivity;
    public MyHandler (HandlerActivity activity){
      mActivity = new WeakReference<HandlerActivity>(activity);
    }
    
    @Oberride
    public void handleMessage(Message msg){
       // do sth
    }
  }
  ```

  

- `外部类生命周期结束时清空消息队列(MessageQueue)`

  ```java
  @Override
  public void onDestroy(){
    if(myHandler!=null){
      myHandler.removeCallbacksAndMessages(null);
    }
    super.onDestroy();
  }
  ```

  

<br>

#### `线程导致的内存泄漏`

> AsyncTask/Runnable以*匿名内部类*的方式存在，会隐式持有对所在Activity的引用。

解决方法：

- 将AysncTask和Runnable设置为静态内部类或独立出来；

  ```java
  private static class MyAsyncTask extends AsyncTask<Void,Void,Void>{
    @Override
    protected Void doInBackground(Void... params){
      // do Sth
    }
  }
  ```

  

- 在线程内部采用弱引用保存Context引用

  ```java
  private static class MyThread extends Thread{
    WeakReference<ThreadActivity> mThreadActivity;
    public MyThread(ThreadActivity activity){
      mThreadActivity = new WeakReference<ThreadActivity>(activity);
    }
    @Override
    public void run(){
      super.run();
      if(mThreadActivity == null)
        return;
      if(mThreadActivity.get()!=null){
        mThreadActivity.get().doSth();
      }
    }
  }
  ```

  > 使用静态内部类：切断Activity对于MyTherad的强引用
  >
  > 使用弱引用：切断MyThread对于Activity的强引用。

<br>

#### `资源对象没关闭`

> 未及时注销资源导致内存泄漏，例如BroadcastReceiver、File、Cursor、Stream，Bitmap等。*往往都使用了缓冲，会造成内存泄漏。*

解决方法：在Activity销毁的时候需要及时关闭或者注销。还有在资源对象不使用时，一定要确保它们已经关闭并将引用置为null，通常在`finally`执行关闭。

> `BroadcastReceiver`：调用`unregisterReceiver()`
>
> `Cursor、Steam、File`：调用`close()`关闭

<br>

### 内存泄漏分析工具

#### MAT分析工具

> 利用DDMS生成堆存储文件，输出文件格式为`hprof`，利用MAT分析堆存储文件。

## 响应速度优化

> 核心思想：**避免在主线程中做耗时操作。**

将耗时操作放到线程中去执行，采用异步方式执行耗时操作。

> 如果在主线程中做太多事情，会导致Activity启动时出现黑屏现象，甚至出现**ANR**。
>
> 出现ANR的场景：
>
> - Activity5秒之内无法响应屏幕触摸事件或者键盘输入事件
> - BroadcaseReceiver在*前台广播10秒或后台广播60秒*未处理完操作
> - Service在*前台20秒后台200秒内*内无法执行完`onCreate()`操作

{% post_link ANR分析 %}

## ListView/RecyclerView优化和Bitmap优化

{% post_link ListView简析 %}

{% post_link RecycleView简析 %}

{% post_link Bitmap分析 %}

## 线程优化

> 核心思想：**采用线程池，避免程序中存在大量的Thread。**

线程池中可以重用内部的线程，从而避免了线程的创建和销毁所带来的性能开销，同时线程池还能有效控制线程池的最大并发数，避免大量的线程因为互相抢占系统资源从而导致阻塞现象的发生。

{% post_link Android-Study-Plan-XVII %}

## 其他性能优化建议

- 避免创建过多的对象
- 不要过度使用枚举，枚举占用的内存空间要比整型大（*大概4倍*）
- 常量请使用`static final`进行修饰
- 使用一些Android特有的数据结构，比如`SparseArray`(*减少了自动装箱和拆箱的消耗*)
- 适当使用弱引用和软引用
- 采用内存缓存和磁盘缓存
- 尽量采用静态内部类(*不会持有外部类的实例*)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--HashMap实现原理及解析</title>
    <url>/2018/05/09/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[
<!--主要是对HashMap，ArrayMap，ConcurrentHashmap-->

<!-- HashMap和HashTable的区别 , HashMap和ConcurrentHashMap的区别，HashMap的底层源码,HashMap的原理,ConcurrentHashMap，ArrayMap,SparseArray,hashmap线程不安全，请问为什么线程不安全？答，并发时会成环。什么时候成环？比如我有两个数据要装入hashmap。hashset和hashmap的区别，写代码使用hashmap实现一个简单的hashset。-->

<!-- https://juejin.im/post/59e86f9351882521ad0f4147, https://juejin.im/post/5a7592f4f265da4e8d42ded2 -->

<!-- hashmap实现的数据结构，数组、桶等。hashmap的哈希冲突解决方法：拉链法等。拉链法的优缺点。hashmap的参数及影响性能的关键参数：加载因子和初始容量。Resize操作的过程。hashmap容量为2次幂的原因。hashtable线程安全、synchronized加锁。hashtable和hashmap异同。为什么hashtable被弃用？-->

<!--关于HashMap扩容，1.8之前，如果不发生Hash冲突不会触发扩容，1.8之后，只要HashMap中的元素个数大于阈值，就发生扩容。（欢迎纠正）expectedSize / 0.75F + 1.0F  equals 和 hashcode 关系,HashMap遍历原理 -->

{% fullimage /images/HashMap结构.png,HashMap基础结构,HashMap基础结构%}

## HashMap定义

`HashMap`是基于`Map`接口实现的一种`键-值对<key,value>`的存储结构。内部允许`null`值，同时非有序，非同步(*线程不安全*)。它存储和查找数据时，是根据`key`的`hashcode`计算出具体的存储位置。内部最多允许一条记录的`key`为`null`。

`HashMap`的底层实现是**数组+链表+红黑树(Java 8新增的)**。

- 数组是HashMap的主体  *所以HashMap的容量指的就是 数组的长度。HashMap的size指的就为存储键值对数量。*

- 链表主要为了解决`Hash冲突`而存在的

  > 常用解决Hash冲突的方法有四种：
  >
  > - `开放地址法--线性探测` ：一般是在散列函数的基础上采取另一种算法，从而找到下一个空的数组位置，再将新数据填充进去。从而有效利用原数组空间。**若整个空间都找不到空余的地址，则产生溢出。**
  > - `链地址法（拉链法）`：基本思路是`全部具有同样哈希地址的而不同的Key的数据元素连接到同一个链表中`。加入在某个位置发生`Hash冲突`，就将新数据以链表的形式接在已有数据的后面。**HashMap1.7 是头插法，冲突的数据放在链表前端；HashMap在1.8之后是尾插法，冲突的数据放在链表尾端。**
  >   - 优点：无堆积现象存在，平均查找长度较短；节点空间是动态申请的，适用于无法缺点表长的情况；装填因子较大时，拉链法中增加的指针空间可忽略不计；删除节点的操作易于实现。
  >   - 缺点：指针需要额外的空间。
  > - `再哈希法`：同时构造多个不同的hash函数，直到不出现冲突为止。
  > - `建立公共溢出区`：将哈希表分为两部分：基本表和溢出表。所有冲突的数据都放到溢出表中。

- 当链表长度大于阈值(*一般为8*)时，会转换成红黑树，减少搜索时间(*最坏时间复杂度为 $ O(nlogn) $*)

## HashMap中的重要参数分析

```java
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 初始容量 左移4位得到16
    static final int MAXIMUM_CAPACITY = 1 << 30; // 最大容量
```

`capacity 容量`：必须是2的幂 并且小于 `MAXIMUM_CAPACITY`$2^{30}$。默认容量为16，如果不设置初始容量的话。

> 为什么要转换为 $2^n$？
>
> - `可以提高取余的效率`。为了防止链表过长，要保证键值对在数组中尽可能均匀分布。确定元素位置的方法是通过`hash%length(table长度)`计算得出的。但是单纯的取余方式消耗相对较大，由于通过位运算`hash & (length-1)`得到的结果是一样的。**一个数对$ 2^n $取余，就是要去这个数二进制的最低n位。**
> - `有利于提高计算元素存放位置的效率`。可以有效降低`Hash冲突`几率。

<br>

```java
    final float loadFactor; // 实际负载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认负载因子
    
    int threshold;//扩容阈值 = 容量 * 负载因子
```

`loadFactor`：HashMap在其容量增加前可达到的最大负载。

> **LoadFactor取值范围为0~∞，当为0时会抛出IllegalArgumentException异常。**
>
> 主要分两种情况分析：
>
> - `loadFactory偏大`：则`HashMap`装载程度就会越高。意味着可以容纳更多的元素，空间利用率就会变高。但元素多了，发生`Hash冲突`的几率就会越大，从而链表会拉长，查询效率就会变低。
> - `loadFactory偏小`：则`HashMap`装载程度就会变低，容纳的元素就会变少，空间利用率就会变低。但是发生`Hash冲突`的几率变低，并且链表长度也会较短，提高查询效率。由于会发生频繁的扩容操作，对性能也会有影响。
>
> 合理的设置`loadFactory`：
>
> - 关心内存的话，采用`时间换空间策略`，适当的加大加载因子，牺牲查询速度，来换取更大的使用空间。
> - 关心时间的话，采用`空间换时间策略`，适当的减小加载因子，从而提高查询性能，但需要考虑到频繁扩容带来的性能消耗。

`threshold`：扩容阈值。当哈希表的大小 >= 扩容阈值时，就会进行扩容操作。例如`capacity设置16，loadFactory设置0.75，则阈值为12。当存储元素个数>12时，触发扩容。`

> 计算方式为`capacity * loadFactor`。
>
> `扩容`：对哈希表进行`resize`操作，扩大到原先的两倍表格大小。

<br>

```java
    static final int TREEIFY_THRESHOLD = 8; //桶的树化阈值
    static final int UNTREEIFY_THRESHOLD = 6; //桶的链表还原阈值
    static final int MIN_TREEIFY_CAPACITY = 64; //最小树形化容量阈值
```

`TREEIFY_THRESHOLD`：当链表长度大于该值时，链表就会转换成红黑树。

`UNTREEIFY_THRESHOLD`：当红黑树节点小于该值时，红黑树会转换回聊表。发生在`resize()`扩容时。

`MIN_TREEIFY_CAPACITY`：当哈希表中的容量大于该值时，才允许链表转换红黑树。

<br>

```java
    transient Node<K,V>[] table;  // 存储数据的Node类型 数组，长度 = 2的幂；数组的每个元素 = 1个单链表
    transient int size;// HashMap的大小，即 HashMap中存储的键值对的数量
```

## HashMap源码解析

### HashMap初始化

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
  ...  
    /**
    * capacity = initialCapacity , loadFactory = loadFactor
    */   
    public HashMap(int initialCapacity, float loadFactor) {
        //初始容量不得 < 0
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +initialCapacity);
        //初始容量最大就是 MAXIMUM_CAPACITY    
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        //负载因子必须 > 0
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        //设置 扩容阈值
        this.threshold = tableSizeFor(initialCapacity);
    }
    
    /**
    * capacity = initialCapacity , loadFactory = 0.75
    */
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    
    /**
    * capacity = 16 , loadFactory = 0.75
    */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
    }
    
    /**
    * capacity = 16 , loadFactory = 0.75
    */
    public HashMap(Map<? extends K, ? extends V> m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        //将传入的子Map中的数据逐个添加到 HashMap中
        putMapEntries(m, false);
    }
  ...
 }
```

> 1. 在初始化`HashMap`中，只是进行了初始变量的赋值，还未进行`table`的设置
> 2. **真正初始化哈希表(table)是在第一次调用`put()`时。这个就是`lazy-load 懒加载`，直到被首次使用时，才会进行初始化。**

### HashMap插入数据 - put()

> 向`HashMap`中插入数据

```java
//调用示例
HashMap map = new HashMap();
map.put("Android","Best");
```

> `put()` 源码

```java
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```

在`put()`中，实现分为了两步：

- `hash()`：将`key`转化成`hash值`。通过`扰动函数`生成对应`hash值`。

  ```java
  static final int hash(Object key) {
          int h;
          return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
      }
  ```

  当`key==null`时，`hash值`为0 ，所以可以允许`key`设置为null，不过后续都会覆盖原值。

  当`key!=null`时，先获取原key的`hashcode()`，然后对其进行扰动处理： 按位异或(^) 再自身右移16位。

  > 所有处理的根本目的：**为了提高 存储键值对 的数组下标位置的随机性&分布均匀性，尽量避免出现Hash冲突。**

- `putVal()`：添加`key-value`的实际方法

  ```java
  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
    //记录当前的hash表
    Node<K,V>[] tab; 
    //记录当前的链表节点
    Node<K,V> p; 
    //n 记录hash表长度 i 记录当前操作的index
    int n, i;
    //tab 为空则创建
    if ((tab = table) == null || (n = tab.length) == 0)
      // 初始化hash表，并把初始化后的hash表长度值赋值给n
      n = (tab = resize()).length;
     
    //通过hash & (length -1 ) 确定最后的元素存储位置
    if ((p = tab[i = (n - 1) & hash]) == null)
          //计算得出位置没有元素存在，则新建节点
          tab[i] = newNode(hash, key, value, null);
    else {
          //当前位置已存在节点，可能是修改或者发生了Hash冲突
          Node<K,V> e; 
          K k;
          //得到的Hash值相同 且 定义的key也相同 可以判定为修改操作
          if (p.hash == hash &&((k = p.key) == key || (key != null && key.equals(k))))
              //将结果赋值给 e
              e = p;
          // 当前节点是树节点
          else if (p instanceof TreeNode)
              //往红黑树结构中 插入新节点或者更新对应节点 如果是新增节点返回值为 null
              e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
          // 当前节点为链表节点
          else {
              for (int binCount = 0; ; ++binCount) {
                  //遍历链表到尾端也没有找到对应key值相同节点
                  if ((e = p.next) == null) {
                      //向尾端插入新节点
                      p.next = newNode(hash, key, value, null);
                      //如果链表长度大于 阈值，就会转换成红黑树结构
                      if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                          treeifyBin(tab, hash);
                      break;
                  }
                  //如果链表中存在key相同且hash值相同的节点，则更新对应值
                  if (e.hash == hash &&((k = e.key) == key || (key != null && key.equals(k))))
                      break;
                  p = e;
              }
          }
          // 发现对应的key，直接用新的value替换旧value，并返回旧value
          if (e != null) { // existing mapping for key
              V oldValue = e.value;
              if (!onlyIfAbsent || oldValue == null)
                  e.value = value;
              //默认空实现，但是 LinkedHashMap有 实现该方法
              afterNodeAccess(e);
              return oldValue;
          }
          
          ++modCount;
          //当前存储的键值对大于 阈值 则进行扩容操作。
          if (++size > threshold)
              resize();
          afterNodeInsertion(evict);
          //证明该操作为新增操作
          return null;
      }
    
  }
  
  
  ```

  {% fullimage /images/HashMap-put流程.png,HashMap-put流程,HashMap-put流程%}

  总结流程：

  1. 先判断`Node<K,V>[] table`是否为空或者null，是则执行`resize()`进行扩容
  2. 根据插入的键值`key`的`hash值`，通过`(length-1) & hash值`得到需要的存储位置`index`，如果该位置上没有数据，则直接新建节点插入该位置。
  3. 如果存储位置已有元素存在，就需要判断`index`上的元素的`hash值和key`是否和当前要操作的一致，一致则判定为`修改操作`，覆盖原元素的value即可
  4. 当前存储位置既有元素，并且`key`也不一致，则判定该位置发生了`hash冲突`。接下来去判断当前头节点是否为树节点(*红黑树*)，如果是就以红黑树的方式插入或修改节点。
  5. 如果头节点不是树节点，则为默认的链表节点，将新增节点直接插入至链表的尾端，然后继续判断当前链表的长度是否大于`TREEIFY_THRESHOLD-1`，大于则转化为`红黑树`。遍历过程中发现`key`已经存在，则直接覆盖`value`。
  6. 插入成功后，在判断当前存储的键值对数量是否大于 `threshold阈值`，大于则触发扩容`resize()`操作。


### HashMap扩容 - resize()

#### 为什么需要扩容

  > 当需要存储的数据量大于HashMap的初始容量时，就会造成部分数据出现在链表或红黑树上，性能比直接通过数组下表查询数据差很多，就需要扩容来减少此类数据，提供查询性能。

#### 如何触发扩容

> 1. `初始化哈希表`。上文分析`put()`时看到，如果哈希表为null或空，就会触发扩容进行哈希表初始化。
> 2. `当前数组容量过小，需要进行扩容`。HashMap存储的键值对大于`threshold`时，会触发扩容。

#### 源码解析

```java
    final Node<K,V>[] resize() {
        //扩容操作前的数组
        Node<K,V>[] oldTab = table;
        //扩容前的数组长度
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        //扩容前的扩容阈值
        int oldThr = threshold;
        //新容量及新阈值初始
        int newCap, newThr = 0;
        
        //触发扩容的条件为  原数组容量过小
        if (oldCap > 0) {
            //扩容前的数组长度已经达到最大值，则无法继续扩容
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            //扩容后数组长度依然满足条件 则进行扩容
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                //调整扩容阈值为原先2倍
                newThr = oldThr << 1; // double threshold
        }
        //触发扩容条件为 初始化哈希表
        else if (oldThr > 0) 
            newCap = oldThr;
        
        else {               
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        //计算新的扩容阈值上限
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        
        threshold = newThr;
        @SuppressWarnings({"rawtypes","uncheck ed"})
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        //替换当前在用的数组
        table = newTab;
        
        //将扩容前的数据迁移到新表中
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        //数据是直接在数组上，直接进行赋值
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        //数据在红黑树上，需要用红黑树的迁移方法
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { 
                        //数据在链表上 进行链表结构的扩容
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            //原索引
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            //原索引 + oldcap
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        //原索引值放到新数组中
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        //原索引 + oldcap 放到新数组中
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }

//树结构的扩容操作
 final void split(HashMap<K,V> map, Node<K,V>[] tab, int index, int bit) {
            TreeNode<K,V> b = this;
            // Relink into lo and hi lists, preserving order
            TreeNode<K,V> loHead = null, loTail = null;
            TreeNode<K,V> hiHead = null, hiTail = null;
            int lc = 0, hc = 0;
            for (TreeNode<K,V> e = b, next; e != null; e = next) {
                next = (TreeNode<K,V>)e.next;
                e.next = null;
                //bit 指向了 oldcap
                if ((e.hash & bit) == 0) {
                    if ((e.prev = loTail) == null)
                        loHead = e;
                    else
                        loTail.next = e;
                    loTail = e;
                    ++lc;
                }
                else {
                    if ((e.prev = hiTail) == null)
                        hiHead = e;
                    else
                        hiTail.next = e;
                    hiTail = e;
                    ++hc;
                }
            }

            if (loHead != null) {
                //小于树还原阈值，就需要重新变回链表样式
                if (lc <= UNTREEIFY_THRESHOLD)
                    tab[index] = loHead.untreeify(map);
                else {
                    tab[index] = loHead;
                    if (hiHead != null) // (else is already treeified)
                        loHead.treeify(tab);
                }
            }
            if (hiHead != null) {
                if (hc <= UNTREEIFY_THRESHOLD)
                    tab[index + bit] = hiHead.untreeify(map);
                else {
                    tab[index + bit] = hiHead;
                    if (loHead != null)
                        hiHead.treeify(tab);
                }
            }
        }
```

根据源码发现，扩容机制会在原基础上扩大两倍的容量进行存储。*扩容后就会把原先在链表以及红黑树上的数据，重新分配到新的数组上去。*

由于我们使用的2次幂的扩展(*每次扩容为原大小的2倍*)，所以元素在扩容后数组的位置要不在原位置（`index`），要不就在原位置加上扩容前的数组长度(`index + olcCap`)。

{% fullimage /images/扩容前后对比.png,扩容前后对比,扩容前后对比%}

简单的描述下，在链表上的数据如何进行扩容处理：

- 遍历旧表，如果元素的next为空(`node.nect == null`)，直接取余后放入新数组
- 元素后面接了一个链表，那么需要新建两条链表，`hi链和lo链`
- 开始遍历链表，计算每个元素的`hash值 & oldcap`的值，如果为0则插入`lo链末端`，不为0则插入`hi链末端`
- 遍历完成后，将两条链的头节点放入新数组中。`iohead`放入原来的位置，`hihead`放入原位置加上`oldcap`处。

{% fullimage /images/HashMap扩容过程.png,HashMap扩容过程,HashMap扩容过程%}

>  扩容后的元素移动方式就是**要不在原位置，要不就是原位置加上旧容量值的位置。** 

### HashMap获取数据 - get()

> 从HashMap获取数据

```java
map.get("Android");
```

> `get()`源码

```java
    public V get(Object key) {
        Node<K,V> e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
    //根据计算出的Hash值 去获取对应结果
    final Node<K,V> getNode(int hash, Object key) {
        //记录当前的hash表
        Node<K,V>[] tab;
        //first 记录对应hash位置的第一个节点
        Node<K,V> first, e; 
        int n; 
        K k;
        //判断当前元素的存储位置是否有元素存在
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (first = tab[(n - 1) & hash]) != null) {
            //头结点的hash值和要获取key的hash值相同 且 key相等
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
                //返回头结点
                return first;
            //数组中不存在相等节点
            if ((e = first.next) != null) {
                //当前位置结构是 红黑树
                if (first instanceof TreeNode)
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                do {
                    //当前位置结构是 链表
                  /**
                   * 遍历单链表，逐一比较链表节点，链表节点的hash值与key的hash值相等，并且key也相等
                   */
                    if (e.hash == hash &&((k = e.key) == key || (key != null && key.equals(k))))
                        //返回对应节点
                        return e;
                } while ((e = e.next) != null);
            }
        }
        //经过上述方式都没找到 就返回null
        return null;
    }
```

{% fullimage /images/HashMap-get流程.png,HashMap-get流程,HashMap-get流程%}

总结流程：

- 先调用`key.hashcode ^ (h>>>16)`计算出`key`的`hash值`
- 根据计算出的`hash值`，通过`(length-1) & hash值`计算出存储位置`table[i]`，判断位置上是否有元素存在
- 存储位置上没有元素存在，则直接返回null。
- 存储位置上存在元素，首先比较头节点(`头节点在数组上`)，如果头节点的`key hash值`和要获取`key hash值`相同并且`first.key == key`，则返回该位置的头节点。
- 头节点元素不是要找的元素，就需要判定头节点的结构
- 头节点结构为 红黑树 (`first instanceof TreeNode`)，按照红黑树的方式遍历查找节点，有就返回，没有返回null
- 头节点结构为 链表(`first instanceof Node`)，遍历单链表，逐一进行比较，当链表节点的`key hash值`和要获取`key hash值`相同并且`first.key == key`，则返回该节点；遍历结束都没找到，就返回null。



## 拓展

### HashMap和HashTable以及HashSet的区别

> HashMap
>
> - 基于`AbstractMap`类，实现`Map、Cloneable(被克隆)、Serializable(序列化)`接口
>
> - HashMap的`key,value`都可以为`null`，`HashMap`遇到`key == null`时，数据会放在`table[0]`上
> - HashMap初始容量为16，负载因子默认0.75,并且容器长度一定是2次幂。扩容时，也已2倍大小进行扩容。
> - HashMap是先将`key`经过`key.hashcode() ^ (h>>>16)`计算出`hash值`，在拿`hash值`经过`hash & (length -1 )`得到最终存储位置
> - HashMap不是线程安全，如果想线程安全，可以通过`Collections.synchronizedMap()`包裹HashMap，实质上是对HashMap的所有操作加了锁(*用synchronized进行修饰*)。导致运行效率下降，推荐使用`ConcurrentHashMap`。

<br>

> HashTable
>
> - 基于`Map`接口和`Dictionry`类
>
> - HashTable的`key,value`不允许为`null`，如果`key ==null`，抛出空指针异常
> - HashTable初始容量为11，负载因子默认0.75，扩容时是以原容量的两倍加1进行扩容，即`newCap = (oldCap << 1)+1`
> - HashTable用的是除留余数法计算存储位置的.`int index = (hash & 0x7FFFFFFF) % tab.length`
> - HashTable是线程安全的，每个操作方法都用`synchronized`进行修饰保证同步，运行效率低，建议使用`ConcurrentHashMap`替换。

<br>

> HashSet
>
> - 实现了Set接口
> - 由于HashSet底层由HashMap实现，所以扩容机制与HashMap相同
> - HashSet只能存储对象，无法存储键值对。利用`add(E e)`插入对象，实质使用的是`HashMap.put(e,new Object())`进行操作。
> - HashSet和HashMap一样是线程不安全的。

### HashMap非线程安全，应该如何处理多线程下操作？何时会发生线程不安全情况？

HashMap不是线程安全的，如果多个线程同时对 HashMap 进行数据更改的话，会导致数据不一致或者数据污染甚至数据丢失。

当出现线程不安全的操作时，HashMap尽可能抛出`ConcurrentModificationException`异常。

- 当我们在对HashMap进行遍历时，如果在遍历期间我们对HashMap进行`put()、remove()`操作，会导致`modCount`发生变化(`exceptedModCount != modCount`)，然后抛出`ConcurrentModificationException`异常，这就是**`fail-fast快速失败`**机制。
- 由于存在扩容机制，多线程操作HashMap时，调用`resize()`进行扩容可能会导致死循环的发生。

如果想要线程安全，还是推荐使用`ConcurrentHashMap`。

### 使用HashMap时，使用什么对象作为key比较好？

**最好选择不可变对象作为key，因为为了计算`hashcode()`，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode，就会导致无法正确的找到对象。**

`String和Interger`等包装类就很适合作为key，而且`String`最常用。因为`String`是不可变的且`final`修饰(*保证key的不可更改性*)，并且已经重写了`equals()和hashcode()`方法(*不容易出现hash值的计算错误*)。

不可变性还有其他的优点例如`线程安全`。

### 如何使用自定义对象作为key？

HashMap的`key`可以是任何类型的对象，只要它遵守了`equals()和hashCode()`的定义规则，并且当对象插入到Map之后将不再会改变了。如果这个自定义对象是不可变的，那么它已经满足了作为键的条件。

> `hashcode()`和`equals()`都是用来对比两个对象是否相等一致。
>
> 由于重写的`equals()`内部逻辑一般比较全面和复杂，效率就会比较低。利用`hashCode()`进行对比，只要生成一个对应的`hash值`就可以了，然后比较两者的`hash值`是否相同，不同肯定不相等。比较效率较高。
>
> 但是如果`hash值`相同的话，可能会有两个情况：
>
> 1. 他们真的是相同对象
> 2. 由于hash的计算过程导致可能生成相同的`hash值`。
>
> 这个时候就需要用到`equals()`去进行比较。
>
> 在改写`equals()`时，需要满足以下3点：
>
> - 自反性：a.equals(a) 必须为 true
> - 对称性：`a.equals(b)`为true，则`b.equals(a)`必须成立
> - 传递性：`a.equals(b)`为true，并且`b.equals(c)`也为true，那么`a.equals(c)`也为true。
>
> **每当需要对比的时候，首先用`hashCode()`进行比较，如果`hashCode()`不一样肯定不相等，就不需要调用`equals()`继续比较。如果`hashCode()`相同，再调用`equals()`继续比较，大大提高了效率也保证了数据的准确。**



```java
class User{
        private int userId;
        private String name;

        public int getUserId() {
            return userId;
        }

        public void setUserId(int userId) {
            this.userId = userId;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            User user = (User) o;
            return userId == user.userId &&
                    Objects.equals(name, user.name);
        }

        //设定userid为hashcode
        @Override
        public int hashCode() {
            return userId;
        }

    }
```

### HashMap遍历

```java
    public static void getMap3(Map<String,String> map){
        Set<Map.Entry<String, String>> set = map.entrySet();
        for (Map.Entry<String, String> entry : set) {
            String value = entry.getValue();
            }
    }

    public static void getMap4(Map<String,String> map){
        Set<String> set = map.keySet();
        for (String entry : set) {
        String value = map.get(entry);
        }
    }
```



## 内容引用

[深入接触HashMap线程安全性问题](<https://juejin.im/post/5c8910286fb9a049ad77e9a3>)]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关及其拓展(二) -- 虚拟机类加载机制</title>
    <url>/2018/04/12/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%8C/</url>
    <content><![CDATA[# 虚拟机类加载机制
## 1.定义
`虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。`


## 2.类的生命周期
  类从被加载到虚拟机内存中开始，到卸载除内存为止，生命周期包括：**加载(Loading)**、**验证(Verification)**、**准备(Preparation)**、**解析(Resolution)**、**初始化(Initialization)**、**使用(Using)**、**卸载(Unloading)**。其中`验证`、`准备`、`解析`统称为**连接(Linking)**
{% fullimage /images/jvm/class_lifecycle.png, 类的生命周期,类的生命周期 %}
  加载、验证、准备、初始化和卸载阶段执行顺序为确定的，类的加载过程必须按照这个顺序开始。解析阶段不一定：在某些情况下可以在初始化阶段之后开始，为了支持Java语言的运行时绑定。
  初始化阶段，虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”：

- 遇到`new ,getstatic,putstatic或invokestatic`指令时，类没有进行初始化，则需要先触发初始化。最常见的Java代码场景：使用new关键字实例化对象、读取或设置一个类的静态字段、调用一个类的静态方法。
- 使用`java.lang.reflect`进行反射调用的时候。
- 初始化一个类时，发现父类还没有初始化，先触发父类初始化方法。
- 虚拟机启动时，用户指定一个要执行的主类(包含`main()`方法的类)，先初始化该类。
- 使用动态语言支持时，若`java.lang.invoke,MethodHandle`实例最后解析结果为`REF_getStatic,REF_putStatic,REF_invokeStatic`的方法句柄，并且该类没有进行初始化。  

使用阶段

执行类的初始化，主动引用会触发类的初始化，被动引用不会触发类的初始化过程。

## 3.类加载的过程
{% fullimage /images/类加载过程.png,类加载过程,类加载过程%}

### **加载**

虚拟机需要完成以下3件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流 (*使用ClassLoader加载*)
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口

并没有指定一个二进制字节流要从一个Class文件中获取

### **验证**

> （若代码被反复验证和使用过，可以使用`-Xverify:none`来关闭大部分的类验证措施，缩短虚拟机加载时间）

验证是连接阶段的第一步，这一阶段的目的是为了**确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全**。
验证阶段大致需要完成以下4个阶段的检验动作：

  1. **文件格式验证**
    验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
    `主要目的是保证输入的字节流能正确的解析并存储于方法区之内，格式上符合描述一个Java类信息的要求。在这个阶段字节流进入内存中的方法区后续不再操作字节流。`
  2. **元数据验证**
    对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范
  3. **字节码验证**
    通过数据流和控制流分析，确定程序语义是合法且符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机的安全的事件。
  4. **符号引用验证**
    发生在虚拟机将符号引用转化为直接引用的时候，这个转化发生在解析阶段。对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验。`确保解析动作能正常执行`

### **准备**

**准备阶段是正式为变量分配内存并设置类初始变量初始值的阶段**，这些变量所使用的内存都将在方法区中进行分配。这个时候进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量。
初始值`通常情况`下是数据类型的零值，如

```java
public static int value = 123;//在准备阶段过程中初始值为0，而不是123。
```
  `特殊情况`：若类字段的属性表中有ConstantValue属性，那么准备阶段value就会初始化为ConstantValue指定的值，如
```java
public static final int value = 123;//在准备阶段过程中初始值为123。
```

### **解析**

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**。解析阶段中会涉及到`直接引用`(直接指向目标的指针、相对偏移量或者是一个能直接定位到目标的句柄)，`符号引用`(以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可)。
解析动作主要针对`类或接口（CONSTANT_Class_info）`、`字段（CONSTANT_Fieldref_info）`、`类方法（CONSTANT_Methodref_info）`、`接口方法（CONSTANT_InterfaceMethodref_info）`、`方法类型（CONSTANT_MethodType_info）`、`方法句柄（CONSTANT_MethodHandle_info）`、`调用点限定符（CONSTANT_InvokeDynamic_info）`。

### **初始化**

初始化是类加载过程的最后一步。**到这里才真正开始执行类中定义的Java程序代码**。
执行类构造器`<clinit>()`方法的过程。

- `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。
- `<clinit>()`方法与类的构造函数不同，他不需要显示的调用父类构造器，因此虚拟中第一个被执行的`<clinit>()`方法的类肯定是`java.long.object`。
- **初始化过程就是对变量进行赋值及执行静态代码块。**



## 4.类的卸载

**由JVM自带的类加载器(`Bootstrap ClassLoader-根加载器、Extension ClassLoader-拓展加载器、Application ClassLoader-应用加载器`)所加载的类，在虚拟机的生命周期中，始终不会被卸载。**这一切是由于Java本身始终引用这些加载类，导致被加载的类对象也会一直可达。

**只有由用户自定义的类加载器所加载的类是可以被卸载的。**

类卸载的触发条件：

- 该类所有的实例都已经被GC，也就是在JVM中不存在该类的任何实例
- 加载该类的ClassLoader也被GC
- 该类的java.lang.Class对象没有在任何地方被引用，如反射都无法访问该类

类卸载过程：

在方法区内的二进制数据会被卸载。

**若卸载后还需要使用，那么就需要去重新加载，然后在Java的虚拟机堆区上重新生成实例。**]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>插件化实现原理简析(基础概念)</title>
    <url>/2019/02/05/%E6%8F%92%E4%BB%B6%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
## 动态加载技术

> 在应用程序运行时，动态的去加载一些程序中原本不存的可执行文件并运行这些文件里的代码逻辑。
>
> 可执行文件总的来说分为两种：
>
> - 一种是动态链接库so
> - 一种是dex相关文件(*dex以及包含dex的jar/apk文件*)

随着应用开发技术和业务的逐步发展，动态加载技术派生出两个技术：**热修复技术以及插件化技术。**

热修复技术主要用来*修复Bug*，插件化技术主要来解决*应用越来越庞大以及功能模块的解耦*。

## 插件化

### 插件化产生

在开发初期时，业务需求以及应用开发的复杂度都不是很高，在后续的开发过程中，容易出现以下情况：

1. 业务复杂，模块耦合

   随着开发过程，应用的体积以及复杂度都会越来越大，模块的耦合也会越来越严重。

2. 应用间的接入

   一个应用不再是单独的应用，他可能还需要接入其他的应用来完善功能。

3. 65535限制

   代码量的增大，方法数也会增加，就很容易超出限制。

### 插件化定义

让我们不用**像原来一样把所有的内容都放在一个apk中**，把一些功能和逻辑单独的放到插件Apk中，由宿主Apk按需调用。方便减少Apk的体积，也可以简单实现热插拔，更加动态化。

插件化的客户端由宿主和插件两个部分组成，宿主多指安装好的Apk，插件就为经过处理的Apk、so的dex等文件。插件可以被宿主加载也可以单独运行。

### 插件化基本原理

#### 类加载

Android中常用的有两种类加载器，`DexClassLoader`和`PathClassLoader`，它们都继承于`BaseDexClassLoader`。这两个加载器的区别是`DexClassLoader`多了一个`optimizedDirectory`参数，这个是用来缓存系统创建的Dex文件。在`PathClassLoader`中这个参数为null，所以只能去加载内部存储(*/data/data/XX*)中的Dex文件。

通过**双亲委托机制**可以保证类不会重复加载，通过*先查看该类是否已被加载，未加载时首先让父加载器先去尝试加载，无法加载再交由自身处理。*

<br>

#### 单DexClassLoader与多DexClassLoader

通过给插件apk生成相应的`DexClassLoader`便可以去访问其中的类。这边又分成两种形式：

- 单DexClassLoader

  {% fullimage /images/单ClassLoader结构.png,单ClassLoader结构,单ClassLoader结构%}

  将插件Apk中的DexClassLoader的DexPathList都合并进宿主Apk中。可以在不同的插件及主工程间直接调用相关类和方法，也可以直接抽出共用模块供其他插件使用。

- 多DexClassLoader

  {% fullimage /images/多ClassLoader结构.png,多ClassLoader结构,多ClassLoader结构%}

  每个插件都会去生成一个DexClassLoader，当加载该插件中的类需要通过各自的DexClassLoader去加载，这样不同插件的类就是相互隔离的。

宿主和插件相互调用时需要注意以下几点：

- 插件调用主工程：

  构造插件的ClassLoader时直接传入主工程的ClassLoader作为父加载器，所以插件可以直接去引用主工程的类。

- 主工程调用插件：

  - 单ClassLoader结构

    主工程可以通过类名直接去访问插件中的类。

    > 需要注意插件中引用了不同版本的相同库时，需要尽量避免。

  - 多ClassLoader结构

    主工程引用插件中类需要先通过插件的ClassLoader加载该类再通过反射调用其方法。

#### 资源加载

Android系统通过`Resource`加载资源，`Resource`又要依赖`AssetManager`去加载资源。

因此，只要将插件Apk的路径加入到`AssetManager`中，便能够实现对插件资源的访问。

资源的插件化方式主要有两种：

| 方式             | 优点                             | 缺点             |
| ---------------- | -------------------------------- | ---------------- |
| 合并资源方案     | 插件和主工程可以直接相互访问资源 | 导致资源冲突     |
| 独立构建资源方案 | 资源隔离，不会造成冲突           | 资源共享比较麻烦 |

### 插件化实现实例

#### Activity插件化

Activity插件化主要有3种实现方式，分别是`反射实现、接口实现以及Hook技术实现`。

> `反射实现`会对应用的性能造成影响。
>
>  `接口实现`可以阅读`dynamic-load-apk`源码，框架提供基础四大组件基类，由需要插件化的组件进行继承。
>
> `Hook技术实现`主流插件化的实现方案。

我们从{% post_link Activity启动过程%}了解到了Activity的启动过程。如果我们需要对Activity进行插件化，需要对这段过程有很好的了解。

通过`Hook方式`去实现Activity插件化，主要需要解决两个问题：

- 插件中的Activity并没有在`AndroidManifest.xml`进行注册，如何绕过`AMS`校验
- 如何去构造Activity的实例，并同步生命周期

##### Hook IActivityManager

###### 1.注册占坑Activity

> 采用**预先占坑**的方式，即在`AndroidManifest.xml`中先注册一个占坑Activity来代表即将加入进来的插件Activity。

```java
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools" package="com.example.wxy.ipc">
  
   <application android:allowBackup="true"
                 android:label="@string/app_name"
                 android:name="com.example.wxy.ipc.App"
                 android:icon="@mipmap/ic_launcher"
                 android:roundIcon="@mipmap/ic_launcher_round"
                 android:supportsRtl="true"
                 android:theme="@style/AppTheme" tools:ignore="GoogleAppIndexingWarning">

        <activity android:name=".LoadActivity"
                  android:launchMode="singleTop">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!--设置占位Activity-->
        <activity android:name=".StubActivity"/>
    </application>
</manifest>
```



###### 2.使用占坑Activity绕过AMS验证

分析Activity启动流程时，`Instrumentation.execStartActivity()`去启动Activity，内部实质是依靠远程调用`AMS.startActivity()`去执行启动流程。

在Android 8.0之前，依靠的是`ActivityManagerNative.getDefault()`执行远程调用

```java ./android/app/Instrumentation.java before Android8.0
public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
 ...
    int result = ActivityManagerNative.getDefault()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
}

// ../android/app/ActivityManagerNative.java
static public IActivityManager getDefault(){
  return gDefault.get();
}

private static final Sigleton<IActivityManager> gDefault = new Singleton<IActivityManager>(){
  protected IActivityManager create() {
    IBinder b = ServiceManager.getService("activity");
    IActivityManager am = asInterface(b);
    return am;
  }
}
```

第一次调用到`getDefault()`时，就会调用到`IActivityManagerSingleton.get()`，由源码可知，该类是一个单例类。

<br>

在Android8.0时，依靠的是`ActivityManager.getService()`执行远程调用

```java ./android/app/Instrumentation.java in Android8.0
public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
 ...
    int result = ActivityManager.getService()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
}

// ../android/app/ActivityManager.java
    public static IActivityManager getService() {
        return IActivityManagerSingleton.get();
    }

    private static final Singleton<IActivityManager> IActivityManagerSingleton =
            new Singleton<IActivityManager>() {
                @Override
                protected IActivityManager create() {
                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                    return am;
                }
            };
```

在其中先去获取名为`activity`的一个代理对象(`IBinder`)，后续实现利用了`AIDL`，根据`asInterface()`可以获得`IActivityManager`对象，他是`AMS`在本地的代理对象。然后就可以直接调用到`AMS`的`startActivity()`。

根据上述两段源码分析，最终都需要通过`IActivityManager`去远程调用到`AMS`，可以将其作为`Hook点`，由于又是接口类型，应该使用`动态代理方式`去生成代理对象。

```java
public class IActivityManagerProxy implements InvocationHandler {

    private Object mActivityManager;
    private static final String TAG = "IActivityManagerProxy";

    public IActivityManagerProxy(Object _object) {
        mActivityManager = _object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if ("startActivity".equals(method.getName())) {
            Intent intent = null;
            int index = 0;
            for (int i = 0; i < args.length; i++) {
                if (args[i] instanceof Intent) {
                    index = i;
                    break;
                }
            }
            intent = (Intent) args[index];
            Intent subIntent = new Intent();
            String packageName = "com.example.wxy.ipc";
            //这个地方配置的是设置好的占坑Activity
            subIntent.setClassName(packageName, packageName + ".hook.StubActivity");
            //存储原先启动目标Activity的Intent，方便后续进行还原
            subIntent.putExtra("target_intent", intent);
            Log.d(TAG,"hook 成功");
            //把对目标Activity的请求指向到占坑Activity
            args[index] = subIntent;
        }
        return method.invoke(mActivityManager, args);
    }
}
```

通过定义上述的代理对象后，跳转到其他Activity时都会被定位到`StubActivity`上，**无论是否在`AndroidManifest.xml`进行过注册**。

接下来要把设置好的代理对象Hook到原有的结构上。

```java
public class HookHelper {
    public static void hookAMS() throws Exception {
        Object defaultSingleton = null;
        if (Build.VERSION.SDK_INT >= 26) {
            Class<?> activityManagerClazz = Class.forName("android.app.ActivityManager");
            //获取ActivityManager中的IActivityManagerSingleton字段
            defaultSingleton = FieldUtil.getField(activityManagerClazz, null, "IActivityManagerSingleton");
        } else {
            @SuppressLint("PrivateApi") Class<?> activityManagerNativeClazz = Class.forName("android.app.ActivityManagerNative");
            //获取ActivityManager中的gDefault字段
            defaultSingleton = FieldUtil.getField(activityManagerNativeClazz, null, "gDefault");
        }
        Class<?> singletonClazz = Class.forName("android.util.Singleton");
        Field mInstanceField = FieldUtil.getField(singletonClazz, "mInstance");
        //获取mInstance字段 即单例类
        Object iActivityManager = mInstanceField.get(defaultSingleton);
        Class<?> iActivityManagerClazz = Class.forName("android.app.IActivityManager");
        //使用新建的IActivityManagerProxy替换掉原有的IActivityManager
        Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[]{iActivityManagerClazz},
                new IActivityManagerProxy((iActivityManager)));
        mInstanceField.set(defaultSingleton, proxy);
    }
}
```

在`Application`引用`HookHelper`类即可完成绕过验证操作

```java
public class MyApplication extends Application{
  @Override
  public void attachBaseContext(Context base){
    super.attachBaseContext(base);
    try{
      HookHelper.hookAMS();
    }catch(Exception e){
      e.printStackTrace();
    }
  }
}
```

在执行`startActivity()`跳转时，都会跳转到`StubActivity`界面。至此完成了*通过AMS验证步骤*。

###### 3.还原插件Activity

> 使用占坑Activity通过`AMS`校验后，因为当前的情况就是把跳转的都指向到了`StubActivity`中，需要做的是还原原本要跳转的Activity，使用原本Activity对`StubActivity`进行替换。
>
> **要实现替换功能，关键点在于找到真正开始绘制Activity的地方，然后实际绘制需要跳转的Activity。**

在{% post_link Activity启动过程%}这节中，了解到绘制Activity的流程是从`ActivityThread.handleLaunchActivity()`开始执行，并调用到`onCreate()`。那就可以在执行这个方法之前，替换掉即将启动的Activity，在上一节中启动的就是`StubActivity`，需要把这个再替换成原本的目标Activity。

控制Activity的一套流程都是通过`H`这个Handler类去执行的，在其中定义了很多code，来分发不同的流程。可以通过Hook这套流程拦截原本的启动Activity流程，替换成自定义的启动流程。

> 使用Handler时如果想拦截原有的`handleMessage()`，就需要为Handler设置一个`Callback`，这样在分发消息(`dispatchMessage()`)的时候，就会去执行到`Callback.handlerMessage(msg)`而不执行原有处理。在此基础上，可以对`ActivityThread.H`设置一个`Callback`拦截启动Activity的事件。

在此先自定义一个Callback

```java
public class HCallback implements Handler.Callback {
    Handler mHandler;

    public HCallback(Handler _handler) {
        mHandler = _handler;
    }

    @Override
    public boolean handleMessage(Message msg) {
        Object r = msg.obj;
        switch (msg.what) {
            case 100: //LAUNCH_ACTIVITY
                try {
                    //得到消息中的Intent -- 启动StubActivity的Intent
                    Intent intent = (Intent) FieldUtil.getField(r.getClass(), r, "intent");
                    //从中取出原本要启动Activity的Intent
                    Intent target = intent.getParcelableExtra("target_intent");
                    //将启动目标Activity的Intent替换掉启动StubActivity的Intent
                    intent.setComponent(target.getComponent());
                } catch (Exception e) {
                    e.printStackTrace();
                }
                break;
            case 159: //Android P 对应的启动条件
                //在Android P中取消了Activity的相关Code，把他们封装成ClientTransacion类型对象，然后存储在其中的 mActivityCallbacks
                //LaunchActivityItem  启动Activity
                //DestoryActivityListItem 关闭Activity
                try {
                    List<Object> mCallbacks = (List<Object>) FieldUtil.getField(r.getClass(), r, "mActivityCallbacks");
                    if (!mCallbacks.isEmpty()) {
                        //找到启动Activity的消息
                        String className = "android.app.servertransaction.LaunchActivityItem";
                        if (mCallbacks.get(0).getClass().getCanonicalName().equals(className)) {
                            Object object = mCallbacks.get(0);
                            Intent intent = (Intent) FieldUtil.getField(object.getClass(), object, "mIntent");
                            Intent target = intent.getParcelableExtra("target_intent");
                            //替换进去
                            intent.setComponent(target.getComponent());
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                break;
        }
        mHandler.handleMessage(msg);
        return true;
    }
}

```

实现了自定义Callback对象`HCallback`后，就需要把它设置到`ActivityThread.H`中使其拦截后续启动动作。

```java
public class HookHelper {
    public static void hookHandler() throws Exception {
        Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");
        //当前对应的ActivityThread对象
        Object currentActivityThread = FieldUtil.getField(activityThreadClass, null, "sCurrentActivityThread");
        //对应Handler对象
        Field mHField = FieldUtil.getField(activityThreadClass, "mH");
        Handler mH = (Handler) mHField.get(currentActivityThread);
        //替换掉mh中的mCallback对象
        FieldUtil.setField(Handler.class, mH, "mCallback", new HCallback(mH));
    }
}
```

上述执行完毕后，启动的就会是目标Activity。

###### 4.插件Activity的生命周期

上述三步执行完毕后，就可以打开插件Activity，但是这种操作下会不会影响到原有的生命周期，实际上还是依赖了`StubActivity`。

Activity生命周期的回调代码都是交由`Instrumentation.callActivityOnXX(ActivityClientRecord.activity)`执行对应的回调代码。其中`ActivityClientRecoed`用于描述应用进程中的Activity。我们只要分析`ActivityClientRecord.activity`对应的是否为目标Activity，是的话那么生命周期就没有问题。

```java ./android/app/ActivityThread.java
 private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
   ...
      Activity activity = null;
        try {
            java.lang.ClassLoader cl = appContext.getClassLoader();
            //加载Activity，其实这时加载的已经是目标Activity了
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            ...
        } catch (Exception e) {
            ...
        }
        ...
        try {
            //创建Application对象
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);
            
            if (activity != null) {
              ...
                //Activity的初始化操作
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window, r.configCallback);
              ...
              //调用 onCreate() 回调方法
              if (r.isPersistable()) {
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
                //设置ActivityClientRecord中的Activity为目标Activity
                r.activity = activity;
              ...
              mActivities.put(r.token,r);
            }
        }catch(Exception e){
           ...
        }
 }
```

从以上源码分析可知，`performLaunchActivity()`时会设置当前Activity为目标Activity，生命周期也会跟着当前Activity去执行，即生命周期是同步的。

##### Hook Instrumentation

> 该实现相对上面会简单很多，主要就是去操作`Instrumentation`，Hook掉其中的两个方法：
>
> - `newActivity()`：新建Activity **用目标Activity替换掉StubActivity**
> - `execStartActivity()`：启动Activity  **拦截跳转到StubActivity上**

###### 1.注册占坑Activity

方法同上

###### 2.设置Instrumentation代理对象

```java
public class InstrumentationProxy extends Instrumentation {
    private static final String TAG = "InstrumentationProxy";
    private Instrumentation mInstrumentation;
    private PackageManager mPackageManager;

    public InstrumentationProxy(Instrumentation _instrumentation, PackageManager _packageManager) {
        mInstrumentation = _instrumentation;
        mPackageManager = _packageManager;
    }
  
   public Activity newActivity(ClassLoader cl, String className,
                                Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
        String intentName = intent.getStringExtra("target_intent");
        if (!TextUtils.isEmpty(intentName)) {
            return super.newActivity(cl, intentName, intent);
        }
        return super.newActivity(cl, className, intent);
    }

    public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,
                                            Intent intent, int requestCode, Bundle options) {
        List<ResolveInfo> infos = mPackageManager.queryIntentActivities(intent, PackageManager.MATCH_ALL);
        //判断需要启动的Activity是否已被注册
        if (infos.isEmpty()) {
            intent.putExtra("target_intent", intent.getComponent().getClassName());
            //未注册则指向StubActivity
            intent.setClassName(who, "com.example.wxy.ipc.hook.StubActivity");
        }
        try {
            //反射调用 execStartActivity
            @SuppressLint("PrivateApi") Method execStartActivity = Instrumentation.class.getDeclaredMethod(
                    "execStartActivity",
                    Context.class, IBinder.class, IBinder.class, Activity.class,
                    Intent.class, int.class, Bundle.class);
            execStartActivity.setAccessible(true);
            return (ActivityResult) execStartActivity.invoke(mInstrumentation, who,
                    contextThread, token, target, intent, requestCode, options);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

设置好代理对象后，需要把代理对象Hook到`ActivityThread`上，方便后续调用

```java
public class HookHelper {
     public static void hookInstrumentation(Context context) throws Exception {
        Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");
        //获取ActivityThread中的 sCurrentActivityThread 代指当前进程的ActivityThread
        Object activityThread = FieldUtil.getField(activityThreadClass,null,"sCurrentActivityThread");
        Field mInsrumentationField = FieldUtil.getField(activityThreadClass, "mInstrumentation");
        //获取到 mInstrumentation
        Object mInstrumentation = mInsrumentationField.get(activityThread);
        //使用InstrumentationProxy替换掉原先的mInstrumentation
        FieldUtil.setField(activityThreadClass, activityThread, "mInstrumentation",
                new InstrumentationProxy((Instrumentation) mInstrumentation, context.getPackageManager()));
    } 
}
```

在`Application`中的`attachBaseContext()`调用`HookHelper.hookInstrumentation()`即可完成插件Activity的加载。





]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide源码解析要点</title>
    <url>/2018/03/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<!-- TODO Glide如何加载大图 BitmapPool的使用-->

> 该源码解析是基于最新的Glide 4.8.0进行的

## Glide基本流程分析

Glide的基本使用代码

```java
Glide.with(context).load($img$).apply(RequestOptions().transform(MultiTransformation(CenterCrop(),CircleCrop())).placeholder(R.drawable.ic_default_avatar)).into(imageView);
```

按照上述的基本使用代码，Glide的加载过程可以分为以下几步：

### `Glide对象初始化`

初始化代码是从`Glide.get()`开始的，在其中主要做了一些事情

```java Glide.java
 @NonNull
  public static Glide get(@NonNull Context context) {
    //Glide对象时一个单例模式
    if (glide == null) {
      synchronized (Glide.class) {
        if (glide == null) {
          checkAndInitializeGlide(context);
        }
      }
    }

    return glide;
  }

//检查Glide对象是否初始化完毕
private static void checkAndInitializeGlide(@NonNull Context context) {
    // In the thread running initGlide(), one or more classes may call Glide.get(context).
    // Without this check, those calls could trigger infinite recursion.
    if (isInitializing) {
      throw new IllegalStateException("You cannot call Glide.get() in registerComponents(),"
          + " use the provided Glide instance instead");
    }
    isInitializing = true;
    //真正初始化Glide的代码
    initializeGlide(context);
    isInitializing = false;
  }
```

初始化Glide时再调用到`initializeGlide()`去进行真正的初始化工作

```java Glide.java
  private static void initializeGlide(@NonNull Context context) {
    initializeGlide(context, new GlideBuilder());
  }

  private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {
    Context applicationContext = context.getApplicationContext();
    GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();
    List<com.bumptech.glide.module.GlideModule> manifestModules = Collections.emptyList();
    //是否使用Manifest配置的GlideModule
    if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {
      manifestModules = new ManifestParser(applicationContext).parse();
    }

    if (annotationGeneratedModule != null
        && !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {
      Set<Class<?>> excludedModuleClasses =
          annotationGeneratedModule.getExcludedModuleClasses();
      Iterator<com.bumptech.glide.module.GlideModule> iterator = manifestModules.iterator();
      while (iterator.hasNext()) {
        com.bumptech.glide.module.GlideModule current = iterator.next();
        if (!excludedModuleClasses.contains(current.getClass())) {
          continue;
        }
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "AppGlideModule excludes manifest GlideModule: " + current);
        }
        iterator.remove();
      }
    }

    if (Log.isLoggable(TAG, Log.DEBUG)) {
      for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) {
        Log.d(TAG, "Discovered GlideModule from manifest: " + glideModule.getClass());
      }
    }

    RequestManagerRetriever.RequestManagerFactory factory =
        annotationGeneratedModule != null
            ? annotationGeneratedModule.getRequestManagerFactory() : null;
    builder.setRequestManagerFactory(factory);
    for (com.bumptech.glide.module.GlideModule module : manifestModules) {
      //循环调用Module中的 applyOptions方法
      //applyOptions的作用是 配置Glide加载时的图片缓存路径以及缓存空间大小
      module.applyOptions(applicationContext, builder);
    }
    if (annotationGeneratedModule != null) {
      //调用注解配置Module中的 applyOptions方法
      //applyOptions的作用是 配置Glide加载时的图片缓存路径以及缓存空间大小
      annotationGeneratedModule.applyOptions(applicationContext, builder);
    }
    //创建Glide对象
    Glide glide = builder.build(applicationContext);
    //循环调用Module中的 registerComponents()
    //registerComponents的作用是 注册指定类型的数据源，以及加载图片使用ModelLoader
    for (com.bumptech.glide.module.GlideModule module : manifestModules) {
      module.registerComponents(applicationContext, glide, glide.registry);
    }
    //调用注解配置Module中的 registerComponents()
    //registerComponents的作用是 注册指定类型的数据源，以及加载图片使用ModelLoader
    if (annotationGeneratedModule != null) {
      annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);
    }
    applicationContext.registerComponentCallbacks(glide);
    Glide.glide = glide;
  }
```

源码中发现`GlideModule`分为两种`manifestModules`和`annotationGeneratedModule`，其中`manifestModules`是为了兼容V3版本，以前的都是配置在`AndroidManifest.xml`中，而V4版本采用注解的方式，取消了清单文件中的配置。

```java 示例配置文件
@GlideModule
public class CustomGlideModule extends AppGlideModule {
    @Override
    public void applyOptions(Context context, GlideBuilder builder) {

        MemorySizeCalculator calculator = new MemorySizeCalculator.Builder(context).build();
        int defaultMemoryCacheSize = calculator.getMemoryCacheSize();
        int defaultBitmapPoolSize = calculator.getBitmapPoolSize();

        int customMemoryCacheSize = (int) (1.2 * defaultMemoryCacheSize);
        int customBitmapPoolSize = (int) (1.2 * defaultBitmapPoolSize);

        builder.setMemoryCache(new LruResourceCache(customMemoryCacheSize));
        builder.setBitmapPool(new LruBitmapPool(customBitmapPoolSize));
    }

    @Override
    public void registerComponents(Context context, Glide glide, Registry registry) {
        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(ProgressManager.getOkHttpClient()));
    }

    @Override
    public boolean isManifestParsingEnabled() {
        return false;
    }
}

```

配置好`GlideModule`文件后，就需要去调用其中的`applyOptions()`设置Glide加载基本配置项，然后调用到了`GlideBuilder.build()`去构造Glide对象，最后调用其中的`regeisterComponents()`设置加载器。

接下来分析构造Glide对象的方法——`GlideBuilder.build()`

```java
  @NonNull
  Glide build(@NonNull Context context) {
    //设置加载图片的线程池
    if (sourceExecutor == null) {
      sourceExecutor = GlideExecutor.newSourceExecutor();
    }
    //写入本地磁盘缓存的线程池
    if (diskCacheExecutor == null) {
      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();
    }
    //执行动画的线程池
    if (animationExecutor == null) {
      animationExecutor = GlideExecutor.newAnimationExecutor();
    }
    //计算内存缓存大小
    if (memorySizeCalculator == null) {
      memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();
    }

    if (connectivityMonitorFactory == null) {
      connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();
    }
    //bitmap缓存池
    if (bitmapPool == null) {
      int size = memorySizeCalculator.getBitmapPoolSize();
      if (size > 0) {
        bitmapPool = new LruBitmapPool(size);
      } else {
        bitmapPool = new BitmapPoolAdapter();
      }
    }

    if (arrayPool == null) {
      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());
    }
    //内存缓存
    if (memoryCache == null) {
      memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());
    }
    //硬盘缓存
    if (diskCacheFactory == null) {
      diskCacheFactory = new InternalCacheDiskCacheFactory(context);
    }
    
    if (engine == null) {
      engine =
          new Engine(
              memoryCache,
              diskCacheFactory,
              diskCacheExecutor,
              sourceExecutor,
              GlideExecutor.newUnlimitedSourceExecutor(),
              GlideExecutor.newAnimationExecutor(),
              isActiveResourceRetentionAllowed);
    }

    if (defaultRequestListeners == null) {
      defaultRequestListeners = Collections.emptyList();
    } else {
      defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);
    }

    RequestManagerRetriever requestManagerRetriever =
        new RequestManagerRetriever(requestManagerFactory);

    return new Glide(
        context,
        engine,
        memoryCache,
        bitmapPool,
        arrayPool,
        requestManagerRetriever,
        connectivityMonitorFactory,
        logLevel,
        defaultRequestOptions.lock(),
        defaultTransitionOptions,
        defaultRequestListeners,
        isLoggingRequestOriginsEnabled);
  }
```

当`GlideBuilder.build()`执行完毕后，最终调用到`new Glide()`完成初始化。其中关键参数为`Registry`后续的操作都需要用到该参数。

### `with()`

> 对Glide的生命周期进行管理。

Glide对象初始化完毕后，首先会调用到的就是`with()`

```java Glide.java
@NonNull
  public static RequestManager with(@NonNull Context context) {
    return getRetriever(context).get(context);
  }

  @NonNull
  public static RequestManager with(@NonNull Activity activity) {
    return getRetriever(activity).get(activity);
  }

  @NonNull
  public static RequestManager with(@NonNull FragmentActivity activity) {
    return getRetriever(activity).get(activity);
  }

  @NonNull
  public static RequestManager with(@NonNull Fragment fragment) {
    return getRetriever(fragment.getActivity()).get(fragment);
  }

  @NonNull
  public static RequestManager with(@NonNull View view) {
    return getRetriever(view.getContext()).get(view);
  }
```

`with()`有5种重载方法，最后调用到的都是`getRetriever(context).get()`

```java RequestManagerRetriever.java
  @NonNull
  public RequestManager get(@NonNull Context context) {
    if (context == null) {
      throw new IllegalArgumentException("You cannot start a load on a null Context");
    } else if (Util.isOnMainThread() && !(context instanceof Application)) {
      if (context instanceof FragmentActivity) {
        return get((FragmentActivity) context);
      } else if (context instanceof Activity) {
        return get((Activity) context);
      } else if (context instanceof ContextWrapper) {
        return get(((ContextWrapper) context).getBaseContext());
      }
    }

    return getApplicationManager(context);
  }

  @NonNull
  public RequestManager get(@NonNull FragmentActivity activity) {
    if (Util.isOnBackgroundThread()) {
      return get(activity.getApplicationContext());
    } else {
      assertNotDestroyed(activity);
      FragmentManager fm = activity.getSupportFragmentManager();
      return supportFragmentGet(
          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
    }
  }

  @NonNull
  public RequestManager get(@NonNull Fragment fragment) {
    Preconditions.checkNotNull(fragment.getActivity(),
          "You cannot start a load on a fragment before it is attached or after it is destroyed");
    if (Util.isOnBackgroundThread()) {
      return get(fragment.getActivity().getApplicationContext());
    } else {
      FragmentManager fm = fragment.getChildFragmentManager();
      return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
    }
  }

  @SuppressWarnings("deprecation")
  @NonNull
  public RequestManager get(@NonNull Activity activity) {
    if (Util.isOnBackgroundThread()) {
      return get(activity.getApplicationContext());
    } else {
      assertNotDestroyed(activity);
      android.app.FragmentManager fm = activity.getFragmentManager();
      return fragmentGet(
          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
    }
  }

  public RequestManager get(@NonNull View view) {
    if (Util.isOnBackgroundThread()) {
      return get(view.getContext().getApplicationContext());
    }

    Preconditions.checkNotNull(view);
    Preconditions.checkNotNull(view.getContext(),
        "Unable to obtain a request manager for a view without a Context");
    Activity activity = findActivity(view.getContext());
    // The view might be somewhere else, like a service.
    if (activity == null) {
      return get(view.getContext().getApplicationContext());
    }

    // Support Fragments.
    if (activity instanceof FragmentActivity) {
      Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
      return fragment != null ? get(fragment) : get(activity);
    }

    // Standard Fragments.
    android.app.Fragment fragment = findFragment(view, activity);
    if (fragment == null) {
      return get(activity);
    }
    return get(fragment);
  }

```

简单分析上述源码可知，调用流程如下：

- 首先判断当前调用是否在子线程，在子线程的话，直接调用`ApplicationContext`获取`ReqeustManager`
- 不在子线程即运行在主线程时，需要判断`context`类型
  - `support.Fragment或者support.FragmentActivity`：调用`supportFragmentGet()`
  - `app.Activity或者app.fragment`：调用`fragmentGet()`
  - `Application`：调用`getApplicationManager()`
  - `view.getContext`：需要判断view的context类型，然后再走一次上面的步骤

根据流程分析，监听生命周期的方式主要是通过`监听一个无UI的Fragment(位于主线程且有对应的context存在)`和`监听Application(当位于后台线程或者contxt为Application)`。

其中`无UI的Fragment`对应源码中的两个类`RequestManagerFragment`、`SupportRequestFragment`在其中构造了`ActivityFragmentLifecycle`对象，在其中的关键生命周期进行联动，就可以对应的去进行加载和取消加载操作了。

```java RequestManagerFragment.java
 @Override
  public void onStart() {
    super.onStart();
    lifecycle.onStart();
  }

  @Override
  public void onStop() {
    super.onStop();
    lifecycle.onStop();
  }

  @Override
  public void onDestroy() {
    super.onDestroy();
    lifecycle.onDestroy();
    unregisterFragmentWithRoot();
  }
```

然后最后返回的`RequestManager`对象自身也会实现`LifecycleListener`接口，就可以根据对应调用跳转加载过程

```java RequestManager.java
//实现了LifecycleListener接口
public class RequestManager implements LifecycleListener{
 
  //主线程中执行
private final Runnable addSelfToLifecycle = new Runnable() {
    @Override
    public void run() {
      lifecycle.addListener(RequestManager.this);
    }
  };
...
  @Override
  public void onStart() {
    resumeRequests();
    targetTracker.onStart();//targetTracker监听
  }
  
  @Override
  public void onStop() {
    pauseRequests();
    targetTracker.onStop();//targetTracker监听
  }
  
  public void resumeRequests() {
    Util.assertMainThread();
    requestTracker.resumeRequests();//requestTracker监听
  }
  
  public void pauseRequests() {
    Util.assertMainThread();
    requestTracker.pauseRequests();//requestTracker监听
  }
  
  @Override
  public void onDestroy() {
    targetTracker.onDestroy();//targetTracker监听
    for (Target<?> target : targetTracker.getAll()) {
      clear(target);
    }
    targetTracker.clear();//targetTracker监听
    requestTracker.clearRequests();//requestTracker监听
    lifecycle.removeListener(this);
    lifecycle.removeListener(connectivityMonitor);
    mainHandler.removeCallbacks(addSelfToLifecycle);
    glide.unregisterRequestManager(this);
  }
}
```

完成上述流程后，RequestManager就可以实现对Fragment的监听，也就等同于实现了Glide的生命周期。

{% fullimage /images/Glide的with.png,Glide的with过程,Glide的with过程%}

### `load()`

> 传入需要加载的图片信息，通过`with()`得到的`RequestManager`进行加载。

```java RequestManager.java
 @NonNull
  @CheckResult
  @Override
  public RequestBuilder<Drawable> load(@Nullable Bitmap bitmap) {
    return asDrawable().load(bitmap);
  }

  @NonNull
  @CheckResult
  @Override
  public RequestBuilder<Drawable> load(@Nullable Drawable drawable) {
    return asDrawable().load(drawable);
  }

  @NonNull
  @CheckResult
  @Override
  public RequestBuilder<Drawable> load(@Nullable String string) {
    return asDrawable().load(string);
  }

  @NonNull
  @CheckResult
  @Override
  public RequestBuilder<Drawable> load(@Nullable Uri uri) {
    return asDrawable().load(uri);
  }

  @NonNull
  @CheckResult
  @Override
  public RequestBuilder<Drawable> load(@Nullable File file) {
    return asDrawable().load(file);
  }

  @SuppressWarnings("deprecation")
  @NonNull
  @CheckResult
  @Override
  public RequestBuilder<Drawable> load(@RawRes @DrawableRes @Nullable Integer resourceId) {
    return asDrawable().load(resourceId);
  }

  @SuppressWarnings("deprecation")
  @CheckResult
  @Override
  @Deprecated
  public RequestBuilder<Drawable> load(@Nullable URL url) {
    return asDrawable().load(url);
  }

  @NonNull
  @CheckResult
  @Override
  public RequestBuilder<Drawable> load(@Nullable byte[] model) {
    return asDrawable().load(model);
  }

  @NonNull
  @CheckResult
  @Override
  public RequestBuilder<Drawable> load(@Nullable Object model) {
    return asDrawable().load(model);
  }
```

经过`load()`分析，Glide加载的类型支持`Bitmap`、`Drawable`、`String(图片地址)`、`Uri`、`File(图片文件)`、`Integer(图片ResourceId)`、`URL`、`byte`，`Object`。

实际内部调用到的是`asDrawable.load()`

```java
  public RequestBuilder<Drawable> asDrawable() {
    return as(Drawable.class);
  }

  @NonNull
  @CheckResult
  public RequestBuilder<Bitmap> asBitmap() {
    return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);
  }

  @NonNull
  @CheckResult
  public RequestBuilder<GifDrawable> asGif() {
    return as(GifDrawable.class).apply(DECODE_TYPE_GIF);
  }

  @NonNull
  @CheckResult
  public <ResourceType> RequestBuilder<ResourceType> as(
      @NonNull Class<ResourceType> resourceClass) {
    return new RequestBuilder<>(glide, this, resourceClass, context);
  }
```

通过`asDrawable()`得到`RequestBuilder`对象，接下来走到`ReqeustBuilder.load()`

```java RequestBuilder.java
public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {
    return loadGeneric(bitmap)
        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
  }
  
  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {
    return loadGeneric(drawable)
        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));
  }
  
  public RequestBuilder<TranscodeType> load(@Nullable String string) {
    return loadGeneric(string);
  }
  
  public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {
    return loadGeneric(uri);
  }
  
  public RequestBuilder<TranscodeType> load(@Nullable File file) {
    return loadGeneric(file);
  }
  
  private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
    this.model = model;
    isModelSet = true;
    return this;
  }
  
  public RequestBuilder<TranscodeType> load(@Nullable Object model) {
    return loadGeneric(model);
  }
```

上述的`load()`都调用到了`loadGeneric()`然后进行了赋值操作，确定了`model`数据，然后完成了load流程。

//TODO 流程图

### `apply()`

> 设置一些额外配置，例如占位图、加载错误图片、图片显示类型，圆角什么的

`load()`流程结束后就得到了`RequestBuilder`对象，调用其中的`apply()`

```java
  public class RequestBuilder<TranscodeType> extends BaseRequestOptions<RequestBuilder<TranscodeType>> implements Cloneable, ModelTypes<RequestBuilder<TranscodeType>> {
      ...
  @NonNull
  @CheckResult
  @Override
  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {
    Preconditions.checkNotNull(requestOptions);
    return super.apply(requestOptions);
  }
      
      ...
}
```

调用到了`super.apply()`其实就是`BaseRequestOptions.apply()`

```java BaseRequestOptions.java
 @NonNull
  @CheckResult
  public T apply(@NonNull BaseRequestOptions<?> o) {
    if (isAutoCloneEnabled) {
      return clone().apply(o);
    }
    BaseRequestOptions<?> other = o;

    if (isSet(other.fields, SIZE_MULTIPLIER)) {
      sizeMultiplier = other.sizeMultiplier;
    }
    ...
    fields |= other.fields;
    options.putAll(other.options);

    return selfOrThrowIfLocked();
  }
```

`isSet()`是判断该属性是否设置，若已设置过则替换，设置完毕后，得到一个`RequestBuilder`对象，不过已经设置了`RequestOptions`里面包含了一些显示上以及缓存上的配置。

### `into()`——最关键步骤

> 进行图片的加载与显示

#### 创建请求`Request`

起点是从`RequestBuilder.into()`开始

```java RequestBuilder.java
  @NonNull
  public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
    Util.assertMainThread();
    Preconditions.checkNotNull(view);
    //获取apply()设置的 RequestOptions
    BaseRequestOptions<?> requestOptions = this;
    //是否设置了RequestOptions的ScaleType，未设置则使用ImageView的android:scaleType
    if (!requestOptions.isTransformationSet()
        && requestOptions.isTransformationAllowed()
        && view.getScaleType() != null) {
      switch (view.getScaleType()) {
        case CENTER_CROP:
          requestOptions = requestOptions.clone().optionalCenterCrop();
          break;
        case CENTER_INSIDE:
          requestOptions = requestOptions.clone().optionalCenterInside();
          break;
        case FIT_CENTER:
        case FIT_START:
        case FIT_END:
          requestOptions = requestOptions.clone().optionalFitCenter();
          break;
        case FIT_XY:
          requestOptions = requestOptions.clone().optionalCenterInside();
          break;
        case CENTER:
        case MATRIX:
        default:
          // Do nothing.
      }
    }

    return into(
        glideContext.buildImageViewTarget(view, transcodeClass),
        /*targetListener=*/ null,
        requestOptions,
        Executors.mainThreadExecutor());
  }

  private <Y extends Target<TranscodeType>> Y into(
      @NonNull Y target,
      @Nullable RequestListener<TranscodeType> targetListener,
      BaseRequestOptions<?> options,
      Executor callbackExecutor) {
    Preconditions.checkNotNull(target);
    if (!isModelSet) {
      throw new IllegalArgumentException("You must call #load() before calling #into()");
    }
    //构建Request请求对象
    Request request = buildRequest(target, targetListener, options, callbackExecutor);
    
    Request previous = target.getRequest();
    if (request.isEquivalentTo(previous)
        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
      request.recycle();
      if (!Preconditions.checkNotNull(previous).isRunning()) {
        previous.begin();
      }
      return target;
    }

    requestManager.clear(target);
    //给当前View设置请求
    target.setRequest(request);
    requestManager.track(target, request);

    return target;
  }
```

通过`buildRequest()`构建图片加载请求对象。

```java RequestBuilder.java
 private Request buildRequest(
      Target<TranscodeType> target,
      @Nullable RequestListener<TranscodeType> targetListener,
      BaseRequestOptions<?> requestOptions,
      Executor callbackExecutor) {
    return buildRequestRecursive(
        target,
        targetListener,
        /*parentCoordinator=*/ null,
        transitionOptions,
        requestOptions.getPriority(),
        requestOptions.getOverrideWidth(),
        requestOptions.getOverrideHeight(),
        requestOptions,
        callbackExecutor);
  }

  private Request buildRequestRecursive(...) {
    
    ErrorRequestCoordinator errorRequestCoordinator = null;
    //判断当前是否设置了 RequestBuilder.error()
    if (errorBuilder != null) {
      errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);
      parentCoordinator = errorRequestCoordinator;
    }
    //生成可能带有缩略图显示的Request
    Request mainRequest =
        buildThumbnailRequestRecursive(...);
    
    if (errorRequestCoordinator == null) {
      return mainRequest;
    }
    //生成带有错误处理的Request
    Request errorRequest =
        errorBuilder.buildRequestRecursive(...);
    errorRequestCoordinator.setRequests(mainRequest, errorRequest);
    return errorRequestCoordinator;
    ...
      
  }

private Request buildThumbnailRequestRecursive(...) {
    //是否设置了 RequestBuilder.thumbnailBuilder(RequestBuilder thumbnailBuilder)
    if (thumbnailBuilder != null) {
      if (isThumbnailBuilt) {
        throw new IllegalStateException("You cannot use a request as both the main request and a "
            + "thumbnail, consider using clone() on the request(s) passed to thumbnail()");
      }

      TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =
          thumbnailBuilder.transitionOptions;

      // Apply our transition by default to thumbnail requests but avoid overriding custom options
      // that may have been applied on the thumbnail request explicitly.
      if (thumbnailBuilder.isDefaultTransitionOptionsSet) {
        thumbTransitionOptions = transitionOptions;
      }

      Priority thumbPriority = thumbnailBuilder.isPrioritySet()
          ? thumbnailBuilder.getPriority() : getThumbnailPriority(priority);

      int thumbOverrideWidth = thumbnailBuilder.getOverrideWidth();
      int thumbOverrideHeight = thumbnailBuilder.getOverrideHeight();
      if (Util.isValidDimensions(overrideWidth, overrideHeight)
          && !thumbnailBuilder.isValidOverride()) {
        thumbOverrideWidth = requestOptions.getOverrideWidth();
        thumbOverrideHeight = requestOptions.getOverrideHeight();
      }

      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
      Request fullRequest =
          obtainRequest(...);
      isThumbnailBuilt = true;
      // Recursively generate thumbnail requests.
      Request thumbRequest =
          thumbnailBuilder.buildRequestRecursive(...);
      isThumbnailBuilt = false;
      coordinator.setRequests(fullRequest, thumbRequest);
      return coordinator;
    }
  //是否设置了 RequestBuilder.thumbnailBuilder(floar thumbSizeMultiplier)  对应的缩放比例
  else if (thumbSizeMultiplier != null) {
      // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
      Request fullRequest = obtainRequest(...);
      BaseRequestOptions<?> thumbnailOptions =
          requestOptions.clone().sizeMultiplier(thumbSizeMultiplier);

      Request thumbnailRequest =
          obtainRequest(...);

      coordinator.setRequests(fullRequest, thumbnailRequest);
      return coordinator;
    } else {
      // 没有设置 thunbmail相关参数
      return obtainRequest(...);
    }
  }

 private Request obtainRequest(
      Target<TranscodeType> target,
      RequestListener<TranscodeType> targetListener,
      BaseRequestOptions<?> requestOptions,
      RequestCoordinator requestCoordinator,
      TransitionOptions<?, ? super TranscodeType> transitionOptions,
      Priority priority,
      int overrideWidth,
      int overrideHeight,
      Executor callbackExecutor) {
    return SingleRequest.obtain(...);
  }
```

{% fullimage /images/Glide创建请求.png,Glide创建请求,Glide创建请求%}

总结一下创建请求的流程，最后调用的是`SingleRequest`对象。

- 通过`RequestBuilder.buildRequest()`创建`Request`对象，调用到`buildRequestRecursive()`执行创建逻辑

- 先判断设置过`RequestBuilder.error()`参数，如果设置过`errorRequest`，需要通过`errorRequest`和`mainRequest`得到`ErrorRequestCoordinator(实现Request接口)`对象。

- 没设置过`RequestBuilder.error()`参数，则向下判断是否设置过`ReqeustBuilder.thumbnail()`参数，设置`ReqeustBuilder.thumbnail()`有两种方法：

  - `ReqeustBuilder.thumbnail(RequestBuilder thumbnailBuilder)`：自定义要显示的缩略图
  - `ReqeustBuilder.thumbnail(float thumbSizeMultiper)`：设置原图缩放比例

  只要设置了其中的一种，就会产生`thumbRequest`对象，然后与`fullRequest`得到`ThumbnailRequestCoordinator(实现Request接口)`对象。

- `ReqeustBuilder.thumbnail()`也未设置，则最终调用`SingleRequest.obtain()`得到`SingleRequest(实现Request接口)`对象。

>  `errorRequest`表示了加载错误的请求
>
>  `thumbRequest`表示了缩略图加载请求
>
>  `mainRequest`和`fullRequest`都代表了原始图片加载请求。

上述创建请求流程执行完毕后，就是发送请求。

#### 发送请求

> 发送请求通过调用`Request`实现。

在[创建请求](#创建请求)中，创建完成后会调用到`requestManager.track(target, request);`去发送请求

```java RequestManager.java
  synchronized void track(@NonNull Target<?> target, @NonNull Request request) {
    //监听target的生命周期
    targetTracker.track(target);
    //开启请求
    requestTracker.runRequest(request);
  }
```

```java  RequestTracker.java
  public void runRequest(@NonNull Request request) {
    requests.add(request);
    if (!isPaused) {
      //开始启动
      request.begin();
    } else {
      request.clear();
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "Paused, delaying request");
      }
      pendingRequests.add(request);
    }
  }
```

接下来就是调用到`Request.begin()`，`Request`是一个接口，`singleRequest`是具体的实现类，即调用到`SingleRequest.begin()`

```java SingleRequest.java
  @Override
  public synchronized void begin() {
    assertNotCallingCallbacks();
    stateVerifier.throwIfRecycled();
    startTime = LogTime.getLogTime();
    if (model == null) {
      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
        width = overrideWidth;
        height = overrideHeight;
      }
      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
      //返回加载失败
      onLoadFailed(new GlideException("Received null model"), logLevel);
      return;
    }
    
    if (status == Status.RUNNING) {
      throw new IllegalArgumentException("Cannot restart a running request");
    }
    //加载完成
    if (status == Status.COMPLETE) {
      onResourceReady(resource, DataSource.MEMORY_CACHE);
      return;
    }
    
    status = Status.WAITING_FOR_SIZE;
    //判断设置大小是否合理
    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
      onSizeReady(overrideWidth, overrideHeight);
    } else {
      //不合理 获取ImageView的size
      target.getSize(this);
    }

    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
        && canNotifyStatusChanged()) {
      //回调Target onLoadStarted()
      target.onLoadStarted(getPlaceholderDrawable());
    }
    if (IS_VERBOSE_LOGGABLE) {
      logV("finished run method in " + LogTime.getElapsedMillis(startTime));
    }
  }

@Override
  public synchronized void onSizeReady(int width, int height) {
    stateVerifier.throwIfRecycled();
    if (IS_VERBOSE_LOGGABLE) {
      logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
    }
    if (status != Status.WAITING_FOR_SIZE) {
      return;
    }
    //更新请求状态为 请求中
    status = Status.RUNNING;

    float sizeMultiplier = requestOptions.getSizeMultiplier();
    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);

    if (IS_VERBOSE_LOGGABLE) {
      logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
    }
    //开始加载图片
    loadStatus = engine.load(...);
    if (status != Status.RUNNING) {
      loadStatus = null;
    }
    if (IS_VERBOSE_LOGGABLE) {
      logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
    }
  }

```

上述流程主要是去计算得到 被加载图片的尺寸信息，如果手动设置了尺寸通过`override`那么通过合法性校验后，加载的图片大小就会为用户设置尺寸，否则使用`Target`的尺寸信息。

> `Target`是一个接口，主要意义是提供View的确切尺寸信息以及对回调结果进行处理。

{% fullimage /images/Glide发送请求.png,Glide发送请求,Glide发送请求%}

#### 加载图片

接下来调用`Engine.load()`开始加载图片，包括三级缓存的部分。

```java Engine.java
public synchronized <R> LoadStatus load(...) {
    long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;

    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
        resourceClass, transcodeClass, options);
    //读取内存中的弱引用
    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
      }
      return null;
    }
    //读取内存缓存
    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
    if (cached != null) {
      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from cache", startTime, key);
      }
      return null;
    }
    
    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
    if (current != null) {
      current.addCallback(cb, callbackExecutor);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Added to existing load", startTime, key);
      }
      return new LoadStatus(cb, current);
    }

    EngineJob<R> engineJob =
        engineJobFactory.build(
            key,
            isMemoryCacheable,
            useUnlimitedSourceExecutorPool,
            useAnimationPool,
            onlyRetrieveFromCache);

    DecodeJob<R> decodeJob =
        decodeJobFactory.build(...);

    jobs.put(key, engineJob);

    engineJob.addCallback(cb, callbackExecutor);
    //若从两级内存缓存中 都没有找到 则开启DecodeJob去加载图片
    engineJob.start(decodeJob);

    if (VERBOSE_IS_LOGGABLE) {
      logWithTimeAndKey("Started new load", startTime, key);
    }
    return new LoadStatus(cb, engineJob);
  }
```

在`Engine.load()`，主要执行逻辑是：先从`一级内存缓存-弱引用`中查找指定资源，找不到则去`二级内存缓存-LRUCache`中去查找，再没有就转到`DecodeJob`去加载图片。

加载图片的具体实现细节会单独在[Glide缓存实现原理](#Glide缓存实现原理)说明。

#### 显示图片

当图片从三级缓存中取出后，最终得到的是一个`Resource`对象，然后再回调到`SingleRequest.onResourceReady()`中

```java SingleRequest.java
  @Override
  public synchronized void onResourceReady(Resource<?> resource, DataSource dataSource) {
    stateVerifier.throwIfRecycled();
    loadStatus = null;
    if (resource == null) {
      //回调加载失败事件
      onLoadFailed(exception);
      return;
    }

    Object received = resource.get();
    if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
      //回收资源
      releaseResource(resource);

      onLoadFailed(exception);
      return;
    }

    if (!canSetResource()) {
      releaseResource(resource);
      // 设置加载状态完成
      status = Status.COMPLETE;
      return;
    }

    onResourceReady((Resource<R>) resource, (R) received, dataSource);
  }

  private synchronized void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {
    // We must call isFirstReadyResource before setting status.
    boolean isFirstResource = isFirstReadyResource();
    status = Status.COMPLETE;
    this.resource = resource;

    if (glideContext.getLogLevel() <= Log.DEBUG) {
      Log.d(GLIDE_TAG, "Finished loading " + result.getClass().getSimpleName() + " from "
          + dataSource + " for " + model + " with size [" + width + "x" + height + "] in "
          + LogTime.getElapsedMillis(startTime) + " ms");
    }

    isCallingCallbacks = true;
    try {
      boolean anyListenerHandledUpdatingTarget = false;
      if (requestListeners != null) {
        for (RequestListener<R> listener : requestListeners) {
          anyListenerHandledUpdatingTarget |=
              listener.onResourceReady(result, model, target, dataSource, isFirstResource);
        }
      }
      anyListenerHandledUpdatingTarget |=
          targetListener != null
              && targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);

      if (!anyListenerHandledUpdatingTarget) {
        Transition<? super R> animation =
            animationFactory.build(dataSource, isFirstResource);
        target.onResourceReady(result, animation);
      }
    } finally {
      isCallingCallbacks = false;
    }
    
    notifyLoadSuccess();
  }
```

在`SingleRequest.onSourceReady()`主要回调了`Target.onResourceReady()`，把`Resource`显示到`Target`上，实质就是`into()`传入的Target对象。

```java ImageViewTarget.java
  @Override
  public void onResourceReady(@NonNull Z resource, @Nullable Transition<? super Z> transition) {
    if (transition == null || !transition.transition(resource, this)) {
      setResourceInternal(resource);
    } else {
      maybeUpdateAnimatable(resource);
    }
  }

  private void setResourceInternal(@Nullable Z resource) {
    // Order matters here. Set the resource first to make sure that the Drawable has a valid and
    // non-null Callback before starting it.
    setResource(resource);
    maybeUpdateAnimatable(resource);
  }

 protected abstract void setResource(@Nullable Z resource);
```

其中有两个类继承了`ImageViewTarget`用于实现不同的功能。分别是`DrawableImageViewTarget`、`BitmapImageViewTarget`。

```java DrawableImageViewTarget.java
public class DrawableImageViewTarget extends ImageViewTarget<Drawable> {

  public DrawableImageViewTarget(ImageView view) {
    super(view);
  }

  /**
   * @deprecated Use {@link #waitForLayout()} instead.
   */
  // Public API.
  @SuppressWarnings({"unused", "deprecation"})
  @Deprecated
  public DrawableImageViewTarget(ImageView view, boolean waitForLayout) {
    super(view, waitForLayout);
  }

  @Override
  protected void setResource(@Nullable Drawable resource) {
    view.setImageDrawable(resource);
  }
}
```

最终通过`ImageView.setImageDrawable()`将图片显示在ImageView上。

{% fullimage /images/Glide显示图片.png,Glide显示图片,Glide显示图片%}

## Glide缓存实现原理

> Glide的缓存主要分成了两个模块，一个是**内存缓存**，另一部分是**硬盘缓存**。
>
> **内存缓存**：防止应用重复将图片数据读取到内存当中
>
> **硬盘缓存**：防止应用重复从网络或其他地方重复下载和读取数据

### 缓存配置

1.在自定义的`GlideModule`中的`applyOptions()`中设置具体的缓存参数

```java
@GlideModule
public class CustomGlideModule extends AppGlideModule {
    @Override
    public void applyOptions(Context context, GlideBuilder builder) {
        MemorySizeCalculator calculator = new MemorySizeCalculator.Builder(context).build();
        int defaultMemoryCacheSize = calculator.getMemoryCacheSize();
        int defaultBitmapPoolSize = calculator.getBitmapPoolSize();
        int customMemoryCacheSize = (int) (1.2 * defaultMemoryCacheSize);
        int customBitmapPoolSize = (int) (1.2 * defaultBitmapPoolSize);
        builder.setMemoryCache(new LruResourceCache(customMemoryCacheSize));
        builder.setBitmapPool(new LruBitmapPool(customBitmapPoolSize));
    }
}
```

2.在具体请求中设置缓存参数

```java
//设置 不在磁盘中进行缓存且内存中也不缓存
val requestBuilder =Glide.with(this).asBitmap().apply(RequestOptions().diskCacheStrategy(DiskCacheStrategy.NONE).skipMemoryCache(true)).load(path)
```

### 缓存Key

缓存功能，就需要有对应的缓存Key，应用可以根据这个Key找到对应的缓存文件。Glide的缓存Key生成代码如下

```java Engine.java
public synchronized <R> LoadStatus load(...）{
      EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,resourceClass, transcodeClass, options);
...
}
```

`model`对应的就是`load()`过程中传入的参数，例如传入`String(图片加载地址)`，那么对应的就是加载地址。决定生成Key的参数有很多。

如果设置了`override`修改了加载尺寸，那也会有不同的key生成。

### 内存缓存

默认情况下，内存缓存是自动开启的，加载图片完成后，就会默认在内存中缓存，然后下次再调用时就会从内存中直接读取显示，无需重新加载。

> 可以通过设置`skipMemoryCache(true)`来关闭内存缓存功能。

Glide中的内存缓存主要分为两部分处理：**弱引用复用机制**和**LRUCache**。

#### 弱引用复用 —— ActiveResources

> 从正在活动的资源中取出缓存进行复用

```java Engine.java
public synchronized <R> LoadStatus load(...){
  ...
    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
      }
      return null;
    }
  ...
}

  @Nullable
 private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
    if (!isMemoryCacheable) {
      return null;
    }
    EngineResource<?> active = activeResources.get(key);
    if (active != null) {
      active.acquire();
    }
    return active;
  }
```

对应的Resource文件要从`ActiveResource`中获取

```java ActiveResource.java
final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();

  synchronized void deactivate(Key key) {
    ResourceWeakReference removed = activeEngineResources.remove(key);
    if (removed != null) {
      removed.reset();
    }
  }

@Nullable
  synchronized EngineResource<?> get(Key key) {
    //获取Key对应的弱引用对象
    ResourceWeakReference activeRef = activeEngineResources.get(key);
    if (activeRef == null) {
      return null;
    }
    EngineResource<?> active = activeRef.get();
    if (active == null) {
      cleanupActiveReference(activeRef);
    }
    return active;
  }

  //清除当前被GC的对象
  void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
    synchronized (listener) {
      synchronized (this) {
        activeEngineResources.remove(ref.key);
        if (!ref.isCacheable || ref.resource == null) {
          return;
        }
        //创建新的Resource对象 ref.resource是强引用类型
        EngineResource<?> newResource =
            new EngineResource<>(ref.resource, /*isCacheable=*/ true, /*isRecyclable=*/ false);
        newResource.setResourceListener(ref.key, listener);
        //将ref缓存进内存中
        listener.onResourceReleased(ref.key, newResource);
      }
    }
  }

 @VisibleForTesting
  static final class ResourceWeakReference extends WeakReference<EngineResource<?>> {
    @SuppressWarnings("WeakerAccess") @Synthetic final Key key;
    @SuppressWarnings("WeakerAccess") @Synthetic final boolean isCacheable;
    @Nullable @SuppressWarnings("WeakerAccess") @Synthetic Resource<?> resource;
    @Synthetic
    @SuppressWarnings("WeakerAccess")
    ResourceWeakReference(
        @NonNull Key key,
        @NonNull EngineResource<?> referent,
        @NonNull ReferenceQueue<? super EngineResource<?>> queue,
        boolean isActiveResourceRetentionAllowed) {
      super(referent, queue);
      this.key = Preconditions.checkNotNull(key);
      this.resource =
          referent.isCacheable() && isActiveResourceRetentionAllowed
              ? Preconditions.checkNotNull(referent.getResource()) : null;
      isCacheable = referent.isCacheable();
    }
    //清除强引用部分，方便回收
    void reset() {
      resource = null;
      clear();
    }
  }
```

`listener`对应的就是`Engine`对象，调用到`Engine.onResourceReleased()`

```java Engine.java
  @Override
  public synchronized void onResourceReleased(Key cacheKey, EngineResource<?> resource) {   
    //清除该key的强引用
    activeResources.deactivate(cacheKey);
    if (resource.isCacheable()) {
      //缓存数据到内存缓存LRUCache中
      cache.put(cacheKey, resource);
    } else {
      resourceRecycler.recycle(resource);
    }
  }
```

`ActivieResources`采用`HashMap + WeakReference`来保存`EngineResource`，不会有上限。然后`get()`从`activeEngineResources`弱引用HashMap中获取数据，这里分为两种情况：

1. 获取到弱引用关联对象`EngineResource`，则直接返回结果
2. 获取不到关联对象，则需进行清除工作调用`cleanupActiveResource()`，在`activeEngineResources`移除对应的key和引用，在判断是否开启缓存，若开启则缓存至`LRUCache`中。

总结：

`ActiveResources`采用弱引用的方式，里面存储的是`EngineResource`，同时采用强引用保存`EngineResource.resource`，在`ActiveResources`中还会有一个清理线程在运行，负责当`EngineResource`被回收时，就去取出对应的`EngineResource.resource`，然后创建一个新的`EngineResource`对象，回调到`Engine.onResourceReleased()`中，在其中做内存缓存，之后调用`ActivityResources.deactivate()`移除对应的强引用。

{% fullimage /images/内存缓存-弱引用机制.png,内存缓存-弱引用机制,内存缓存-弱引用机制%}

#### LRUCache

> 在当前活动资源中没有对应的缓存时，就要从内存中去进行读取

```java Engine.java
public synchronized <R> LoadStatus load(...){
  ...
    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
    if (cached != null) {
      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from cache", startTime, key);
      }
      return null;
    }
}

  private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
    //不允许缓存 直接返回null
    if (!isMemoryCacheable) {
      return null;
    }

    EngineResource<?> cached = getEngineResourceFromCache(key);①
    if (cached != null) {
      cached.acquire();
      //存入活动资源中
      activeResources.activate(key, cached);②
    }
    return cached;
  }

  private EngineResource<?> getEngineResourceFromCache(Key key) {
    Resource<?> cached = cache.remove(key);③

    final EngineResource<?> result;
    if (cached == null) {
      result = null;
    } else if (cached instanceof EngineResource) {
      result = (EngineResource<?>) cached;
    } else {
      result = new EngineResource<>(cached, true /*isMemoryCacheable*/, true /*isRecyclable*/);
    }
    return result;
  }
```

`loadFromCache()`实际调用到`getEngineResourceFromCache()`获取内存缓存中的资源，如果找到，缓存数量+1，然后会把`cached`放入`ActiveResources`中，变为活动资源，对应的要在`内存缓存`中移除引用。

①`getEngineResourceFromCache(key)`：从内存缓存中根据缓存key获取缓存

②`activeResources.activate(key, cached)`：取出的缓存数据存入到活动资源中

```java ActiveResources.java
  synchronized void activate(Key key, EngineResource<?> resource) {
    //构件新的 弱引用对象
    ResourceWeakReference toPut =
        new ResourceWeakReference(
            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);
    
    ResourceWeakReference removed = activeEngineResources.put(key, toPut);
    //如果存在替换，也需要把旧数据回收
    if (removed != null) {
      removed.reset();
    }
  }
```

③`cache.remove(key)`：从内存缓存中移除对应缓存

`cache`对应的是`MemoryCache`是一个接口，实现类为`LruResourceCache`

```java LruResourceCache.java
public class LruResourceCache extends LruCache<Key, Resource<?>> implements MemoryCache {
  private ResourceRemovedListener listener;

  public LruResourceCache(long size) {
    super(size);
  }

  //监听资源移除
  @Override
  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
    this.listener = listener;
  }

  //当前缓存被淘汰是调用
  @Override
  protected void onItemEvicted(@NonNull Key key, @Nullable Resource<?> item) {
    if (listener != null && item != null) {
      listener.onResourceRemoved(item);
    }
  }
  //获取当前缓存大小
  @Override
  protected int getSize(@Nullable Resource<?> item) {
    if (item == null) {
      return super.getSize(null);
    } else {
      return item.getSize();
    }
  }

  @SuppressLint("InlinedApi")
  @Override
  //内存不足时 触发
  public void trimMemory(int level) {
    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
      clearMemory();
    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {
      trimToSize(getMaxSize() / 2);
    }
  }
}
```

`LruResourceCache`继承自`LruCache`，不过内部计算缓存大小是通过`Resource`对象的大小累计，还增加了资源移除监听，为了和`ActiveResources`进行联动。

`LruResourceCache`的`size`是在自定义`GlideModule`中的 `applyOptions()`时设置进来的，如果未设置会采用`MemorySizeCalculator.getMemoryCacheSize()`设置。

当前在内存中缓存的对象都是`Resource`，而不是通常认为的Bitmap，下面会介绍到转码的过程。

{% fullimage /images/内存缓存-LruCache.png,内存缓存-LruCache,内存缓存-LruCache%}

#### 小结

在`内存缓存`中，分为两种方案：**从弱引用中获取**、**从内存缓存中获取**。两者的关系简单概括就是：

> 读取内存缓存时，会优先从`ActiveResources`中读取，读取到的话，需要判断当前包装`Resource`的弱引用对象是否被回收，未回收则直接返回。被回收的话，需要重新包装`EngineResource.resource`然后存入到内存缓存中并需要移除`ActiveResources`对其的引用。
>
> 从`ActiveResources`中没有获取到对应缓存时，就从`LruResourceCache`中去获取，获取到的话，就需要从当前内存缓存中移除对应缓存引用，并存入到`ActiveResources`中。
>
> **实现了正在使用的图片通过弱引用进行缓存，未使用的图片通过LruCache进行缓存。**
>
> `ActiveResources`优先级高于`LruResourceCache`。

比较两者之间的区别：

|          | 弱引用获取                                     | 内存缓存获取                    |
| -------- | ---------------------------------------------- | ------------------------------- |
| 基础实现 | HashMap                                        | LinkedHashMap(*LruCache*)       |
| 可否禁用 | 用户无法禁用                                   | 通过`skipMemoryCache(true)`禁用 |
| 运行位置 | 内存                                           | 内存                            |
| 释放时机 | 依赖垃圾回收机制<br>**弱引用实现，GC时被回收** | 采用**最近最少使用**来淘汰数据  |

### 磁盘缓存

> 当内存中不存在缓存时，就会向下从硬盘中去读取缓存数据
>
> 通过设置`diskCacheStrategy(DiskCacheStrategy.NONE)`来关闭硬盘缓存功能。

```java Engine.java
public synchronized <R> LoadStatus load(...){
  ...
    //判断当前是否存在该任务 EngineJob
    // private final Map<Key, EngineJob<?>> jobs = new HashMap<>();
    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
    if (current != null) {
      //资源加载完毕通知回调
      current.addCallback(cb, callbackExecutor);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Added to existing load", startTime, key);
      }
      return new LoadStatus(cb, current);
    }
    //内部维护线程池，用来管理资源加载
    EngineJob<R> engineJob =
        engineJobFactory.build(...);
    //用来进行资源加载
    DecodeJob<R> decodeJob =
        decodeJobFactory.build(... , engineJob);
    //插入任务列表中
    jobs.put(key, engineJob);

    engineJob.addCallback(cb, callbackExecutor);
    //开始进行加载
    engineJob.start(decodeJob);

}
```

从内存中读取不到缓存时，`Engine`尝试从`jobs`读取对应的`EngineJob`缓存，如存在就去回调`加载成功或加载失败`。不存在的话，就需要新建一个`EngineJob`以及`DecodeJob`去加载图片。

```java EngineJob.java
  public synchronized void start(DecodeJob<R> decodeJob) {
    this.decodeJob = decodeJob;
    GlideExecutor executor = decodeJob.willDecodeFromCache()
        ? diskCacheExecutor
        : getActiveSourceExecutor();
    executor.execute(decodeJob);
  }
```

通过线程池去执行`decodeJob`，`DecodeJob`实现了`Runnable`接口，`execute()`直接调用到`run()`

```java DecodeJob.java
 @SuppressWarnings("PMD.AvoidRethrowingException")
  @Override
  public void run() {
    //统计执行时长
    GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);
    DataFetcher<?> localFetcher = currentFetcher;
    try {
      if (isCancelled) {
        notifyFailed();
        return;
      }
      //实际执行逻辑
      runWrapped();
    } catch (CallbackException e) {
      throw e;
    } catch (Throwable t) {
      if (stage != Stage.ENCODE) {
        throwables.add(t);
        notifyFailed();
      }
      if (!isCancelled) {
        throw t;
      }
      throw t;
    } finally {
      // Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call
      // close in all cases anyway.
      if (localFetcher != null) {
        localFetcher.cleanup();
      }
      GlideTrace.endSection();
    }
  }

  private void runWrapped() {
    switch (runReason) {
      case INITIALIZE:
        stage = getNextStage(Stage.INITIALIZE);
        currentGenerator = getNextGenerator();
        runGenerators();
        break;
      case SWITCH_TO_SOURCE_SERVICE:
        runGenerators();
        break;
      case DECODE_DATA:
        //解析数据并解码
        decodeFromRetrievedData();
        break;
      default:
        throw new IllegalStateException("Unrecognized run reason: " + runReason);
    }
  }

  private enum RunReason {
    //第一次执行
    INITIALIZE,
    //从Cache中去读取数据失败，则从其他渠道读取
    SWITCH_TO_SOURCE_SERVICE,
    //解析数据
    DECODE_DATA,
  }

```

调用`DecodeJob.run()`开始加载资源，内部调用`runWrapped()`，此时`runWrapped()`中会根据`runReason`执行不同的操作，`runReason`就是用于控制当前执行到的任务。

> `INITIALIZE`：第一次调用`run()`，执行目的是从`diskcache`中获取缓存
>
> `SWITCH_TO_SOURCE_SERVICE`：从`diskcache`中获取缓存失败，需要从数据源获取
>
> `DECODE_DATA`：缓存数据成功，对数据进行解析

#### 获取硬盘缓存数据

```java DecodeJob.java
//通过 RequestOptions.diskCacheStrategy() 设置
private DiskCacheStrategy diskCacheStrategy;

private void runGenerators() {
    currentThread = Thread.currentThread();
    startFetchTime = LogTime.getLogTime();
    boolean isStarted = false;
    while (!isCancelled && currentGenerator != null
        && !(isStarted = currentGenerator.startNext())) {
      stage = getNextStage(stage);
      currentGenerator = getNextGenerator();

      if (stage == Stage.SOURCE) {
        reschedule();
        return;
      }
    }
    // We've run out of stages and generators, give up.
    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {
      notifyFailed();
    }
  }

  private Stage getNextStage(Stage current) {
    switch (current) {
      case INITIALIZE:
        //支持转换后的图片缓存 返回状态就是RESOURCE_CACHE
        return diskCacheStrategy.decodeCachedResource()
            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
      case RESOURCE_CACHE:
        //支持转换后的图片缓存 返回状态就是DATA_CACHE
        return diskCacheStrategy.decodeCachedData()
            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
      case DATA_CACHE:
        //如果缓存已存在 就返回结束 否则去加载远程图片
        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
      case SOURCE:
      case FINISHED:
        return Stage.FINISHED;
      default:
        throw new IllegalArgumentException("Unrecognized stage: " + current);
    }
  }

  //根据不同的步骤 调用不同的Generator对象
  private DataFetcherGenerator getNextGenerator() {
    switch (stage) {
      case RESOURCE_CACHE:
        return new ResourceCacheGenerator(decodeHelper, this);
      case DATA_CACHE:
        return new DataCacheGenerator(decodeHelper, this);
      case SOURCE:
        return new SourceGenerator(decodeHelper, this);
      case FINISHED:
        return null;
      default:
        throw new IllegalStateException("Unrecognized stage: " + stage);
    }
  }

  private enum Stage {
    //加载初始状态
    INITIALIZE,
    //转换后图片的缓存
    RESOURCE_CACHE,
    //原图缓存
    DATA_CACHE,
    //远程图片
    SOURCE,
    //解析图片
    ENCODE,
    //加载完成
    FINISHED,
  }
```

`stage`对应`Stage`枚举类，可以通过`DiskCacheStrategy`得到`Stage`。

> `DiskCacheStrategy`参数解释：
>
> - `NONE`：表示不缓存任何内容
> - `DATA`：只缓存原始图片
> - `RESOURCE`：只缓存转换后的图片
> - `ALL`：原始图片和转换后的图片都进行缓存
> - `AUTOMATIC`：尝试选择最佳策略。针对加载数据类型进行区分：
>   - 加载本地图片：缓存原始图片
>   - 加载网络图片：缓存转换后的图片

`stage`默认尽量就是`INITIALIZE`，通过递归调用`getNextStage()`向下推进，并改变`stage`表示进行状态。`stage`的推进过程也表示了硬盘缓存的查找顺序。

| Stage          | 描述                                    |
| -------------- | --------------------------------------- |
| INITIALIZE     | 初始状态                                |
| RESOURCE_CACHE | 转换后缓存 调用`ResourceCacheGenerator` |
| DATA_CACHE     | 原图缓存 调用`DataCacheGenerator`       |
| SOURCE         | 远程获取图片 调用`SourceGenerator`      |
| ENCODE         | 解析资源，生成`Resource`对象            |
| FINISHED       | 解析完成                                |

查找缓存从`初始查找开始`->`查找转换后图片缓存`->`查找原图图片缓存`->`前面都没找到就去进行远程加载`->`加载完成后就开始解析数据`->`解析完成`。

查找缓存从`currentGenerator.startNext()`开始，就先从`ResourceCacheGenerator`开始

```java ResourceCacheGenerator.java
  private File cacheFile;
  public boolean startNext() {
    List<Key> sourceIds = helper.getCacheKeys();
    if (sourceIds.isEmpty()) {
      return false;
    }
    List<Class<?>> resourceClasses = helper.getRegisteredResourceClasses();
    if (resourceClasses.isEmpty()) {
      if (File.class.equals(helper.getTranscodeClass())) {
        return false;
      }
      throw new IllegalStateException(
         "Failed to find any load path from " + helper.getModelClass() + " to "
             + helper.getTranscodeClass());
    }
    while (modelLoaders == null || !hasNextModelLoader()) {
      resourceClassIndex++;
      if (resourceClassIndex >= resourceClasses.size()) {
        sourceIdIndex++;
        if (sourceIdIndex >= sourceIds.size()) {
          return false;
        }
        resourceClassIndex = 0;
      }

      Key sourceId = sourceIds.get(sourceIdIndex);
      Class<?> resourceClass = resourceClasses.get(resourceClassIndex);
      Transformation<?> transformation = helper.getTransformation(resourceClass);
      //构建磁盘缓存key
      currentKey =
          new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops
              helper.getArrayPool(),
              sourceId,
              helper.getSignature(),
              helper.getWidth(),
              helper.getHeight(),
              transformation,
              resourceClass,
              helper.getOptions());
      //根据Key去获取cacheFile
      cacheFile = helper.getDiskCache().get(currentKey);
      if (cacheFile != null) {
        sourceKey = sourceId;
        modelLoaders = helper.getModelLoaders(cacheFile);
        modelLoaderIndex = 0;
      }
    }

    loadData = null;
    boolean started = false;
    while (!started && hasNextModelLoader()) {
      //使用FileLoader去加载对应cache文件
      ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
      loadData = modelLoader.buildLoadData(cacheFile,
          helper.getWidth(), helper.getHeight(), helper.getOptions());
      if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
        started = true;
        loadData.fetcher.loadData(helper.getPriority(), this);
      }
    }

    return started;
  }
```

根据相关参数生成对应的`cacheKey`，然后从`DiskCache`中取出对应的`cacheFile`，然后使用`FileLoader`解析该文件。

> `helper.getDiskCache()`对应的就是`DiskLruCacheWrapper`类，内部包装了`DiskLruCache`，内部实现了整套的文件读写功能。

#### 远程获取数据

若为初次加载的数据，肯定不会在`diskCache`中获取到，就需要远程加载。

```java SourceGenerator.java
  public boolean startNext() {
    //判断当前是否存在缓存
    if (dataToCache != null) {
      Object data = dataToCache;
      dataToCache = null;
      
      cacheData(data);
    }
    //存在缓存
    if (sourceCacheGenerator != null && sourceCacheGenerator.startNext()) {
      return true;
    }
    sourceCacheGenerator = null;

    loadData = null;
    boolean started = false;
    while (!started && hasNextModelLoader()) {
      loadData = helper.getLoadData().get(loadDataListIndex++);
      if (loadData != null && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
        started = true;
        //加载远程图片
        loadData.fetcher.loadData(helper.getPriority(), this);
      }
    }
    return started;
  }
//缓存至磁盘中
private void cacheData(Object dataToCache) {
    long startTime = LogTime.getLogTime();
    try {
      Encoder<Object> encoder = helper.getSourceEncoder(dataToCache);
      DataCacheWriter<Object> writer =
          new DataCacheWriter<>(encoder, dataToCache, helper.getOptions());
      originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());
      helper.getDiskCache().put(originalKey, writer);
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "Finished encoding source to cache"
            + ", key: " + originalKey
            + ", data: " + dataToCache
            + ", encoder: " + encoder
            + ", duration: " + LogTime.getElapsedMillis(startTime));
      }
    } finally {
      loadData.fetcher.cleanup();
    }

    sourceCacheGenerator =
        new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);
  }

  @Override
  public void onDataReady(Object data) {
    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();
    if (data != null && diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) {
      //上面判断是否cache
      dataToCache = data;
      cb.reschedule();
    } else {
      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,
          loadData.fetcher.getDataSource(), originalKey);
    }
  }
```

在`SourceGenerator.startNext()`会优先判断数据是否在`DiskCache`中，若存在调用`cacheData()`创建`DataCacheGenerator`调用其`startNext()`。不存在则循环去获取`loadData`，通过`DecodeHelper.getLoadData()`，然后继续执行`loadData.fetch.loadData()`去加载数据，加载成功后回调到`onDataReady()`。

现在开始按步骤分析：

##### 加载远程数据——地址加载(`HttpUrlFetcher`)

```java HttpUrlFetcher.java
 public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
    try {
      InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
      callback.onDataReady(result);
    } catch (IOException e) {
      callback.onLoadFailed(e);
    } finally {
    }
  }

```

##### 加载本地数据——本地文件加载(`ByteBufferFetcher`)

```java ByteBufferFileLoader.java
private static final class ByteBufferFetcher implements DataFetcher<ByteBuffer> {
  ...
     @Override
    public void loadData(@NonNull Priority priority,
        @NonNull DataCallback<? super ByteBuffer> callback) {
      ByteBuffer result;
      try {
        result = ByteBufferUtil.fromFile(file);
      } catch (IOException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "Failed to obtain ByteBuffer for file", e);
        }
        callback.onLoadFailed(e);
        return;
      }

      callback.onDataReady(result);
    }
}
```

`loadData()`成功后，回调到`SourceGenerator.onDataReady()`中。这时需要判断是否开启了硬盘缓存，如果关闭了直接回调到`DecodeJob.onDataFetcherReady()`，开启了的话，就继续调用到`DecodeJob.reschedule()`。

```jave DecodeJob.java
 @Override
  public void reschedule() {
    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
    callback.reschedule(this);
  }

  @Override
  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,
      DataSource dataSource, Key attemptedKey) {
    this.currentSourceKey = sourceKey;
    this.currentData = data;
    this.currentFetcher = fetcher;
    this.currentDataSource = dataSource;
    this.currentAttemptingKey = attemptedKey;
    if (Thread.currentThread() != currentThread) {
      //向下执行 数据解析
      runReason = RunReason.DECODE_DATA;
      //再次调用到 runWrapped() 此时会走向 decodeFromRetrievedData()
      callback.reschedule(this);
    } else {
      GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData");
      try {
        // 解析数据的真正逻辑
        decodeFromRetrievedData();
      } finally {
        GlideTrace.endSection();
      }
    }
  }
  
  private void runWrapped() {
    switch (runReason) {
      case INITIALIZE:
        stage = getNextStage(Stage.INITIALIZE);
        currentGenerator = getNextGenerator();
        runGenerators();
        break;
      case SWITCH_TO_SOURCE_SERVICE:
        runGenerators();
        break;
      case DECODE_DATA:
        //解析数据并解码
        decodeFromRetrievedData();
        break;
      default:
        throw new IllegalStateException("Unrecognized run reason: " + runReason);
    }
  }
```

在`reschedule()`，把`runReason`设为`SWITCH_TO_SOURCE_SERVICE`，继续调用到`EngineJob.reschedule()`，再次执行到`DecodeJob.run()`不过已经在一个新的线程池中继续执行。

在`onDataFetcherReady()`中，会判断当前线程是否相同，不同的话，设置`runReason`为`DECODE_DATA`，重新执行`EngineJob.reschedule()`还会走到`run()`中，继续执行到` decodeFromRetrievedData()`，线程相同则直接执行。

#### 解析数据

> 此时拿到的数据类型还是`InputStream`或者`ByteBuffer`，需要解析成常用的`File`或者`Bitmap`。

此时`runReason`为`DECODE_DATA`，调用到`decodeFromRetrievedData()`

```java DecodeJob.java
private Object currentData;  
private void decodeFromRetrievedData() {
    ...
    Resource<R> resource = null;
    try {
      resource = decodeFromData(currentFetcher, currentData, currentDataSource);
    } catch (GlideException e) {
      e.setLoggingDetails(currentAttemptingKey, currentDataSource);
      throwables.add(e);
    }
    if (resource != null) {
      notifyEncodeAndRelease(resource, currentDataSource);
    } else {
      runGenerators();
    }
  }

  private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,
      DataSource dataSource) throws GlideException {
    try {
      ...
      Resource<R> result = decodeFromFetcher(data, dataSource);
      return result;
    } finally {
      fetcher.cleanup();
    }
  }

  @SuppressWarnings("unchecked")
  private <Data> Resource<R> decodeFromFetcher(Data data, DataSource dataSource)
      throws GlideException {
    LoadPath<Data, ?, R> path = decodeHelper.getLoadPath((Class<Data>) data.getClass());
    return runLoadPath(data, dataSource, path);
  }

  private <Data, ResourceType> Resource<R> runLoadPath(Data data, DataSource dataSource,
      LoadPath<Data, ResourceType, R> path) throws GlideException {
    Options options = getOptionsWithHardwareConfig(dataSource);
    DataRewinder<Data> rewinder = glideContext.getRegistry().getRewinder(data);
    try {
      return path.load(
          rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));
    } finally {
      rewinder.cleanup();
    }
  }
```

调用`decodeFromRetrievedData`开始解析加载返回的数据，数据格式可能为`InputSteam`、`ByteBuffer`。向下调用到`decodeFromData()`，再到`decodeFromFetcher()`，最终通过`DecodeHelper.getLoadPath()`得到的`LoadPath`去对获取的数据进行解析。

```java LoadPath.java
  public Resource<Transcode> load(DataRewinder<Data> rewinder, @NonNull Options options, int width,
      int height, DecodePath.DecodeCallback<ResourceType> decodeCallback) throws GlideException {
    List<Throwable> throwables = Preconditions.checkNotNull(listPool.acquire());
    try {
      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);
    } finally {
      listPool.release(throwables);
    }
  }

private Resource<Transcode> loadWithExceptionList(DataRewinder<Data> rewinder,
      @NonNull Options options,
      int width, int height, DecodePath.DecodeCallback<ResourceType> decodeCallback,
      List<Throwable> exceptions) throws GlideException {
    Resource<Transcode> result = null;
    //noinspection ForLoopReplaceableByForEach to improve perf
    for (int i = 0, size = decodePaths.size(); i < size; i++) {
      DecodePath<Data, ResourceType, Transcode> path = decodePaths.get(i);
      try {
        //又传递到DecodePath上
        result = path.decode(rewinder, width, height, options, decodeCallback);
      } catch (GlideException e) {
        exceptions.add(e);
      }
      if (result != null) {
        break;
      }
    }

    if (result == null) {
      throw new GlideException(failureMessage, new ArrayList<>(exceptions));
    }

    return result;
  }
```

```java DecodePath.java
  public Resource<Transcode> decode(DataRewinder<DataType> rewinder, int width, int height,
      @NonNull Options options, DecodeCallback<ResourceType> callback) throws GlideException {
    Resource<ResourceType> decoded = decodeResource(rewinder, width, height, options);
    Resource<ResourceType> transformed = callback.onResourceDecoded(decoded);
    return transcoder.transcode(transformed, options);
  }

  @NonNull
  private Resource<ResourceType> decodeResource(DataRewinder<DataType> rewinder, int width,
      int height, @NonNull Options options) throws GlideException {
    List<Throwable> exceptions = Preconditions.checkNotNull(listPool.acquire());
    try {
      return decodeResourceWithList(rewinder, width, height, options, exceptions);
    } finally {
      listPool.release(exceptions);
    }
  }

 @NonNull
  private Resource<ResourceType> decodeResourceWithList(DataRewinder<DataType> rewinder, int width,
      int height, @NonNull Options options, List<Throwable> exceptions) throws GlideException {
    Resource<ResourceType> result = null;
    //noinspection ForLoopReplaceableByForEach to improve perf
    for (int i = 0, size = decoders.size(); i < size; i++) {
      ResourceDecoder<DataType, ResourceType> decoder = decoders.get(i);
      try {
        //数据解析器
        DataType data = rewinder.rewindAndGet();
        if (decoder.handles(data, options)) {
          data = rewinder.rewindAndGet();
          result = decoder.decode(data, width, height, options);
        }
      } catch (IOException | RuntimeException | OutOfMemoryError e) {

      }

      if (result != null) {
        break;
      }
    }

    if (result == null) {
      throw new GlideException(failureMessage, new ArrayList<>(exceptions));
    }
    return result;
  }
```

`LoadPath.load()`通过调用`loadWithExceptionList()`，循环获取`DecodePath`对象，然后调用其自身的`decode()`进行数据解析。`DecodePath`与`LoadPath`逻辑相似，最终在`DecodePath.decodeResourceWithList()`中循环获取`ResourceDecoder`对象，通过`DateRewinder.rewindAndGet()`获取要解析数据的格式(比如`ByteBuffer，InputStream`)，然后调用`decoder.decode`继续解析数据。

##### 获取数据格式

由上述流程可知，我们能获得的数据类型为`InputStream`和`ByteBuffer`，对应的就会有两种`DataRewinder`

```java InputStreamRewinder.java
 private final RecyclableBufferedInputStream bufferedStream;
@NonNull
  @Override
  public InputStream rewindAndGet() throws IOException {
    bufferedStream.reset();
    return bufferedStream;
  }
```

```java ByteBufferRewinder.java
  @NonNull
  @Override
  public ByteBuffer rewindAndGet() {
    buffer.position(0);
    return buffer;
  }
```

将传进来的data可以转换成对应的数据格式。

##### 根据格式转换相应类型

得到对应数据格式后，就需要通过`ResourceDecoder.decode()`去解析数据。

```java ResourceDecoder.java
public interface ResourceDecoder<T, Z> {
  //判断这两个组合参数是否能进行解析
  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;

   */
  @Nullable
  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options)
      throws IOException;
}
```

`T`代表需要被解析的类型(例如InputStream、ByteBuffer)，`Z`代表解析的结果类型(例如Bitmap、Drawable)。

`ResourceDecoder`在原码中有很多实现类，`StreamBitmapDecoder`、`ButeBufferBitmapDecoder`，此处拿出常用的`StreamBitmapDecoder`进行分析。

```java StreamBitmapDecoder.java
  @Override
  public boolean handles(@NonNull InputStream source, @NonNull Options options) {
    return downsampler.handles(source);
  }

  @Override
  public Resource<Bitmap> decode(@NonNull InputStream source, int width, int height,
      @NonNull Options options)
      throws IOException {

    // Use to fix the mark limit to avoid allocating buffers that fit entire images.
    final RecyclableBufferedInputStream bufferedStream;
    final boolean ownsBufferedStream;
    if (source instanceof RecyclableBufferedInputStream) {
      bufferedStream = (RecyclableBufferedInputStream) source;
      ownsBufferedStream = false;
    } else {
      bufferedStream = new RecyclableBufferedInputStream(source, byteArrayPool);
      ownsBufferedStream = true;
    }
    ExceptionCatchingInputStream exceptionStream =
        ExceptionCatchingInputStream.obtain(bufferedStream);

    MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream);
    UntrustedCallbacks callbacks = new UntrustedCallbacks(bufferedStream, exceptionStream);
    try {
      return downsampler.decode(invalidatingStream, width, height, options, callbacks);
    } finally {
      exceptionStream.release();
      if (ownsBufferedStream) {
        bufferedStream.release();
      }
    }
  }
```

`ResourceDecode.decode()`内部是通过`Downsampler.decode()`进行解析

```java Downsampler.java
  @SuppressWarnings({"resource", "deprecation"})
  public Resource<Bitmap> decode(InputStream is, int requestedWidth, int requestedHeight,
      Options options, DecodeCallbacks callbacks) throws IOException {
    ...
    try {
      Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
          downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,
          requestedHeight, fixBitmapToRequestedDimensions, callbacks);
      return BitmapResource.obtain(result, bitmapPool);
    } finally {
      releaseOptions(bitmapFactoryOptions);
      byteArrayPool.put(bytesForOptions);
    }
  }

 private Bitmap decodeFromWrappedStreams(InputStream is,
      BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
      DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,
      int requestedHeight, boolean fixBitmapToRequestedDimensions,
      DecodeCallbacks callbacks) throws IOException {
   
      Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);
      callbacks.onDecodeComplete(bitmapPool, downsampled);
 }

 private static Bitmap decodeStream(InputStream is, BitmapFactory.Options options,
      DecodeCallbacks callbacks, BitmapPool bitmapPool) throws IOException {
    ...
    TransformationUtils.getBitmapDrawableLock().lock();
    try {
      result = BitmapFactory.decodeStream(is, null, options);
    } catch (IllegalArgumentException e) {
      ...
      throw bitmapAssertionException;
    } finally {
      TransformationUtils.getBitmapDrawableLock().unlock();
    }
   ...
  }
```

`Downsampler.decode()`内部主要实现依靠`decodeFromWrapperStreams()`，内部主要是配置`BitmapFactory.Options`。去控制图片的缩放(scale)、旋转(rotate)、复用(inBitmap)等方面配置。最后通过`decodeStream`解析输入流，最后生成Bitmap对象返回。

##### 获取图片后继续处理(例如圆角)

```java DecodePath.java
  public Resource<Transcode> decode(DataRewinder<DataType> rewinder, int width, int height,
      @NonNull Options options, DecodeCallback<ResourceType> callback) throws GlideException {
    //上述步骤已完成
    Resource<ResourceType> decoded = decodeResource(rewinder, width, height, options);
    //加载完成的回调 调用Transform
    Resource<ResourceType> transformed = callback.onResourceDecoded(decoded);
    return transcoder.transcode(transformed, options);
  }
```

`decodeResource`最终会调到`DecodeJob.onResourceDecoded()`进行`Transform`处理。

```java
 <Z> Resource<Z> onResourceDecoded(DataSource dataSource,
      @NonNull Resource<Z> decoded) {
    @SuppressWarnings("unchecked")
    Class<Z> resourceSubClass = (Class<Z>) decoded.get().getClass();
    Transformation<Z> appliedTransformation = null;
    Resource<Z> transformed = decoded;
    if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
      //获取到的是 RequestOptions.getTransformations()这个集合
      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
      transformed = appliedTransformation.transform(glideContext, decoded, width, height);
    }
    // TODO: Make this the responsibility of the Transformation.
    if (!decoded.equals(transformed)) {
      decoded.recycle();
    }
if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,
        encodeStrategy)) {
      if (encoder == null) {
        throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
      }
      final Key key;
      switch (encodeStrategy) {
        case SOURCE:
          key = new DataCacheKey(currentSourceKey, signature);
          break;
        case TRANSFORMED:
          key =
              new ResourceCacheKey(
                  decodeHelper.getArrayPool(),
                  currentSourceKey,
                  signature,
                  width,
                  height,
                  appliedTransformation,
                  resourceSubClass,
                  options);
          break;
        default:
          throw new IllegalArgumentException("Unknown strategy: " + encodeStrategy);
      }
    ...
    }
    return result;
  }

```

> 从这里可看出 保存原图和保存转换后图片的缓存key是不一致的。
>
> 缓存原图用的是`DataCacheKey`，保存转换后图片用的是`ResourceCacheKey`

上述数据处理完毕后，层层回溯到达了`decodeFromRetrievedData`()

```java DecodeJob.java
private void decodeFromRetrievedData() {
    ...
    Resource<R> resource = null;
    try {
      resource = decodeFromData(currentFetcher, currentData, currentDataSource);
    } catch (GlideException e) {
      e.setLoggingDetails(currentAttemptingKey, currentDataSource);
      throwables.add(e);
    }
    //这时Resource已经赋值完毕
    if (resource != null) {
      notifyEncodeAndRelease(resource, currentDataSource);
    } else {
      runGenerators();
    }
  }

  private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {
    if (resource instanceof Initializable) {
      ((Initializable) resource).initialize();
    }

    notifyComplete(result, dataSource);
    //加载完毕后 回到初始状态
    stage = Stage.ENCODE;
    ...
  }

  private void notifyComplete(Resource<R> resource, DataSource dataSource) {
    setNotifiedOrThrow();
    callback.onResourceReady(resource, dataSource);
  }
```

经过解析数据那一套流程下来后，数据已经加载完成，然后回到`DecodeJob.decodeFromRetrieveData()`，这时Resource对象不为空，向下继续调用`notifyEncodeAndRelease()`，内部调用到`notifyComplete()`再回调到`EngineJob.onResourceReady()`。

```java EngineJob.java
  @Override
  public void onResourceReady(Resource<R> resource, DataSource dataSource) {
    synchronized (this) {
      this.resource = resource;
      this.dataSource = dataSource;
    }
    notifyCallbacksOfResult();
  }

  void notifyCallbacksOfResult() {
    ResourceCallbacksAndExecutors copy;
    Key localKey;
    EngineResource<?> localResource;

    listener.onEngineJobComplete(this, localKey, localResource);

    for (final ResourceCallbackAndExecutor entry : copy) {
      entry.executor.execute(new CallResourceReady(entry.cb));
    }
    decrementPendingCallbacks();
  }
```

`EngineJob.onResourceReady()`资源加载完成后，通过`notifyCallbacksOfResulr()`调用到`Engine.onEngineJobComplete()`

```java Engine.java
  public synchronized void onEngineJobComplete(
      EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
    // A null resource indicates that the load failed, usually due to an exception.
    if (resource != null) {
      resource.setResourceListener(key, this);

      if (resource.isCacheable()) {
        activeResources.activate(key, resource);
      }
    }

    jobs.removeIfCurrent(key, engineJob);
  }


```

加载完成后，把对应资源插入到`ActiveResources`中作为活动资源。

{% fullimage /images/Glide-硬盘缓存.png,Glide-硬盘缓存,Glide-硬盘缓存%}

## Glide高级用法

处理带有后缀的图片类型，可能为了保证安全，不同的用户获取的图片除了图片地址外还会有一段标识用户的token。而且token并不一定是固定的，这样我们再去加载图片时，由于缓存key不一致，导致重复加载。

这里涉及到了[缓存key](#缓存key)的生成，其中有一个重要参数为远程图片加载地址，对于上述情况，因为地址的变化，key不同则查找缓存时也无法命中，解决这个情况就需要排除掉变化的部分。

```java
class MyGlideUrl extends GlideUrl{

    private String mUrl;

    public MyGlideUrl(String url) {
        super(url);
        mUrl = url;
    }

    @Override
    public String getCacheKey() {
        return mUrl.replace(replaceTokenParam(),"");
    }
    
    private String replaceTokenParam(){
        String tokenParam="";
        int tokenIndex = mUrl.contains("?.token") ? mUrl.indexOf("?token"):mUrl.indexOf("&token");
        if(tokenIndex!=-1){
            int nextAndIndex = mUrl.indexOf("&",tokenIndex+1);
            if (nextAndIndex!=-1){
                tokenParam = mUrl.substring(tokenIndex+1,nextAndIndex+1);
            }else{
                tokenParam = mUrl.substring(tokenIndex);
            }
        }
        return tokenParam;
    }
}


Glide.with(mContext).load(MyGlideUrl(imgUrl)).into(imageView);
```

## 内容引用

[Glide主流源码分析](https://juejin.im/post/5c31fbdff265da610e803d4e#heading-14)

[Glide4.8源码拆解（二）核心加载流程](<https://juejin.im/post/5c2dffa8f265da611d66c8b6#heading-2>)

]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关及其拓展(三) -- 虚拟机类加载器</title>
    <url>/2018/04/16/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%89/</url>
    <content><![CDATA[
# 1.虚拟机类加载器

## 定义：

在类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码块称为“类加载器”。

例如：编写的是.java文件，代码运行后变成.class文件，类加载器就是加载.class文件。

**不同的类加载器加载同一个类时，得到的两个类也是不相等的。**



## Java类加载器分类：

### 1.系统提供的类加载器

{% fullimage /images/类加载器.png,类加载器分类,类加载器分类%}

- **Bootstrap ClassLoader(启动类加载器)**：由C/C++实现的加载器，用于加载虚拟机运行时所需要的系统类，如`java.lang.*、java.uti.*`等系统类。它负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。

  这个加载器由于是C实现的，所以**无法被Java程序直接引用**。并且不继承`java.lang.ClassLoader`。

- **Extension ClassLoader(扩展类加载器)**：这个加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录中的，或者被`javax.ext.dirs`系统变量所指定的路径中的所有类库。

  **开发者可以直接进行引用。**

- **Application ClassLoader(应用程序类加载器)**：这个加载器由sun.misc.Launcher$AppClassLoader实现。可以加载用户类路径上的指定类库，通过`ClassLoader.getSystemClassLoader()`方式获取，没有定义过自己的类加载器，则默认是这个。

- **Custom ClassLoader(自定义加载器)**：通过集成`java.lang.ClassLoader`来实现自己的加载器。

  

### 2.双亲委托模型

{% fullimage /images/jvm/parent_loader.png, alt,双亲委托模型 %}

- 工作流程：如果一个类加载器收到了类加载的请求，不会自己去尝试加载这个类，而把这个请求委派给父类加载器去完成，每一层都是如此，依次向上递归，直到委托到最顶层的`Bootstrap ClassLoader`，若父加载器无法处理加载请求（它的搜索范围内没有找到所需的类时），则交由子加载器去加载。

  > 简单流程介绍
  >
  > 1. 自定义类加载器先从缓存中查看Class文件是否被加载，如果加载则返回Class，没有加载则委托给父类加载
  > 2. 一直委托到`Bootstrap ClassLoader`,在`Bootstrap ClassLoader`没有找到Class文件，则在自己的规定路径<JAVA_HOME>\lib或者-Xbootclasspath选项指定路径的jar包进行查询，找到则返回Class，没有就交由子加载器去加载。
  > 3. 最后交由我们自定义的类加载器去加载，还找不到则抛出`ClassNotFoundException`异常。
- 代码模型实现：


```java
 protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // 检查请求的类是否已被加载过
            Class<?> c = findLoadedClass(name);
            //对应的类已被加载则不会往下进行
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                    //父加载器不为null，调用父加载器的load方法
                        c = parent.loadClass(name, false);
                    } else {
                    //父加载器为null，则调用系统的BootstrapClassLoader
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                    //父类加载器无法加载则抛出ClassNotFoundException异常
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    //父类加载器无法加载则调用本身的findClass()方法去加载
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

- 好处：
  - 避免重复加载，若该Class已加载则从缓存中直接读取
  - 更加安全，例如`java.lang.Object`，无论哪一个类加载器去加载这个类，最终都会委派给Bootstrap ClassLoader去进行加载，所以我们自定义的Object类并不会被加载而导致系统中出现多个Object类。

###  3.破坏双亲委托模型

双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载实现方式。

- 在JDK1.2发布之前，还没有双亲委托机制
- 由模型自身缺陷所导致的
- 用户对于程序动态性导致的，例如代码热替换，模块热部署



### 4.自定义ClassLoader
- 自定义需要加载的类

  ```java
  public class Jobs {
          public void say() {
          System.err.println("自定义加载器加载");
      }
  }
  ```

  自定义完成后需调用`javac Jobs.java`去生成对应的`Jobs.class`文件以用来加载。

- 实现自定义的ClassLoader

  ```java
  import java.io.*;

  public class DiskClassLoader extends ClassLoader {
      private String path;

      public DiskClassLoader(String path) {
          this.path = path;
      }

      @Override
      protected Class<?> findClass(String name) throws ClassNotFoundException {
          Class clazz = null;
          byte[] classData = loadClassData(name);
          if (classData == null) {
              throw new ClassNotFoundException();
          } else {
              //用来将获取的字节码数组转为class的实例
              clazz = defineClass(name, classData, 0, classData.length);
          }
          return clazz;
      }

      /**
       * 获得class文件的字节码数组
       * @param name
       * @return
       */
      private byte[] loadClassData(String name) {
          String fileName = getFileName(name);
          File file = new File(path, fileName);
          System.err.println(fileName);
          InputStream inputStream = null;
          ByteArrayOutputStream byteArrayOutputStream = null;
          try {
              inputStream = new FileInputStream(file);
              byteArrayOutputStream = new ByteArrayOutputStream();
              byte[] buffer = new byte[1024];
              int length = 0;
              while ((length = inputStream.read(buffer)) != -1) {
                  byteArrayOutputStream.write(buffer, 0, length);
              }
              return byteArrayOutputStream.toByteArray();
          } catch (IOException e) {
              e.printStackTrace();
          } finally {
              //读取流后需要关闭，以免造成内存泄露
              try {
                  if (inputStream != null) {
                      inputStream.close();
                  }
              } catch (IOException e) {
                  e.printStackTrace();
              }
              try {
                  if (byteArrayOutputStream != null) {
                      byteArrayOutputStream.close();
                  }
              } catch (IOException e) {
                  e.printStackTrace();
              }
          }
          return null;
      }

      private String getFileName(String name) {
          int index = name.indexOf('.');
          if (index == -1) {
              return name + ".class";
          } else {
              return name.substring(index + 1) + ".class";
          }
      }
  }

  ```

  自定义的ClassLoader需要读取对应Class的字节流数组，以便产生实例。注意不要忘记对流的关闭。

- 使用自定义的ClassLoader去加载类

  ```java
  import java.lang.reflect.InvocationTargetException;
  import java.lang.reflect.Method;

  public class CustomClassLoaderTest{
       public static void main(String[] args) {
        DiskClassLoader diskClassLoader = new DiskClassLoader("需要加载的class的地址");
          try {
              //对class文件进行加载
              Class c = diskClassLoader.loadClass("Jobs");
              if (c != null) {
                  try {
                      Object object = c.newInstance();
                      System.err.println(object.getClass().getClassLoader());
                      Method method = c.getDeclaredMethod("say", null);
                      method.invoke(object, null);
                  } catch (IllegalAccessException e) {
                      e.printStackTrace();
                  } catch (InstantiationException e) {
                      e.printStackTrace();
                  } catch (NoSuchMethodException e) {
                      e.printStackTrace();
                  } catch (InvocationTargetException e) {
                      e.printStackTrace();
                  }
              }
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
       }
  }
  ```

  在对应的文件夹下是否已存在Jobs.java文件：

  - ```java
    //存在要加载的Java文件
    sun.misc.Launcher$AppClassLoader@18b4aac2
    自定义加载器加载
    ```

  - ```java
    //不存在对应的Java文件
    DiskClassLoader@d716361
    自定义加载器加载
    ```

​          以上就为自定义ClassLoader的基本步骤，也是热修复框架中ClassLoader的雏形。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关及其拓展（一）-- JVM内存区域</title>
    <url>/2018/04/10/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[# 1. JVM内存区域

{% fullimage /images/jvm/jvm_data.png, JVM运行时数据区,JVM运行时数据区 %}
JVM在执行Java程序的过程中会把管理的内存分为若干个数据局域。
- **程序计数器(Program Counter Register)**：一块较小的内存空间，可看作为**当前线程所执行的字节码的行号指示器**。每条线程都需要一个独立的程序计数器，所以为线程私有区域。`没有规定任何OutOfMemoryError情况的区域`。`线程执行Java方法，则记录正在执行的虚拟机字节码指令地址，若为Native方法，则计数器值则为Undefined`

  

- **Java虚拟机栈(VM Stack)**：虚拟机栈是线程私有的，生命周期与线程相同。描述的是**Java方法执行的内存模型**：每个方法在执行时都会创建一个栈帧用于存储局部变量表(存放编译器可知的各种基本数据类型`boolean,byte,char,int,long,float,double,short`,对象引用和returnAddress类型)，操作树栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。这个区域存在两种异常情况：`StackOverflowError：请求栈深度大于虚拟机所允许的深度`，`OutOfMemoryError：无法申请到足够的内存`

  

- **本地方法栈(Native Method Stack)**：本地方法栈是线程私有的，虚拟机执行Native方法的服务，和虚拟机栈类似存在两个异常情况。

- **Java堆(Heap)**：JVM管理内存中最大的一块。是被所有线程共享的一块区域，在虚拟机启动时创建。唯一目的`存放对象实例`，几乎所有对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为”GC堆”。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，则抛出OutOfMemoryError异常。

- **方法区(Method Area)**：方法区与Java堆一样，是各个线程共享的内存区域。**用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。同Java堆一样会抛出OutOfMemoryError异常。

- **运行时常量池(Runtime Constant Pool)**：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一个是常量池（存放编译器生成的各种字面量和符号引用）。有一个重要特征是具有动态性，运行期也可以将新的常量放入池中。受到方法区内存的限制，也会抛出OutOfMemoryError异常。

- **直接内存(Direct Memory)**：不属于虚拟机运行时数据区的一部分。

> 拓展：
> -  程序计数器，虚拟机栈，本地方法栈随着线程生命周期变化，生则生，死则死。
> -  程序计数器，虚拟机栈，本地方法栈不需要过多考虑内存回收问题，随着方法结束或者线程结束时，内存随着就会回收。
> 堆和栈在操作系统内的区别？
> 都是内存存放数据的地方。具体区别在于：
> - 栈内存：主要用于存放**基本数据类型和局部变量**；在代码块中定义一个变量时，便会在栈中为这个变量分配内存空间，超过变量的作用域后块空间就会被自动释放掉。
> - 堆内存：用于存放**‌运行时创建的对象**，比如通过`new`创建出的对象，需要交由GC来对其进行回收。

简述：JVM的内存区域主要有以下5类：

1. 程序计数器：线程私有，当前线程所执行的字节码的行号指示器
2. 虚拟机栈：线程私有，存放基本数据类型、对象引用和returnAddress类型，会发生内存溢出异常
3. 本地方法栈：线程私有，为JVM中用到的Native方法服务，会发生内存溢出异常
4. Java堆：线程共享，存放对象的实例，也是GC回收管理器的主要区域，会发生内存溢出异常
5. 方法区：线程共享，存储已被JVM加载的类信息、常量、静态变量、即时编译后的代码等数据，会发生内存溢出异常




# 2.HotSpot虚拟机对象创建，布局以及访问
## 对象的创建
   在语言层面上，创建对象只需要一个`new`关键字。
   在虚拟机中，分为以下几步：
- **遇到一条new指令时，先去检查指令对应参数是否在常量池中可以定位到一个符号的引用，并且检查指令的参数是否已被加载、解析和初始化过。若无则需要执行相应的类加载过程。**
- **类加载检查通过后，将为新生对象分配内存。**对象所需的内存大小在类加载完成后便可确定，这块内存由Java堆中划分出来。内存的分配方式由Java堆中内存是否规整决定（`已使用的内存和空闲内存是否相互交错`）。规整则使用 **指针碰撞**（`把指针向空闲空间挪动对象大小的距离`），不规整则使用**空闲列表**（`虚拟机内维护一个列表用来记录内存块中的可用区域，然后找到一块足够大的空间划分给对象实例`）。
- **处理并发安全问题。**除了如何分配内存，还需要考虑虚拟机中对象创建是非常频繁的行为，就会涉及到线程安全。解决这个问题有两种方案：
  - 对分配内存空间的行为进行同步处理
  - 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为`本地线程分配缓存(TLAB)`。哪个线程需要分配内存就在哪个TLAB上分配，只有TLAB用完了，才同步申请另一块内存。
- **内存分配完成后，虚拟机将需要分配到的内存空间都初始化为零值（不包括对象头）。**这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
- **虚拟机对对象进行设置，将`类的元数据信息、对象的哈希码、对象的GC分代年龄信息`存入对象头中。**
- **执行init方法初始化。**从虚拟机角度来说，对象已经产生完成，从Java方面来说才刚刚开始，要等到new指令执行并\<init\>方法执行后，把对象按照意愿初始化后，真正可用的对象生成完毕。

{%fullimage /images/Jvm对象创建过程.png,Jvm对象创建过程,Jvm对象创建过程%}

## 对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：`对象头(Header)`、`实例数据(Instance Data)`和`对齐填充(Padding)`
### 对象头
**存储自身的运行时数据**

| 存储内容 | 标志位 | 状态 |
|---|---|---|
| 对象哈希码、对象分代年龄 | 01 | 未锁定 |
| 指向锁记录的指针 | 00 | 轻量级锁定 |
| 指向重量级锁的指针 | 10 | 膨胀(重量锁) |
| 空，不需要记录信息 | 11 | GC标记 |
| 偏向线程ID，偏向时间戳，对象分代年龄 | 01 | 可偏向 |

**类型指针**
对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象为一个Java数组，则对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。

### 实例数据
里面是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。在分配策略中，相同宽度的字段总是会被分配在一起。
### 对齐填充
并非必然存在的，也没有特别的含义。仅仅起着占位符的作用。当实例数据部分没有对齐时，需要对齐填充来补全。
## 对象的访问
Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式是`句柄访问`和`直接指针访问`。
- 使用句柄访问：Java堆中会划分出一块内存来作为句柄池，`refrence中存储的对象就是对象的句柄地址`，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
	**句柄访问的最大好处是refrence中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，refrence本身不会有修改。**
 {% fullimage /images/jvm/get_object_by_handle.png, alt,流程图 %}
- 使用直接指针访问：Java堆对象需要考虑如何放置访问类型数据的相关信息，而`refrence中存储的直接就是对象地址`。
	**直接访问的最大好处是速度快，节省了一次指针定位的时间开销，在Java HotSpot虚拟机中很常用。**
 {% fullimage /images/jvm/get_object_direct.png, alt,流程图 %}]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC机制</title>
    <url>/2018/12/11/Binder%E5%8F%8AAIDL/</url>
    <content><![CDATA[
# IPC机制

{% fullimage /images/IPC机制.png,IPC机制,IPC机制%}

> IPC是Inter-Process Communication的缩写。含义为进程间通信或者跨进程通信，指代两个进程间进行数据交换的过程、

还需要理解进程以及线程的区别和联系

> 进程：一般指一个执行单元，在设备上一般代指应用程序。
>
> 线程：CPU调度的最小单元且线程是有限资源。
>
> 一个进程可以包含多个线程，即一个应用内部可以执行多个任务。在Android中就会区分为`主线程(UI线程)`和`子线程`，一般会在子线程上做耗时操作，主线程不可。

由于IPC的使用场景是在多进程模式下。多进程的使用情况主要分为两种：`一个应用因为某些原因需要采用多进程模式来实现，比如获取更大内存空间`,`当前应用需要向其他应用来获取数据`。

## 1.  多进程模式

   1. 开启多进程模式

      - 通过JNI在native层fork一个新的进程
      - 在`AndroidManifest.xml`中给四大组件指定属性`android:process`。

   2. 进程名的命名

      ```xml
      <activity 
                android:name="com.wxy.test.AActivity"
                android:process=":remote"/>
      <activity
                android:name="com.wxy.text.BActivity"
                android:process="com.wxy.test.remote"/>
      ```

      上述代码为两种命名方案

      - 省略包名以:开头：代指进程名为`com.wxy.test:remote`为**私有进程**，其他应用的组件不可以和他跑到同一个进程中
      - 完整命名：如上述`com.wxy.test.remote`为**全局进程**，其他应用可以通过`ShareUID方式与他在同一进程中运行。`

      Android系统会为每一个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。

      上述通过ShareUID将两个应用跑在同一个进程间是有要求的，**必须是两个应用具有相同的ShareUID且签名相同才可以**。达成上述要求时就可以 **共享两者间的data目录、组件信息以及内存数据**。

      拓展知识：当两者签名不同时，会触发安装错误[INSTALL_FAILED_SHARED_USER_INCOMPATIBLE]

   3. 查看进程信息

      `adb shell ps|grep $packageName`

   4. 运行机制

      Android为每一个应用分配了一个独立的虚拟机，或者说为了每一个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上就会有不同的地址空间，就会导致不同的虚拟机访问同一个类的对象会产生多分副本。

      **所有运行在不同进程的四大组件，只要他们通过内存共享数据，就会共享失败。**

   5. 多进程的优点

      - Android系统对每个应用占用内存是有限制的，占用内存越大越容易被杀死。可以提出组件运行于单独的进程中，减少主进程占用内存，降低被杀死几率。
      - 子进程如果因为某种原因崩溃不会影响到主进程的使用。
      - 独立进程的启动与退出不依赖于用户的使用，可以完全独立的控制，不会因为主进程的退出而结束。

   6. 多进程造成的问题

      - 静态成员变量和单例模式完全失效
      - 线程同步机制失败
      - SharedPreferences的可靠性下降 `不支持多进程读写`
      - Application会多次创建`分配了独立的虚拟机`

   一个应用内的多进程：**相当于两个不同的应用采用了ShareUId模式**。虽说不能直接共享内存数据，但是可以通过跨进程通信来实现数据交互。

## 2. 序列化

>  当我们需要跨进程通信时，传递的数据就需要进行序列化传递，然后接受方在反序列化得到传递数据

   > 什么是序列化？
   >
   > 将对象转化为可以传输的二进制流的过程，就可以通过序列化，转化为可以在网络传输或者保存到本地的流，从而进行传输数据。反序列化即为从二进制流转化为对象的过程。
   >
   > 也为了解决对象的持久化问题。当你在程序中声明一个类后，程序关闭则释放对象，持久化就是为了应用关闭后类的内容依然存在。

   1. `Serializable`

      > 由Java提供的一个序列化接口，为对象提供标准的序列化以及反序列化操作。

      使用方式相当简单

      ```java
      public class User implements Serializable{
          //该参数是用来辅助序列化以及反序列化的过程，原则上该值相同才可以进行序列化以及反序列化的操作.
          //不指定时 系统也会自动生成 但是容易因为变量的数量和类型发生改变而导致序列化失败。
          private static final long serialVersionUID = 123123L;
          
          public String name;
          ...
      } 
      ```

      优缺点：使用简单但是效率较低，在序列化(ObjectOutputStream)以及反序列化(ObjectInputStream)类调用中会有大量的I/O操作。

      适用场景：将对象类序列化存储到设备或者需要网络传输。

   2. `Parcelable`

      > Android提供的序列化接口，使用起来较为繁琐

      ```java
      import android.os.Parcel;
      import android.os.Parcelable;
      
      public class User implements Parcelable {
      
          public String name;
      
          protected User(Parcel in) {
              name = in.readString();
          }
      
          public static final Creator<User> CREATOR = new Creator<User>() {
              @Override
              public User createFromParcel(Parcel in) {
                  return new User(in);
              }
      
              @Override
              public User[] newArray(int size) {
                  return new User[size];
              }
          };
      
          @Override
          public int describeContents() {
              return 0;
          }
      
          @Override
          public void writeToParcel(Parcel dest, int flags) {
              dest.writeString(name);
          }
      }
      ```

      序列化功能由`writeToParcel`实现，反序列化由`Parcel的read`实现。

      优缺点：传递效率高效使用较为繁琐，主要序列化都在内存上进行。由于Parcelabel是Android提供的方法，可能会由于版本更新而会有些许改动。

      适用场景：在内存的序列化中使用。

## 3. IPC方式

> 本节主要讲述各种跨进程通信方式，目前有以下六种：
>
> {% fullimage /images/IPC-mode.png,IPC方式, IPC方式 %}
>
> 上述方式实际都是通过Binder来实现的

### 1.Bundle

> 支持在`Activity、Service和Receiver`之间通过Intent来传递Bundle数据(调用`intent.putExtra()`)，由于Bundle实现了Parcelable接口，所以可以方便的在不同进程间传递(`传输的数据必须可以被序列化，不然无法进行传递`)。可以看做为一个特殊的Map类型。
>
> **最简单的进程间通信方式。**

拓展：当A进程计算后的结果无法通过Bundle传递至B进程时，可以将计算的过程用B进程的一个Service进行操作，然后在回调给B进程。

> 为什么Bundle不直接使用HashMap呢？
>
> 1. Bundle内部是由ArrayMap实现的，ArrayMap实质内部为两个数组，一个是`int[]`用于保存每个item的`hashCode`，另一个`Object[]`用于保存`key/value`键值对，容量为上一个数组的2倍。在添加、查找数据时，只要用二分查找法找到对应位置进行操作即可。占用内存也会小于`HashMap`。
> 2. 在Android中如果需要使用Intent传递数据的话，需要的数据类型必须为`基本类型`或`可序列化类型`，`HashMap`采用`Serializable`进行序列化，`Bundle`采用了`Paracelable`进行序列化，更加适合于Android平台，在内存中完成序列化功能，开销更小。

### 2.文件共享

> **两个进程间通过读/写一个文件来进行数据传递**，适用于对数据同步要求不高的进程间通信，并且需要对**并发读/写**进行妥善处理

拓展：Android中的SharedPreferences也是文件共享方案的一种，但由于系统提供了一种缓存策略(内存中会有一份该文件的缓存)，导致它在多进程模式下，读/写并不可靠，甚至丢失数据。

### 3.Messenger

> 轻量级的IPC方案，可以在不同的进程间传递Message对象。调用`Messenger.send(Message message)`传递Message对象。
>
> Messager的底层实现是`AIDL`。它对AIDL做了封装，由于它一次只可以处理一个请求**（串行请求）**，因此不需考虑线程同步的问题。不过不能直接调用服务端的方法，只能通过传递消息处理。
>
> 由于主要传递的都是Message对象，导致无法实现远程调用。

Messenger的构造函数分以下两种：

 ```java
 public Messenger(IBinder target){
     mTarget = IMessenger.Stub.asInterface(target);
 }
 
 public Messenger(Handler target){
     mTarget = target.getImessenger();
 }
 ```
>
> 拓展：**Handler主要用于线程间通信，Messenger用于进程间通信**

实现一个Messenger需要以下两步：

- **服务端进程**：

  ①创建一个Service来处理客户端的连接请求

  ②创建一个Handler并由他构造一个Messenger对象

  ③然后在Service的onBind方法中返回该Messenger对象中的Binder。

  代码示例：

  ```java
  //MessengerServcice.java
  public class MessengerService extends Service {
      private static class MessengerHanler extends Handler {
          @Override
          public void handleMessage(Message msg) {
             //处理返回的Message消息
              ...
                  //获取Client返回的Messenger对象
                      Messenger client = msg.replyTo;
                      if (client != null) {
                          //拼接数据 发送消息
                      }
              
          }
      }
      //通过Handler构造一个Messenger对象
      private final Messenger mMessenger = new Messenger(new MessengerHanler());
     
      @Override
      public IBinder onBind(Intent intent) {
          //返回IBinder对象 将消息交由对应Handler处理
          return mMessenger.getBinder();
      }
  }
  ```

- **客户端进程**：

  ①绑定服务端Service --`bindService`

  ②绑定后使用Service返回的IBinder对象创建一个Messenger对象

  ③通过Messenger对象向服务端发送Message  **完成单向通信**

  ④创建一个Handler由此创建一个Messenger对象，然后将Messenger对象放入Message的**replyTo**字段传递给Server。  **完成双向通信**

  代码示例：

  ```java
  public class MessengerActivity extends Activity {
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_messenger);
          Intent intent = new Intent(this, MessengerService.class);
          bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
      }
  
      private Messenger mService;
      private ServiceConnection mConnection = new ServiceConnection() {
          @Override
          public void onServiceConnected(ComponentName name, IBinder service) {
              mService = new Messenger(service);
              Message msg = Message.obtain(null, 1);
              Bundle data = new Bundle();
              data.putString("msg", "it is from client");
              msg.setData(data);
              //若存在则形成了双向通信
              msg.replyTo = mGetReplyMessenger;
              try {
                  mService.send(msg);
              } catch (RemoteException e) {
                  e.printStackTrace();
              }
          }
  
          @Override
          public void onServiceDisconnected(ComponentName name) {
  
          }
      };
  
      private Messenger mGetReplyMessenger = new Messenger(new MessengerHanler());
      private static class MessengerHanler extends Handler {
          @Override
          public void handleMessage(Message msg) {
             //处理消息
          }
      }
  
      @Override
      protected void onDestroy() {
          //取消绑定service
          unbindService(mConnection);
          super.onDestroy();
      }
  }
  ```

Messenger的工作原理：

{% fullimage /images/Messenger-principle.png,Messenger工作原理,Messenger工作原理 %}

### 4.AIDL

{% post_link Binder系列-Binder%}

### 5.ContentProvider

> ContentProvider是专门用于不同应用间进行数据共享的方式，底层同样是由Binder实现。**主要是提供了一个统一的接口为了存储和获取数据。**

[ContentProvide](https://www.jianshu.com/p/9048b47bb267)

### 6.Socket

> Socket也称为"套接字"，是网络通信中的概念，分为流式套接字(`基于TCP协议，采用流的方式提供可靠的字节流服务`)和用户数据报套接字（`基于UDP协议，采用数据报文提供数据打包发送的服务`）两种。**Socket不仅可以跨进程通信还可以跨设备通信。**

`TCP协议是面向连接的协议，提供稳定的双向通信功能，因为连接的建立需要经过'三次握手'才能完成，由于本身提供了超时重传机制，因此具有很高的稳定性。`

`UDP是无连接的，提供不稳定的单向通信功能，在性能上拥有良好的效率，但数据不一定能够有效传输。`

1. 实现方法：

   服务端：

   - 创建一个Service，在线程中建立TCP服务，监听相应的端口等待客户端连接请求
   - 与客户端连接时，会生成新的Socket对象，利用它可与客户端进行数据传输
   - 断开连接时，关闭相应的socket并结束线程

   客户端：

   - 开启一个线程，通过Socket发起连接请求
   - 连接成功后，读取服务端消息
   - 断开连接，关闭Socket

2. 注意事项：

   - 需要声明网络权限



以上6种IPC方式比较：

| 名称            | 优点                                                         | 缺点                                                | 适用场景                                                   |
| --------------- | ------------------------------------------------------------ | --------------------------------------------------- | ---------------------------------------------------------- |
| Bundle          | 简单易用                                                     | 只能传输Bundle支持的数据类型                        | 四大组件的进程间通信                                       |
| 文件共享        | 简单易用                                                     | 不适合高并发场景，且无法做到实时通信                | 无并发访问情形，数据简单且实时性不高                       |
| AIDL            | 功能强大，支持一对多并发通信，支持实时通信                   | 使用稍复杂，需要处理好线程同步                      | 一对多通信且支持远程调用                                   |
| Messenger       | 功能强大，支持一对多串行通信，支持实时通信                   | 不能很好处理高并发场景，数据只能通过Message进行传输 | 低并发的一对多即时通信，并且不需要返回结果，不需要远程调用 |
| ContentProvider | 在数据访问方面功能强大，支持一对多数据共享，可通过Call方法扩展其他操作 | 受约束的AIDL实现，主要提供对数据的CRUD操作          | 一对多的进程间数据共享                                     |
| Socket          | 功能强大，可以通过网络传输字节流，支持一对多并发通信         | 实现细节稍微麻烦                                    | 网络数据交换                                               |
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识</title>
    <url>/2018/01/17/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[
<!--Java多态，重载和重写，分别应用场景，多态的原理-->

<!--内部类为什么可以访问外部类变量-->

<!--构造方法，代码块，静态代码块，静态变量，非静态变量在父子类中的加载顺序-->

<!--软引用当内存不足是一定能回收吗？-->

<!--javafinal-->

<!---->

> 如何理解Java的多态？其中，重载和重写有什么区别？

多态是同一个行为具有多个不同表现形式或形态的能力，多态是同一个接口，使用不同的实例而执行不同操作。多态就是程序运行期才确定，一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法。

多态存在的三个必要条件是：`继承，重写，向上转型(需要将子类的引用赋值给父类对象，只有这样该引用才能具备调用父类的方法和子类的方法)`。

多态的三个实现方式：`重写、接口、抽象类和抽象方法`。

继承链中对象方法的调用优先级：

```java 
this.show(O) -> super.show(o) -> this.show((super)O) -> super.show((super)O) 
  
当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，
引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。
```

| 区别点   | 重载 Oberload | 重写 Override                                  |
| -------- | ------------- | ---------------------------------------------- |
| 参数类型 | 必须修改      | 不能修改                                       |
| 返回类型 | 可以修改      | 不能修改                                       |
| 异常     | 可以修改      | 可以减少或删除，一定不能抛出新的或者更广的异常 |
| 访问     | 可以修改      | 一定不能做严格的限制                           |

> 面向对象编程四大特性及含义

- 抽象：对现实世界的事物进行概括
- 封装：将某事物的属性和行为包装到对象中，构成一个不可分割的实体，数据被保护在抽象数据类型的内部。只保留一些借口使之与外部发生联系。
- 继承：子类继承父类，不仅可以有父类原有的方法和属性，也可以增加自己或者重写父类的方法及属性。
- 多态：允许不同类的对象对同一消息作出的各自响应。

> Object的`equals()`和`==`的区别

`equals()`：Object的公有方法，默认情况下是**引用比较**，不过有些类对其进行了重写，大部分是进行**值比较**。

`==`：针对不同的类型，会有不同的比较方式

- 基本类型：比较值是否相同
- 引用类型：比较引用是否相同即内存地址是否相同

> ]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关及其拓展(七) — 线程安全与锁优化</title>
    <url>/2018/12/19/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%83/</url>
    <content><![CDATA[
# 线程安全与锁优化

> 首先需要并发的正确性，然后在此基础上实现高效。

## 线程安全

> 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。

线程安全的代码必须具备一个特征：**代码本身封装了所有必要的正确保障性手段，令调用者无需关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。**

线程安全的“安全程度”由强至弱分为以下5类：

- ### 不可变

  > 只要一个不可变的对象被正确的构建出来，那其外部的可见状态永远不会改变
  >
  > `不发生 this引用逃逸 情况下成立 -- 在构造函数返回之前，其他线程已经取得了该对象的引用。`

  实现方案：

  - 如果共享数据是一个`基本数据类型`，只要在定义时用`final`修饰
  - 如果共享数据是一个`对象`，最简单的就是 吧对象中带有状态的变量都声明为final

  符合不可变要求的类型：`String、枚举类(Enum)、Long，Double以及BigInteger等大数据类型`

- ### 绝对线程安全

  > 完全满足线程安全的定义，即达到"不管运行环境如何，调用者都不需要任何额外的同步措施。"

- ### 相对线程安全

  > 保证对这个对象单独的操作是线程安全的，调用时不需做额外的保障措施，但是对于一些特定顺序的连续调用，就需要在调用端使用额外的同步手段保证调用的正确性。

  大部分的线程安全类都属于这种类型，例如`Vector,HashTable,synchronizedCollection()`

- ### 线程兼容

  > 对象本身并非线程安全，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全的使用。

  例如`ArrayList,HashMap`

- ### 线程对立

  > 无论调用端是否采取了同步措施，都无法在多线程环境中并发使用。**应当尽量避免**

  例如`Thread中的suspend()和resume()`。

## 线程安全的实现方法

> ①通过代码实现线程安全 ②通过虚拟机本身实现同步与锁

### 互斥同步 (阻塞同步) 

> **同步**：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只能被一个线程使用。
>
> **互斥**：实现同步的一种手段，`临界区、互斥量和信号量都是主要的互斥实现方法`

**互斥是因，同步是果；互斥是方法，同步是目的**

**互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），就会出现问题，无论共享数据是否真的会出现数据竞争，都要进行加锁。**

实现手段：

- **synchronized**

  {% post_link synchorized关键字分析 %}

- **ReentrantLock**

  {% post_link ReenTrantLock关键字分析 %}

`synchronized`和`ReentrantLock`的异同：

- 两者都是**可重入锁**  <!--自己实现一个可重入锁-->

  > **可重入锁**：当一个线程得到一个对象锁后，再次请求该对象锁时是可以再次得到该对象锁的。**自己可以再次获得自己的内部锁。**

- `synchronized`依赖于JVM而`ReentrantLock`依赖于API

  `synchronized`底层用**Mutex(互斥量)**实现，`ReentrantLock`继承自`Lock接口`,Lock接口又依赖于AQS实现

- `synchronized`的锁状态无法在代码中判断，`ReentrantLock`通过`isLocked()`判断

- `synchronized`非公平锁，另一个可以是公平也可以是非公平的

- `synchronized`不可被中断，另一个调用`lockInterrupbity()`即可中断

- `ReentrantLock`可以提高多个线程的读操作的效率

### 非阻塞同步

> 基于冲突检测的乐观并发策略，即先进行操作，若无其他线程争用共享数据，操作成功；反之，产生了冲突再去采用其他的补偿措施（**最常见自旋——不停重试，直到成功为止**）。

为了保证**操作和冲突检测**具备原子性，需要用到硬件指令集，比如：

- 测试并设置
- 获取并增加
- 交换
- ***比较并交换(CAS)***
- 加载链接/条件存储

{% post_link Atomic原子操作类分析%}

### 无同步方案

> 不用同步的方式保证线程安全，因为有些天生就是安全的。

有以下两类：

- #### 可重入代码/纯代码(Reentrant Code/Pure Code)

  > 在代码执行的时候在任何时刻去中断，再去执行另外的代码，在控制权返回后，原来的程序不会出现任何的错误。

  **可重入性是它的基本特征，满足可重入性的代码一定是线程安全的，反之，满足线程安全的代码不一定是可重入的。**

  共同特征：不依赖存储在堆上的数据和公用的系统资源、用到的状态栏都由参数中传入、不调用非可重入的方法等

  判定依据：**返回结果是可预测的，只要是输入了相同的数据就能返回相同的结果，就满足可重入性的要求。**

- #### 线程本地存储(Thread Local Storage)

  > 把共享数据的可见范围限制在同一个进程之内，无须同步也可以保证线程之间不出现数据争用的情况。

  使用`ThreadLocal`类可实现本地存储的功能。


## 锁优化

> 锁优化是为了在线程之间更高效的共享数据，以及解决竞争性问题。
>
> 锁的状态共分为4种：**无锁状态、偏向锁、轻量级锁和重量级锁**。锁随着竞争情况可以升级，**但升级后不能降级**。
>
> `无锁状态->偏向锁->轻量级锁->重量级锁`

### 1. 自旋锁与适应性自旋

互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，影响系统的并发性能。同时，共享数据的锁定状态只会持续很短的一段时间，不值得去挂起和恢复线程。

**自旋锁**：若物理机器有一个以上的处理器，能使多个线程同时并行执行，让后面的请求锁线程(通过自旋——**CPU忙循环执行空指令**)等待，但不放弃处理器的执行时间，看看持有锁的线程是否很快释放锁。

`自旋等待不能代替阻塞，虽然避开了线程切换的开销，但要占用处理器时间，因此自旋等待必须有一定的上限，若超过了次数没有成功，就需要去挂起线程。`

**自适应自旋锁**：自旋时间不固定，由该锁上次的自旋时间及锁的拥有者状态决定。

- 对于某个锁，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，JVM就会认为这次自旋也会再次成功获得锁，进而允许等待持续相对更长的时间
- 对于某个所，自选很少成功获得锁，以后再获取这个锁时可能忽略自旋过程，以避免浪费处理器资源。

### 2. 锁消除

> JVM即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为他们是线程私有的，同步加锁操作自然就无须进行。

例如`StringBuffer`对象的连续`append()`



### 3. 锁粗化

> JVM探测到一串零碎的操作都对同一对象进行加锁，将会把加锁同步的范围扩展（**粗化**）到整个操作序列的外代码

### 4. 轻量级锁

> 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。**轻量级锁并不是用来代替重量级锁的**

必须先了解 HotSpot虚拟机的对象(**对象头部分**)的内存布局：分为两部分

- ***Mark Word***：存储自身的运行时数据，如：`HashCode、GC分代年龄和锁信息`，这部分数据的长度在32和64位中的JVM中分别为32bit和64bit。**它是实现轻量级锁和偏向锁的关键。**
- 存储指向方法区对象类型数据的指针，如果是数组对象的话，额外会存储数据的长度。

{% fullimage /images/MarkWord.png,Mark Word,Mark Word %}

> 加锁过程

代码进入同步块时，如果同步对象未锁定(标记位为`01`)，虚拟机会在当前线程的栈帧中建立一个`锁记录(Lock Record)`的空间，用于存储对象目前的`Mark Word`拷贝（**Displaced Mark Word**）。

然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。

- 更新成功，那么当前线程拥有了该对象的锁，且对象Mark Word的锁标志位为`00` ，处于轻量级锁定状态。
- 更新失败，JVM首先会检查对象的Mark Word是否指向当前线程的栈帧
  - 已指向表明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行
  - 没指向表明该对象已被其他线程抢占。

**如果有两条以上的线程竞争同一个锁，轻量级锁就无法使用，需要膨胀为重量级锁，Mark Word的锁标志位变为`10`,存储的是指向重量级的指针，后面等待锁的也会进入阻塞状态。**

> 解锁过程

若对象的Mark Word仍然指向线程的Lock Record，那就用CAS操作把对象当前的Mark Word和Displaced Mark Word替换回来

- 替换成功，就完成了整个同步过程
- 替换失败，说明有其他线程尝试获取锁，就要在释放锁的同时，唤醒被挂起的线程

> `栈帧`：用于支持虚拟西进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址信息。第一个方法从调用开始到执行完成，就是一个栈帧从入栈到出栈的过程。

### 5. 偏向锁

> 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。**提高一个对象在很长一段时间内都只被一个线程用做锁对象场景下的性能。**
>
> *偏向锁可以提高带有同步但无竞争的程序性能。*

这个锁会偏向于第一个获得它的线程，如果后续该锁没有被其他线程获取，则持有偏向锁的线程将永远不会进行同步。

> 加锁过程

JVM启用了`偏向锁`模式，当锁对象第一次被线程获取的时候，JVM会把锁标记位置为`01`,即偏向模式。使用CAS操作记录锁的线程ID到Mark Word中。

- CAS操作成功。持有偏向锁的线程在每次进入和退出同步块是，只要比较一下Mark Word存储的线程ID是否相同。
  - 相同代表线程已经获得了锁，不需要再用CAS操作加锁和解锁
  - 不同，就需要CAS操作竞争锁，竞争成功，替换Mark Word中的ThreadID为当前竞争线程的ID

> 解锁过程

当有另一个线程去尝试获取偏向锁时，CAS替换ThreadID失败，就要撤销偏向锁。(撤销偏向锁，需要等待原持有偏向锁的线程到达全局安全点`所有线程都是暂停的，没有字节码正在执行`，暂停线程，并检查状态)。判断原持有偏向锁的线程是否处于活动状态

- 无活动则置为无锁状态(锁标志为`01`，是否偏向锁状态`0`)
- 还处于活动状态，则升级为轻量锁(标志位为`00`)

> 关闭偏向锁模式

使用JVM参数 `-XX:BlasedLockingStartupDelay=0`可以关闭延迟，因为偏向锁需要应用启动后过几秒激活

`-XX:UseBlasedLocking=false`关闭偏向锁

三种锁的升级

{% fullimage /images/lock-upgrade.png,锁的升级，锁的升级%}

三种锁的比较

|    锁    | 优点                                                         | 缺点                                          |              适用场景              |
| :------: | ------------------------------------------------------------ | --------------------------------------------- | :--------------------------------: |
|  偏向锁  | 加锁和解锁不需要额外的消耗，与执行非同步方法相比仅存在纳秒级的差距 | 线程间存在锁竞争，需要带来额外锁撤销的消耗    |     只有一个线程访问同步块场景     |
| 轻量级锁 | 竞争的线程不会阻塞，提高程序的相应速度                       | 始终得不到锁竞争的线程，会使用自旋消耗CPU资源 | 追求相应时间，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                        |   追求吞吐量，同步块执行时间较长   |

> **重量级锁**：本质上是依赖操作系统的`Mutex Lock`互斥量来实现同步操作。由于线程间的切换需要从用户态转向核心态，转换成本较高，耗时相对较长。

*一个线程如何判断自己是否取得锁？*

> 线程在获取锁之前会判断对象的`Mark Word`中是否存放自己的`threadId`，存放且相同则重入；不同，则使用CAS进行切换，锁升级为`轻量级锁`，释放偏向锁，清空`Mark Word`，线程开始竞争，竞争成功的就存入自己的`ThreadId`，失败的开始自旋。
>
> 调用`Thread.holdsLock()`

## 其他锁类型及其概念

### 1.乐观锁

> 由于在进程挂起和恢复执行过程中需要很大的开销进行切换。所以有了乐观锁概念。
>
> 每次去拿数据的时候都认为别人不会修改，但在更新的时候会去判断在此期间是否数据发生修改，没有被修改则进行数据更新。如果因为修改过产生冲突就失败就重试到成功为止(**自旋**)。

实例：例如`Atomic原子类`

使用场景：适合读取操作比较频繁的场景

### 2.悲观锁

> 每次获取数据的时候，担心数据被修改，所以每次都要加锁，确保操作过程中数据不会发生改变，操作完成后再解锁让其他线程操作。
>
> 在某个资源不可用的时候，就将CPU让出，把当前等待的线程切换为阻塞状态。等到资源可用，将阻塞线程唤醒，进入Runnable状态等待CPU调度。

实例：例如`synchronized` 

使用场景：比较适合写入操作频繁的场景

### 3.互斥锁

> 通过`排他性`，同时只允许一个访问者对其进行访问来保证资源的有效同步，但无法限制线程对该资源的访问顺序

### 4.**死锁**

> 两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，他们都将无法推进下去。

死锁形成必须要求四个条件：

- **互斥条件**：一个资源每次只能被一个线程使用

- **请求与保持条件**：一个线程引请求资源而阻塞时，对已获得的资源保持不放
- **不剥夺条件**：线程已获得的资源，在未使用完之前，不能强行剥夺
- **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系

常见死锁类型：

- **静态的锁顺序死锁** `所有需要多个锁的线程，都要以相同的顺序获得锁`

  ```java
  class DeadLockTest{
      private final Object lockA = new Object();
      private final Object lockB = new Object();
      public void a(){
          synchronized(lockA){
              synchronized(lockB){
                  System.out.println("func A")
              }
          }
      }
      
      public void b(){
          synchronized(lockB){
              synchronized(lockA){
                  System.out.println("func b")
              }
          }
      }
  }
  ```

- **动态的锁顺序死锁** `自定义锁的顺序，确保所有线程以相同的顺序获得锁`

- **协作对象之间发生的死锁** `避免在持有锁的情况下调用外部的方法`

死锁预防：

- 以确定的顺序获得锁

  将所有的锁都按照特定顺序进行获取，防止死锁发生。

  > **银行家算法**：允许进程动态的申请资源，但在系统进行资源分配之前，先计算此次资源分配的安全性，若分配不会导致进入不安全状态，则分配；否则等待。

- 超时放弃

  > 例如`synchronized`只要线程没有获得锁，就会永远等待下去，`Lock`提供了`tryLock()`可以实现超时放弃]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity,Window,View的关联与理解</title>
    <url>/2018/04/01/Activity-Window-View%E7%9A%84%E5%85%B3%E8%81%94%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[# Activity,Window,View相关

{% fullimage /images/ActivityWindowView的联系.png,Activity&Window&View,Activity&Window&View%}

## 1. 什么是Activity,Window,View以及职能简介
- Activity：不负责视图控制，只是控制生命周期和处理事件，真正控制视图的是Window，一个Activity包含一个Window，Window真正代表一个窗口。`Activity是一个控制器，控制视图的添加与显示以及通过回调方法来进行Window与View的交互。`
- Window：Window是视图的承载器，内部持有一个DecorView，DecorView才是view的根布局，Window为抽象类，实际是Activity中的其子类PhoneWindow，其中有个内部类DecorView，通过创建DecorView来加载`R.layout.*`，Window通过WindowManager加载DecorView，并将DecorView和ViewRoot关联，进行视图控制与交互。
- View：DecorView继承自FrameLayout,DecorView作为顶级View，一般其内部包含一个竖直方向的LinearLayout，里面包含ViewStub，标题栏（titleView），内容栏（contentView）。Activity通过`setContentView()`将布局文件加载进内容栏中。
- ViewRoot：ViewRoot的实现类是ViewRootImpl，是WindowService和DecorView之间的纽带。ViewRoot不属于View节点，和View之间没有直接联系，不过实现了ViewParent接口。
{% fullimage /images/study_plan/activity_window_view.png, alt,流程图 %}

## 2. Activity如何和Window，View关联（附源码）
### Activity和Window关联

{% post_link Activity启动过程%}

在此简述下Activity的启动过程：

- 调用`ContextImpl.startActivity()`实质调用`ContextImpl.startActivityForResult()`
- 执行到`performLaunchActivity()`在其中完成启动流程
- 通过`Instrumentation.newActivity`使用类加载器创建Activity对象
- 通过`LoadedApk.makeApplication()`尝试创建Application对象(*Application已被创建则跳过*)
- 创建`ContextImpl`对象，并执行`Activity.attach()`完成一些重要数据的初始化
- 最终调用`Activity.onCreate()`完成启动流程。

其中`Activity和Window的关联`发生在`Activity.attach()`中

```java
 final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window, ActivityConfigCallback activityConfigCallback) {
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);
        //进行了PhoneWindow的初始化并进行关联
        mWindow = new PhoneWindow(this, window, activityConfigCallback);
        mWindow.setWindowControllerCallback(this);
        mWindow.setCallback(this);
        mWindow.setOnWindowDismissedCallback(this);
        mWindow.getLayoutInflater().setPrivateFactory(this);
        ...
 }
```

其中`PhoneWindow`就是Activity的根Window，可以在其上添加其他的Window(*例如Dialog*)，`PhoneWindow`就是`Activity`与`View`之间的桥梁，Activity无法直接操作View。

### Window和View关联

Activity无法直接和View交互，需要通过Window管理

```java
    public void setContentView(@LayoutRes int layoutResID) {
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
    }

    public Window getWindow() {
        return mWindow;
    }
```

Activity通过`setContentView()`加载要显示的布局，观察源码可知还是通过`Window`进行了加载操作。

### 加载View

```java
 @Override
 public void setContentView(int layoutResID) {
        if (mContentParent == null) {
            installDecor();
        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            mContentParent.removeAllViews();
        }

        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                    getContext());
            transitionTo(newScene);
        } else {
            mLayoutInflater.inflate(layoutResID, mContentParent);
        }
        mContentParent.requestApplyInsets();
        final Callback cb = getCallback();
        if (cb != null && !isDestroyed()) {
            cb.onContentChanged();
        }
        mContentParentExplicitlySet = true;
    }

private void installDecor() {
    if (mDecor == null) {
        mDecor = generateDecor(); //生成DecorView
        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
        mDecor.setIsRootNamespace(true);
        if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {
            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
        }
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor); // 为DecorView设置布局格式，并返回mContentParent
        ...
        } 
    }
}

    protected DecorView generateDecor(int featureId) {
        Context context;
        if (mUseDecorContext) {
            Context applicationContext = getContext().getApplicationContext();
            if (applicationContext == null) {
                context = getContext();
            } else {
                context = new DecorContext(applicationContext, getContext().getResources());
                if (mTheme != -1) {
                    context.setTheme(mTheme);
                }
            }
        } else {
            context = getContext();
        }
        return new DecorView(context, featureId, this, getAttributes());
    }
```

Activity通过`setContentView()`调用到`PhoneWindow.setContentView()`执行DecorView的创建流程。

> `DecorView`直接和`PhoneWindow`进行关联，其内部包含了我们定义的布局(*ContentView*)以及一个`titlebar`。

### 显示View

上述方法只是创建了一个`DecorView`，而没有执行显示流程。这就涉及到了`Activity的生命周期`，其中有讲到在`onResume()`才对用户可见。

{% post_link View的工作原理 %}



**View需要通过Window才能展示在Activity上。**

## 3.总结

> Activity就像个控制器，不负责视图部分；
>
> Window像个承载器，装着内部视图；
>
> DecorView就是个顶层视图，是所有View的最外层布局；
>
> ViewRoot就是个连接器，负责沟通，是WindowManager和View之间的桥梁。



Activity包含了一个PhoneWindow，而PhoneWindow就是继承于Window的，Activity通过`setContentView`将View设置到了PhoneWindow上，而View通过WindowManager的`addView()、removeView()、updateViewLayout()`对View进行管理。Window的添加过程以及Activity的启动流程都是一次IPC的过程。Activity的启动需要通过AMS完成；Window的添加过程需要通过WindowSession完成。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关及其拓展(八) — 静态分派&amp;动态分派</title>
    <url>/2019/02/21/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%85%AB/</url>
    <content><![CDATA[


## 方法调用

方法调用不同于方法执行，方法调用阶段唯一的任务就是**确定被调用方法的版本(即调用哪一个方法)**。

## 解析

> 调用目标在代码程序写好、编译器进行编译时就必须确定下来。

在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括`静态方法`和`私有方法`两大类。前者与类型直接关联，后者在外部不可访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。

在解析阶段中可以唯一确定的调用版本，符合这个条件的有`静态方法、私有方法、实例构造器，父类方法`四种。


## 分派
Java具备面向对象的3个特性：**继承、封装和多态**。分派就体现了*多态*这一特征。

{% fullimage /images/方法分派.png,方法分派,方法分派%}

### 变量的静态&动态类型

```java
public class Test{
    static abstract class Human{
        
    }
    
    static class Man extends Human{
        
    }
    
    static class Woman extends Human{
        
    }
    public static void main(String[] args){
        Human man = new Human();
    }
}
```

在`Human man =  new Man()`中，`Human`对应的变量的静态类型——**(引用类型)不会被改变，在编译期可知**。`Man`对应着变量的动态类型——**(实例对象类型)会发生变化，在运行期才可以确定**。

### 静态分派

> **根据变量的静态类型来定位方法执行版本的分派动作**。静态分派发送在编译阶段，因此确定静态分派的动作实际上是不由虚拟机来执行的。

#### 应用场景

方法重载(`Overload`)

#### 实例说明

```java
public class TestStatic {
    static abstract class Human{}
    static  class Man extends Human{}
    static  class Woman extends Human{}

    public void sayHello(Human human){
        System.err.println("hello human");
    }
    public void sayHello(Man man){
        System.err.println("hello man");
    }
    public void sayHello(Woman woman){
        System.err.println("hello woman");
    }
    public static void main(String[] args){
        Human man = new Man() ;
        Man man1 = new Man();
        Woman woman = new Woman();
        Human human = new Woman();

        TestStatic testStatic = new TestStatic();
        testStatic.sayHello(man);
        testStatic.sayHello(man1);
        testStatic.sayHello(woman);
        testStatic.sayHello(human);
    }
}
```

得到的最终结果是：

```java
hello human
hello man
hello woman
hello human
```

观察发现，最终得到的结果是根据变量的`静态类型`最终得出的。这是由于*编译器虽然能确定方法的重载版本，但是很多情况下重载方法并不唯一，最终仍需确认一个合适的版本，就选用到了 变量的静态类型作为 实际参数。*

#### 注意事项

##### 变量的静态类型发生变化

> 通过`强制类型转换`改变变量的静态类型

```Java
Human man = new Man()
   
test.sayHello((Man)man)
```

得到的最终结果就会变为`hello man`。

##### 匹配优先级

> 当程序中没有显示指定变量的静态类型时，程序需要根据`静态类型的优先级`确定`优先的静态类型`进行方法分配。

### 动态分派

> **根据变量的动态类型进行方法分派**。动态分派发生在运行阶段。

#### 应用场景

方法重写(`Override`)

#### 实例说明

```java
class Human{
    public void sayHello(){
        System.out.println("hello human");
    }
}

class Man extends Human {
    @Override
    public void sayHello() {
        System.err.println("hello man");
    }
}

class Woman extends Human {
    @Override
    public void sayHello() {
        System.err.println("hello woman");
    }
}

public class Test{
    public static void main(String[] args){
        Human man = new Man();
        man.sayHello();
        
        Human human = new Human();
        human.sayHello();
        
        Woman woman = new Woman();
        woman.sayHello();
    }
}
```

运行结果：

```java
hello man
hello human
hello woman
```

观察发现，最终得出的结果是根据变量的`动态类型`最终得出的。利用`invokevirtual`指令来执行动态分派。执行步骤分为两步：

1. 确定接受者的动态类型
2. 将 常量池中的 类方法符号引用 解析到不同的直接引用上。

]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关及其拓展(四) -- 垃圾收集器与内存分配策略</title>
    <url>/2018/05/04/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%9B%9B/</url>
    <content><![CDATA[
# 垃圾收集器与内存分配策略

## 垃圾收集器

### 1.概述

**垃圾收集(Garbage Collection,GC)：自动管理回收不再引用的内存数据**需要完成的三件事情：

- 哪些内存需要回收
- 什么时候回收
- 如何回收

>  Java语言会自动管理和回收不再引用的内存数据，由垃圾回收机制来完成。Java自身提供了内存管理机制，应用程序不需要去关注内存如何释放，内存用完后，GC会去自动进行处理，不需要人为干预出现错误。

在{% post_link JVM相关及其拓展 %}章节中介绍了JVM的内存区域。

**其中`程序计数器`、`虚拟机栈`，`本地方法栈`随线程而生，随线程而灭**。栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作，因此每一个栈帧分配多少内存基本是在类结构确定下来就已经是已知的。**因此这几个区域的内存分配和回收都具备确定性。所以不需要过多考虑回收的问题，在方法结束或者线程结束后，内存就随着回收了，也就实现了内存的自动清理。**

**而`Java堆`和`方法区`则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序运行期间才知道会创建哪些对象，这部分的内存分配和回收是动态的。垃圾收集器关注的就是这部分的内存。**

### 2.判断对象是否可以回收

>  在堆里面存放着几乎所有的对象实例，垃圾收集器在回收前需要去判断对象是否还被引用来决定是否回收，即找到那些不再被任何途径使用的对象。

- **引用计数算法(Refrence Counting)**

 > 给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时候计数器为0的对象是不能再被引用的，可以被当做垃圾收集。
 >
 > 优点：实现简单，判断效率高
 > 缺点：无法检测出对象之间相互循环引用，开销大（会发生频繁且大量的引用变化，带来大量的额外运算）。

- **可达性分析算法(Reachability Analysis)**

 > 通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的节点为引用链，当一个对象到GC Roots没有任何引用链相连（从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

{% fullimage /images/jvm/gc_reachability_analysis.png,可达性分析算法,可达性分析算法  %}

在Java语言中，可作为GC Roots的对象包括以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象（Native对象）

 > 优点：更加精确严谨可以分析出循环引用的情况
 >
 > 缺点：实现复杂，效率低，分析过程中需要GC停顿（因为应用关系不能发生改变，需要停止所有Java线程）

###  3.对象是生存还是死亡

> 真正宣告一个对象死亡，至少要经历两次标记过程 

- **第一次标记**：

  对象在进行可达性分析算法后没有发现与GC Roots相连接的引用链，将会被第一次标记并进行第一次筛选。筛选的条件是此对象是否有必要执行`finalize()`方法。

  - 没必要执行

    对象没有覆盖`finalize()`方法，或者`finalize()`方法已被虚拟机调用过。

  - 有必要执行

    对象会被放置在一个F-Queue的队列中，稍后会由一个JVM自动建立的、低优先级的Finalizer线程去执行。

- **第二次标记：**

  GC对F-Queue中的对象进行第二次小规模的标记，`finalize()`是对象摆除被回收的最后方法

  - 若对象要避免自己被回收，需要重新与引用链上的任何一个对象建立关系即可，譬如把自己（this）赋值给某个变量或者对象的成员变量，那就会移除被回收的集合
  - 如果没有摆除，则基本上会被回收。任何一个对象的`finalize()`方法只会被系统自动调用一次，再次调用`finalize()`方法则不会再次执行。

```java
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive() {
        System.err.println("It is live");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.err.println("finalize is executed");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();

        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.err.println("It is over");
        }
        //将对象的引用链重新置为null，则拯救失败
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.err.println("It is over");
        }
        
    }
    
}
```

- **`finalize()`**

  运行代价高昂，不确定性大，无法保证各个对象的调用顺序。

{% fullimage /images/判断Java对象是否存活.png,判断Java对象是否存活,判断Java对象是否存活 %}

### 4.回收方法区

> 永久代的垃圾收集主要分为两部分：**废弃常量和无用的类**
>
> **废弃常量**：假如常量池中存在一个常量，但是没有任何对象引用该常量，在发生回收的时候，该常量就会被系统清理出常量池，常量池中的其他类（接口）、方法、字段的符号引用类似。
>
> **无用的类**：需要同时满足以下条件
>
> 1. 该类的所有实例已被回收，Java堆中不存在该类的任何实例
> 2. 加载该类的ClassLoader已被回收
> 3. 该类对应的Class对象没有在任何地方被引用，也无法在任何地方通过反射访问到该类的方法

### 5.垃圾收集算法

#### **标记-清除算法(Mark-Sweep)  最基础的收集算法**

> 算法分为`标记`和`清除`两个阶段，**首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象**。主要不足有两个：一个是效率问题（`标记和清除两个过程的效率都不高`）；另一个是空间问题（`标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作`）。

{% fullimage /images/jvm/gc_mark_sweep.png ,标记-清除算法,标记-清除算法%}

#### **复制算法(Copying)**

> 将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象移到另一块上面，然后把已使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时就不需考虑内存碎片等情况。
>
> 缺点：可用内存会减少一半；效率会随存活对象的升高而降低（当对象存活率较高的时候，需要更多的copy操作，导致效率降低）

{% fullimage /images/jvm/gc_copying.png,整理算法,整理算法 %}

现在的商业虚拟机都采用这种收集算法来回收新生代。

提供了改良算法（基于**弱代理论①**）：不是按照1:1的比例去划分内存空间，而是分为较大的Eden空间和两块较小的Survivor空间，在回收时将Eden和Survivor存活的对象移至到另一块Survivor空间上。**HotSpot中Eden和Survivor的大小比例为8:1。**`在一般场景下足够使用，当Survivor空间不够使用时，需要依赖其他内存(代指老年代)进行分配担保②`。

> ①**弱代理论**：1. 大多数分配了内存的对象存活不会太久，在年轻代就会死掉；2. 很少有对象从年老代变成年轻代。
>
> ②**分配担保**：如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。

#### **标记-整理算法(Mark-Compact)**

> 标记过程与“标记-清除”算法一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理端边界以外的内存。

{% fullimage /images/jvm/gc_mark_compact.png,标记-整理算法,标记-整理算法%}

> 优点：1. 效率不随对象存活率升高而降低。 2. 不像标记-清除算法会产生大量的内存碎片（因为会进行一次整理，将存活对象集中到一端）。
>
> 缺点：除了需要进行标记，还需要整理过程，执行效率更低。

#### **分代收集算法(Generational Collection)——主流收集算法**

> 根据对象存活周期的不同将内存划分为几块，一般是把Java堆分成新生代和老年代~~和持久代(JDK8中移除)~~，这样就可以根据各个年代的特点采用最适当的收集算法。
> **新生代**中每次垃圾收集都会有大量的对象被回收，只有少量存活，就可以使用复制算法。
>
> **老年代**中因为对象存活率较高，没有额外空间进行分配担保，所以必须使用“标记-清理”或者“标记-整理”算法。

- **新生代(Young Generation)**：所有新生对象都会放在新生代，新生代的目标是尽快收集生命周期短的对象，每次GC过后只有少量存活。新生代发生的GC叫做**`Minor GC（频率较高，新生代Eden区满才触发）`**。新生代细分为`Eden、From Survivor、To Survivor`三块空间（三块空间大小并非均分，默认比例为8:1:1）。

  新生代的垃圾回收执行过程：

  1. `Eden`区 + `From Survivor`区存活的对象复制到`To Survivor`区
  2. 清空`Eden以及From Survivor`区
  3. `From Survivor`和`To Survivor`进行交换

- **老年代(Tenured Generation)**：新生代发生几次GC后依然存活的对象会放到老年代中，所以老年代中的对象生命周期较长。内存也比新生代大很多（大概2:1）,当老年代内存满时会触发**`Full GC/Major GC(针对新生代和老年代触发，经常会伴随至少一次的Minor GC，收集频率较低且耗时长，一般慢10倍以上)`**。

- ~~**持久代(Permanent Generation)**~~：用于存放静态文件，如Java类，方法等，对GC没有影响。

- **拓展**：别处也有介绍   Full GC针对整个堆空间（包含新生代，老年代，永久代（如果包含））的回收。而Major GC是针对老年代的内存回收。

- **Minor GC**：新生代是堆的一部分，对象首先在新生代中分配。新生代填满时，垃圾收集器会暂停所有的应用程序，回收新生代空间。不再使用的对象会被回收，仍然使用的对象移动至其他地方。

- **Full GC:** 对象不断地移至老年代，最终老年代也被填满，JVM需要找到老年代不再使用的对象并进行回收。会导致长时间停顿。

{% fullimage /images/jvm/gc_java_heap_memory.png,Java堆内存,Java堆内存 %}

### 6.垃圾收集器

> 收集算法是内存回收的方法论，垃圾收集器就为内存回收的具体实现。

{% fullimage /images/jvm/gc_collectors.png,垃圾收集器,垃圾收集器 %}

根据上图分析新生代收集器主要是：**Serial收集器,ParNew收集器,Parallel Scavenge收集器和G1收集器**。老年代收集器为**CMS收集器，Serial Old收集器，Parallel收集器和G1收集器**。

在两个收集器之间存在连线，则意味着他们之间可以搭配使用。

#### `Serial收集器`

> 该收集器是最基本、发展历史最悠久的收集器。这个收集器是一个**单线程**收集器（`不仅是他只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是他在进行垃圾收集时必须停止其他的工作线程(Stop The World)，直到收集结束。进行Full GC时，还会对老年代空间对象进行压缩整理。`）。

是虚拟机运行在Client端的默认新生代收集器

有着优于其他收集器的地方：

 - **简单而高效**
 - **没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集效率**

关键控制参数：

- -XX:SurvivorRatio：设置两个Survivor区和Eden区的比值(**8表示 1:1:8**)
- -XX:PretenureSizeThreshold：设定对象超过多少岁时进入老年代
- -XX:HandlePromotionFailure：设置是否允许担保失败

#### `ParNew收集器`

> ParNew收集器其实是Serial收集器的多线程版本。除了使用多线程进行垃圾收集之外，其他科Serial收集器完全一样。

该收集器是运行在Server模式下的虚拟机中的首选的新生代收集器，其中有一个重要的原因就是：**除了Serial收集器外，目前只有它能和CMS收集器配合工作。**随着可以使用的CPU数量增加，GC时系统资源的有效利用还是有好处的。**默认开启的收集线程数与CPU的数量相同**

> **并行（Parallel）**：指多条垃圾收集器线程并行工作，但此时用户线程仍处于等待状态
>
> **并发（Concurrent）**：指用户线程与垃圾收集器同时执行，用户程序仍继续运行，而垃圾收集器执行于另一个CPU上。

关键控制参数：

- -XX:UserParNewGC：是否开启ParNew收集器

#### `Parallel Scavenge收集器`

> Parallel Scavenge收集器是一个新生代收集器，使用了复制算法以及并行的多线程收集器。

该收集器的目标是：**达到一个可控制的吞吐量（ThroughPut）**①。

停顿时间越短越适合需要与用户交互的程序，良好的响应速度可以提升用户体验，高吞吐量就可以高效率的利用CPU时间，主要适合在后台运算而不需要太多交互的任务。

> `吞吐量`：CPU用于运行用户代码时间与CPU总消耗时间的比值。

关键控制参数：

 - -XX:UseAdaptiveSizePolicy：开关参数，当打开时就不需要去指定新生代大小以及Eden与Survivor比例，晋升老年代对象岁数大小等参数，触发**GC自适应调节策略**(`虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数已提供最适合的停顿时间或者最大的吞吐量`)

#### `Serial Old收集器`

> 是Serial收集器的老年代版本，同样是一个单线程收集器。使用“标记-整理算法”

该收集器主要为了给Client模式下的虚拟机使用。如果在Server模式下，还有以下用途：

- 在JDK1.5及之前的版本搭配Paraller Scavenge收集器
- 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用

#### `Parallel Old收集器`

> 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”。

在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑`Parallel Scavenge +  Parallel Old`组合。

#### **`CMS收集器（Concurrent Mark Sweep）`**

> 以获取最短回收停顿时间为目标的收集器。基于“**标记-清除算法**”实现。整体上来说内存回收过程是与用户线程一起并发执行的。

{% fullimage /images/CMS收集器.png,CMS收集器,CMS收集器%}

运作过程比较复杂，分为4个步骤：

- **初始标记**：仅仅标记一下GC Roots能关联到的对象，速度很快  `触发Stop The World`
- **并发标记**：进行GC Roots Tracing的过程
- **重新标记**：修正并发标记期间因用户程序继续运做而导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记长一些，但短于并发标记时间  `触发Stop The World`
- **并发清除**：可以和用户线程一起工作

{% fullimage /images/jvm/gc_collectors_CMS.png,CMS,CMS %}

CMS收集器有3个明显的缺点：

1. **对CPU资源非常敏感**

   **面向并发设计的程序都对CPU资源比较敏感**。在并发阶段，虽然不会导致用户线程停顿，但是会因为占了一部分CPU资源而导致线程变慢，吞吐量会降低。`CMS默认启动的回收线程数量为(CPU数量+3)/4`

2. **无法处理浮动垃圾（Floating Garabge）**

   由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就有新的垃圾产生，即`浮动垃圾(这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉他们，只能留到下一次GC进行清理)`。

   因此CMS收集器不能像其他收集器一样等到老年代几乎完全满了在进行收集，需要预留一部分空间提供并发收集时使用。

   JDK1.5默认设置下，CMS收集器到老年代到了68%即会激活，到1.6时提高到了92%。

   要是CMS运行期间预留的内存无法满足程序需要，就会出现一次`Concurrent Mode Failure`失败，虚拟机将会启动后备预案：**临时启用Serial Old收集器来重新进行老年代的垃圾收集，停顿时间就会变得很长了。**

3. **产生的空间碎片**

   由于CMS是基于“标记-清除”算法实现的收集器。这种方式会产生大量的空间碎片，碎片过多时将会给对象分配来很大麻烦，往往会出现老年代还有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。

关键控制参数：

- -XX:CMSInitiatingOccupancyFraction：设置CMS触发阈值即老年代对象占用空间

#### **`G1收集器`**

> 全称Garbage-First收集器，通过-XX:+UseG1GC参数来启用，在JDK9中，被提议为默认收集器。`在JDK10中，把单线程的Full GC改良为了多线程Full GC`

{% fullimage /images/G1收集器.png,G1收集器,G1收集器%}

G1收集器是一款面向服务端的垃圾收集器，设计目标是为了取代CMS收集器。具备如下特点：

- **并行与并发**：使用多个CPU来缩短停顿时间，也会通过并发的方式让Java程序继续运行
- **分代收集**：分代概念在G1中得以保留，可以不需要其他的收集器配合管理整个堆，可以采用不同的方式去处理新创建的对象和旧对象。
- **空间整合**：整体基于“标记-整理”算法，局部（两个Region之间）采用“复制”算法实现
- **可预测的停顿**：除了追求低停顿外，还可建立可预测的时间停顿模型，用户可以指定期望停顿的时间

##### Region

在G1收集器之前其他收集器进行收集的范围都是整个新生代或者老年代，而G1可以通用。使用G1收集器，Java堆的内存布局就与其他收集器不同，将整个Java堆划分为多个大小相等的独立区域（Region），虽然保留了新生代老年代的概念，但他们都变成了一部分Region的集合。

##### 可停顿的时间模型

可以实现有计划的避免在整个Java堆中进行全区域的垃圾收集。跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region空间。可以保证G1收集器在有限时间内获得尽可能高的收集效率。

##### Remembered Set

Region不可能是独立的，由于可能会被其他对象引用。在G1中，Region之间的对象引用以及其他收集器中的新生代老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。每一个Region都会对应一个Remembered Set，虚拟机发现在对Reference进行读写操作时，产生一个`Write Barrier`暂时中断写操作，检查对象引用是否位于不同的Region中，若是则通过`CardTable`记录相关引用信息到Remembered Set中。**在进行内存回收时，在GC Roots中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。**

##### **stop-the-world**

概念：**除GC所需线程外，多有线程都要进如等待状态，直到GC任务完成。**

解决方法：使用多个CPU来缩短停顿时间。

##### G1运作步骤

- **初始标记**：标记一下GC Roots能直接关联的对象，需要停顿线程
- **并发标记**：从GC Roots开始进行可达性分析，找出存活的对象耗时较长
- **最终标记**：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，需要停顿线程，可并行执行
- **筛选回收**：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间来指定回收计划。

**如果应用追求吞吐量，那并不会带来特别的好处**

#### `ZGC收集器`

> 在Java11 中引入的新型收集器



###  7.内存分配与回收策略

**对象的内存分配，就是在堆上进行分配。**

> 对象优先在Eden分配,就是在JVM的堆上进行内存分配

> 大对象直接进入老年代

大对象代指 **需要连续内存空间的Java对象**

> 长期存活的对象将进入老年代

当Eden区满了，在创建对象会触发Minor GC(**执行Minor GC时，Eden空间存活的对象会被复制到To Survivor·空间，并且之前经过一次Minor GC在From Survivor存活并年轻的对象也会被复制到To Survivor空间。如果存活对象的分代年龄超过阈值，则会晋升到老年代。**)

> 动态对象年龄判定

为了更好的适应不同程序的内存状况，并不需要永远要求对象年龄必须达到`maxTenuringThreshold`才可以晋升老年代，**若在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。**

> 空间分配担保

**如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。**

]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Service工作过程</title>
    <url>/2019/01/10/Service%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[
## Service基础知识

{% post_link Android-Study-Plan-II%}

## Service工作过程

Service分为两种工作状态，一种是`启动状态`，主要用于执行后台计算；另一种是`绑定状态`，主要用于其他组件和Service的交互。

Service的这两种状态是可以共存的，即Service既可以处于启动状态也可以同时处于绑定状态。

```java
//启动Service
Intent intent= new Intent(this,MyService.class);
startService(intent);

//绑定Service
Intent intent= new Intent(this,MyService.class);
bindService(intent,mServiceConnection,BIND_AUTO_CREATE);
```

### Service启动过程 - startService

Service的启动过程从`ContextWrapper.startService()`开始

```java
// ../android/content/ContextWrapper.java
    Context mBase;
    @Override
    public ComponentName startService(Intent service) {
        return mBase.startService(service);
    }
```

在Activity启动的时候`performLaunActivity`时，会创建上下文对象`Context`，然后在`Activity.attach()`调用了`attachBaseContext()`将得到的contenxt进行赋值。最终操作的就是`ContextImpl`。

```java
// ../android/app/ContextImpl.jsvs
    @Override
    public ComponentName startService(Intent service) {
        warnIfCallingFromSystemProcess();
        return startServiceCommon(service, false, mUser);
    }

    private ComponentName startServiceCommon(Intent service, boolean requireForeground,
            UserHandle user) {
        try {
            validateServiceIntent(service);
            service.prepareToLeaveProcess(this);
            //启动Service
            ComponentName cn = ActivityManager.getService().startService(
                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(
                            getContentResolver()), requireForeground,
                            getOpPackageName(), user.getIdentifier());
            if (cn != null) {
                 ...
            }
            return cn;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
```

`ActivityManager.getService()`在Activity启动过程中有介绍它是得到`IActiivtyManager`实际就是指向`AMS`的一个Binder对象，调用到的就是`AMS.startService()`

```java
// ../core/java/com/android/server/am/ActivityManagerService.java
    @Override
    public ComponentName startService(IApplicationThread caller, Intent service,
            String resolvedType, boolean requireForeground, String callingPackage, int userId)
            throws TransactionTooLargeException {
        enforceNotIsolatedCaller("startService");
        // Refuse possible leaked file descriptors
        if (service != null && service.hasFileDescriptors() == true) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }

        if (callingPackage == null) {
            throw new IllegalArgumentException("callingPackage cannot be null");
        }

        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE,
                "*** startService: " + service + " type=" + resolvedType + " fg=" + requireForeground);
        synchronized(this) {
            final int callingPid = Binder.getCallingPid();
            final int callingUid = Binder.getCallingUid();
            final long origId = Binder.clearCallingIdentity();
            ComponentName res;
            try {
                res = mServices.startServiceLocked(caller, service,
                        resolvedType, callingPid, callingUid,
                        requireForeground, callingPackage, userId);
            } finally {
                Binder.restoreCallingIdentity(origId);
            }
            return res;
        }
    }


```

`mServices`的类型是`ActiveServices`.*`ActiveServices`是一个辅助`AMS`进行Service管理的类，其中包括Service的启动，绑定和停止等功能。*

```java
// ../core/java/com/android/server/am/ActiveServices.java
ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,
            int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId)
            throws TransactionTooLargeException {
   ...
        //去查找是否有与参数 service 对应的ServiceRecord。
        ServiceLookupResult res =
            retrieveServiceLocked(service, resolvedType, callingPackage,
                    callingPid, callingUid, userId, true, callerFg, false);
        if (res == null) {
            return null;
        }
        if (res.record == null) {
            return new ComponentName("!", res.permission != null
                    ? res.permission : "private to package");
        }
        //封装一个ServiceRecord对象
        ServiceRecord r = res.record;
   ...
     
     ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);
 }
```

`ServiceRecord`描述的是一个Service记录，一直贯穿着整个Service的启动过程。

```java
    ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,
            boolean callerFg, boolean addToStarting) throws TransactionTooLargeException {
        ...
        String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);
        if (error != null) {
            return new ComponentName("!!", error);
        }

        ...

        return r.name;
    }

    private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,
            boolean whileRestarting, boolean permissionsReviewRequired)
            throws TransactionTooLargeException {
      ...
        //获取Service想在那个进程中运行  process
        final String procName = r.processName;
        String hostingType = "service";
        ProcessRecord app;
        //当前不止一个进程
        if (!isolated) {
            //查询是否存在一个 与Service类型对应的ProcessRecord对象的app进程
            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);
            if (DEBUG_MU) Slog.v(TAG_MU, "bringUpServiceLocked: appInfo.uid=" + r.appInfo.uid
                        + " app=" + app);
            //Service的运行进程已经存在
            if (app != null && app.thread != null) {
                try {
                    app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);
                    //启动service
                    realStartServiceLocked(r, app, execInFg);
                    return null;
                } catch (TransactionTooLargeException e) {
                    throw e;
                } catch (RemoteException e) {
                    Slog.w(TAG, "Exception when starting service " + r.shortName, e);
                }
            }
        } else {
            app = r.isolatedProc;
            if (WebViewZygote.isMultiprocessEnabled()
                    && r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) {
                hostingType = "webview_service";
            }
        }

        //没有对应的运行进程启动
        if (app == null && !permissionsReviewRequired) {
            //需要新启动一个应用进程 承载Service
            if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,
                    hostingType, r.name, false, isolated, false)) == null) {
                String msg = "Unable to launch app "
                        + r.appInfo.packageName + "/"
                        + r.appInfo.uid + " for service "
                        + r.intent.getIntent() + ": process is bad";
                Slog.w(TAG, msg);
                bringDownServiceLocked(r);
                return msg;
            }
            if (isolated) {
                r.isolatedProc = app;
            }
        }
      ...
    }
```

在`bringUpServiceLocked()`中，优先获取`Service需要的运行进程--通过android:process设置`，然后去判断当前进程中是否存在符合要求的

- 不存在，调用`AMS.startProcessLocked()`去新建对应应用进程，这个函数在Activity启动过程中有讲解
- 存在，直接调用`realStartServiceLocked()`去启动Service，*命名方法类似Activity启动过程中的`realStartActivityLocked()`*

```java
    private final void realStartServiceLocked(ServiceRecord r,
            ProcessRecord app, boolean execInFg) throws RemoteException {
      ...
        boolean created = false;
        try {
          ...
            app.thread.scheduleCreateService(r, r.serviceInfo,
                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),
                    app.repProcState);
            r.postNotification();
            created = true;
        } catch (DeadObjectException e) {
            Slog.w(TAG, "Application dead when creating service " + r);
            mAm.appDiedLocked(app);
            throw e;
        } finally {
            if (!created) {
                // Keep the executeNesting count accurate.
                final boolean inDestroying = mDestroyingServices.contains(r);
                serviceDoneExecutingLocked(r, inDestroying, inDestroying);

                // Cleanup.
                if (newService) {
                    app.services.remove(r);
                    r.app = null;
                }

                // Retry.
                if (!inDestroying) {
                    scheduleServiceRestartLocked(r, false);
                }
            }
        }
      
      ...
        //由于 必须startRequested 参数为true
        if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {
            r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),
                    null, null, 0));
        }
        //调用Service中的其他方法，例如 onStartCommand
        sendServiceArgsLocked(r, execInFg, true);

    }


    private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,
            boolean oomAdjusted) throws TransactionTooLargeException {
      ...
        //通知ActivityThread初始化已经完成，然后调用后续方法
        r.app.thread.scheduleServiceArgs(r, slice);
      ...
    }
```

`app.thread`是`IApplicationThread`类型的，实际上是一个Binder对象，它的实现是`ApplicationThread`，用于和`ActivityThread`进行通信。

```java
// ../android/app/ActivityThread.java       
public final void scheduleCreateService(IBinder token,
                ServiceInfo info, CompatibilityInfo compatInfo, int processState) {
            updateProcessState(processState, false);
            CreateServiceData s = new CreateServiceData();
            s.token = token;
            s.info = info;
            s.compatInfo = compatInfo;

            sendMessage(H.CREATE_SERVICE, s);
        }
```

这里与`Activity启动过程`是一致的，通过`ActivityThread.H`这个Handler对象发送消息，切换到主线程去处理消息。这个发送的是`CREATE_SERVICE`，最后调用到了`ActivityThread.handleCreateService()`去启动Service

```java
final ArrayMap<IBinder, Service> mServices = new ArrayMap<>();    
private void handleCreateService(CreateServiceData data) {
        // If we are getting ready to gc after going to the background, well
        // we are back active so skip it.
        unscheduleGcIdler();
        //获取LoaderApk对象 是一个Apk文件的描述器
        LoadedApk packageInfo = getPackageInfoNoCheck(
                data.info.applicationInfo, data.compatInfo);
        Service service = null;
        try {
            java.lang.ClassLoader cl = packageInfo.getClassLoader();
            service = (Service) cl.loadClass(data.info.name).newInstance();
        } catch (Exception e) {
            if (!mInstrumentation.onException(service, e)) {
                throw new RuntimeException(
                    "Unable to instantiate service " + data.info.name
                    + ": " + e.toString(), e);
            }
        }

        try {
            if (localLOGV) Slog.v(TAG, "Creating service " + data.info.name);
            //创建Service的ContextImpl对象
            ContextImpl context = ContextImpl.createAppContext(this, packageInfo);
            context.setOuterContext(service);

            Application app = packageInfo.makeApplication(false, mInstrumentation);
            //初始化Service
            service.attach(context, this, data.info.name, data.token, app,
                    ActivityManager.getService());
            //调用 onCreate 生命周期
            service.onCreate();
            mServices.put(data.token, service);
            try {
                ActivityManager.getService().serviceDoneExecuting(
                        data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        } catch (Exception e) {
            if (!mInstrumentation.onException(service, e)) {
                throw new RuntimeException(
                    "Unable to create service " + data.info.name
                    + ": " + e.toString(), e);
            }
        }
    }

```

`handleCreateService()`执行了以下的几件事：

- 通过类加载器创建`Service`实例，*Actiivty启动过程是利用了 Instrumention.newActivity() 执行相同创建实例*
- `makeApplication()`创建`Application`对象并调用其`onCreate`
- 创建`ContextImpl`对象并调用`Service.attach()`建立关系
- 最后调用`Service.onCreate()`开始创建过程，并存储至`ArrayMap<IBinder,Service>`中，在下一节会介绍这里存储数据的作用
- 调用`onCreate()`之后，Service也已经启动了。

{% fullimage /images/Service启动过程.png,Service启动过程,Service启动过程%}

### Service绑定过程 - bindService

和Service的启动过程一样，Service的绑定过程也是从`ContextWrapper`开始

```java
// ../android/content/ContextWrapper.java    
@Override
    public boolean bindService(Intent service, ServiceConnection conn,
            int flags) {
        return mBase.bindService(service, conn, flags);
    }
```

```java
// ../android/app/ContextImpl.java
    @Override
    public boolean bindService(Intent service, ServiceConnection conn,
            int flags) {
        warnIfCallingFromSystemProcess();
        return bindServiceCommon(service, conn, flags, mMainThread.getHandler(),
                Process.myUserHandle());
    }

    private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler
            handler, UserHandle user) {
        IServiceConnection sd;
        if (conn == null) {
            throw new IllegalArgumentException("connection is null");
        }
        if (mPackageInfo != null) {
            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);
        } else {
            throw new RuntimeException("Not supported in system context");
        }
        validateServiceIntent(service);
        try {
           ...
            service.prepareToLeaveProcess(this);
            int res = ActivityManager.getService().bindService(
                mMainThread.getApplicationThread(), getActivityToken(), service,
                service.resolveTypeIfNeeded(getContentResolver()),
                sd, flags, getOpPackageName(), user.getIdentifier());
            if (res < 0) {
                throw new SecurityException(
                        "Not allowed to bind to service " + service);
            }
            return res != 0;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

```

在`bindServiceCommon()`主要做了两件事情：

- `getServiceDispatcher()` 将传进来的`ServiceConnection`转化成`IServiceConnection`，通过Binder对象进行通信。使得Service的绑定支持跨进程调用。

  ```java
  // ../android/app/LoaderApk.java    
  public final IServiceConnection getServiceDispatcher(ServiceConnection c,
              Context context, Handler handler, int flags) {
          synchronized (mServices) {
              LoadedApk.ServiceDispatcher sd = null;
              ArrayMap<ServiceConnection, LoadedApk.ServiceDispatcher> map = mServices.get(context);
              if (map != null) {
                  if (DEBUG) Slog.d(TAG, "Returning existing dispatcher " + sd + " for conn " + c);
                  sd = map.get(c);
              }
              if (sd == null) {
                  sd = new ServiceDispatcher(c, context, handler, flags);
                  if (DEBUG) Slog.d(TAG, "Creating new dispatcher " + sd + " for conn " + c);
                  if (map == null) {
                      map = new ArrayMap<>();
                      mServices.put(context, map);
                  }
                  map.put(c, sd);
              } else {
                  sd.validate(context, handler);
              }
              return sd.getIServiceConnection();
          }
      }
  ```

  `mServices`存储了一个应用当前活动的`ServiceConnection和ServiceDispatcher`的映射关系。`ServiceDispatcher`的作用是*连接ServiceConnection和IServiceConnection。*

- `bindService()`开始Service的绑定流程

  ```java
  // ../core/java/com/android/server/am/ActivityManagerService.java
      public int bindService(IApplicationThread caller, IBinder token, Intent service,
              String resolvedType, IServiceConnection connection, int flags, String callingPackage,
              int userId) throws TransactionTooLargeException {
          enforceNotIsolatedCaller("bindService");
  
          // Refuse possible leaked file descriptors
          if (service != null && service.hasFileDescriptors() == true) {
              throw new IllegalArgumentException("File descriptors passed in Intent");
          }
  
          if (callingPackage == null) {
              throw new IllegalArgumentException("callingPackage cannot be null");
          }
  
          synchronized(this) {
              return mServices.bindServiceLocked(caller, token, service,
                      resolvedType, connection, flags, callingPackage, userId);
          }
      }
  
  ```

存储好对应的`ServiceConnection`和`ServiceDispatcher`映射的关系，之后开始继续绑定流程

```java
// ../core/java/com/android/server/am/ActiveServices.java
    int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,
            String resolvedType, final IServiceConnection connection, int flags,
            String callingPackage, final int userId) throws TransactionTooLargeException {
        // 获取应用进程信息  
        final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);
        if (callerApp == null) {
            throw new SecurityException(
                    "Unable to find app for caller " + caller
                    + " (pid=" + Binder.getCallingPid()
                    + ") when binding service " + service);
        }
        //获取绑定Activity信息
        ActivityRecord activity = null;
        if (token != null) {
            activity = ActivityRecord.isInStackLocked(token);
            if (activity == null) {
                Slog.w(TAG, "Binding with unknown activity: " + token);
                return 0;
            }
        }
        //获取Service相关信息
        ServiceRecord s = res.record;
        //启动Activity成功后 ，再启动Service
        if (mAm.mPermissionReviewRequired) {
            if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(
                    s.packageName, s.userId)) {
              RemoteCallback callback = new RemoteCallback(
                        new RemoteCallback.OnResultListener() {
                    @Override
                    public void onResult(Bundle result) {
                        synchronized(mAm) {
                            final long identity = Binder.clearCallingIdentity();
                            try {
                                ...
                                if (...) {
                                    try {
                                        // 启动 Service
                                        bringUpServiceLocked(...);
                                    } catch (RemoteException e) {
                                        /* ignore - local call */
                                    }
                                } else {
                                    ...
                                }
                            } finally {
                                ...
                            }
                        }
                    }
                });

                final Intent intent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS);
                // 注意 callback
                intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback);
                
                // 启动 Activity，成功启动后回调 callback 
                mAm.mHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        mAm.mContext.startActivityAsUser(intent, new UserHandle(userId));
                    }
                });
            }
        }
      try{
        // 如果设置了绑定后自动启动
        if ((flags&Context.BIND_AUTO_CREATE) != 0) { 
                s.lastActivity = SystemClock.uptimeMillis();
                // 启动 Service
                if (bringUpServiceLocked(s, service.getFlags(), callerFg, false,
                        permissionsReviewRequired) != null) {
                    return 0;
                }
           }
            // Service 已经在运行中，直接回调 onServiceConnected 即可
            if (s.app != null && b.intent.received) { 
                // Service is already running, so we can immediately
                // publish the connection.
                try {
                    // 回调 onServiceConnected
                    c.conn.connected(s.name, b.intent.binder, false);
                } catch (Exception e) {
                    ...
                }
                //
                if (b.intent.apps.size() == 1 && b.intent.doRebind) {
                    requestServiceBindingLocked(s, b.intent, callerFg, true);
                }
                ...
                  //没有进行过绑定Service请求
            } else if (!b.intent.requested) { 
                // 回调 onBind，内部调用了 scheduleBindService
                requestServiceBindingLocked(s, b.intent, callerFg, false);
            }
        ...
      } finally {
         Binder.restoreCallingIdentity(origId);
      }
      return 1;
    }
```

> 介绍几个与Service有关的对象类型：
>
> - ServiceRecord：描述一个Service
> - ProcessREcord：描述一个进程的信息
> - ConnectionRecord：描述应用程序进程和Service建立的一次通信。
> - AppBindRecord：维护Srvice与应用程序进程之间的关联。
> - IntentBindRecord：描述绑定Service的Intent

`bindServiceLocked()`内部会通过`bringUpServiceLocked()`自动启动Service。然后向下走`启动Service流程`。

还会多调用一个`requestServiceBindingLocked()`请求绑定过程

```java
// ../core/java/com/android/server/am/ActiveServices.java
    private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,
            boolean execInFg, boolean rebind/*是否重新绑定*/) throws TransactionTooLargeException {
        if (r.app == null || r.app.thread == null) {
            // If service is not currently running, can't yet bind.
            return false;
        }
        if (DEBUG_SERVICE) Slog.d(TAG_SERVICE, "requestBind " + i + ": requested=" + i.requested
                + " rebind=" + rebind);
        //是否发送过 绑定Service的请求 
        if ((!i.requested || rebind) && i.apps.size() > 0) {
            try {
                bumpServiceExecutingLocked(r, execInFg, "bind");
                r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);
                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,
                        r.app.repProcState);
                if (!rebind) {
                    i.requested = true;
                }
                i.hasBound = true;
                i.doRebind = false;
            } catch (... ) {//最大通常限制为1M.
               ...
            }
        }
        return true;
    }
```

`app.thread`把逻辑切换到了 `ActivityThread`中了

```java
// ../android/app/ActivityThread.java       
public final void scheduleBindService(IBinder token, Intent intent,
                boolean rebind, int processState) {
            updateProcessState(processState, false);
            BindServiceData s = new BindServiceData();
            s.token = token;
            s.intent = intent;
            s.rebind = rebind;

            if (DEBUG_SERVICE)
                Slog.v(TAG, "scheduleBindService token=" + token + " intent=" + intent + " uid="
                        + Binder.getCallingUid() + " pid=" + Binder.getCallingPid());
            sendMessage(H.BIND_SERVICE, s);
        }

// 处理绑定Service流程
private void handleBindService(BindServiceData data) {
        //获取要绑定的Service对象
        Service s = mServices.get(data.token);
        if (DEBUG_SERVICE)
            Slog.v(TAG, "handleBindService s=" + s + " rebind=" + data.rebind);
        if (s != null) {
            try {
                data.intent.setExtrasClassLoader(s.getClassLoader());
                data.intent.prepareToEnterProcess();
                try {
                   //绑定Service
                    if (!data.rebind) {
                        //调用 onBind 方法，此时已绑定Service
                        IBinder binder = s.onBind(data.intent);
                        //通知绑定成功
                        ActivityManager.getService().publishService(
                                data.token, data.intent, binder);
                    } else {
                        //执行重新绑定流程
                        s.onRebind(data.intent);
                        ActivityManager.getService().serviceDoneExecuting(
                                data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
                    }
                    ensureJitEnabled();
                } catch (RemoteException ex) {
                    throw ex.rethrowFromSystemServer();
                }
            } catch (Exception e) {
                if (!mInstrumentation.onException(s, e)) {
                    throw new RuntimeException(
                            "Unable to bind to service " + s
                            + " with " + data.intent + ": " + e.toString(), e);
                }
            }
        }
    }
```

> `Service.onRebind()`执行条件为：使用Service的流程是，先`startService()`然后`bindService()`，在Activity退出的时候，Service并不会停止，再进入Activity重新进行`bindService()`，会触发`onRebind()`方法。**但是先前Activity退出时调用的`onUnbind()`返回为`true`，直接写死返回结果。**
>
> **当多次绑定同一个Service时，`onBind()`只会执行一次，除非Service被终止。**

{% fullimage /images/Service绑定过程.png,Service绑定过程,Service绑定过程%}

#### Service绑定通知

发现Service未绑定时，就会调用到`onBind()`，Service就处于绑定状态，但是客户端无法感知到Service已经连接成功，所以需要`AMS`进行通知。

```java
// ../core/java/com/android/server/am/ActivityManagerService.java
    public void publishService(IBinder token, Intent intent, IBinder service) {
        // Refuse possible leaked file descriptors
        if (intent != null && intent.hasFileDescriptors() == true) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }

        synchronized(this) {
            if (!(token instanceof ServiceRecord)) {
                throw new IllegalArgumentException("Invalid service token");
            }
            mServices.publishServiceLocked((ServiceRecord)token, intent, service);
        }
    }


```

`mServices`就是`ActiveServices`对象，调用其内部的`publishServiceLocked()`

```java
// ../core/java/com/android/server/am/ActiveServices.java
void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) {
        final long origId = Binder.clearCallingIdentity();
        try {
             ...
                    for (int conni=r.connections.size()-1; conni>=0; conni--) {
                        ArrayList<ConnectionRecord> clist = r.connections.valueAt(conni);
                        for (int i=0; i<clist.size(); i++) {
                            ConnectionRecord c = clist.get(i);
                            try {
                                c.conn.connected(r.name, service, false);
                            } catch (Exception e) {
                                Slog.w(TAG, "Failure sending service " + r.name +
                                      " to connection " + c.conn.asBinder() +
                                      " (in " + c.binding.client.processName + ")", e);
                            }
                        }
                    }
                }

                serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false);
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }
```

`c.conn`指向`IServiceConnection`，他是`ServiceConnection`在本地的代理对象，用于解决当前应用程序进程和Service跨进程通信的问题。

他的具体实现为`ServiceDispatcher.InnerConnection`。

```java
// ../android/app/LoaderApk.java
static final class ServiceDispatcher {
 ...
        private static class InnerConnection extends IServiceConnection.Stub {
            final WeakReference<LoadedApk.ServiceDispatcher> mDispatcher;

            InnerConnection(LoadedApk.ServiceDispatcher sd) {
                mDispatcher = new WeakReference<LoadedApk.ServiceDispatcher>(sd);
            }

            public void connected(ComponentName name, IBinder service, boolean dead)
                    throws RemoteException {
                LoadedApk.ServiceDispatcher sd = mDispatcher.get();
                if (sd != null) {
                    sd.connected(name, service, dead);
                }
            }
        }
  
        public void connected(ComponentName name, IBinder service, boolean dead) {
            if (mActivityThread != null) {
                mActivityThread.post(new RunConnection(name, service, 0, dead));
            } else {
                doConnected(name, service, dead);
            }
        }
  
  			...
}
```

`mActivityThread`是一个Handler对象，指向的就是`ActivityThread.H`。因此可以通过调用`post()`直接发送`RunConnection`对象的内容运行在主线程中。**mActivityThread不可能为空。**

```java
private final class RunConnection implements Runnable {
            RunConnection(ComponentName name, IBinder service, int command, boolean dead) {
                mName = name;
                mService = service;
                mCommand = command;
                mDead = dead;
            }

            public void run() {
                if (mCommand == 0) {
                    doConnected(mName, mService, mDead);
                } else if (mCommand == 1) {
                    doDeath(mName, mService);
                }
            }

            final ComponentName mName;
            final IBinder mService;
            final int mCommand;
            final boolean mDead;
        }
```

调用了`RunConnection`实际上还是调用了`doConnected()`

```java
ServiceConnection mConnection;
public void doConnected(ComponentName name, IBinder service, boolean dead) {
            ServiceDispatcher.ConnectionInfo old;
            ServiceDispatcher.ConnectionInfo info;

            synchronized (this) {
            ...
            // 如果存在老Service 会优先断掉连接
            if (old != null) {
                mConnection.onServiceDisconnected(name);
            }
            // Service已消失 死亡回调
            if (dead) {
                mConnection.onBindingDied(name);
            }
            // 全新的Service 通知绑定成功
            if (service != null) {
                mConnection.onServiceConnected(name, service);
            }
        }
```

```java
//使用场景 
private ServiceConnection mConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
           //绑定成功回调
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            
        }
    };
```

<!-- 为什么bindservice不会触发onStartCommanad-->



### Service解绑过程 - unbindService()

Service的解绑过程也是从`ContextWrapper`开始

```java
    @Override
    public void unbindService(ServiceConnection conn) {
        mBase.unbindService(conn);
    }
```

实际调用的是`ContextImpl.unbindService()`

```java
// ../android/app/ContextImpl.java
    @Override
    public void unbindService(ServiceConnection conn) {
        if (conn == null) {
            throw new IllegalArgumentException("connection is null");
        }
        if (mPackageInfo != null) {
            IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(
                    getOuterContext(), conn);
            try {
                ActivityManager.getService().unbindService(sd);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        } else {
            throw new RuntimeException("Not supported in system context");
        }
    }
```

这里主要分为两部分：

- `LoadedApk.forgetServiceDispatcher()`

  ```java
  // ../android/app/LoaderApk.java
  public final IServiceConnection forgetServiceDispatcher(Context context,
              ServiceConnection c) {
          synchronized (mServices) {
              //获取当前存储的ServiceConnection
              ArrayMap<ServiceConnection, LoadedApk.ServiceDispatcher> map
                      = mServices.get(context);
              LoadedApk.ServiceDispatcher sd = null;
              if (map != null) {
                  //获取对应的ServiceDispatcher
                  sd = map.get(c);
                  if (sd != null) {
                      if (DEBUG) Slog.d(TAG, "Removing dispatcher " + sd + " for conn " + c);
                      map.remove(c);
                      sd.doForget();
                      if (map.size() == 0) {
                          mServices.remove(context);
                      }
                      if ((sd.getFlags()&Context.BIND_DEBUG_UNBIND) != 0) {
                          ArrayMap<ServiceConnection, LoadedApk.ServiceDispatcher> holder
                                  = mUnboundServices.get(context);
                          if (holder == null) {
                              holder = new ArrayMap<ServiceConnection, LoadedApk.ServiceDispatcher>();
                              mUnboundServices.put(context, holder);
                          }
                          RuntimeException ex = new IllegalArgumentException(
                                  "Originally unbound here:");
                          ex.fillInStackTrace();
                          sd.setUnbindLocation(ex);
                          holder.put(c, sd);
                      }
                      return sd.getIServiceConnection();
                  }
              }
          ...
            
      }
  ```

  在这个函数中移除掉存储的映射关系

- `AMS.unbindService()`

  ```java
  // ../core/java/android/com/server/am/ActivityManagerService.java
      public boolean unbindService(IServiceConnection connection) {
          synchronized (this) {
              return mServices.unbindServiceLocked(connection);
          }
      }
  ```

  

调用到`ActiveServices.unbindServiceLocked()`

```java
// ../core/java/android/com/server/am/ActiveServices.java
 boolean unbindServiceLocked(IServiceConnection connection) {
        IBinder binder = connection.asBinder();
        if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, "unbindService: conn=" + binder);
        ArrayList<ConnectionRecord> clist = mServiceConnections.get(binder);
        if (clist == null) {
            Slog.w(TAG, "Unbind failed: could not find connection for "
                  + connection.asBinder());
            return false;
        }

        final long origId = Binder.clearCallingIdentity();
        try {
            while (clist.size() > 0) {
                ConnectionRecord r = clist.get(0);
                //移除掉对应Service的绑定
                removeConnectionLocked(r, null, null);
                
                ...
                //从映射表中移除对应的ServiceConnection
              
            }

            mAm.updateOomAdjLocked();

        } finally {
            Binder.restoreCallingIdentity(origId);
        }

        return true;
    }

 void removeConnectionLocked(
        ConnectionRecord c, ProcessRecord skipApp, ActivityRecord skipAct) {
        IBinder binder = c.conn.asBinder();
        AppBindRecord b = c.binding;
        ServiceRecord s = b.service;
        ArrayList<ConnectionRecord> clist = s.connections.get(binder);
        if (clist != null) {
            clist.remove(c);
            if (clist.size() == 0) {
                s.connections.remove(binder);
            }
        }
        b.connections.remove(c);
        ...
        if (!c.serviceDead) {
            if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, "Disconnecting binding " + b.intent
                    + ": shouldUnbind=" + b.intent.hasBound);
            if (s.app != null && s.app.thread != null && b.intent.apps.size() == 0
                    && b.intent.hasBound) {
                try {
                    bumpServiceExecutingLocked(s, false, "unbind");
                    if (b.client != s.app && (c.flags&Context.BIND_WAIVE_PRIORITY) == 0
                            && s.app.setProcState <= ActivityManager.PROCESS_STATE_RECEIVER) {
                        // If this service's process is not already in the cached list,
                        // then update it in the LRU list here because this may be causing
                        // it to go down there and we want it to start out near the top.
                        mAm.updateLruProcessLocked(s.app, false, null);
                    }
                    mAm.updateOomAdjLocked(s.app, true);
                    b.intent.hasBound = false;
                    // Assume the client doesn't want to know about a rebind;
                    // we will deal with that later if it asks for one.
                    b.intent.doRebind = false;
                    s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());
                } catch (Exception e) {
                    Slog.w(TAG, "Exception when unbinding service " + s.shortName, e);
                    serviceProcessGoneLocked(s);
                }
            }

          ...
          //如果是利用 BIND_AUTO_CREATE的flag就会向下调用
          if ((c.flags&Context.BIND_AUTO_CREATE) != 0) {
                boolean hasAutoCreate = s.hasAutoCreateConnections();
                if (!hasAutoCreate) {
                    if (s.tracker != null) {
                        s.tracker.setBound(false, mAm.mProcessStats.getMemFactorLocked(),
                                SystemClock.uptimeMillis());
                    }
                }
                //这里走的是stopService的流程
                bringDownServiceIfNeededLocked(s, true, hasAutoCreate);
            }
        }
    }
```

又看到了熟悉的`app.thread`就知道切换回到了`ActivityThread`

```java
// ../android/app/ActivityThread.java
public final void scheduleUnbindService(IBinder token, Intent intent) {
            BindServiceData s = new BindServiceData();
            s.token = token;
            s.intent = intent;

            sendMessage(H.UNBIND_SERVICE, s);
        }

private void handleUnbindService(BindServiceData data) {
        Service s = mServices.get(data.token);
        if (s != null) {
            try {
                data.intent.setExtrasClassLoader(s.getClassLoader());
                data.intent.prepareToEnterProcess();
                //调用到 onUnbind() 生命周期
                boolean doRebind = s.onUnbind(data.intent);
                try {
                    if (doRebind) {
                        //需要重新绑定
                        ActivityManager.getService().unbindFinished(
                                data.token, data.intent, doRebind);
                    } else {
                        //取消绑定
                        ActivityManager.getService().serviceDoneExecuting(
                                data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
                    }
                } catch (RemoteException ex) {
                    throw ex.rethrowFromSystemServer();
                }
            } catch (Exception e) {
                ...
            }
        }
    }
```

当Service调用`onUnbind()`之后，还需要做一件事情，如果是靠`bindService()`并配置`flag`为`BIND_AUTO_CREATE`。那么后续还会执行到`stopService()`中的流程，即会调用到`Service.onDestroy()`。

```java
// ../core/java/android/com/server/am/ActiveServices.java
 void removeConnectionLocked(
//如果是利用 BIND_AUTO_CREATE的flag就会向下调用
          if ((c.flags&Context.BIND_AUTO_CREATE) != 0) {
                boolean hasAutoCreate = s.hasAutoCreateConnections();
                if (!hasAutoCreate) {
                    if (s.tracker != null) {
                        s.tracker.setBound(false, mAm.mProcessStats.getMemFactorLocked(),
                                SystemClock.uptimeMillis());
                    }
                }
                //这里走的是stopService的流程
                bringDownServiceIfNeededLocked(s, true, hasAutoCreate); //true true
            }
   }
```

```java
private final void bringDownServiceIfNeededLocked(ServiceRecord r, boolean knowConn,
            boolean hasConn) {
        //由于bindService过程中的Service不是由startService()进行启动的，所有这里可以向下执行
        if (isServiceNeededLocked(r, knowConn, hasConn)) {
            return;
        }
        // Are we in the process of launching?
        if (mPendingServices.contains(r)) {
            return;
        }
        bringDownServiceLocked(r);
    }

private final boolean isServiceNeededLocked(ServiceRecord r, boolean knowConn,
            boolean hasConn) {
        // 是否由startService()执行
        if (r.startRequested) {
            return true;
        }
        // Is someone still bound to us keeping us running?
        if (!knowConn) {
            hasConn = r.hasAutoCreateConnections();
        }
        if (hasConn) {
            return true;
        }
        return false;
    }

```

{% fullimage /images/Service解绑过程.png,Service解绑过程,Service解绑过程%}

### Service停止过程 - stopService()

还是由`ContextWrapper.stopService()`开始执行

```java
    @Override
    public boolean stopService(Intent name) {
        return mBase.stopService(name);
    }
```

向下执行到`ContextImpl.stopService()`中

```java
    @Override
    public boolean stopService(Intent service) {
        warnIfCallingFromSystemProcess();
        return stopServiceCommon(service, mUser);
    }

    private boolean stopServiceCommon(Intent service, UserHandle user) {
        try {
            validateServiceIntent(service);
            service.prepareToLeaveProcess(this);
            int res = ActivityManager.getService().stopService(
                mMainThread.getApplicationThread(), service,
                service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());
            if (res < 0) {
                throw new SecurityException(
                        "Not allowed to stop service " + service);
            }
            return res != 0;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }

```

`ActivityManager.getService()`实际就是指向`ActivityManagerService`的一个Binder对象

```java
// ../core/java/android/com/server/am/ActivityManagerService.java   
@Override
    public int stopService(IApplicationThread caller, Intent service,
            String resolvedType, int userId) {
        enforceNotIsolatedCaller("stopService");
        // Refuse possible leaked file descriptors
        if (service != null && service.hasFileDescriptors() == true) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }

        synchronized(this) {
            return mServices.stopServiceLocked(caller, service, resolvedType, userId);
        }
    }
```

`mServices`是`ActiveServices`的一个实际对象。

```java
int stopServiceLocked(IApplicationThread caller, Intent service,
            String resolvedType, int userId) {
        ...
        // If this service is active, make sure it is stopped.
        ServiceLookupResult r = retrieveServiceLocked(service, resolvedType, null,
                Binder.getCallingPid(), Binder.getCallingUid(), userId, false, false, false);
        if (r != null) {
            if (r.record != null) {
                final long origId = Binder.clearCallingIdentity();
                try {
                    stopServiceLocked(r.record);
                } finally {
                    Binder.restoreCallingIdentity(origId);
                }
                return 1;
            }
            return -1;
        }

        return 0;
    }

    private void stopServiceLocked(ServiceRecord service) {
        ...
        service.startRequested = false;
        if (service.tracker != null) {
            service.tracker.setStarted(false, mAm.mProcessStats.getMemFactorLocked(),
                    SystemClock.uptimeMillis());
        }
        service.callStart = false;
        bringDownServiceIfNeededLocked(service, false, false);
    }

    private final boolean isServiceNeededLocked(ServiceRecord r, boolean knowConn,
            boolean hasConn) {
        // Are we still explicitly being asked to run?
        if (r.startRequested) {
            return true;
        }

        if (!knowConn) {
            hasConn = r.hasAutoCreateConnections();
        }
        if (hasConn) {
            return true;
        }

        return false;
    }

    private final void bringDownServiceIfNeededLocked(ServiceRecord r, boolean knowConn,
            boolean hasConn) {
        if (isServiceNeededLocked(r, knowConn, hasConn)) {
            return;
        }

        if (mPendingServices.contains(r)) {
            return;
        }

        bringDownServiceLocked(r);
    }
```

最后调用到了`bringDownServiceLocked()`

```java
private final void bringDownServiceLocked(ServiceRecord r) {    
  ...
     if (r.app != null) {
            synchronized (r.stats.getBatteryStats()) {
                r.stats.stopLaunchedLocked();
            }
            r.app.services.remove(r);
            if (r.whitelistManager) {
                updateWhitelistManagerLocked(r.app);
            }
            if (r.app.thread != null) {
                updateServiceForegroundLocked(r.app, false);
                try {
                    bumpServiceExecutingLocked(r, false, "destroy");
                    mDestroyingServices.add(r);
                    r.destroying = true;
                    mAm.updateOomAdjLocked(r.app, true);
                    r.app.thread.scheduleStopService(r);
                } catch (Exception e) {
                    Slog.w(TAG, "Exception when destroying service "
                            + r.shortName, e);
                    serviceProcessGoneLocked(r);
                }
            } else {
                if (DEBUG_SERVICE) Slog.v(
                    TAG_SERVICE, "Removed service that has no process: " + r);
            }
        } else {
            if (DEBUG_SERVICE) Slog.v(
                TAG_SERVICE, "Removed service that is not running: " + r);
        }
  ...
}
```

`app.thread`切换到`ApplicaitonThread`继续执行流程

```java
// ../android/app/ActivityThread.java
public final void scheduleStopService(IBinder token) {
            sendMessage(H.STOP_SERVICE, token);
        }

private void handleStopService(IBinder token) {
        Service s = mServices.remove(token);
        if (s != null) {
            try {
                if (localLOGV) Slog.v(TAG, "Destroying service " + s);
                s.onDestroy();
                s.detachAndCleanUp();
                Context context = s.getBaseContext();
                if (context instanceof ContextImpl) {
                    final String who = s.getClassName();
                    ((ContextImpl) context).scheduleFinalCleanup(who, "Service");
                }

                QueuedWork.waitToFinish();

                try {
                    ActivityManager.getService().serviceDoneExecuting(
                            token, SERVICE_DONE_EXECUTING_STOP, 0, 0);
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            } catch (Exception e) {
                ...
            }
        } else {
           ...
        }
      
    }
```

最后执行到`Service.onDestroy`完成停止流程。

{% fullimage /images/Service停止流程.png,Service停止流程,Service停止流程%}

## 拓展

为什么Activity退出时`bindService()`的Service会一并销毁？

观察源码发现，`bindService()`也会去启动Service，但为什么没有回调到`onStartCommand()`？]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关及其拓展(六) -- Java与线程</title>
    <url>/2018/12/18/JVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%85%AD/</url>
    <content><![CDATA[
# Java与线程

## 线程的实现

线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程间既可以共享进程资源，又可以独立调度(`线程是CPU调度的基本单位`)。

实现线程主要有三种方式：

- ### 使用内核线程实现

  > 直接由操作系统内核支持的线程。
  >
  > 由内核来完成切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。

  `多线程内核`：有能力处理多件事情，支持多线程的内核

  `轻量级进程`：内核线程的一种高级接口。`只有先支持内核线程，才能有轻量级进程`

  - 优点：每个轻量级进程都是一个独立的调度单元，即使有一个在系统调用中堵塞了，也不影响整个进程继续工作。
  - 缺点：各种线程操作都需要进行系统调用，代价相对高，需要在**用户态和内核态**中来回切换。另外轻量级进程的数量是有限的。
  - 轻量级进程与内核线程是1:1的关系

- ### 使用用户线程实现

  > 广义：一个线程只要不是内核线程，就可以认为是用户线程
  >
  > 狭义：完全建立在用户空间的线程库上，而系统内核不能感知线程存在的实现

  - 优点：线程的建立、同步、销毁和调度都在用户态中完成，不需要内核参与，所以操作时非常快速且低消耗，还支持更大的线程数量
  - 缺点：没有系统内核的支持，所有线程操作都需要用户程序自己处理，实现较复杂
  - 进程与用户线程之间是1:N的关系

- ### 使用用户线程加轻量级进程混合实现

  > 既存在用户线程，也存在轻量级进程。

  - 优点：用户线程还是在用户空间中，还可以支持大规模的用户线程并发；轻量级进程可以作为内核线程和用户线程之间的桥梁，用户线程的系统调用需要轻量级进程来完成，大大降低了系统被阻塞的危险。
  - 采用多对多的线程模型。

Java线程的实现是不能确定的。**由于操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的。**

## 线程调度

> 系统为线程分配处理器使用权的过程。

主要调度方式有两种：

- ### 协同式线程调度

  > 线程的执行时间有 **线程本身** 控制，线程把自己的工作执行完后，要主动通知系统切换到另一个线程上。

  - 优点：实现简单，切换操作可知，基本不存在线程同步问题
  - 缺点：线程执行时间不可控

- ### 抢占式线程调度

  > 每个线程由系统分配执行时间，线程的切换不由线程本身决定

  - 线程执行时间是可控的，不存在因为一个线程而堵塞整个系统的问题

  - 可以设置**线程优先级**，优先级越高的线程越容易被系统选择执行

    `线程优先级并不是太靠谱，一方面线程调度还是取决于操作系统，优先级的实现不会太一致。另一方面优先级会被系统自行改变。`

## 线程状态转换

> 在任意时间点，一个线程有且只有一个状态

{% fullimage /images/Thread-State.png,线程状态转换,线程状态转换%}

- ### 新建

  > 线程创建后尚未启动的线程状态

- ### 运行

  > 包括正在执行和等待着CPU为它分配执行时间

- ### 无限期等待

  > 不会被分配CPU执行时间，要等待被其他线程显示的唤醒。以下方法会让线程陷入无限期的等待状态：
  >
  > 1. 没有设置Timeout参数的`Object,wait()`
  > 2. 没有设置Timeout参数的`Thread.join()`
  > 3. `LockSupport.park()`

- ### 限期等待

  > 不会被分配CPU执行时间，但在一定时间后会被系统唤醒。以下方法会让线程进入限期等待状态：
  >
  > 1. `Thread.sleep()`
  > 2. 设置Timeout参数的`Object,wait()`
  > 3. 设置Timeout参数的`Thread.join()`
  > 4. `LockSupport.parkNanos()`
  > 5. `LockSupport.parkUntil()`

- ### 阻塞

  > 线程被阻塞了 在程序等待进入同步区域的时候进入这种状态。
  >
  > **阻塞状态**：等待着获取到一个**排他锁**，将在另一个线程放弃这个锁的时候发生
  >
  > **等待状态**：在等待一段时间或者唤醒动作的发生

- ### 结束

  > 线程已经结束执行]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Android屏幕的刷新机制</title>
    <url>/2020/05/30/View%E7%9A%84%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[
![View屏幕刷新](/images/View屏幕刷新xmind.png)

## 基础概念

在显示系统中，一般包含三个部分`CPU、GPU，屏幕`。

`CPU`：执行View的绘制流程`measure,layout.draw`

`GPU`：进一步处理数据，对图形数据进行渲染并放到`buffer缓冲区`中缓存

`屏幕`：将`buffer缓冲区`的数据取出来填充屏幕像素点



**CPU绘制后提交数据，GPU进一步处理和缓存数据、最后屏幕从缓冲区获取数据并显示。**

![img](/images/webp-20200911191007410)

### 屏幕刷新频率

> 一秒内屏幕刷新的次数也即显示了多少帧的图像，单位`Hz`。一般都是60Hz。*该值取决于屏幕参数*

### 逐行扫描

> 屏幕不是一次性进行画面显示，而是从左到右，从上到下的进行`逐行扫描`。

### 帧率

> **GPU一秒内绘制操作的帧数。**Android系统默认60fps

帧率是动态变化的。

### 丢帧

> 在下一个`Vsync`信号到来时，由于下一帧数据尚未准备就绪，缓存没有交换，此时显示的上一帧的数据。该情况就为**丢帧(Jank)**

![丢帧](/images/丢帧.png)

### 双缓冲(`Double Buffer`)

> 为了解决`画面撕裂`提出的概念
>
> 画面撕裂：在GPU向缓冲区写入数据的同时，屏幕也在从`buffer缓冲区`读取数据，导致屏幕显示了不同帧的画面，产生`画面撕裂`。

由绘制和屏幕拥有各自的`buffer缓冲区`：

`GPU`处理完数据后，将图形数据写入`Back Buffer`。

`屏幕`从`Frame Buffer`读取图形数据。

当屏幕刷新(Vsync信号到来)时，`FrameBuffer`与`BackBuffer`的数据进行交换(**交换各自的内存地址**)，然后屏幕进行绘制。与`屏幕刷新频率`保持一个交换频率。

![双缓冲示意](/images/双缓冲)

### 垂直同步(`VSync`)

> **通过屏幕硬件中断告诉系统应该什么时候刷新屏幕。**
>
> 开启后GPU会等待显示器的VSync信号发出后再进行新的一帧渲染和缓冲区更新。
>
> 在显卡帧率大于屏幕帧率时有效解决显示问题。

配合`双缓冲`可以使`CPU/GPU`有充分时间处理数据，减少`jank(丢帧)`

![VSync](/images/VSync.png)

每次收到`VSync`信号时，CPU开始处理各帧数据。

### 三缓冲(`Triple Buffer`)

> 在`双缓冲`机制基础上增加了一个`Graphic Buffer`缓冲区，最大限度利用空闲时间，但是会多占用一个`Graphic buffer`缓冲区内存。

![三缓存](/images/三缓冲.png)

1. 第一个`Jank`时无可避免的，在第二个时间段，CPU/GPU使用第三个`Graphic Buffer`完成`C帧`的计算，避免`Jank`问题频发
2. 在第三段时，`A帧`计算完成，需要到第四个`Vsync`信号才会显示。
3. 第二段中，`C帧`需要在第四段才可以显示，相当于多了16ms延迟。

> **三缓冲**有效利用等待`vsync`的时间，减少了`jank`，但是增加了延迟。
>
> **`Graphic Buffer`不是越多越好，一般还是两个，出现`jank`以后可以三个。**



### Project Buffer(黄油计划)

前面提到的`VSYnc`、`双缓冲/三缓冲`都是`Project Buffer`的关键点，还有下面需要提到的`Choreographer`.

- 核心关键：**VSync**实现定时中断
- `双缓冲/三缓冲`：一般情况下`双缓冲`足矣，当出现`jank`时，可以添加一块`Graphic Buffer`缓冲区，实现`三缓冲`
- `Choreographer`：统一管理应用的绘制工作



## Choreographer

![View屏幕刷新-Choreographer](/images/View屏幕刷新-Choreographer.png)

> Android4.1 之后加入的`Choreographer`控制`Input输入`、`Animation动画`，`Draw绘制`三个UI操作。
>
> 每隔16.6ms，`VSync`信号到来时，马上开始下一帧的渲染，**CPU和GPU立即开始计算把数据写入Buffer中。**



![img](/images/15722752299458.jpg)

### 入口

既然说`Choreographer`与`View`的显示有关，`View的绘制过程`起点位于`ViewRootImpl.setView()`，此处为*Activity执行到`onResume()`后，`window`添加到Activity上*。通过调用到`ViewRootImpl.setView()`开始绘制布局

```java
//ActivityThread.java
public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,
            String reason) {
  ...
    if (a.mVisibleFromClient) {
                if (!a.mWindowAdded) {//尚未添加window
                    a.mWindowAdded = true;
                    wm.addView(decor, l);//准备添加View
                } else {
                    // The activity will get a callback for this {@link LayoutParams} change
                    // earlier. However, at that time the decor will not be set (this is set
                    // in this method), so no action will be taken. This call ensures the
                    // callback occurs with the decor set.
                    a.onWindowAttributesChanged(l);
                }
            }
  ...
  
}

//WindowManagerGlobal.java WindowManager实现类
    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
      ...
        ViewRootImpl root;
      ...
        root = new ViewRootImpl(view.getContext(), display);
      ...
        try {
                root.setView(view, wparams, panelParentView);
            } catch (RuntimeException e) {
                // BadTokenException or InvalidDisplayException, clean up.
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
                throw e;
            }
      ...
    }

//ViewRootImpl.java
   public void setView(View view /*DecorView*/, WindowManager.LayoutParams attrs, View panelParentView) {
     ...
       requestLayout();//刷新布局
     ...
       view.assignParent(this); //设置DecorView 父类为 ViewRootImpl，此时将ViewRootImpl与DecorView进行绑定
     ...
   }
//View.java
    void assignParent(ViewParent parent) {
        if (mParent == null) {
            mParent = parent;
        } else if (parent == null) {
            mParent = null;
        } else {
            throw new RuntimeException("view " + this + " being added, but"
                    + " it already has a parent");
        }
    }

//ViewRootImpl.java
    @Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            checkThread();
            mLayoutRequested = true;
            scheduleTraversals();
        }
    }
```

根据上述源码可以得出以下结论：

- Activity走完`onResume()`之后会进行`window的添加`
- `window添加`过程中在`ViewRootImpl.setView()`中将`DecorView`与`ViewRootImpl`进行绑定
- `ViewRootImpl`与`DecorView`绑定后开始进行View的绘制任务

> 为什么`onCreate()`无法获取View宽高？
>
> 此时未执行到`onResume()`尚未开始绘制，也还没开始执行`measure -> layout -> draw`过程，也就无法获取。

以上只是`Activity启动`时相关的绘制过程，此外还有`属性动画、View.invalidate()`都会影响到`UI变化`。

**所有的UI变化都是走到`ViewRootImpl.scheduleTraversals()`。**



#### ViewRootImpl.scheduleTraversals()

`UI变化`最终都会走到此处。

```java
//ViewRootImpl.java
    final ViewRootHandler mHandler = new ViewRootHandler();

    void scheduleTraversals() {
        if (!mTraversalScheduled) {
          //保证多次调用UI刷新，只走一次绘制流程
            mTraversalScheduled = true;
          //添加同步屏障，屏蔽同步消息，保证Vsync到来时优先绘制流程
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
          //使用到了 Choreographer
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            ...
        }
    }

    final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            doTraversal();
        }
    }
    final TraversalRunnable mTraversalRunnable = new TraversalRunnable();

    void doTraversal() {
        if (mTraversalScheduled) {
          //执行任务时，恢复状态
            mTraversalScheduled = false;
          //移除同步屏障
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            if (mProfile) {
                Debug.startMethodTracing("ViewAncestor");
            }
           //开始View的绘制流程
            performTraversals();

            if (mProfile) {
                Debug.stopMethodTracing();
                mProfile = false;
            }
        }
    }

```

`scheduleTraversals()`主要有以下逻辑：

1. 设置`mTraversalScheduled)`保证同时多次请求只会进行一次`View刷新`
2. 在`getLooper().getQueue()当前消息队列`添加**同步屏障**，保证`Vsync信号`到来时，可以立即执行对应任务。暂时屏蔽掉`同步消息`的处理。
3. 调用`Choreographer.postCallback(,mTraversalRunnable,)`，在下一次`VSync信号到来时`，会执行`doTraversal()`，继续向下调用`performTraversals()`开始绘制流程。

### 构造函数

```java
//Choreographer.java
    public static Choreographer getInstance() {
        return sThreadInstance.get();
    }

    private static final ThreadLocal<Choreographer> sThreadInstance =
            new ThreadLocal<Choreographer>() {
        @Override
        protected Choreographer initialValue() {
            //获取当前线程的Looper对象
            Looper looper = Looper.myLooper();
            if (looper == null) {
                throw new IllegalStateException("The current thread must have a looper!");
            }
            Choreographer choreographer = new Choreographer(looper, VSYNC_SOURCE_APP);
            if (looper == Looper.getMainLooper()) {
                mMainInstance = choreographer;
            }
            return choreographer;
        }
    };
```

`Choreographer`和`Handler`中的`Looper`一致，都是每个线程持有一个`Choreographer`，通过`ThreadLocal`进行获取。

接下来是`Choreographer`的构造方法

```java
//Choreographer.java    
private Choreographer(Looper looper, int vsyncSource) {
        mLooper = looper;
       //创建Handler对象
        mHandler = new FrameHandler(looper);
       //接收Vsync信号
        mDisplayEventReceiver = USE_VSYNC //USE_VSYNC在4.1以上默认 true，表示可以接收VSync信号
                ? new FrameDisplayEventReceiver(looper, vsyncSource)
                : null;
        //上一次帧绘制的时间点
        mLastFrameTimeNanos = Long.MIN_VALUE;
        //每帧的差值，一般为16.6ms
        mFrameIntervalNanos = (long)(1000000000 / getRefreshRate());
        //初始化回调队列
        mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];
        for (int i = 0; i <= CALLBACK_LAST; i++) {
            mCallbackQueues[i] = new CallbackQueue();
        }
        // b/68769804: For low FPS experiments.
        setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, 1));
    }

```

`Choreographer`在构造时分别执行了以下几步：

- 初始化`FrameHandler(接收并处理消息)`
- 初始化`FrameDisplayEventReceiver(接收VSync信号)`
- 初始化`mLastFrameTimeNanos(上一次绘制帧时间点)`、`mFrameIntervalNanos(帧率)`
- 初始化`mCallbackQueues(回调队列)`

#### FrameHandler

> 发送异步消息（设置了同步屏障）。有延迟的任务发送延迟消息，不在主线程的任务发到主线程。

```java
    private final class FrameHandler extends Handler {
        public FrameHandler(Looper looper) {
            super(looper);
        }

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_DO_FRAME:
                //执行绘制过程
                    doFrame(System.nanoTime(), 0);
                    break;
                case MSG_DO_SCHEDULE_VSYNC:
                //当需要执行绘制任务时，申请VSync信号
                    doScheduleVsync();
                    break;
                case MSG_DO_SCHEDULE_CALLBACK:
                //执行需要延迟的任务
                    doScheduleCallback(msg.arg1);
                    break;
            }
        }
    }
```

主要处理以下类型的消息：

- `MSG_DO_FRAME`：开始绘制流程
- `MSG_DO_SCHEDULE_VSYNC`：请求VSync信号
- `MSG_DO_SCHEDULE_CALLBACK`：请求执行`Callback`



#### FrameDisplayEventReceiver

> 主要用来接收`VSync信号`，控制系统的同步操作

```java
private final class FrameDisplayEventReceiver extends DisplayEventReceiver
            implements Runnable {
        private boolean mHavePendingVsync;
        private long mTimestampNanos;
        private int mFrame;

        public FrameDisplayEventReceiver(Looper looper, int vsyncSource) {
            super(looper, vsyncSource);
        }

  //此处接收 VSync信号
        @Override
        public void onVsync(long timestampNanos, int builtInDisplayId, int frame) {
            if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {
                Log.d(TAG, "Received vsync from secondary display, but we don't support "
                        + "this case yet.  Choreographer needs a way to explicitly request "
                        + "vsync for a specific display to ensure it doesn't lose track "
                        + "of its scheduled vsync.");
                scheduleVsync();
                return;
            }
          
            long now = System.nanoTime();
            if (timestampNanos > now) {
                Log.w(TAG, "Frame time is " + ((timestampNanos - now) * 0.000001f)
                        + " ms in the future!  Check that graphics HAL is generating vsync "
                        + "timestamps using the correct timebase.");
                timestampNanos = now;
            }

            if (mHavePendingVsync) {
                Log.w(TAG, "Already have a pending vsync event.  There should only be "
                        + "one at a time.");
            } else {
                mHavePendingVsync = true;
            }
          //VSync信号到来的时间
            mTimestampNanos = timestampNanos;
            mFrame = frame;
          //构建异步消息，传入本身作为任务的执行者，需要执行的任务就是 run()
            Message msg = Message.obtain(mHandler, this);
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
        }

  //需要执行的任务
        @Override
        public void run() {
            mHavePendingVsync = false;
            doFrame(mTimestampNanos, mFrame);
        }
    }
```

接收到`VSync信号`后，回调到`onVsync()`方法，在其中构造一个`异步消息`，传入`FrameDisplayEventReceiver`为`runnable`，通过`FrameHandler`发送该消息，等到消息触发时就执行`doFrame()`。



#### CallbackQueue

> 存储对应任务类型的队列，在执行任务时从对应队列中获取任务

```java
    private final class CallbackQueue {
        private CallbackRecord mHead;

      //当前是否有等待执行的任务
        public boolean hasDueCallbacksLocked(long now) {
            return mHead != null && mHead.dueTime <= now;
        }

      //获取队列任务
        public CallbackRecord extractDueCallbacksLocked(long now) {
            CallbackRecord callbacks = mHead;
            if (callbacks == null || callbacks.dueTime > now) {
                return null;
            }

            CallbackRecord last = callbacks;
            CallbackRecord next = last.next;
            while (next != null) {
                if (next.dueTime > now) {
                    last.next = null;
                    break;
                }
                last = next;
                next = next.next;
            }
            mHead = next;
            return callbacks;
        }

      //添加消息
        public void addCallbackLocked(long dueTime, Object action, Object token) {
            CallbackRecord callback = obtainCallbackLocked(dueTime, action, token);
            CallbackRecord entry = mHead;
            if (entry == null) {
                mHead = callback;
                return;
            }
            if (dueTime < entry.dueTime) {
                callback.next = entry;
                mHead = callback;
                return;
            }
            while (entry.next != null) {
                if (dueTime < entry.next.dueTime) {
                    callback.next = entry.next;
                    break;
                }
                entry = entry.next;
            }
            entry.next = callback;
        }

      //删除消息
        public void removeCallbacksLocked(Object action, Object token) {
            CallbackRecord predecessor = null;
            for (CallbackRecord callback = mHead; callback != null;) {
                final CallbackRecord next = callback.next;
                if ((action == null || callback.action == action)
                        && (token == null || callback.token == token)) {
                    if (predecessor != null) {
                        predecessor.next = next;
                    } else {
                        mHead = next;
                    }
                    recycleCallbackLocked(callback);
                } else {
                    predecessor = callback;
                }
                callback = next;
            }
        }
    }
```

`CallbackQueue`存储的元素为`CallbackRecord`

```java
    private static final class CallbackRecord {
        public CallbackRecord next;
        public long dueTime;
        public Object action; // Runnable or FrameCallback
        public Object token;

        public void run(long frameTimeNanos) {
            if (token == FRAME_CALLBACK_TOKEN) {
              //执行了postFrameCallback()或 postFrameCallbackDelayed 执行此处
                ((FrameCallback)action).doFrame(frameTimeNanos);
            } else {
              //否则执行 run
                ((Runnable)action).run();
            }
        }
    }
```

根据源码`CallbackRecord`执行`run()`有两种情况：

- token不为null且`FRAME_CALLBACK_TOKEN`

  > 执行`doFrame()`，实际这种情况只会执行`postFrameCallback()`或`postFrameCallbackDelayed()`。
  >
  > 这两个方法在{% post_link Android动画-属性动画%}都会被调用到

- token为其他

  > 执行`run()`，此时`action`对应的就是`ViewRootImpl的mTraversalRunnable`也就会开始执行绘制流程

### 设置任务-postCallback()

`ViewRootImpl.scheduleTraversals()`通过`postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)`添加绘制任务

```java
//Choreographer.java 
private void postCallbackDelayedInternal(int callbackType,
            Object action, Object token, long delayMillis) {
        ...
        synchronized (mLock) {
          //当前时间
            final long now = SystemClock.uptimeMillis();
          //延迟时间
            final long dueTime = now + delayMillis;
          //将任务添加到回调队列
            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);

            if (dueTime <= now) {
              //任务立即开始执行
                scheduleFrameLocked(now);
            } else {
              //封装异步消息等待执行
                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
                msg.arg1 = callbackType;
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, dueTime);
            }
        }
    }

  private final class FrameHandler extends Handler {
     ...
     @Override
     public void handleMessage(Message msg) {
       ...
        case MSG_DO_SCHEDULE_CALLBACK:
           doScheduleCallback(msg.arg1);
           break;
     }
    }

    void doScheduleCallback(int callbackType) {
        synchronized (mLock) {
            if (!mFrameScheduled) {
                final long now = SystemClock.uptimeMillis();
                if (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) {
                    scheduleFrameLocked(now);
                }
            }
        }
    }
```

`CallbackType`表示回调任务的类型，目前分为4种类型

- `CALLBACK_INPUT`：输入回调，接收到`VSync信号`时首先运行，如处理Move事件
- `CALLBACK_ANIMATION`：动画回调
- `CALLBACK_TRAVERSAL`：Traversal回调，执行`measure->layout->draw`
- `CALLBACK_COMMIT`：Commit回调，处理帧绘制完成后的操作，如整理应用内存，属性动画起始时间调整

`postCallback()`最后都会执行到`scheduleFrameLocked()`

```java
 private void scheduleFrameLocked(long now) {
        if (!mFrameScheduled) {//当前是否有帧在执行
            mFrameScheduled = true;
            if (USE_VSYNC) {//支持VSync，默认true
                if (DEBUG_FRAMES) {
                    Log.d(TAG, "Scheduling next frame on vsync.");
                }
              
                //当前运行在Looper所在的线程，立即执行申请VSync信号
                if (isRunningOnLooperThreadLocked()) {
                    scheduleVsyncLocked();
                } else {
                  //通过 mHandler发送异步消息到原线程，申请VSync信号
                    Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);
                    msg.setAsynchronous(true);
                    mHandler.sendMessageAtFrontOfQueue(msg);
                }
            } else {//不支持 VSync
                final long nextFrameTime = Math.max(
                        mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);
                if (DEBUG_FRAMES) {
                    Log.d(TAG, "Scheduling next frame in " + (nextFrameTime - now) + " ms.");
                }
                //执行 doFrame()
                Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextFrameTime);
            }
        }
    }

    private final class FrameHandler extends Handler {
      ...
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_DO_FRAME:
                    doFrame(System.nanoTime(), 0);
                    break;
                case MSG_DO_SCHEDULE_VSYNC:
                    doScheduleVsync();
                    break;
                ...
            }
        }
    }

    void doScheduleVsync() {
        synchronized (mLock) {
            if (mFrameScheduled) {
                scheduleVsyncLocked();
            }
        }
    }
```

`postCallback()`主要执行了以下几步：

1. 实际执行的为`postCallbackDelayedInternal()`，先将任务通过`addCallbackLocked()`添加到`CallbackQueue`中
2. 判断任务执行时间与当前时间的差值
   - 执行时间在当前时间之前：直接执行`scheduleFrameLocked()`
   - 执行时间在当前时间之后：将任务封装成`异步消息`，通过`mHandler`发送消息，且消息为`MSG_CO_SCHEDULE_CALLBACK`。到达执行时间之后，也是执行`scheduleFrameLocked()`
3. 执行`scheduleFrameLocked()`，需要先判断`mFrameSchduled`，在执行跳过此次任务；未执行，继续判断`是否支持VSync`
   - 不支持`VSync`：封装异步消息，且消息为`MSG_DO_FRAME`，发送消息到主线程，执行`doFrame()`
   - 支持`VSync`：需要判断当前是否为UI线程
     - 是UI线程：立即执行`scheduleVsyncLocked()`
     - 非UI线程：封装异步消息，且消息为`MSG_DO_SCHEDULE_VSYNC`，发送消息到主线程，后执行`scheduleVsyncLocked()`
4. 执行`scheduleVsyncLocked()`去申请`Vsync信号`。

> 简单总结`postCallback()`
>
> 

### 申请和接收信号-onVsync()

上一节调用的`scheduleVsyncLocked()`申请`VSync信号`

```java
    private void scheduleVsyncLocked() {
        mDisplayEventReceiver.scheduleVsync();
    }

//DisplayEventReceiver.java
    public void scheduleVsync() {
        if (mReceiverPtr == 0) {
            Log.w(TAG, "Attempted to schedule a vertical sync pulse but the display event "
                    + "receiver has already been disposed.");
        } else {
            nativeScheduleVsync(mReceiverPtr);
        }
    }
```

`nativeScheduleVsync()`调用native方法申请`VSync信号`



```java
//DisplayEventReceiver.java
    // Called from native code.
    @SuppressWarnings("unused")
    private void dispatchVsync(long timestampNanos, int builtInDisplayId, int frame) {
        onVsync(timestampNanos, builtInDisplayId, frame);
    }
```

通过native调用`dispatchVsync()`回调`onVsync()`



```java
//Chorgegrapher.FrameDisplayEventReceiver.java
    private final class FrameDisplayEventReceiver extends DisplayEventReceiver
            implements Runnable {
      ...
      @Override
      public void onVsync(long timestampNanos, int builtInDisplayId, int frame) {
       ...
            Message msg = Message.obtain(mHandler, this);
            msg.setAsynchronous(true);
            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
      }
      
        @Override
        public void run() {
            mHavePendingVsync = false;
            doFrame(mTimestampNanos, mFrame);
        }
    }
```

将本身作为`runnable`对象，执行的就是`run()`，最终执行的就是`doFrame()`

### 执行任务-doFrame()

> 最终在接收到`VSync`信号时，执行`doFrame()`

```java
    void doFrame(long frameTimeNanos, int frame) {
        final long startNanos;
        synchronized (mLock) {//
            if (!mFrameScheduled) {//当前有任务在执行
                return; // no work to do
            }
            ...
            //预期执行时间
            long intendedFrameTimeNanos = frameTimeNanos;
            //实际frame执行时间
            startNanos = System.nanoTime();
            //预期与实际时间差
            final long jitterNanos = startNanos - frameTimeNanos;
            if (jitterNanos >= mFrameIntervalNanos) {//时间差大于一帧执行时长，当前为16.6ms
                final long skippedFrames = jitterNanos / mFrameIntervalNanos;//计算跳过的帧数
                if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {//默认30
                    //跳过的帧数超出了30时，打印日志
                    Log.i(TAG, "Skipped " + skippedFrames + " frames!  "
                            + "The application may be doing too much work on its main thread.");
                }
                //重新计算实际执行与当前时间的偏差值
                final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
                if (DEBUG_JANK) {
                    Log.d(TAG, "Missed vsync by " + (jitterNanos * 0.000001f) + " ms "
                            + "which is more than the frame interval of "
                            + (mFrameIntervalNanos * 0.000001f) + " ms!  "
                            + "Skipping " + skippedFrames + " frames and setting frame "
                            + "time to " + (lastFrameOffset * 0.000001f) + " ms in the past.");
                }
                //修正偏差值，方便后续同步工作
                frameTimeNanos = startNanos - lastFrameOffset;
            }

          //当前时间小于上一次绘制时间，就等待下一次绘制时机到老
            if (frameTimeNanos < mLastFrameTimeNanos) {
                if (DEBUG_JANK) {
                    Log.d(TAG, "Frame time appears to be going backwards.  May be due to a "
                            + "previously skipped frame.  Waiting for next vsync.");
                }
                scheduleVsyncLocked();
                return;
            }

            if (mFPSDivisor > 1) {
                long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;
                if (timeSinceVsync < (mFrameIntervalNanos * mFPSDivisor) && timeSinceVsync > 0) {
                    scheduleVsyncLocked();
                    return;
                }
            }

            mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
            mFrameScheduled = false;
          //记录上一次绘制时间
            mLastFrameTimeNanos = frameTimeNanos;
        }

        try {
           //按类型顺序执行任务
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#doFrame");
            AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);

            mFrameInfo.markInputHandlingStart();
            //输入
            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);

            mFrameInfo.markAnimationsStart();
            //动画
            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);

            mFrameInfo.markPerformTraversalsStart();
            //绘制
            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);
            //遍历完成的提交操作
            doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
        } finally {
            AnimationUtils.unlockAnimationClock();
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }

        if (DEBUG_FRAMES) {
            final long endNanos = System.nanoTime();
            Log.d(TAG, "Frame " + frame + ": Finished, took "
                    + (endNanos - startNanos) * 0.000001f + " ms, latency "
                    + (startNanos - frameTimeNanos) * 0.000001f + " ms.");
        }
    }
```

`doFrame()`主要执行了两步：

1. 修正`frame`执行时间
2. 按照顺序，从`callbackQueue`获取`CallbackRecord`执行

```java
void doCallbacks(int callbackType, long frameTimeNanos) {
        CallbackRecord callbacks;
        synchronized (mLock) {
            // We use "now" to determine when callbacks become due because it's possible
            // for earlier processing phases in a frame to post callbacks that should run
            // in a following phase, such as an input event that causes an animation to start.
            final long now = System.nanoTime();
            //根据回调类型获取可执行回调(已到达执行时间)
            callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(
                    now / TimeUtils.NANOS_PER_MS);
            if (callbacks == null) {
                return;
            }
            mCallbacksRunning = true;

            ...
            //属于 提交任务类型
            if (callbackType == Choreographer.CALLBACK_COMMIT) {
                final long jitterNanos = now - frameTimeNanos;
                Trace.traceCounter(Trace.TRACE_TAG_VIEW, "jitterNanos", (int) jitterNanos);
                if (jitterNanos >= 2 * mFrameIntervalNanos) {
                    final long lastFrameOffset = jitterNanos % mFrameIntervalNanos
                            + mFrameIntervalNanos;
                    if (DEBUG_JANK) {
                        Log.d(TAG, "Commit callback delayed by " + (jitterNanos * 0.000001f)
                                + " ms which is more than twice the frame interval of "
                                + (mFrameIntervalNanos * 0.000001f) + " ms!  "
                                + "Setting frame time to " + (lastFrameOffset * 0.000001f)
                                + " ms in the past.");
                        mDebugPrintNextFrameTimeDelta = true;
                    }
                    frameTimeNanos = now - lastFrameOffset;
                    mLastFrameTimeNanos = frameTimeNanos;
                }
            }
        }
        try {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);
            //迭代执行对应 callbackType队列的任务
            for (CallbackRecord c = callbacks; c != null; c = c.next) {
                if (DEBUG_FRAMES) {
                    Log.d(TAG, "RunCallback: type=" + callbackType
                            + ", action=" + c.action + ", token=" + c.token
                            + ", latencyMillis=" + (SystemClock.uptimeMillis() - c.dueTime));
                }
              //回调CallbackRecord的run()
                c.run(frameTimeNanos);
            }
        } finally {
            synchronized (mLock) {
                mCallbacksRunning = false;
                do {
                    final CallbackRecord next = callbacks.next;
                    recycleCallbackLocked(callbacks);
                    callbacks = next;
                } while (callbacks != null);
            }
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }

private static final class CallbackRecord {
        ...
        public void run(long frameTimeNanos) {
            if (token == FRAME_CALLBACK_TOKEN) {
              //执行了postFrameCallback()或 postFrameCallbackDelayed 执行此处
                ((FrameCallback)action).doFrame(frameTimeNanos);
            } else {
              //否则执行 run
                ((Runnable)action).run();
            }
        }
    }
```

`doCallbacks()`主要执行了以下几步：

1. `extractDueCallbacksLocked(now/TimeUtils.NANOS_PER_MS)`获取当前时间之前所有可执行的Callback，保存在单链表中。

2. 关于`CALLBACK_COMMIT`的处理，如果当前`frame`渲染时间超出了两个`Vsync`间隔，将当前提交时间修正为上一次`VSync信号`发出时间。**为了保证下一个frame的提交时间和当前frame的时间相差为1且不重复**。

   `CALLBACK_COUNT`是为了解决`属性动画`的问题引入的，有时候可能因遍历时间或绘制时间过长，导致动画启动时间过长，发生跳帧，在此处**修正动画的第一帧时间**。

   ![img](/images/CALLBACK_COMMIT作用)

   修正了动画启动时间，保证动画执行时间的正确性。

3. 最后取出`CallbackRecord`，执行`run()`



![View刷新过程](/images/View刷新过程.jpg)



## Vsync申请和回调流程(Native)

### 申请Vsync信号



`frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp`

`frameworks/native/libs/gui/DisplayEventDispatcher.cpp`

> 从`nativeScheduleVsync()`开始监听`VSync信号`

```java
//DisplayEventReceiver.java
    private static native void nativeScheduleVsync(long receiverPtr);

    //初始化
    public DisplayEventReceiver(Looper looper, int vsyncSource) {
        if (looper == null) {
            throw new IllegalArgumentException("looper must not be null");
        }

        mMessageQueue = looper.getQueue();
        mReceiverPtr = nativeInit(new WeakReference<DisplayEventReceiver>(this), mMessageQueue,
                vsyncSource);

        mCloseGuard.open("dispose");
    }
```

> 执行`nativeInit()`初始化并创建`DisplayEventReceiver`

```c++
//android_view_DisplayEventReceiver.cpp
static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak,
        jobject messageQueueObj, jint vsyncSource, jint configChanged) {
    sp<MessageQueue> messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
    if (messageQueue == NULL) {
        jniThrowRuntimeException(env, "MessageQueue is not initialized.");
        return 0;
    }
    //创建NAtiveDisplayEventReceiver，与DurfaceFlinger建立连接
    sp<NativeDisplayEventReceiver> receiver = new NativeDisplayEventReceiver(env,
            receiverWeak, messageQueue, vsyncSource, configChanged);
    status_t status = receiver->initialize();
    if (status) {
        String8 message;
        message.appendFormat("Failed to initialize display event receiver.  status=%d", status);
        jniThrowRuntimeException(env, message.string());
        return 0;
    }

    receiver->incStrong(gDisplayEventReceiverClassInfo.clazz); // retain a reference for the object
    return reinterpret_cast<jlong>(receiver.get());
}

NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env,
        jobject receiverWeak, const sp<MessageQueue>& messageQueue, jint vsyncSource,
        jint configChanged) :
        DisplayEventDispatcher(messageQueue->getLooper(),
                static_cast<ISurfaceComposer::VsyncSource>(vsyncSource),
                static_cast<ISurfaceComposer::ConfigChanged>(configChanged)),
        mReceiverWeakGlobal(env->NewGlobalRef(receiverWeak)),
        mMessageQueue(messageQueue) {
    ALOGV("receiver %p ~ Initializing display event receiver.", this);
}
```



新建完`DisplayEventReceiver`，由`DisplayEventDispatcher`进行后续操作

```c++
//DisplayEventReceiver.h
class DisplayEventDispatcher : public LooperCallback {
  public:
    explicit DisplayEventDispatcher(
            const sp<Looper>& looper,
            ISurfaceComposer::VsyncSource vsyncSource = ISurfaceComposer::eVsyncSourceApp,
            ISurfaceComposer::ConfigChanged configChanged =
                    ISurfaceComposer::eConfigChangedSuppress);
   ...
     
    private:
    sp<Looper> mLooper;
    DisplayEventReceiver mReceiver;
    ...
      
}


//DisplayEventDispatcher.cpp
DisplayEventDispatcher::DisplayEventDispatcher(const sp<Looper>& looper,
                                               ISurfaceComposer::VsyncSource vsyncSource,
                                               ISurfaceComposer::ConfigChanged configChanged)
      : mLooper(looper), mReceiver(vsyncSource, configChanged), mWaitingForVsync(false) {
    ALOGV("dispatcher %p ~ Initializing display event dispatcher.", this);
}
```

```c++
//DisplayEventReceiver.cpp
DisplayEventReceiver::DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource,
                                           ISurfaceComposer::ConfigChanged configChanged) {
    sp<ISurfaceComposer> sf(ComposerService::getComposerService());
    if (sf != nullptr) {
        //为客户端创建显示连接，通过该连接请求SurfaceFlinger发送及接收Vsync信号
        mEventConnection = sf->createDisplayEventConnection(vsyncSource, configChanged);
        if (mEventConnection != nullptr) {
            //创建BitTube
            mDataChannel = std::make_unique<gui::BitTube>();
            //通过Binder获取对应Connection的Socket
            mEventConnection->stealReceiveChannel(mDataChannel.get());
        }
    }
}
```

#### createDisplayEventConnection

`createDisplayEventConnection()`是一个Binder IPC

```c++
//ISurfaceComposer.cpp
    virtual sp<IDisplayEventConnection> createDisplayEventConnection(VsyncSource vsyncSource,
                                                                     ConfigChanged configChanged) {
        Parcel data, reply;
        sp<IDisplayEventConnection> result;
        int err = data.writeInterfaceToken(
                ISurfaceComposer::getInterfaceDescriptor());
        if (err != NO_ERROR) {
            return result;
        }
        data.writeInt32(static_cast<int32_t>(vsyncSource));
        data.writeInt32(static_cast<int32_t>(configChanged));
        //请求SurfaceLinger处理 CREATE_DISPLAY_EVENT_CONNECTION
        err = remote()->transact(
                BnSurfaceComposer::CREATE_DISPLAY_EVENT_CONNECTION,
                data, &reply);
        if (err != NO_ERROR) {
            ALOGE("ISurfaceComposer::createDisplayEventConnection: error performing "
                    "transaction: %s (%d)", strerror(-err), -err);
            return result;
        }
        result = interface_cast<IDisplayEventConnection>(reply.readStrongBinder());
        return result;
    }
```

在`onTransact()`处理发过来的`CREATE_DISPLAY_EVENT_CONNECTION`

```c++
//ISurfaceComposer.cpp
status_t BnSurfaceComposer::onTransact(
    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
  ...
          case CREATE_DISPLAY_EVENT_CONNECTION: {
            CHECK_INTERFACE(ISurfaceComposer, data, reply);
            auto vsyncSource = static_cast<ISurfaceComposer::VsyncSource>(data.readInt32());
            auto configChanged = static_cast<ISurfaceComposer::ConfigChanged>(data.readInt32());

            sp<IDisplayEventConnection> connection(
                    createDisplayEventConnection(vsyncSource, configChanged));
            reply->writeStrongBinder(IInterface::asBinder(connection));
            return NO_ERROR;
        }
  ...
}
```

通过`SurfaceFlinger`处理请求

```c++
sp<IDisplayEventConnection> SurfaceFlinger::createDisplayEventConnection(
        ISurfaceComposer::VsyncSource vsyncSource, ISurfaceComposer::ConfigChanged configChanged) {
    const auto& handle =
            vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;

    return mScheduler->createDisplayEventConnection(handle, configChanged);
}
```

```c++
//EventThread.cpp
sp<EventThreadConnection> Scheduler::createConnectionInternal(
        EventThread* eventThread, ISurfaceComposer::ConfigChanged configChanged) {
    return eventThread->createEventConnection([&] { resync(); }, configChanged);
}

sp<IDisplayEventConnection> Scheduler::createDisplayEventConnection(
        ConnectionHandle handle, ISurfaceComposer::ConfigChanged configChanged) {
    RETURN_IF_INVALID_HANDLE(handle, nullptr);
    return createConnectionInternal(mConnections[handle].thread.get(), configChanged);
}

sp<EventThreadConnection> EventThread::createEventConnection(
        ResyncCallback resyncCallback, ISurfaceComposer::ConfigChanged configChanged) const {
    return new EventThreadConnection(const_cast<EventThread*>(this), std::move(resyncCallback),
                                     configChanged);
}
```

最后生成`EventConnection`对象，主要有两个作用：

- 处理客户的的Vsync申请请求
- 向客户端发送事件(Vsync)

```c++
//EventThread.cpp
EventThreadConnection::EventThreadConnection(EventThread* eventThread,
                                             ResyncCallback resyncCallback,
                                             ISurfaceComposer::ConfigChanged configChanged)
      : resyncCallback(std::move(resyncCallback)),
        mConfigChanged(configChanged),
        mEventThread(eventThread),
        mChannel(gui::BitTube::DefaultSize) {}
```

`BitTube`是一个`Socket pair`，主要有两个作用：

- 封装用于显示时间的Socket通信
- 跨进程传递Socket文件描述符(`fd`)

```c++
void EventThreadConnection::onFirstRef() {
    // NOTE: mEventThread doesn't hold a strong reference on us
    mEventThread->registerDisplayEventConnection(this);
}

status_t EventThread::registerDisplayEventConnection(const sp<EventThreadConnection>& connection) {
    std::lock_guard<std::mutex> lock(mMutex);

    // this should never happen
    auto it = std::find(mDisplayEventConnections.cbegin(),
            mDisplayEventConnections.cend(), connection);
    if (it != mDisplayEventConnections.cend()) {
        ALOGW("DisplayEventConnection %p already exists", connection.get());
        mCondition.notify_all();
        return ALREADY_EXISTS;
    }
    //添加连接到集合中
    mDisplayEventConnections.push_back(connection);
    mCondition.notify_all();
    return NO_ERROR;
}

```

`EventThread`与`EventThreadConnection`采用`观察者模式`，当有显示事件发生时，`EventThread`向`EventThreadConnection`传递事件。

#### stealReceiveChannel

通过一系列操作得到`EventConnection`，在向下执行到`stealReceiveChannel()`

```c++
class BpDisplayEventConnection : public SafeBpInterface<IDisplayEventConnection> {
  ...
        status_t stealReceiveChannel(gui::BitTube* outChannel) override {
        return callRemote<decltype(
                &IDisplayEventConnection::stealReceiveChannel)>(Tag::STEAL_RECEIVE_CHANNEL,
                                                                outChannel);
    }
  ...
}
  
status_t BnDisplayEventConnection::onTransact(uint32_t code, const Parcel& data, Parcel* reply,
                                              uint32_t flags) {
    if (code < IBinder::FIRST_CALL_TRANSACTION || code > static_cast<uint32_t>(Tag::LAST)) {
        return BBinder::onTransact(code, data, reply, flags);
    }
    auto tag = static_cast<Tag>(code);
    switch (tag) {
        case Tag::STEAL_RECEIVE_CHANNEL:
            return callLocal(data, reply, &IDisplayEventConnection::stealReceiveChannel);
        ...
    }
}
```



监听`mReceivcer`所获的文件句柄，一旦有数据到来，回调给`this`即`DisplayEventDispatcher`的`handleEvent()`

```c++
status_t DisplayEventDispatcher::initialize() {
    status_t result = mReceiver.initCheck();
    if (result) {
        ALOGW("Failed to initialize display event receiver, status=%d", result);
        return result;
    }

    if (mLooper != nullptr) {
        int rc = mLooper->addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT, this, NULL);
        if (rc < 0) {
            return UNKNOWN_ERROR;
        }
    }

    return OK;
}
```



> `FrameDisplayEventReceiver`



### 回调Vsync信号

收到`Vsync信号`后，回调到`DisplayEventDispatcher.handleEvent()`

```c++
int DisplayEventDispatcher::handleEvent(int, int events, void*) {
    if (events & (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) {
        ALOGE("Display event receiver pipe was closed or an error occurred.  "
              "events=0x%x",
              events);
        return 0; // remove the callback
    }

    if (!(events & Looper::EVENT_INPUT)) {
        ALOGW("Received spurious callback for unhandled poll event.  "
              "events=0x%x",
              events);
        return 1; // keep the callback
    }

    // Drain all pending events, keep the last vsync.
    nsecs_t vsyncTimestamp;
    PhysicalDisplayId vsyncDisplayId;
    uint32_t vsyncCount;
    if (processPendingEvents(&vsyncTimestamp, &vsyncDisplayId, &vsyncCount)) {
        ALOGV("dispatcher %p ~ Vsync pulse: timestamp=%" PRId64
              ", displayId=%" ANDROID_PHYSICAL_DISPLAY_ID_FORMAT ", count=%d",
              this, ns2ms(vsyncTimestamp), vsyncDisplayId, vsyncCount);
        mWaitingForVsync = false;
        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);
    }

    return 1; // keep the callback
}
```

回调到`handleEvent()`在向下执行到`dispatchVsync()`

```c++
//android_view_DisplayEventReceiver.cpp
void NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, PhysicalDisplayId displayId,
                                               uint32_t count) {
    JNIEnv* env = AndroidRuntime::getJNIEnv();

    ScopedLocalRef<jobject> receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal));
    if (receiverObj.get()) {
        ALOGV("receiver %p ~ Invoking vsync handler.", this);
        env->CallVoidMethod(receiverObj.get(),
                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, displayId, count);
        ALOGV("receiver %p ~ Returned from vsync handler.", this);
    }

    mMessageQueue->raiseAndClearException(env, "dispatchVsync");
}
```

此处调用到`DisplayEventReceiver.dispatchVsync()`

## Handler异步消息与同步屏障

在`ViewRootImpl.schdeuleTraversals()`执行`mHandler.getLooper().getQueue().postSyncBarrier()`添加`同步屏障`，在`doTraversal()`执行`removeSyncBarrier()`移除`同步屏障`。

`同步屏障`：为了**提高异步消息优先级，保证Vsync信号和绘制的同步。**

{%post_link  Handler机制即源码解析%}



## 总结

![总结](/images/View屏幕刷新-总结.png)

**丢帧**：这一帧的内容延迟显示，因为只有收到`VSync信号`才会进行Buffer交换。主要原因一般都是：**布局层级较多或主线程耗时导致CPU/GPU执行时间变长，超出`16.6ms`就会导致丢帧**。

一般屏幕的固定刷新率是`60Hz`，换算就是`60帧`，即每`16.6ms`切换一帧。

屏幕内容的绘制也是如此，没有绘制任务(没执行`scheduleTraversals()`)就不会执行绘制流程，但是**底层仍然会每隔16.6ms切换下一帧画面，只不过一直显示相同的内容**。当有绘制任务时，执行完`measure->layout->draw`流程后，依然需要等待收到`VSync信号`界面才会刷新。

`VSync信号`发生在*扫描完一个屏幕后，需要从最下面回到第一行继续循环，此时会发出该信号保证双缓冲(CPU/GPU)数据交换*。

在同一时间多次调用`requestLayout()/invalidate()`不会导致多次页面刷新，由于`mTraversalScheduled`的设置，当存在任务的时候，就会过滤重复请求，因为**最后的请求都会执行到`ViewRootImpl.scheduleTraversals()`，只要一次绘制就可以刷新所有View**。

`Choreographer`主要为了**在VSync信号到来时开始处理消息即CPU/GPU绘制**。



## 其他

![其他](/images/View屏幕刷新-其他知识.png)

1. 利用`Choreographer.postFrameCallback(frameCallback)`统计丢帧状况

   `postFrameCallback()`会在每次frame渲染的时候回调一次，然后执行`frameCallback.doFrame()`，在`doFrame()`可以获取每一帧的渲染时间然后判断是否发生丢帧

   ```java
   Choreographer.getInstance().postFrameCallback(new TestFrameCallback())
   
   public class TestFrameCallback implements Choreographer.FrameCallback {
     @Override
     public void doFrame(long frameTimeNanos){
       ...
       //计算帧率 or others
         
       //注册下一帧回调  
       Choreographer.getInstance().postFrameCallback(this);
     }
   }
   ```

2. `Choreographer.CALLBACK_INPUT`使用场景？

   {%post_link Android事件分发%}

## 参考链接

{%post_link View的工作原理%}

[Choreographer原理](http://gityuan.com/2017/02/25/choreographer/)

[Android Code Search](cs.android.com)

[Android-Choreographer](https://androidperformance.com/2019/10/22/Android-Choreographer/)

[Android与SurfaceFlinger建立连接过程](https://www.jianshu.com/p/304f56f5d486)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler机制源码解析(二)</title>
    <url>/2018/10/07/Handler%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C/</url>
    <content><![CDATA[
# 主要包括Handler其他使用知识点

{% fullimage /images/Handler拓展知识点.png,Handler拓展知识点,Handler拓展知识点%}

## 1. 子线程创建Handler对象

> 不可以直接在子线程创建Handler对象，因为Handler对象必须要绑定一个Looper，才可以使用。
>
> 若在子线程需要使用Handler，则需要先创建一个Looper对象即执行`Looper.prepare()`然后再创建Handler对象时调用`Looper.myLooper()`获取Looper对象传入方法，最后调用`Looper.loop()`开始运行。

```kotlin
class MyActivity : Activity{
    lateinit var mThread: MyThread
    lateinit var mHandler: MyHandler
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.act_main)
        //初始化子线程
        mThread = Mythread()
        mThread.start()
        //需要发出的消息
        val message = Message.obtain()
        message.obj = "test"
        //初始化Handler
        mHandler = MyHandler(this, mThread.childLooper)
        //发送消息
        mHandler.sendMessage(message)
    }
    
    //子线程
    class MyThread : Thread() {
        var childLooper: Looper? = null
        override fun run() {
            Looper.prepare()
            childLooper = Looper.myLooper()
            Looper.loop()
        }
    }
    
    //安全的Handler写法
     class MyHandler(activity: MyActivity, looper: Looper?) : Handler(looper) {
        var mWeakRe: WeakReference<MyActivity> = WeakReference(activity)

        override fun handleMessage(msg: Message?) {
            super.handleMessage(msg)
            val activity: MyActivity? = mWeakRe.get()
            if (activity!=null){
                //添加handlerMessage需要处理的逻辑
            }
        }
    }
}
```

以上代码执行完毕后就可以在子线程调用Handler对象。

**但是，在多次执行过程中，会有<font color = 'red'>java.lang.NullPointerException: Attempt to read from field 'android.os.MessageQueue android.os.Looper.mQueue' on a null object reference</font>空指针导致应用崩溃。**调试过程中发现是由于Looper对象为空导致的异常。由于**在子线程`run()`初始化了Looper对象，Handler对象的初始化依然继续执行，Looper对象此时尚未初始化好，导致空指针异常。**

由于这种情况的出现是随机的，不是百分百重现，为了保证应用的运行就需要引入`HandlerThread`这个类，可以帮我们解决这个问题。

```kotlin
//HandlerThread示例代码
class MyActivity : Activity{
    lateinit var mHandler: MyHandler
    var mHandlerThread: HandlerThread?=null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.act_main)
        //初始化HandlerThread并指定线程名字为test
        mHandlerThread = HandlerThread("test",Process.THREAD_PRIORITY_BACKGROUND)
        mHandlerThread?.start()
        //需要发出的消息
        val message = Message.obtain()
        message.obj = "test"
        //初始化Handler
        mHandler = MyHandler(this, mHandlerThread?.looper)
        //发送消息
        mHandler.sendMessage(message)
    }
    
    //安全的Handler写法
    class MyHandler(activity: MyActivity, looper: Looper?) : Handler(looper) {
        var mWeakRe: WeakReference<MyActivity> = WeakReference(activity)

        override fun handleMessage(msg: Message?) {
            super.handleMessage(msg)
            val activity: MyActivity? = mWeakRe.get()
            if (activity!=null){
                //添加handlerMessage需要处理的逻辑
            }
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        //结束时停止thread
        mHandlerThread?.quit()
    }
}
```

以上代码执行完毕后即在HandlerThread可以调用Handler对象。

我们需要从源码去分析为什么使用`HandlerThread`可以避免上述异常，是怎样一个机制实现的。

```java
// 源码位置:../core/java/android/os/HandlerThread.java
public class HandlerThread extends Thread {
    ...
     //设置线程优先级 优先级主要分为UI线程和后台线程(Background)
    int mPriority;
    public HandlerThread(String name) {
        super(name);
        //默认标准App线程优先级
        mPriority = Process.THREAD_PRIORITY_DEFAULT;
    }
    
    public HandlerThread(String name, int priority) {
        super(name);
        mPriority = priority;
    }
    
    //可以重写这个方法，在内部新建Handler对象
    protected void onLooperPrepared() {
    }
    
    @Override
    public void run() {
        //获取到线程ID
        mTid = Process.myTid();
        //创建对应的Looper，MessageQueue对象
        Looper.prepare();
        synchronized (this) {
            //对mLooper进行赋值
            mLooper = Looper.myLooper();
            //唤醒等待Looper赋值而阻塞的所有线程
            notifyAll();
        }
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        Looper.loop();
        mTid = -1;
    }
    
    public Looper getLooper() {
        //判断当前线程是否存活 关闭则返回空
        if (!isAlive()) {
            return null;
        }
        
        // If the thread has been started, wait until the looper has been created.
        synchronized (this) {
            //mLooper==null表明当前Looper对象尚未初始化
            while (isAlive() && mLooper == null) {
                try {
                    //调用线程等待 直至初始化完成 阻塞其他线程
                    wait();
                } catch (InterruptedException e) {
                }
            }
        }
        //返回Looper对象
        return mLooper;
    }
    
    //内嵌一个可以直接引用的Handler对象，外部可以直接使用
    @NonNull
    public Handler getThreadHandler() {
        if (mHandler == null) {
            mHandler = new Handler(getLooper());
        }
        return mHandler;
    }
    
    //HandlerThread退出 同步于Looper.quit()
    public boolean quit() {
        Looper looper = getLooper();
        if (looper != null) {
            looper.quit();
            return true;
        }
        return false;
    }
    
    //HandlerThread退出 同步于Looper.quitSafely()
    public boolean quitSafely() {
        Looper looper = getLooper();
        if (looper != null) {
            looper.quitSafely();
            return true;
        }
        return false;
    }
}
```

总结：

- `HandlerThread`内嵌了Handler,Looper,MessageQueue对象
- `HandlerThread`内部使用`wait(),notifyAll()`等线程同步方式保证`mLooper`对象不会为空，`wait()`当Looper对象尚未初始化完成时阻塞其他线程，`notifyAll()`当mLooper对象不为空时，通知其他线程使用mLooper。

## 2. IdleHandler

> 当Looper里面的Message暂时处理完毕即**全部消息处理完毕或者阻塞等待新消息**时会调用`IdleHandler`这个类去处理一些空闲时间的消息。
>
> 继承`IdleHandler`这个接口，需要设置`queueIdle()`的返回值。若返回`false`则调用一次后会移除，为`true`则继续持有，空闲时依然会调用。
>
> 概括就是：**优先级别较低的`Message`，只有当`Looper`中没有消息要处理时，才会去处理`IdleHandler`。**

```kotlin
    //使用示例代码
    val message = Message.obtain()
    message.obj = "1234"
    handler.sendMessage(message)

    val delayMessage=Message.obtain()
    delayMessage.obj="12344"
    handler.sendMessageDelayed(delayMessage,3000)

    //子线程添加IdleHandler 限制API23以上使用
    mHandlerThread?.looper?.queue?.addIdleHandler(OnceIdleHandler())
    mHandlerThread?.looper?.queue?.addIdleHandler(ForeverIdleHandler())
    //主线程添加IdleHandler
    Looper.myQueue().addIdleHandler(OnceIdleHandler())
    Looper.myQueue().addIdleHandler(ForeverIdleHandler())

    //只使用一次的IdleHandler
    class OnceIdleHandler : MessageQueue.IdleHandler {
        override fun queueIdle(): Boolean {
            LogUtils.e("idle once")
            return false
        }
    }

    //一直持续存在的IdleHandler
    class ForeverIdleHandler : MessageQueue.IdleHandler {
        override fun queueIdle(): Boolean {
            LogUtils.e("idle forever")
            return true
        }
    }

    //需要移除IdleHandler 调用
     Looper.myQueue().removeIdleHandler(OnceIdleHandler())
     Looper.myQueue().removeIdleHandler(ForeverIdleHandler())
```

集成上述代码即可测试IdleHandler的使用，接下来要分析源码的实现以及使用场景。

```java
// 源码位置:../core/java/android/os/MessageQueue.java
   /**
     * IdleHandler定义
     * Callback interface for discovering when a thread is going to block
     * waiting for more messages.
     */
    public static interface IdleHandler {
        /**
         * Called when the message queue has run out of messages and will now
         * wait for more.  Return true to keep your idle handler active, false
         * to have it removed.  This may be called if there are still messages
         * pending in the queue, but they are all scheduled to be dispatched
         * after the current time.
         */
        boolean queueIdle();
    }
   //mIdleHandlers 是ArrayList型 故可以重复添加
   private final ArrayList<IdleHandler> mIdleHandlers = new ArrayList<IdleHandler>();
   //往MessageQueue中添加一个IdleHandler对象
   public void addIdleHandler(@NonNull IdleHandler handler) {
        if (handler == null) {
            throw new NullPointerException("Can't add a null IdleHandler");
        }
        synchronized (this) {
            //添加IdleHandler是线程安全的 
            mIdleHandlers.add(handler);
        }
    }
   
    //移除一个IdleHandler
    public void removeIdleHandler(@NonNull IdleHandler handler) {
        synchronized (this) {
            mIdleHandlers.remove(handler);
        }
    }

    //调用上述方法往mIdleHandlers添加或移除IdleHandler对象后 需要在next()方法中 去使用mIdleHandlers中的对象
   Message next() {
       //无限循环
       for(;;){
           ...
                // If first time idle, then get the number of idlers to run.
                // Idle handles only run if the queue is empty or if the first message
                // in the queue (possibly a barrier) is due to be handled in the future.
                if (pendingIdleHandlerCount < 0
                        && (mMessages == null || now < mMessages.when)) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount <= 0) {
                    // 判断当前没有空闲线程可执行 则继续堵塞
                    mBlocked = true;
                    continue;
                }

                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
       }
       
       // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
            for (int i = 0; i < pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler

                boolean keep = false;
                try {
                    //获取继承接口定义的queueIdle()返回值 判定后续是否需要继续执行
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG, "IdleHandler threw exception", t);
                }

                if (!keep) {
                    //不需要继续执行 则自动移除对象
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }
   }
```

## 3. Handler常见问题

### 1. 消息机制中的主要引用对象及其关系

> `Looper ，MessageQueue，Message，ThreadLocal，Handler `

1. Looper对象有一个MessageQueue,MessgaeQueue为一个消息队列来存储Message
2. Message中带有一个Handler对象，从Looper中取出消息后，可以直接调用到Handler的相关方法
3. Handler发送消息时会把自身封装进Message  `Message.ontain(Handler h ,int what,int arg1,int arg2,Object onj)`
4. Handler通过获取Looper对象中的MessageQueue插入消息来发送Message
5. Looper创建对象时会把自己保存至ThreadLocal中，并提供一个`public static Looper myLooper()`方法来返回一个Looper对象

### 2. Android主线程不会因为`Looper.loop()`死循环卡死

简单来说就是**循环里有阻塞`阻塞的原理是利用Linux的管道机制(PIPE/EPOLL)机制实现`，所以死循环不会一直执行，由于大部分时间都是没有消息的，所以主线程大部分处于休眠状态，也不会过度消耗CPU资源导致卡死。**

先说明进程和线程的区别：

> **进程**：每个app运行时首先会创建一个进程，该进程是由zygote fork出来的，用于承载运行app上的Activity/Service等组件。进程对于上层应用来说是完全透明的，目的是为了`让App都运行在Android Runtimr`。大多数情况下一个App运行在一个线程中，除非配置了`Android:Process`属性，或者通过native fork 进程。
>
> **线程**：线程比较常见，每次`new Thread().start()`都会创建一个新线程。并且与当前App所在进程之间资源共享。`在CPU看来进程或线程无非是一段可执行的代码，CPU采用CFS调度算法，保证每个task尽可能公平享有CPU时间片`。
>
> 拓展知识：CFS调度算法是一种完全公平调度算法，基本设计思路是根据各个进程的权重来分配运行时间**。

当进入死循环时又该如何处理其他事务呢？**需要创建新的线程去处理**。

主线程进入Looper的死循环后，需要处理 activity的各个生命周期的回调函数执行(`在同一个线程下，代码是按顺序执行的，如果死循环堵塞了，后续该如何执行`)。

```java
//源码地址 android/app/ActivityThread.java 
public static void main(String[] args){
    ...
    //Looper初始化
    Looper.prepareMainLooper();
    //new 一个ActivityThread并调用了attach方法
    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    if (false) {
       Looper.myLooper().setMessageLogging(new
             LogPrinter(Log.DEBUG, "ActivityThread"));
       }

       // End of event ActivityThreadMain.
       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
       Looper.loop();

       throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

源码中在初始化ActivityThread时也会初始化一个`H类型的成员，它继承了Handler`。

源码中调用`thread.attach(false)`时,**回去创建一个Binder进程（具体代指ApplicationThread,Binder的服务端，用于接收系统AMS发出来的事件），由Handler线程发送Message至主线程。**

所以在主线程开启Looper死循环之前，就已经启动了一个Binder线程并且准备了`H 这一个Handler类`，就可以用于处理一些死循环之外的事务。`仅需通过Binder线程向H发送消息即可`。

{% fullimage /images/activity_binder.png, App运行过程, App运行过程 %}

**system_server进程即为系统进程**，里面运行了大量的系统服务，比如上图提供了`ApplicationThreadProxy以及ActivityManagerService`，这两者都基于IBinder接口，都是Binder线程。

**App进程即为我们常说的应用程序**，主线程主要负责Activity等组件的生命周期以及UI绘制。每个App进程中至少会包括两个binder线程:`ApplicationThread和ActivityManagerProxy`。

**Binder用于不同进程间的通信，由一个进程的Binder客户端向另一个进程的服务端发送事务。**

**Handler则用于同一进程间不同线程的通信。**

### 3.主线程的消息模型

上图中绘制出主线程(ActivityThread)是如何循环的,简单的文字表达就是

> `ActivityManagerService(AMS)` ==直接调用==>`ApplicationThreadProxy(ATP)`==Binder==>`ApplicationThread`==Handler方式==>`ActivityThread`
>
> 主线程(ActivityThread)通过`ApplicationThread`和`ActivityManagerService`进行进程间通信，AMS以进程间通信的方式完成`ActivityThread`的请求后回调`ApplicationThread`中的Binder方法。然后由`ApplicationThread`向`ActivityThread`中的`H`发送消息，然后收到消息后 把处理逻辑发送至`ActivityThread`中去执行。



### 4.Message的触发统计

> Message是在MessageQueue中进行存放，事件的分发需要通过Looper.next()从`MessageQueue`中获取Message，`BlockCanary`就是通过计算事件分发的时间间隔来判断当前是否出现卡顿。

可以通过给Handler中的Looper对象设置`setMessageLogging()`，对事件的分发进行监听。

```java
Looper.getMainLooper().setMessageLogging(new Printer(){
  @Override
  public void println(String x){
    //x 包含了以下内容  Message.target Message.callback  Message.what
  }
})
```

]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字分析</title>
    <url>/2018/12/17/Java-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
<!--缓存一致性 指令重排序概念-->

{% fullimage /images/volatile.png,volatile相关概念,volatile相关概念%}

## volatile基础概念

***volatile的主要作用是保证可见性以及有序性，不一定保证原子性。***

**JVM提供的最轻量级的同步机制。**

当一个变量被`volatile`关键字修饰后，就会具备两层语义：

- **保证此变量对所有线程的可见性，这里指  当一条线程修改了这个变量的值，新值对于其他线程来说是立即可得知的。**
- **禁止进行指令重排序优化**

### volatile 保证可见性

在使用`volatile`关键字修饰一个变量后，该变量在一个线程中被修改后，会发生如下事情：

1. 修改后，修改的变量值会强制立即写入主内存中
2. 然后强制过期其他线程中工作内存中的缓存，使缓存无效
3. 由于缓存无效，其他线程需要读取该变量值时，会强制重新从主内存中读取

> 当访问共享变量时，多个线程也会在自己的工作内存中有一份共享变量的副本。当某个线程更改了自己工作内存中的数据时，由于某些原因（线程阻塞）没有及时的刷新数据至主内存，然后其他线程的工作内存中的数据还是老数据。就会导致`缓存一致性`问题。
>
> **缓存一致性**：当其他线程读取该变量时，发现该缓存是无效的，就会从主内存中重新读取。

{% fullimage /images/volatile-process.png,volatile可见性,volatile可见性%}



### volatile 保证有序性

`volatile`禁止指令重排序，可以在一定程度上保证有序性。

**指令重排序**：JVM为了优化指令，提高程序运行效率，在不影响**单线程**执行结果的前提下，尽可能的提高并行度。

volatile关键字通过提供“**内存屏障(重排序时不能把后面的指令重排序到内存屏障之前的位置)**”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。`加入volatile关键字的代码会多出一个lock前缀指令`。

内存屏障提供如下功能：

- 重排序时不会把后面的指令重排序到内存屏障之前的位置—`有序性`
- 本CPU的Cache立即写入内存，并且会引起别的CPU或者别的内核无效化其Cache，可以是对volatile变量的修改对其他CPU可见—`可见性`

`内存屏障`在`volatile`读写时是不同位置插入`lock`指令

- `volatile读`

  在`volatile读`操作后分别插入`LoadLoad`和`LoadStore`屏障

  {% fullimage /images/volatile读.webp,volatile读,volatile读%}

  `LoadLoad`屏障：禁止`volatile读`与后面的普通读进行重排序

  `LoadStore`屏障：禁止`volatile读`与后面的普通写进行重排序

- `volatile写`

  在`volatile写`操作前后分别插入`StoreStore`和`StoreLoad`屏障

  {% fullimage /images/volatile写.webp,volatile写,volatile写%}

  `StoreStore`屏障：保证`volatile写`之前的普通写操作已经对所有线程可见，该屏障保证**前面的所有普通写操作的值都刷新到主内存。**

  `StoreLoad`屏障：禁止`volatile写`与后面可能存在的`volatile读/写`进行重排序。

### volatile不保证原子性

`volatile`只能保证对单个volatile变量的读/写具有原子性，但是对于`volatile++`这样的复合操作没办法。

自增操作 `volatile++`实际执行了三步：

1. 读取变量的初始值
2. 在CPU中加1
3. 重新写入工作内存，在写入主内存

要想保证原子性，只能借助于`synchronized、Lock和java.util.concurrent.atomic包下的原子操作类`保证这些操作时原子性操作。



## volatile应用场景

`volatile`由于无法保证原子性，所以要使用必须具备以下两个条件：

- 对变量的写操作不依赖于当前值 

  ```java
  volatile int a = 0 ;
  a = a * 2;
  ```

- 该变量没有包含在具有其他变量的不变式中



  ***在多线程场景下，这两种情况即时使用`volatile`修饰，也有可能会有同步问题。***

## volatile使用实例

1. 状态量标记

   ```java
   volatile bool flag = true;
   
   public void write(){
       flag = false;
   }
   
   public void modify(){
       if(flag){
           doSth();
       }
   }
   ```

2. 单例模式的实现(DCL)

   ```java
   class Singleton{
       private Singleton(){
           
       }
       
       private volatile static Singleton sInstance;
       
       public static Singleton getInstence(){
           if(sInstance == null){
               synchronized(Sineleton.class){
                   if(sInstance == null){
                       sInstance = new Singleton();
                     /**
                     * 1.内存中创建对象
                     * 2.分配内存，并将指针指向内存区域
                     * 如果此时发生指令重排序，可能导致构造函数在初始化对象完成就赋值完成，导致其他线程获取对象为空，所以使用volatile进行修饰，避免指令重排序
                     */
                   }
               } 
           }
            return sInstance;
       }
   }
   ```

## volatile和 synchronized区别

- `volatile`仅能使用在变量级别，`synchronized`适用于变量、方法和类
- `volatile`仅能实现变量修改可见性，不保证原子性；`synchronized`可以保证可见性及原子性
- `volatile`不会造成线程的阻塞；`synchronized`会造成阻塞(`阻塞同步`)
- `volatile`由于禁止指令重排序，不会被编译器优化；`synchronized`会被优化



## 参考链接

[volatile](https://juejin.im/post/5ea913d35188256d4576d199#heading-17)]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-动画分析</title>
    <url>/2018/06/11/Android-%E5%8A%A8%E7%94%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
> Android的动画就可以分为3种：
>
> - View动画 `View Animation`
> - 帧动画 `Drawable Animation`
> - 属性动画 `Property Animation`

## 1.View动画

> View动画的作用对象是View。**View动画的View移动只是视觉效果，并不能真正的改变位置。**

### View动画的种类

| 种类       | 标签          | 子类               | 效果             |
| ---------- | ------------- | ------------------ | ---------------- |
| 平移动画   | `<translate>` | TranslateAnimation | 平移View         |
| 缩放动画   | `<scale>`     | ScaleAnimation     | 放大或者缩小View |
| 旋转动画   | `<rotate>`    | RotateAnimation    | 旋转View         |
| 透明度动画 | `<alpha>`     | AlphaAnimation     | View的透明度变化 |

### 使用View动画

要使用View动画，需要先创建动画的XML文件，这个文件的路径为`res/anim/animateFile.xml`。

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator=""
    android:shareInterpolator="[true | false]"
    android:fillAfter="true"
    android:duration='integar'>
    
    <translate
        android:fromXDelta="float"
        android:toXDelta="float"
        android:fromYDelta="float"
        android:toYDelta="float"/>
     <scale
        android:fromXScale="float"
        android:toXScale="float"
        android:fromYScale="float"
        android:toYScale="float"
        android:pivotX="float"
        android:pivotY="float"/>    
     <rotate
        android:fromDegrees="float"
        android:toDegrees="float"
        android:pivotY="float"
        android:pivotX="float"/>
    <alpha 
        android:fromAlpha="float"
        android:toAlpha="float"/>

</set>
```

*View动画既可以是单个动画，也可以由一系列动画组成。*

`<set>`：表示动画集合，对应`AnimationSet`，可以包含若干个动画，并且内部也可以嵌套其他动画集合。

- `android:interpolator`：表示动画集合所采用的插值器，插值器会影响到动画的速度。
- `android:shareInterpolator`：是否共享插值器。*如果不指定，子动画就需要单独指定插值器或者使用默认值。*
- `android:fillAfter`：表示动画结束时是否保持动画结束的状态。`false`回到动画初始样式
- `android:integar`：表示动画持续时长

`<translate>`：表示平移动画，对应`TranslateAnimation`

- `android:fromXDelta`：动画起始时X坐标上的位置。
- `android:toXDelta`：动画结束时X坐标上的位置。
- `android:fromYDelta`：动画起始时Y坐标上的位置。
- `android:toYDelta`：动画结束时Y坐标上的位置。

> 以上4个属性的取值可能为`数值，百分数，百分数P`，他们的含义有所区别：
>
> `数值`： 50 --> 以View左上角为原点，向正方向偏移50px
>
> `百分数` 50% --> 以View左上角为原点，向正方向偏移View宽/高的50%
>
> `百分数P` 50%P -> 以View左上角为原点，向正方向偏移父布局(parent)宽/高的50%；

`<scale>`：表示缩放动画，对应`ScaleAnimation`

- `android:fromXScale`动画起始时水平方向伸缩值。 
-  `android:toXScale`：动画结束时水平方向伸缩值。
-  `android:fromYScale`：动画起始时竖直方向伸缩值。
-  `android:toYScale`：动画结束时水平方向伸缩值。

> 以上4个属性的取值有不同的含义
>
> `值为0.0`  缩放比为0  代表缩放到原来的0 即消失
>
> `值<1.0`  缩放比小于1 代表缩小
>
> `值为1.0` 缩放比等于1 代表与原来相同
>
> `值>1.0` 缩放比大于1 代表放大

- `android:pivotX`：缩放轴点的X坐标。
- `android:pivotY`：缩放轴点的Y坐标。

> 以上两个属性表示 ，缩放的起始坐标，**取值为%**，*默认View的中心点，即50%,50%*。举个例子：如果`pivotX和pivotY`设置为0，即为左上角坐标，缩放时就是以左上角为原点向外向内。

`<rotate>`：表示旋转动画，对应`RotateAnimation`

- `android:fromDegrees`：动画起始时旋转的角度 。
- `android:toDegrees`：动画结束时旋转的角度。

> 以上两个属性共同确定旋转方向，原则是：当角度为**负**数时表示**逆时针**旋转，反之。
>
> 故共存在以下四种情况： 
>
> - from=负数 -> to=正数：表示顺时针旋转
> - from=负数 ->to =负数：表示逆时针旋转
> - from=正数 ->to =正数：表示顺时针旋转
> - from=正数 ->to=负数：表示逆时针旋转

- `android:pivotX`：旋转轴点的X坐标。
- `android:pivotY`：旋转轴点的Y坐标。

`<alpha>`：表示透明度动画，对应`AlphaAnimation`

- `android:fromAlpha`：动画起始时透明度。
- `android:toAlpha`动画结束时透明度。

> 以上两个属性取值范围为 0~1
>
> `值<=0` 代表完全透明
>
> `值>=1` 代表完全不透明

### 应用代码

> 通过XML文件构建

```xml
<!-- animationset.xml -->
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:shareInterpolator="true" >
    
    <translate
        android:duration="2000"
        android:fromXDelta="0"
        android:fromYDelta="0"
        android:toXDelta="100%"
        android:toYDelta="100%"> />
    <scale
       android:duration="2000"
       android:fromXScale="1.0"
       android:fromYScale="1.0"
       android:pivotX="50%"
       android:pivotY="50%"
       android:toXScale="0.5"
       android:toYScale="0.5" /> 
    <rotate
        android:duration="2000"
        android:fromDegrees="0"
        android:toDegrees="360"
        android:pivotX="50%"
        android:pivotY="50%"/>
     <alpha
       android:duration="2000"
       android:fromAlpha="1.0"
       android:toAlpha="0"/>   
</set>
```

```java
Animation animation = AnimationUtils.loadAnimation(this,R.anim.animationet);
view.startAnimation(animation);
animation.setAnimationListener(new AnimationListener(){
  void onAnimationStart(Animation animation){
    //动画开始
  }
  
  void onAnimationEnd(Animation animation){
    //动画结束
  }
  
  void onAnimationRepeat(Animation animation){
    //动画重复 设置 android:repeatMode="[restart | reverse]" 时触发
  }
})
```

> 通过Java构建

```java
AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0);
alphaAnimation.setDuration(2000);

AnimationSet animationSet = new AnimationSet(true);
animationSet.addAnimation(alphaAnimation);

view.startAnimation(animationSet);
```

### 自定义View动画

> 自定义View动画是为了 实现系统提供的无法满足的动画情况，例如`3D翻转效果`，无法简单组合就能实现，就需要用到自定义View动画。

实现步骤：`继承Animation -> 重写initialize()以及applyTransformation()方法 `

- `inltialize()`：初始化工作
- `allpyTransformation()`：进行相应的矩阵变换

#### 自定义View动画实例

TODO

### View动画特殊使用场景

#### 1. LayoutAnimation

> 作用于ViewGroup，为ViewGroup指定一个动画，当它的子元素出场时都会具有这样的效果。

```xml
<layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android"
                 android:delay=""
                 android:animationOrder=""
                 android:animation="" />                
```

`android:delay`：表示子元素开始动画的延迟时间。

> 比如，设置子元素入场动画的周期为 300ms，delay设置为0.5意味着，每个子元素都需要延迟150ms播放动画

`android:animationOrder` ：表示子元素动画的顺序

- normal 正序显示，按照排列顺序播放
- random 随机显示
- reverse 逆序显示

`android:animation`：表示设置的子元素动画

##### 应用代码

> XML定义

```xml
// anim_layout.xml
<layoutAnimation 
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:animation="@anim/anim_layout_item"
    android:delay="0.5"
    android:animationOrder="normal">
</layoutAnimation>

//anim_layout_item.xml
<set 
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="500"
    android:shareInterpolator="true"
    android:interpolator="@android:anim/accelerate_interpolator">
    <alpha
        android:fromAlpha="0"
        android:toAlpha="1" />
    <scale
        android:fromXScale="1"
        android:toXScale="0" />
</set>

<ListView 
          android:layoutAnimation ="@anim/anim_layout" />
```

> Java代码生成

```java
Animation animation = AnimationUtils.loadLayoutAnimation(this, R.anim.anim_item);
        LayoutAnimationController controller = new LayoutAnimationController(animation);//对应android:animation属性
        controller.setDelay(0.5);//对应android:delay属性      
        controller.setOrder(LayoutAnimationController.ORDER_NORMAL);//对应android:animationOrder属性
        listView.setLayoutAnimation(controller);//对应android:layoutAnimation属性
```



#### 2.Activity切换效果

> Activity有默认的切换效果，是由系统自己定义的。需要自定义切换效果就需要用到`oberridePendingTransition(int inAnim,int outAnim)`

```xml
// enter_anim.xml
<?xml version="1.0" encoding="utf-8"?>  
<set xmlns:android="http://schemas.android.com/apk/res/android"  
        android:interpolator="@android:anim/decelerate_interpolator">  
    <scale android:fromXScale="2.0" android:toXScale="1.0"  
           android:fromYScale="2.0" android:toYScale="1.0"  
           android:pivotX="50%p" android:pivotY="50%p"  
           android:duration="@android:integer/config_mediumAnimTime" />  
</set>  

//exit_anim.xml
<?xml version="1.0" encoding="utf-8"?>  
<set xmlns:android="http://schemas.android.com/apk/res/android"  
        android:interpolator="@android:anim/decelerate_interpolator"  
        android:zAdjustment="top">  
    <scale android:fromXScale="1.0" android:toXScale=".5"  
           android:fromYScale="1.0" android:toYScale=".5"  
           android:pivotX="50%p" android:pivotY="50%p"  
           android:duration="@android:integer/config_mediumAnimTime" />  
    <alpha android:fromAlpha="1.0" android:toAlpha="0"  
            android:duration="@android:integer/config_mediumAnimTime"/>   
</set>  
```



```java
Intent intent =new Intent(this,AnimActivity.class);
startActivityIntent(intent);
overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);
//退出时设置
finish();
overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);
```

**该方法必须在`startActivity()`或者`finish()`之后调用才生效。**

## 2.帧动画

> 帧动画是顺序播放一组预先定义好的图片，对应`AnimationDrawable`

```xml
<animation-list  xmlns:android="http://schemas.android.com/apk/res/android"
    android:oneshot="[true | false]">
    <item android:drawable="" android:duration="intreger"/>
</animation-list>
```

`android:oneshot`：表示是否播放一次

### 应用代码

> XML方式

```xml
// animationlist.xml
<animation-list  xmlns:android="http://schemas.android.com/apk/res/android"
    android:oneshot="false">
    <item android:drawable="@drawable/bg1" android:duration="500"/>
    <item android:drawable="@drawable/bg2" android:duration="500"/>
    <item android:drawable="@drawable/bg3" android:duration="500"/>
    <item android:drawable="@drawable/bg4" android:duration="500"/>
</animation-list>
```

```java
view.setBackgroundResource(R.drawable.animationlist);
AnimationDrawable animationDrawable = (AnimationDrawable)mView.getBackground();
animationDrawable.start();
```

> Java生成

```java
AnimationDrawable ad = new AnimationDrawable();//1.创建AnimationDrawable对象
    for (int i = 0; i < 4; i++) {//2.添加Drawable对象及其持续时间
        Drawable drawable = getResources().getDrawable(getResources().getIdentifier("bg" + i, "drawable", getPackageName()));
        ad.addFrame(drawable, 500);
    }
    ad.setOneShot(false);//3.设置是否执行一次
    mView.setBackgroundResource(ad);//4.将帧动画作为view背景
    ad.start();//5.播放动画
```

**使用帧动画时要注意不能使用尺寸过大的图片。否则容易造成OOM错误**

### 优化内存占用

> 由于图片全部是从xml中读取的，一定要全部读取下来动画才可以开始，因为要不断地替换图片去实现动画效果。一次性取出所有图片，就容易导致OOM

优化思路：**一次只取一个图片，开启一个线程去取下一张，达到一致的效果。**

## 3.属性动画

{% post_link Android动画-属性动画%}]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android - Drawable相关</title>
    <url>/2019/01/10/Android-Drawable%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[
## Drawable简介

> Drawable是一种 可以在Canvas上进行绘制的对象，即**可绘制物**。

在实际开发中，Drawable通常被用作View的背景，一般通过XML进行定义，也支持通过代码去实现(*例如动画样式的Drawable*)。

Drawable是一个抽象类，是所有Drawable的基类。例如常用的`ShapeDrawable、BitmapDrawable，LayerDrawable`等。

<!--Drawable绘制流程与View有什么区别？实现动画有什么区别？View为什么还要Drawable-->

### Drawable使用方式

- `XML引入`：创建所需Drawable根节点的`XML`，再通过调用`@drawable/xx`引入页面布局中

  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <shape xmlns:android="http://schemas.android.com/apk/res/android"
      android:shape="oval">
      <solid android:color="#fff3c3" />
      <size
          android:width="@dimen/x16"
          android:height="@dimen/x16" />
  </shape>
  
  android:background = "@drawable/xx"
  ```

- `Java代码`：new一个所需Drawable并设置相关属性，最后设置到布局中。

  ```java
  //自定义一个 Drawable对象 ，需要继承 Drawable基类
  class HomeWaterRippleDrawable(private val context: Context) : Drawable()
  //动态为布局设置 Drawable属性
  lav_camera.setImageDrawable(HomeWaterRippleDrawable(mActivity))
  ```


#### Drawable宽高

Drawable可以通过`getIntrinsicWidth()和getIntrinsicHeight()`获取内部宽高。*其实在View工作原理的`measure`过程中有用到这个方法，就是为了View设置背景时可以精确的确定其宽高*。

> 不是所有的Drawable都有宽高
>
> - 图片所形成的Drawable内部宽高就是图片的宽高
> - 颜色所形成的Drawable没有内部宽高的概念

Drawable没有大小的概念，当用作View的背景时，Drawable会被拉伸至View的同等大小。

#### Drawable使用范围

- 作为ImageView的图像显示
- 作为View的背景

## Drawable的种类

#### 1.BitmapDrawable

> 表示一张图片

根节点为`bitmap`。在使用过程中，我们可以直接引用原始图片即可，也可以通过XML的方式来描述他。

```xml
<bitmap 
   xmlns:android="http://schemas.android.com/apk/res/android"
   android:src=""
   android:antialias="[true | false]"
   android:dither="[true | false]"
   android:filter="[true | false]"
   android:tileMode="[disabled | clamp | repeat | mirror]"
   android:gravity="[top | bottom | left | right | center_vertical |
                    |fill_vertical | center_horizontal | fill_horizontal |
                    |center | fill | clip_vertical | clip_horizontal]"
   >
</bitmap>
```

下面是各个属性的含义：

`android:src`：图片的资源id

`android:antialias`：是否开启抗锯。，开启会让图片变得平滑。*可能导致图片清晰度下降，基本可以忽略，应该开启。*

`android:dither`：是否开启抖动效果。可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果，是图片显示不过于失真。*应该开启。*

`android:filter`：是否开启过滤效果。当图片被拉伸或者压缩时，开启可以保持较好的显示效果。*应该开启*。

`android:tileMode`：平铺模式。开启平铺模式时，`gravity`属性会被忽略。

|  可选项  |                       含义                       |
| :------: | :----------------------------------------------: |
| disabled |               关闭平铺模式*默认值*               |
|  clamp   | 图片四周的像素会拓展到周围区域*就是边缘像素拉伸* |
|  repeat  |                水平和竖直方向平铺                |
|  mirror  |              水平和竖直方向镜像显示              |

`android:gravity`：对图片位置进行定位。可以通过"|"进行组合使用。

|      可选项       |                含义                |
| :---------------: | :--------------------------------: |
|        top        |      不改变大小，置于容器顶部      |
|      bottom       |      不改变大小，置于容器底部      |
|       left        |      不改变大小，置于容器左部      |
|       right       |      不改变大小，置于容器右部      |
|  center_vertical  |    不改变大小，置于容器竖直居中    |
|   fill_vertical   |        图片竖直拉伸填满容器        |
| center_horizontal |    不改变大小，置于容器水平居中    |
|  fill_horizontal  |        图片水平拉伸填满容器        |
|      center       | 不改变大小，置于容器水平和竖直居中 |
|       fill        |  水平竖直方向拉伸填满容器*默认值*  |
|   clip_vertical   |          竖直方向进行裁剪          |
|  clip_horizontal  |          水平方向进行裁剪          |

##### 应用代码

```xml
//repeat_bitmap.xml
<?xml version="1.0" encoding="utf-8"?>
<bitmap xmlns:android="http://schemas.android.com/apk/res/android"
    android:dither="true"
    android:src="@mipmap/ic_launcher"
    android:tileMode="repeat"
    >
</bitmap>

//布局文件引用
android:background="@drawable/repeat_bitmap"
```

```java
	Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher);
	BitmapDrawable bitDrawable = new BitmapDrawable(bitmap);
	bitDrawable.setDither(true);
	bitDrawable.setTileModeXY(Shader.TileMode.REPEAT, Shader.TileMode.REPEAT);

	view.setBackground(bitmapDrawable);
```

#### 2.NinePatchDrawable

> 表示一张.9格式的图片

```xml
<nine-patch xmlns:android="http://schemas.android.com/apk/res/android"
    android:dither="[true|false]"
    android:src="">
</nine-patch>
```

`android:src`：图片的资源id

`android:dither`：是否开启抖动效果。可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果，是图片显示不过于失真。*应该开启。*

##### 应用代码

```xml
//对应 ninepatch.9.png   ninepatch.xml
<?xml version="1.0" encoding="utf-8"?>
<nine-patch xmlns:android="http://schemas.android.com/apk/res/android"
    android:dither="true"
    android:src="@drawable/ninepatch"
    >
</nine-patch>

//布局文件引用
android:background="@drawable/ninepatch"
```



#### 3.ShapeDrawable — 实际为`GradientDrawable`

> 可表示纯色，有渐变效果的基础几何图形(例如矩形，圆形等)

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="[rectangle | oval | line | ring]">
    <corners
        android:radius="integer"
        android:topLeftRaidus="integer"
        android:topRightRaidus="integer"
        android:bottomLeftRaidus="integer"
        android:bottomRightRaidus="integer" />
    <gradient
        android:angle="integer"
        android:centerX="integer"
        android:centerY="integer"
        android:centerColor="color"
        android:endColor="color"
        android:gradientRadius="integer"
        android:startColor="color"
        android:type="[linear | radial | sweep]"
        android:useLevel="[true | false]" />
    <padding
        android:left="integer"
        android:top="integer"
        android:right="integer"
        android:bottom="integer" />
    <size
        android:width="integer"
        android:height="integer" />
    <solid
        android:color="color" />
    <stroke
        android:width="integer"
        android:color="color"
        android:dashWidth="integer"
        android:dashGap="integer" />
</shape>
```

`android:shape`：图形的形状。

- `rectabgle`：矩形
- `oval`：椭圆
- `line`：横线。必须设置`<stroke>`属性指定直线宽度及颜色
- `ring`：圆环。必须设置`<stroke>`属性指定圆环宽度及颜色

`<corners>`：表示四个圆角的角度，只适合矩形。`android:radius`这个属性的设置优先级低于单独设置各个圆角角度。

`<gradient>`：可以设置渐变效果

- `android:angle`：设置渐变角度。默认为0，且要求值必须为45的倍数，*0表示从左到右，90表示从下到上*
- `android:centerX`：渐变的中心点的X坐标。
- `android:centerY`：渐变的中心点的Y坐标。
- `android:startColor`：渐变的起始色。
- `android:centerColor`：渐变的中间色。
- `android:endColor`：渐变的结束色。
- `android:gradient`：渐变半径。仅当**android:type="radial"**时有效。
- `android:type`：渐变的类型
  - linear：线性渐变
  - radial：径向渐变。类似扩散效果
  - sweep：扫描线渐变。类似雷达效果。

`<padding>`：设置四周空白距离

`<size>`：设置图形的固有大小，但不是最终的大小。*作为View背景时，大小还是跟着View走的*

`<solid>`：设置纯色填充

`<stroke>`：设置描边

| stroke属性        | 作用                       |
| :---------------- | -------------------------- |
| android:width     | 描边的宽度，越大边缘越明显 |
| android:color     | 描边的颜色                 |
| android:dashwidth | 虚线的宽度                 |
| android:dashGap   | 虚线的空隙间隔             |

*如果android:dashWidth或android:dashGap*有任何一个为0，则虚线效果无法生效。

##### 应用代码

```xml
//shpae.xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">

    <solid android:color="#ffffff" />

    <padding
        android:bottom="7dp"
        android:left="7dp"
        android:right="7dp"
        android:top="7dp" />
    <stroke
        android:width="3dp"
        android:color="#FFFF00" />
    <corners
        android:radius="3dp"/>

</shape>

android:background="@drawable/shape"
```

#### 4.LayerDrawable

> 表示一种层次性的Drawable集合，通过将不同的Drawable放置在不同的层上面从而达到一种叠加的效果。

```xml
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android"
    >
  <item
        android:drawable=""
        android:id="@+id"
        android:left="integer"
        android:right="integer"
        android:top="integer"
        android:bottom="integer" >
  </item>
</layer-list>
```

`android:drawable`：引用的背景资源

`android:id`：层id

`android:top`：layer相对于容器的上边距

`android:bottom`：layer相对于容器的下边距

`android:left`：layer相对于容器的左边距

`android:right`：layer相对于容器的右边距

*Layer-list有层次的概念，下面的item会覆盖上面的item*。

##### 应用代码

```xml
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/ic_launcher"
             />
    </item>
    <item
        android:left="20dp"
        android:bottom="30dp">
        <bitmap
            android:gravity="center"
            android:src="@mipmap/ic_launcher"
             />
    </item>
</layer-list>

```

#### 5.StateListDrawable

> 对应着`<selector>`标签，也表示Drawable集合，每个Drawable对应着View的一种状态。

```xml
<selector xmlns:android="http://schemas.android.com/apk/res/android"
          android:constantSize="[true | false]"
          android:dither="[true|false]"
          android:variablePadding="[true|false]"
          >
  <item 
        android:drawable=""
        android:state_pressed="[true | false]"
        android:state_focused="[true | false]"
        android:state_selected="[true | false]"
        android:state_hovered="[true | false]"
        android:state_checked="[true | false]"
        android:state_checkable="[true | false]"
        android:state_enabled="[true | false]"
        android:state_activated="[true | false]"
        android:state_window_focused="[true | false]"
        >
  </item>
</selector>
```

`android:constantSize`：固有大小是否不随着其状态的改变而改变。由于状态改变会导致`StateListDrawable`切换到对应的Drawable，导致大小发生变化。

- 设置为 true  固有大小是固定值，就是所有item中的最大值
- 设置为 false  固有大小跟着切换的item发生变化  *默认值*

`android:variblePadding`：`padding`是否随着状态改变而改变

- true `padding`随着状态改变而改变
- false  `padding`是固定值，取内部所有item中padding的最大值   *默认值*

`<item>`

| 状态                   | 含义                               |
| ---------------------- | ---------------------------------- |
| android:state_pressed  | 表示手指按下的状态                 |
| android:state_focused  | 表示获取焦点的状态                 |
| android:state_selected | 表示选中的状态                     |
| android:state_checked  | 表示选中的状态。一般用与`CheckBox` |
| android:state_enabled  | 表示当前可用的状态                 |

##### 应用代码

```xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:state_pressed="true"
        android:drawable="@drawable/state_pressed"/>
  <item android:state_focused="true"
        android:drawable="@drawable/state_focused"/>
  <item android:drawable="@drawable/state_normal"/>
</selector>
```

#### 6.LevelListDrawable

> 表示一个Drawable集合，集合中的每一个Drawable都有**等级**的概念。

```xml
<level-list xmlns:android="http://schemas.android.com/apk/res/android" >
    <item android:drawable=""
          android:maxLevel="integer"
          android:minLevel="integer"/>
</level-list>
```

`android:maxLevel`：对应的最大值，取值范围为0~10000，默认0 *常用该属性*

`android:minLevel`：对应的最小值，取值范围为0~10000，默认0

使用方法：无论是用xml还是代码实现

- 作为View背景：都需要在Java代码中调用`setLevel()`
- 作为图片前景：需要调用`setImageLevel()`

##### 应用代码

```xml
//level.xml
<?xml version="1.0" encoding="utf-8"?>
<level-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:maxLevel="1" android:drawable="@drawable/image1" />
    <item android:maxLevel="2" android:drawable="@drawable/image2" />
</level-list>

<View android:background="@drawable/level"/>
<ImageView android:src="@drawable/level"/>

// 设置View背景
view.setLevel(1)
//设置ImageView
imageView.setImageLevel(1);

```

> 拓展：ImageView的`android:setBackground`和`android:src`有什么区别？
>
> `android:setBackground`：会根据ImageView控件的宽高去拉伸图片
>
> `android:src`：保持原图大小

#### 7.TransitionDrawable

> 表示两个Drawable之间的淡入淡出效果

```xml
<?xml version="1.0" encoding="utf-8"?>
<transition xmlns:android="http://schemas.android.com/apk/res/android">
  <item
        android:drawable=""
        android:id="@+id"
        android:left="integer"
        android:right="integer"
        android:top="integer"
        android:bottom="integer"
        >
  </item>
</transition>
```

##### 应用代码

```xml
// transition.xml
<?xml version="1.0" encoding="utf-8"?>
<transition xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:drawable="@drawable/bg1" />
  <item android:drawable="@drawable/bg2" />
</transition>

<view android:background="@drawable/transition"/>
```

```java
TransitionDrawable drawable = (TransitionDrawable)view.getBackground();
drawable.startTransition(1000); //正向调用
// drawable.reverseTransition(1000);  反向调用
```



#### 8.InsetDrawable

> 表示把一个Drawable嵌入到另一个Drawable的内部，并在四周留一些间距

```xml
<?xml version="1.0" encoding="utf-8"?>
<insert xmlns:android="http://schemas.android.com/apk/res/android"
        android:drawable=""
        android:visible="[true | false]"
        android:insertLeft="integer"
        android:insertRight="integer"
        android:insertTop="integer"
        android:insertBottom="integer"
        >
</transition>
```

`android:visible`：是否保留边距。默认保留

##### 应用代码

```xml
<?xml version="1.0" encoding="utf-8"?>
<inset xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/image"
    android:insetBottom="20dp"
    android:insetLeft="20dp"
    android:insetRight="20dp"
    android:insetTop="20dp"
    android:visible="true">
</inset>
```



#### 9.ScaleDrawable

> 表示将Drawable缩放到一定比例

```xml
<?xml version="1.0" encoding="utf-8"?>
<scale xmlns:android="http://schemas.android.com/apk/res/android"
        android:drawable=""
        android:scaleWidth="percentage"
        android:scaleHeight="percentage"
        android:scaleGravity="[top | bottom | left | right |
        center_vertical | center_horizontal | center |
        fill_vertical | fill_horizontal | fill |
        clip_vertical | clip_horizontal]"
        >
</scale>
```

`android:scaleGravity`：效果同`android:gravity`

`android:scaleWidth/android:scaleHeight`：指定宽/高缩放比例。以百分比形式展示(`25%`)。

##### 应用代码

```xml
// scale.xml
<?xml version="1.0" encoding="utf-8"?>
<scale xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/drawable_test"
    android:scaleGravity="center"
    android:scaleHeight="70%"
    android:scaleWidth="70%"/>

<ImageView android:background="@drawable/scale"></ImageView>
```

```java
ScaleDrawable scaleDrawable = (ScaleDrawable) imageView.getDrawable();
scaleDrawable.setLevel(1);
```

`setLevel`填值不可以为0，取值范围为`0~10000`，0表示不可见。

#### 10.ClipDrawable

> 表示裁剪一个Drawable

```xml
<?xml version="1.0" encoding="utf-8"?>
<clip xmlns:android="http://schemas.android.com/apk/res/android"
        android:drawable=""
        android:clipOrientation="[horizonal | vertical]"
        android:scaleGravity="[top | bottom | left | right |
        center_vertical | center_horizontal | center |
        fill_vertical | fill_horizontal | fill |
        clip_vertical | clip_horizontal]" >
</clip>
```

`android:clipOrientation`：表示裁剪方向 可选值为 `horizonal 水平`，`vertical 竖直`

`android:gravity`：表示对齐方式
|      可选项       |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|        top        | 放在容器的顶部，不改变大小<br>若为竖直裁剪，则从底部开始裁剪 |
|      bottom       | 放在容器的底部，不改变大小<br/>若为竖直裁剪，则从顶部开始裁剪 |
|       left        | 放在容器的左边，不改变大小<br/>若为水平裁剪，则从右部开始裁剪 |
|       right       | 放在容器的右边，不改变大小<br/>若为水平裁剪，则从左边开始裁剪 |
|  center_vertical  | 放在容器的竖直居中，不改变大小<br/>若为竖直裁剪，则从上下开始裁剪 |
|   fill_vertical   |  竖直方向填充容器<br/>若为竖直裁剪，仅当level为0才开始裁剪   |
| center_horizontal | 放在容器的水平居中，不改变大小<br/>若为水平裁剪，则从左右同时开始裁剪 |
|  fill_horizontal  |  水平方向填充容器<br/>若为水平裁剪，仅当level为0才开始裁剪   |
|      center       | 放在容器的中心，不改变大小<br/>若为竖直裁剪，则从上下开始裁剪<br>若为水平裁剪，则从左右开始裁剪 |
|       fill        | 放在容器的顶部，不改变大小<br/>若为竖直裁剪，则从底部开始裁剪* |
|   clip_vertical   |                       竖直方向进行裁剪                       |
|  clip_horizontal  |                       水平方向进行裁剪                       |

##### 应用代码

```xml
// clip.xml
<?xml version="1.0" encoding="utf-8"?>
<clip xmlns:android="http://schemas.android.com/apk/res/android"
        android:drawable="@drawable/bg1"
        android:clipOrientation="vertical"
        android:scaleGravity="bottom" >
</clip>

<ImageView 
           android:backgrounf="@drawable/clip"/>
```

```java
ClipDrawable clipDrawable = (ClipDrawable) imageView.getDrawable();
clipDrawable.setLevel(5000)

```

`setLevel()`数值范围为`0~10000`，0代表完全裁剪，8000代表裁剪20%

#### 11.RotateDrawable

> 表示旋转Drawable

```xml
<?xml version="1.0" encoding="utf-8"?>
<rotate xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable=""
    android:fromDegrees="integer"
    android:pivotX="percentage"
    android:pivotY="percentage"
    android:toDegrees="integer"
    android:visible="[true | false]">
</rotate>
```

`android:fromDegrees` RotateDrawable实例起始角度,大于0是顺时针旋转,小于0是逆时针旋转;
`android:toDegrees` RotateDrawable实例最终角度,大于0是顺时针旋转,小于0是逆时针旋转;
`android:pivotX` RotateDrawable实例旋转中心点X轴坐标相对自身位置;
`android:pivotY` RotateDrawable实例旋转中心点Y轴坐标相对自身位置;

##### 应用代码

```xml
//rotate.xml
<?xml version="1.0" encoding="utf-8"?>
<rotate xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@mipmap/rotate_round"
    android:fromDegrees="0"
    android:pivotX="50%"
    android:pivotY="50%"
    android:toDegrees="360"
    android:visible="true">
</rotate>

<view android:background="@drawable/rotate"
```

```java
RotateDrawable rotateDrawable = (RotateDrawable) view.getDrawable();
rotateDrawable.setLevel(5000) //设置旋转角度 0~10000  ==  0~360
```







### 自定义Drawable

> 需要去复合实现 Drawable 效果。

```java
//自定义Drawable
public class CustomDrawable extends Drawable {
   
    private Paint mPaint;

    public CustomDrawable(int color) {
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setColor(color);
    }

    @Override
    public void draw(Canvas canvas) {
        final Rect rect =  getBounds();
        float cx = rect.exactCenterX();
        float cy = rect.exactCenterY();
        canvas.drawCircle(cx, cy, Math.min(cx, cy), mPaint);
    }

    @Override
    public void setAlpha(int alpha) {
        mPaint.setAlpha(alpha);
        invalidateSelf();
    }

    @Override
    public void setColorFilter(ColorFilter colorFilter) {
        mPaint.setColorFilter(colorFilter);
        invalidateSelf();
    }

    @Override
    public int getOpacity() {
        return PixelFormat.TRANSLUCENT;
    }
}
```

需要实现自定义Drawable的话，就必须要实现`draw(),setAlpha(),setColorFilter(),getOpacity()`这几个方法。

如果自定义的Drawable设置了固有大小，最好重写`getInstrinsicWidrh()和getInstrinsicHeight()`，因为会影响到`wrap_content`属性。

### Drawable相关

1. android中的dp、px、dip、sp，dpi相关概念

   `px`：就是像素单位，例如手机分辨率`1080*1920`单位就是px

   `dp`：设备独立像素，不同的设备有不同的效果，在不同的像素密度的设备上会自动适配

   `dpi`：每英寸像素树，有设备决定是固定的。计算方法：`横向分辨率/横向英寸数`

   `sp`：同dp相似，*会根据用户的字体大小偏好进行缩放*

2. Drawable文件过多如何整理

   - 自定义View，实现常用的Drawable属性

   - [参考该库](https://github.com/JavaNoober/BackgroundLibrary) 

     给LayoutInflater添加了一个LayoutInflater.Factory类。而Android的Activity在创建过程（也就是`setContentView`）中实际上是通过把xml转换成View的对象。而LayoutInflater.Factory相当于这中间的一个后门，它是xml解析创建成View的必经方法，google中的v7support包里很多内容就是通过LayoutInflater.Factory来实现向下兼容的。，加入一个自定义的LayoutInflater.Factory，去解析添加的自定义属性，



## Drawable原理

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack-ViewModel简析</title>
    <url>/2019/02/15/Jetpack-ViewModel%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
## ViewModel简介

> ViewModel是用来存储和管理Lifecycle创建数据的组件，在配置发生改变或者屏幕旋转时数据仍然不会丢失。**ViewModel可以负责组件间的通信，可以高效解决Activity与Fragment的通信问题。**

主要的功能还是在非手动关闭以及系统回收条件下进行 Activity/Fragment的数据保存。

## ViewModel使用示例
> 代码中提供了`ViewModel`以及`AndroidViewModel`，这两者的区别在于`AndroidViewModel`多提供了`application`入参，可以调用它去获取资源或者其他信息。

添加VIewModel的第三方引用

```groovy
 dependencies {
    def lifecycle_version = "2.0.0"
    implementation "androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version"
    implementation "androidx.lifecycle:lifecycle-extensions:$lifecycle_version"
 }
```



先创建一个类继承ViewModel
```java 
  public class CustomViewModel extends ViewModel{
     private String text = "text";
     public String getText(){
        return text;
     }
  }
```
创建完毕后，需要在Activity/Fragment中进行调用
```java
public class MainActivity extends AppCompatActivity {
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //获取自定义的ViewModel对象
        CustomViewModel vm = ViewModelProviders.of(this)
                .get(CustomViewModel.class);
        //直接调用内部方法
        vm.getText();
    }
}
```
上述为最简单的示例，更高级的可以参考[ViewModel 官方示例](https://developer.android.google.cn/topic/libraries/architecture/viewmodel)

## 源码分析
根据上节的使用示例分析ViewModel中的源码实现。
### ViewModel
需要先新建ViewModel实例，等待调用
```java ViewModel.java
public abstract class ViewModel {
    //当ViewModel实例被销毁时调用
    @SuppressWarnings("WeakerAccess")
    protected void onCleared() {
      //做清空操作
    }
}
```
还提供了AndroidViewModel，可以支持传入Application
```java AndroidViewModel.java
public class AndroidViewModel extends ViewModel {
    private Application mApplication;
    //传入Application
    public AndroidViewModel(@NonNull Application application) {
        mApplication = application;
    }

    @NonNull
    public <T extends Application> T getApplication() {
        return (T) mApplication;
    }
}
```
### ViewModelProvider
创建实例完毕后，需要获取对应实例
```java ViewModelProviders.java
public class ViewModelProviders {
   ...
    @NonNull
    @MainThread
    public static ViewModelProvider of(@NonNull Fragment fragment) {
        return of(fragment, null);
    }
    
    @NonNull
    @MainThread
    public static ViewModelProvider of(@NonNull FragmentActivity activity) {
        return of(activity, null);
    }
    
    @NonNull
    @MainThread
    public static ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory) {
        Application application = checkApplication(checkActivity(fragment));
        if (factory == null) {
            factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);
        }
        return new ViewModelProvider(ViewModelStores.of(fragment), factory);
    }
    
    @NonNull
    @MainThread
    public static ViewModelProvider of(@NonNull FragmentActivity activity,
            @Nullable Factory factory) {
        Application application = checkApplication(activity);
        //默认构造器为AndroidViewModel
        if (factory == null) {
            factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);
        }
        return new ViewModelProvider(ViewModelStores.of(activity), factory);
    }
}
```
*观察源码可知ViewModel支持的类型为`FragmentActivity`以及`support.Fragment。`*
经过`ViewModelProviders.of(FragmentActivity/Fragment)`最终得到一个`ViewModelProvider`实例。
```java ViewModelProvider.java
public class ViewModelProvider {
    //获取对应ViewModle实例
    @NonNull
    @MainThread
    public <T extends ViewModel> T get(@NonNull Class<T> modelClass) {
        String canonicalName = modelClass.getCanonicalName();
        if (canonicalName == null) {
            throw new IllegalArgumentException("Local and anonymous classes can not be ViewModels");
        }
        return get(DEFAULT_KEY + ":" + canonicalName, modelClass);
    }
    
    @NonNull
    @MainThread
    public <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {
        //从ViewModelStore缓存中获取对应ViewModel实例
        ViewModel viewModel = mViewModelStore.get(key);
        //如果相同就直接返回缓存中实例
        if (modelClass.isInstance(viewModel)) {
            return (T) viewModel;
        } else {
            //noinspection StatementWithEmptyBody
            if (viewModel != null) {
                // TODO: log a warning.
            }
        }
        //不存在，则创建新实例
        viewModel = mFactory.create(modelClass);
        //创建完毕后放入缓存中
        mViewModelStore.put(key, viewModel);
        return (T) viewModel;
    }
}
```
`ViewModelStore`负责存放`ViewModel`的缓存数据，可以保证不会重复创建新实例。
源码中提供了两种Factory类：`AndroidViewModelFactory(默认使用)`及`NewInstanceFactory`。
```java ViewModelProvider.java
    //创建对应实例
    public interface Factory {
        @NonNull
        <T extends ViewModel> T create(@NonNull Class<T> modelClass);
    }

    public static class NewInstanceFactory implements Factory {
        @SuppressWarnings("ClassNewInstance")
        @NonNull
        @Override
        public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
            try {
                //创建ViewModel新实例
                return modelClass.newInstance();
            } catch (InstantiationException e) {
                throw new RuntimeException("Cannot create an instance of " + modelClass, e);
            } catch (IllegalAccessException e) {
                throw new RuntimeException("Cannot create an instance of " + modelClass, e);
            }
        }
    }
    
    public static class AndroidViewModelFactory extends ViewModelProvider.NewInstanceFactory {

        private static AndroidViewModelFactory sInstance;

        //单例模式
        @NonNull
        public static AndroidViewModelFactory getInstance(@NonNull Application application) {
            if (sInstance == null) {
                sInstance = new AndroidViewModelFactory(application);
            }
            return sInstance;
        }

        private Application mApplication;

        public AndroidViewModelFactory(@NonNull Application application) {
            mApplication = application;
        }

        @NonNull
        @Override
        public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
            //判断传入的ViewModel是否继承自AndroidViewModel
            if (AndroidViewModel.class.isAssignableFrom(modelClass)) {
                try {
                    //创建一个AndroidViewModel实例
                    return modelClass.getConstructor(Application.class).newInstance(mApplication);
                } catch (NoSuchMethodException e) {
                    throw new RuntimeException("Cannot create an instance of " + modelClass, e);
                } catch (IllegalAccessException e) {
                    throw new RuntimeException("Cannot create an instance of " + modelClass, e);
                } catch (InstantiationException e) {
                    throw new RuntimeException("Cannot create an instance of " + modelClass, e);
                } catch (InvocationTargetException e) {
                    throw new RuntimeException("Cannot create an instance of " + modelClass, e);
                }
            }
            //否则向上调用父类 NewInstanceFactory的创建方法
            return super.create(modelClass);
        }
    }
```
默认使用`AndroidViewModelFactory`，需要传入`Application`参数构建一个`ViewModel`类型，否则需要调用到`NewInstanceFactory`去构建，创造出一个无参构造的ViewModel类。

构建完成后，将其放到`ViewModelStore`中进行缓存，以便下次调用。
### ViewModelStore
通过`ViewModelStores.of()`获取到ViewModelStore这一缓存对象。
```java ViewModelStores.java
public class ViewModelStores{
    @NonNull
    @MainThread
    public static ViewModelStore of(@NonNull FragmentActivity activity) {
        if (activity instanceof ViewModelStoreOwner) {
            return ((ViewModelStoreOwner) activity).getViewModelStore();
        }
        return holderFragmentFor(activity).getViewModelStore();
    }
    
    @NonNull
    @MainThread
    public static ViewModelStore of(@NonNull Fragment fragment) {
        if (fragment instanceof ViewModelStoreOwner) {
            return ((ViewModelStoreOwner) fragment).getViewModelStore();
        }
        return holderFragmentFor(fragment).getViewModelStore();
    }
}
```
> 在这里有个注意点：`activity instanceof ViewModelStoreOwner`在support 27.1.0以上这个判断是成立的，因为`FragmentActivity以及Fragment`都已经实现了`ViewModelStoreOwner`接口，就直接调用系统内实现好的`ViewModelStore`即可。
> 在support 27.1.0以下的还未实现，依然需要开发者自己去实现，或者直接调用`HolderFragment`的系统实现。


与`ViewModelProvides`类似，通过`of()`去获取到实例。
```java ViewModelStore.java
public class ViewModelStore {
    private final HashMap<String, ViewModel> mMap = new HashMap<>();
    //放入ViewModel实例
    final void put(String key, ViewModel viewModel) {
        ViewModel oldViewModel = mMap.put(key, viewModel);
        if (oldViewModel != null) {
            oldViewModel.onCleared();
        }
    }
    //获取ViewModel实例
    final ViewModel get(String key) {
        return mMap.get(key);
    }

    public final void clear() {
        for (ViewModel vm : mMap.values()) {
            vm.onCleared();
        }
        mMap.clear();
    }
}
```

### HolderFragment
`HolderFragment`是一个Fragment组件，没有UI界面，唯一的作用就是**存储数据(ViewModelStore)**。
对于每一个使用了`ViewModel`的Activity/Fragment都会动态的为其添加一个`HolderFragment`，其实现了`ViewModelStoreOwner`接口，可以直接获取到内部存储的`ViewModelStore`数据。
`HolderFragment`是整个ViewModel源码实现的核心，由它进行数据存储且保证发生屏幕旋转等配置改变时存储的数据不会丢失。
```java HoldFragment.java
public class HolderFragment extends Fragment implements ViewModelStoreOwner {
    ...
	private ViewModelStore mViewModelStore = new ViewModelStore();

    public HolderFragment() {
        setRetainInstance(true);①
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        sHolderFragmentManager.holderFragmentCreated(this);
    }
    
    @Override
    public void onDestroy() {
        super.onDestroy();
        //Fragment销毁时，清空自身存储的ViewModel
        mViewModelStore.clear();
    }
    
     @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
    public static HolderFragment holderFragmentFor(FragmentActivity activity) {
        return sHolderFragmentManager.holderFragmentFor(activity);
    }

    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
    public static HolderFragment holderFragmentFor(Fragment fragment) {
        return sHolderFragmentManager.holderFragmentFor(fragment);
    }
    
     static class HolderFragmentManager {
        //储存那些已调用commit()但是还没有被添加进宿主Activity的HolderFragment，在真正创建完毕
        //即调用到 onCreate()时才算添加进入。 
        private Map<Activity, HolderFragment> mNotCommittedActivityHolders = new HashMap<>();
        private Map<Fragment, HolderFragment> mNotCommittedFragmentHolders = new HashMap<>();
         
         
        ...
        //HoldFragment添加至宿主Activity完毕
        void holderFragmentCreated(Fragment holderFragment) {
            Fragment parentFragment = holderFragment.getParentFragment();
            if (parentFragment != null) {
                mNotCommittedFragmentHolders.remove(parentFragment);
                parentFragment.getFragmentManager().unregisterFragmentLifecycleCallbacks(
                        mParentDestroyedCallback);
            } else {
                mNotCommittedActivityHolders.remove(holderFragment.getActivity());
            }
        }
        //根据HOLDER_TAG寻找对应的HolderFragment
        private static HolderFragment findHolderFragment(FragmentManager manager) {
            if (manager.isDestroyed()) {
                throw new IllegalStateException("Can't access ViewModels from onDestroy");
            }
            Fragment fragmentByTag = manager.findFragmentByTag(HOLDER_TAG);
            if (fragmentByTag != null && !(fragmentByTag instanceof HolderFragment)) {
                throw new IllegalStateException("Unexpected "
                        + "fragment instance was returned by HOLDER_TAG");
            }
            return (HolderFragment) fragmentByTag;
        }
         
        private static HolderFragment createHolderFragment(FragmentManager fragmentManager) {
            HolderFragment holder = new HolderFragment();
            fragmentManager.beginTransaction().add(holder, HOLDER_TAG).commitAllowingStateLoss();
            return holder;
        }
         
         HolderFragment holderFragmentFor(FragmentActivity activity) {
            FragmentManager fm = activity.getSupportFragmentManager();
            HolderFragment holder = findHolderFragment(fm);
            if (holder != null) {
                return holder;
            
            //获取对应HolderFragment实例
            holder = mNotCommittedActivityHolders.get(activity);
            if (holder != null) {
                return holder;
            }

            if (!mActivityCallbacksIsAdded) {
                //添加Activity生命周期监听
                mActivityCallbacksIsAdded = true;
                activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks);
            }
            //创建一个HolderFragment对象
            holder = createHolderFragment(fm);
            mNotCommittedActivityHolders.put(activity, holder);
            return holder;
        }

        HolderFragment holderFragmentFor(Fragment parentFragment) {
            FragmentManager fm = parentFragment.getChildFragmentManager();
            HolderFragment holder = findHolderFragment(fm);
            if (holder != null) {
                return holder;
            }
            
            holder = mNotCommittedFragmentHolders.get(parentFragment);
            if (holder != null) {
                return holder;
            }

            parentFragment.getFragmentManager()
                    .registerFragmentLifecycleCallbacks(mParentDestroyedCallback, false);
            holder = createHolderFragment(fm);
            mNotCommittedFragmentHolders.put(parentFragment, holder);
            return holder;
        }
     }
}
```

`HolderFragment`通过调用`HolderFragmentManager.holderFragmentFor()`获取最终的`HolderFragment`。

主要有以下几步：

1. 根据HOLDER_TAG，从宿主的`FragmentManager`中查询对应Tag的HolderFragment，找到则返回
2. 再从`mNotCommitedActivityHolder`中查找`HolderFragment`实例，找到则返回
3. 为宿主添加生命周期监听，可以在销毁时及时移除数据
4. 使用HOLDER_TAG创建一个`HolderFragment`，并添加到宿主上
5. 再添加至`mNotCommitedActivityHolder`缓存中，等待`HolderFragment.onCreate()`执行时移除。

①`setRetainInstance(true)`：不会销毁Fragment实例

### 整体流程

源码分析完毕后，对总流程进行总结：

- `ViewModelProviders`创建对应的`ViewModelProvider`对象
- `ViewModelStores`获取`ViewModelStore`对象
- 创建`HolderFragment`添加至宿主Activity或Fragment上，并返回ViewModelStore对象
- `ViewModelProvider`创建`ViewModel`对象，并配合`ViewModelStore`进行缓存



## ViewModel拓展知识

### ViewModel与`onSaveInstanceState()`区别

- 两者都可以进行保存数据，但是`ViewModel`可以支持保存更多数据
- 当Activity因为系统内存紧张被回收时，`onSaveInstanceState()`可以恢复数据，而`ViewModel`因为`HolderFragment`被销毁数据也随之丢失。
- 两者都只是临时性存储

## 内容引用

[ViewModel源码分析](<https://blog.csdn.net/hyc1988107/article/details/81456460>)

[Jekton-ViewModel](<https://jekton.github.io/2018/06/30/android-arch-ViewModel/>)]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack-Lifecycle简析</title>
    <url>/2019/02/15/Jetpack-Lifecycle%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
## Lifecycle简介

Google官方提供的一个**生命周期感知组件**。可以由引用组件自己进行生命周期管理，从而减少内存泄露以及异常的可能性。

**让我们自己创建的对象也可以感知到Android组件的生命周期。**

## Lifecycle使用示例

先构建需要监听生命周期的组件

```java
public class LifeCycleComponent implements LifecycleObserver {
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    void onCreate(){

    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    void onPause(){

    }
}
```

在Activity/Fragment中引用该组件并绑定生命周期

```java
public class NewActivity extends AppCompatActivity {
   protected void onCreate(@Nullable Bundle savedInstanceState) {
   		super.onCreate(savedInstanceState);
        getLifecycle().addObserver(new LifeCycleComponent());
   }
}
```

更多使用示例可参考[官方Lifecycle示例](<https://developer.android.google.cn/topic/libraries/architecture/lifecycle#codelabs>)

## Lifecycle源码解析

### LifecycleObserver 

> 属于观察者模式的**观察者**，负责接受生命周期事件。需要监听生命周期的组件都需要实现该接口。

```java LifecycleObserver.java
/**
 * Marks a class as a LifecycleObserver. It does not have any methods, instead, relies on
 * {@link OnLifecycleEvent} annotated methods.
 */
public interface LifecycleObserver {

}
```

内部未提供任何方法，需要监听生命周期的话就采用`OnLifecycleEvent`去实现

```java
//运行时注解
@Retention(RetentionPolicy.RUNTIME)
//只支持注解方法
@Target(ElementType.METHOD)
public @interface OnLifecycleEvent {
    Lifecycle.Event value();
}
```

至此定义完成了需要取得监听结果的对象以及需要监听的生命周期

### Lifecycle

> 属于观察者模式中的**被观察者**，负责接受生命周期监听事件，并分发到观察者`LifecycleObserver`中。

```java Lifecycle.java
public abstract class Lifecycle {
    //添加观察者
    @MainThread
    public abstract void addObserver(@NonNull LifecycleObserver observer);
    //移除观察者
    @MainThread
    public abstract void removeObserver(@NonNull LifecycleObserver observer);
    //获取当前生命周期状态
    @MainThread
    @NonNull
    public abstract State getCurrentState();

    public enum Event {
        /**
         * Constant for onCreate event of the {@link LifecycleOwner}.
         */
        ON_CREATE,
        /**
         * Constant for onStart event of the {@link LifecycleOwner}.
         */
        ON_START,
        /**
         * Constant for onResume event of the {@link LifecycleOwner}.
         */
        ON_RESUME,
        /**
         * Constant for onPause event of the {@link LifecycleOwner}.
         */
        ON_PAUSE,
        /**
         * Constant for onStop event of the {@link LifecycleOwner}.
         */
        ON_STOP,
        /**
         * Constant for onDestroy event of the {@link LifecycleOwner}.
         */
        ON_DESTROY,
        /**
         * An {@link Event Event} constant that can be used to match all events.
         */
        ON_ANY
    }

    /**
     * Lifecycle states. You can consider the states as the nodes in a graph and
     * {@link Event}s as the edges between these nodes.
     */
    public enum State {
        /**
         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch
         * any more events. For instance, for an {@link android.app.Activity}, this state is reached
         * <b>right before</b> Activity's {@link android.app.Activity#onDestroy() onDestroy} call.
         */
        DESTROYED,

        /**
         * Initialized state for a LifecycleOwner. For an {@link android.app.Activity}, this is
         * the state when it is constructed but has not received
         * {@link android.app.Activity#onCreate(android.os.Bundle) onCreate} yet.
         */
        INITIALIZED,

        /**
         * Created state for a LifecycleOwner. For an {@link android.app.Activity}, this state
         * is reached in two cases:
         * <ul>
         *     <li>after {@link android.app.Activity#onCreate(android.os.Bundle) onCreate} call;
         *     <li><b>right before</b> {@link android.app.Activity#onStop() onStop} call.
         * </ul>
         */
        CREATED,

        /**
         * Started state for a LifecycleOwner. For an {@link android.app.Activity}, this state
         * is reached in two cases:
         * <ul>
         *     <li>after {@link android.app.Activity#onStart() onStart} call;
         *     <li><b>right before</b> {@link android.app.Activity#onPause() onPause} call.
         * </ul>
         */
        STARTED,

        /**
         * Resumed state for a LifecycleOwner. For an {@link android.app.Activity}, this state
         * is reached after {@link android.app.Activity#onResume() onResume} is called.
         */
        RESUMED;

        /**
         * Compares if this State is greater or equal to the given {@code state}.
         *
         * @param state State to compare with
         * @return true if this State is greater or equal to the given {@code state}
         */
        public boolean isAtLeast(@NonNull State state) {
            return compareTo(state) >= 0;
        }
    }
}
```

{% fullimage /images/lifecycle-states.png,Lifecycle的Event及State对应关系,Lifecycle的Event及State对应关系%}

### LifecycleOwner

定义好自定义组件后就需要将其与Activity/Fragment进行绑定。此时就需要去获取其内部的`lifecycle`对象

```java
public interface LifecycleOwner {
    Lifecycle getLifecycle();
}
```

`LifecycleOwner`只提供一个`getLifecycle()`获取`lifecycle`对象。

在Activity/Fragment中，可以直接调用到`getLifecycle()`进行获取

```java 
public class FragmentActivity extends ComponentActivity implements
    ViewModelStoreOwner{
    ...
}

public class ComponentActivity extends Activity
        implements LifecycleOwner, KeyEventDispatcher.Component {
    ...
    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);
    ...
    @Override
    public Lifecycle getLifecycle() {
        return mLifecycleRegistry;
    }
}
```

```java
public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner,
ViewModelStoreOwner {
    ...
    LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);
    ...
    @Override
    public Lifecycle getLifecycle() {
        return mLifecycleRegistry;
    }
}
```

在`FragmentActivity`及`Fragment`中都已默认实现了`LifecycleOwner`接口，就无需开发者自己实现。

### LifecycleRegistry

> Lifecycle抽象类的核心功能实现类，由它实现了生命周期绑定及添加/移除监听功能。

先分析在Activity/Fragment中是如何使用`LifecycleRegistry`，后续分析功能实现。

#### Fragment绑定

```java
public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner,
        ViewModelStoreOwner {
    ...
    LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);
    ...
    @Override
    public Lifecycle getLifecycle() {
        return mLifecycleRegistry;
    }
            
    ...
    void performCreate(Bundle savedInstanceState) {
        if (mChildFragmentManager != null) {
            mChildFragmentManager.noteStateNotSaved();
        }
        //标记当前Lifecycle.State为CREATED
        mState = CREATED;
        mCalled = false;
        onCreate(savedInstanceState);
        mIsCreated = true;
        //回调 ON_CREATE
        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);
    }
            
    void performStart() {
        mState = STARTED;
        mCalled = false;
        onStart();
        if (mChildFragmentManager != null) {
            mChildFragmentManager.dispatchStart();
        }
        //回调ON_START
        mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);
        if (mView != null) {
            mViewLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);
        }
    }        
}
```

`Fragment`通过`LifecycleRegistry.handleLifecycleEvent()`进行了生命周期绑定。

#### Activity绑定

```java
public class ComponentActivity extends Activity
        implements LifecycleOwner, KeyEventDispatcher.Component {
        ...
    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);
        @Override
    @SuppressWarnings("RestrictedApi")
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ReportFragment.injectIfNeededIn(this);
    }

    @CallSuper
    @Override
    protected void onSaveInstanceState(Bundle outState) {
        mLifecycleRegistry.markState(Lifecycle.State.CREATED);
        super.onSaveInstanceState(outState);
    }
    ...
}
```

如果绑定在Activity上，就需要通过动态添加一个`ReportFragment`去绑定生命周期

```java ReportFragment.java
public class ReportFragment extends Fragment {
public static void injectIfNeededIn(Activity activity) {
        // ProcessLifecycleOwner should always correctly work and some activities may not extend
        // FragmentActivity from support lib, so we use framework fragments for activities
        android.app.FragmentManager manager = activity.getFragmentManager();
        //创建自身并加入宿主Activity
        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {
            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();
            // Hopefully, we are the first to make a transaction.
            manager.executePendingTransactions();
        }
    }

    static ReportFragment get(Activity activity) {
        //获取自身实例
        return (ReportFragment) activity.getFragmentManager().findFragmentByTag(
                REPORT_FRAGMENT_TAG);
    }
    
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        dispatchCreate(mProcessListener);
        //分发ON_CREATE事件
        dispatch(Lifecycle.Event.ON_CREATE);
    }

    @Override
    public void onStart() {
        super.onStart();
        dispatchStart(mProcessListener);
        //分发ON_START事件
        dispatch(Lifecycle.Event.ON_START);
    }
    
    private void dispatch(Lifecycle.Event event) {
        Activity activity = getActivity();
        if (activity instanceof LifecycleRegistryOwner) {
            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);
            return;
        }
        //指代了 ComponentActivity
        if (activity instanceof LifecycleOwner) {
            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();
            if (lifecycle instanceof LifecycleRegistry) {
                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);
            }
        }
    }
}
```

Activity的生命周期监听需要依赖动态添加进的`ReportFragment`的生命周期进行回调。

#### 生命周期事件的分发

观察上述源码发现，每触发一个生命周期都会响应到`LifecycleRegistry.handleLifecycleEvent()`

```java LifecycleRegistry.java
    public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {
        //根据当前收到的生命周期状态获取事件发生后的后续状态
        State next = getStateAfter(event);
        moveToState(next);
    }

    private void moveToState(State next) {
        if (mState == next) {
            return;
        }
        mState = next;
        //处于未同步状态则返回
        if (mHandlingEvent || mAddingObserverCounter != 0) {
            mNewEventOccurred = true;
            // we will figure out what to do on upper level.
            return;
        }
        mHandlingEvent = true;
        //执行同步方法，把所有的State转成Event
        sync();
        mHandlingEvent = false;
    }

    static State getStateAfter(Event event) {
        switch (event) {
            case ON_CREATE:
            case ON_STOP:
                return CREATED;
            case ON_START:
            case ON_PAUSE:
                return STARTED;
            case ON_RESUME:
                return RESUMED;
            case ON_DESTROY:
                return DESTROYED;
            case ON_ANY:
                break;
        }
        throw new IllegalArgumentException("Unexpected event value " + event);
    }
```

设置状态完毕后需要同步所有的状态(`Status`)。

```java
    //Lifecycle自定义的数据结构，类似HashMap
    private FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap =
            new FastSafeIterableMap<>();


    // happens only on the top of stack (never in reentrance),
    // so it doesn't have to take in account parents
    private void sync() {
        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();
        if (lifecycleOwner == null) {
            Log.w(LOG_TAG, "LifecycleOwner is garbage collected, you shouldn't try dispatch "
                    + "new events from it.");
            return;
        }
        while (!isSynced()) {
            // mNewEventOccurred 是为了在 observer 触发状态变化时让 backwardPass/forwardPass()
            // 提前返回用的。我们刚准备调他们，这里设置为 false 即可。
            mNewEventOccurred = false;
            // no need to check eldest for nullability, because isSynced does it for us.
            if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {
                // mObserverMap 里的元素的状态是非递增排列的，也就是说，队头的 state 最大
                // 如果 mState 小于队列里最大的那个，说明有元素需要更新状态
                // 为了维持 mObserverMap 的 Invariant，这里我们需要从队尾往前更新元素的状态
                backwardPass(lifecycleOwner);
            }
            Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();
            // 如果 mNewEventOccurred，说明在上面调用 backwardPass() 时，客户触发了状态修改
            if (!mNewEventOccurred && newest != null
                    && mState.compareTo(newest.getValue().mState) > 0) {
                forwardPass(lifecycleOwner);
            }
        }
        mNewEventOccurred = false;
    }

    // 如果所有的 observer 的状态都已经同步完，则返回 true
    private boolean isSynced() {
        if (mObserverMap.size() == 0) {
            return true;
        }
        //获取最大状态
        State eldestObserverState = mObserverMap.eldest().getValue().mState;
        //获取最小状态
        State newestObserverState = mObserverMap.newest().getValue().mState;
        // 因为我们保证队头的 state >= 后面的元素的 state，所以只要判断头尾就够了
        return eldestObserverState == newestObserverState && mState == newestObserverState;
    }

```

`sync()`时发现状态不一致，就需要进行向前或向后的变化。

使用当前Lifecycle的`mState`和`mObserverMap`的最大值进行比较，如果当前`mState`较小，需要进行递减状态`backwardPass()`

使用当前Lifecycle的`mState`和`mObserverMap`的最小值进行比较，如果当前`mState`较大，需要进行递增状态`forwardPass()`

```java
private ArrayList<State> mParentStates = new ArrayList<>();


    private void forwardPass(LifecycleOwner lifecycleOwner) {
        // 从队头开始迭代
        Iterator<Entry<LifecycleObserver, ObserverWithState>> ascendingIterator =
                mObserverMap.iteratorWithAdditions();
        while (ascendingIterator.hasNext() && !mNewEventOccurred) {
            Entry<LifecycleObserver, ObserverWithState> entry = ascendingIterator.next();
            ObserverWithState observer = entry.getValue();
            //当前observer的state值小于mState，则需递增当前状态到mState
            while ((observer.mState.compareTo(mState) < 0 && !mNewEventOccurred
                    // 可能在回调客户代码的时候，客户把自己移除了
                    && mObserverMap.contains(entry.getKey()))) {
                pushParentState(observer.mState);
                //递增其状态
                observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));
                popParentState();
            }
        }
    }

    private void backwardPass(LifecycleOwner lifecycleOwner) {
        // 从队尾开始迭代
        Iterator<Entry<LifecycleObserver, ObserverWithState>> descendingIterator =
                mObserverMap.descendingIterator();
        while (descendingIterator.hasNext() && !mNewEventOccurred) {
            Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next();
            ObserverWithState observer = entry.getValue();
            //当前observer的state值大于mState，则需递减当前状态到mState
            while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred
                    && mObserverMap.contains(entry.getKey()))) {
                //递减其状态
                Event event = downEvent(observer.mState);
                pushParentState(getStateAfter(event));
                observer.dispatchEvent(lifecycleOwner, event);
                popParentState();
            }
        }
    }

    private void popParentState() {
        mParentStates.remove(mParentStates.size() - 1);
    }

    private void pushParentState(State state) {
        mParentStates.add(state);
    }

    private static Event downEvent(State state) {
        switch (state) {
            case INITIALIZED:
                throw new IllegalArgumentException();
            case CREATED:
                return ON_DESTROY;
            case STARTED:
                return ON_STOP;
            case RESUMED:
                return ON_PAUSE;
            case DESTROYED:
                throw new IllegalArgumentException();
        }
        throw new IllegalArgumentException("Unexpected state value " + state);
    }

    private static Event upEvent(State state) {
        switch (state) {
            case INITIALIZED:
            case DESTROYED:
                return ON_CREATE;
            case CREATED:
                return ON_START;
            case STARTED:
                return ON_RESUME;
            case RESUMED:
                throw new IllegalArgumentException();
        }
        throw new IllegalArgumentException("Unexpected state value " + state);
    }
```

`forwardPass()`首先获取一个`mObserverMap`的迭代器，然后遍历每一子元素，递增其状态并通过`dispatchEvent()`分发事件，直到状态递增到`mState`为止。

假设`mObserverMap`中的所有都处于`CREATED`状态，当收到一个`ON_START`事件时，表示需要进入`STARTED`状态，由于`STARTED`较大，需要进行`forwardPass()`来递增`mObserverMap`中的状态，其内部调用到`upEvent()`升至了`STARTED`，再发送出去，外部接受到的就是`ON_START`事件。

#### 注册/注销观察者

通过`addObserver()/removeObserver()`控制观察者的添加与移除

```java
 @Override
    public void addObserver(@NonNull LifecycleObserver observer) {
        //计算初始状态
        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;
        ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);
        //从缓存中获取 observer这个key对应的值
        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);
        //防止重复加入
        if (previous != null) {
            return;
        }
        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();
        if (lifecycleOwner == null) {
            // it is null we should be destroyed. Fallback quickly
            return;
        }

        boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;
        //计算当前lifecycle的状态
        State targetState = calculateTargetState(observer);
        mAddingObserverCounter++;
        while ((statefulObserver.mState.compareTo(targetState) < 0
                && mObserverMap.contains(observer))) {
            pushParentState(statefulObserver.mState);
            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));
            popParentState();
            // 在回调时可能用户操作导致发生变化
            targetState = calculateTargetState(observer);
        }

        if (!isReentrance) {
            // we do sync only on the top level.
            sync();
        }
        mAddingObserverCounter--;
    }

    private State calculateTargetState(LifecycleObserver observer) {
        Entry<LifecycleObserver, ObserverWithState> previous = mObserverMap.ceil(observer);

        State siblingState = previous != null ? previous.getValue().mState : null;
        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)
                : null;
        // 返回最小的 state
        return min(min(mState, siblingState), parentState);
    }


static class ObserverWithState {
    //保存当前Observer的状态
    State mState;
    //源Observer的包装类
    GenericLifecycleObserver mLifecycleObserver;

    ObserverWithState(LifecycleObserver observer, State initialState) {
        //生成一个原Observer的包装类
        mLifecycleObserver = Lifecycling.getCallback(observer);
        mState = initialState;
    }
    //该方法将生命周期事件分发到LifecycleObserver中
    void dispatchEvent(LifecycleOwner owner, Event event) {
        State newState = getStateAfter(event);
        mState = min(mState, newState);
        //调用包装类的onStateChanged方法，传递生命周期事件到Observer中
        mLifecycleObserver.onStateChanged(owner, event);
        mState = newState;
    }
}
```

通过上述流程就完成了添加/移除功能

## 拓展

`@OnLifecycleEvent`采用**运行时注解**方式，需要通过反射来执行逻辑。`Lifecycle`对于该注解采用了 **一次查找后续从缓存中获取**的形式，降低了反射时的性能消耗。详情可参考 *androidx.lifecycle.ClassInfoCache*内部有具体的逻辑实现。

## 内容引用

[Jekton-Lifecycle](<https://jekton.github.io/2018/07/06/android-arch-lifecycle/>)]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack-LiveData简析</title>
    <url>/2019/02/15/Jetpack-LiveData%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
## LiveData简介

本质上是一个观察者模式，在Activity/Fragment中实现观察者，LiveData是被观察者，在LiveData存储的数据变更时触发事件。

LiveData还具有**生命周期感知**能力，可以控制在应用可见时去更新UI，不可见时不执行操作，减少了内存泄露问题。

## LiveData示例

一般情况下`LiveData`要配合着`ViewModel`一起使用，ViewModel负责触发数据更新，LiveData负责通知观察者数据更新。

引入LiveData三方库

```groovy
dependencies {
    def lifecycle_version = "2.0.0"
    implementation "androidx.lifecycle:lifecycle-livedata:$lifecycle_version"
    implementation "androidx.lifecycle:lifecycle-runtime:$lifecycle_version"
 }
```

新建ViewModel类并包含LiveData

```java
public class LiveDataViewModel extends ViewModel {

    private MutableLiveData<String> currentText;

    public MutableLiveData<String> getCurrentText() {
        if (currentText == null)
            return new MutableLiveData<>();
        return currentText;
    }
}
```

在Activity/Fragment中添加监听

```java
public class NewActivity extends AppCompatActivity {
    private LiveDataViewModel viewModel;
    private TextView textView;
    private Button button;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        textView = findViewById(R.id.text);
        button = findViewById(R.id.btn1);

        viewModel = ViewModelProviders.of(NewActivity.this).get(LiveDataViewModel.class);
        final Observer<String> testObserver = new Observer<String>() {
            @Override
            //监听回调
            public void onChanged(String s) {
                textView.setText(s);
            }
        };
        //注册监听
        viewModel.getCurrentText().observe(this, testObserver);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                viewModel.getCurrentText().setValue("12" + System.currentTimeMillis());
            }
        });
    }
}
```

这样即可以实现监听功能。

想了解更多实例可参考[LiveData官方示例](<https://developer.android.google.cn/topic/libraries/architecture/livedata#java>)

## LiveData源码解析

### LiveData

```java
public abstract class LiveData<T> {
    ...
}
```

`LiveData`是一个抽象类无法直接使用，一般都是应用其子类`MutableLiveData`

```java
public class MutableLiveData<T> extends LiveData<T> {
    @Override
    public void postValue(T value) {
        super.postValue(value);
    }

    @Override
    public void setValue(T value) {
        super.setValue(value);
    }
}

```

`MutableLiveData`多了设置数据的方法，以便开发者对内容进行修改。若不想有人进行修改，可以返回`LiveData`保证安全。



### Observer

构建LiveData完毕后，需要对其添加监听。

```java
public interface Observer<T> {
    /**
     * Called when the data is changed.
     * @param t  The new data
     */
    void onChanged(T t);
}
```

`Observer`只提供数据变化的监听并返回修改后的结果。

```java LiveData.java
private SafeIterableMap<Observer<? super T>, ObserverWrapper> mObservers =
            new SafeIterableMap<>();   

@MainThread
    public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {
        //监测是否在主线程操作
        assertMainThread("observe");
        // Activity/Frgment已被销毁就无需添加监听
        if (owner.getLifecycle().getCurrentState() == DESTROYED) {
            // ignore
            return;
        }
        //关键点
        LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);
        //取出对应的Observer
        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
        if (existing != null && !existing.isAttachedTo(owner)) {
            throw new IllegalArgumentException("Cannot add the same observer"
                    + " with different lifecycles");
        }
        //已存在就无需重复添加
        if (existing != null) {
            return;
        }
        //添加对应监听 而且只在UI可见时会有回调
        owner.getLifecycle().addObserver(wrapper);
    }

    //支持监听永久存在，不会因为Activity/Fragment销毁而消失
    @MainThread
    public void observeForever(@NonNull Observer<? super T> observer) {
        assertMainThread("observeForever");
        AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);
        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
        if (existing != null && existing instanceof LiveData.LifecycleBoundObserver) {
            throw new IllegalArgumentException("Cannot add the same observer"
                    + " with different lifecycles");
        }
        if (existing != null) {
            return;
        }
        //无需理会 宿主状态
        wrapper.activeStateChanged(true);
    }
```

- 当宿主组件已经Destroy时，就无需添加监听
- 需要新建一个`LifecycleBoundObserver`保存`owner以及observer`
- 从`mObservers.putIfAbsent()`中去获取或者插入对应observer
- 返回为null，则对`owner`添加该监听。

### LifecycleBoundObserver

```java LiveData.java
    //LiveData激活时回掉
    protected void onActive() {}
    //LiveData销毁时回掉
    protected void onInactive() {}

    private abstract class ObserverWrapper {
        final Observer<? super T> mObserver;
        boolean mActive;
        int mLastVersion = START_VERSION;

        ObserverWrapper(Observer<? super T> observer) {
            mObserver = observer;
        }

        abstract boolean shouldBeActive();

        boolean isAttachedTo(LifecycleOwner owner) {
            return false;
        }

        void detachObserver() {
        }

        void activeStateChanged(boolean newActive) {
            if (newActive == mActive) {
                return;
            }
            // immediately set active state, so we'd never dispatch anything to inactive
            // owner
            mActive = newActive;
            //mActiveCount 表示当前处于active的observer数量
            boolean wasInactive = LiveData.this.mActiveCount == 0;
            LiveData.this.mActiveCount += mActive ? 1 : -1;
            if (wasInactive && mActive) {
                onActive();
            }
            //激活数量为0  说明都被销毁
            if (LiveData.this.mActiveCount == 0 && !mActive) {
                onInactive();
            }
            if (mActive) {
                //分发数据
                dispatchingValue(this);
            }
        }
    }

    //绑定了生命周期
    class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {
        @NonNull
        final LifecycleOwner mOwner;

        LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {
            super(observer);
            mOwner = owner;
        }

        @Override
        boolean shouldBeActive() {
            //至少是用户可见状态即 onStart() ~ onStop()
            return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);
        }

        @Override
        public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {
            if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {
                //处于销毁态时 及时移除监听防止内存泄露
                removeObserver(mObserver);
                return;
            }
            activeStateChanged(shouldBeActive());
        }

        @Override
        boolean isAttachedTo(LifecycleOwner owner) {
            return mOwner == owner;
        }

        @Override
        void detachObserver() {
            mOwner.getLifecycle().removeObserver(this);
        }
    }
```

### 发布修改

设置数据完毕后，需要通知到监听者进行响应

```java LiveData.java
public abstract class LiveData<T> {

    // 同步修改数据
    protected void setValue(T value);

    // 会用 Handler post 一个 runnable，然后在 runnable 里面 setValue
    protected void postValue(T value);
}
```

`postValue()及setValue()`都是`protected`只有本身及子类才可以调用，又由于`LiveData`为`abstract`不可用`new `即使用子类才可以修改数据。

#### setValue()：同步调用

```java 
	private volatile Object mData = NOT_SET;    
	//需要执行在主线程
    @MainThread
    protected void setValue(T value) {
        //监测是否运行在主线程
        assertMainThread("setValue");
        //每修改一次数据，就添加一次版本号
        mVersion++;
        //即将发送的数据
        mData = value;
        dispatchingValue(null);
    }

	void dispatchingValue(@Nullable ObserverWrapper initiator) {
        if (mDispatchingValue) {
            //在onChanged的回调中 再次调用 setValue()时触发
            //final Observer<String> testObserver = new Observer<String>() {
            //@Override
            //public void onChanged(String s) {
            //    textView.setText(s);
            //    viewModel.getCurrentText().setValue("12" + System.currentTimeMillis());
            //}
            //};
            mDispatchInvalidated = true;
            return;
        }
        //为了防止循环调用
        mDispatchingValue = true;
        do {
            mDispatchInvalidated = false;
            if (initiator != null) {
                considerNotify(initiator);
                initiator = null;
            } else {
                for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =
                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {
                    //回调到对应方法
                    considerNotify(iterator.next().getValue());
                    if (mDispatchInvalidated) {
                        break;
                    }
                }
            }
        } while (mDispatchInvalidated);
        mDispatchingValue = false;
    }	

    //该方法可能在生命周期发送变更时被多次调用 但是数据却没有变化
    private void considerNotify(ObserverWrapper observer) {
        if (!observer.mActive) {
            return;
        }
        // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.
        //
        // we still first check observer.active to keep it as the entrance for events. So even if
        // the observer moved to an active state, if we've not received that event, we better not
        // notify for a more predictable notification order.
        if (!observer.shouldBeActive()) {
            observer.activeStateChanged(false);
            return;
        }
        //判定当前的分发是否有setValue()触发 利用mVersion 
        if (observer.mLastVersion >= mVersion) {
            return;
        }
        //重置成当前记录的mVersion
        observer.mLastVersion = mVersion;
        //回调到设置的 onChanged()
        observer.mObserver.onChanged((T) mData);
    }
```

##### 源码简述

调用`setValue()`：

- 先监测当前是否在主线程运行，否则抛出异常结束运行
- 设置当前存储的`mVersion+1`，以待后用
- 调用`dispatchValue()`进行数据分发
- 首先判断当前是否存在循环调用，在`dispatchValue()`中设置`mDispatchingValue`为true，操作结束完毕再设置false。还有一个`mDispatchInvalidated`标志位，如果该标志为true，表明已经发生了循环调用，需要重新开始。
- `considerNotify()`将消息发送到对应的观察者上，需要判定当前是否是因为调用`setValue()`导致的分发，因为在UI不可见时也不会调用分发，只有可见时才会调用，就可能导致重复分发，需要使用到`mVersion`来进行一次判定，如果小于记录的`mVersion`。即进行分发结束一次分发过程。

> 当Activity/Fragment挂在后台时，LiveData不会分发数据，`setValue()`的值就会被缓存到`mData`中，但是只能缓存一个值，所以当再次回到前台时，最终打到的就是最新的一次`setValue()`的数据。

#### postValue()：异步调用

```java
    // 使用volatile进行修饰，因为mPendingData 可能被其他线程进行修改
    private volatile Object mPendingData = NOT_SET;

    private final Runnable mPostValueRunnable = new Runnable() {
        @Override
        public void run() {
            Object newValue;
            synchronized (mDataLock) {
                newValue = mPendingData;
                mPendingData = NOT_SET;
            }
            //本质还是调用到了setValue()
            setValue((T) newValue);
        }
    };    

    protected void postValue(T value) {
        boolean postTask;
        synchronized (mDataLock) {
            postTask = mPendingData == NOT_SET;
            mPendingData = value;
        }
        //表明此时已有Runnable在执行，无需重复执行
        if (!postTask) {
            return;
        }
        //切换到主线程
        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);
    }

```

`postValue()`利用`ArchTaskExecutor`将发送消息逻辑切换到主线程上，实质执行的还是`setValue()`。

```java
public class ArchTaskExecutor extends TaskExecutor {
    private static volatile ArchTaskExecutor sInstance;
    
    @NonNull
    private TaskExecutor mDefaultTaskExecutor;
    
    private ArchTaskExecutor() {
        mDefaultTaskExecutor = new DefaultTaskExecutor();
        mDelegate = mDefaultTaskExecutor;
    }
    
    @Override
    public void postToMainThread(Runnable runnable) {
        mDelegate.postToMainThread(runnable);
    }
}
```

`archTaskExecutor`实质调用的是`DefaultTaskExecutor`去执行切换主线程任务

```java DefaultTAskExecutor.java
    @Override
    public void postToMainThread(Runnable runnable) {
        if (mMainHandler == null) {
            synchronized (mLock) {
                if (mMainHandler == null) {
                    //获取主线程Looper 并生成对应Handler
                    mMainHandler = new Handler(Looper.getMainLooper());
                }
            }
        }
        //noinspection ConstantConditions
        mMainHandler.post(runnable);
    }
```

通过`Handler`进行了主线程切换。

##### 源码简述

`postValue()`调用过程：

- 先根据`mPendingData`的值判定是否需要执行任务，当已有任务在执行时，不需要重复执行
- 调用`ArchArchTaskExecutor`实质调用了`DefaultTaskExecutor`去执行`postToMainThread()`
- 本质通过`Handler`进行了线程切换任务
- 最后切换主线程完毕后，去调用`setValue()`发送数据



## LiveData拓展

1. 根据源码分析，LiveData的数据接受的生命周期只在`onStart()`-> `onPause()`中，其他时间无法分发消息，只有等到回到用户可见时重新开始分发过程。
2. `LiveData`是通过`Lifecycle`与Activity/Fragment进行生命周期绑定的。
3. 由于`LiveData`是与生命周期进行绑定的，即使宿主被销毁，也不会造成内存泄露。



## 内容引用

[Jekton-LiveData](<https://jekton.github.io/2018/07/14/android-arch-LiveData/>)

[LiveData的工作原理](<https://juejin.im/post/5baee5205188255c930dea8a>)]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp简析</title>
    <url>/2019/03/08/OkHttp%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
> 基于OkHttp 3.13版本进行分析

![OkHttp简析](/images/OkHttp简析mind.png)

## OkHttp定义

`OkHttp`现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。

所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。

OkHttp支持`SPDY协议`，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。

> `SPDY协议`：Google提出的基于TCP的应用层协议，通过`压缩、多路复用、优先级`来缩短加载时间。

## OkHttp使用示例

### 构造请求

#### GET请求

```java
 Request request = new Request.Builder()
      .url(url)
      .build();

```

#### POST请求

```java
  RequestBody body = RequestBody.create(JSON, json);
  Request request = new Request.Builder()
      .url(url)
      .post(body)
      .build();
```

### 同步请求

```java
OkHttpClient client = new OkHttpClient();
Response response = client.newCall(request).execute();
return response.body().string();
```

### 异步请求

```java
OkHttpClient client = new OkHttpClient();

client.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
    }

    @Override
    public void onResponse(Call call, okhttp3.Response response) throws IOException {
    }
});
```



## OkHttp源码分析

### 构造`OkHttpClient`对象

![构造OkHttpClient对象](/images/OkHttp-构造OkHttpClient对象.png)

> 需要先创建一个`OkHttpClient`用以执行后续请求。**内部主要是相关参数配置。**
>
> 主要功能：通信的客户端，用以统一发起请求与解析返回值。

```java OkHttpClient.java
  public OkHttpClient() {
    this(new Builder());
  }

  OkHttpClient(Builder builder) {
    //用于调用网络请求 本质为 线程池
    this.dispatcher = builder.dispatcher;
    //设置代理
    this.proxy = builder.proxy;
    //设置协议
    this.protocols = builder.protocols;
    this.connectionSpecs = builder.connectionSpecs;
    //设置拦截器
    this.interceptors = Util.immutableList(builder.interceptors);
    //设置网络拦截器
    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
    //回调监听
    this.eventListenerFactory = builder.eventListenerFactory;
    this.proxySelector = builder.proxySelector;
    //Cookie
    this.cookieJar = builder.cookieJar;
    //缓存
    this.cache = builder.cache;
    this.internalCache = builder.internalCache;
    this.socketFactory = builder.socketFactory;

    boolean isTLS = false;
    for (ConnectionSpec spec : connectionSpecs) {
      isTLS = isTLS || spec.isTls();
    }

    //用于Https请求
    if (builder.sslSocketFactory != null || !isTLS) {
      this.sslSocketFactory = builder.sslSocketFactory;
      this.certificateChainCleaner = builder.certificateChainCleaner;
    } else {
      X509TrustManager trustManager = Util.platformTrustManager();
      this.sslSocketFactory = newSslSocketFactory(trustManager);
      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
    }

    if (sslSocketFactory != null) {
      Platform.get().configureSslSocketFactory(sslSocketFactory);
    }

    this.hostnameVerifier = builder.hostnameVerifier;
    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
        certificateChainCleaner);
    this.proxyAuthenticator = builder.proxyAuthenticator;
    this.authenticator = builder.authenticator;
    this.connectionPool = builder.connectionPool;
    this.dns = builder.dns;
    this.followSslRedirects = builder.followSslRedirects;
    this.followRedirects = builder.followRedirects;
    //是否需要重试
    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
    this.callTimeout = builder.callTimeout;
    //链接超时时长
    this.connectTimeout = builder.connectTimeout;
    //读取超时时间
    this.readTimeout = builder.readTimeout;
    //写入超时时间
    this.writeTimeout = builder.writeTimeout;
    this.pingInterval = builder.pingInterval;

    if (interceptors.contains(null)) {
      throw new IllegalStateException("Null interceptor: " + interceptors);
    }
    if (networkInterceptors.contains(null)) {
      throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
    }
  }
```

`OkHttpClient`是应用**建造者模式**，通过`OkHttpClient.Builder`来构造一个`OkHttpClient`对象，支持数十种参数配置。

### 构造`Request`请求对象

![OkHttp-构造Request请求对象](/images/OkHttp-构造Request请求对象.png)

> 创建一个`Request`对象用以包括请求的所有信息，内部包含了**请求地址，请求头，请求内容**。
>
> 主要功能：封装请求的具体信息。

```java Request.java
public final class Request {
  Request(Builder builder) {
    //请求地址
    this.url = builder.url;
    //请求方法 例如：GET、POST、PUT、DELETE等
    this.method = builder.method;
    //请求头信息
    this.headers = builder.headers.build();
    //请求内容构造体
    this.body = builder.body;
    //请求的标签  用于后续对指定标签可进行特殊处理
    this.tags = Util.immutableMap(builder.tags);
  }
    
  public static class Builder {
    @Nullable HttpUrl url;
    String method;
    Headers.Builder headers;
    @Nullable RequestBody body;

    /** A mutable map of tags, or an immutable empty map if we don't have any. */
    Map<Class<?>, Object> tags = Collections.emptyMap();
    
    //默认是GET方法，不带有请求体
    public Builder() {
      this.method = "GET";
      this.headers = new Headers.Builder();
    }

    Builder(Request request) {
      this.url = request.url;
      this.method = request.method;
      this.body = request.body;
      this.tags = request.tags.isEmpty()
          ? Collections.emptyMap()
          : new LinkedHashMap<>(request.tags);
      this.headers = request.headers.newBuilder();
    }
     ... 
  }
}
```

`Request`使用的也是**建造者模式**，通过`Request.Builder`去构造对应`Request`。

#### 请求体`RequestBody`

> 主要功能：用以提交**流、表单等请求信息**。

##### FormBody

> 支持提交键值对类型。例如`userId : 1 `

使用方法

```java
        FormBody.Builder formBodyBuilder = new FormBody.Builder();
        Map<String, Object> map = new ConcurrentHashMap<>();
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            formBodyBuilder.add(entry.getKey(), entry.getValue().toString());
        }
        RequestBody body = formBodyBuilder.build();
```



##### MultipartBody

> 除了支持键值对，还有提交文件功能。

使用方法

```java
 MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);
        Map<String, Object> map = new ConcurrentHashMap<>();
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            multipartBuilder.addFormDataPart(entry.getKey(), entry.getValue().toString());
        }
        //可以针对文件新起一个 参数来进行传递
        for (Map.Entry<String, File> entry : message.getFiles().entrySet()) {
            File f = entry.getValue();
            if (f == null)
                continue;
            String name = f.getName();
            String ext = name.substring(name.lastIndexOf('.'));
            String imageFormat = "jpg";
            if (".png".equalsIgnoreCase(ext)) {
                imageFormat = "png";
            }
            multipartBuilder.addFormDataPart(
                    entry.getKey(),
                    entry.getValue().getName(),
                    RequestBody.create(MediaType.parse("image/" + imageFormat), entry.getValue())
            );
        }

        RequestBody body = multipartBuilder.build();
```



### 发送`Request`请求

![OkHttp-发送Request请求](/images/OkHttp-发送Request请求.png)

通过`OkHttpClient.newCall()`发送出`Request`请求

```java OkHttpClient.java
  @Override public Call newCall(Request request) {
    return RealCall.newRealCall(this, request, false /* for web socket */);
  }
```

返回了一个`Call`对象，实现类为`RealCall`

```java
public interface Call extends Cloneable {
  //获取当前请求
  Request request();
  //执行当前请求 并返回结果
  Response execute() throws IOException;
  //异步请求
  void enqueue(Callback responseCallback);
  //取消请求
  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
  void cancel();
  //当前请求是否正在执行
  boolean isExecuted();
  //请求是否已取消
  boolean isCanceled();
  //超时返回
  Timeout timeout();
  //克隆请求 用于重新调用
  Call clone();

  interface Factory {
    Call newCall(Request request);
  }
}
```

```java RealCall.java
final class RealCall implements Call {
    private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
    	//前面先行创建的 OkHttpClient
    	this.client = client;
        //创建的请求对象
    	this.originalRequest = originalRequest;
   		//用于建立长连接
    	this.forWebSocket = forWebSocket;
  	}
    
    static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
    	// Safely publish the Call instance to the EventListener.
    	RealCall call = new RealCall(client, originalRequest, forWebSocket);
        //为这次请求设置了事件监听器，包括请求开始、结束、异常等监听
    	call.transmitter = new Transmitter(client, call);
    	return call;
  	}
}
```

通过`newCall()`根据传递进来的`Request`创建一个`RealCall`实例去发送请求。

#### 同步请求——execute()

> 直接执行并返回请求结果

```java
@Override public Response execute() throws IOException {
    synchronized (this) {
      if (executed) throw new IllegalStateException("Already Executed");
      executed = true;
    }
    transmitter.timeoutEnter();
    //请求开始
    transmitter.callStart();
    try {
      //加入 runningSuncCalls 队列中
      client.dispatcher().executed(this);
      //返回响应结果
      return getResponseWithInterceptorChain();
    } finally {
      //从队列中移除 避免重复执行
      client.dispatcher().finished(this);
    }
  }
```

> 执行`execute()`时，监听到请求事件开始，就会加入到`Dispatcher.runningSyncCalls`中，里面记录的是当前正在进行同步请求的call，然后当call完成时或因异常结束时，再从`Dispatcher.runningSyncCalls`移除。

#### 异步请求——enqueue(Callback callback)

> 构造一个异步执行队列，然后把请求加入队列中处理

```java
  @Override public void enqueue(Callback responseCallback) {
    synchronized (this) {
      if (executed) throw new IllegalStateException("Already Executed");
      executed = true;
    }
    transmitter.callStart();
    client.dispatcher().enqueue(new AsyncCall(responseCallback));
  }

final class AsyncCall extends NamedRunnable {
    private final Callback responseCallback;
    private volatile AtomicInteger callsPerHost = new AtomicInteger(0);

    AsyncCall(Callback responseCallback) {
      super("OkHttp %s", redactedUrl());
      this.responseCallback = responseCallback;
    }

    AtomicInteger callsPerHost() {
      return callsPerHost;
    }
    ...

    void executeOn(ExecutorService executorService) {
      assert (!Thread.holdsLock(client.dispatcher()));
      boolean success = false;
      try {
        executorService.execute(this);
        success = true;
      } catch (RejectedExecutionException e) {
        InterruptedIOException ioException = new InterruptedIOException("executor rejected");
        ioException.initCause(e);
        transmitter.noMoreExchanges(ioException);
        responseCallback.onFailure(RealCall.this, ioException);
      } finally {
        if (!success) {
          client.dispatcher().finished(this); // This call is no longer running!
        }
      }
    }

    @Override protected void execute() {
      boolean signalledCallback = false;
      transmitter.timeoutEnter();
      try {
        Response response = getResponseWithInterceptorChain();
        signalledCallback = true;
        //回调请求结果
        responseCallback.onResponse(RealCall.this, response);
      } catch (IOException e) {
        if (signalledCallback) {
          // Do not signal the callback twice!
          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
        } else {
          //回调失败并返回异常
          responseCallback.onFailure(RealCall.this, e);
        }
      } finally {
        //从队列中移除
        client.dispatcher().finished(this);
      }
    }
  }

```

> `enqueue()`调用到`Dispatcher.enqueue()`传入的是一个`AsyncCall`对象，`AsyncCall`本质是一个`Runnable`对象，通过`Dispatcher`中的`ExecutorService`来执行`AsyncCall`。

### 执行`Request`请求

> 由`execute()`或`enqueue()`发送请求时，最后都是需要有`Dispatch`去执行请求。

```java
public final class Dispatcher {
  private int maxRequests = 64;
  private int maxRequestsPerHost = 5;
    
  private @Nullable ExecutorService executorService;
  //正在准备执行的异步请求队列
  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
  //正在执行的异步请求队列
  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
  //正在执行的同步请求队列 
  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
    
  //用以执行异步请求
  public synchronized ExecutorService executorService() {
    if (executorService == null) {
      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
          new SynchronousQueue<>(), Util.threadFactory("OkHttp Dispatcher", false));
    }
    return executorService;
  }
    
  void enqueue(AsyncCall call) {
    synchronized (this) {
      //加入正在执行的异步队列中
      readyAsyncCalls.add(call);

      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to
      // the same host.
      if (!call.get().forWebSocket) {
        AsyncCall existingCall = findExistingCallWithHost(call.host());
        if (existingCall != null) call.reuseCallsPerHostFrom(existingCall);
      }
    }
    promoteAndExecute();
  }
    
  //加入正在执行的同步队列
  synchronized void executed(RealCall call) {
    runningSyncCalls.add(call);
  }
  //从政在执行的异步队列中移除  
  void finished(AsyncCall call) {
    call.callsPerHost().decrementAndGet();
    finished(runningAsyncCalls, call);
  }
  //执行完毕后  从正在执行的同步队列中移除
  void finished(RealCall call) {
    finished(runningSyncCalls, call);
  }
    
  private <T> void finished(Deque<T> calls, T call) {
    Runnable idleCallback;
    synchronized (this) {
      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
      idleCallback = this.idleCallback;
    }
    boolean isRunning = promoteAndExecute();
    if (!isRunning && idleCallback != null) {
      idleCallback.run();
    }
  }
    
  private boolean promoteAndExecute() {
    //判定当前线程是否持有锁
    assert (!Thread.holdsLock(this));

    List<AsyncCall> executableCalls = new ArrayList<>();
    boolean isRunning;
    synchronized (this) {
      
      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
        AsyncCall asyncCall = i.next();
        //正在运行的异步请求不能超过 64个
        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
        //在同一个Host下的异步请求不能超过5个
        if (asyncCall.callsPerHost().get() >= maxRequestsPerHost) continue; // Host max capacity.

        i.remove();
        //CAS
        asyncCall.callsPerHost().incrementAndGet();
        //添加至异步执行队列
        executableCalls.add(asyncCall);
        //添加至正在执行异步请求队列
        runningAsyncCalls.add(asyncCall);
      }
      isRunning = runningCallsCount() > 0;
    }

    for (int i = 0, size = executableCalls.size(); i < size; i++) {
      AsyncCall asyncCall = executableCalls.get(i);
      //执行异步请求
      asyncCall.executeOn(executorService());
    }

    return isRunning;
  }
}
```

`Dispatcher`是一个任务调度器，内部维护了三个双端队列：

- `readyAsyncCalls`：准备执行的异步请求。*已经超过请求上限的异步请求就会放在该队列中。*
- `runningAsyncCalls`：正在执行的异步请求。*不超过请求上限时，异步请求会加入到该队列中，超过时，依然放到`readyAsyncCalls`中。*
- `runningSyncCalls`：正在执行的同步请求。*直接把同步请求添加到该队列中。*

通过`Dispatcher`中的`executorService`去执行对应请求。

### 处理`Request`请求——通过拦截器

![OkHttp-处理Request请求](/images/OkHttp-处理Request请求.png)

> 通过`Dispatcher`执行完请求后，返回回调结果前，需要通过`getResponseWithInterceptorChain()`通过层层责任链的执行来获得最终的请求结果。
>
> **通过责任链模式将请求一层层的通过拦截器进行处理。**

```java RealCall.java
Response getResponseWithInterceptorChain() throws IOException {
    // Build a full stack of interceptors.
    List<Interceptor> interceptors = new ArrayList<>();
    //加入用户自定义的拦截器
    interceptors.addAll(client.interceptors());
    //重试和重定向拦截器
    interceptors.add(new RetryAndFollowUpInterceptor(client));
    //转化用户请求为网络请求
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    //负责读取缓存以及更新缓存
    interceptors.add(new CacheInterceptor(client.internalCache()));
    //与服务器建立连接
    interceptors.add(new ConnectInterceptor(client));
    if (!forWebSocket) {
       //用户自定义的网络拦截器
      interceptors.addAll(client.networkInterceptors());
    }
    //从服务器读取响应的数据
    interceptors.add(new CallServerInterceptor(forWebSocket));

    Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0,
        originalRequest, this, client.connectTimeoutMillis(),
        client.readTimeoutMillis(), client.writeTimeoutMillis());

    boolean calledNoMoreExchanges = false;
    try {
      //链式调用拦截器，最终返回 Response
      Response response = chain.proceed(originalRequest);
      if (transmitter.isCanceled()) {
        closeQuietly(response);
        throw new IOException("Canceled");
      }
      return response;
    } catch (IOException e) {
      calledNoMoreExchanges = true;
      throw transmitter.noMoreExchanges(e);
    } finally {
      if (!calledNoMoreExchanges) {
        transmitter.noMoreExchanges(null);
      }
    }
  }
```

在获得响应结果之前，需要对用户设置的原始请求转换为实际的网络请求，然后通过一系列拦截器，直到最终得到结果，采用**链式调用**保证这些拦截器的执行顺序。

#### OkHttp拦截器

> 所有的拦截器都实现了`Interceptor`接口，支持用户去自定义拦截器，只要实现`Interceptor`接口即可。
>
> 拦截器可以 用来*监控、改写和重试HTTP访问*。

```java
public interface Interceptor {
  //主要实现该接口，控制返回结果
  Response intercept(Chain chain) throws IOException;

  interface Chain {
    
    Request request();

    Response proceed(Request request) throws IOException;

    //返回Request执行后的返回结果
    @Nullable Connection connection();

    Call call();

    int connectTimeoutMillis();

    Chain withConnectTimeout(int timeout, TimeUnit unit);

    int readTimeoutMillis();

    Chain withReadTimeout(int timeout, TimeUnit unit);

    int writeTimeoutMillis();

    Chain withWriteTimeout(int timeout, TimeUnit unit);
  }
}
```

##### `ApplicationInterceptor`

![OkHttp-ApplicationInterceptor](/images/OkHttp-ApplicationInterceptor.png)

> 该拦截器会被第一个执行，此处得到的`Request`为最原始状态。但是最终得到的`Response`是最终的结果。

引用代码

```java
OkHttpClient client = new OkHttpClient.Builder()
    .addInterceptor(new LoggingInterceptor())
    .build();
```

> `ApplicationInterceptor`适用于在请求前统一添加一些公共参数，例如`App的版本号，系统信息`等。
>
> 也可用于对返回的`Response`进行加工。

`ApplicationInterceptor`有以下特定：

- 不需要关心后续拦截器进行的操作，因为是会被第一个执行的，只要关心返回结果即可。
- 只会被响应一次，即使强制缓存获取
- 可以对后续的拦截器调用进行拦截或者进行多次调用——**通过`Chain.proceed()`进行控制**

##### `RetryAndFollowUpInterceptor`

![OkHttp-RetryAndFollowUpInterceptor](/images/OkHttp-RetryAndFollowUpInterceptor.png)

> 负责失败重试和重定向的拦截器。

```java
public final class RetryAndFollowUpInterceptor implements Interceptor {
    @Override public Response intercept(Chain chain) throws IOException {
    //从自定义拦截器 那里传递下来的请求
    Request request = chain.request();
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    //获取事件监听器
    Transmitter transmitter = realChain.transmitter();
    //初始化 重定向次数
    int followUpCount = 0;
    Response priorResponse = null;
    //开启死循环 进行重试操作
    while (true) {
      transmitter.prepareToConnect(request);
      //请求取消
      if (transmitter.isCanceled()) {
        throw new IOException("Canceled");
      }

      Response response;
      boolean success = false;
      try {
        //向下调用 下一个拦截器——BridgeInterceptor
        response = realChain.proceed(request, transmitter, null);
        success = true;
      } catch (RouteException e) {
        // 不需要重试 则抛出异常
        if (!recover(e.getLastConnectException(), transmitter, false, request)) {
          throw e.getFirstConnectException();
        }
        continue;
      } catch (IOException e) {
        // 无法与服务端建立连接
        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
        if (!recover(e, transmitter, requestSendStarted, request)) throw e;
        continue;
      } finally {
        // The network call threw an exception. Release any resources.
        if (!success) {
          //释放资源
          transmitter.exchangeDoneDueToException();
        }
      }

      // Attach the prior response if it exists. Such responses never have a body.
      if (priorResponse != null) {
        response = response.newBuilder()
            .priorResponse(priorResponse.newBuilder()
                    .body(null)
                    .build())
            .build();
      }

      Exchange exchange = Internal.instance.exchange(response);
      Route route = exchange != null ? exchange.connection().route() : null;
      //根据返回的 response的Code 判断是否需要进行重定向
      Request followUp = followUpRequest(response, route);

      if (followUp == null) {
        //释放资源
        if (exchange != null && exchange.isDuplex()) {
          transmitter.timeoutEarlyExit();
        }
        return response;
      }

      RequestBody followUpBody = followUp.body();
      if (followUpBody != null && followUpBody.isOneShot()) {
        return response;
      }

      closeQuietly(response.body());
      if (transmitter.hasExchange()) {
        exchange.detachWithViolence();
      }

      //超出重定向次数
      if (++followUpCount > MAX_FOLLOW_UPS) {
        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
      }
      //获取重定向结果 赋予 request继续向下请求
      request = followUp;
      priorResponse = response;
    }
  }
    
  private boolean recover(IOException e, Transmitter transmitter,
      boolean requestSendStarted, Request userRequest) {
    // 未开启重试 retryOnConnectionFailure(false)
    if (!client.retryOnConnectionFailure()) return false;
    // 只允许发送一次 isOneShot(){return true;}
    if (requestSendStarted && requestIsOneShot(e, userRequest)) return false;
    // 发生异常
    if (!isRecoverable(e, requestSendStarted)) return false;
    // 设置不允许重试
    if (!transmitter.canRetry()) return false;
    return true;
  }
}
```

> 1. 尝试执行下一个拦截器，即`BridgeInterceptor`
> 2. 抛出异常，需要根据以下情况去判断是否需要重试：
>    - 客户端是否开启  `retryOnConnectionFailure`
>    - `RequestBody.isOneShot()`返回值
>    - 判断异常类型，除了`ConnectionShutdownException`被中断情况外的`IOException`的子类，都不会进行重试
> 3. 根据Response返回的响应码`code`进行处理

```java RetryAndFollowUpInterceptor.java
private Request followUpRequest(Response userResponse, @Nullable Route route) throws IOException {
    if (userResponse == null) throw new IllegalStateException();
    int responseCode = userResponse.code();

    final String method = userResponse.request().method();
    switch (responseCode) {
      // 407 需要进行代理认证
      case HTTP_PROXY_AUTH:
        Proxy selectedProxy = route != null
            ? route.proxy()
            : client.proxy();
        if (selectedProxy.type() != Proxy.Type.HTTP) {
          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
        }
        return client.proxyAuthenticator().authenticate(route, userResponse);
      // 401 未经认证
      case HTTP_UNAUTHORIZED:
        return client.authenticator().authenticate(route, userResponse);
      // 307 永久重定向  308 临时重定向  只有GET、HEAD请求方法才有效
      case HTTP_PERM_REDIRECT:
      case HTTP_TEMP_REDIRECT:
        // "If the 307 or 308 status code is received in response to a request other than GET
        // or HEAD, the user agent MUST NOT automatically redirect the request"
        if (!method.equals("GET") && !method.equals("HEAD")) {
          return null;
        }
        // fall-through
      
      case HTTP_MULT_CHOICE:// 300  多个重定向地址
      case HTTP_MOVED_PERM:// 301 永久移除 指向了新的位置
      case HTTP_MOVED_TEMP://302  临时移除
      case HTTP_SEE_OTHER://303 查看其他位置
        // 开发者是否允许重定向
        if (!client.followRedirects()) return null;
        //重定向后的实际地址
        String location = userResponse.header("Location");
        if (location == null) return null;
        HttpUrl url = userResponse.request().url().resolve(location);

        // Don't follow redirects to unsupported protocols.
        if (url == null) return null;

        // If configured, don't follow redirects between SSL and non-SSL.
        boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
        if (!sameScheme && !client.followSslRedirects()) return null;

        // Most redirects don't include a request body.
        Request.Builder requestBuilder = userResponse.request().newBuilder();
        if (HttpMethod.permitsRequestBody(method)) {
          final boolean maintainBody = HttpMethod.redirectsWithBody(method);
          if (HttpMethod.redirectsToGet(method)) {
            requestBuilder.method("GET", null);
          } else {
            RequestBody requestBody = maintainBody ? userResponse.request().body() : null;
            requestBuilder.method(method, requestBody);
          }
          if (!maintainBody) {
            requestBuilder.removeHeader("Transfer-Encoding");
            requestBuilder.removeHeader("Content-Length");
            requestBuilder.removeHeader("Content-Type");
          }
        }

        // When redirecting across hosts, drop all authentication headers. This
        // is potentially annoying to the application layer since they have no
        // way to retain them.
        if (!sameConnection(userResponse.request().url(), url)) {
          requestBuilder.removeHeader("Authorization");
        }

        return requestBuilder.url(url).build();
      //408 超时
      case HTTP_CLIENT_TIMEOUT:
        // 408's are rare in practice, but some servers like HAProxy use this response code. The
        // spec says that we may repeat the request without modifications. Modern browsers also
        // repeat the request (even non-idempotent ones.)
        if (!client.retryOnConnectionFailure()) {
          // The application layer has directed us not to retry the request.
          return null;
        }

        RequestBody requestBody = userResponse.request().body();
        if (requestBody != null && requestBody.isOneShot()) {
          return null;
        }

        if (userResponse.priorResponse() != null
            && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
          // We attempted to retry and got another timeout. Give up.
          return null;
        }

        if (retryAfter(userResponse, 0) > 0) {
          return null;
        }

        return userResponse.request();
      //503 服务端不可用
      case HTTP_UNAVAILABLE:
        if (userResponse.priorResponse() != null
            && userResponse.priorResponse().code() == HTTP_UNAVAILABLE) {
          // We attempted to retry and got another timeout. Give up.
          return null;
        }

        if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
          // specifically received an instruction to retry without delay
          return userResponse.request();
        }

        return null;

      default:
        return null;
    }
  }
```

通过`followUpRequest()`对`Response`返回的`code`进行对应操作，在触发到重定向相关的code`3XX`时，需要对应的转换`Request`使用获取到的重定向后地址进行请求。

> 由源码可知，可以重试的最大次数为**20**次，可以通过`retryOnConnectionFailure(true)`设置支持重试。但是不支持自定义重试次数，若需要自定义重试次数，需要自定义拦截器去实现。

```kotlin
class RetryInterceptor(var maxRetry: Int/*最大重试次数*/) : Interceptor {
        //当前重试次数
        private var retryNum = 0

        override fun intercept(chain: Interceptor.Chain): Response {
            val request = chain.request()
            var response = chain.proceed(request)

            while (!response.isSuccessful && retryNum < maxRetry) {
                retryNum++
                response = chain.proceed(request)
            }
            return response
        }
    }
```



##### `BridgeInterceptor`

![OkHttp-BridgeInterceptor](/images/OkHttp-BridgeInterceptor.png)

> 用以将用户的请求转换为向服务器的请求，之后再把服务器返回的数据转换成用户直观的数据。**主要是对Header进行处理**

```java
public final class BridgeInterceptor implements Interceptor {
    @Override public Response intercept(Chain chain) throws IOException {
    Request userRequest = chain.request();
    Request.Builder requestBuilder = userRequest.newBuilder();
    //重构用户请求 为 服务器请求格式
    RequestBody body = userRequest.body();
    //如果存在Body
    if (body != null) {
      //对Header进行调整
      MediaType contentType = body.contentType();
      if (contentType != null) {
        requestBuilder.header("Content-Type", contentType.toString());
      }

      long contentLength = body.contentLength();
      if (contentLength != -1) {
        requestBuilder.header("Content-Length", Long.toString(contentLength));
        requestBuilder.removeHeader("Transfer-Encoding");
      } else {
        requestBuilder.header("Transfer-Encoding", "chunked");
        requestBuilder.removeHeader("Content-Length");
      }
    }
    //设置Header中的 host
    if (userRequest.header("Host") == null) {
      requestBuilder.header("Host", hostHeader(userRequest.url(), false));
    }

    //设置 connection : Keep-Alive 保持长连接模式
    if (userRequest.header("Connection") == null) {
      requestBuilder.header("Connection", "Keep-Alive");
    }

    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
    // the transfer stream.
    boolean transparentGzip = false;
    //默认使用Gzip压缩
    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
      transparentGzip = true;
      requestBuilder.header("Accept-Encoding", "gzip");
    }
    //设置 Cookie信息
    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
    if (!cookies.isEmpty()) {
      requestBuilder.header("Cookie", cookieHeader(cookies));
    }
    //设置UA
    if (userRequest.header("User-Agent") == null) {
      requestBuilder.header("User-Agent", Version.userAgent());
    }
    //传递至下一个拦截器处理
    Response networkResponse = chain.proceed(requestBuilder.build());

    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());

    Response.Builder responseBuilder = networkResponse.newBuilder()
        .request(userRequest);
    //如果服务器支持Gzip压缩，需要进行解压操作
    if (transparentGzip
        && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
        && HttpHeaders.hasBody(networkResponse)) {
      GzipSource responseBody = new GzipSource(networkResponse.body().source());
      Headers strippedHeaders = networkResponse.headers().newBuilder()
          .removeAll("Content-Encoding")
          .removeAll("Content-Length")
          .build();
      responseBuilder.headers(strippedHeaders);
      String contentType = networkResponse.header("Content-Type");
      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
    }

    return responseBuilder.build();
  }
}
```

> `GZip`：是一种压缩技术，可以改进Web应用的性能，将请求体明显的减少其大小，如果服务器也支持该格式，就会返回对应格式的内容，客户端需要进行解压操作，可以明显的减少流量消耗。

`BridgeInterceptor`主要执行了以下3步：

- 用户请求转换为网络请求

  在原来`Request`上添加了很多`Header`，例如`Content-Type(定义网络文件的类型和网页的编码)、Content-Length(请求体内容长度)、Transfer-Encoding(请求体的大小)与Content-Length互斥、Accept-Encoding(编码格式)`。

  未设置`Accept-Encoding`默认为`gzip`。

- 执行转换后的网络请求

  `chain.proceed(requestBuilder.build())`

- 服务器返回的响应结果转换为用户响应结果

  根据上一步获得`Response`后，需要再次转化为用户直观格式。主要在于服务端返回的信息里是否设置了`Accept-Encoding:gzip`，设置了则需要进行解压过程，获取最终结果。

##### `CacheInterceptor`

![OkHttp-CacheInterceptor](/images/OkHttp-CacheInterceptor.png)

> 主要用于**读取缓存以及更新缓存的**，**为了节省流量和提高响应速度**。

```java
public final class CacheInterceptor implements Interceptor {
    @Override public Response intercept(Chain chain) throws IOException {
    //根据请求的相关信息获取缓存
    Response cacheCandidate = cache != null
        ? cache.get(chain.request())
        : null;

    long now = System.currentTimeMillis();
    //创建缓存策略
    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();①
    Request networkRequest = strategy.networkRequest;
    Response cacheResponse = strategy.cacheResponse;

    if (cache != null) {
      cache.trackResponse(strategy);
    }
    //缓存无法使用，关闭获得的Response
    if (cacheCandidate != null && cacheResponse == null) {
      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
    }

    // 根据策略，不使用网络且没有缓存的直接报错，返回504
    if (networkRequest == null && cacheResponse == null) {
      return new Response.Builder()
          .request(chain.request())
          .protocol(Protocol.HTTP_1_1)
          .code(504)
          .message("Unsatisfiable Request (only-if-cached)")
          .body(Util.EMPTY_RESPONSE)
          .sentRequestAtMillis(-1L)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build();
    }

    // 直接返回缓存，不允许使用网络
    if (networkRequest == null) {
      return cacheResponse.newBuilder()
          .cacheResponse(stripBody(cacheResponse))
          .build();
    }

    Response networkResponse = null;
    try {
      //请求向下传递
      networkResponse = chain.proceed(networkRequest);
    } finally {
      // If we're crashing on I/O or otherwise, don't leak the cache body.
      if (networkResponse == null && cacheCandidate != null) {
        closeQuietly(cacheCandidate.body());
      }
    }

    // 接受到服务器返回数据，如果返回code为 304 直接使用缓存结果
    if (cacheResponse != null) {
      if (networkResponse.code() == HTTP_NOT_MODIFIED) {
        Response response = cacheResponse.newBuilder()
            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
            .cacheResponse(stripBody(cacheResponse))
            .networkResponse(stripBody(networkResponse))
            .build();
        networkResponse.body().close();

        // Update the cache after combining headers but before stripping the
        // Content-Encoding header (as performed by initContentStream()).
        cache.trackConditionalCacheHit();
        //更新当前存储的缓存信息
        cache.update(cacheResponse, response);
        return response;
      } else {
        closeQuietly(cacheResponse.body());
      }
    }
    //读取服务器返回结果
    Response response = networkResponse.newBuilder()
        .cacheResponse(stripBody(cacheResponse))
        .networkResponse(stripBody(networkResponse))
        .build();
    //对数据进行缓存
    if (cache != null) {
      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
        // Offer this request to the cache.
        CacheRequest cacheRequest = cache.put(response);
        return cacheWritingResponse(cacheRequest, response);
      }

      if (HttpMethod.invalidatesCache(networkRequest.method())) {
        try {
          cache.remove(networkRequest);
        } catch (IOException ignored) {
          // The cache cannot be written.
        }
      }
    }

    return response;
  }
}
```

`CacheInterceptor`的执行流程如下所示：

1. 先行读取缓存数据
2. 创建好对应的缓存策略：`强制缓存`、`对比缓存`
3. 根据缓存策略，不使用网络、也没有对应缓存，返回`504`
4. 根据缓存策略，不使用网络，存在缓存则直接返回
5. 前面都没有返回结果，继续向下执行请求：`chain.proceed()`
6. 接受到对应网络结果，如果返回code为`304`，代表直接使用缓存并更新对应缓存信息
7. 读取网络结果，对数据进行缓存
8. 返回获取的网络结果

具体的缓存策略请参考[缓存策略](#OkHttp缓存机制)

##### `ConnectInterceptor`

![OkHttp-ConnectInterceptor](/images/OkHttp-ConnectInterceptor.png)

> 真正与服务端建立连接，底层是通过`Socket`进行连接。

```java
public final class ConnectInterceptor implements Interceptor {
  public final OkHttpClient client;

  @Override public Response intercept(Chain chain) throws IOException {
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    Request request = realChain.request();
    Transmitter transmitter = realChain.transmitter();

    // We need the network to satisfy this request. Possibly for validating a conditional GET.
    boolean doExtensiveHealthChecks = !request.method().equals("GET");
    //建立连接
    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);
    //继续请求下一个拦截器
    return realChain.proceed(request, transmitter, exchange);
  }
}
```

`ConnectInterceptor`主要功能是建立与服务器的连接关系，通过`Transmitter.newExchange()`建立连接，建立完成后继续向下执行请求。

具体的连接过程可以参考[连接机制](# OkHttp连接机制)

##### `NetworkInterceptor`

![OkHttp-NetworkInterceptor](/images/OkHttp-NetworkInterceptor.png)

> 用户自定义的网络拦截器，处于第6个拦截器，前面经过了`RetryAndFolowUpInterceptor`的重定向过程以及`BridgeInterceptor`的请求头处理，在此处可以获取到更多的连接信息。

引用代码

```java
OkHttpClient client = new OkHttpClient.Builder()
    .addNetworkInterceptor(new LoggingInterceptor())
    .build();
```

> `NetworkInterceptor`可以获取到最终请求的`Request`，以及获取到真正进行过网络请求的得到的`Response`，从而可以针对`Response`进行修改然后再回传到上层拦截器。

`NetworkInterceptor`主要有以下特点：

- 可以操作经过`重定向、重试`得到的`Response`
- 无法响应缓存数据的请求，因为`CacheInterceptor`执行在它之前
- 得到最终进行请求的`Request`
- 可以获得连接信息

##### `CallServerInterceptor`

![OkHttp-CallServerInterceptor](/images/OkHttp-CallServerInterceptor.png)

> 数据的写入过程，也就是客户端和服务端进行交互的过程，客户端发送数据，服务端返回数据。

```java
public final class CallServerInterceptor implements Interceptor {
@Override public Response intercept(Chain chain) throws IOException {
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    Exchange exchange = realChain.exchange();
    Request request = realChain.request();

    long sentRequestMillis = System.currentTimeMillis();
    //写入请求头
    exchange.writeRequestHeaders(request);

    boolean responseHeadersStarted = false;
    Response.Builder responseBuilder = null;
    //判断当前是否有 请求体body
    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
      // Continue" response before transmitting the request body. If we don't get that, return
      // what we did get (such as a 4xx response) without ever transmitting the request body.
      //如果是1XX的话 表示当前需要等服务端响应 
      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
        exchange.flushRequest();
        responseHeadersStarted = true;
        exchange.responseHeadersStart();
        responseBuilder = exchange.readResponseHeaders(true);
      }

      
      if (responseBuilder == null) {
        //写入请求体
        if (request.body().isDuplex()) {
          // Prepare a duplex body so that the application can send a request body later.
          exchange.flushRequest();
          BufferedSink bufferedRequestBody = Okio.buffer(
              exchange.createRequestBody(request, true));
          request.body().writeTo(bufferedRequestBody);
        } else {
          // Write the request body if the "Expect: 100-continue" expectation was met.
          BufferedSink bufferedRequestBody = Okio.buffer(
              exchange.createRequestBody(request, false));
          request.body().writeTo(bufferedRequestBody);
          bufferedRequestBody.close();
        }
      } else {
        exchange.noRequestBody();
        if (!exchange.connection().isMultiplexed()) {
          // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
          // from being reused. Otherwise we're still obligated to transmit the request body to
          // leave the connection in a consistent state.
          exchange.noNewExchangesOnConnection();
        }
      }
    } else {
      exchange.noRequestBody();
    }

    if (request.body() == null || !request.body().isDuplex()) {
        //结束请求
      exchange.finishRequest();
    }

    if (!responseHeadersStarted) {
      exchange.responseHeadersStart();
    }
    //得到响应头
    if (responseBuilder == null) {
      responseBuilder = exchange.readResponseHeaders(false);
    }
    
    Response response = responseBuilder
        .request(request)
        .handshake(exchange.connection().handshake())
        .sentRequestAtMillis(sentRequestMillis)
        .receivedResponseAtMillis(System.currentTimeMillis())
        .build();
    //读取响应体内容
    int code = response.code();
    if (code == 100) {
      // server sent a 100-continue even though we did not request one.
      // try again to read the actual response
      response = exchange.readResponseHeaders(false)
          .request(request)
          .handshake(exchange.connection().handshake())
          .sentRequestAtMillis(sentRequestMillis)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build();

      code = response.code();
    }

    exchange.responseHeadersEnd(response);
    //forWebSocket 表示为socket连接方式
    if (forWebSocket && code == 101) {
      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
      response = response.newBuilder()
          .body(Util.EMPTY_RESPONSE)
          .build();
    } else {
      response = response.newBuilder()
          .body(exchange.openResponseBody(response))
          .build();
    }
    // close表示关闭连接
    if ("close".equalsIgnoreCase(response.request().header("Connection"))
        || "close".equalsIgnoreCase(response.header("Connection"))) {
      exchange.noNewExchangesOnConnection();
    }

    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
      throw new ProtocolException(
          "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
    }

    return response;
  }
}
```

`CallServerInterceptor`主要执行了以下过程：

- 写入请求头
- 写入请求体(如果存在)
- 获取状态行及响应头
- 获取响应体

`CallServerInterceptor`已经是最后一个拦截器了，接下来就是向上回溯并返回自己获得的`Response`。

> HTTP报文结构：
>
> **请求报文**：
>
> 请求行：声明请求方法、主机域名及协议版本
>
> 请求头：声明客户端的部分报文信息
>
> 请求体：存放客户端发送给服务器的数据
>
> **响应报文**
>
> 状态行：声明HTTP协议版本、状态码及描述
>
> 响应头：声明服务端的部分报文信息
>
> 响应体：服务端返回客户端的数据

#### 责任链模式串联

介绍完上述的拦截器后，接下来就是分析如何将这些拦截器进行串联调用。

```java RealCall.java
Response getResponseWithInterceptorChain() throws IOException {
    // Build a full stack of interceptors.
    List<Interceptor> interceptors = new ArrayList<>();
    ...
    //构建责任链
    Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0,
        originalRequest, this, client.connectTimeoutMillis(),
        client.readTimeoutMillis(), client.writeTimeoutMillis());

    boolean calledNoMoreExchanges = false;
    try {
      //开始从头链式调用拦截器
      Response response = chain.proceed(originalRequest);
      if (transmitter.isCanceled()) {
        closeQuietly(response);
        throw new IOException("Canceled");
      }
      return response;
    } catch (IOException e) {
      calledNoMoreExchanges = true;
      throw transmitter.noMoreExchanges(e);
    } finally {
      if (!calledNoMoreExchanges) {
        transmitter.noMoreExchanges(null);
      }
    }
  }
```

实际执行链式调用的是`RealInterceptorChain`，由他负责责任链的执行

```java
public final class RealInterceptorChain implements Interceptor.Chain {
    @Override public Response proceed(Request request) throws IOException {
    return proceed(request, transmitter, exchange);
  }

  public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange)
      throws IOException {
    if (index >= interceptors.size()) throw new AssertionError();

    calls++;

    // 存在已经在使用的流，直接进行复用
    if (this.exchange != null && !this.exchange.connection().supportsUrl(request.url())) {
      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
          + " must retain the same host and port");
    }

    // If we already have a stream, confirm that this is the only call to chain.proceed().
    if (this.exchange != null && calls > 1) {
      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
          + " must call proceed() exactly once");
    }

    // 调用该链中的下一个拦截器 实质为 用户自定义的拦截器，不存在则为 RetryAndFollowUpInterceptor
    RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange,
        index + 1, request, call, connectTimeout, readTimeout, writeTimeout);
    Interceptor interceptor = interceptors.get(index);
    Response response = interceptor.intercept(next);

    // Confirm that the next interceptor made its required call to chain.proceed().
    if (exchange != null && index + 1 < interceptors.size() && next.calls != 1) {
      throw new IllegalStateException("network interceptor " + interceptor
          + " must call proceed() exactly once");
    }

    // Confirm that the intercepted response isn't null.
    if (response == null) {
      throw new NullPointerException("interceptor " + interceptor + " returned null");
    }

    if (response.body() == null) {
      throw new IllegalStateException(
          "interceptor " + interceptor + " returned a response with no body");
    }

    return response;
  }
}
```

`RealIntercrptor`为链式调用的起点，调用`proceed()`之后，继续调用下一层的拦截器，直到得到最终的Response。

后续的拦截器也是按照这个规则向下执行，内部都会调用到`chain.proceed()`直到没有调用为止。

**Request是按照定义的`interceptor`顺序向下执行，然后Response是逆向向上处理的。**

### 获取请求结果`Response`

> `Response`：返回HTTP请求响应结果，包含了状态码，响应正文等

在`CallServerInterceptor`得到最初格式的`Response`

```java
//获得状态行及响应头  
public @Nullable Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
    try {
      Response.Builder result = codec.readResponseHeaders(expectContinue);
      if (result != null) {
        Internal.instance.initExchange(result, this);
      }
      return result;
    } catch (IOException e) {
      eventListener.responseFailed(call, e);
      trackFailure(e);
      throw e;
    }
  }
//获得响应正文
public ResponseBody openResponseBody(Response response) throws IOException {
    try {
      eventListener.responseBodyStart(call);
      String contentType = response.header("Content-Type");
      long contentLength = codec.reportedContentLength(response);
      Source rawSource = codec.openResponseBodySource(response);
      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);
      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
    } catch (IOException e) {
      eventListener.responseFailed(call, e);
      trackFailure(e);
      throw e;
    }
  }
```

![OkHttp执行流程](/images/OkHttp执行流程.png)

## OkHttp缓存机制

### Http缓存

![OkHttp-HTTP缓存机制](/images/OkHttp-HTTP缓存机制.png)

> Http缓存是web性能优化的重要手段，缓存机制是依赖于`header`中的参数实现的，这些参数指定了缓存需要*从缓存中获取*还是*从服务端获取*。

Http缓存有多种规则，根据是否需要重新向服务器发起请求来进行分类：

#### 强制缓存

> 当客户端第一次请求数据时，服务端在响应头会携带**缓存规则信息**，主要为两个字段：**Expires**、**Cache-Control**
>
> 当再次请求数据时，如果符合缓存规则，则直接使用缓存数据，无需与服务端重新交互。

![强制缓存流程](/images/强制缓存流程.png)

强制缓存在缓存未失效的情况下，可以直接使用缓存数据，接下来介绍`判断缓存数据是否失效`。
上文提到，强制缓存是根据两个Header字段进行判定的，这两个字段表示了`失效规则`。
##### ~~Expires~~
> 服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。
*这参数是HTTP1.0的东西了，现在主流的是HTTP1.1。*
可能由于客户端时间没有与服务端时间同步而导致缓存命中的误差。
##### Cache-Control
> 在HTTP1.1中替代`Expires`，功能与其一致。
`Cache-Control`常见的取值有如下几种：
- `private`：客户端可以进行缓存
- `public`：客户端以及代理服务器都可以进行缓存
- `max-age= XX`：缓存数据在 XX秒后失效
- `no-cache`：需要使用到`对比缓存`
- `no-store`：所有内容都不进行缓存
- `s-maxage = XX`：限定缓存可以在代理服务器中存放多久

#### 对比缓存
> 需要进行比较判断来确定是否使用缓存，当客户端第一次请求数据时，服务端会返回**缓存标识**以及数据给客户端，客户端对两者都要进行备份到缓存，当再次请求数据时，客户端会带上**缓存标识**发送给服务端，服务端对标识进行判断，返回code值。返回若为**304**，则继续使用缓存。

![对比缓存流程](/images/对比缓存流程.png)


在**缓存标识**未失效时，可以继续使用缓存数据，每次都需要与服务端进行交互去验证**缓存标识**。
对比缓存也是依据两个Header字段进行判定的，这两个字段表示了`缓存标识`。

##### Last-Modified/If-Modified-Since
`Last-Modified`：服务端返回给客户端，表示资源的最后修改时间。
`If-Modified-Since`：客户端发给服务端，表示服务端上次返回的资源最后修改时间。
服务端接收到`If-Modified-Since`后，与被请求资源的最后修改时间进行比对。
- 若大于，返回最新资源并返回code为200，客户端需要重新进行缓存
- 否则，说明资源无修改并返回code为304，客户端继续使用缓存数据

##### ETag/If-None-Match
`ETag`：服务端返回给客户端，表示当前资源在服务器的唯一标识。
`If-None-Match`：客户端发送给服务端，表示服务端上次返回的资源唯一标识。
服务端接收到`If-None-Match`后，与被请求资源的唯一标识进行比对
- 标识不同，表示资源被改动过，返回最新资源及设置code为200，客户端需要重新进行缓存
- 标识相同，表示资源未被改动，返回code为304，客户端继续使用缓存数据

其中`ETag/If-None-Match`的优先级是高于`Last-Modified/If-Modified-Since`的

#### 总结
> - 强制缓存的优先级是高于对比缓存的
> - 对于`强制缓存`，服务端会给予一个过期时间，在有效期内再次请求都只会使用缓存，不会请求服务端。
> - 超过有效期就使用`对比缓存`策略，将服务端返回的`ETag/Last-Modified`发还给服务端进行验证，有效则继续使用缓存数据(*返回code为304*)，无效则重新获取并进行缓存(*返回code为200*)。
### 缓存存储

![OkHttp缓存实现](/images/OkHttp缓存实现.png)

介绍完毕Http的缓存机制后，接下来就是看`OkHttp`中的源码实现
```java CacheStrategy.java
  CacheStrategy(Request networkRequest, Response cacheResponse) {
    this.networkRequest = networkRequest;
    this.cacheResponse = cacheResponse;
  }
```
缓存策略主要通过`CacheStrategy`类实现，关键参数为`networkRequest(网络请求)`、`cacheResponse(缓存的响应结果)`。
`CacheStrategy`通过工厂模式进行构建的，最终通过调用`getCandidate()`来生成不同模式。

```java
private CacheStrategy getCandidate() {
      // 没缓存直接进行重新请求
      if (cacheResponse == null) {
        return new CacheStrategy(request, null);
      }

      // 如果是HTTPs且握手信息丢失进行重新请求
      if (request.isHttps() && cacheResponse.handshake() == null) {
        return new CacheStrategy(request, null);
      }
      //判断缓存已经失效 重新进行请求
      if (!isCacheable(cacheResponse, request)) {
        return new CacheStrategy(request, null);
      }
      // 
      CacheControl requestCaching = request.cacheControl();
      if (requestCaching.noCache() || hasConditions(request)) {
        return new CacheStrategy(request, null);
      }

      CacheControl responseCaching = cacheResponse.cacheControl();
      //
      long ageMillis = cacheResponseAge();
      long freshMillis = computeFreshnessLifetime();

      if (requestCaching.maxAgeSeconds() != -1) {
        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
      }

      long minFreshMillis = 0;
      if (requestCaching.minFreshSeconds() != -1) {
        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
      }

      long maxStaleMillis = 0;
      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
      }
      //处于强制缓存状态，直接返回缓存数据
      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
        Response.Builder builder = cacheResponse.newBuilder();
        if (ageMillis + minFreshMillis >= freshMillis) {
          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
        }
        long oneDayMillis = 24 * 60 * 60 * 1000L;
        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
        }
        return new CacheStrategy(null, builder.build());
      }

      // Find a condition to add to the request. If the condition is satisfied, the response body
      // will not be transmitted.
      String conditionName;
      String conditionValue;
      if (etag != null) {
        conditionName = "If-None-Match";
        conditionValue = etag;
      } else if (lastModified != null) {
        conditionName = "If-Modified-Since";
        conditionValue = lastModifiedString;
      } else if (servedDate != null) {
        conditionName = "If-Modified-Since";
        conditionValue = servedDateString;
      } else {
        return new CacheStrategy(request, null); // No condition! Make a regular request.
      }
      //交由服务端去进行判断
      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);

      Request conditionalRequest = request.newBuilder()
          .headers(conditionalRequestHeaders.build())
          .build();
      return new CacheStrategy(conditionalRequest, cacheResponse);
    }

```
`CacheStrategy`根据之前的缓存结果以及要发送的`request的header`计算缓存策略

| networkRequest | cacheResponse | CacheStrategy                                                |
| -------------- | ------------- | ------------------------------------------------------------ |
| null           | null          | 不进行网络请求且缓存不存在或过期<br />返回504错误            |
| null           | not null      | 不进行网络请求但是存在缓存且有效<br />直接返回缓存数据       |
| not null       | null          | 进行网络请求且缓存不存在或过期<br />直接进行网络请求获取数据 |
| not null       | not null      | 进行网络请求，请求头包含`ETag/Last-Modified`且缓存存在<br />根据网络请求结果判断<br />返回304，使用缓存<br />返回200，使用请求数据且更新缓存 |



## OkHttp连接机制

在`ConnectInterceptor`中进行了与服务端的连接，通过`Exchange`类进行连接。
```java
  Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
    synchronized (connectionPool) {
      if (noMoreExchanges) throw new IllegalStateException("released");
      if (exchange != null) throw new IllegalStateException("exchange != null");
    }
    //建立连接
    ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);
    Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec);

    synchronized (connectionPool) {
      this.exchange = result;
      this.exchangeRequestDone = false;
      this.exchangeResponseDone = false;
      return result;
    }
  }
```
### 通过Socket连接服务端
通过`ExchangeCodec.find()`来设置连接或者复用
```java  ExchangeCodec.java
public ExchangeCodec find(
      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
    int connectTimeout = chain.connectTimeoutMillis();
    int readTimeout = chain.readTimeoutMillis();
    int writeTimeout = chain.writeTimeoutMillis();
    int pingIntervalMillis = client.pingIntervalMillis();
    boolean connectionRetryEnabled = client.retryOnConnectionFailure();

    try {
      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
      return resultConnection.newCodec(client, chain);
    } catch (RouteException e) {
      trackFailure();
      throw e;
    } catch (IOException e) {
      trackFailure();
      throw new RouteException(e);
    }
  }
  //返回一个健康的连接 
  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
      boolean doExtensiveHealthChecks) throws IOException {
    while (true) {
      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
          pingIntervalMillis, connectionRetryEnabled);

      // If this is a brand new connection, we can skip the extensive health checks.
      synchronized (connectionPool) {
        if (candidate.successCount == 0) {
          return candidate;
        }
      }

      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
      // isn't, take it out of the pool and start again.
      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
        candidate.noNewExchanges();
        continue;
      }

      return candidate;
    }
  }
  
  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
    boolean foundPooledConnection = false;
    RealConnection result = null;
    Route selectedRoute = null;
    RealConnection releasedConnection;
    Socket toClose;
    synchronized (connectionPool) {
      if (transmitter.isCanceled()) throw new IOException("Canceled");
      hasStreamFailure = false; // This is a fresh attempt.
      
      Route previousRoute = retryCurrentRoute()
          ? transmitter.connection.route()
          : null;

      // Attempt to use an already-allocated connection. We need to be careful here because our
      // already-allocated connection may have been restricted from creating new exchanges.
      releasedConnection = transmitter.connection;
      toClose = transmitter.connection != null && transmitter.connection.noNewExchanges
          ? transmitter.releaseConnectionNoEvents()
          : null;

      if (transmitter.connection != null) {
        // We had an already-allocated connection and it's good.
        result = transmitter.connection;
        releasedConnection = null;
      }

      if (result == null) {
        // Attempt to get a connection from the pool.
        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
          foundPooledConnection = true;
          result = transmitter.connection;
        } else {
          selectedRoute = previousRoute;
        }
      }
    }
    closeQuietly(toClose);

    if (releasedConnection != null) {
      eventListener.connectionReleased(call, releasedConnection);
    }
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result);
    }
    if (result != null) {
      // If we found an already-allocated or pooled connection, we're done.
      return result;
    }

    // If we need a route selection, make one. This is a blocking operation.
    boolean newRouteSelection = false;
    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
      newRouteSelection = true;
      routeSelection = routeSelector.next();
    }

    List<Route> routes = null;
    synchronized (connectionPool) {
      if (transmitter.isCanceled()) throw new IOException("Canceled");

      if (newRouteSelection) {
        // Now that we have a set of IP addresses, make another attempt at getting a connection from
        // the pool. This could match due to connection coalescing.
        routes = routeSelection.getAll();
        if (connectionPool.transmitterAcquirePooledConnection(
            address, transmitter, routes, false)) {
          foundPooledConnection = true;
          result = transmitter.connection;
        }
      }
      //没有从连接池中获取到连接需要重新建立
      if (!foundPooledConnection) {
        if (selectedRoute == null) {
          selectedRoute = routeSelection.next();
        }

        // Create a connection and assign it to this allocation immediately. This makes it possible
        // for an asynchronous cancel() to interrupt the handshake we're about to do.
        result = new RealConnection(connectionPool, selectedRoute);
        connectingConnection = result;
      }
    }

    // If we found a pooled connection on the 2nd time around, we're done.
    if (foundPooledConnection) {
      eventListener.connectionAcquired(call, result);
      return result;
    }

    // Do TCP + TLS handshakes. This is a blocking operation.
    // 开始TCP三次握手以及TLS操作，为阻塞操作
    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
        connectionRetryEnabled, call, eventListener);
    connectionPool.routeDatabase.connected(result.route());

    Socket socket = null;
    synchronized (connectionPool) {
      connectingConnection = null;
      // Last attempt at connection coalescing, which only occurs if we attempted multiple
      // concurrent connections to the same host.
      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
        // We lost the race! Close the connection we created and return the pooled connection.
        result.noNewExchanges = true;
        socket = result.socket();
        result = transmitter.connection;
      } else {
        //加入连接池 等待复用
        connectionPool.put(result);
        transmitter.acquireConnectionNoEvents(result);
      }
    }
    closeQuietly(socket);

    eventListener.connectionAcquired(call, result);
    return result;
  }
```
最终通过`Socket.connect()`进行连接。

### 连接池(ConnectionPool)

![OkHttp-连接池 ConnectionPool](/images/OkHttp-连接池 ConnectionPool.png)

> 频繁的进行Socket连接(三次握手)和Socket断开(四次挥手)非常消耗网络资源以及时间。在HTTP1.1之后提供了`keep-alive`这个header，可以实现长连接，有效的降低了延迟并提升了处理速度。
> 连接池就是为了**复用已存在连接**，可以有效降低创建连接的开销。

#### 连接池构造方法以及成员变量

```java ConnectionPool.java
public final class ConnectionPool {
  //后台清理线程
   private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
      new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true)); 
    //最大的空闲连接数
    private final int maxIdleConnections;
    //连接最大持续时间
    private final long keepAliveDurationNs;
    //存储连接的双向队列
    private final Deque<RealConnection> connections = new ArrayDeque<>();
  
    public ConnectionPool() {
      this(5, 5, TimeUnit.MINUTES);
    }

  public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
    this.maxIdleConnections = maxIdleConnections;
    this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);

    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
    if (keepAliveDuration <= 0) {
      throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
    }
  }
}
```

`ConnectionPool`支持配置以下变量

- `maxIdleConnections`：最大空闲连接数，默认`5`
- `keepAliveDurationNs`：最大连接保持时间，默认`5min`

`Connection`连接池中的`Connection`任一超出以上配置，就需要执行清理。

可以通过以下方法配置连接池

```java
        OkHttpClient.Builder builder = new OkHttpClient.Builder()
                .connectionPool(new ConnectionPool()); //配置连接池
```

#### 连接池加入连接

![双端队列](/images/1345862-20200603214235374-1759578389.png)

通过`connections`存储`Connection`

```java
  void put(RealConnection connection) {
    assert (Thread.holdsLock(this));
    if (!cleanupRunning) {//当前清理线程没有运行
      cleanupRunning = true;
      executor.execute(cleanupRunnable);//开启清理过程
    }
    connections.add(connection);//加入队列
  }
```

在外部执行`put()`时，连接加入连接池，并且开启清理线程去清理那些超出配置的连接。

外部执行`put()`路径如下

```java
// ConnectInterceptor 连接拦截器，其中执行连接过程
public final class ConnectInterceptor implements Interceptor {
    @Override public Response intercept(Chain chain) throws IOException {
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    Request request = realChain.request();
    StreamAllocation streamAllocation = realChain.streamAllocation();

    // We need the network to satisfy this request. Possibly for validating a conditional GET.
    boolean doExtensiveHealthChecks = !request.method().equals("GET");
    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);//建立新连接
    RealConnection connection = streamAllocation.connection();

    return realChain.proceed(request, streamAllocation, httpCodec, connection);
}
  
// StreamAllocation 
   public HttpCodec newStream(
      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
       ...

    try {
      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);//寻找可用的连接
      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);

      synchronized (connectionPool) {
        codec = resultCodec;
        return resultCodec;
      }
    } catch (IOException e) {
      throw new RouteException(e);
    }
  } 
  
  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
      boolean doExtensiveHealthChecks) throws IOException {
    while (true) {
      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
          pingIntervalMillis, connectionRetryEnabled);
      ...

      return candidate;
    }
  }
  
   private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
    ...
     synchronized (connectionPool) {
      if (released) throw new IllegalStateException("released");
      if (codec != null) throw new IllegalStateException("codec != null");
      if (canceled) throw new IOException("Canceled");

      // Attempt to use an already-allocated connection. We need to be careful here because our
      // already-allocated connection may have been restricted from creating new streams.
      releasedConnection = this.connection;
      toClose = releaseIfNoNewStreams();
      ...
      if (result == null) {
        // Attempt to get a connection from the pool.
        Internal.instance.get(connectionPool, address, this, null);//根据address从连接池中获取对应连接
        if (connection != null) {
          foundPooledConnection = true;
          result = connection;
        } else {
          selectedRoute = route;
        }
      }
    }
     ...
    if (result != null) {
      // If we found an already-allocated or pooled connection, we're done.
      return result;
    }  
     
     ...
       
    synchronized (connectionPool) {
      if (canceled) throw new IOException("Canceled");

      if (newRouteSelection) {
        // Now that we have a set of IP addresses, make another attempt at getting a connection from
        // the pool. This could match due to connection coalescing.
        List<Route> routes = routeSelection.getAll();
        for (int i = 0, size = routes.size(); i < size; i++) {
          Route route = routes.get(i);
          Internal.instance.get(connectionPool, address, this, route);
          if (connection != null) {
            foundPooledConnection = true;
            result = connection;
            this.route = route;
            break;
          }
        }
      }

      if (!foundPooledConnection) {
        if (selectedRoute == null) {
          selectedRoute = routeSelection.next();
        }

        // Create a connection and assign it to this allocation immediately. This makes it possible
        // for an asynchronous cancel() to interrupt the handshake we're about to do.
        route = selectedRoute;
        refusedStreamCount = 0;
        result = new RealConnection(connectionPool, selectedRoute);//连接池未找到对应连接，建立新连接
        acquire(result, false);
      }
    }
     
     ...
    
    synchronized (connectionPool) {
      reportedAcquired = true;

      // Pool the connection.
      Internal.instance.put(connectionPool, result);//将新建的连接加入到连接池内

      // If another multiplexed connection to the same address was created concurrently, then
      // release this connection and acquire that one.
      if (result.isMultiplexed()) {
        socket = Internal.instance.deduplicate(connectionPool, address, this);
        result = connection;
      }
    }
     
   }
  
  //OkHttpClient
  public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
    static {
      Internal.instance = new Internal() {
       ...
        @Override public RealConnection get(ConnectionPool pool, Address address,
          StreamAllocation streamAllocation, Route route) {
           return pool.get(address, streamAllocation, route);//从连接池获取连接
        } 
         
        @Override public void put(ConnectionPool pool, RealConnection connection) {
          pool.put(connection);//向连接池添加连接
        }
       ...
      }
  }
```

通过`ConnectInterceptor.intercept()`去建立连接，向下调用到`StreamAllocation.newStream()`

在`newStream()`中继续执行到`findConnection()`，其中主要执行了两步

1. 从`ConnectionPool`寻找是否存有当前`address`对应的连接，调用`ConnectionPool.get(XXX)`，存在就返回对应连接。
2. 不存在对应连接，执行`new RealConnection()`新建连接，并调用`ConnectionPool.put()`存储新连接

对应的`get()、put()`都是通过`Internal.instance`调用的，其中`Internal`是一个抽象类，具体实现类对应的就是`OkHttpClient`。

#### 连接池清理连接

在使用`连接池`时，初始化了一个`Executor`线程池，这个主要就是为了在清理无效连接时去开启清理线程用的

```java
  /**
   * Background threads are used to cleanup expired connections. There will be at most a single
   * thread running per connection pool. The thread pool executor permits the pool itself to be
   * garbage collected.
   * 清理过期的连接，且保证最多只能运行一个清理线程。
   */
  private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
      new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));

//清理过期连接任务
  private final Runnable cleanupRunnable = new Runnable() {
    @Override public void run() {
      while (true) {
        long waitNanos = cleanup(System.nanoTime());//返回下次需要清理连接的时间
        if (waitNanos == -1) return;
        if (waitNanos > 0) {
          long waitMillis = waitNanos / 1000000L;
          waitNanos -= (waitMillis * 1000000L);
          synchronized (ConnectionPool.this) {
            try {
              ConnectionPool.this.wait(waitMillis, (int) waitNanos);//阻塞等待
            } catch (InterruptedException ignored) {
            }
          }
        }
      }
    }
  };
```

##### cleanup()

内部主要执行的是`标记空闲连接`、`清理空闲连接`，`返回下次清理时间`这几步

```java
  long cleanup(long now) {
    int inUseConnectionCount = 0;
    int idleConnectionCount = 0;
    RealConnection longestIdleConnection = null;
    long longestIdleDurationNs = Long.MIN_VALUE;

    // Find either a connection to evict, or the time that the next eviction is due.
    synchronized (this) {
      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {//遍历连接储存队列
        RealConnection connection = i.next();

        // If the connection is in use, keep searching.
        if (pruneAndGetAllocationCount(connection, now) > 0) {//标记正在使用的活跃连接
          inUseConnectionCount++;
          continue;
        }

        idleConnectionCount++;//非活跃标记为空闲连接

        // If the connection is ready to be evicted, we're done.
        long idleDurationNs = now - connection.idleAtNanos;
        if (idleDurationNs > longestIdleDurationNs) {
          longestIdleDurationNs = idleDurationNs;
          longestIdleConnection = connection;//得到最长空闲时间的连接
        }
      }

      if (longestIdleDurationNs >= this.keepAliveDurationNs
          || idleConnectionCount > this.maxIdleConnections) {
        // We've found a connection to evict. Remove it from the list, then close it below (outside
        // of the synchronized block).
        // 空闲连接超过`maxIdleConnections`个或者空闲时间超过`keepAliveDurationNs`，需要清理该连接
        connections.remove(longestIdleConnection);
      } else if (idleConnectionCount > 0) {
        // A connection will be ready to evict soon.
        // 返回最大空闲连接的到期时间，等待到达时间后进行清理
        return keepAliveDurationNs - longestIdleDurationNs;
      } else if (inUseConnectionCount > 0) {
        // All connections are in use. It'll be at least the keep alive duration 'til we run again.
        // 所有都是活跃连接，返回最大空闲连接时间，等待到达时间后清理
        return keepAliveDurationNs;
      } else {
        // No connections, idle or in use.
        // 当前不存在连接，直接返回 -1，不进行清理任务
        cleanupRunning = false;
        return -1;
      }
    }
		// 立即关闭过期连接
    closeQuietly(longestIdleConnection.socket());

    // Cleanup again immediately.
    return 0;
  }
```

`cleanup()`执行流程如下：

- 遍历`ConnectionPool`的`connections`，通过`pruneAndGetAllocationCount()`判断`connection`是否空闲
- 遍历完毕后，找到最长时间的空闲连接(`longestIdleConnection`)
- 得到`longestIdleConnection`后，先是比较当前的`idleConnectionCount`是否大于`maxIdleConnections`或者`longestIdleDurarionNs`是否大于`keepAliveDurationNs`，两者满足其一，则清理掉`longestIdleConnection`
- 不满足其上条件，继续判断`idleConnectionCount > 0 `，表示当前存在空闲连接，就返回距离最大空闲连接时间差`keepAliveDurationNs - longestIdleDurationNs`，等待到时清理
- 不满足其上条件，继续判断`inUseConnectionCount > 0`，表示当前都是活跃连接，返回`keepAliveDurationNs`，等待达到时间清理
- 以上条件都不满足，表示当前没有连接，直接返回`-1`
- 存在`longestIdleConnection`，即调用`longestIdleConnection.socket().close()`关闭连接即可

##### pruneAndGetAllocationCount(Connection)

判断当前连接是否正在活跃，采用了**引用计数法**

```java
  private int pruneAndGetAllocationCount(RealConnection connection, long now) {
    //连接弱引用列表
    List<Reference<StreamAllocation>> references = connection.allocations;
    for (int i = 0; i < references.size(); ) {
      //获取引用连接
      Reference<StreamAllocation> reference = references.get(i);
      //不为null ，表示当前连接尚未回收
      if (reference.get() != null) {
        i++;
        continue;
      }

      // We've discovered a leaked allocation. This is an application bug.
      StreamAllocation.StreamAllocationReference streamAllocRef =
          (StreamAllocation.StreamAllocationReference) reference;
      String message = "A connection to " + connection.route().address().url()
          + " was leaked. Did you forget to close a response body?";
      Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);

      //移除引用
      references.remove(i);
      connection.noNewStreams = true;

      // If this was the last allocation, the connection is eligible for immediate eviction.
      //所有引用都被移除，表示当前连接处于空闲
      if (references.isEmpty()) {
        connection.idleAtNanos = now - keepAliveDurationNs;
        return 0;
      }
    }

    return references.size();
  }
```

`StreamAllocation`引用是在`StreamAllocation.acquire()`时加入的

```java
  public void acquire(RealConnection connection, boolean reportedAcquired) {
    assert (Thread.holdsLock(connectionPool));
    if (this.connection != null) throw new IllegalStateException();

    this.connection = connection;
    this.reportedAcquired = reportedAcquired;
    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
  }

```

通过这种`引用计数法`来判断当前是否为空闲连接

## OkHttp-DNS功能

### DNS介绍

`Domain Name System`：根据域名查出IP地址，是`HTTP协议`的前提，只有将域名正确的进行解析，得到IP地址后，才可以继续进行网络连接。

DNS服务器结构如下：

- `根DNS服务器`：返回顶级DNS服务器的IP地址
- `顶级域DNS服务器`：返回权威DNS服务器的IP地址
- `权威DNS服务器`：返回对应主机的IP地址

![img](/images/DNS服务器结构)

#### LocalDNS

![OkHttp-LocalDNS](/images/OkHttp-LocalDNS.png)

**运营商提供的DNS服务器**，请求时优先查询`LocalDNS 缓存`，存在直接使用。不存在就需要从`根域名服务器 -> 顶级域名服务器 -> 权威域名服务器`往上查询可用的`IP地址`。

![img](/images/DNS请求过程)

##### 缺陷

1. 不稳定

   > DNS劫持或者服务器故障，导致解析服务不可用

2. 不准确

   > `LocalDNS调度`不一定是**就近原则**。某些运营商会把解析请求转发到其他运营商的`LocalDNS`服务器。
   >
   > 就会导致解析出的IP不是就近服务器，致使访问变慢甚至无法访问。

3. 不及时

   > 运营商可能修改DNS的`TTL(Time-To-Live，DNS缓存时间)`，导致DNS解析结构发生修改，但是在当前请求条件下尚未生效。



![img](/images/640-2236080.)

#### HttpDNS

![OkHttp-HTTPDNS](/images/OkHttp-HTTPDNS.png)

`HTTPDNS`利用`HTTP协议`与DNS服务交互，绕开了运营商`LocalDNS`服务，有效防止了域名劫持以及提高了域名解析成功率。

##### 原理

![img](/images/HTTPDNS原理.jpeg)

1. 客户端直接访问`HttpDNS`接口，获取域名在`HTTPDNS服务器`上的最优IP(从容灾方面考虑，还需要保留`LocalDNS`请求)
2. 客户端获取到`IP`后，直接向该`IP`发起HTTP请求

##### 优势

1. 降低了`UnknownHostException`异常发生
2. 调度精准，根据用户IP，精准获取域名对应IP
3. 扩展性强，可以自定义域名对应IP规则



### OkHttp-HttpDNS实现

OkHttp提供了`Dns接口`，可以进行自定义拓展替代本身的`LocalDNS`解析方式

```kotlin
//自定义DNS
class OptimizeLocalDNS : Dns{
    override fun lookup(hostname: String): List<InetAddress> {
        return DNSLookUpUtil.loadLocalDNS(hostname)
    }
}

//设置LocalDNS超时取消
        fun loadLocalDNS(hostname: String, timeout: Long = 10L): List<InetAddress> {
            try {
                val task = FutureTask<List<InetAddress>>(Callable<List<InetAddress>> {
                    //返回去重结果
                    InetAddress.getAllByName(hostname).toList().distinct()
                })
                Thread(task).start()
                return task.get(timeout, TimeUnit.SECONDS)
            } catch (e: Exception) {
            }
            return listOf()
        }

//设置自定义DNS
mOkHttpClient = httpBuilder
        .dns(OptimizeLocalDNS())
        .build();
```

### OkHttp-DNS原理

配置的`dns()`初始使用位于`RetryAndFollowUpInterceptor.intercept()`中

```java
public final class RetryAndFollowUpInterceptor implements Interceptor {
  ...
   @Override public Response intercept(Chain chain) throws IOException {
    ...
        StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
        createAddress(request.url()), call, eventListener, callStackTrace);
   }
  
   private Address createAddress(HttpUrl url) {
    ...
    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
  }
 
  ...
}
```

构造出一个`Address`对象，里面包含了`主机名(host)、端口(port)、DNS配置(DNS)、SSL配置(sslSocketFactory,certificatePinner)、代理设置`

得到`Address`，通过`StreamAllocation`构造了`RouteSelector`对象

```java
  public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
      EventListener eventListener, Object callStackTrace) {
    this.connectionPool = connectionPool;
    this.address = address;
    this.call = call;
    this.eventListener = eventListener;
    this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
    this.callStackTrace = callStackTrace;
  }
```

`RouteSelector`主要为了**Select Route(选择路由)，返回一个可用的`Route`对象**。

```java
private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
    // Clear the addresses. Necessary if getAllByName() below throws!
    inetSocketAddresses = new ArrayList<>();

    String socketHost;
    int socketPort;
    if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {//存在代理
      socketHost = address.url().host();
      socketPort = address.url().port();
    } else {
      SocketAddress proxyAddress = proxy.address();
      if (!(proxyAddress instanceof InetSocketAddress)) {
        throw new IllegalArgumentException(
            "Proxy.address() is not an " + "InetSocketAddress: " + proxyAddress.getClass());
      }
      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;
      socketHost = getHostString(proxySocketAddress);
      socketPort = proxySocketAddress.getPort();
    }

    if (socketPort < 1 || socketPort > 65535) {
      throw new SocketException("No route to " + socketHost + ":" + socketPort
          + "; port is out of range");
    }

    if (proxy.type() == Proxy.Type.SOCKS) {//解析的直接为代理地址
      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));
    } else {
      //dns开始解析监听
      eventListener.dnsStart(call, socketHost);

      // Try each address for best behavior in mixed IPv4/IPv6 environments.
      List<InetAddress> addresses = address.dns().lookup(socketHost);//通过配置的DNS去解析对应域名的IP列表
      if (addresses.isEmpty()) {
        throw new UnknownHostException(address.dns() + " returned no addresses for " + socketHost);
      }
      //dns解析结束监听
      eventListener.dnsEnd(call, socketHost, addresses);

      for (int i = 0, size = addresses.size(); i < size; i++) {
        InetAddress inetAddress = addresses.get(i);
        inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
      }
    }
  }
```



`resetNextInetSocketAddress()`返回`List<InetSocketAddress>`，区分了一下两种情况

- 设置了`proxies`代理服务器，直接返回`InetSocketAddress(socketHost,socketPort)`代理服务器对应的地址和端口
- 未设置代理服务器，通过设置的`dns`去解析对应域名(`dns.lookup(host)`)得到`List<InetAddress>`对应的IP列表，在返回对应地址



## OkHttp-HTTP2.0协议支持

![OkHttp-HTTP2.0](/images/OkHttp-HTTP2.0.png)

> 基于`二进制分帧`、`首部压缩`和`服务端推送`进行分析

//TODO

## OkHttp拓展

### 请求时间获取

`EventListener`是OkHttp提供的监听回调，可以通过实现这个抽象类监听到网络请求各阶段的时间点

```java
public abstract class EventListener {
   //请求相关回调
   public void callStart(Call call) {} 
   public void callEnd(Call call) {}
   public void callFailed(Call call, IOException ioe) {}  
  
   //dns解析回调
   public void dnsStart(Call call, String domainName) {}
   public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {}
  
   //请求连接相关回调
   public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy){}
   public void connectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,@Nullable Protocol protocol) {}
   public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
      @Nullable Protocol protocol, IOException ioe) {}
   public void connectionAcquired(Call call, Connection connection){}
   public void connectionReleased(Call call, Connection connection){}
  
   ...
}
```



#### DNS解析耗时

只要监听`dnsStart()`和`dnsEnd()`之间的时间差即可

```java
    private long dnsStartTime;

    private long dnsDuration = -1L;    

    @Override
    public void dnsStart(Call call, String domainName) {
        super.dnsStart(call, domainName);
        recordEventLog("dnsStart");
        dnsStartTime = System.nanoTime();
    }

    @Override
    public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
        super.dnsEnd(call, domainName, inetAddressList);
        recordEventLog("dnsEnd");
        dnsDuration = (System.nanoTime() - dnsStartTime) / 1000000;
    }

    public long getDnsDuration() {
        return dnsDuration;
    }
```

`dnsDuration`即为DNS解析耗时

#### 请求连接耗时

初始连接耗时

> 使用Socket建立TCP连接，初始连接表示的就是`Socket建立连接的过程`

只要监听`connectStart()`和`connectEnd()`之间的时间差。

复用连接耗时

> OkHttp设置`ConnectionPool`，可以复用已存在的连接

需要监听`connectAcquired()`和`connectReleased()`之间的时间差

## 内容引用
[开源框架源码鉴赏：OkHttp](https://juejin.im/post/5a704ed05188255a8817f4c9)
[彻底弄懂HTTP缓存机制及原理](https://www.cnblogs.com/chenqf/p/6386163.html)

[百度App网络深度优化系列《一》DNS优化](https://mp.weixin.qq.com/s/iaPtSF-twWz-AN66UJUBDg)



[HTTP2.0相关](https://juejin.im/post/6844903785232498696#heading-4)

[HPACK算法](https://tools.ietf.org/html/rfc7541)

[HTTP/2首部压缩的OkHttp3实现](https://sq.163yun.com/blog/article/188769987293102080)

]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP的原理和工作机制</title>
    <url>/2020/03/29/HTTP%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[
# HTTP的原理和工作机制

![HTTP大纲](/images/http/HTTP大纲.png)

## 什么是HTTP?

> HyperText(可以指向其他文本的链接文本) Transfer Protocol——超文本传输协议。位于`TCP/IP`协议的最顶层——应用层。

从日常角度来说，在App中调用网络请求，直接就会使用到HTTP。发送数据(`Request`)到服务端，等待服务端数据处理完毕再返回(`Response`)到App，App在进行后续处理，例如页面展示等。

### HTTP工作机制

#### 浏览器输入地址后发生了什么？

- 浏览器向DNS服务器请求解析该url中的域名对应的IP地址
- 解析得到IP地址后，根据IP地址和端口，与服务器建立TCP连接
- 浏览器发出读取文件的HTTP请求
- 服务器对浏览器请求做出响应，返回html文本到浏览器
- 根据Header中的`Connection`判断是否需要释放TCP连接，若为`close`则关闭连接；为`keep-alive`则保持该连接一段时间，可以继续接受服务器数据
- 浏览器解析服务端返回的html文本并显示

### HTTP特点与缺点

![HTTP优点和缺点mind](/images/HTTP优点和缺点mind.png)

#### 特点

- 灵活可拓展
  - 只规定基本格式，没有语法的限制
  - 传输形式多样性，支持文本、图片、视频等数据
- 传输可靠，基于TCP/IP，继承其特性
- 无状态，通信过程不会记录上下文信息，每次请求都是独立的，减少了网络开销

#### 缺点

- 无状态

  需要长连接的场景中，需要保存信息时，导致传输大量无用的信息，这时就是缺点

  如果只是单纯的获取数据，不需要保存信息时，反而减少了网络开销

- 明文传输

  协议里的报文使用文本形式传递，为调试提供便利但是会把明文信息暴露给外界，导致请求不安全。

- 队头阻塞问题

  当http开启长连接时(`Connection:Keep-Alive`)，共用同一个TCP连接，同一时刻只能处理同一个请求，当头部请求耗时过长，会导致后续请求堵塞，产生**队头阻塞**问题。



### HTTP报文结构

![HTTP报文结构mind](/images/http/HTTP报文结构mind.png)

#### 请求报文(`Request`)

![HTTP_RequestMessage](/images/HTTP_RequestMessage.png)

##### 请求行

> 声明请求方法、主机域名和协议版本

基本格式： **Method Request-URI HTTP-Version CRLF**

Method：表示请求方法，例如`GET、POST...`

Request-URI：统一资源标识符，例如`https://leo-wxy.github.io/`

HTTP-Version：HTTP协议版本，例如`HTTP/1.1 HTTP/2.0`

CRLF：表示回车和换行，`\r\n`

示例数据： `GET http://leo-wxy.github.io/ HTTP/1.1 `



##### 请求头

> 声明客户端的首部信息

参考后面章节的 `Headers`

##### 请求体

> 存放客户端发送给服务端的数据信息，若为`GET`请求则没有该结构

参考后面章节的 `Body`

##### 示例

| 请求行     | **GET /test/index.html HTTP/1.1** |
| ---------- | --------------------------------- |
| **请求头** | Host : www.github.io              |
|            | User-Agent : Mozilla/5.0          |
| **空行**   | (用于隔开请求头和请求体)          |
| **请求体** | id=0&page=1                       |



#### 响应报文(`Response`)

![HTTP_ResponseMessage](/images/HTTP_ResponseMessage.png)

##### 状态行

> 声明协议版本、状态码和描述(对状态码进行描述)

​	基本格式： **HTTP-Version Status-Code Reason-Parse CRLF**

​	HTTP-Version：HTTP协议版本，例如`HTTP/1.1 HTTP/2.0`

​	Status-Code：服务器返回的状态码，对应上面的[响应状态码](#响应状态码)

​	Reason-Parse：状态码的文本描述，对应上面的[响应状态码](#响应状态码)

​	CRLF：表示回车和换行，`\r\n`

​	示例数据： `HTTP/1.1 404 Not Found `

##### 响应头

> 声明客户端、服务端的报头信息

参考后面章节的 `Headers`

##### 响应报文

> 存放反给客户端的数据信息

参考后面章节的 `Body`

##### 示例

| 状态行       | HTTP/1.1 200 OK            |
| ------------ | -------------------------- |
| **响应报头** | Connection : keep-alive    |
|              | Server : Nginx             |
| **空行**     | (用于隔开响应头和响应正文) |
| **响应正文** | {"error":false,"result":1} |



### HTTP Request Methods

![HTTP请求方法mind.png](/images/HTTP请求方法mind.png)

> HTTP协议所定义的请求方法

| 请求方法 | 作用                           | 描述                                                         | 简化                                                         |
| -------- | ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| GET      | 获取资源                       | 客户端需要从服务器读取资源时使用<br>一般用于获取/查询信息<br>通过URL传递且参数长度是有限制的<br>请求格式 ` /test/result?key=key&page=1`<br>请求是安全的，因为只读，不会改变服务器数据 | 用于获取资源<br/> 不设置Body <br/>不会改变服务器数据<br/>符合**幂等性** |
| POST     | 传输实体主体                   | 客户端向服务端提供信息时使用<br>可以附带数据，用于更新服务器数据<br>将请求参数封装在请求数据中，可传输大量数据<br>传参方式更加安全，但是请求是不安全的，会导致服务器数据发生改变 | 会改变服务器数据，增加或修改资源<br/> 需要设置Body<br/>不符合**幂等性** |
| HEAD     | 获取报文首部                   | 不返回报文实体部分，主要用于确认URL有效性以及资源更新日期    | 几乎与`GET`相同<br/>服务器不返回Body<br/>可用于下载场景，获取信息 |
| PUT      | 上传文件                       | 自身不带验证机制，存在安全性问题。**一般不使用**             | 会改变服务器数据，只能修改资源<br/>不设置Body<br/>符合**幂等性** |
| PATCH    | 对资源部分进行修改             | 可以部分对资源进行修改                                       |                                                              |
| DELETE   | 删除文件                       | 自身不带验证机制，存在安全性问题。                           | 会改变服务器数据，删除资源<br/>不设置Body<br/>符合**幂等性** |
| OPTIONS  | 查询支持的方法                 | 查询指定的URL可以提供的方法。<br>返回示例：`Allow: GET , POST` |                                                              |
| CONNECT  | 要求与代理服务器通信时建立隧道 | 对通信内容进行加密后通过网络隧道传输                         |                                                              |
| TRACE    | 追踪路径                       | 将通信路径返回给客户端                                       |                                                              |

#### Tips

##### **幂等性**

> 对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。

HTTP请求方法中的`GET、PUT、DELETE`是满足`幂等性`的。



#### 常见问题

##### GET和POST请求有什么区别？

- GET请求会被主动缓存下来，留下历史记录；POST不会缓存
- GET方式提交的数据长度有限制(URL长度限制)，POST请求数据可以非常大
- GET请求只能进行URL编码；POST没有限制
- GET请求都是放在URL中的，安全性不高；POST可以放在请求体中，增强安全性
- **(本质区别)GET请求是幂等的；POST不是**

### HTTP Status Code

![HTTP状态码mind](/images/HTTP状态码mind.png)

> 位于服务端返回**响应报文**中的第一行，包含了状态码以及原因短语，用来告知客户端请求结果。

| 状态码 | 类别                           | 含义                     |
| ------ | ------------------------------ | ------------------------ |
| 1XX    | Informational(信息性状态码)    | 接收请求正在处理         |
| 2XX    | Success(成功状态码)            | 请求正常处理完毕         |
| 3XX    | Redirection(重定向状态码)      | 需要进行附加操作完成请求 |
| 4XX    | Client Error(客户端错误状态码) | 服务器无法处理请求       |
| 5XX    | Server Error(服务端错误状态码) | 服务器处理请求出错       |

#### 1XX 信息状态码

- 100 Continue：客户端继续发送请求
- 101 Switching Protocls：正在切换协议，可以切换HTTP 2.0

#### 2XX 成功状态码

- 200 OK：请求成功
- 204 No Content：请求成功，但没有body数据
- 206 Partial Content：部分内容，用于分块下载和断点续传，与`Content-Range`一起使用

#### 3XX 重定向状态码

- 301 Moved Permanently：永久性重定向 *常见*
- 302 Found：临时性重定向
- 304 Not Modified：内容没有改变，与Http缓存有关

#### 4XX 客户端错误状态码

- 400 Bad Request：请求报文存在语法错误
- 401 Unauthorized：未认证用户-`服务端不知道你是谁`
- 403 Forbiden：请求被拒绝-`服务端知道你是谁，但你不配`
- 404 Not Found：找不到对应服务器

#### 5XX 服务端错误状态码

- 500 Internal Server Error：服务器执行请求发生错误
- 502 Bad Gateway：返回响应无效
- 503 Server Unavliable：服务器无法处理请求
- 504 Gateway Time-out：服务器处理请求超时



### HTTP Header

![HTTP首部格式mind](/images/HTTP首部格式mind.png)

> HTTP消息的元数据(metadata)，例如消息长度、格式等。

#### 请求报文Header

##### **Accept**：客户端可以接受的MIME类型

> MIME类型：描述消息内容类型的因特网标准，包含文本、图像、音频、视频以及其他应用 程序专用数据，例如PDF之类的

`文本类型`：text/html、text/css

`图片文件`：image/gif、image/png

`视频文件`：video/mpeg、video/mp4

`应用程序二进制文件`：application/json、application/pdf

如果`Accept`包含了某类型，表示客户端可以支持该格式数据处理。

一般MIME类型会和`q`这个属性一起使用，

例如`Accept:text/html,application/json;q=0.9,image/webp;q=0.8,*/*;q=0.8`

`q`表示了**媒体类型增加优先级**，权重高的优先处理。

例如上述数据表示：

| 权重 | MIME类型         |
| ---- | ---------------- |
| 1.0  | text/html        |
| 0.9  | application/json |
| 0.8  | Image/webp       |



###### **Accept-Encoding**：支持的压缩方式

> 一般都会对传输数据进行编码压缩，设置客户端可接受的压缩方式

`gzip`：由文件压缩gzip程序产生的编码格式 **最常用**

`deflate`：使用zlib结构和deflate算法产生的压缩格式

`br`：使用Brotil算法的压缩格式

如果配置了`q`，也表示相对优先级，例如`Accept-Encoding:gzip;q=0.9`



###### **Accept-Language**：支持的语言

> 指定客户端支持的语言

如果配置了`q`，也表示相对优先级，例如`Accept-Language:zh-CN;q=0.9`



###### **Accept-Charset**：支持的字符集

> 指定客户端支持的字符集

如果配置了`q`，也表示相对优先级，例如`Accept-Charset:utf-8;q=0.9`

**Host**：请求资源所在服务器

**User-Agent**：当前访问服务器的用户信息

**Range**：设置下载数据的范围，可用于断点续传/多线程下载。

#### 响应报文Header

**Location**：重定向后的目标url

**Accept-Range**：表示当前可以按照`bytes`来进行资源获取

**Content-Type**：指定请求体(Body)类型/响应体返回数据类型

- `text/html`：返回Html文本
- `application/json、image/jpeg`：返回文本或文件内容，也可用于向服务器传输文件
- `application/x-www-form-urlencoded`：普通表单类型提交，只支持传文本
- `multitype/form-data`：支持提交二进制文件，例如图片啥的
- `charset=utf-8`：表示设置的字符集 对标于`Accept-Charset`

**Content-Encoding**：服务端设置的压缩格式 对标于`Accept-Encoding`

**Content-Language**：服务端设置的语言 对标于`Accept-Language`



#### 通用Header(请求/响应都可以用)

**Content-Length**：指定请求体(Body)长度/响应体返回数据长度

**Connection**：允许发送的指令连接选项

- `keep-alive`：保持连接
- `close`：通讯完成后关闭连接

**Cache-Control**：对数据进行缓存，减少从服务器获取数据次数，优化网络性能

- `no-cache`：需要使用到`对比缓存`
- `no-store`：不要缓存数据
- `max-age:XX`：缓存在XX时间后失效
- `private`：客户端可以缓存数据(个人化信息)
- `public`：客户端与中间节点都可以进行缓存(所有人都能使用)
- `s-maxage`：限定缓存在代理服务器中可以存放多久





### HTTP Cache

![HTTP缓存mind](/images/HTTP缓存mind.png)

> Web性能优化的重要手段，主要依赖于上节中配置的`Header`。会去指定缓存的来源 

#### 强制缓存

> 在第一次请求数据时，服务端在Header会携带`缓存规则信息`，只要符合缓存规则，就直接取缓存数据，不会重新发起请求。按照服务端给予的`缓存时间`比较，不超出则一直使用缓存数据。

通过`Cache-Control`验证强缓存是否可用，如果设置了`max-age=XXX`，表示缓存会在`XXX`后的时间失效，在这期间只要请求资源，都会从缓存中获取数据。

在HTTP1.0版本使用的是`Expires`字段，存放的是一个具体的过期时间，但是存在**服务器与客户端时间不同步**问题，导致缓存失效时间无法确定。所以在HTTP1.1是废弃了该字段。

#### 对比缓存

> 需要按照`Header`中的配置来判断是否需要读取缓存还是重新从服务器中拉取数据。

按照缓存下来的数据标识，需要每次与服务器进行交互去验证`缓存标识`是否有效，有效则继续使用缓存数据即可。

以下则为认证时用到的`缓存标识`：

**Last-Modified/If-Modified-Since**

- `Last-Modified`：服务端返回给客户端，表示资源的最后修改时间
- `If-Modified-Since`：客户端发送服务端，表示服务端返回的上次资源修改时间

服务端在收到`If-Modified-Since`之后，与服务端资源进行比较

- 若本地时间大于接收的时间，则返回`200`，需要客户端重新缓存资源
- 否则，返回`304`，表示资源没有发生变化，客户端可以继续使用本地缓存资源



**ETag/If-None-Match**

- `ETag`：服务端返回给客户端，表示当前资源在服务器的唯一标识
- `If-None-Match`：客户端发送给服务端，表示服务端说返回的资源唯一标识

服务端在收到`If-None-Match`之后，进行服务器资源的唯一标识比对

- 标识不一致，返回`200`，需要客户端重新缓存资源
- 否则，返回`304`，客户端可以继续使用本地缓存资源



*强制缓存的优先级是高于对比缓存的。*

**Etag/If-None-Match**这组标识符的优先级是高于**Last-Modified/If-Modified-Since**，如果存在则优先执行。



![http缓存流程](/images/http缓存流程.jpg)

#### 代理缓存

> 每次客户端缓存失效都需要从源服务器获取的话，会产生较大的压力。所以引入`代理缓存`机制，由代理服务器进行数据的缓存，但代理服务器缓存过期了才从源服务器请求数据。

缓存代理的控制分为两部分：**源服务端的控制**，**客户端的控制**。

##### 源服务端的控制

通过配置`Cache-Control`属性进行控制

`Cache-Control:public`：允许代理服务器进行缓存

`Cache-Control:private`：只允许客户端进行缓存

`Cache-Control:s-maxage=XXX`：允许缓存服务器最多缓存XXX时间

与`max-age`的区别是，`max-age`管理的是客户端的缓存有效时间。

##### 客户端的控制

通过在请求头配置属性进行控制

`max-stale:num`：表示客户端在代理服务器拿到缓存时，最多允许`num`的过期时间

`min-fresh:num`：表示代理缓存在到期`num`秒之前可以获取

`only-if-cached`：表示客户端只从代理缓存获取数据，获取缓存无效则返回`504`超时

### HTTP Cookie

![HTTP-Cookiemind](/images/HTTP-Cookiemind.png)

> `由于HTTP协议是无状态的，不对之前发生的请求和响应进行管理。`Cookie就是为了解决这类问题所提供的。可以用于对用户进行认证以及保存部分信息。客户端保存本地后，后续请求就会带上该信息。

`Cookie`会根据从服务端发送的响应报文(`Response`)内的一个叫做`Set-Cookie`的`Header`信息，通知客户端保存Cookie信息。当下次再发起请求时，客户端会自动在请求报文(`Request`)中加入`Cookie`值后发送到服务端。

![Cookie交互流程](/images/Cookie交互流程.jpg)

#### 属性

| 属性     | 类型    | 描述                                                         |
| -------- | ------- | ------------------------------------------------------------ |
| domain   | String  | 指定浏览器发出HTTP请求时，哪些域名需要附加Cookie信息         |
| expires  | Date    | 指定一个具体的Cookie到期时间，值为UTC格式                    |
| httponly | Boolean | 指定该无法通过JS脚本拿到，主要是`Document.cookie`获取        |
| maxAge   | String  | 指定从现在开始的Cookie存在秒数，超过则失效                   |
| path     | String  | 指定浏览器发出Http请求时，哪些路径要附带这个Cookie信息       |
| secure   | Boolean | 指定浏览器只有在`HTTPS`协议下可以发送Cookie到服务器          |
| signed   | Boolean | 给浏览器发送一个加密的Cookie，服务端可以校验该Cookie是否被篡改 |
| SameSite | String  | 设置第三方Cookie属性                                         |

按照功能可以将以上7个属性进行分类

##### Cookie生命周期-`expires,maxAge`

`expires`设置的是一个`Date`格式的时间，`maxAge`设置的是一个`毫秒时间戳`。**推荐使用maxAge**

若同时指定了`expires`和`maxAge`，那么`maxAge`属性优先生效。

*若不设置任一属性的值，那么该Cookie仅在当前页面生效，关闭就不会再保留。*

##### Cookie作用域-`domain,path`

`domain`设置哪些域名需要附加Cookie信息，`path`设置哪些路径需要附加Cookie信息(若`path:'/'`表示该域名下所有路径都附加Cookie信息)。

*若与任一属性值不匹配，那么请求服务端时就不会带上Cookie信息。*

##### Cookie安全性-`secure,httponly,SameSite`

`secure`设置只有在`HTTPS协议`下可以传输Cookie；`httponly`设置Cookie只能通过HTTP协议进行传输，其他方式都无法获取Cookie信息。

`SameSite`主要为了预防`CSRF攻击`，可以设置为3个值：

- None：显式关闭SameSite属性，但是必须设置`secure:true`，否则设置无效
- Lax：只能在`GET`请求下使用，请求时会携带Cookie，否则不会有信息
- Strict：浏览器完全禁止第三方请求携带Cookie信息，只能在同一域名下生效。

#### 作用

- **状态记录**：记录当前状态，例如用户登录，操作记录
- **用户偏好**：记录用户的个性化设置
- **行为分析**：分析用户的行为，可以了解用户喜好

#### 缺点

- **容量缺陷**：Cookie保存的诗句不能超过4K，而且浏览器会设置保存Cookie的上限
- **性能缺陷**：Cookie默认跟随域名一起发起请求，无论需要与否，导致性能浪费。*可以通过设置`domain`和`path`减少使用。*
- **安全权限**：Cookie以纯文本形式进行传递，很容易被非法截获，然后进行篡改后再发给服务端，降低安全性。

#### 风险

- **XSS(跨站脚本攻击)**：被JavaScript获取用户Cookie，然后发送到其他网站，就会导致Cookie泄漏，危害数据安全。

  解决方案：在Cookie信息中添加`HttpOnly`属性，就保证当前Cookie只会用于网络请求，而不会被获取。

- **CSRF(跨站请求伪造)**：随机访问可能存有Cookie的网址，然后越权操作用户数据。

  解决方案：
  
  - 同源检测
  
    - 使用`Origin Header`确定来源域名
  
    - 使用`Referer Header`确定来源域名
  - CSRF Token
  - SameSite Cookie属性



## HTTPS

> 是以安全为目标的HTTP通信，在HTTP下加入了SSL/TLS协议，用于保障HTTP的加密传输。
>
> `TLS(传输层安全性协议)`：前身为`SSL(安全套接层)`，目的是为互联网通信提供安全及数据完整性保障。
>
> 使用`SSL`后，HTTPS就具有**加密、认证，完整性保护**功能

### HTTPS加密

![HTTPS](/images/HTTPSmind.png)

#### 对称密钥加密

> 采用单钥密码系统的加密方法，同一个密钥可以用作信息的加密和解密。
>
> 也可叫`单密钥加密`。

##### 常用加密算法

DES、AES

![对称密钥加解密过程](/images/对称密钥加解密过程.png)

#### 非对称密钥加密

> 需要两个密钥来进行加密和解密，这两个密钥分别是**公钥(public key)**和**私钥(private key)**。
>
> 公钥所有人都可以获得，通信方得到公钥后，就可以对发送内容进行加密，然后传递至服务端，服务端就可以利用私钥进行解密。
>
> 私钥还可以对服务端返回内容进行签名，利用公钥去验证签名是否正确，防止被人篡改。

##### 常用加密算法

RSA，ECC

![非对称密钥加解密过程](/images/非对称密钥加解密过程.png)

#### 混合加密(HTTPS采用方案)

采用了`对称加密与非对称加密`混合加密的形式，只用`对称加密`，会有安全隐患；只用`非对称加密`，性能消耗太大。所以需要结合两者，保证性能的同时又保证安全。

- 客户端向服务器发送`client_random`和加密方法列表(例如RSA方法)
- 服务端收到后，返回`server_random`、加密方法(RSA)以及`非对称加密公钥`到客户端
- 客户端收到后，再生成一个`pre_random`，使用`非对称加密公钥`加密后发送给服务器
- 服务端使用`非对称加密私钥`解密后，得到的就是`对称加密用到的密钥`
- 双方持有``对称加密用到的密钥``后，后续数据通信就用`对称加密`的方式进行。



本质就是为了**防止私钥加密的数据外传。**

#### 数字证书(解决身份伪装问题)

> 为了向服务器证明自己的身份，可以解决身份伪装问题。

上面两种加密方式的结合，可以实现加密传输。但是还会存在一些问题，若发生了DNS劫持，那么传输过程中的所有内容都有可能造假，不能保证安全性。

数字证书的使用流程大概如下：

1. 服务器首先向一个大家都信任的第三方机构(`CA`)获取授权，获取通过后获取**数字证书**。
2. 客户端向服务器建立通信之前向服务器请求获得服务器的证书
3. 服务器收到请求之后发送**数字证书**给客户端
4. 客户端获得证书之后，向第三方机构进行验证，验证通过后进行正常的内容通信。



数字证书有两个作用：

- 服务器向客户端证明自己的身份
- 把`非对称加密公钥`传给客户端



##### CA机构

证书颁发机构。是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。

#### 数字签名(解决数据篡改问题)

> 功能类似写在纸上的普通签名，可以用于校验通信双方数据的准确性以及完整性。

数字签名有两个作用：

- 验证数据是否为意料中的对象发出
- 对数据的完整性进行验证，验证数据是否被篡改过



**使用私钥加密(生成签名)，公钥解密(验证签名)。**

服务端对消息进行私钥加密，客户端使用服务端传递的公钥进行验证，验证通过则表示消息一致，数字签名是正确的。

通常会对消息进行**摘要**，然后拿到消息的Hash值再进行私钥签名(`Hash值一般都会小于消息原文`)，大大提升签名效率。

**哈希摘要算法**：根据任意长度数据计算出固定签名长度的算法。常用的有`SHA256、SHA384`。

### 握手过程

![HTTPS通信过程](/images/http/HTTPS通信过程.jpg)

#### Client Hello

> 客户端发送消息到服务端

客户端生成随机数`client_random`，然后发送`TLS版本`，`加密算法列表`发送给服务端。

例如：发送消息为

- `Random`：client_random

- `Version`：TLS 1.2

- `Cipher Suites`：TLS_AES_128_GCM_SHA256（`只是其中一种，整体是一个List型`）

  服务端会从列表中选择一种加密算法，后续使用该算法进行通信。

#### Server Hello

> 服务端发送消息到客户端

服务端同样生成随机数`server_random`，以及`确认的TLS版本` 、`服务端选择的加密算法`，`服务器的证书信息`返回给客户端。

例如：返回消息为

- `Random`：server_random
- `Cipher Suite`：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256（`返回一个来确定后续都用这种加密方式`）
  - ECDHE：密钥协商算法
  - RSA：证书公钥加密算法
  - AES_128：对称加密算法以及密法长度
  - GCM：AES加密模式
  - SHA256：消息摘要算法
- `Certificate`：返回的服务端证书信息，以及`非对称加密使用的公钥`

#### Certificate

> 客户端验证数字证书以及验证通过后发送消息到服务端

客户端验证服务端传来`证书`和`签名`是否通过，如果通过，按照协议不同有以下两种处理方式

- 传统RSA版本

  客户端再生成一个随机数`pre_random`，并且使用证书携带的RSA公钥加密，传给服务端

- TLS 1.2版本

  客户端生产`client_params`参数给服务端

#### Server Key Exchange

> 服务端根据传递的参数生成对称加密使用的密钥

- 传统RSA版本

  服务端接收到客户端传来的`pre_random`，使用私钥进行解密，然后拿着`client_random`、`server_random`以及`pre_random`按照约定算法生成最终的`secret(对称加密密钥)`

- TLS 1.2版本

  服务端接收到客户端传来的`client_params`，使用`ECDHE(椭圆曲线加密)`，根据已有的`client_params`和`server_params`生成最后的`pre_random`，最后使用`client_random`、`server_random`以及`pre_random`按照约定算法生成最终的`secret(对称加密密钥)`

服务端生成`secret`后，给客户端发送一个收尾消息，该收尾消息包含两部分：

- `Change Cipher Spec`：提示客户端后续消息会采用`secret`的对称加密进行传递
- `Finished`：对之前报文的所有数据进行摘要，加密后交由客户端进行解密，解密通过则表示协商成功

#### Client Key Exchange

> 客户端根据已有的参数生成对称加密使用的密钥

- 传统RSA版本

  客户端根据已有的`client_random`、`server_random`以及`pre_random`按照约定算法生成最终的`secret(对称加密密钥)`

- TLS 1.2版本

  客户端通过`ECDHE`算法计算出`pre_random`，其中传入两个参数:**server_params**和**client_params**。现在你应该清楚这个两个参数的作用了吧，由于`ECDHE`基于`椭圆曲线离散对数`，这两个参数也称作`椭圆曲线的公钥`。

  客户端根据`client_random`、`server_random`以及`pre_random`按照约定算法生成最终的`secret(对称加密密钥)`。

客户端生成`secret`后，会给服务端发送一个收尾消息，该收尾消息包含两部分：

- `Change Cipher Spec`：提示服务器后续消息会采用`secret`的对称加密进行传递
- `Finished`：对之前报文的所有数据进行摘要，加密后交由服务端进行解密，解密通过则表示协商成功



当客户端与服务端都收到`finished`消息后，客户端和服务端都会持有`secret`，后续的请求都会使用`secret`进行对称加密传递消息。

### HTTPS缺点

1. HTTPS协议握手阶段比较费时，因为需要加密/解密过程
2. SSL证书是需要收费
3. HTTPS加密范围有限，而且证书不一定是可以信任的

### 与HTTP区别

- https协议需要向`CA`申请证书，需要一定费用
- http信息是明文传输，HTTPS具有安全性的ssl加密传输协议
- http和https使用的是完全不同的连接方式，端口不同，http使用了`80`端口，https使用`443`端口
- http连接是简单的，无状态的；HTTPS由`http+ssl`构成的可进行加密传输，身份认证的网络协议，更加安全。

### 中间人攻击

> 攻击者与通信两端(服务端与客户端)分别创建独立的联系，并交换所受到的数据，使通信的两端认为他们正在通过一个私密的连接与对方直接通信，事实上整个会话都被攻击者完全控制、
>
> 中间人攻击者可以拦截通讯双方的通话并插入新的内容。

![中间人攻击](/images/中间人攻击.jpg)

#### 如何防御中间人攻击？

- 公钥基础建设PKI

  PKI相互认证机制，服务端验证客户端，客户端验证服务端

- 使用复杂加密哈希函数运行计算以造成数十秒的延迟

  如果双方通信时间过长，可以基本判断存在中间人



## HTTP协议版本区别

![HTTP协议版本区别mind](/images/HTTP协议版本区别mind.png)

### HTTP1.0

- 默认短连接
- 增加了POST、HEAD命令

### HTTP1.1

- 默认长连接(默认添加Header`Connection:Keep-Alive`)
- 增加了请求方法(`OPTIONS、PUT、DELETE、TRACE、CONNECT`)
- 请求消息和响应消息都支持Host头域
- 支持chunked编码传输

### HTTP2.0

- 头部压缩

  针对请求头字段进行压缩，采用了`HPACK`算法

  HPACK算法：

  - 在服务端与客户端建立哈希表，存放使用的字段，只要在传输过程传输索引值，然后按照索引表查询即可
  - 对于整数和字符串进行**哈夫曼编码**

- 多路复用

  允许同时通过单一的HTTP2连接发起多重请求，由于把HTTP通信的基本单位缩小为一个个的二进制帧，各自对应着信息。

  被拆分为很多互不依赖的`二进制帧`后，这些`二进制帧`就可以乱序发送。

  ![img](/images/v2-a3b152bfae26b0cfa2aa96ab2c638b4b_1440w.jpg)

- 二进制分帧

  HTTP/2在 应用层和传输层增加一个`二进制分层`，在该分层中将传输的信息分割为更小的消息和帧，并采用二进制格式的编码。

  > HTTP队头阻塞：在同一个TCP长连接中，前面的请求没有得到响应的话，后面的请求就无法被处理，导致阻塞。
  >
  > `并发连接`：对于一个域名分配多个长连接，相当于增加了任务队列，可以分散任务。
  >
  > `域名分片`：对一个域名分配多个二级域名，但是指向同一台服务器，使并发变多。

  ![img](/images/v2-bb03351e6eac392c2afd89dafcf1e90f_1440w.jpg)

- 服务端推送    

  在客户端请求之前发送数据，客户端请求一个资源后，服务端判断可能还需要其他资源，就会主动发送消息到客户端，减少客户端的等待
  
  ![img](/images/v2-fd019652daff484a0c06bbfb27404bc9_1440w.jpg)
  
  需要注意以下两点：
  
  - 服务端推送遵循`同源策略`
  - 服务端推送基于客户端的请求响应来确定的
  
  > 当服务端需要主动推送某个资源时，便会发送一个`PUSH_PROMISE`的`二进制帧(Frame)`，里面携带了`Stream ID`，表示服务端会用这个`ID`来推送资源，客户端解析时，需要从这个ID获取资源。

## HTTP相关协议

![HTTP相关协议mind](/images/HTTP相关协议mind.png)

### DNS协议 

> 提供域名到IP地址之间的解析服务，能够使人更方便地访问互联网。
>
> 还可以根据多个地址做负载均衡，并且选择一个就近的地点IP进行访问。

#### 解析过程

1. 客户端访问`XX.com`域名，先去请求本地DNS解析器
2. 本地DNS解析器先去查看本地缓存是否有对应记录，若有直接使用；否则请求本地DNS服务器
3. 本地DNS服务器一般部署在运营商网络中，然后本地DNS服务器也会查看是否存在本地缓存，存在则直接使用；否则递归请求根服务器
4. 直到请求到顶级域名服务器，例如`.com`，查到数据后返回真实的IP地址。

#### 存在的问题

##### 域名缓存问题

由于DNS会优先获取本地缓存，如果缓存没有及时刷新，就会导致访问失败。

##### 域名转发问题

DNS解析请求可能会被转发到其他DNS服务器进行处理，导致解析时无法判断地址，而返回一个较远IP使访问异常。

##### 域名更新问题

忽略域名缓存IP的有效时间，导致结果更新不及时，一样会有访问异常问题

##### 解析延迟问题

DNS会进行递归解析，可能经过多个服务器，才可以获得最终结果，中间时间非常漫长

#### HTTPDNS

> 不走传统的DNS解析模式，自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商。需要进行DNS解析时，直接通过HTTP请求这个集群得到结果即可。

##### 工作模式

在客户端动态请求HTTPDNS服务端，获取解析的IP结果以及失效时间缓存到本地。后续在缓存未失效的情况下可直接返回对应域名的IP信息。如果没有返回信息，也可以降级回最初的LocalDNS解析方案。

### CDN

> 内容分发网络(Content Delivery Network)。主要目的是**改善互联网服务质量**，提高用户访问网站的响应速度和成功率。

通过权威DNS服务器来实现最优节点的选择，通过**缓存**来减少源站的压力

### URL/URI

> 用户在浏览器地址栏输入的或者是App发起请求时设置的地址

`URI`：统一资源标识符，唯一的标记互联网资源

`URL`：统一资源定位符，也就是**网址**，实际为`URI`的子集

#### URI结构

![URI结构](/images/URI结构.webp)

##### 协议类型(`scheme`)

比如`http`,`https`,`file`等，必须和`://`连在一起

##### 服务器地址(`host:port`)

对应的是所需接受浏览器/App请求的服务器地址

##### 请求路径(`path`)

对应请求需要处理的位置

##### 查询参数(`query`)

为`key=value`这类的形式，存在多个用`&`进行连接

##### 锚点(`fragment`)

表示URI定位资源内的一个锚点，通过这个锚点可以跳转到指定位置

```
https://juejin.im/search?query=s#heading-1
```







## 参考链接

[图解HTTP]()

[深入理解HTTPS](https://mp.weixin.qq.com/s/smYo1tECl6-TS6anKF8Jgw)

[HTTP灵魂之问](https://juejin.im/post/5e76bd516fb9a07cce750746#heading-74)

[中间人攻击](https://zh.wikipedia.org/wiki/中间人攻击)

[HTTP协议版本差异](https://www.jianshu.com/p/52d86558ca57)

[GET与POST区别](https://www.zhihu.com/question/28586791)

[CSRF防护](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

[CDN相关](https://www.zhihu.com/question/36514327/answer/193768864)

[TCP拥塞控制详解](https://mp.weixin.qq.com/s/KTKVu3uCC5MFlU5oylZPFA)

​            

]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化-网络优化详解</title>
    <url>/2020/10/09/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[
<!--DNS优化 连接优化 弱网优化-->

]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-synchronized关键字分析</title>
    <url>/2018/12/18/Java-synchorized%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
# synchronized

## `synchronized`场景

一般用在以下场景

### 修饰实例方法（锁定当前对象实例）

```java
public class SynchronizedInstance{
  public synchronized void test(){
    //...
  }
}
```

> 锁定的是访问该方法的实例对象，如果在多个线程中的不同对象访问该方法，则不可保证互斥同步效果



### 修饰静态方法(锁定当前类Class对象)

```java
public class SynchronizedStatic{
  public synchronized static void test(){
    //...
  }
}
```

> 由于静态方法是类方法，所以锁的是包含这个方法的类，也就是类对象；如果多个线程调用不同实例对象，也会有互斥同步效果



### 修饰代码块(锁定指定对象)

```java
public class Singleton{
  private static volatile Suingleton mInstance;
  public static Singleton getInstance(){
    if(mInstance==null){
      synchronized(Singleton.class){
        if(mInstance==null){
          mInstance = new Singleton();
        }
      }
    }
    return mInstance;
  }
}
```

> 



>`synchronized`可作用于一段代码或方法，既可以保证可见性也可以保证原子性。
>
>**可见性**：通过`synchronized`能保证同一个时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前将会对变量的修改刷新到主存中。
>
>**原子性**：要么不执行，要么执行到底。
>
>锁类型为：**可重入锁，非公平锁，独占锁，互斥锁**

{% fullimage /images/synchronized.png,synchronized关键字,synchronized关键字%}

## `synchronized`作用

- 确保线程互斥的访问代码块，同一时刻只有一个方法进入临界区，其他线程必须等到当前线程执行完毕才能使用。
- 保证共享变量的修改能即时可见
- 有效解决重排序问题

## `synchronized`使用

### 修饰实例方法，锁的是当前对象实例(this)

> 一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。

```java
public class SynchronizedMethodTest { 
   public synchronized void method1(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.err.println("method1 finish" + System.currentTimeMillis());
    }

    public synchronized void method2(){
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.err.println("method2 finish"+ System.currentTimeMillis());
    }

    public static void main(String[] args){
        final SynchronizedMethodTest test =new SynchronizedMethodTest();
        new Thread(test::method1).start();
        new Thread(test::method2).start();
    }
}

输出结果：
method1 finish 1545188801152
method2 finish 1545188803157
```



### 修饰静态方法，锁的是当前Class对象(静态方法属于类，而不是对象) 

> 由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。

```java
public class SynchronizedStaticMethodTest {
    public synchronized static void method1() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.err.println("method1 finish" + System.currentTimeMillis());
    }

    public synchronized static void method2() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.err.println("method2 finish" + System.currentTimeMillis());
    }

    public static void main(String[] args) {
        new Thread(SynchronizedStaticMethodTest::method1).start();
        new Thread(SynchronizedStaticMethodTest::method2).start();
    }
}

输出结果
method1 finish 1545189344322
method2 finish 1545189346327
```



### 修饰代码块，锁的是括号里的对象

> 修饰代码块 其中普通代码块 如`synchronized（obj）` 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；
> Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。
> Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。
>
> **就是 Synchronized代码块更加灵活精确。**

```java
public class SynchronizedCodeBlockTest {
    public void method1() {
        synchronized (this) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.err.println("method1 finish" + System.currentTimeMillis());
        }
    }

    public void method2() {
        synchronized (this) {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.err.println("method2 finish" + System.currentTimeMillis());
        }
    }

    public static void main(String[] args) {
        final SynchronizedCodeBlockTest test =new SynchronizedCodeBlockTest();
        new Thread(test::method1).start();
        new Thread(test::method2).start();
    }
}

输出结果：
method1 finish 1545189694303
method2 finish 1545189696308
```

### 修饰代码块，但是指定了修饰类，此时锁的是括号里的Class类对象

> Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。

```java
public class Test{
    public void method(){
        synchronized(Test.class){
            try{
                Thread.sleep(500);
            }catch(Exception e){
                e.printStackTrace();
            }
        }
    }
}
```



## `synchronized`锁的区别

### 对象锁

> 类似`synchronized(this)`就为对象锁的一种，其他的还包括`synchronized`修饰的实例方法`public synchronized void method() `。

**控制方法间的同步。**Java中的所有对象都包含一个`互斥锁`，这个锁由JVM自动获取和释放。当线程进入`synchronized`的时候会获取该对象的锁，如果有其他线程已经获得了这个对象锁，当前线程就需要等待其他线程执行完毕——`synchronized`正常返回或者抛出异常终止。JVM就会自动释放该锁。

### 类锁

> 类似`synchronized(obj.class)`就为类锁的一种，其他还包括`synchronized`修饰的静态方法`public synchronized static void method()`。

**控制静态方法之间的同步。**由于Java类中只会有一个Class对象，类的不同实例之间共享该类的Class对象。类锁对应的锁数量也就只有一个，就是锁住Class对象。



| 类型                   | 锁对象   | 锁的数量                       | 实现形式                                                     | 使用场景             |
| ---------------------- | -------- | ------------------------------ | ------------------------------------------------------------ | -------------------- |
| 对象锁(包括实例方法锁) | 实例对象 | 多个<br>类的对象实例可以有多个 | `synchronized void method()`<br>`synchronized(this){}`       | 控制方法间的同步     |
| 类锁(包括静态方法锁)   | 类对象   | 1个<br>一个类只会有一个类对象  | `synchronized static void method()`<br>`synchronized(obj.class)` | 控制静态方法间的同步 |



## `synchronized`原理

JVM基于进入和退出`monitor`对象来实现**代码块同步**和**方法同步**。

- **代码块同步**

  在编译后通过`monitorenter`插入到同步代码的开始处，将`monitorexit`插入到代码结束处和异常处，反编译字节码时就可以看到相关指令。**JVM要保证每个monitorenter必须有对应的monitorexit。**

  `monitorenter`：每个对象都有一个监视器锁(`monitor`)，当某个monitir被某个线程占用时就会处于锁定状态，线程执行`monitorenter`指令时会尝试获取`monitor`的所有权，尝试获取对象的锁。

  - monitor进入数为0，则该进程进入monitor，然后将进入数置为1，该进程即为monitor的持有者
  - 如果线程已占有monitor，只是重新进入，则monitor进入数+1
  - 如果其他线程已占用monitor，则该线程处于堵塞状态，直至monitor进入数为0，在尝试重新获取monitor的所有权

  `monitorexit`：执行`monitorexit`的线程必须是objectref所对应的monitor持有者。指令执行时，monitor进入数-1，如果-1后进入数为0，则线程退出monitor，不再是monitor持有者。其他被这个monitor阻塞的线程就可以尝试去获取monitor。

  > 反编译命令 `javap -v **.class`

  ```java
           3: monitorenter
           4: ldc2_w        #16                 // long 2000l
           7: invokestatic  #4                  // Method java/lang/Thread.sleep:(J)V
            ...
          45: aload_1
          46: monitorexit
          47: goto          55
          50: astore_3
          51: aload_1
          52: monitorexit
  
  ```

- **方法同步**

  `synchronized`在`method_info`会添加`ACC_synchronized`标记，线程执行会识别该标记，获取对应的锁。

  ```java
  public synchronized void method2();
      descriptor: ()V
      flags: ACC_PUBLIC, ACC_SYNCHRONIZED
      Code:
        stack=4, locals=2, args_size=1
           0: ldc2_w        #16                 // long 2000l
           3: invokestatic  #4                  // Method java/lang/Thread.sleep:(J)V
  
  ```

两者实现细节不同，**本质上都是对一个对象的监视器(monitor)获取，任意一个对象都拥有自己的监视器。**当这个对象由代码块同步或者方法同步调用时，**执行方法的线程必须先获取对象的监视器才能进入同步块或同步方法，没有获取到对象监视器的线程就会被堵塞在入口处，变为Blocked堵塞状态。当成功获取监视器线程释放了锁后，会唤醒堵塞的同步队列的线程，使其重新尝试获取监视器。**

{% fullimage /images/synchronized-monitor.png,同步方法关系,同步方法关系%}







理解Java中的synchronized关键字。
指标：理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。

有如下一个类A

```java
class A {
    public synchronized void a() {
    }

    public synchronized void b() {
    }
}
```

然后创建两个对象

```java
A a1 = new A();
A a2 = new A();
```

然后在两个线程中并发访问如下代码：
Thread1                       Thread2
a1.a();                       a2.a();

请问二者能否构成线程同步？

如果A的定义是下面这种呢？

```java
class A {
    public static synchronized void a() {
    }

    public static synchronized void b() {
    }
}
```

# 答案

Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。

> Synchronized作用:

- 确保线程互斥的访问同步代码块
- 保证共享变量的修改能够及时可见
- 有效解决重排序问题

> wait(),notify(),notifyAll(),sleep()作用

- wait 调用线程 释放锁，然后进入休眠
- sleep thread的一个操作方法，不释放锁直接进入休眠
- notify 唤醒等待队列中的第一个相关进程
- notifyAll 唤醒所有

> Synchronized主修修饰对象为以下三种：

1. 修饰普通方法 一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。
2. 修饰静态方法 由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。
3. 修饰代码块 其中普通代码块 如Synchronized（obj） 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。
   Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。
   Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。

简单来说 就是 Synchronized代码块更加灵活精确。

> 示例代码

```java
public class SyncThread implements Runnable {
    private static int count;
    public SyncThread() {
        count = 0;
    }
    @Override
    public void run() {
        synchronized (this) {
            for (int i = 0; i < 5; i++) {
                try {
                    System.err.println(Thread.currentThread().getName() + " " + (count++));
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    public static int getCount() {
        return count;
    }
}
```

# 修饰代码块

```java
 public static void main(String[] args) {
        SyncThread syncThread = new SyncThread();
        Thread thread1 = new Thread(syncThread, "sync1");
        Thread thread2 = new Thread(syncThread, "sync2");
        thread1.start();
        thread2.start();
    }
```

访问的同一个对象时，同一时刻只能有一个线程执行，执行代码块是会锁定当前对象，所以需要执行完才能释放，下一个线程才能继续执行并锁定对象

> 运行结果

```log
sync1 0
sync1 1
sync1 2
sync1 3
sync1 4
sync2 5
sync2 6
sync2 7
sync2 8
sync2 9
```

# 修饰对象

```java
 public static void main(String[] args) {
        Thread thread1 = new Thread(new SyncThread(), "sync1");
        Thread thread2 = new Thread(new SyncThread(), "sync2");
        thread1.start();
        thread2.start();
    }
```

这时创建了两个SyncThread对象，线程1执行对象1中的同步代码，线程2执行的是对象2的代码，这时两把锁分别锁定SyncThread1和SyncThread2对象，两把锁互不干扰也不互斥，所以同时执行。

> 运行结果

```log
sync1 0
sync2 1
sync1 2
sync2 3
sync1 4
sync2 5
sync1 6
sync2 7
sync1 8
sync2 9
```

问题1 ：不能同步

- a1.a()锁是a1 a2.b()锁是a2 不是同一把锁 所以不同步
  问题2：能同步
- 锁都为A.class对象，是统一把锁]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-协程</title>
    <url>/2019/04/12/Kotlin%E5%8D%8F%E7%A8%8B%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[


> 协程本质上是**轻量级的线程**。

## 协程的概念

协程是一种**非抢占式或协作式**的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。避免在异步编程中使用大量的回调，同时相比于传统的多线程技术，更容易*提升系统的高并发处理能力。*

线程和协程属于**一对多**关系，一个线程上允许存在多个协程。

> 线程大多数的实现是映射到内核的线程，当线程中的代码逻辑在线程抢到CPU的时间片才可以执行，否则只能等待。而协程之所以**轻量级**，协程并不会映射到内核线程，调度可以在用户态搞定，任务之间调度并非抢占式。



## 协程的使用

```kotlin
GlobalScope.launch(Dispatchers.Main + ,start = CoroutineStart.DEFAULT){
  // TODO
}

public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,//协程作用域
    start: CoroutineStart = CoroutineStart.DEFAULT,//协程启动方式
    block: suspend CoroutineScope.() -> Unit //协程内需要执行的操作
): Job {...}
```

### 协程作用域(`CoroutineScope`)

> 在Android环境中，通常每个界面(Activity、Fragment)启动的协程(`Coroutine`)只在该界面有效，当退出界面时，协程执行的任务也没有意义。所以在设计`Coroutine`时会要求在`Scope`中执行，当`CoroutineScope`取消时，对应的`Coroutine`也需要自动取消。

#### 阻塞协程作用域(`runBlocking`)

> 调用`runBlocking`的线程会被阻塞直到内部协程任务执行完毕

```kotlin
runBlocking {
    launch {
        println("Hello ${System.currentTimeMillis()}")
        delay(1000)
    }
}
println("world ${System.currentTimeMillis()}")

输出结果：
Hello 1597924663541
world 1597924664551
结果相差接近1s
```

**多用于单元测试代码中，不会用于实际的业务开发。就因为会堵塞当前线程**



#### 全局协程作用域(`GlobalScope`)

> 作用于整个应用的生命周期中，并且无法被取消，在界面中使用，例如`Activity`中使用，就会导致内存泄露

```kotlin
GlobalScope.launch(Dispatchers.Unconfined) {
    println("Hello ${System.currentTimeMillis()}")
    delay(1000)
}
println("world ${System.currentTimeMillis()}")

输出结果：
Hello 1597924937030
world 1597924937038
结果接近
```

通过`GlobalScope`创建的协程将不会有`父协程`，也被称为`根协程`。



```kotlin
public object GlobalScope : CoroutineScope {
    /**
     * Returns [EmptyCoroutineContext].
     */
    override val coroutineContext: CoroutineContext
        get() = EmptyCoroutineContext //返回一个上下文但并没有进行上下文关联，导致无法被取消
}
```





#### 自定义协程作用域(`: CoroutineScope`)

> 自定义协程的作用域，就不会造成作用域过大导致的内存泄漏

```kotlin
val coroutineContext : CoroutineContext = Dispatchers.Main + Job()//协程上下文
val coroutineScope = CoroutineScope(coroutineContext)//自定义作用域

fun main(args:Array<String>){
  coroutineScope.launch{
      println("Hello ${System.currentTimeMillis()}")
      delay(1000)
  }
  println("world ${System.currentTimeMillis()}")
  //主动控制作用域的取消
  coroutineScope.cancel()
}
```

自定义协程作用域最关键的就是**定义CoroutineContext属性**。

自定义`CoroutineContext`主要由两部分构成：`dispatcher`、`job`。

`dispatcher`：用于指定协程默认使用的调度器(*后续会介绍*)

`job`：可在任意时刻取消协程(*后续会介绍*)

```kotlin
val coroutineContext : CoroutineContext = Dispatchers.Main + Job()
```

用`+`连接多个上下文，其中如果出现多个同类型的上下文，后面新添加的会成为使用的上下文，例如

```kotlin
val coroutineContext : CoroutineContext = Dispatchers.Unconfined + Job() + Dispatchers.IO
print(coroutineContext.toString())

输出结果：
[JobImpl{Active}@300ffa5d, Dispatchers.IO] //采用了新添加的调度器
```

#### 系统提供协程作用域

##### MainScope

> 为了方便开发使用，kotlin标准库中定义了`MainScope()`可以快速生成`CoroutineScope`

```kotlin
//MainScope实现源码
public fun MainScope(): CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)

使用方式：
val mainScope  = MainScope()

fun test(){
  mainScope.launch{
    //TODO
  }
}

fun onDestroy(){
  mainScope.cancel()
}
```



##### viewModelScope

> 在AndroidX中 引入了`viewModelScope`，当ViewModel销毁时会自动取消协程任务。

```kotlin
//引用viewModelScope
implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.1.0-beta01:" //也可以引用更高版本

class MyViewModel:ViewModel(){
  fun test(){
    viewModelScope.launch{
      //TODO 
    }
  }
}
```

简单源码解析：

```kotlin
//lifecycle/lifecycle-viewmodel-ktx/src/main/java/androidx/lifecycle/ViewModel.kt

private const val JOB_KEY = "androidx.lifecycle.ViewModelCoroutineScope.JOB_KEY"

/**
 * [CoroutineScope] tied to this [ViewModel].
 * This scope will be canceled when ViewModel will be cleared, i.e [ViewModel.onCleared] is called
 *
 * This scope is bound to
 * [Dispatchers.Main.immediate][kotlinx.coroutines.MainCoroutineDispatcher.immediate]
 */
//使用拓展方法
val ViewModel.viewModelScope: CoroutineScope
        get() {
            val scope: CoroutineScope? = this.getTag(JOB_KEY)
          //缓存中读取 对应scope
            if (scope != null) {
                return scope
            }
           //对应了ViewModel内部的实现代码
            return setTagIfAbsent(JOB_KEY,
                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate))
        }
//自动取消 coroutineScope
internal class CloseableCoroutineScope(context: CoroutineContext) : Closeable, CoroutineScope {
    override val coroutineContext: CoroutineContext = context

    override fun close() {
        coroutineContext.cancel()
    }
}
```

`viewModelScope`默认调度器为`Dispatchers.Main`，因为`ViewModel`与UI交互较为频繁，减少线程间的切换。

```kotlin
//lifecycle/lifecycle-viewmodel/src/main/java/androidx/lifecycle/ViewModel.java

private final Map<String, Object> mBagOfTags = new HashMap<>();
//同步存值
    <T> T setTagIfAbsent(String key, T newValue) {
        T previous;
        synchronized (mBagOfTags) {
            previous = (T) mBagOfTags.get(key);
            if (previous == null) {
                mBagOfTags.put(key, newValue);
            }
        }
        T result = previous == null ? newValue : previous;
        if (mCleared) {
            closeWithRuntimeException(result);
        }
        return result;
    }

 @MainThread
//销毁ViewModel
    final void clear() {
        mCleared = true;
        // Since clear() is final, this method is still called on mock objects
        // and in those cases, mBagOfTags is null. It'll always be empty though
        // because setTagIfAbsent and getTag are not final so we can skip
        // clearing it
        if (mBagOfTags != null) {
            synchronized (mBagOfTags) {
              //读取缓存好的 viewModelScope对象
                for (Object value : mBagOfTags.values()) {
                    // see comment for the similar call in setTagIfAbsent
                    closeWithRuntimeException(value);
                }
            }
        }
        onCleared();
    }

//清理缓存对象 这也是CloseableCoroutineScope存在的原因
 private static void closeWithRuntimeException(Object obj) {
        if (obj instanceof Closeable) {
            try {
                ((Closeable) obj).close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
```

### 协程启动模式(`CoroutineStart`)

> 控制协程创建后的调用规则

#### CoroutineStart.DEFAULT

> 协程的默认启动模式，为`饿汉式调用`，调用协程后，会立即进入调度状态(等待调度器初始化完毕)。

```kotlin
suspend fun test1(){
    print(1)
    val job = GlobalScope.launch {
        print(2)
        delay(1000)
    }
    print(3)
    job.join()
    print(4)
}

输出结果：
123(delay 1000ms)4
```

**协程创建后，立即开始调度，在调度前如果协程被取消，将直接进入取消响应的状态。**

#### CoroutineStart.LAZY

> `懒汉式调用`，`launch`后并不会有任何调度行为，协程也不会执行，直到调用执行时，协程才会执行。
>
> 只有主动调用`start、join、或await`后协程才会开始调度。
>
> `job.start()`：启动协程
>
> `job.join()`：启动协程并等待任务执行结束

```kotlin
suspend fun test1(){
    print(1)
    val job = coroutineScope.launch(start = CoroutineStart.LAZY) {
        print(2)
        delay(1000)
    }

    print(3)
    job.start()
  //job.join()
    print(4)
}

输出结果：
job.start() 1324 没有延迟输出4
job.join() 1324 延迟1s后输出4
```

**协程创建后，只有被需要使用时才会执行，例如调用`start、join`才会开始调度执行。**

#### CoroutineStart.ATOMIC(实验版)

> 协程创建后，立即开始调度，在**协程执行到第一个挂起点之前不会响应`cancel`操作**

```kotlin
suspend fun test1(){
    print(1)
  //val job = GlobalScope.launch(start = CoroutineStart.DEFAULT) {
    val job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {
        print(2)
        delay(1000)
    }
    job.cancel()
    print(3)
    print(4)
}

输出结果：
DEFAULT：134 由于在准备执行时触发了cancel，导致2无法输出
ATOMIC：1324 ATOMIC在执行前不会响应到cancel，所以2正常输出
```

**ATOMIC将`调度`与`执行`合二为一，是一个原子化操作。**

升级版示例：

```kotlin
    print(1)
    val job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {
        print(2)
        delay(1000)
        print(5)
    }
    job.cancel()
    print(3)
    print(4)

输出结果：
1342 
不输出5的原因是：`ATOMIC`在第一个挂起点时忽略`cancel`，后续在执行挂起时,`cancel`	功能生效，导致后续无法输出，这里`delay`就是下一次的挂起操作。
```

#### CoroutineStart.UNDISPATCHED(实验版)

> 协程创建后立即在当前函数调用栈中执行，直到第一个挂起点？

```kotlin
suspend fun test1(){
    println("${Thread.currentThread()} 1")
    val job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) {
 // val job = GlobalScope.launch(start = CoroutineStart.DEFAULT) {
        println("${Thread.currentThread()} 2")
        delay(1000)
        println("${Thread.currentThread()} 5")
    }

    println("${Thread.currentThread()} 3")
    job.join()
    println("${Thread.currentThread()} 4")
}

输出结果：
DEFAULT
Thread[main,5,main] 1
Thread[main,5,main] 3
Thread[DefaultDispatcher-worker-1,5,main] 2
Thread[DefaultDispatcher-worker-1,5,main] 5
Thread[DefaultDispatcher-worker-1,5,main] 4

UNDISPATCHED
Thread[main,5,main] 1
Thread[main,5,main] 2
Thread[main,5,main] 3
Thread[DefaultDispatcher-worker-1,5,main] 5
Thread[DefaultDispatcher-worker-1,5,main] 4
```

比较`DEFAULT`结果可见，在`UNDISPATCHED`条件下，未达到挂起点时，代码会执行在调用函数栈中，例如`UNDISPATCHED`的`print(2)`就输出在`Main`线程下。

| CoroutineStart配置 | 功能                                                         |
| ------------------ | ------------------------------------------------------------ |
| DEFAULT            | 协程创建后立即执行                                           |
| LAZY               | 协程创建后，等待需要调用时才会执行协程<br>`start、join、await`等代码调用 |
| ATOMIC             | 功能类似`DEFAULT`，但是在执行协程前无法被取消，直到执行到了第一个`suspend函数`,例如`delay()`就是个`suspend`函数 |
| UNDISPATCHED       | 立即在当前线程执行协程，直到执行到了第一个`suspend函数`      |



### *协程上下文(`CoroutineContext`)

> 本体是一个数据结构，可以看做是`map`，内部实现为`单链表`
>
> `上下文`记录了协程所需信息：
>
> - 协程调度器：Dispatchers
> - 执行任务：Job
> - 协程名字：CoroutineName
> - 协程异常处理：CoroutineExceptionHandler

```kotlin
val coroutineContext : CoroutineContext = Dispatchers.Main + Job() + CoroutineName("name")//协程上下文
```

#### 自定义上下文

Kotlin提供了`AbstractCoroutineContextElement`可以快速实现自定义上下文，例如`CoroutineName`就是依赖这个实现的

```kotlin
public data class CoroutineName(
    /**
     * User-defined coroutine name.
     */
    val name: String
) : AbstractCoroutineContextElement(CoroutineName) {
    /**
     * Key for [CoroutineName] instance in the coroutine context.
     */
    public companion object Key : CoroutineContext.Key<CoroutineName>

    /**
     * Returns a string representation of the object.
     */
    override fun toString(): String = "CoroutineName($name)"
}

```

#### 协程上下文的父子关系

> 每个协程都会有一个父级对象，协程的父级对象的`上下文`也会和父级协程的`上下文`不一致。

关系遵循如下公式

**父级上下文 = 默认值 + 继承的`CoroutineContext` + 参数**

`默认值`：一些元素包含的默认值，例如默认`Dispatcher`就是`Dispatchers.Default`

`继承的CoroutineContext`：父协程的`CoroutineContenxt`

`参数`：后续子协程配置的参数，如上文所示组成部分，新添加的参数会覆盖前面的对应配置。

```kotlin
suspend fun testCoroutineContextExtend() {
    val parentContext: CoroutineContext = Dispatchers.Default + Job() + CoroutineName("parent")
    val parentScope = CoroutineScope(parentContext)
    parentScope.launch {
        log(currentCoroutineContext().toString()) //打印当前上下文内容
        val childContext = parentContext + Dispatchers.IO + CoroutineName("child")
        val job =  launch(childContext) {
            log(currentCoroutineContext().toString())
        }
    }
}

输出结果：
19:29:57:497 [DefaultDispatcher-worker-1] [CoroutineName(parent), StandaloneCoroutine{Active}@4815c1f8, Dispatchers.Default]
19:29:57:500 [DefaultDispatcher-worker-2] [CoroutineName(child), StandaloneCoroutine{Active}@2ca2b65d, Dispatchers.IO]
```

根据上述输出结果可得到**后续的同类内容会覆盖前面的元素**。

`CoroutineContext`使用**+**进行元素的合并，加号右侧的元素会覆盖左侧的元素，最后得到一个新的`CoroutineContext`元素。



//TODO 后续会补充如何调用自定义上下文

### 协程拦截器(`ContinuationInterceptor`)

> 协程拦截器也是`CoroutineContext`的一个实现，可以控制协程的执行流程，功能类似于`Okhttp的拦截器`。
>
> `协程拦截器`永远置于`CoroutineContext`组合的最后一位，保证不会被其他实现所覆盖。
>
> **协程拦截器最多只能存在1个。**
>
> <!--如何配置多个拦截器？-->

```kotlin
class CustomInterceptor : ContinuationInterceptor {
    override val key = ContinuationInterceptor

    override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>  = CustomContinuation<T>(continuation)

    class CustomContinuation<T>(val continuation: Continuation<T>) : Continuation<T> {
        override val context: CoroutineContext = continuation.context

        override fun resumeWith(result: Result<T>) {
            println("result = $result")
            //对result进行多次处理，也可以联动成多个拦截器的处理
            //此处hook 返回值可对其进行修改或者拓展
            continuation.resumeWith(result)
        }
    }
}

GlobalScope.launch(CustomInterceptor()){
  //TODO ...
}
```



### 协程调度器(`CoroutineDispatcher`)

> 属于`CoroutineContext`的子类，同时实现了`ContinuationInterceptor`接口，通过拦截功能实现协程的调度。
>
> 调度器的主要目的**切换执行线程**。

```kotlin
public abstract class CoroutineDispatcher :
    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {
  
      ... 
      //此处切换任务执行线程
      public abstract fun dispatch(context: CoroutineContext, block: Runnable)

 }
```

先了解源码中提供的调度器

#### Dispatchers.Default

> 默认协程调度器，适合处理后台计算，为`CPU密集型`任务调度器

<!--ForkJoinPool-->

```kotlin
public actual object Dispatchers {
      @JvmStatic
    public actual val Default: CoroutineDispatcher = createDefaultDispatcher()
  ...
}

internal actual fun createDefaultDispatcher(): CoroutineDispatcher =
    if (useCoroutinesScheduler) DefaultScheduler else CommonPool

internal object DefaultScheduler : ExperimentalCoroutineDispatcher() {
    val IO: CoroutineDispatcher = LimitingDispatcher(
        this,
        systemProp(IO_PARALLELISM_PROPERTY_NAME, 64.coerceAtLeast(AVAILABLE_PROCESSORS)),
        "Dispatchers.IO",
        TASK_PROBABLY_BLOCKING
    )

    override fun close() {
        throw UnsupportedOperationException("$DEFAULT_DISPATCHER_NAME cannot be closed")
    }

    override fun toString(): String = DEFAULT_DISPATCHER_NAME

    @InternalCoroutinesApi
    @Suppress("UNUSED")
    public fun toDebugString(): String = super.toString()
}
```

#### Dispatchers.IO（仅JVM可用）

> IO调度器，适合执行IO相关操作，例如读写文件，为`IO密集型`任务调度器

IO仅在JVM上有定义，基于`Default`调度器，并实现了独立的队列和限制，因此`Default与IO`切换不会触发线程切换。

```kotlin
suspend fun test2(){
    log("1")
    val job = GlobalScope.async(Dispatchers.IO) {
        log(2)
        withContext(Dispatchers.Default){
            log(3)
            withContext(Dispatchers.IO){
                log(4)
                withContext(Dispatchers.Default){
                    log(5)
                    123
                }
            }
        }
    }
    log(job.await())
}

输出结果：
13:26:04:564 [main] 1
13:26:04:581 [DefaultDispatcher-worker-1] 2
13:26:04:586 [DefaultDispatcher-worker-1] 3
13:26:04:586 [DefaultDispatcher-worker-1] 4
13:26:04:587 [DefaultDispatcher-worker-1] 5 //切换过程中一直在同一线程
13:26:04:588 [DefaultDispatcher-worker-2] 123
```

`Default`与`IO`调度器对任务的执行做了优化，可以保证线程执行效率较高。

主要原理为：Kotlin实现了`CoroutineScheduler`，支持抢占任务。

```kotlin
internal class CoroutineScheduler(
    @JvmField val corePoolSize: Int,
    @JvmField val maxPoolSize: Int,
    @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,
    @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME
) : Executor, Closeable {
  ...
  //CPU密集任务队列
    @JvmField
    val globalCpuQueue = GlobalQueue()
  //IO密集任务队列
    @JvmField
    val globalBlockingQueue = GlobalQueue()
  
  ...
      fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) {
        trackTask() // this is needed for virtual time support
        val task = createTask(block, taskContext)
        // try to submit the task to the local queue and act depending on the result
        val currentWorker = currentWorker()
        //任务优先插入本地队列中执行
        val notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)
        //本地队列已满，就将任务插入到全局队列中
        if (notAdded != null) {
            if (!addToGlobalQueue(notAdded)) {
                // Global queue is closed in the last step of close/shutdown -- no more tasks should be accepted
                throw RejectedExecutionException("$schedulerName was terminated")
            }
        }
      ...
    }
  //执行的任务
   internal inner class Worker private constructor() : Thread() {
      override fun run() = runWorker()
     //执行任务
     private fun runWorker() {
            var rescanned = false
            while (!isTerminated && state != WorkerState.TERMINATED) {
              //从队列中找到任务
                val task = findTask(mayHaveLocalTasks)
              ...
            }
   }
    //找到本地队列任务
    fun findTask(scanLocalQueue: Boolean): Task? {
            //获取CPU控制权
            if (tryAcquireCpuPermit()) return findAnyTask(scanLocalQueue)
            // If we can't acquire a CPU permit -- attempt to find blocking task
            val task = if (scanLocalQueue) {
                localQueue.poll() ?: globalBlockingQueue.removeFirstOrNull()
            } else {
                globalBlockingQueue.removeFirstOrNull()
            }
           //从其他队列获取任务执行
            return task ?: trySteal(blockingOnly = true)
        }

     //从其他队列获取任务
     private fun trySteal(blockingOnly: Boolean): Task? {
            assert { localQueue.size == 0 }
            val created = createdWorkers
            // 0 to await an initialization and 1 to avoid excess stealing on single-core machines
            if (created < 2) {
                return null
            }

            var currentIndex = nextInt(created)
            var minDelay = Long.MAX_VALUE
            repeat(created) {
                ++currentIndex
                if (currentIndex > created) currentIndex = 1
                val worker = workers[currentIndex]
                if (worker !== null && worker !== this) {
                    assert { localQueue.size == 0 }
                  //从其他工作线程中获取任务来执行
                    val stealResult = if (blockingOnly) {
                        localQueue.tryStealBlockingFrom(victim = worker.localQueue)
                    } else {
                        localQueue.tryStealFrom(victim = worker.localQueue)
                    }
                    if (stealResult == TASK_STOLEN) {
                        return localQueue.poll()
                    } else if (stealResult > 0) {
                        minDelay = min(minDelay, stealResult)
                    }
                }
            }
            minDelayUntilStealableTaskNs = if (minDelay != Long.MAX_VALUE) minDelay else 0
            return null
        }
  
}
```

总体设计分为三步：

1. 优先任务放在本地线程中，放在`Worker`中的`LocalQueue`中
2. 使用双重队列`GlobalCpuQueue(CPU密集任务队列)`、`GlobalBlockingQueue(IO密集任务队列)`，`LocalQueue`满后，任务会放到对应全局队列中
3. 当`LocalQueue`和`GlobalQueue`中的任务执行完时，会从其他正在执行任务的`Worker`中获取他的`LocalQueue`的任务放到自己的`LocalQueue`中执行。

这三步可以保证**线程资源的充分利用，减少了多线程的切换开销，提高了使用效率**。实现参考的是`ForkJoinPool`。

#### Dispatchers.Main

> UI调度器，根据执行平台不同会初始化为对应平台UI线程的调度器
>
> 在Android中，就会通过`Handler`调度到`UI线程`执行任务

```kotlin
//加载各个平台下定义的`MainDispatcherFactory`
private fun loadMainDispatcher(): MainCoroutineDispatcher {
        return try {
            val factories = if (FAST_SERVICE_LOADER_ENABLED) {
                FastServiceLoader.loadMainDispatcherFactory()
            } else {
                // We are explicitly using the
                // `ServiceLoader.load(MyClass::class.java, MyClass::class.java.classLoader).iterator()`
                // form of the ServiceLoader call to enable R8 optimization when compiled on Android.
                ServiceLoader.load(
                        MainDispatcherFactory::class.java,
                        MainDispatcherFactory::class.java.classLoader
                ).iterator().asSequence().toList()
            }
            @Suppress("ConstantConditionIf")
            factories.maxBy { it.loadPriority }?.tryCreateDispatcher(factories)
                ?: createMissingDispatcher()
        } catch (e: Throwable) {
            // Service loader can throw an exception as well
            createMissingDispatcher(e)
        }
    }
```

拿Android举例，分析下如何实现`Dispatchers.Main`功能

```kotlin
    internal fun loadMainDispatcherFactory(): List<MainDispatcherFactory> {
        val clz = MainDispatcherFactory::class.java
        if (!ANDROID_DETECTED) {
            return load(clz, clz.classLoader)
        }

        return try {
            val result = ArrayList<MainDispatcherFactory>(2)
          //加载对应类名的类
            createInstanceOf(clz, "kotlinx.coroutines.android.AndroidDispatcherFactory")?.apply { result.add(this) }
            createInstanceOf(clz, "kotlinx.coroutines.test.internal.TestMainDispatcherFactory")?.apply { result.add(this) }
            result
        } catch (e: Throwable) {
            // Fallback to the regular SL in case of any unexpected exception
            load(clz, clz.classLoader)
        }
    }
```

Android下的实现

```kotlin
//在Android编译完成后，可以读取到该类
internal class AndroidDispatcherFactory : MainDispatcherFactory {
    override fun createDispatcher(allFactories: List<MainDispatcherFactory>) = HandlerContext(Looper.getMainLooper().asHandler(async = true), "Main")
}
internal class HandlerContext private constructor(
    private val handler: Handler,
    private val name: String?,
    private val invokeImmediately: Boolean
) : HandlerDispatcher(), Delay {
    public constructor(
        handler: Handler,
        name: String? = null
    ) : this(handler, name, false)

    //android中需要向主looper进行提交调度
    override fun isDispatchNeeded(context: CoroutineContext): Boolean {
        return !invokeImmediately || Looper.myLooper() != handler.looper
    }

    //通过持有主线程looper的handler进行调度
    override fun dispatch(context: CoroutineContext, block: Runnable) {
        handler.post(block)
    }
    ...
}
```

Android的`Dispatchers.Main`通过`Handler`将任务放到主线程中执行。

#### Dispatchers.Unconfined

> 在协程体中，遇到第一个挂起函数前的代码运行在原线程中，执行挂起函数后，就运行在子线程中，



#### 自定义调度器

> `Default`和`IO`的底层实现都依赖了`线程池`，执行到`挂起函数`时还是会发生线程的切换。可以通过自定义调度器减少这类切换的发生。

```kotlin
val myDispatcher= Executors.newSingleThreadExecutor{ r -> Thread(r, "MyThread") }.asCoroutineDispatcher() //转换线程池到 Dispatcher

suspend fun test(){
  GlobalScope.launch(myDispatcher){
    //TODO 
  }
  
  //任务执行完毕后关闭线程池，避免内存泄漏
  myDispatcher.close() 
  
}
```

### 协程执行任务(`Job`)

> `Job`用于处理协程。封装了协程需要执行的代码逻辑，并且拥有简单的生命周期。
>
> **负责管理协程的声明周期。**

主要有以下几个生命周期：

- `New` 新建任务
- `Active` 任务活跃
- `Completing` 任务完成中
- `Cancelling` 任务取消中
- `Cancelled` 任务已取消
- `Completed` 任务已完成

{% fullimage  /images/Job生命周期.jpg,ViewTree,ViewTree%}

`Job.join()`：中断与当前`Job`关联的协程，直到所有`子Job`执行完成，所关联的协程才可以继续执行。

`join()`由`suspend`修饰，所以必须在协程内部被调用。



#### `SupervisorJob`

使用`Job`时，若发生异常会导致异常进行传递，导致`父任务及兄弟任务都会被取消`。

`SupervisorJob`针对异常传播情况进行处理，当发生异常时，只会影响自身，其他任务不受影响。

**`SupervisorJob`只有在`supervisorScope`或者`CoroutineScope(SupervisorJob())`内执行可以生效。**

```kotlin
val scope = CoroutineScope(SupervisorJob())

scope.launch{
  launch{
     //child 1
  }
  
  launch{
    // child 2
  }
}

若 child1 发生异常 child2可以继续运行。
```





### 协程构造器(`Coroutine Builders`)

> 配置完上述的`启动模式、调度器、上下文`之后，就要开始构造一个`协程`。

协程提供了几个通用的构造器

#### `launch`

> 默认构建一个新的协程，并返回一个`Job`对象，可以对该`Job`进行操作，例如`start()、join()`启动协程,`cancel()`取消该协程。

```kotlin
val job = GlobalScope.launch{
  //TODO ...
}
job.cancel()
```

`Job`代表了协程本身，封装了协程需要执行的代码逻辑，并且拥有简单的生命周期。



#### `async`

> 创建一个协程后，会返回一个`Deferred<T>`对象，可以通过该对象调用`await()`获取返回值。

```kotlin
val job = GlobalScope.async(Dispatchers.IO) {
	log(2)
  delay(1000)
  123
}
val result = job.await()
```

`async`允许**并行的允许多个子线程任务**。减少请求的耗时。

`Deferred`提供了`await()`，用`suspend`修饰，需要获取`Deferred`对象的结果时，调用`await()`等待执行结果返回。

### 协程异常处理(`Coroutine Exception`)

以下是会导致协程异常发生的测试代码

```kotlin
val a = 1
//模拟产生异常方法
suspend fun test3() =
    suspendCoroutine<Int> { continuation ->
        if (a == 0) {
            continuation.resume(a)
        } else {
            continuation.resumeWithException(IllegalArgumentException("haha"))
        }
    }

suspend fun main(args:Array<String>){
    val dispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher();
    coroutineScope.launch(dispatcher) {
        log(1)
        //创建子协程
        val job = coroutineScope.async {
            test2()
        }
        job.join()
        log(2)
    }
    log(3)
    dispatcher.close()
}

输出结果：
[main] 3
[pool-1-thread-1] 1
Exception in thread "pool-1-thread-1" java.lang.IllegalArgumentException: haha

Process finished with exit code 0 //程序终止
```

有以下两种手段来对异常进行捕获处理

#### 局部异常捕获

> 这部分主要涉及到`协程作用域`的概念，根据上面对`协程作用域`的描述，主要分为`GlobalScope`以及`自定义CoroutineScope`两种。
>
> 对于这两种`协程作用域`异常传播也有不同的形式。

##### 不传播异常

上面提到过`GlobalScope`为全局作用域，本身不存在父协程，发生异常后，只会输出异常信息，不会对运行产生影响。

```kotlin
suspend fun test5() {
    coroutineScope.launch {
        log(1)
        val job = GlobalScope.launch {
            throw NullPointerException("11")
        }
        log(2)
        delay(1000)
        log(3)
    }
    delay(1000)
    log(4)
}

输出结果：
20:02:29:623 [DefaultDispatcher-worker-1] 1
20:02:29:625 [DefaultDispatcher-worker-1] 2
Global Exception is catch and msg = 11
Exception in thread "DefaultDispatcher-worker-3" java.lang.NullPointerException: 11
	at com.webrtc.lib_licode_adaptation.MyClassKt$test5$2$job$1.invokeSuspend(MyClass.kt:183)
20:02:30:632 [kotlinx.coroutines.DefaultExecutor] 4
20:02:30:632 [DefaultDispatcher-worker-3] 3

Process finished with exit code 0
```

使用`GlobalScope`启动协程，发生异常时，不会影响外部协程的运行。



##### 传播异常

> **将异常主动往外抛到启动顶层协程所在的线程。**
>
> 主要采用`try{..}catch{...}`方式进行异常捕获

`coroutineScope`

> 协程默认作用域，在该作用域内当自身执行任务失败的时候，触发双向传播。
>
> **子协程异常<=>父协程异常**

示例：

```kotlin
suspend fun test7() {
    log(1)
    coroutineScope {
        // 启动一个子协程
        launch {
            try {
                delay(1000)
                println("3")
            } catch (e: Exception) {
                println(e.message)
            }
        }
        delay(100)
        throw NullPointerException("111")
        println("3")
    }
}

输出结果：
10:15:46:738 [main] 1
Parent job is Cancelling //由于父协程异常，导致子协程的执行取消
Exception in thread "main" java.lang.NullPointerException: 111
```

![img](/Users/wxy/myblog/blog/source/images/640.gif)

`supervisorScope`

> 在作用域内当自身执行任务失败的时候，只会向下传播关闭子协程，不会影响父协程及其他同级协程的运行。
>
> **父协程异常->子线程异常，子协程异常不影响父协程**
>
> `supervisorScope`使用`SupervisorJob`

```kotlin
private class SupervisorJobImpl(parent: Job?) : JobImpl(parent) {
    override fun childCancelled(cause: Throwable): Boolean = false //子协程不影响父协程
}
```

示例：

```kotlin
suspend fun test7() {
    println(1)
    supervisorScope {
        println("2")
        // 启动一个子协程
        launch {
            throw NullPointerException("111")// 故意让子协程出现异常
        }
        delay(100)
        println("3")
    }
    println("4")
}

输出结果：
1
2
Exception in thread "DefaultDispatcher-worker-1" java.lang.NullPointerException: 111
...
3
4
```

`supervisorScope`内子协程的异常不影响父协程的继续运行。

![img](/Users/wxy/myblog/blog/source/images/640.png)



#### 全局异常捕获

> 类似`Java`，协程也提供了捕获全局异常(`未声明捕获异常`)的方式。

`Java`的全局异常捕获方式：

```java
        Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                //TODO 异常处理
            }
        });
```

##### 协程内全局异常捕获方式（`针对协程作用域内未捕获的异常`）

```kotlin
suspend fun test4() {
    val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable ->
        log("Throws an exception with message: ${throwable.message}")
    }
    log(1)
    val job = coroutineScope.launch(exceptionHandler) {
        log(3)
        throw ArithmeticException("Hey!")
    }
    log(2)
  //避免执行过程中 进程中断，导致输出结果不一致
    delay(1000)
}

输出结果：
15:31:47:846 [main] 1
15:31:47:927 [main] 2
15:31:47:929 [DefaultDispatcher-worker-1] 3
15:31:47:933 [DefaultDispatcher-worker-1] Throws an exception with message: Hey! //捕获到异常

Process finished with exit code 0
```

上述代码调用了`launch`的构造方式，`async`的输出结果会如何？

```kotlin
suspend fun test4() {
    val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable ->
        log("Throws an exception with message: ${throwable.message}")
    }
    log(1)
    val job = coroutineScope.async(exceptionHandler) {
        log(3)
        4
        throw ArithmeticException("Hey!")
    }
    log(2)
    log(job.await())
    delay(1000)
}

输出结果：
16:04:14:980 [main] 1
16:04:15:013 [main] 2
16:04:15:015 [DefaultDispatcher-worker-1] 3
Exception in thread "main" java.lang.ArithmeticException: Hey!
	at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$1.invokeSuspend(MyClass.kt:171)
```

`async`直接抛出未捕获异常，导致当前进程执行中断

针对`launch`和`async`的不同表现，需要从源码层面进行分析

```kotlin
`launch`执行指向以下代码
// kotlinx.coroutines.BuildersKt
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,//启动方式
    block: suspend CoroutineScope.() -> Unit
): Job {
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    coroutine.start(start, coroutine, block)
    return coroutine
}

private open class StandaloneCoroutine(
    parentContext: CoroutineContext,
    active: Boolean
) : AbstractCoroutine<Unit>(parentContext, active) {
    override fun handleJobException(exception: Throwable): Boolean {
        handleCoroutineException(context, exception)
        return true
    }
}

public fun handleCoroutineException(context: CoroutineContext, exception: Throwable) {
    // Invoke an exception handler from the context if present
    //若context存在 ExceptionHandler 则会对异常进行处理
    try {
        context[CoroutineExceptionHandler]?.let {
            it.handleException(context, exception)
            return
        }
    } catch (t: Throwable) {
        handleCoroutineExceptionImpl(context, handlerException(exception, t))
        return
    }
    // If a handler is not present in the context or an exception was thrown, fallback to the global handler
    handleCoroutineExceptionImpl(context, exception)
}

`async`执行指向如下代码
public fun <T> CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Deferred<T> {
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyDeferredCoroutine(newContext, block) else
        DeferredCoroutine<T>(newContext, active = true)
    coroutine.start(start, coroutine, block)
    return coroutine
}

private open class DeferredCoroutine<T>(
    parentContext: CoroutineContext,
    active: Boolean
) : AbstractCoroutine<T>(parentContext, active), Deferred<T>, SelectClause1<T> {
  //没有对 exception进行处理，导致全局异常无法处理
    override fun getCompleted(): T = getCompletedInternal() as T
    override suspend fun await(): T = awaitInternal() as T
    override val onAwait: SelectClause1<T> get() = this
    override fun <R> registerSelectClause1(select: SelectInstance<R>, block: suspend (T) -> R) =
        registerSelectClause1Internal(select, block)
}
```

综上所述：**在全局异常处理下，只有用`launch`启动的协程才可以捕获异常，而`async`不能被捕获异常，会继续抛出异常。**

##### 真·全局异常捕获方式

上述实现的`ExceptionHandler`只能在协程内使用，而无法处理其他协程的异常情况。需要使用`ServiceLoader`来实现全局协程异常捕获

实现全局的异常捕获需要如下几步：

1. 新建全局`ExceptionHandler`类

   ```kotlin
   class GlobalExceptionHandler : CoroutineExceptionHandler{
       override val key: CoroutineContext.Key<*> = CoroutineExceptionHandler
   
       override fun handleException(context: CoroutineContext, exception: Throwable) {
           print("Global Exception is catch and msg = ${exception.message}")
       }
   }
   ```

   

2. `classpath`中注册该类

   在`src/main`目录下新建`resources/META-INF/`文件夹，然后新建文件命名为`kotlinx.coroutines.CoroutineExceptionHandler`，文件内写入

   ```
   com.XX.lib.GlobalExceptionHandler
   ```

   目录结构如下：

   src

   ​	-main

   ​		-java

   ​		-resources

   ​			-META-INF

   ​				-services

   ​					-kotlinx.coroutines.CoroutineExceptionHandler

3. 测试效果

   ```kotlin
   suspend fun test4() {
       val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable ->
           print("Throws an exception with message: ${throwable.message}")
       }
       log(1)
       val job = coroutineScope.launch() { //exceptionHandler配置
           log(3)
           throw ArithmeticException("Hey!")
       }
       log(2)
     //避免执行过程中 进程中断，导致输出结果不一致
       delay(1000)
   }
   
   输出结果：
   16:04:14:980 [main] 1
   16:04:15:013 [main] 2
   16:04:15:015 [DefaultDispatcher-worker-1] 3
   Global Exception is catch and msg = Hey!
   Exception in thread "main" java.lang.ArithmeticException: Hey!
   	at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$1.invokeSuspend(MyClass.kt:171)
   
   若配置了exceptionHandler就会覆盖Global的配置
   输出如下内容：
   16:04:14:980 [main] 1
   16:04:15:013 [main] 2
   16:04:15:015 [DefaultDispatcher-worker-1] 3
   Exception in thread "main" java.lang.ArithmeticException: Hey!
   	at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$1.invokeSuspend(MyClass.kt:171)
   
   
   ```

   **全局异常捕获的配置只对`launch`有效，`async`无效。**

   `真·全局异常捕获`不支持`JS以及Native`平台。
   
   拓展：
   
   1. SPI机制
   
      > 全称为`Service Provider Interface`，JDK内置的一种服务提供发现机制，主要源码在`java,util.ServiceLoader`。
   
      使用时需要在`META-INF/services`创建和服务同名的**全限定名**相同的文件(例如*com.xx.xx.service*)，在文件中写入**服务提供者**的全限定名(例如*com.xxx.xx.XXService*)。
   
      实现原理：
      
      1. 调用`ServiceLaoder.load()`创建新的`ServiceLoader`
      2. 再通过迭代器获取对象实例
         - 判断`providers`是否缓存实例对象，若存在则返回
         - 不存在，则执行类的装载过程：
           1. 读取`META-INF/services`的配置文件，获得需要被实例化类的名称
           2. 反射调用`Class.forName()`并调用`instance()`进行类实例化。**需要对应类必须存在一个无参构造方法。**
           3. 实例化对象存到`providers`缓存对象中并返回实例对象。
      
      缺点：
      
      1. 无法按需加载，只能通过遍历的方式获取全部接口实现类
      2. 无法直接获取实例对象，只能通过遍历匹配对应实现类
      3. 并发`serviceLoader`是不安全的
      
      

#### 总结

1. **协程内部异常处理流程**

   - 在作用域内使用`try..catch`可以直接捕获子线程中的异常
   - 如果未设置异常捕获，则会走`全局异常捕获流程`(**只在`launch`创建协程下生效**)
     - 若设置`CoroutineExceptionHandler`则处理
     - 没配置，向`GlobalExceptionHandler`进行处理，该配置时全局的，对所有协程任务生效

2. **异常传播不同作用域表现**

   - `GlobalScope`：异常不会向外传递，因为已经是`根协程`
   - `coroutineScope`：异常进行`双向传递`，父协程和子协程都会被取消
   - `supervisorScope`：异常进行`单向传递`，只有父协程向子协程传递异常，子协程会被取消，父协程不受影响

3. `launch/join`和`async/await`表现不同

   `launch/join`关注的是**任务是否执行完成**，`async/await`关注的是**任务的执行结果**，所以在局部异常捕获的时候，两种创建方式的异常捕获也会有区别
   
4. **全局的异常处理器(CoroutineExceptionHandler)只会对父协程生效，子协程的异常最后还是会传递到根协程进行处理。**非`supervisorScope`条件下。

### 协程取消(`Coroutine Cancel`)

> 取消针对`Job`而设的，调用`cancel()`可以取消正在运行的协程。

```kotlin
//官方示例代码
val job = launch {
    repeat(1000) { i ->
        println("I'm sleeping $i ...")
        delay(500L)
    }
}
delay(1300L) // 等待一段时间
println("main: I'm tired of waiting!")
job.cancel() // 取消 job
job.join() // 等待 job 结束
println("main: Now I can quit.")
```

上述代码是最基础的`cancel`使用方式



#### 协程之间的关系

> 协程之间是存在着父子关系的，**取消父协程时，也会取消所有子协程！**

主要有以下三种关系：

##### 父协程调用`cancel()`主动或者触发异常结束时，会立即取消所有子协程；子协程调用`cancel()`不影响父协程及兄弟协程执行。

```kotlin
基础调用流程
Job.cancel() => JobImpl.cancel() => JobSupport.cancelImpl() => JobSupport.notifyCancelling()

    private fun notifyCancelling(list: NodeList, cause: Throwable) {
        // first cancel our own children
        onCancelling(cause)
        notifyHandlers<JobCancellingNode<*>>(list, cause)
        // then cancel parent
        cancelParent(cause) // tentative cancellation -- does not matter if there is no parent
    }

    private fun cancelParent(cause: Throwable): Boolean {
        // Is scoped coroutine -- don't propagate, will be rethrown
        if (isScopedCoroutine) return true

        val isCancellation = cause is CancellationException
        val parent = parentHandle
        // No parent -- ignore CE, report other exceptions.
        if (parent === null || parent === NonDisposableHandle) {
            return isCancellation
        }
        //调用所有子协程进行取消任务，子线程也会收到 CancellException
        return parent.childCancelled(cause) || isCancellation
    }
```



##### 父协程必须等到所有子协程完成(执行完成 或 取消)才算完成



##### 子协程抛出未捕获的异常时，默认情况下会取消父协程(`CancellationException除外`)



#### 只有可取消的协程代码，才可以被取消

> 协程的代码必须与外界配合，才能够被取消！

目前只有`kotlinx.coroutines`中的所有挂起函数都是**可取消的**。这些挂起函数会检查协程是否被取消，并在被取消时抛出`CancellationException`异常。

例如`delay()、yield()`这些预置的挂起函数，或者封装的挂起函数都是可以被取消的。

##### delay()

> 让协程挂起，而且不会阻塞CPU。
>
> <!--Thread.sleep 让出CPU，不会释放锁。wait会释放锁，等待notify进行唤醒-->

```kotlin
public suspend fun delay(timeMillis: Long) {
    if (timeMillis <= 0) return // don't delay
    return suspendCancellableCoroutine sc@ { cont: CancellableContinuation<Unit> ->
        //将任务放到
        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)
    }
}

//默认延迟线程池
internal val CoroutineContext.delay: Delay get() = get(ContinuationInterceptor) as? Delay ?: DefaultDelay

//EventLoopImplBase
    public override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation<Unit>) {
        val timeNanos = delayToNanos(timeMillis)//设置执行时间
        if (timeNanos < MAX_DELAY_NS) {
            val now = nanoTime()
            DelayedResumeTask(now + timeNanos, continuation).also { task -> //按照延时添加任务
                continuation.disposeOnCancellation(task)
                schedule(now, task)
            }
        }
    }
```

关键点就在于`suspendCancellableCoroutine`提供了普通函数的挂起转换

```kotlin
public suspend inline fun <T> suspendCancellableCoroutine(
    crossinline block: (CancellableContinuation<T>) -> Unit
): T =
    suspendCoroutineUninterceptedOrReturn { uCont ->
        val cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)
        /*
         * For non-atomic cancellation we setup parent-child relationship immediately
         * in case when `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but
         * properly supports cancellation.
         */
        cancellable.initCancellability()
        block(cancellable)
        cancellable.getResult()
    }
```



##### yield()

> 挂起当前协程，然后将协程分发到`Dispatcher`的队列，可以让该协程所在线程或线程池可以运行其他协程逻辑，然后等待`Disapcher`空闲的时候继续执行原来协程。
>
> <!--Thread.yield() 让出CPU调度，只能让 同优先级的线程有执行机会-->

```kotlin
val dispatcher = Executors.newFixedThreadPool(2).asCoroutineDispatcher()  
coroutineScope.launch(dispatcher){
            launch { //协程1
                repeat(3) {
                    log("job1 repeat $it times")
                    yield() //让协程2得以执行
                }
            }
            launch { //协程2
                repeat(3) {
                    log("job2 repeat $it times")
//                    yield()
                }
            }
    }
delay(1000)
dispatcher.close()

输出结果：
19:28:30:808 [pool-1-thread-2] job1 repeat 0 times
19:28:30:809 [pool-1-thread-1] job2 repeat 0 times
19:28:30:809 [pool-1-thread-1] job2 repeat 1 times
19:28:30:809 [pool-1-thread-1] job2 repeat 2 times
19:28:30:809 [pool-1-thread-1] job1 repeat 1 times
19:28:30:809 [pool-1-thread-1] job1 repeat 2 times
```

`yield()`相关源码

```kotlin
public suspend fun yield(): Unit = suspendCoroutineUninterceptedOrReturn sc@ { uCont ->
    val context = uCont.context
    context.checkCompletion()
    ...
    COROUTINE_SUSPENDED
}
```



##### *suspendCoroutineUninterceptedOrReturn

根据上面两个源码发现，转换挂起函数的关键在于`suspendCoroutineUninterceptedOrReturn`，只要实现了该函数，就可以转换为可被取消的挂起函数

通常做转换的时候，可以使用系统提供的两个转换函数

- `suspendCoroutine`
- `suspendCancellableCoroutine`

这两者都调用了`suspendCoroutineUninterceptedOrReturn`函数

```kotlin
val aa = 0
suspend fun ttt() = suspendCancellableCoroutine<Int> { cancellableContinuation ->
    if (aa == 0) {
        //执行完毕抛出结果
        cancellableContinuation.resume(1) {
            // 执行过程异常捕获
            log("aaa ${it.message}")
        }
    } else {
        cancellableContinuation.resumeWithException(IllegalArgumentException("123"))
    }

    cancellableContinuation.invokeOnCancellation {
       //协程任务执行cancel时，回调该方法
        log("我被取消了")
    }
}
```



#### 取消计算代码(使用`isActive`判断)

> 如果协程正处在某个计算过程当中，并且不进行检查状态的取消，那它就是无法被取消的。

对于这种情况有两种处理方式：

1. 周期性调用挂起函数(`采用上面的手段得到挂起函数`)，检查协程是否被取消
2. 显式检查协程是否被取消

在这一节，采用的就是第二种方案取消协程。

```kotlin
suspend fun test9() {
    val startTime = System.currentTimeMillis()
    val dispatcher = Executors.newFixedThreadPool(3).asCoroutineDispatcher()
    val job = coroutineScope.launch(dispatcher) {
        var nextPrintTime = startTime
        var i = 0
        while (isActive) { // 一个浪费 CPU 的计算任务循环
            // 每秒打印信息 2 次
            if (System.currentTimeMillis() >= nextPrintTime) {
                i++
                log(i)
                nextPrintTime += 500L
            }
        }
    }
    delay(1300L) // 等待一段时间
    println("main: I'm tired of waiting!")
    job.cancelAndJoin() // 取消 job, 并等待它结束
    println("main: Now I can quit.")
    dispatcher.close()
}

输出结果：
19:30:01:805 [pool-1-thread-1] 1
19:30:02:292 [pool-1-thread-1] 2
19:30:02:792 [pool-1-thread-1] 3
main: I'm tired of waiting!
main: Now I can quit.
```

相关源码

```kotlin
JobSupport.cancelImpl() => JobSupport.makeCancelling() => JobSupport.tryMakeCancelling()

    private fun tryMakeCancelling(state: Incomplete, rootCause: Throwable): Boolean {
        assert { state !is Finishing } // only for non-finishing states
        assert { state.isActive } // only for active states
        // get state's list or else promote to list to correctly operate on child lists
        val list = getOrPromoteCancellingList(state) ?: return false
        // Create cancelling state (with rootCause!)
        val cancelling = Finishing(list, false, rootCause)
        if (!_state.compareAndSet(state, cancelling)) return false
        // Notify listeners
        notifyCancelling(list, rootCause)
        return true
    }

    private class Finishing(
        override val list: NodeList,
        isCompleting: Boolean,
        rootCause: Throwable?
    ) : SynchronizedObject(), Incomplete {
      
      ...
       override val isActive: Boolean get() = rootCause == null // !isCancelling 此处isActive就变为false
    }
```



#### 禁止取消

> 当任务被取消时，挂起函数会收到`CancellationException`后续如果需要执行一些其他的挂起函数任务将无法执行。

可以通过对挂起函数调用`withContext(NonCancellable)`进行包含，保证挂起函数正常执行

```kotlin
suspend fun test9() {
    val startTime = System.currentTimeMillis()
    val dispatcher = Executors.newFixedThreadPool(3).asCoroutineDispatcher()
    val job = coroutineScope.launch(dispatcher) {
        try {
            var nextPrintTime = startTime
            var i = 0
            //按道理 这边会被取消，因为设置了 NonCancellable导致任务无法被取消
            withContext(NonCancellable){
                log("111")
                delay(2000)
            }
        }
        finally {
                withContext(NonCancellable){
                    delay(1000)
                }
                log("111")
        }
    }
    delay(1300L) // 等待一段时间
    println("main: I'm tired of waiting!")
    job.cancelAndJoin() // 取消 job, 并等待它结束
    println("main: Now I can quit.")
    dispatcher.close()
}

输出结果：
20:31:35:163 [pool-1-thread-1] 111
main: I'm tired of waiting!
20:31:38:173 [pool-1-thread-3] 111  //间隔大概3s
main: Now I can quit.
```

`NonCancellable`就是一个普通的对象

```kotlin
public object NonCancellable : AbstractCoroutineContextElement(Job), Job {
 ...
      override val isActive: Boolean get() = true //永远为true
}
```



#### 超时取消

> 大部分取消协程的原因都是**超出了预期的执行时间**，此时就会去触发取消的操作。

```kotlin
suspend fun testTimeout() {
    try {
        withTimeout(1300) {
            repeat(5) {
                delay(500)
            }
        }
    } catch (e: Exception) {
        log("e.msg = ${e.message}") //捕获超时异常
    } finally {
        log("job cancelled") //任务取消后，可以做一些其他工作
    }
    delay(1000)
}

输出结果：
13:25:54:484 [kotlinx.coroutines.DefaultExecutor] e.msg = Timed out waiting for 1300 ms
13:25:54:485 [kotlinx.coroutines.DefaultExecutor] job cancelled
```

执行超过`timeout`的时候，会抛出`TimeoutCancellationException`异常

上述`withTimeout()`超时时会抛出异常，系统另外提供了`withTimeoutOrNull()`超时的时候不会抛出异常，而是返回一个null



### 协程挂起(`suspend`)

在上节`协程取消`中，说到取消协程的一个要求就是`必须为可被取消的协程代码`，里面就有讲到转换成`挂起函数`就可以被取消。

> 把协程当成一个任务，运行在某个线程之上，该任务是可以中止也可以被继续恢复执行。
>
> `协程挂起`指的就是*任务的中止，而且不会阻塞当前的线程。*
>
> `协程挂起`的条件是*在协程调用`挂起函数`时，才可以被挂起*。

#### 基础概念

##### 续体接口(`Continuation`)

> 作为协程调用`挂起函数`时的回调，`挂起函数`执行结束后通过使用该接口唤醒调用者。

```kotlin
@SinceKotlin("1.3")
public interface Continuation<in T> {
    /**
     * The context of the coroutine that corresponds to this continuation.
     * 定义的协程上下文
     */
    public val context: CoroutineContext

    /**
     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the
     * return value of the last suspension point.
     * 执行完毕回调，回调成功或失败的结果
     */
    public fun resumeWith(result: Result<T>)
}
//提供拓展函数，支持直接调用成功或失败回调
public inline fun <T> Continuation<T>.resume(value: T): Unit =
    resumeWith(Result.success(value))

public inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =
    resumeWith(Result.failure(exception))
```

`Continuation`作为`挂起函数`调用时的一个`隐式参数`传入，封装了协程恢复后的执行代码逻辑。

##### 挂起函数(`suspend function`)

>  `suspend`修饰挂起函数，可以通过调用其他`挂起函数`执行代码，而且**不阻塞当前执行线程**。
>
> `挂起函数`的运行可以被中止，运行`挂起函数`的线程可以去执行其他任务。
>
> **挂起函数无法被其他常规函数调用！**

```kotlin
suspend fun test(){
  ...
}
```

上述实例为`挂起函数`。









当`挂起函数`在一个协程中被调用时，该挂起函数内部会增加一个参数`Continuation`，类似下面的代码

```java
fun test(contimuation:Continuation){
  ...
}
```

这种转换被称为**CPS（续体传递风格）**，每个`挂起函数`或`挂起Lambda表达式`都会附加一个`Continuation`参数，在外界调用`挂起函数`时隐式入参。 





## 协程的原理

上述的基础概念已基本涵盖协程的整套执行流程，后面会在{%post_link Kotlin协程原理%} 串联整体流程。

## 协程在Android中的应用



## 附录

### CPU上下文

> **CPU寄存器和程序计数器**，这两者都是CPU在运行任务前，都必须的依赖环境。
>
> `CPU寄存器`：CPU内置的容量小、但速度极快的内存
>
> `程序计数器`：存储CPU正在执行的指令位置，或即将执行的下一条指令位置



### 上下文切换

> 把前一个任务的`CPU上下文`保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后在跳转到程序计数器所指的新位置，运行新任务。
>
> 被保存的上下文会存储到*系统内核*中，在任务被重新调度时重新加载。

#### 进程上下文切换

> 从一个进程切换到另一个进程运行。

进程的运行空间分为：

- `内核空间`：具有最高权限，可以访问进程间的所有资源。（进程运行其中称为**内核态**。）
- `用户空间`：只能访问受限资源，不能直接访问内存等硬件设备，必须通过**系统调用**陷入到内核中，才能访问所有资源。（进程运行其中为**用户态**。）

`系统调用(system-call)`：进程从`用户态`到`内核态`的转变，需要通过`系统调用`实现。过程如下：

- 保存CPU寄存器里原来用户态的指令位
- 为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置
- 跳转到内核态执行内核任务
- 系统调用结束后，CPU寄存器需要回复到原来保存的用户态，然后再切换到用户空间，继续运行线程。

`系统调用`过程中，总共发生了`两次CPU上下文切换`(用户态->内核态->用户态)。



#### 线程上下文切换

> 从一个线程切换到另一个线程执行。

**线程时调度的基本单位，进程这是资源拥有的基本单位。**内核中的任务调度，实际调度对象为线程；进程只是给线程提供了`虚拟内存、全局变量`等资源。

线程发生上下文切换时，还需要保存线程所拥有的私有数据，例如栈、寄存器等。

线程上下文切换场景：

- 切换的线程不处于同一进程中，因为资源不共享，执行的流程同`进程上下文切换`。
- 切换的线程处于同一进程中，资源是共享的，公共资源就不需要进行切换，只要切换线程的私有数据。

#### 中断上下文切换

> 中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。打断进程时，只需要保留当前进程的运行状态，中断执行结束后，继续从愿状态运行。

中断上下文切换不涉及进程的用户态，在中断触发时，只需要保存内核态中断服务程序所必需的状态。例如`CPU寄存器、内核堆栈、硬件中断参数等`。

**中断上下文切换比进程上下文切换拥有更高的优先级，两者不会在同一CPU上同时发生。**



## 参考链接

[viewModelScope简易介绍](https://juejin.im/post/6844903858368413704)

[Kotlin-调度器介绍](https://blog.csdn.net/weixin_42063726/article/details/106198068)

[协程官方文档](https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html)

[SPI机制](http://zhoukaibo.com/2019/03/16/java-spi-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/)

[Kotlin协程设计思路](https://github.com/Kotlin-zh/KEEP/blob/master/proposals/coroutines.md)

[揭秘suspend修饰符](https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652055127&idx=2&sn=283de8250bfc8a7bd8287a7aadad1339&chksm=808c8612b7fb0f047702c2101d27f4de42363ae5dd462be977ec897c7ae6a36e57b94675750a&scene=178#rd)

]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC相关记录</title>
    <url>/2020/08/06/WebRTC%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[
## WebRTC连接流程

![连接过程](https://pic4.zhimg.com/80/v2-02ce0ae8a59238a1d4303268ad5f76a5_1440w.jpg)



当前采用服务端框架为 `LiCode`





## WebRTC通话原理及相关概念

### 媒体协商

> 彼此了解对方支持的媒体格式



#### SDP

##### 参数含义



### 网络协商





## WebRTC源码相关





## WebRTC业务SDK功能

1.消息推送（语音电话提醒、新消息接收、对方挂断、支持拓展额外参数）

2.本地长连接（WebRTC dataChannel、保活）

3.语音通话（音频采集、降噪、回声消除、静音）

4.各种状态封装（连接成功、超时、失败、重连等）



## WebRTC待完成

单独编译VAD（静音检测）、NS（降噪）、AECM（回声消除）三模块

NS：`RNNoise`和`WebRTC-NS`



## WebRTC随手记

`SamplesReadyCallback`：在采集音频时可以获取音频信息

`setAudioProcessingFactory()`：设置音频处理相关配置



`webrtc_voice_engine.cc`音频控制

```c++
//音频处理默认配置
  {
    AudioOptions options;
    options.echo_cancellation = true;
    options.auto_gain_control = true;
    options.noise_suppression = true;
    options.highpass_filter = true;
    options.stereo_swapping = false;
    options.audio_jitter_buffer_max_packets = 200;
    options.audio_jitter_buffer_fast_accelerate = false;
    options.audio_jitter_buffer_min_delay_ms = 0;
    options.audio_jitter_buffer_enable_rtx_handling = false;
    options.typing_detection = true;
    options.experimental_agc = false;
    options.experimental_ns = false;
    options.residual_echo_detector = true;
    bool error = ApplyOptions(options);
    RTC_DCHECK(error);
  }


//降噪等级默认为 High  
if (options.noise_suppression) {
    const bool enabled = *options.noise_suppression;
    apm_config.noise_suppression.enabled = enabled;
    apm_config.noise_suppression.level =
        webrtc::AudioProcessing::Config::NoiseSuppression::Level::kHigh;
    RTC_LOG(LS_INFO) << "NS set to " << enabled;
  }


```



`audio_processing_impl.cc` Audio_processing处理类，包含回声消除、降噪等功能







]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS操作&amp;Atomic原子操作类分析</title>
    <url>/2018/12/18/Atomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[


{% fullimage /images/CAS.png,CAS基本知识,CAS基本知识%}



# CAS与原子操作

## 乐观锁与悲观锁

### 悲观锁

认为每次访问共享资源时都会发生冲突，必须对每次对象操作进行上锁，以保证临界区的程序同时只能有一个线程执行。

### 乐观锁

假设对共享资源的访问不会发生冲突，线程可以不停的执行，无需加锁。

**一旦发生线程冲突，通常都会采用`CAS操作`保证线程执行的安全性**



> `悲观锁`适用于**写多读少**的环境，避免频繁失败和重试影响性能。
>
> `乐观锁`适用于**写少读多**的环境，避免频繁加锁影响性能。



## CAS操作

> CAS是乐观锁技术，当多个线程尝试使用CAS更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程不会被挂起，而是告知竞争失败，并尝试再次发起请求。

CAS指令需要有三个操作数：

- **内存位置(V)**：简单的理解为变量的内存地址
- **旧的预期值(A)**
- **新值(B)**

执行CAS操作，当且仅当`V`符合旧预期`A`时，处理器就会更新`B`到`V`上。否则处理器不做任何操作。

```java
//伪代码实现
boolean compareAndSwap(V,A,B){
    if(V!=A){
        return false;//CAS操作失败
    }else{
        V=B;//替换内存中的值为新值
        return true;//CAS操作成功
    }
}
```

**由于CAS是一种原子操作，当多个线程同时使用CAS操作一个变量时，只有一个会成功，并且更新变量，其他线程都会失败。但失败的线程不会被挂起，只是告知失败，并且继续尝试操作变量。**

### CAS原理

> `compareAndSet()`内部是调用Java本地方法`compareAndSwapInt()`实现的，虚拟机内部对这些方法做了特殊处理，借助C来调用CPU的底层指令保证硬件层面实现原子操作。
>
> Intel CPU 利用**cmpxchg**指令实现CAS

CAS操作是由`sun.misc.Unsafe`类里面的`computeAndSwapXX()`实现的

```java
boolean compareAndSwapObject(Object o, long offset,Object expected, Object x);
boolean compareAndSwapInt(Object o, long offset,int expected,int x);
boolean compareAndSwapLong(Object o, long offset,long expected,long x);
```

`Unsafe`主要提供一些用于执行低级别，不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言等底层资源操作能力方法面起到了很大的作用。

但由于`Unsafe`可以操作内存空间，增加了程序发生指针问题的风险。

 [Java魔法类：Unsafe应用解析](https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html)



### CAS问题

#### ABA问题

因为CAS需要在操作值的时候检查值是否发生变化，如果没有发生变化则更新，但如果一个值原来是A，变成了B，再变成了A，对于CAS检查而言就是没有发生过变化，实际已经发生变化。

解决思路就是利用版本号，在变量前添加版本号，并每次更新时加1，则A->B->A 会变为 1A->2B->3A。

可以利用`AtomicStampedReference`来解决，它内部的`compareAndSwap()`首先会去检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，全部相等才会替换值。

```java
public boolean compareAndSet(V   expectedReference,
                             V   newReference,
                             int expectedStamp,
                             int newStamp) {
    Pair<V> current = pair;
    return
        expectedReference == current.reference &&
        expectedStamp == current.stamp && //比较标志是否等于预期标志
        ((newReference == current.reference &&
          newStamp == current.stamp) ||
         casPair(current, Pair.of(newReference, newStamp)));
}
```

也可使用`AtomicMarkableReference`主要关心的是**引用变量是否发生变化**。

```java
    public boolean compareAndSet(V       expectedReference,
                                 V       newReference,
                                 boolean expectedMark,
                                 boolean newMark) {
        Pair<V> current = pair;
        return
            expectedReference == current.reference &&
            expectedMark == current.mark &&
            ((newReference == current.reference &&
              newMark == current.mark) ||
             casPair(current, Pair.of(newReference, newMark)));
    }
```



#### 循环时间长开销大

相对于`synchronized`省去了挂起线程以及恢复线程的开销。CAS是非阻塞同步，不会将线程挂起，会进行自旋（`死循环`），时间过长会对性能造成很大的消耗。`Pause`指令

#### 只能保证一个变量的原子操作

当对多个变量进行操作时，CAS无法保证原子性操作，这时可以用锁或者`AtomicReference`保证引用对象之间的原子性，就可以把多个变量放在一个对象里进行操作。



## Atomic原子操作类

> 方便在多线程环境下，无锁的进行原子操作。**提供非阻塞的线程安全编程**

### 类摘要

| 类                          | 描述                                                    |
| --------------------------- | ------------------------------------------------------- |
| AtomicInteger               | 更新int                                                 |
| AtomicBoolean               | 更新boolean                                             |
| AtomicLong                  | 更新long                                                |
| AtomicIntegerArray          | 更新int数组                                             |
| AtomicIntegerFieldUpdater   | 基于反射，可以对指定类的指定``volatile int`字段进行更新 |
| AtomicLongArray             | 更新long数组                                            |
| AtomicLongFieldUpdater      | 基于反射，可以对指定类的指定`volatile long`字段进行更新 |
| AtomicMarkableReference     | 维护带有标记的对象引用，可以更新                        |
| AtomicReference             | 更新对象引用                                            |
| AtomicReferenceArray        | 更新对象引用数组                                        |
| AtomicReferenceFieldUpdater | 基于反射，可以对指定类的指定volatile 字段进行更新       |
| AtomicStampedReference      | 维护带有整数标志的对象引用，可以更新                    |

Java 8之后新增了4个新的原子操作类

| 类                | 描述       |
| ----------------- | ---------- |
| LongAdder         | 更新long   |
| DoubleAdder       | 更新double |
| LongAccumulator   | 更新long   |
| DoubleAccumulator | 更新double |

上述四个类引用`多段锁`的概念。**通过CAS保证原子性，通过自旋保证当次修改的最终修改成功，通过降低锁粒度（多段锁）增加并发性能。** 他们**属于原子累加器，适用于数据统计以及高并发环境，不适用于其他粒度的应用。**

> `原子累加器`使用了**热点分离**思想
>
> **热点分离**：①将竞争的数据进行分解成多个单元，在每个单元中分别进行数据处理 ②各单元处理完成后，通过`Hash算法`进行求和，从而得到最终结果
>
> `热点分离`减小了锁的粒度，提供并发环境下的吞吐量，但需要额外空间存储数据，增大空间消耗。



### 如何保证原子操作

内部都实现了一个`compareAndSet()`方法

```java
    
 // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }
    //用volatile修饰 value 保证可见性
    private volatile int value;

public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset/*V 内存地址*/, expect/*A 旧的预期值*/, update/*B 修改值*/);
    }

```

`compareAndSwap()`涉及了两个重要对象，一个是`unsafe`另一个是`valueOffset`。

`unsafe`是JVM提供的一个后门，用来执行 **硬件级别的原子操作**。

`valueOffset`是通过`unsafe`获取到的，代表 **AtomicInteger对象value成员变量在内存中的偏移量**。可以简单的认为是*value变量的内存地址*。



]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Art类加载过程</title>
    <url>/2019/12/19/Android-Art%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[
## Dex文件加载

> 加载Dex文件后会生成`DexFile`对象，里面储存了多个类文件信息。

通过`PathClassLoader`或者`DexClassLoader`去加载`Dex`文件，最后还是调用到`BaseDexClassLoader`的加载方法

```java
class BaseDexClassLoader extends ClassLaoder{
      public BaseDexClassLoader(String dexPath, File optimizedDirectory,
            String librarySearchPath, ClassLoader parent) {
        super(parent);
        this.pathList = new DexPathList(this, dexPath, librarySearchPath, null);
				...
    }
}
```

- DexPathList

  ```java DexPathList.java
  final class DexPathList{
    private Element[] dexElements;
    private final NativeLibraryElement[] nativeLibraryPathElements;
    
    ...
        public DexPathList(ClassLoader definingContext, String dexPath,
              String librarySearchPath, File optimizedDirectory) {
     ...
     // 记录所有的dexFile
     this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,                       suppressedExceptions, definingContext);
      
     //记录app目录的Native库
     this.nativeLibraryDirectories = splitPaths(librarySearchPath, false);
     //记录系统使用的Native库
     this.systemNativeLibraryDirectories =                splitPaths(System.getProperty("java.library.path"), true);
     //记录所有使用的Native库
     this.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories);
    }
  }
  ```

  为了初始化以下两个字段：

  - `dexElements`：记录所有的DexFile，按照`;`进行路径分割
  - `nativeLibraryPathElements`：记录所有的Native代码库，包括`app`和`系统`使用的Native库

- makeDexElements

  ```java
      private static Element[] makeDexElements(List<File> files, File optimizedDirectory,
              List<IOException> suppressedExceptions, ClassLoader loader) {
        Element[] elements = new Element[files.size()];
       for (File file : files) {
        ...
          //以 dex 文件名结尾
          if (name.endsWith(DEX_SUFFIX)) {
            try {
              //加载Dex文件
               DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements);
               if (dex != null) {
                   elements[elementsPos++] = new Element(dex, null);
               }
               } catch (IOException suppressed) {
  
               }
          }else{
            dex = loadDexFile(file, optimizedDirectory, loader, elements);              
                if (dex == null) {
                    elements[elementsPos++] = new Element(file);
                } else {
                    elements[elementsPos++] = new Element(dex, file);
                }
          }
       }
       ... 
      }
  ```

  根据传入的Dex文件路径转换`Element`数组

- loadDexFile

  ```java
      private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,
                                         Element[] elements)
              throws IOException {
         //优化后Dex文件 存放地址是否为空
          if (optimizedDirectory == null) {
              //为空创建DexFile对象
              return new DexFile(file, loader, elements);
          } else {
              String optimizedPath = optimizedPathFor(file, optimizedDirectory);
            //不为空将优化后的Dex文件存放到指定目录
              return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);
          }
      }
  ```

  此处为了加载Dex文件

- DexFile

  ```java
  public final class DexFile {
       DexFile(File file, ClassLoader loader, DexPathList.Element[] elements)
              throws IOException {
          this(file.getPath(), loader, elements);
      }
    
    ...
          DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) throws IOException {
          mCookie = openDexFile(fileName, null, 0, loader, elements);
          mInternalCookie = mCookie;
          mFileName = fileName;
      }
    ...
          static DexFile loadDex(String sourcePathName, String outputPathName,
          int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException {
          return new DexFile(sourcePathName, outputPathName, flags, loader, elements);
      }
    ...
  }
  ```

  `loadDex`本质也是调用了`new DexFile(...)`去加载Dex文件的。

- openDexFile

  ```java
      private static Object openDexFile(String sourceName, String outputName, int flags,
              ClassLoader loader, DexPathList.Element[] elements) throws IOException {
          // Use absolute paths to enable the use of relative paths when testing on host.
          //加载Dex文件
          return openDexFileNative(new File(sourceName).getAbsolutePath(),
                                   (outputName == null)
                                       ? null
                                       : new File(outputName).getAbsolutePath(),
                                   flags,
                                   loader,
                                   elements);
      }
  ```

  `openDexFile`为了加载Dex文件

- openDexFileNative

  ```c dalvik_system_DexFile.cc
  // art/runtime/native/dalvik_system_DexFile.cc
  static jobject DexFile_openDexFileNative(JNIEnv* env,
                                           jclass,
                                           jstring javaSourceName,
                                           jstring javaOutputName ATTRIBUTE_UNUSED,
                                           jint flags ATTRIBUTE_UNUSED,
                                           jobject class_loader,
                                           jobjectArray dex_elements) {
    ScopedUtfChars sourceName(env, javaSourceName);
    if (sourceName.c_str() == nullptr) {
      return 0;
    }
  
    Runtime* const runtime = Runtime::Current();
    ClassLinker* linker = runtime->GetClassLinker();
    std::vector<std::unique_ptr<const DexFile>> dex_files;
    std::vector<std::string> error_msgs;
    const OatFile* oat_file = nullptr;
  
    dex_files = runtime->GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(),
                                                                 class_loader,
                                                                 dex_elements,
                                                                 /*out*/ &oat_file,
                                                                 /*out*/ &error_msgs);
  
  ...
  
      return nullptr;
    }
  }
  ```

  `openDexFileNative`主要处理dex文件，并生成`odex`到`optimizedDirectory`里

- openDexFilesFromOat

  //TODO 版本差异较大

  ```c
  //art/runtime/oat_file_manager.cc
  
  std::vector<std::unique_ptr<const DexFile>> OatFileManager::OpenDexFilesFromOat(
      const char* dex_location,
      const char* oat_location,
      jobject class_loader,
      jobjectArray dex_elements,
      const OatFile** out_oat_file,
      std::vector<std::string>* error_msgs) {
    
  }
  
  oat_file_manager.cc
    
  oat_file_assistant.cc
  ```



{% fullimage /images/jvm/Dex加载过程.png, Dex加载过程,Dex加载过程 %}



## Dex中的类文件加载

> Dex文件是由多个Class类文件组成，Android加载类需要从Dex中找到对应类进行加载，实际`从DexFile找到Class`

```java
public class BaseDexClassLoader extends ClassLoader {
 ...
   private final DexPathList pathList;
   
     @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // First, check whether the class is present in our shared libraries.
        //加载需要使用的Native库
        if (sharedLibraryLoaders != null) {
            for (ClassLoader loader : sharedLibraryLoaders) {
                try {
                    return loader.loadClass(name);
                } catch (ClassNotFoundException ignored) {
                }
            }
        }
        // Check whether the class in question is present in the dexPath that
        // this classloader operates on.
        List<Throwable> suppressedExceptions = new ArrayList<Throwable>();
        // 找寻Dex中对应class
        Class c = pathList.findClass(name, suppressedExceptions);
        if (c == null) {
            ClassNotFoundException cnfe = new ClassNotFoundException(
                    "Didn't find class \"" + name + "\" on path: " + pathList);
            for (Throwable t : suppressedExceptions) {
                cnfe.addSuppressed(t);
            }
            throw cnfe;
        }
        return c;
    }

}
```

- DexPathList - findClass

  ```java
      public Class<?> findClass(String name, List<Throwable> suppressed) {
          for (Element element : dexElements) {
              Class<?> clazz = element.findClass(name, definingContext, suppressed);
              if (clazz != null) {
                  return clazz;
              }
          }
  
          if (dexElementsSuppressedExceptions != null) {
              suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
          }
          return null;
      }
  ```

  `findClass`为了找到Dex文件中的对应类

  > `dexElements`是由`Dex`文件加载后得到的`DexFile`组装成的`Element`集合形成的。
  >
  > `findClass`实质是去遍历已加载完成的`Dex`文件中的Class，只要找到对应的Class就会结束循环。
  >
  > **当两个相同的类出现在不同的Dex时，系统会优先处理排在前面的Dex文件中的类，后面出现的就不会被加载。**
  >
  > 热修复的核心逻辑：`将需要修复的类所打包的Dex文件插入到dexElements的首位`。

  

- Element - findClass

  ```java
         public Class<?> findClass(String name, ClassLoader definingContext,
                  List<Throwable> suppressed) {
              return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed)
                      : null;
          }
  ```

  

- DexFile - loadClassBinaryName

  ```java
      public Class loadClassBinaryName(String name, ClassLoader loader, List<Throwable> suppressed) {
          return defineClass(name, loader, mCookie, this, suppressed);
      }
  
      private static Class defineClass(String name, ClassLoader loader, Object cookie,
                                       DexFile dexFile, List<Throwable> suppressed) {
          Class result = null;
          try {
              //定义Class
              result = defineClassNative(name, loader, cookie, dexFile);
          } catch (NoClassDefFoundError e) {
              if (suppressed != null) {
                  suppressed.add(e);
              }
          } catch (ClassNotFoundException e) {
              if (suppressed != null) {
                  suppressed.add(e);
              }
          }
          return result;
      }
  ```

  

- Dalvik_system_DexFile.cc - DexFile_defineClassNative

  ```c
  static jclass DexFile_defineClassNative(JNIEnv* env,
                                          jclass,
                                          jstring javaName,
                                          jobject javaLoader,
                                          jobject cookie,
                                          jobject dexFile) {
    std::vector<const DexFile*> dex_files;
    const OatFile* oat_file;
    if (!ConvertJavaArrayToDexFiles(env, cookie, /*out*/ dex_files, /*out*/ oat_file)) {
      VLOG(class_linker) << "Failed to find dex_file";
      DCHECK(env->ExceptionCheck());
      return nullptr;
    }
  
    ScopedUtfChars class_name(env, javaName);
    if (class_name.c_str() == nullptr) {
      VLOG(class_linker) << "Failed to find class_name";
      return nullptr;
    }
    const std::string descriptor(DotToDescriptor(class_name.c_str()));
    const size_t hash(ComputeModifiedUtf8Hash(descriptor.c_str()));
    for (auto& dex_file : dex_files) {
      const DexFile::ClassDef* dex_class_def =
          OatDexFile::FindClassDef(*dex_file, descriptor.c_str(), hash);
      if (dex_class_def != nullptr) {
        ScopedObjectAccess soa(env);
        ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
  			...
          return nullptr;
        }
        //创建目标类对象
        ObjPtr<mirror::Class> result = class_linker->DefineClass(soa.Self(),
                                                                 descriptor.c_str(),
                                                                 hash,
                                                                 class_loader,
                                                                 *dex_file,
                                                                 *dex_class_def);
        // Add the used dex file. This only required for the DexFile.loadClass API since normal
        // class loaders already keep their dex files live.
        class_linker->InsertDexFileInToClassLoader(soa.Decode<mirror::Object>(dexFile),
                                                   class_loader.Get());
        if (result != nullptr) {
          VLOG(class_linker) << "DexFile_defineClassNative returning " << result
                             << " for " << class_name.c_str();
          return soa.AddLocalReference<jclass>(result);
        }
      }
    }
    VLOG(class_linker) << "Failed to find dex_class_def " << class_name.c_str();
    return nullptr;
  }
  ```

- Class_linker.cc  - DefineClass

  ```c
  mirror::Class* ClassLinker::DefineClass(Thread* self,
                                          const char* descriptor,
                                          size_t hash,
                                          Handle<mirror::ClassLoader> class_loader,
                                          const DexFile& dex_file,
                                          const DexFile::ClassDef& dex_class_def) {
    ...
    if (klass == nullptr) {
      //加载类实例
      klass.Assign(AllocClass(self, SizeOfClassWithoutEmbeddedTables(dex_file, dex_class_def)));
    }
    ObjPtr<mirror::DexCache> dex_cache = RegisterDexFile(*new_dex_file, class_loader.Get());
    if (dex_cache == nullptr) {
      self->AssertPendingException();
      return nullptr;
    }
    //设置Dex缓存，后续数据从缓存中读取
    klass->SetDexCache(dex_cache);
    //设置Class信息
    SetupClass(*new_dex_file, *new_class_def, klass, class_loader.Get());
    // 把 Class 插入 ClassLoader 的 class_table 中做一个缓存
    ObjPtr<mirror::Class> existing = InsertClass(descriptor, klass.Get(), hash);
    // 加载类属性
    LoadClass(self, *new_dex_file, *new_class_def, klass);
  
  }
  ```

  每当一个类被加载时，ART运行时都会检查该类所属的Dex文件是否已经关联一个`dex_cache`。

  如果尚未关联，就会创建一个`dex_cache`与Dex文件建立关联，建立关联后，通过调用`RegisterDexFile`注册到aRT运行时中去，后续可以直接使用。

  `dex_cache`用来缓存包含在一个Dex文件里的`类型(Type)、方法(Method)、域(Field)、字符串(String)和静态存储区(Static Storage)`等信息。

  `通过dex_cache间接调用类方法，可以做到延时解析类方法(只有方法第一次调用才会被解析，可以避免解析永远不调用的方法)；一个类方法只会被解析一次，解析的结果存在dex_cache中，下次调用时可以直接从dex_cache进行调用。`



### 加载类成员







## 参考链接

[Android类加载器ClassLoader](http://gityuan.com/2017/03/19/android-classloader/)

[相关源码](cs.android.com)

[谈谈 Android 中的 PathClassLoader 和 DexClassLoader](https://juejin.im/post/5d6a79de5188256c3920b8f7#heading-4)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议相关</title>
    <url>/2020/03/31/TCP-IP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[
# TCP/IP协议

## TCP/IP协议族

> 由一系列网络协议所组成的一个**网络分层**模型，是Internet的核心协议并被广泛应用于局域网和互联网。

### 分层

> 为什么要分层？
>
> - 每层内部的设计可以自由改动，只需要修改替换对应分层即可
> - 设计变得简单，分层只需要考虑当前的任务，不需要在意其他分层情况
> - **网络的不稳定性**

{% fullimage /images/http/TCP分层.png,TCP分层,TCP分层%}

#### 应用层(Application Layer)

> 向用户提供应用服务时通信的活动

相关协议：

- HTTP协议
- FTP协议-文件传输
- DNS协议-域名解析

#### 传输层(Transport Layer)

> 提供处于网络连接中的两台计算机之间的数据传输

相关协议：

- TCP协议
- UDP协议

#### 网络层(Internet Layer)

> 处理网络上流动的数据包，规定如何将数据包传送给对方

相关协议：

- IP协议

#### 数据链路层(Link Layer)

> 处理连接网络的硬件部分，例如网卡、光纤等

#### <u>物理层</u>

> 例如，网线啥的

### 如何通信传输？

{% fullimage /images/http/TCP-IP通信传输.jpg,TCP/IP通信传输,TCP/IP通信传输%}

进行通信时，会按照分层顺序与对方进行通信。*发送端数据从应用层向下走，接收端数据向应用层往上走。*

如上图所示：

- 客户端向服务端发起请求
  - 在应用层(HTTP协议)发送请求数据
  - 传输层(TCP协议)接收到数据，并进行分割打上标记转发给网络层
  - 网络层(IP协议)，增加做为通信目的地的服务器MAC地址转发给链路层
  - 链路层驱动硬件进行传输。
- 服务端接受客户端数据
  - 链路层接收到数据
  - 网络层继续向上转发数据到传输层
  - 传输层向上转发到应用层
  - 应用层接收到数据
  - 一次HTTP请求完成



## TCP协议

<!--TCP三次握手、四次挥手 Tcp和Udp的区别？TCP的三次握手？两次行不行？为什么？TCP攻击知道吗？如何进行攻击？-->

> TCP协议位于传输层，提供可靠的字节流服务
>
> 字节流服务：方便数据的传输，将大块数据分割成`报文段`的数据包进行管理。

{% fullimage /images/http/TCP协议要点.png,TCP协议要点,TCP协议要点%}

### 特点

| 特点       | 具体描述                                                     |
| ---------- | ------------------------------------------------------------ |
| 面向连接   | 使用TCP传输数据前，必须先建立TCP连接；传输完成后在释放连接   |
| 面向字节流 | 虽然应用程序和TCP的交互是一次一个数据块，但TCP只把数据看为一连串无结构的字节流。数据以流的形式传输 |
| 全双工通信 | 建立TCP连接后，通信双方都能发送数据                          |
| 可靠       | TCP首部格式TCP传输的数据：不丢失、无差错、不重复，按序到达   |



### TCP首部格式

{% fullimage /images/http/TCP首部格式结构.png,TCP首部格式结构,TCP首部格式结构%}

{% fullimage /images/http/TCP首部格式.jpg,TCP首部格式结构,TCP首部格式结构%}

- 源端口号

  表示`发送端端口号`，字段长16位

- 目标端口号

  表示`接收端端口号`，字段长16位

- **序列号**

  指的是**本报文段第一个字节的序列号**，长32位。每发送一次数据，就累加一次该数据的字节流大小。

  **序列号不会从0、1开始，而是以一个随机数作为初始值(ISN)，通过SYN包发送给服务端。**

  主要作用如下：

  - 在`SYN`报文中交换彼此的初始序列号(`ISN`)
  - 保证数据报按正确的顺序发送

  **ISN**：随机生成的一个初始值，在三次握手过程中双端互相交换。

  > ISN基本是每4ms加一，溢出则回到0，使猜测ISN过程变得困难。
  >
  > 以上操作是为了**避免被攻击者预测到，防止攻击者伪造`RST`控制位，导致连接被强制关闭。**

- **确认号**

  表示`告知对方下一个期望接收的序列号`，长度为32位。**小于确认号的所有字节已被全部正常接收。**

- 首部长度

  表示`TCP传输的数据部分应该从TCP包的第几位开始计算`，等价于TCP首部的长度。剩下的都为数据长度

- 保留

  该字段是为了以后扩展时使用，长度为4位。

- 控制位/标记位

  用来控制连接的流程

  {% fullimage /images/http/控制位结构.jpg,控制位结构,控制位结构%}

  - CWR：控制拥塞窗口
  - ECE：值为1时，通知通信对方当前网络有拥塞。
  - URG：值为1时，表示包中有需要紧急处理的数据。
  - **ACK**：确认应答的字段变为有效。*TCP规定除了最初建立连接时的SYN包之外该值必须设置为1。*
  - **PSH**：若值为1，告知通信对方收到的数据应该直接上传到上层的应用层；若值为0，不需要立即上传而是先进行缓存。
  - **RST**：值为1，表示TCP连接出现异常必须强制断开连接。
  - **SYN**：用于建立连接，值为1表示希望建立连接，并进行初始序列号(`ISN`)的设置
  - **FIN**：值为1，表示今后不会再有数据发送，希望断开连接。
  
- 窗口大小
  长度为16位，用于`通知从相同TCP首部的确认号所指位置开始能接收的数据大小`。告知对方允许发送的数据量。
  
   > 实际上该大小是不够用的。因此TCP支持`窗口缩放`选项，作为窗口缩放比例因子，范围在`0~14`，可以扩大当前窗口值为2^n。
  
- 校验和
  
  长度为16位，**防止传输过程中数据包有损坏，如果数据不正确，则等待重传。**
  
- 紧急指针
  
  长为16位，只有在`URG`控制位为1时才有效。
  
  表示`本报文段中紧急数据的指针——数据首位到紧急数据指针之间的都是紧急数据。`
  
  一般用于`暂时中断通信`
  
- 可选项
  
  主要用于**提高TCP的传输性能**。
  
  
  
  | 类型 | 长度 | 意义                      | 描述                                                         |
  | ---- | ---- | ------------------------- | ------------------------------------------------------------ |
  | 2    | 4    | Maximum Segment Size(MSS) | TCP允许从对方接收的最大报文段                                |
  | 3    | 3    | WSOPT-Window Scale        | 扩大窗口，可提高吞吐量                                       |
  | 5    | N    | SACK                      | 选择确认选项<br/>可以允许最大四次的方式确认应答，在数据时不时丢失的情况下，避免无用重发并提高重发速度。 |
  | 8    | 10   | TSOPT-Time Stamp Option   | 用于高速通信中对序列号的管理，可以区分新老序列号。           |
  
  `TSOPT-Time Stamp Option`：记录序列号发送时的内核时间在报文中。
  
  > 格式：kind(1字节)+length(1字节)+info(8字节)
  >
  > 按照上表来看，`kind`为8，`length`为10，info包含`timestamp`和`timestamp echo`。
  
  可以解决以下两大问题：
  
  1. 计算往返时延(RTT)
  
     - 客户端向服务端发送数据时，`timestamp`存储当前内核时间`ta1`
     - 服务端回复客户端时，`timestamp`存放服务端内核时间`tb`
     - 客户端收到数据时，可以解析得到`timestamp`为客户端内核时间`ta2`，在解析`timestamp echo`得到第一次发送时的内核时间`ta1`，然后`ta2-ta1`就是`RTT`。
  
  2. 防止序列号的回绕问题
  
     在传输不稳定的网络情况下，有可能会在较晚的时间内收到较早时发送的一个数据报，由于记录了`timestamp`那么可以比较`timestamp`来判断是否同一个数据报。

### *TCP连接建立——三次握手

{% fullimage /images/http/TCP建立连接-三次握手.png,TCP三次握手过程,TCP三次握手过程%}

#### 过程

{% fullimage /images/TCP三次握手过程.webp,TCP三次握手过程,TCP三次握手过程%}

- 初始时，客户端与服务端都处于`CLOSED`状态，服务端为了提供服务，主动监听端口，然后进入`LISTEN`状态
- 客户端主动发起连接(发起`SYN`包)，进入`SYN-SENT`状态。——*第一次握手*
- 服务端收到`SYN`包后，回复`SYN、ACK`包，然后服务端进入`SYN-RCVD`状态——*第二次握手*
- 客户端收到服务端发来的`SYN、ACK`包后，确认服务端通信建立，在回复`ACK`包，并进入`ESTABLISHED`状态；服务端接收到`ACK`之后，也变成了`ESTABLISHED`状态。——*第三次握手*

**此时，双方进入了正常的数据传输过程。**

> - SYN：sunchronize，该包需要对端的确认
> - ACK：acknowldgement

**前两次握手过程中不能携带数据，第三次握手时可以携带数据。**若有人在第一次发送的`SYN`包时注入大量数据，势必导致服务端要耗费更多的资源进行数据处理，降低了服务器的性能。

#### 拓展

##### 为什么不能两次握手？

根本原因：**无法确认客户端的接收能力。**

当客户端发送`SYN`后想进行第一次握手，但是由于网络原因导致该`SYN`包滞留而没有发送到服务端。此时触发**超时重传**机制，于是客户端会重新发出`SYN`包，由于是两次握手，客户端与服务端建好了连接。

但是过一段时间后，连接已经被关闭，这时上面被滞留的`SYN`包就可能会发送到服务端，此时服务端继续发送`SYN、ACK`包与客户端建立了连接。导致了**连接资源的浪费**。

##### TCP攻击

利用TCP的三次握手机制，模拟多个客户端对服务端发起连接请求(发送`SYN`包)，但是不处理服务端所返回的`SYN、ACK`包，导致服务端一直处于一种**半连接**状态，大量消耗服务器资源，导致死机。

*即使配置了超时重试功能，也会因为数量过大，导致无限等待。*

这个就叫做`SYN FLOOD攻击`，如何去应对上述攻击：

- 增加`SYN`连接数，想办法增加`半连接队列`的容量
- 减少`SYN+ACK`重试次数，避免堆积大量的`超时重发`任务
- 也可以利用`SYN Cookie`技术，服务端收到`SYN`包后不先去分配资源，而是根据`SYN`包计算出一个`SYN Cookie`，在第二次握手时回复给客户端进行保存，这样在客户端回复`ACK`时带上`SYN Cookie`，服务端验证合法后就可以分配资源。

##### 半连接/全连接队列

**半连接队列**：客户端发送`SYN包`到服务端后，服务端会回复`ACK、SYN`，并且切换状态至`SYN-RECV`，该连接就会进入`半连接队列`。

**全连接队列**：客户端接收到服务端的`ACK、SYN`包后，三次握手即完成。这时，该连接就会加入至`全连接队列`。



### *TCP连接关闭——四次挥手

TCP断开连接——四次挥手

{% fullimage /images/http/TCP断开连接-四次挥手.png,TCP四次挥手过程,TCP四次挥手过程%}

#### 过程

{% fullimage /images/TCP四次挥手过程.webp,TCP四次挥手过程,TCP四次挥手过程%}

- 初始时，客户端与服务端都处于`ESTABLISHED`状态并双向传输数据
- 客户端准备断开连接，然后发出`FIN`包并且指定一个`seq序列号`，发出后客户端进入`FIN-WAIT-1`状态——*第一次挥手*
- 服务端收到`FIN`包后，回复`ACK`到客户端，并进入`CLOSE-WAIT`状态；客户端在收到服务端的`ACK`包后，也进入`FIN-WAIT-2`状态，等待服务端的最终释放连接报文(`FIN`)——*第二次挥手*
- 服务端此时也要准备断开连接，发送`FIN、ACK`包到客户端，表示自己准备断开连接，然后进入`LAST-ACK`状态——*第三次挥手*
- 客户端收到`FIN、ACK`消息后，会回复`ACK`包到服务端，并进入`TIME-WAIT`状态。**出于稳定和安全性考虑，客户端会等待`2MSL`的时长，然后进入`CLOSED`状态。**服务端在收到客户端的`ACK`包后，也进入`CLOSED`状态。——*第四次挥手*

**此时，双方都进入`CLOSED`状态，表明正式断开了连接。**

> - FIN：连接释放报文段
>
> - MSL：最长报文段寿命，表示**任何报文段在网络上的最长存活时间，超过这个时间的报文都将被丢弃。**
>
>   协议规定`MSL`为2分钟，常用的多是`30s、1min、2min`

#### 拓展

##### 为什么要四次挥手？

当关闭连接时，客户端发送`FIN`报文到服务端，服务端先返回一个`ACK`报文到客户端，但是不会关闭掉当前的连接，这也导致会出现第三次挥手的情况，必须等到服务端任务处理完毕，才能发送`FIN`报文到客户端，通知客户端准备关闭。

如果服务端直接发送`FIN、ACK`包，如果此时网络出现延迟就会导致客户端触发`超时重传`一直发送`FIN`包，浪费连接资源。

##### 为什么需要等待`2MSL`时间在关闭？

- 首先，客户端如果不等待`2MSL`而是直接关闭，就会导致服务端后续发送的包无法被接收，并且客户端端口已被其他使用，就会产生无用数据，导致数据包混乱
- 用一个`MSL`保证四次挥手中主动关闭方最后的`ACK`报文可以到达对方，上面示例表示的就是`客户端发出的ACK包可以被服务端接收`
- 另一个`MSL`可以保证**已失效的连接请求报文段**不会出现在连接中，避免下一个新的连接出现旧的连接请求报文。

### TCP状态机

> 将连接建立和断开的两个时序状态图结合起来，就是`TCP状态机`。

{% fullimage /images/http/TCP状态机.webp,TCP状态机,TCP状态机%}



### TCP快速打开——TCP Fast Open

{% fullimage /images/http/TCP快速打开-TFO.png,TCP快速打开,TCP快速打开%}

> TCP快速打开为了优化后续的TCP握手流程，快速建立连接。——TFO
>
> 主要利用的原理就是**SYN Cookie**

在第一次建立连接时，服务端会计算得出一个`SYN Cookie`，然后放置于`SYN、ACK`数据包中的`FAST OPEN`选项返回给客户端，客户端收到`SYN、ACK`数据包时，解析`FAST_OPEN`选项，缓存其中的Cookie。

在后续建立连接的过程中，客户端会直接发送`SYN包、HTTP请求以及SYN Cookie`到服务端，只要服务端验证`SYN Cookie`通过，就会返回`SYN、ACK`包以及`HTTP请求的响应数据`。

{% fullimage /images/http/TCP快速打开流程.jpg,TCP快速打开流程,TCP快速打开流程%}



### *可靠性保证

> 无论对方以多快的的速度发送数据，接收方总来得及处理收到的数据

{% fullimage /images/http/TCP可靠性保证.png,TCP可靠性保证,TCP可靠性保证%}

#### 核心思想

- **出错重传**：出现错误时，让发送方重新发送数据
- **速度匹配**：当接收方来不及处理接收的数据时，通知发送方降低数据传输速率。



#### 流量控制

> 接收方根据自己接收缓存的大小，动态调整发送窗口的大小，从而控制对方的发送速率。

##### 滑动窗口协议

> **传输层进行流量控制**的一种措施，接收方通过告知发送方自己的窗口大小，从而控制对方的发送速率，达到防止对方数据发送过快导致自己处理不完的问题。

滑动窗口分为以下两部分

- 发送窗口

  > 任意时刻，发送方维持的一组连续的，允许发送帧的帧序号。

  {% fullimage /images/滑动窗口协议-发送窗口.png,滑动窗口协议-发送窗口,滑动窗口协议-发送窗口%}

  其中黑框部分就是**发送窗口**。是由下面的`已经发送但没有收到确认帧`和`未发送但可以发送数据`这两部分组成。

  <br/>

  **发送窗口**包含以下四大部分：

  - 已经发送并收到确认帧(`Sent and Acknowledged`)
  - **已经发送但没收到确认帧**(`Sent but not yet Acknowledged`)
  - **未发送但可以发送(`Not sent Recipient Ready to Receive`)**
  - 未发送且不能发送(`Not send and not ready to receive`)

  <br/>

  每收到一个接收方返回的确认帧，发送窗口就向前移动一帧。当`发送窗口`里都为`已经发送但没收到确认帧`，那么`发送窗口`停止发送数据，直到收到接收方发出的确认帧则继续向后移动，直到发送窗口内无数据可以发送。

  

- 接收窗口

  > 任意时刻，接收方维持的一组连续的，允许接收帧的帧序号。

  {% fullimage /images/滑动窗口协议-接收窗口.png,滑动窗口协议-接收窗口,滑动窗口协议-接收窗口%}

  其中黑框部分就是**接收窗口**。是由下面的`未接受准备接收数据帧`组成。

  **接收窗口**包含以下三大部分：

  - 已接收数据帧
  - **未接收但准备接收数据帧**
  - 未接收且未准备接收数据帧

  <br/>

  每收到一个发送方发送的数据帧，接收窗口就向前移动一帧，并返回确认帧到发送端。

  若收到的数据帧不在接收窗口内，则丢弃该数据帧。



##### 流量控制过程

- 接收端向发送端通知自己可以接收的数据的大小`a`
- 发送端就会发送不超过`a`大小的数据
- 后续，接收端缓冲区面临溢出时，又会通知一个更小的窗口值`b`到发送端
- 发送端收到通知后再发送不超过`b`大小的数据

{% fullimage /images/http/流量控制过程.jpg,流量控制过程,流量控制过程%}



##### 可能出现的问题

若接收端发给发送端的`窗口调整通知`中途丢失的话，可能会导致无法继续通信，甚至出现**死锁问题**(由于发送方一直等待接收方的窗口通知，然后接收方一直等到发送方的数据)。

解决方案：

TCP为每一个连接设计持续计时器，只要TCP发送方收到`零窗口通知`，就启动该计时器。若计时器结束，则会发出一个`零窗口探测`的数据报，等待对方给出`窗口大小`。为0则重新设置计时器，不为0则打破死锁状态。

> 死锁的形成条件：
>
> - 互斥条件：一个资源每次只能被一个进程使用
> - 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放
> - 不可强行占有：进程已获得的资源，未使用完之前不能强行剥夺
> - 循环等待：若干进程形成一种头尾相接的循环等待资源关系。

#### 拥塞控制

> 防止过多的数据注入到网络中，使得网络中的路由器和链路不至于过载。

##### 拥塞窗口(cwrd)

> 指目前自己还能传输的数据量大小

`接收窗口`与`拥塞窗口`都是接收端上的概念，两者计算后可以得出`发送窗口`的大小。

```
发送窗口大小 = min(接收窗口大小，拥塞窗口大小)
```



##### 慢启动

> 当主机开始发送数据时，由小到大逐渐增加**拥塞窗口(发送窗口)数值**，从而由小到大逐渐增大发送报文段。

得到的是**慢启动阈值(ssthresh)**，当发送窗口到达这个阈值时，就先暂停一下发送。

##### 拥塞避免

> 当发送窗口到达**慢启动阈值**时，使得`拥塞窗口`大小按规律线性增长。每经过一轮`RTT(往返时延)`，拥塞窗口大小+1。



##### 快速重传

TCP传输的过程中，如果发生了丢包——接收端发现数据端不是按序到达，那么就需要发送端重新发送丢失的数据。

例如发送了`4 5 6 7`四个数据报到接收端，但是接收端没有收到`5`，通常的情况下需要发送端等待一个`RTO(超时重传时间)`然后重新发送`4 5 6 7`数据报。

>  当发送方至少收到3个重复的ACK时，意识到丢包了，就会立即重新重传对方尚未收到的报文段，而不用等待一个`RTO`。

###### 选择性重传

> 当接收端已经收到了部分数据时，回复发送端`ACK`报文时，可以设置`可选项(Option)`，加上`SACK`熟悉，通过`left edge`、`right edge`告知发送端已接收的数据范围。
>
> 然后发送端就会发送不在该范围内的数据给接收端，减少数据量。

##### 快速恢复

> 当发送端接收到三次重复ACK之后，就会发现传输过程中出现了数据丢失，就会进入`快速恢复`阶段。

- cwnd大小缩小为当前的一半
- `ssthresh`设置为缩小后的`cwnd`大小
- cwnd大小线性增加



### 提高网络利用率

{% fullimage /images/http/TCP提高利用率.png,TCP提高利用率,TCP提高利用率%}

#### Nagle算法

> 发送端即使还有应该发送的数据，但如果这部分的数据还很少的话，则进行延迟发送。
>
> **主要为了避免小包的频繁发送。**

立即发送条件

- 已发送的数据都已经收到确认应答时
- 数据包发送的大小达到`MSS（最大报文长度）`时

可能的问题

可能产生某种程度的延迟。可以通过设置`TCP_NODELAY`关闭该算法。

#### 延迟确认

> 接收端收到数据以后并不立即返回确认应答(`ACK`)，而是等待一定时间内合并多个`ACK`在回复给发送端。

*TCP要求这个时延必须小于**500ms**(可能导致发送端重新发送数据)，一般操作系统不会设置超过**200ms***。

立即回复条件

- 需要调整发送窗口大小
- TCP处于`quickack`模式，通过`tcp_in_quickack_mode`开启
- 发现了乱序包

## UDP协议

{% fullimage /images/http/UDP协议.png,UDP协议,UDP协议%}

> UDP协议位于传输层，但不保证可靠性。

### 特点

| UDP特点    | 具体描述                                                 |
| ---------- | -------------------------------------------------------- |
| 无连接     | 使用UDP传输数据，不需要建立连接                          |
| 不可靠     | UDP的数据包发送后，不管其是否会到达接收方                |
| 面向报文   | 数据 以**数据报文(包)**的形式传输                        |
| 无拥塞控制 | 由于是不可靠传输，不管是否到达接收方，所以不需要拥塞控制 |

### UDP首部格式

{% fullimage /images/http/UDP首部格式.jpg,UDP首部格式,UDP首部格式%}

- 源端口号

  表示`发送端端口号`，长`16位`。

  可以不设置该端口号，默认为`0`，表示单方面发送消息，不需要接受端的返回信息。

- 目标端口号

  表示`接收端端口号`，长`16位`。

- UDP包长度

  保存了`UDP首部的长度和数据的长度之和`。

- UDP校验和

  为了提供可靠的`UDP首部和数据而设计`。检测用户数据报在传输过程中是否有错。

### TCP、UDP的区别

- TCP是`面向连接`的，UDP是面向无连接的

  **所谓连接，是为了在客户端和服务端之间建立连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。**

- TCP`提供可靠交付`，通过`TCP`传输的数据，**不丢失、无差错、不重复，按序到达**。而UDP继承了IP包的特性，不保证不丢失，不保证按序到达。

- TCP是`面向字节流`的，把每个数据块看为`一串无结构的字节流`，方便进行维护；而UDP继承IP包特性，基于`数据报`的，一个个的向外发或者接收。

- TCP是有`拥塞控制`的，意识到丢包或者网络环境不好时，会调整自己的行为，调整发包频率；UDP只要有包就会发送，无论是否到达接收方。

- TCP是`有状态`的服务，会记录当前状态，例如包是否发送，该发送哪个；UDP是无状态的，不会记录下来

### 适用场景

1. 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用
2. 不需要一对一沟通，建立连接，而是可以广播的应用
3. 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络堵塞，也不能受到影响。

例如：`流媒体的协议(视频播放)`、`实时游戏`、`IoT物联网`、`移动通信领域(语言、视频通话)`。

### QUIC协议

> Google提出的一种基于UDP改进的通信协议，目的是**降低网络通信的延迟，提供更好的用户体验**。该协议位于`应用层`上。

- 自定义连接机制
- 自定义重传机制
- 无阻塞的多路复用
- 自定义流量控制

## 参考内容

[图解TCP/IP]()

[TCP快速打开](https://zh.wikipedia.org/wiki/TCP快速打开)

[QUIC 协议原理分析](https://cloud.tencent.com/developer/article/1017235)





]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化-内存优化详解</title>
    <url>/2020/03/23/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[
# Android内存优化

## 内存的概念

内存是计算机中最重要的部件之一，是硬盘与CPU之间沟通的桥梁，所有程序都是运行其上，会对程序的性能造成很大的影响。

## 内存管理机制

### 系统层面

<!--进程优先级-->

`LowMemoryKiller`

### 进程层面

GC

## 优化目标

### 内存泄漏

<!--分析流程-->

### 图片加载

### 内存抖动

### 内存溢出

### 其他问题



## 优化工具



## 优化技巧





## 参考链接

[内存管理概览](https://developer.android.com/topic/performance/memory-overview)

[探索Android内存优化方法](https://mp.weixin.qq.com/s/EerrwaRGdTkOFPLrg8_-oQ)

[探索Android内存优化](https://juejin.im/post/5e780257f265da575209652c#heading-6)

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--ConcurrentHashMap原理及解析</title>
    <url>/2019/01/16/Java-ConcurrentHashMap%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[
<!--主要是对HashMap，ArrayMap，ConcurrentHashmap-->

<!-- HashMap和HashTable的区别 , HashMap和ConcurrentHashMap的区别，HashMap的底层源码,HashMap的原理,ConcurrentHashMap，ArrayMap,SparseArray,hashmap线程不安全，请问为什么线程不安全？答，并发时会成环。什么时候成环？比如我有两个数据要装入hashmap。hashset和hashmap的区别，写代码使用hashmap实现一个简单的hashset。-->

<!-- https://juejin.im/post/59e86f9351882521ad0f4147, https://juejin.im/post/5a7592f4f265da4e8d42ded2 -->

<!-- hashmap实现的数据结构，数组、桶等。hashmap的哈希冲突解决方法：拉链法等。拉链法的优缺点。hashmap的参数及影响性能的关键参数：加载因子和初始容量。Resize操作的过程。hashmap容量为2次幂的原因。hashtable线程安全、synchronized加锁。hashtable和hashmap异同。为什么hashtable被弃用？-->

<!--关于HashMap扩容，1.8之前，如果不发生Hash冲突不会触发扩容，1.8之后，只要HashMap中的元素个数大于阈值，就发生扩容。（欢迎纠正）expectedSize / 0.75F + 1.0F  equals 和 hashcode 关系,HashMap遍历原理-->

{% fullimage /images/ConcurrentHashMap结构.png,ConcurrentHashMap结构,ConcurrentHashMap结构%}

> HashMap本身不是线程安全的，通常在多线程情况下可以去使用`HashTable`替代`HashMap`使用，该类中基本所有的操作方法都采用`synchronized`进行修饰，所以在高并发的情况下，每次只能有一个线程获取`对象监视器锁`，并发性能太低。
>
> 针对上述情况，就产生了`ConcurrentHashMap`这个类去解决上述问题，提高效率。

## ConcurrentHashMap重要参数分析

`table`：默认为`null`，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方

```java
transient volatile Node<K,V>[] table;
```



<br>

`nextTable`：默认为null，扩容时使用，大小为原数组的2倍。

```java
private transient volatile Node<K,V>[] nextTable;
```

<br>

`sizeCtl`：该属性用来控制`table`的初始化和扩容操作。

- **-1**：表示当前数组正在初始化
- **-N**：表示当前争优`N-1`个线程进行扩容操作
- **0**：数组还未初始化
- **N**：1. table未初始化，表示table需要初始化的大小；2. table初始化完成，表示扩容阈值。**源码观察可知该值始终是 table容量的0.75倍**。

```java
volatile int sizeCtl;

// sizeCtl = n - (n>>>2)
```

<br>

`sun.misc.Unsage U`：利用该类实现`CAS算法`，实现一种乐观锁的操作。

<br>

`Node`：主要存放 key-value对，并且具有next域。可以保存`key、value、hash值`的数据结构。

```java
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        //使用 volatile进行修饰 保证可见性
        volatile V val;
        volatile Node<K,V> next;
     ... 
    }
```

<br>

`ForwardingNode`：一个特殊的节点，`key、value、hash值`均为`null`，存储着对`nextTable`的引用

```java
    static final class ForwardingNode<K,V> extends Node<K,V> {
        final Node<K,V>[] nextTable;
        ForwardingNode(Node<K,V>[] tab) {
            super(MOVED, null, null, null);
            this.nextTable = tab;
        }
      ...
    }
```

只有table发生扩容的时候，`ForwardingNode`才有作用，作为一个占位符放在`table`中表示当前节点为`null`或者已经被移动。

<br>

## ConcurrentMap源码解析

### ConcurrentHashMap初始化

```java
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentMap<K,V>, Serializable {
    //构造一个空的map ，初始容量为默认值 16
    public ConcurrentHashMap() {
    
    }
    //设定map的初始容量
    public ConcurrentHashMap(int initialCapacity) {
        //小于0 直接抛出异常
        if (initialCapacity < 0)
            throw new IllegalArgumentException();
        //计算过程类比于 1.5 * initialCapacity + 1
        int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
                   MAXIMUM_CAPACITY :
                   tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
        //计算出的最终容量进行赋值
        this.sizeCtl = cap;
    }
    //插入一个map
    public ConcurrentHashMap(Map<? extends K, ? extends V> m) {
        this.sizeCtl = DEFAULT_CAPACITY;
        putAll(m);
    }    
    //设定map的初始容量及加载因子
    public ConcurrentHashMap(int initialCapacity, float loadFactor) {
        this(initialCapacity, loadFactor, 1);
    }        
    //设定map的初始容量，加载因子以及并发度 - 预计同事可操作数据的线程数
    public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();
        //容量会根据并发度进行调整
        if (initialCapacity < concurrencyLevel)   // Use at least as many bins
            initialCapacity = concurrencyLevel;   // as estimated threads
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
        int cap = (size >= (long)MAXIMUM_CAPACITY) ?
            MAXIMUM_CAPACITY : tableSizeFor((int)size);
        this.sizeCtl = cap;
    }
    
    /**
    * 对传入的初始容量进行操作，向上取整 得到最接近初始值的 符合2的幂次
    */
    private static final int tableSizeFor(int c) {
        int n = c - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
  ...    
}
```

此时ConcurrentHashMap的初始化只是初始化了 table的容量，还未直接初始化`table`。需要等到第一次调用`put()`后执行。

### ConcurrentHashMap插入数据 - put()

> 向ConcurrentHashMap中插入数据

```java
ConcurrentHashMap concurrentHashMap = new ConcurrentHashMap();
concurrentHashMap.put("Android","best");
```

> `put()`源码

```java
    public V put(K key, V value) {
        return putVal(key, value, false);
    }

    final V putVal(K key, V value, boolean onlyIfAbsent) {
        //如果key或者value为null 直接抛出异常
        if (key == null || value == null) throw new NullPointerException();
        //计算出key对应的hash值
        int hash = spread(key.hashCode());①
        int binCount = 0;
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            //当前table没有初始化
            if (tab == null || (n = tab.length) == 0)
                //table开始初始化
                tab = initTable();②
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {③
                //利用CAS方式 直接插入值
                if (casTabAt(tab, i, null,new Node<K,V>(hash, key, value, null)))④
                    break;                   // no lock when adding to empty bin
            }
            //表示当前正在扩容
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);⑤
            else {
                V oldVal = null;
                //获取头节点的监视器锁
                synchronized (f) {
                    //在节点插入之前，在进行判断，防止被其他线程修改
                    if (tabAt(tab, i) == f) {
                        //当前为链表，在链表中插入新的键值对
                        if (fh >= 0) {
                            //记录链表长度
                            binCount = 1;
                            //开始遍历链表
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                //如果找到了相等的key
                                if (e.hash == hash &&((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    //直接覆盖旧值
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)                         
                                        e.val = value;
                                    break;
                                }
                                //到了链表末端，直接数据插到链表末端
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key, value, null);
                                    break;
                                }
                            }
                        }
                        //当前数据结构为 红黑树
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                //插入数据后再根据实际大小判断是否需要转换成红黑树
                if (binCount != 0) {
                    if (binCount >= TREEIFY_THRESHOLD)
                        //这个方法中不一定会进行红黑树的变换，如果当前数据的长度小于64 (MIN_TREEIFY_CAPACITY)
                        //就会执行扩容操作，而不是进行红黑树转化。
                        treeifyBin(tab, i);⑥
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        //对当前数组容量进行检查，超过了临界值，就需要扩容
        addCount(1L, binCount);⑦
        return null;
    }
```

`put()`操作主要包括以下几项：

①` int hash = spread(key.hashCode());`：计算Hash值

```java
    static final int spread(int h) {
        return (h ^ (h >>> 16)) & HASH_BITS;
    }
```

②`tab = initTable();`：如果table尚未初始化，就需要进行初始化操作

```java
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        // 当一个线程发现sizeCtl<0即正在初始化时，意味着另外的线程正在执行初始化操作，其他线程只能让出CPU等待table初始化完成
        if ((sc = sizeCtl) < 0)
            Thread.yield();
        // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁 
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    // DEFAULT_CAPACITY 默认初始容量是 16
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    // 初始化数组，长度为 16 或初始化时提供的长度
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    // 将这个数组赋值给 table，table 是 volatile 的
                    table = tab = nt;
                    // 如果 n 为 16 的话，那么这里 sc = 12
                    // 其实就是 0.75 * n
                    sc = n - (n >>> 2);
                }
            } finally {
                // 设置 sizeCtl 为 sc
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
```

*table初始化的操作有且只有一个线程能够操作，其他线程通过`Thread.yield()`让出CPU时间片等待初始化完成。*

③`f = tabAt(tab, i = (n - 1) & hash))`：获取hash值转换后得到的存储位置的头节点`f`。*无论链表头节点还是红黑树的根节点都是在数组上的。*

```java
    static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {
        return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);
    }
```

在`JMM`中，每个线程都有他自己的工作内存，里面存储着数据的副本，虽然`table`是`volatile`修饰的，但不能绝对保证拿到的就是最新的数据，利用`U.getObjectVolatile`是直接取得指定内存的数据，可以保证每次拿到的都是最新的。

④`casTabAt(tab, i, null,new Node<K,V>(hash, key, value, null))`：由于发现存储位置上没有元素，则利用CAS直接插入新节点

```java
    static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,Node<K,V> c, Node<K,V> v) {
        return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);
    }
```

利用`CAS操作`直接将节点放入table对应位置中。但是如果CAS插入失败，意味着是一个并发操作，直接向下继续执行。

⑤`helpTransfer()`：帮助数据迁移

```java
    final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
        Node<K,V>[] nextTab; int sc;
        if (tab != null && (f instanceof ForwardingNode) &&
            (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {
            int rs = resizeStamp(tab.length);
            while (nextTab == nextTable && table == tab &&
                   (sc = sizeCtl) < 0) {
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || transferIndex <= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                    transfer(tab, nextTab);
                    break;
                }
            }
            return nextTab;
        }
        return table;
    }
```

⑥`treeifyBin()`：当完成数据新节点插入后，会进一步对当前链表大小进行调整。当链表长度大于`TREEIFY_THRESHOLD`阈值，默认8，会进行链表转换红黑树，也可能是仅仅做数组扩容。

```java
private final void treeifyBin(Node<K,V>[] tab, int index) {
    Node<K,V> b; int n, sc;
    if (tab != null) {
        // MIN_TREEIFY_CAPACITY 为 64
        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容
        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)
            //扩容
            tryPresize(n << 1);
        // b 是头结点
        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {
            // 加锁
            synchronized (b) {

                if (tabAt(tab, index) == b) {
                    // 下面就是遍历链表，建立一颗红黑树
                    TreeNode<K,V> hd = null, tl = null;
                    for (Node<K,V> e = b; e != null; e = e.next) {
                       //链表节点转换树节点
                        TreeNode<K,V> p = new TreeNode<K,V>(e.hash, e.key, e.val, null, null);
                        if ((p.prev = tl) == null)
                            hd = p;
                        else
                            tl.next = p;
                        tl = p;
                    }
                    // 将红黑树设置到数组相应位置中
                    setTabAt(tab, index, new TreeBin<K,V>(hd));
                }
            }
        }
    }
}
```

⑦`addCount(1L, binCount)`：table存储键值对数量增加，然后需要判断是否超过扩容阈值，若超过需要进行扩容操作。

```java
private final void addCount(long x, int check) {
        CounterCell[] as; long b, s;
        if ((as = counterCells) != null ||
            !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
            CounterCell a; long v; int m;
            boolean uncontended = true;
            if (as == null || (m = as.length - 1) < 0 ||
                (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
                !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
                fullAddCount(x, uncontended);
                return;
            }
            if (check <= 1)
                return;
            s = sumCount();
        }
        if (check >= 0) {
            Node<K,V>[] tab, nt; int n, sc;
            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
                   (n = tab.length) < MAXIMUM_CAPACITY) {
                int rs = resizeStamp(n);
                if (sc < 0) {
                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                        transferIndex <= 0)
                        break;
                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                        transfer(tab, nt);
                }
                else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                             (rs << RESIZE_STAMP_SHIFT) + 2))
                    transfer(tab, null);
                s = sumCount();
            }
        }
    }
```

### ConcurrentHashMap扩容操作 - tryPresize()

> 由上述源码可知，触发扩容动作的情况有两个：
>
> 1. 新增节点后，链表长度达到了8，就会调用`treeifyBin()`对其进行转换，但是如果此时存储的键值对数量如果未到64(`最小树形化阈值`)，就会触发`tryPresize()`扩大数组长度至原来的两倍，并调用`transfer()`进行数据迁移。
> 2. 新增节点后，会调用`addCount()`使存储数量 +1 ，还会去检测是否达到扩容阈值，达到时会触发`transfer()`，重新调整节点的位置。

```java
private final void tryPresize(int size) {
    // c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。
    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
        tableSizeFor(size + (size >>> 1) + 1);
    int sc;
    //跳出循环的判断 需要依赖 transfer的操作结束
    while ((sc = sizeCtl) >= 0) {
        Node<K,V>[] tab = table; int n;

        // 初始化数组
        if (tab == null || (n = tab.length) == 0) {
            n = (sc > c) ? sc : c; //取大值
            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if (table == tab) {
                        @SuppressWarnings("unchecked")
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        table = nt;
                        sc = n - (n >>> 2); // 0.75 * n
                    }
                } finally {
                    sizeCtl = sc;
                }
            }
        }
        //已经超过最大上限 就不需要扩容了
        else if (c <= sc || n >= MAXIMUM_CAPACITY)
            break;
        else if (tab == table) {
            int rs = resizeStamp(n);

            if (sc < 0) {
                Node<K,V>[] nt;
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex <= 0)
                    break;
                // 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法
                //    此时 nextTab 不为 null
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
            // 1. 将 sizeCtl 设置为 (rs << RESIZE_STAMP_SHIFT) + 2)
            //  调用 transfer 方法，此时 nextTab 参数为 null
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs << RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
        }
    }
}
```



#### ConcurrentHashMap迁移数据 - transfer() **重要**

> 将原来旧表的数据迁移至新表中。

迁移过程涉及并发操作。原数组长度为n，所以会出现n个迁移任务，让每个线程单独去负责每一个迁移任务，每做完一个任务在检测是否有其他没做完的任务。

`transfer()`中利用了一个`stride(步长)`，每个线程负责迁移一部分。

再调用到`transfer()`的函数中观察到`transfer(tab, null)`在一次调用过程中只会存在一次，然后其他调用的时候`nextTable`已经初始化完毕，就不会在调用到空。

```java
 private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
        int n = tab.length, stride;
        //设置任务执行区域 NCPU代指CPU核数
        if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
            stride = MIN_TRANSFER_STRIDEC;  //最小长度为 16
        //先进行一次 nextTable初始化 
        //这个过程只会发生一次
        if (nextTab == null) {            
            try {
                @SuppressWarnings("unchecked")
                //容量翻倍
                Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];
                //进行赋值 即 nextTable长度为旧表的两倍
                nextTab = nt;
            } catch (Throwable ex) {      // try to cope with OOME
                sizeCtl = Integer.MAX_VALUE;
                return;
            }
            nextTable = nextTab;
            //用于控制迁移的位置
            transferIndex = n;
        }
        
        int nextn = nextTab.length;
        //初始化 ForwardNode 代表正在被迁移的Node hash值 = MOVED
        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);
        //表明该位置的迁移工作已经完成
        boolean advance = true;
        //所有迁移工作中是否完成
        boolean finishing = false; // to ensure sweep before committing nextTab
        // i 代表当前处理的槽位序号  bound 代表要处理的槽位边界 是从后向前的循环方式
        for (int i = 0, bound = 0;;) {
            Node<K,V> f; int fh;
            while (advance) {
                int nextIndex, nextBound;
                if (--i >= bound || finishing)
                    advance = false;
                //表明原数组的所有位置都有相应的线程进行处理
                else if ((nextIndex = transferIndex) <= 0) {
                    i = -1;
                    advance = false;
                }
                else if (U.compareAndSwapInt
                         (this, TRANSFERINDEX, nextIndex,
                          nextBound = (nextIndex > stride ?
                                       nextIndex - stride : 0))) {
                    //nextBound代表这次迁移任务的边界，当为0时，代表已经在处理了
                    bound = nextBound;
                    i = nextIndex - 1;
                    advance = false;
                }
            }
            //表明迁移任务已经结束
            if (i < 0 || i >= n || i + n >= nextn) {
                int sc;
                // 表明迁移任务结束
                if (finishing) {
                    nextTable = null;
                    table = nextTab;
                    //重新调整 sizeCtl 为新数组长度 0.75倍
                    sizeCtl = (n << 1) - (n >>> 1);
                    return;
                }
                // 迁移任务开始前 sizeCtl 会被设置为 rs << RESIZE_STAMP_SHIFT) + 2
                // 每有一个线程参与迁移任务 sizeCtl + 1
                // CAS对其进行 -1操作
                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)
                        return;
                    //当sizeCtl 与初始值相同时 意味着所有的迁移已经完毕
                    finishing = advance = true;
                    i = n; // recheck before commit
                }
            }
            //位置 i 没有元素存在，那么直接放入初始化好的 ForwardingNode , 然后告知其他线程该位置已经迁移完毕
            else if ((f = tabAt(tab, i)) == null)
                advance = casTabAt(tab, i, null, fwd);
            //位置 i 上是 ForwardingNode 代表该位置已经迁移完毕
            else if ((fh = f.hash) == MOVED)
                advance = true; // already processed
            else {
                //需要对该位置节点操作加锁
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        Node<K,V> ln, hn;
                        //代表当前结构是链表结构
                        if (fh >= 0) {
                            //将该位置的链表一分为二 按照
                            int runBit = fh & n;
                            Node<K,V> lastRun = f;
                            for (Node<K,V> p = f.next; p != null; p = p.next) {
                                int b = p.hash & n;
                                if (b != runBit) {
                                    runBit = b;
                                    lastRun = p;
                                }
                            }
                            if (runBit == 0) {
                                ln = lastRun;
                                hn = null;
                            }
                            else {
                                hn = lastRun;
                                ln = null;
                            }
                            for (Node<K,V> p = f; p != lastRun; p = p.next) {
                                int ph = p.hash; K pk = p.key; V pv = p.val;
                                if ((ph & n) == 0)
                                    ln = new Node<K,V>(ph, pk, pv, ln);
                                else
                                    hn = new Node<K,V>(ph, pk, pv, hn);
                            }
                            //将 ln 放在新数组的 i(即在旧数组的原位置) 上
                            setTabAt(nextTab, i, ln);
                            //将 hn 放在新数组的 i+oldCap 上
                            setTabAt(nextTab, i + n, hn);
                            //设置原数组上该位置的点为 ForwardingNode 代表该位置已经迁移完毕
                            setTabAt(tab, i, fwd);
                            //标记迁移完毕
                            advance = true;
                        }
                        //结构为 红黑树
                        else if (f instanceof TreeBin) {
                            TreeBin<K,V> t = (TreeBin<K,V>)f;
                            TreeNode<K,V> lo = null, loTail = null;
                            TreeNode<K,V> hi = null, hiTail = null;
                            int lc = 0, hc = 0;
                            for (Node<K,V> e = t.first; e != null; e = e.next) {
                                int h = e.hash;
                                TreeNode<K,V> p = new TreeNode<K,V>
                                    (h, e.key, e.val, null, null);
                                if ((h & n) == 0) {
                                    if ((p.prev = loTail) == null)
                                        lo = p;
                                    else
                                        loTail.next = p;
                                    loTail = p;
                                    ++lc;
                                }
                                else {
                                    if ((p.prev = hiTail) == null)
                                        hi = p;
                                    else
                                        hiTail.next = p;
                                    hiTail = p;
                                    ++hc;
                                }
                            }
                            // 如果一分为二后，节点数少于 8，那么将红黑树转换回链表
                            ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                                (hc != 0) ? new TreeBin<K,V>(lo) : t;
                            hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                                (lc != 0) ? new TreeBin<K,V>(hi) : t;
                            setTabAt(nextTab, i, ln);
                            setTabAt(nextTab, i + n, hn);
                            setTabAt(tab, i, fwd);
                            advance = true;
                        }
                    }
                }
            }
        }
    }
```

总结流程：

- 构建一个`nextTable`，它的容量是原来的两倍，这个操作只会执行一次。
- 根据hash值 计算对应的存储位置，然后根据`tabAt(i)`获得对应位置的头节点。
- 如果头节点为null，就在原table[i]放入`ForwardingNode`，代表当前位置已经迁移完毕。
- 如果头节点为链表节点，就构造一个反序链表，把他们分别放在`nextTable`中的`i和i+oldCap`位置上。放入成功后，在table[i]放入`ForwardingNode`，代表迁移完毕。
- 如果头节点为树节点，也做一个反序操作，并且判断是否需要重新转换成链表，再把处理后的结果分别放到`nextTable`中的`i和i+oldCap`位置上。放入成功后，在table[i]放入`ForwardingNode`，代表迁移完毕
- 遍历所有的节点就完成了数据迁移工作，让nextTable替代ConcurrentHashMap中的table，并更新`sizeCtl`为新数据容量的0.75倍，完成扩容。

### ConcurrentHashMap获取数据 - get()

> concurrentHashMap.get("Android");

源码解析：

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    //计算 hash值
    int h = spread(key.hashCode());
    //当前数组不能为空
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        // 判断头结点是否就是我们需要的节点
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                return e.val;
        }
        // 如果头结点的 hash 小于 0，说明 正在扩容 -1 ，或者该位置是红黑树
        else if (eh < 0)
            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)
            return (p = e.find(h, key)) != null ? p.val : null;

        // 遍历链表
        while ((e = e.next) != null) {
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```

总结流程：

- 首先计算key对应的`Hash值`，定为到`table`上的对应位置，如果直接是头节点就返回
- 此时需要判断头节点的`hash值`
  - `hash值等于-1`：说明该节点为`ForwardingNode`，表明此时正在执行扩容操作，调用其`find()`从`nextTable`寻找对应值
  - `hash值等于-2`：说明该节点是一个树节点，调用`TreeBin.find()`去寻找对应值,**内部存在着读写锁，可能红黑树正在旋转变色。**
  - `hash值大于等于0`：说明该节点是一个链表节点，直接进行链表遍历寻找对应值即可。
- 如果都没有找到，就返回null

> 为什么`get()`不需要加锁？
>
> 关键点在于`table`是由`volatile`进行修饰的，这个关键字可以保证可见性以及有序性。如果对其声明的变量进行了写操作，JVM就会向处理器发送一条指令，将这个变量所在的缓存行数据写回到主内存。基于**缓存一致性协议**，其他线程去读取时，就要强制从主内存中读取。**在数组进行扩容时可以保证可见性。**
>
> 对存储的节点`Node`的`元素val`以及`指针next`也是用`volatile`进行修饰的，再、在多线程环境下对他们进行改变对其他线程也是可见的。



## 引用参考

[**Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析**](https://javadoop.com/post/hashmap#put%20%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90)

[深入浅出ConcurrentHashMap1.8](https://www.jianshu.com/p/c0642afe03e0)

[ConcurrentHashMap&HashTable](https://juejin.im/post/5df8d7346fb9a015ff64eaf9)]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 反射</title>
    <url>/2018/12/14/Java-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[
## Java反射机制基础

{% fullimage /images/反射-基础概念.png,反射-基础概念,反射-基础概念%}

### 反射机制定义

反射(`Reflection`)是Java的特征之一，它允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。对于任何一个类，能够知道这个类中的所有属性和方法；对于任何一个对象，都能够调用它的任意一个方法和属性。

### 反射机制功能

通过反射，可以在运行时获取程序中的每一个类型的成员和成员信息。利用Java的反射机制可以动态的创建对象并调用其属性。反射可以提供运行时的类信息，并且可以支持这个类在运行过程中加载进来，甚至在编译时也没有加入编译的类。

主要提供了如下功能：

- 在运行时判断任意一个对象所属的类
- 在运行时构造任意一个类的对象
- 在运行时判断任意一个类所具有的成员变量和方法
- 在运行时调用任意一个对象的方法
- 生成动态代理

**一切都是在运行时而不是编译时。**

### 反射机制支持

由`java.lang.reflect`提供反射机制的支持，主要包含了三个类：

- `Field`：使用`getField()`和`setField()`读取和修改Field对象关联的字段
- `Method`：使用`invoke()`调用`Method`对象关联的方法
- `Constructor`：创建新的对象

### 反射机制优点

- **可拓展性**：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类
- **类浏览器和可视化开发环境**：可以枚举类的成员
- **调试器和调试工具**：可以调用类中的`private`或者`protected`的对象。

### 反射机制缺点

- **性能开销**：反射涉及了动态类型的解析，所以JVM无法对这些代码进行优化。导致效率低
- **安全限制**：使用反射要求在没有安全限制的环境下去进行
- **内部暴露**：由于反射允许代码执行一些正常情况下无法执行的操作(*访问私有变量或方法*)，反射代码也破坏了抽象性，当内部代码发生改变时，反射的代码也需要进行相应调整。

## Java反射机制使用场景

- 用于逆向代码，反编译
- 与注解相结合的框架 例如`Retrofit`使用的运行时注解
- 单纯的利用反射机制的框架 例如`EventBus`所以那些Event都不能被混淆
- 动态代理

## Java反射机制的基本运用

{% fullimage /images/反射-基本运用.png,反射-基本运用,反射-基本运用%}

### 获得Class对象

> 每个类被加载后，系统都会为其生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类

获取Class对象的方法有如下三种

#### 使用`Class.forName(String className/*必须完整包名*/)`获取对象。

```java
Class<?> clazz = Class.forName("com.example.wxy.FieldUtil");
```

#### 调用类的class属性来获取该类对应的Class对象

```java
Class<?> clazz = FieldUtil.class;
```

#### 调用某个对象的`getClass()`，

```java
Person person = new Person();
Class<?> class = Person.getClass();
```



### 获取Class对象的方法

主要有以下几个方法：

#### `getDeclaredMethods()`

> 返回类或接口声明的所有方法，包括`public(公共)、private(私有)、protected(保护)，default(默认)`，但不包括继承的方法

```java
public Method[] getDeclaredMethods() throws SecurityException
```

#### `getMethods()`

> 返回类或接口所有的`公共(public)`方法，包括父类的`公共(public)`方法

```java
public Method[] getMethods() throws SecurityException
```

#### `getDeclaredMethod()`

> 返回Class对象对应类的且带指定形参列表的所有方法

```java
/**
* name 方法名称
* parameterTypes 参数对应的Class对象
*/
public Method getDeclaredMethod(String name, Class<?>... parameterTypes)
```

#### `getMethod()`

> 返回Class对象对应类的且带指定形参列表的`公共(public)`方法

```java
/**
* name 方法名称
* parameterTypes 参数对应的Class对象
*/
private Method getMethod(String name, Class<?>... parameterTypes)
```

#### 实例分析

```java
public class reflect {
    public static void main(String[] args) {
        try {
            Class<?> methodClass = MethodClass.class;
            //获取所有共用方法，且包含父类方法
            Method[] methods = methodClass.getMethods();
            //获取所有方法，不包含父类方法
            Method[] declaredMethods = methodClass.getDeclaredMethods();
            //反射得到私有add()
            Method addMethod = methodClass.getDeclaredMethod("add", int.class, int.class);
            //反射得到共有sub()
            Method subMethod = methodClass.getMethod("sub", int.class, int.class);
            System.err.println("Declared Method "+addMethod);
            System.err.println("public Method "+subMethod);
            for (Method method : methods) {
                System.err.println("Public Methods "+method);
            }
            for (Method method : declaredMethods) {
                System.err.println("Declared Methods "+method);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class MethodClass {
    public final int a = 4;
    private int add(int a, int b) {
        return a + b;
    }
    public int sub(int a, int b) {
        return a - b;
    }
}

运行结果为:

Declared Method private int MethodClass.add(int,int)
Public Method public int MethodClass.sub(int,int)
//获取到的所有公共方法 包含了父类 Object中的公共方法
Public Methods public int MethodClass.sub(int,int)
Public Methods public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
Public Methods public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
Public Methods public final void java.lang.Object.wait() throws java.lang.InterruptedException
Public Methods public boolean java.lang.Object.equals(java.lang.Object)
Public Methods public java.lang.String java.lang.Object.toString()
Public Methods public native int java.lang.Object.hashCode()
Public Methods public final native java.lang.Class java.lang.Object.getClass()
Public Methods public final native void java.lang.Object.notify()
Public Methods public final native void java.lang.Object.notifyAll()
//获取到当前类的所有方法，不包含父类
Declared Methods private int MethodClass.add(int,int)
Declared Methods public int MethodClass.sub(int,int)
```

### 获取Class对象的成员变量

主要有以下方法：

#### `getFields()`

> 获取Class对象的public属性的所有变量

```java
 public Field[] getFields() throws SecurityException 
```

#### `getField()`

> 获取Class对象的指定public属性变量

```java
public Field getField(String name) throws NoSuchFieldException {
```

#### `getDeclardFields()`

> 获取Class对象的所有变量

```java
public native Field[] getDeclaredFields();
```

#### `getDeclardField()`

> 获取Class对象的指定属性变量

```java
public native Field getDeclaredField(String name) throws NoSuchFieldException
```

#### 实例分析

```java
public class reflect {
    public static void main(String[] args) {
        try {
            Class<?> methodClass = MethodClass.class;
            //返回所有public属性变量
            Field[] fields = methodClass.getFields();
            //返回所有变量
            Field[] declaredFields = methodClass.getDeclaredFields();
            Field field = methodClass.getField("a");
            Field declaredField = methodClass.getDeclaredField("c");
            for (Field f : fields) {
                System.err.println("Public Fields " + f);
            }
            for (Field f : declaredFields) {
                System.err.println("Declared Fields " + f);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class MethodClass {
    public final int a = 4;
    private final int c = 5;
}

运行结果为：
Public Fields public final int MethodClass.a
Declared Fields public final int MethodClass.a
Declared Fields private final int MethodClass.c
```

### 获取Class对象的构造函数

#### `getConstructors()`

> 获取Class对象的Public构造函数

```java
public Constructor<?>[] getConstructors() throws SecurityException 
```

#### `getDeclaredConstructors()`

> 获取Class对象的所有构造函数

```java
public Constructor<?>[] getDeclaredConstructors() throws SecurityException
```

#### `getConstructor()`

> 获取指定声明的public构造函数

```java
/**
* parameterTypes 参数对应的Class对象
*/
public Constructor<T> getConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException
```

#### `getDeclaredConstructor()`

> 获取指定声明的构造函数

```java
/**
* parameterTypes 参数对应的Class对象
*/
public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException
```

#### 实例分析

```java
public class reflect {
    public static void main(String[] args) {
        try {
            Class<?> methodClass = MethodClass.class;
            Constructor<?>[] constructors = methodClass.getConstructors();
            Constructor<?>[] declaredConstructors = methodClass.getDeclaredConstructors();
            Constructor<?> constructor = methodClass.getConstructor(int.class,int.class);
            Constructor<?> declaredConstructor = methodClass.getDeclaredConstructor(int.class,int.class,int.class);

            for (Constructor f : constructors) {
                System.err.println("Public Constructors " + f);
            }
            for (Constructor f : declaredConstructors) {
                System.err.println("Declared Constructors " + f);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class MethodClass {
    public MethodClass(int a ,int b){

    }

    private MethodClass(int a,int b,int c){

    }
}

运行结果：
Public Constructors public MethodClass(int,int)
Declared Constructors public MethodClass(int,int)
Declared Constructors private MethodClass(int,int,int)
```

### 创建Class对象实例

#### `newInstance()`

> 创建对象的实例 **需要对应Class有无参构造函数**

```java
public native T newInstance() throws InstantiationException, IllegalAccessException;
```

#### `Constructor.newInstance()`

> 通过构造器去创建对象实例

```java
public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException
```

#### 实例分析

```java
public class reflect {
    public static void main(String[] args) {
        try {
            Class<?> methodClass = MethodClass.class;
            Object object = methodClass.newInstance();

            Constructor<?> constructor = methodClass.getConstructor(int.class,int.class);
            Object object1 = constructor.newInstance(1,2);
            System.err.println("newInstance() "+object.getClass());
            System.err.println("Constructor.newInstance() "+object1.getClass());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class MethodClass {
    public int a = 4;
    private int b = 6;
    private int c = 5;
    public MethodClass(){
    }
    public MethodClass(int a, int b) {
        this(a, b, 0);
    }
    private MethodClass(int a, int b, int c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}

运行结果：
newInstance() class MethodClass
Constructor.newInstance()  class MethodClass
```

### 调用Class对象方法

#### `invoke()`

> 传入方法名和参数，就可以调用到对应方法

```java
@CallerSensitive
@FastNative
public native Object invoke(Object obj, Object... args)
            throws IllegalAccessException, IllegalArgumentException, InvocationTargetException;
```

> `@FastNative`：Android 8.0新增加的注解，可以更快速的进行原生调用
>
> `@CallserSensitive`：跳过检查直接确定调用的对象

#### 实例分析

```java
public class reflect {
    public static void main(String[] args) {
        try {
            Class<?> methodClass = MethodClass.class;
            Object object = methodClass.newInstance();

            Method addMethod = methodClass.getDeclaredMethod("add", int.class, int.class);
            addMethod.setAccessible(true);
            addMethod.invoke(object,1,2);
          
            Method subMethod = methodClass.getMethod("sub", int.class, int.class);
            subMethod.invoke(object,2,1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class MethodClass {
    public MethodClass(){

    }
    private int add(int a, int b) {
        System.err.println("I`m reflect private method " + a+b);
        return a + b;
    }
    public int sub(int a,int b){
        System.err.println("I`m reflect public method" + a-b);
        return a - b;
    }
}

运行结果：
I`m reflect private method 3
I`m reflect public method 1
```

> 当通过`Method.invoke()`调用对应方法时，要求程序必须拥有调用该方法的权限。如果程序调用了private方法，就需要设置`setAccessible(boolean flag)`，设置`flag`为true则取消访问权限检查；false继续执行检查，则会报错`Class reflect can not access a member of class MethodClass with modifiers "private"`。

### 设置Class对象变量值

#### `Field.set()/Field.get()`

> 设置/获取任意变量值*Object*

```java
public native void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException;

public native Object get(Object obj) throws IllegalArgumentException, IllegalAccessException;
```

#### `Field.setXX()/Field.getXX()`

> 设置/获取基本类型变量*int,boolean.long,double,float,char,short,byte8种基本类型*

```java
public native boolean getBoolean(Object obj) throws IllegalArgumentException, IllegalAccessException;
public native void setBoolean(Object obj, boolean z) throws IllegalArgumentException, IllegalAccessException;
```

| 基本类型 | 对应名称(位数)                                               |
| -------- | ------------------------------------------------------------ |
| 整数型   | byte(8位)，short(16位)，int(32位)，long(64位)                |
| 浮点型   | float(32位)，double(64位) 默认为double，要设置成float，需要结尾加f |
| 字节型   | char(16位)                                                   |
| 布尔型   | boolean(1位)                                                 |

实例分析

```java
public class reflect {
    public static void main(String[] args) {
        try {
            Class<?> methodClass = MethodClass.class;
            Object object = methodClass.newInstance();

            Field field = methodClass.getField("a");
            Field declaredField = methodClass.getDeclaredField("b");
            field.setAccessible(true);
            declaredField.setAccessible(true);
            field.set(object,3);
            declaredField.set(object,5);

            Method addMethod = methodClass.getDeclaredMethod("add", int.class, int.class);
            addMethod.setAccessible(true);
            addMethod.invoke(object,1,2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

class MethodClass {
    public int a = 4;
    private int b = 6;
    private int c = 5;

    public MethodClass(){
    }
    public MethodClass(int a, int b) {
        this(a, b, 0);
    }
    private MethodClass(int a, int b, int c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    private int add(int a, int b) {
        System.err.println("reflect value a="+ this.a+" b="+ this.b);
        return a + b;
    }

    public int sub(int a, int b) {
        return a - b;
    }
}

运行结果：
reflect value a=3 b=5
```

## Java反射机制的高级运用

### 反射创建数组

> 数组是一个比较特殊的类型，在反射机制中有专门的处理类——`java.lang.reflect.Array`
>
> `newInstance()`：创建一个数组对象
>
> `get()/getXX()`：获取数组中对应位置的值
>
> `set()/setXX()`：设置数组中对应位置的值

#### 实例分析

```java
public class GenerateArray {
    public static void main(String[] args){
        try {
            Class<?> clazz = Class.forName("java.lang.String");
            //创建一个 String型数组
            Object array = Array.newInstance(clazz,20);
            Array.set(array,0,"12");
            Array.set(array,1,"23");
            System.err.println(Array.get(array,1));
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}

运行结果：
23
```



### 反射获取泛型

{% post_link Java-泛型 %}

反射只能对普通类型的Field有效，如果该Field的类型是有泛型限制的类型，例如`Map<String,String>`类型，则无法准备取得该Field的泛型参数。

#### `ParameterizedType`

代表被参数化的类型，增加了泛型限制的类型。

#### `getRawType()`

返回没有泛型信息的原始类型

#### `getActualTypeArguments()`

返回泛型参数的类型

#### 实例分析

```
public class GenerateArray {
    //使用泛型类型的Map
    private Map<String, Integer> map = new HashMap<>();

    public static void main(String[] args) {
        try {
            Class<GenerateArray> clazz = GenerateArray.class;
            //反射获取Map变量
            Field f = clazz.getDeclaredField("map");
            //直接获取Field类型
            Class<?> mapClazz = f.getType();
            System.err.println(mapClazz);
            //获取Field的泛型类型
            Type type = f.getGenericType();
            //判断是否为泛型类型
            if (type instanceof ParameterizedType) {
                //强制类型转换
                ParameterizedType pType = (ParameterizedType) type;
                //获取原始类型 这里得到的是Map
                Type rType = pType.getRawType();
                System.err.println("原始类型 ：" + rType);
                //获取泛型类型的泛型参数
                Type[] types = pType.getActualTypeArguments();
                System.err.println("泛型类型 ：");
                for (int i = 0; i < types.length; i++) {
                    System.err.println(types[i]);
                }
            } else {
                System.err.println("无法获取泛型类型");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 反射使用注意事项

由于反射会额外的消耗一定的系统资源，如果不需要动态的创建一个对象，那么就不需要用到反射。

另外反射调用方法时会忽略权限检查，因此可能会破坏封装性导致安全问题。

## 反射优化

反射慢的原因主要在两点：

- 虽然javac不怎么优化代码，但反射导致JIT编译器无法有效做优化，使得反射执行慢
- 反射方法的检测，需要检测`类、方法是否存在，权限是否正确`



优化点如下：

- `setAccessible(true)`避免反射时的检测
- 若大量执行反射，对反射对象的反射结果进行缓存，可以后续反射时直接调用缓存
- 使用三方反射库，例如`ReflactASM`通过添加字节码的方式实现反射功能。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI基础知识</title>
    <url>/2019/03/02/JNI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[
<!--注册方案-->

## JNI基础概念

JNI本意为`Java Native Interface`，为了方便Java调用C、C++等本地代码所封装的一层接口。当出现一些无法用Java处理的任务时，就可以借用JNI技术去完成。
一般来说有以下几种情况需要用到JNI技术：
- 需要调用Java语言不支持的依赖于操作系统平台特性的一些功能。例如：调用当前Android系统的底层功能，而Java无法实现，就需要用到JNI
- 为了提升应用部分功能的性能，必须采用其他语言实现。例如：OpenCV进行图像识别

为了开发者方便使用JNI技术，Android提供了**NDK**这个工具集合，通过NDK可以在Android中更加方便的通过JNI访问Native代码。NDK还提供了交叉编译器，只要简单的修改`build.gradle`中的`cMake`配置就可以支持生成特定CPU的动态链接库。

NDK有如下优点：
- 提高代码的安全性。由于so库反编译比较困难，提高了程序的安全性。
- 可以很方便的植入已有的C/C++库，例如FFmpeg、OpenCv等
- 提高程序在某些特定情况下的执行效率，但不能明显提升Android程序的性能。
- 易于代码复用和移植，用C/C++开发的代码也可以移植到其他平台上

JNI目前有着非常广泛的应用场景，包括音视频开发、热修复、插件化等当前热门技术。

## 源码中的JNI
## JNI基础使用
## JNI原理简略分析
## JNI参数相关]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字节码学习-应用场景</title>
    <url>/2019/11/18/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[
<!-- ASM基本原理、代码中的动态替换  非静态调用通过字节码编辑改为静态调用 字节码注入 SPI Transform-->

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>组件化原理及实践</title>
    <url>/2019/02/27/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[
<!--SPI实现、字节码注入实现、如何实现组件通信、平级调用数据-->

## 利用SPI机制实现组件化功能





## 利用字节码注入配合transform api实现组件化功能





## 组件化间通信机制





## 参考链接

[AutoRegister](https://baiqiantao.github.io/Java/aop/YzaiEf/)

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字节码学习-操作指令</title>
    <url>/2019/11/14/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[
> 对常见的字节码操作指令进行整理，方便日后进行查询。为了在字节码应用时可以进行合理利用。

JVM采用基于栈的架构，操作指令由**操作码和操作数**组成。`操作码`决定要完成的操作，`操作数`指参加运算的数据及其所在的单元地址。

操作码：一个字节长度（0～299），操作码个数不能不能超过256

操作数：一条指令可以包含0个或多个操作数。

> 为了提升传输效率，减少数据量。字节码指令放弃了 操作数对齐，减少了填充与间隔符号的使用。但是如果操作码处理超过一个字节的数据时，必须在运行时从字节码里构建出具体的数据结构，占用CPU，导致解释执行字节码会损失部分性能。



## 操作指令（按功能分类）

**大部分数据类型相关指令，都没有支持byte、short、char数据类型，并且没有任何支持boolean类型的指令。**

编译器会在编译期或运行期将`byte、short`转为**带符号拓展的int型数据**，将`char、boolean`转为**零位拓展的int型数据**。

### 加载存储指令

{% fullimage /images/字节码-操作指令-加载指令.jpg,字节码-操作指令-加载指令,字节码-操作指令-加载指令%}

{% fullimage /images/操作指令-加载指令.png,操作指令-加载指令,操作指令-加载指令%}

> 主要用于*局部变量与操作数栈交换数据*、*常量装载到操作数栈*。

#### 局部变量与操作数栈交换数据

##### load

> 加载局部变量表指定位置的相应类型变量到操作数栈栈顶

`iload、iload_<n>`：将`第n+1`个`int`变量推到栈顶

`lload、lload_<n>`：将`第n+1`个`long`变量推到栈顶

`fload、fload_<n>`：将`第n+1`个`float`变量推到栈顶

`dload、dload_<n>`：将`第n+1`个`double`变量推到栈顶

`aload、aload_<n>`：将`第n+1`个`引用`变量推到栈顶



##### store

> 将操作数栈栈顶的相应类型数据保存到局部变量的指定位置

`istore、istore_<n>`：将栈顶的`int`类型数值保存到`n+1`的局部变量中

`lstore、lstore_<n>`：将栈顶的`long`类型数值保存到`n+1`的局部变量中

`fstore、fstore_<n>`：将栈顶的`float`类型数值保存到`n+1`的局部变量中

`dstore、dstore_<n>`：将栈顶的`double`类型数值保存到`n+1`的局部变量中

`astore、astore_<n>`：将栈顶的`引用`类型数值保存到`n+1`的局部变量中



`XXX_<n>`，其中`n`表示非负整数，范围在0~3之间，超过这个范围则表示成`XXX n`

例 `iload 4`，将第5个`int`类型数值推到栈顶。



####  常量装载到操作数栈

##### push

> 相应类型常量数值放入栈顶

`bipush`：单字节的常量值(-128~127)进栈
例：	`static final int a = 123`

`sipush`：短整型常量值(-32768~32767)进栈
例：	`static final int a =456`

对应上述操作码的操作数为 **常量的数值**，例 `bipush 123`



##### const

> 将相应的数值类型放入栈顶，无对应操作数

`iconst_m1、iconst_<n>`：`int`型常量进栈，`m1`指代-1，n为`1~5`

例 `int a = -1`,若`int a=6 `则对应`bipush 6`

`lconst_0,lconst_1`：`long`型常量进栈，只有0L、1L有效

例 `long a = 0L`

`fconst_0,fconst_1,fconst_2`：`float`型常量进栈，只有0F、1F、2F有效

例 `float a = 0f`

`dconst_0,dconst_1`：`double`型常量进栈，只有0D、1D有效

例 `double a = 0d`

`aconst_null`：对象`null`进栈，只有`null`有效

例 `String a = null`



##### ldc

> 把数值常量或String型常量从常量池中推送至栈顶，`操作数为常量池索引`

**所有不是通过new方式创建的String都是放在常量池中的。**

`ldc`：`int、float或String型常量`推送至栈顶

例 `int a = 66666`，对应`ldc #18`，18代指了常量池中的位置，*索引为8位*

`ldc_w`：`int、float或String型常量`推送至栈顶，**宽索引**

例`宽索引`：表示常量池的行号，索引的字段长度。*索引为16位*

`ldc2_w`：`long、double型常量`推送至栈顶，**宽索引**

例 `doubla a = 2.3`，对应`ldc2_w #19`，#19表示了`double 2.3`



### 操作数栈管理指令

{% fullimage /images/操作指令-操作数栈管理指令.png,操作指令-操作数栈管理指令,操作指令-操作数栈管理指令%}

> 对操作数栈进行直接操作：**出栈、复制栈顶元素、交换栈顶元素**

#### 操作数栈栈顶出栈

##### pop

> 操作数栈栈顶元素出栈 **不能是long、double**，只支持一个字节的数据

##### pop2

> 操作数栈栈顶元素出栈 ，支持两个字节的数据，例如`long/double`一个数值，其他类型是两个数值

#### 操作数栈栈顶复制

以下三个操作指令支持的数据类型 不包括**long、double**，其他类型例如`int、returnAddress、refrence`都支持

##### dup

> 复制栈顶一个字节长度的元素，复制后的数据重新压入栈顶

原始操作数栈    …->value3->value2->value1

dup操作后         …->value3->value2->value1->value1

例 `int a = 0; a= ++a;` 对应字节码为 `dup`

##### dup_x1

> 复制栈顶一个字节长度的元素，弹出栈顶两个字节长度元素后，压入复制的数据，再将弹出的两个字节长度元素压入栈顶

原始操作数栈    …->value3->value2->value1

dup_x1操作后    …->value3->value1->value2->value1

##### dup_x2

> 复制栈顶一个字节长度的元素，弹出栈顶三个字节长度元素后，压入复制的数据，再将弹出的三个字节长度元素压入栈顶

原始操作数栈    …->value3->value2->value1

dup_x2操作后    …->value1->value3->value2->value1



<br>

以下三个操作指令支持所有数据类型

##### dup2

> 复制栈顶两个字节长度的元素，复制后的数据重新压入栈顶

原始操作数栈    …->value3->value2->value1

dup2操作后        …->value3->value2->value1->value2->value1

若value1为`long/double` …->value3->value2->value1->value1

例 `long a = 0L; a= ++a;` 对应字节码为 `dup2`

##### dup2_x1

> 复制栈顶两个字节长度的元素，弹出栈顶三个字长的数据，压入复制的数据，再将弹出的三个字长的数据压入栈顶

原始操作数栈    …->value3->value2->value1

dup2_x1操作后  …->value2->value1->value3->value2->value1

若value1 为`long/double` 	…->value3->value1->value2->value1

##### dup2_x2

> 复制栈顶两个字节长度的元素，弹出栈顶四个字长的数据，压入复制的数据，再将弹出的四个字长的数据压入栈顶

原始操作数栈    …->value4->value3->value2->value1

dup2_x2操作后  …->value2->value1->value4->value3->value2->value1

若value1、value2为`long/double`  …->value4->value3->value2->value1->value2->value1

#### 操作数栈栈顶元素交换

##### swap

> 栈顶的两个数值互换，且不能是**long、double**

原始操作数栈    …->value3->value2->value1

swap操作后		 …->value3->value1->value2



### 对象操作指令

{% fullimage /images/操作指令-对象操作指令.png,操作指令-对象操作指令,操作指令-对象操作指令%}

> 主要是操作对象（主要指类）的创建与访问，例如`新建对象实例，访问对象实例变量与类变量等`

#### 创建对象实例

##### new

> 创建新对象实例

例 `String a = new String("new")` 对应指令为 `new`

#### 访问类变量（实例变量、静态变量）

##### getField

> 从常量池中获取对象的字段，并压入栈顶

例 `getField #18`，取出常量池中索引为18的字段

##### putField

> 给从常量池中获取的对象赋值

例 `putField #18`，给常量池索引为18的字段赋值

##### getStatic

> 获取类的静态(static)变量，并压入栈顶

例 `getStatic #19`，取出常量池索引为19的静态变量

##### putStatic

> 给类的静态(static)变量进行赋值

例 `putStatic #19`，给常量池索引为19的静态变量赋值

#### 对象类型操作

##### checkcast

> 类型转换检测

##### instanceof

> 判断类型是否相符，操作数为常量池索引

例 `str instanceof String` 对应`instanceof #13`

### 数组操作指令

{% fullimage /images/数组操作指令.png,操作指令-数组操作指令,操作指令-数组操作指令%}

> 主要是对数组对象的操作，包括**创建数组、加载数组元素、获取数组长度**等

#### 创建数组

##### newarray

> 创建数组且**类型必须是基础数据类型**，操作数为**基础数据类型**

例 `int[] a = new int[2]` 对应操作指令为 `newarray int`

##### anewarray

> 创建数组且**类型为引用类型**，操作数为**常量池类名索引**

例 `String[] a=new String[2]` 对应操作指令为 `anewarray #18`

##### multianewarray

> 创建多维度的数组，操作数为**常量池类名索引以及维度**

例`int[][] a = new int[2][3]` 对应操作指令为 `multianewarray #2,2`代表类来自索引为2的类名以及维度为2，有两层嵌套

#### 数组元素与操作数栈交换数据

> 由于数组也是对象，故前缀为`a`，

##### (X)aload

> 数组元素加载到操作数栈栈顶，X可以为**b(byte)、c(char)、s(short)、i(int)、l(long)、f(float)、d(double)、a(refrence)**

例 `int c = a[2]`，对应操作指令为

```java
        41: aload_0 //加载数组对象
        42: iconst_2 //设置取索引为2的值
        43: iaload //获取对应值
```

##### (X)astore

> 操作数栈的值给对应数组元素赋值，X可以为**b(byte)、c(char)、s(short)、i(int)、l(long)、f(float)、d(double)、a(refrence)**

例 `a[5] = 5`，对应操作指令为

```java
  aload_0 //加载数组对象
  iconst_5 //设置常量为5
  bipush 6 //赋值对应元素为6
  iastore  //保存赋值
  
```



#### 数组长度

##### arraylength

> 获取对应数组的长度，无操作数



### 方法操作指令

{% fullimage /images/操作指令-方法操作指令.png,操作指令-方法操作指令,操作指令-方法操作指令%}

> 主要是对方法进行操作，包括**方法调用、方法返回**

#### 方法调用

> 调用类中不同的方法指令

##### invokevirtual

> 调用实例方法，操作数为**常量池的索引，索引的值为 方法符号引用** 属于静态分派

例 `System.out.println("aaa")`对应操作指令为

```java
 invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
```



##### invokestatic

> 调用类的静态(static)方法，操作数为**常量池的索引，索引的值为 方法符号引用** 

例 `Test.test(int a,boolean b)` 对应操作指令为

```java
 invokestatic  #11                 // Method test:(IZ)V
```



##### invokeinterface

> 调用接口方法，运行时搜索由特定对象所实现的接口方法，并找到合适的进行调用，操作数为**常量池的索引，索引值为 接口方法符号引用**。还有个`count`???

例`new ArrayList<String>().add("sd");` 对应操作指令为

```java
invokeinterface #16,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
```



##### invokespecial

> 调用一些需要特殊处理的实例方法，包括**实例初始化方法、私有方法、父类方法**。操作数为 **常量池的索引且值为 方法符号引用**



##### *invokedynamic？？

> Java7中引入，在Java8中允许调用
>
> 调用动态链接方法 ，用于`lambda`表达式中

//TODO 拓展一节

#### 方法返回

> 方法的返回指令根据返回数据类型进行区分

##### ireturn

> 返回数据类型为 `boolean、byte、short、char、int`时调用

例 `int getResult()`，对应操作指令为`ireturn`

##### lreturn

> 返回数据类型为`long`

##### freturn

> 返回数据类型为`float`

##### dreturn

> 返回数据类型为`double`

##### areturn

> 返回数据类型为`reference`

##### return

> 返回`void`



### 控制转移指令

{% fullimage /images/操作指令-控制转移指令.png,操作指令-控制转移指令,操作指令-控制转移指令%}

> 让JVM有条件或无条件的从指定位置的指令继续执行程序，而不是当前控制转移指令的下一条，从而达到**控制流程**目标。

#### 条件跳转指令

> 对栈顶元素进行判断，操作数为**可能跳转的指令行号**

##### ifeq、ifne

> 若栈顶int元素值【=0或!=0】则跳转

```java
a==0 //ifne 11
a!=0 //ifeg 11
```

##### iflt、ifle

> 若栈顶int元素值【小于(<)0或小于等于(<=)0】则跳转

```java
a>=0 //iflt 11
a>0 //ifle 11
```

##### ifgt、ifge

> 若栈顶int元素值【大于(>)0或大于等于(>=)0】则跳转

```java
a<=0 //ifgt 11
a<0 //ifge 11
```

##### ifnull、ifnotnull

> 若栈顶引用值为【==null或!=null】则跳转

```java
a==null //ifnotnull 11
a!=null //ifnull 11
```



#### 无条件跳转指令

##### goto

> 无条件跳转指定位置，操作数为**指定行数**

还有`goto_w`，无条件跳转不过`w`表示宽索引

##### jsr（Java7及以后不使用）

> Java 6之前 finally语句生成，跳转到子例程序

##### ret（Java7及以后不使用）

> Java 6之前 返回由指定局部变量所给出的指令地址

##### athrow

> 显式抛出异常

#### 复合条件跳转指令

##### tableswitch

> 通过索引访问跳转表，并跳转

例

```java
switch (a) {
            case 0:
                return 0;
            case 1:
                return 1;
            case 2:
                return 2;
            case 5:
                return 5;
            default:
                return -1;
        }
```

对应操作指令为

```java
 tableswitch   { // 0 to 5
                       0: 40
                       1: 42
                       2: 44
                       3: 48
                       4: 48
                       5: 46
                 default: 48
            }
```

其中源码未出现的3,4都跳转默认指令行数

##### lookupswitch

> 通过键值访问跳转表，并跳转

例

```java
switch (a) {
            case -5:
                return 0;
            case 1:
                return 1;
            case 2:
                return 2;
            case 5:
                return 5;
            default:
                return -1;
        }
```

对应操作指令为

```java
 lookupswitch  { // 4
                      -5: 44
                       1: 46
                       2: 48
                       5: 50
                 default: 52
            }
```



> 为何后续`switch`可以支持`String`类型，由于在字节码的过程中会被转换成`str.hashcode`，根据对应的`hashcode`进行判断。



#### 比较指令

> 比较操作数栈栈顶两个元素的大小，然后根据比较结果压入操作数栈中

##### dcmpg、dcmpl

> 比较栈顶两double类型值，
>
> **前者大，1入栈<br>都相等，0入栈<br>后者大，-1入栈<br>存在NaN，则-1入栈**

例

```java
double da = 1f;
double db = 2f;
double dc = Double.NaN;
double dd = 1f;

System.err.println(da>db); //dcmpl  (-1)  ifle
System.err.println(db<da); //dcmpg  ( 1)  ifge
System.err.println(da=dd); //dcmpl  ( 0)  ifne
System.err.println(da>dc); //dcmpl  (-1)  ifle
System.err.println(da<dc); //dcmpg  (-1)  ifge
```



##### fcmpg、fcmpl

> 比较栈顶两float类型值，
>
> **前者大，1入栈<br>都相等，0入栈<br>后者大，-1入栈<br>存在NaN，则-1入栈**

例

```java
float fa = 1f;
float fb = 2f;
float fc = Float.NaN;

System.err.println(fa>fb); //fcmpl  (-1)  ifle
System.err.println(fa<fb); //fcmpg  (-1)  ifge
System.err.println(fb<fa); //fcmpg  ( 1)  ifge
System.err.println(fa>fc); //fcmpl  (-1)  ifle
System.err.println(fa<fc); //fcmpg  (-1)  ifge
```



##### lcmp

> 比较栈顶两long类型值
>
> **前者大，1入栈<br>都相等，0入栈<br>后者大，-1入栈**



上述的比较指令是只针对于`float、double、long`型的数据，剩下的还有`int、refrence`

##### if_icmpeq、if_icmpne

> 栈顶两int类型值是否相等

```java
int a =1;
int b =2;

a==b //if_icmpne 11
a!=b //if_icmpeq 11
```



##### if_icmplt、if_icmple

> 栈顶两int类型是否前者【小于(<)或小于等于(<=)】后者

```java
int a =1;
int b =2;

a>=b //if_icmplt 11
a>b //if_icmple 11
```



##### if_icmpgt、if_icmpge

> 栈顶两int类型是否前者【大于(>)或大于等于(>=)】后者

```java
int a =1;
int b =2;

a<=b //if_icmplt 11
a<b //if_icmple 11
```



##### if_acmpeq、if_acmpne

> 栈顶两引用类型值是否相等

```java
String sa = "1";
String sb = "2";

sa==sb //if_acmpne 11
sa!=sb //if_acmpeq 11
```

### 类型转换指令

{% fullimage /images/操作指令-类型转换指令.png,操作指令-类型转换指令,操作指令-类型转换指令%}

> 对两种不同类型的数值进行转换。**一般用于实现用户代码中的显式类型转换操作，或者用来解决字节码指令集不完备的问题（例如byte、short、char、boolean需要转换为int）。**

#### 宽化类型转换

> **存储长度由小到大转换，无需显式的转换指令，并且是安全的操作。**
>
> 转换范围由小到大为：**int << long << float << double**

##### i2l、i2f、i2d

> `int`转换为`long、float、double`

##### l2f、l2d

> `long`转换为`float、double`

##### f2d

> `float`转换为`double`

#### 窄化类型转换

> **存储长度由大到小转换，需要显式的调用转换指令，很可能导致精度丢失。**
>
> 转换范围由大到小为：**double >> float >> long >> int**

##### d2f、d2l、d2i

> `double`转换为`float、long、int`

##### f2l、f2i

> `float`转换为`long、int`

##### l2i

> `long`转换为`int`

##### i2b、i2s、i2c

> `int`转换为`byte、short、char`。通过将栈顶`int`类型截断成对应类型，然后将对应类型通过`符号拓展`成int型。

`i2b`：`byte`占8位，就是取出int转换二进制后的低八位的补码即为结果

`i2s`：`short`占16位，取出int转换二进制后的低16位的补码即为结果

`i2c`：数字转换字符后，会当做`ASCII`编码来处理

> 当遭遇到`Float.NaN或者Double.NaN`就转换为对应类型的0！

### 运算指令

{% fullimage /images/操作指令-运算指令.png,操作指令-运算指令,操作指令-运算指令%}

> 对操作数栈的两个数值进行运算，并将结果重新存入操作数栈中。
>
> 只支持**整数类型与浮点类型**数据的运算。

#### 通用运算指令

> 包括一些**加、减、乘、除、求余、取反**等操作

##### Xadd

> 运算指令 ——加法，栈顶两数相加，结果入栈
>
> X为`i(int)、l(long)，f(float)、d(double)`

##### Xsub

> 运算指令 ——减法，栈顶两数相减，结果入栈
>
> X为`i(int)、l(long)，f(float)、d(double)`

##### Xmul

>运算指令 ——乘法，栈顶两数相乘，结果入栈
>
>X为`i(int)、l(long)，f(float)、d(double)`

##### Xdiv

>运算指令 ——除法，栈顶两数相除，结果入栈
>
>X为`i(int)、l(long)，f(float)、d(double)`

##### Xrem

> 运算指令 ——求余，栈顶两数取模，结果入栈
>
> X为`i(int)、l(long)，f(float)、d(double)`

例`a % b` 对应操作指令为`rem`

##### Xneg

> 运算指令 ——取反，栈顶数据取反，结果入栈
>
> X为`i(int)、l(long)，f(float)、d(double)`



#### 其他运算指令

> 包括一些**移位运算、按位布尔运算、自增运算**

##### Xshl、Xshr、Xushr

> 运算指令——移位运算，栈顶数据进行移位运算结果入栈
>
> X为`i(int)、l(long)`

`Xshl`：左移运算，**丢弃最高位，往左移位，右侧空位补0**

例 `5 << 2`，5 转换二进制为`0101` 向左移2位后，得到`01 0100`值为20

`Xshr`：算术右移运算，**丢弃最低位，往右移位，左侧空位补符号位**

例`5>>2`，5 转换二进制为`0101` ，向右移2位后，得到`0001`值为1

`Xushr`：无符号右移，逻辑右移运算，**丢弃最低位，向右移位，左边空出来的位置补0**

例`-7>>>2`，-7转换二进制为`11111111 11111111 11111111 11111001`，右移2位得到`00111111 11111111 11111111 11111110`得到`1073741822`

**在不大于自身数值类型最大位数的移位时，一个数左移n位，就是将这个数乘以2的n次幂；一个数右移n位，就是将这个数除2的n次幂，然后取整。**

> 若需要移位的数值大于32，等价于移位数和32取余得到的结果为移位数。

##### Xand、Xor、Xxor

> 运算指令——按位布尔运算，栈顶数据进行按位运算后结果入栈
>
> X为`i(int)、l(long)`

`Xand`：按位与运算，**都为1就是1，否则为0——同1为1**

例`4 & 2`，4的二进制为`0100`，2的二进制为`0010`，结果为`0000`得0

`Xor`：按位或运算，**有1得1，否则为0——有1为1**

例`4 | 2`，4的二进制为`0100`，2的二进制为`0010`，结果为`0110`得6

`Xxor`：按位异或运算，**数值相同为0，否则为1——同0异1**

例`4 ^ 2`，4的二进制为`0100`，2的二进制为`0010`，结果为`0110`得6



##### iinc

> 运算指令——自增运算。 指定数据进行自增后结果入栈。
>
> 操作数有两个，一个是操作数栈的索引(对应需要自增的数值)，一个是自增的步长(一次加多少)

例`b+=2`，对应操作指令为`iinc 1,2`，`1`对应的是操作数栈索引，`2`对应的是自增步长



> 还有非运算(`~`)，不过字节码中转换成为了`x xor -1`

例`~4` ，即`4 xor -1`，4的二进制为`0000 0100`，-1的二进制为`1111 1111`，结果为`1111 1011`再取一次补码得到`1111 1101`得到`-5`

### 同步与异常指令

#### 同步指令

{% fullimage /images/操作指令-同步指令.png,操作指令-同步指令,操作指令-同步指令%}

> 同步指令集序列，由`synchronized语句块`进行控制

##### monitorenter

> 进入并获得对象监视锁(**加锁**)

##### monitorexit

> 释放并退出对象监视锁(**释放锁**)



`synchronized`锁分为两种：**对象锁**、**类锁**。

未被锁定的对象的该计数器为0，当一个线程获得锁（执行`monitorenter`）后，该计数器自增变为 1 ，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁（执行`monitorexit`指令）的时候，计数器再自减。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。

`synchronized`修饰方法时，通过`ACC_SYNCHRONIZED`进行隐式加锁。

#### 异常指令

{% fullimage /images/操作指令-异常指令.png,操作指令-异常指令,操作指令-异常指令%}

>显式抛出异常以及`throw`语句都是通过异常指令实现

##### athrow

> 显示的抛出异常
>
> *在JVM中，`catch`代码不由字节码指令来实现，需要通过异常表(Exception Table)表示*

关于`finally`块中的指令采用的是每个分支代码中冗余一份，就是`try`，n个`catch`方法中字节码部分都会冗余finally的代码。

如果出现未显式捕获的异常则通过`athrow`指令抛出。如果出现已声明捕获的异常，在前面的字节码中就会执行，不会走到`athrow`指令行数。

## 拓展知识

### 堆、栈的区别

> 最主要区别是：
>
> `栈内存`用来存储 **局部变量和方法调用**
>
> `堆内存`用来存储 **Java中的对象。无论是成员变量、局部变量、类变量 他们指向的对象都存储在堆内存中。**
>
> 额外补充：如果局部变量是 基本数据类型 ，那么局部变量的值 直接存储于栈中；如果局部变量是 对象 ，那么该变量的引用存在栈中，但是对象存储于堆中。

- `栈内存` 线程私有，`堆内存` 所有线程共享
- `栈内存` 抛出``StackOverflowError`，`堆内存` 抛出`OutOfMemoryError`

### 栈的组成

> 栈 主要用于存储 **栈帧**，栈帧也叫`过程活动记录`，一种用于支持JVM调用/执行程序方法的数据结构，每个方法被调用时都会创建一个栈帧存储所需的数据信息，`栈帧伴随方法的调用而创建，执行结束而销毁`。
>
> **每一个方法从调用开始到执行完成都对应着一个栈帧在JVM里面从入栈到出栈的过程。**

`栈帧`主要存储了以下四部分：

- 局部变量表：`用于存储方法参数和定义在方法体的局部变量，这些包含了各类原始数据类型、对象引用、returnAddress类型。`局部变量表的大小在编译期就已经确定，对应的是字节码中的`Code-LocalVariableTable`属性。

  局部变量表中最小的存储单元是`slot`，除了`double,float`占用两个`slot`，其他都是一个`slot`。

  `slot`是可以被重用的，用于`节省栈帧的占用空间`，当某个变量执行完毕时，它对应的`slot`就可以被其他变量所使用。

- 操作数栈：`通过入栈、出栈操作来完成一次数据访问。本质是个**临时数据存储区域**。`操作数栈的大小在编译期就已经确定，对应的是字节码中的`Code-maxStack`

  > 当一个方法开始执行时，操作数栈为空，在执行过程中由于`出栈、入栈`操作，往操作数栈中写入和提取内容。

- 动态链接：`表示指向运行时常量池中该栈帧所属方法的引用，为了支持当前方法的代码能够实现 动态连接`。主要用于`将编译期无法被确定的方法调用，在运行期符号引用转换为调用方法的直接引用`。

  - 静态链接：被调用的目标方法在编译期可知，且运行期保持不变时，那么这种情况下调用方法的符号引用转换为直接引用的过程为静态链接。

  > 两者主要区别在于：
  >
  > - 静态链接可以在类加载的解析阶段（编译期）将符号引用转为直接引用
  > - 动态链接在每一次运行时期（运行期）将符号引用转为直接引用

- 方法返回值：`记录方法被调用的位置，可以在方法执行结束后回到被调用处继续向下执行`。

  有两种方式可以退出方法调用：
  
  - 正常调用：执行引擎遇到了返回的字节码指令(例如`ireturn(int,boolean,byte,short,char)、lreturn(long)、freturn(float)、dreturn(double)、areturn(refrence)，return(void)`)，这时将返回值传递给上层的方法调用者。
  
  - 异常调用：在执行过程中遇到了异常，并且没有处理该异常，就会导致方法退出并且不会返回值。
  
  一般方法正常退出该值为`调用者的PC计数器的值`。

### 零位拓展与符号位拓展

符号位拓展

> 需要使用更多内存存储一个有符号数时，需要保持符号位一直在第一位。
>
> 当对一个负数进行符号位拓展时，**把拓展之后数的高位全部设置为1**；
>
> 例如二进制表示-1，10000001，需要使用十六位则表示为 1111111110000001，高位全补1
>
> 当对一个正数进行符号位拓展时，**把拓展之后数的高位全部设置为0**；
>
> 例如二进制表示1，00000001，需要使用十六位则表示为 0000000000000001，高位全补0

零位拓展

> 无论高位多少，拓展后全补0

**有符号数向其他类型进行转换时，需要用到符号位拓展；无符号数向其他类型进行转换时，使用零位拓展。**

### 二进制相关知识

`原码`：对于二进制值，最高位为符号位，0表示正数，1表示负数，剩余部分表示正值。

`补码`：对于二进制值，正数的补码为本身；负数的补码除符号位按位取反，末位加一。

`反码`：对于二进制值，正数的反码为本身；负数的反码除符号位按位取反。

**负数的二进制为 正数的补码= 正数的反码+1**

**补码还原原码为 补码的补码为原码**

例 `byte a = (byte)300;` 按照上述规则

- 300转换二进制为`01 1001 0000`
- 截取低八位为`1001 0000`
- 转换补码为 `1111 0000`为`-112`

| 基本类型 | 占字节数 | 最小值  | 最大值  |
| -------- | -------- | ------- | ------- |
| boolean  |          |         |         |
| char     | 16bit    |         |         |
| byte     | 8bit     | -2^7    | 2^7-1   |
| short    | 16bit    | -2^15   | 2^15-1  |
| int      | 32bit    | -2^31   | 2^31-1  |
| long     | 64bit    | -2^63   | 2^63-1  |
| float    | 32bit    | IEEE754 | IEEE754 |
| double   | 64bit    | IEEE754 | IEEE754 |
| void     | -        |         |         |



## 参考链接

[字节码指令](http://gityuan.com/2015/10/24/jvm-bytecode-grammar/)

[Java二进制指令代码解析](http://www.blogjava.net/DLevin/archive/2011/09/13/358497.html)

[java虚拟机 JVM字节码 指令集 bytecode 操作码 指令分类用法 助记符](https://www.cnblogs.com/noteless/p/9556928.html)

[Jvm官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10.1.9.monitorenter)]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-红黑树</title>
    <url>/2018/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[
<!--二叉平衡树的区别，好处有哪些，红黑树的节点增删...不会-->

]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树</title>
    <url>/2018/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    <content><![CDATA[


## 二叉树

> 每个节点最多只能有两个子节点，

## 排序二叉树



## 平衡二叉树（AVL树）



## B树、B+树



## 红黑树



## N叉树



## 参考链接

[红黑树](https://juejin.im/post/5df4aaefe51d45581269a6d2)]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal原理分析</title>
    <url>/2018/12/09/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
# ThreadLocal详解

> 在前几节Handler详解中介绍 如何获取Looper对象时提及了是利用ThreadLocal来进行Looper的存储与获取。

{% fullimage /images/ThreadLocal解析.png,ThreadLocal解析,ThreadLocal解析%}

## 1.初步理解ThreadLocal

ThreadLocal的定义为：**用于提供线程变量，在多线程环境中可以保证各个线程的变量独立于其他线程里的变量。**主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量不会互相干扰，适用于`高并发状态下实现无状态的调用即各个线程依赖不同的变量完成操作`。

ThreadLocal的另一个使用场景是**复杂逻辑下的对象传递**。

> ThreadLocal保证的是多线程环境下的独立性，同步机制则保证多线程下数据的一致性。

## 2.使用样例

```java
public class ThreadLocalTest {
    private static String label;
    private static ThreadLocal<String> threadLocal = new ThreadLocal<>();

    public static void main(String[] args) {
        label = "main";
        threadLocal.set("main");
        //new Thread
        Thread thread = new Thread() {
            @Override
            public void run() {
                super.run();
                label = "new";
                threadLocal.set("new");
            }
        };
        thread.start();

        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.err.println("label = " + label);
        System.err.println("threadLocal = " + threadLocal.get());
    }
}

//console.log
label = new
threadLocal = main
```

对于ThreadLocal中的变量，在一个线程中修改它的值，并不会影响到在其他线程中的值。**ThreadLocal中的值在每个线程中都是独立的。**

## 3.深入理解ThreadLocal

ThreadLocal类中提供了以下几个方法来进行变量的操作：

- `public T get()`获取ThreadLocal在当前线程中保存的变量副本
- `public void set(T value)`设置当前线程中的变量副本
- `public void remove()`移除当前线程中的变量副本
- `protected T initialValue()`设置ThreadLocal的初始值，该方法为延迟加载

接下来具体查看上述方法的内部实现。加深理解

### `get()`

```java
//返回当前线程中存储的变量副本
public T get() {
        //获取当前线程
        Thread t = Thread.currentThread();
        //获取到持有变量副本的map
        ThreadLocalMap map = getMap(t);
        //map存在则返回存储值
        if (map != null) {
            //该map key为ThreadLocal 故获取value用的是this
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        //不存在则返回默认值
        return setInitialValue();
    }
```

### `set(T value)`

```java
//设置当前线程的变量副本
public void set(T value){
   Thread t = Thread.currentThread();
   ThreadLocalMap map = getMap(t);
    //map不为null 则保存value
    if(map!=null){
        map.set(this,value);
    }
    //否则创建一个ThreadLocalMap后保存value
    else{
        createMap(t,value);
    }
}
```

### `remove()`

```java
//移除保存的变量副本
public void remove(){
    ThreadLocalMap map = getMap(Thread.currentThread);
    //map不为空 则移除当前ThreadLocal对应的变量副本
    if(map!=null)
        map.remove(this);
}
```

### `initialValue()`

```java
//子类可重写该方法 进行默认值的设置
protected T initialValue() {
        return null;
    }

对应有setInitialValue()
private T setInitialValue(){
   T value = initialValue();
   Thread t = Thread.currentThread();
   ThreadLocalMap map = getMap(t);
    if(map!=null){
        map.set(this,value);
    }else{
        createMap(t,value);
    }
    return value;
}
```

在上述四个方法中都会涉及到一个类**`ThreadLocalMap`**，该类是ThreadLocal的核心机制实现。`在使用ThreadLocal的方法对存储变量进行操作时都需要获得当前线程对应的ThreadLocalMap来对变量进行操作`。**每个线程都会有专属的ThreadLocalMap，其中维护的value也是对应当前线程的。就保证了ThreadLocal中存储的变量都是相互独立的，不会受到多线程环境的影响。**

### **`ThreadLocalMap`**

> 该类为ThreadLocal中的内部类，没有实现Map接口，内部自己实现了Map的功能。

1. 构造方法

   ```java
    ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
               table = new Entry[INITIAL_CAPACITY];
               int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
               table[i] = new Entry(firstKey, firstValue);
               size = 1;
               setThreshold(INITIAL_CAPACITY);
           }
   ```

2. 初始对象

   ```java
   // 初始容量，必须是 2 的幂
   private static final int INITIAL_CAPACITY = 16;
   
   // 存储数据的哈希表
   private Entry[] table;
   
   // table 中已存储的条目数
   private int size = 0;
   
   // 表示一个阈值，当 table 中存储的对象达到该值时就会扩容
   private int threshold;
   
   // 设置 threshold 的值
   private void setThreshold(int len) {
       threshold = len * 2 / 3;
   }
   ```

   由内部实现了一套Map机制

3. Entry

   > table中存储的都为Entry对象，用于保存K-V数据结构

   ```java
           static class Entry extends WeakReference<ThreadLocal<?>> {
               /** The value associated with this ThreadLocal. */
               Object value;
   
               Entry(ThreadLocal<?> k, Object v) {
                   super(k);
                   value = v;
               }
           }
   ```

   Entry继承自`WeakRefrence<ThreadLocal<?>>`为弱引用类型并且限制了`K`只能为ThreadLocal对象，但是对应的`V`为强引用类型，则可能导致**内存泄漏**。

4. 保存key-value

   ```java
   //调用set方法将 key-value类型进行存储
   private void set(ThreadLocal<?> key, Object value) {
   
               // We don't use a fast path as with get() because it is at
               // least as common to use set() to create new entries as
               // it is to replace existing ones, in which case, a fast
               // path would fail more often than not.
   
               Entry[] tab = table;
               int len = tab.length;
               //计算要存储的索引位置
               int i = key.threadLocalHashCode & (len-1);
               //判断要存储的索引位置是否已经存在Entry 存在则继续向下
               for (Entry e = tab[i];
                    e != null;
                    e = tab[i = nextIndex(i, len)]) {
                   ThreadLocal<?> k = e.get();
                   //key相同则更新
                   if (k == key) {
                       e.value = value;
                       return;
                   }
                   //key为空 代表该位置对应的Entry已失效，需要直接进行替换
                   if (k == null) {
                       replaceStaleEntry(key, value, i);
                       return;
                   }
               }
               //若不存在 则将Entry保存到该位置
               tab[i] = new Entry(key, value);
               int sz = ++size;
               //超过当前负载 则需进行扩容机制 重新调整table
               if (!cleanSomeSlots(i, sz) && sz >= threshold)
                   rehash();
           }
   ```

   使用当前的ThreadLocal中对应的threadLocalHashCode来计算该键值对要存储的索引位置。该值是由ThreadLocal对象自动生成的，创建时就会进行赋值。

   ```java
   private final int threadLocalHashCode = nextHashCode();
   
       /**
        * The next hash code to be given out. Updated atomically. Starts at
        * zero.
        * 使用AtomicInteger用来保证多线程环境下不会受到影响
        */
       private static AtomicInteger nextHashCode =
           new AtomicInteger();
   
       /**
        * The difference between successively generated hash codes - turns
        * implicit sequential thread-local IDs into near-optimally spread
        * multiplicative hash values for power-of-two-sized tables.
        */
       private static final int HASH_INCREMENT = 0x61c88647;
   
       /**
        * Returns the next hash code.
        */
       private static int nextHashCode() {
           return nextHashCode.getAndAdd(HASH_INCREMENT);
       }
   
   ```

   当table中的条目超出阈值时就需要进行扩容

   ```java
   //扩容是 新table的容量为原先的两倍 触发条件为table中的条目数超出了阈值的3/4
   private void resize(){
       Entry[] oldTab = table;
       int oldLen = oldTab.length;
       int newLen = oldLen * 2;
       Entry[] newTab = new Entry[newLen];
       int count = 0;
       for(int j = 0;j<oldLen;++j){
           Entry e = oldTab[j];
           if(e!=null){
              ThreadLocal<?> k =e.get();
               if(k == null){
                   e.value = null;
               } else{
                   //重新计算扩容后的Hash值
                   int h = k.threadLocalHashCode & (newLen - 1);
                   while(newTab[h]!=null){
                       h = nextIndex(h,newLen);
                   }
                   newTab[h] = e;
                   count ++;
               }
           }
       }
       //重新设定当前容量
       setThreshold(newLen);
       size = count;
       table = newTab;
   }
   ```

5. 获取Entry对象

   ```java
   //根据传递进来的ThreadLocal 获取对应的entry
   private Entry getEntry(ThreadLocal<?> key) {
              //重新计算threadLocal对应的index
               int i = key.threadLocalHashCode & (table.length - 1);
               Entry e = table[i];
               if (e != null && e.get() == key)
               //entry不为空且对应位置key相同 则返回Entry
                   return e;
               else
               //否则 寻找临近的位置是否存在对应的值
                   return getEntryAfterMiss(key, i, e);
           }
   
   private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {
       Entry[] tab = table;
       int len = tab.length;
       //当前传递的entry不为空 则开始循环
       while (e != null) {
           ThreadLocal<?> k = e.get();
           if (k == key)
               //相同则返回对应的 entry
               return e;
           if (k == null)
               //key消失 则移除对应的Entry
               expungeStaleEntry(i);
           else
               //继续向下寻找
               i = nextIndex(i, len);
           e = tab[i];
       }
       return null;
   }
   ```

   调用`getEntryAfterMiss()`时，大部分由于哈希冲突(`Hash slot`)导致的。由于ThreadLocalMap没有使用链表的方式实现,所以解决Hash冲突的方式也只能使用一种**线性探测**的方式。`线性探测意为根据初始key的hashcode来确定元素在表中的位置，若发现位置已被占用，则会利用固定算法找到下一个位置，直到找到可以存放的位置。`

   ThreadLocalMap解决Hash冲突的方法就是 `步长+1或-1`,寻找下一个相邻的位置。

6. 移除指定的Entry

   ```java
   //根据threadLocal移除对应位置的Entry
   private void remove(ThreadLocal<?> key) {
       Entry[] tab = table;
       int len = tab.length;
       int i = key.threadLocalHashCode & (len-1);
       for (Entry e = tab[i];
            e != null;
            e = tab[i = nextIndex(i, len)]) {
           if (e.get() == key) {
               e.clear();
               expungeStaleEntry(i);
               return;
           }
       }
   }
   ```

7. 其他知识点

   在上述`set(),get(),remove()`方法中都涉及到了一个点，都会去进行一次判断当前位置的Entry是否无效并清除的操作，主要是为了**降低内存泄漏发生的可能性**。

   上面分析中就有提到ThreadLocalMap的key为弱引用型，而value为强引用型，就可能导致内存泄漏发生。

   **所以当我们使用ThreadLocal时，每次使用完毕都需要主动调用一次remove()方法来防止内存泄漏的发生。**

## 4.实现原理

在每个`Thread`中维护一个`ThreadLocalMap`，存储中的key为`ThreadLocal`对象本身，value是需要存储的对象。

这样设计的好处在于

- `ThreadLocalMap`中存储的`Entry`数量会变少，数量由`ThreadLocal`对象的个数来决定。
- `Thread`销毁后其内部的`ThreadLocalMap`也会一并销毁，减少内存的使用。

## 拓展

### ThreadLocal与synchronized的区别

`ThreadLocal`是一个Java类，通过对当前线程中的局部变量的操作来解决不同线程间的变量访问问题。每个线程都拥有自己的变量副本。**空间换时间**

`synchronized`是一个关键字，依靠JVM中的锁机制`monitor`来实现变量访问的原子性。保证的是同一时间只有一个线程可以访问变量。**时间换空间**

### InheritableThreadLocal

> `ThreadLocal`中变量副本是线程私有的即其他线程无法对其进行访问。`InheritableThreadLocal`是可以支持**在子线程中访问到父线程的变量副本**。

```java
 private static ThreadLocal<String> threadLocal = new ThreadLocal<>();
private static InheritableThreadLocal<Integer> integerInheritableThreadLocal =
            new InheritableThreadLocal<>();

    public static void main(String[] args) {
        threadLocal.set("main");
        integerInheritableThreadLocal.set(123);

        Thread thread = new Thread() {
            @Override
            public void run() {
                super.run();
                System.err.println("threadLocal "+ threadLocal.get());
                System.err.println("inheritableThreadLocal "+ integerInheritableThreadLocal.get());
            }
        };
        thread.start();

        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

运行结果：
threadLocal null
inheritableThreadLocal 123
```

实现原理：

在线程进行初始化时，子线程会拷贝父线程的`inheritableThreadLocals`到自己的变量中，故调用`get()`时，会读取到父线程所存储的变量副本。



## 总结

- 每个ThreadLocal中只能保存一个变量副本，如果需要多个则需创建多个ThreadLocal
- 由于ThreadLocal内部中ThreadLocalMap的key实现为弱引用，可能导致内存泄漏，使用完成后需要及时调用`remove()`来避免泄漏
- 使用ThreadLocal时，需要先`set()`再`get()`避免发生空指针异常，若重写了`initialValue()`该方法，则没问题
- ThreadLocal的适用场景为无状态且副本变量独立后不影响业务逻辑的高并发场景。

## 内容引用

[JAVA并发-自问自答学ThreadLocal](https://www.jianshu.com/p/807686414c11)

[ThreadLocal解析](<https://juejin.im/post/5c72805651882562276c49d6>)

]]></content>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字节码学习</title>
    <url>/2019/09/24/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[
<!-- https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html https://juejin.im/post/5d884c766fb9a06ae76444dc https://www.cnblogs.com/zzlove2018/p/9097885.html -->



{% fullimage /images/字节码结构大纲.png,字节码结构大纲,字节码结构大纲%}

<!-- more -->

> Java的最大特性——**一次编译，到处运行**。Java的`跨平台性`非常强大，如此强大的`跨平台性`主要依赖了两部分：**JVM（执行器）**、**字节码**。
>
> `JVM`：主要是翻译功能，将`字节码`翻译成对应平台的计算机指令。
>
> `字节码`：Java源代码拓展名为`.java`经过编译后变成`.class`文件，该文件中包含的内容就是`字节码`。
>
> 现在大热的`Kotlin`也是通过最终编译成`字节码`实现了与Java的兼容性。

{% fullimage /images/Java运行流程.png,字节码执行过程,字节码执行过程%}

`字节码`由`十六进制值`组成，JVM以字节为单位进行读取。如上图所示，通过Java编译器(`javac`)编译后得到了`.class`文件，里面包含的就是字节码，可通过`javap -verbose`获得完整字节码文件。

获得字节码文件后，就需要交由JVM进行加载。

## JVM类加载机制

{% post_link JVM相关及其拓展-二%}



## 字节码结构分析

先编写一个简单的Java文件，用以分析字节码的基本结构，后续通过拓展方法来展现其他字节码结构。

```java
public class BytecodeDemo {
    int a = 1;
    public static void main(String[] args){
        System.out.println("Hello World");
    }
}

```

通过`javac`编译该类，得到`BytecodeDemo.class`

使用例如`010Editor`或者`VSCode(安装hexdump for VSCode插件)`就可以查看`.class`文件原始代码。

{% fullimage /images/BytecodeDemo字节码.png,字节码,字节码%}

图片中就是一堆十六进制数并按字节为单位进行分割。这些十六进制符号长串是遵守[Java虚拟机规范](https://github.com/waylau/java-virtual-machine-specification)的。

下列结构全部是有规范的，此处规范[参考网址](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html)

### 魔数(magic)

> 占4个字节(u4)，且为固定值**0xCAFEBABE**。用于校验字节码文件是否符合虚拟机规范，符合继续执行。

### 版本号(version)

#### 次版本号(minor_version)

> 占两个字节(u2)，表示**生成字节码文件的次版本号**。

上图中为`0x0000`

#### 主版本号(major_version)

> 占两个字节(u2)，表示**编译该字节码文件的Java版本**，`低版本的虚拟机是无法运行高版本的字节码文件，但高版本虚拟机是兼容低版本编译的字节码文件。`

上图中为`0x0034`。对应实际的Java版本就为`JDK 1.8`

查询本机Java版本号为`java version "1.8.0_181"`符合上述描述。

### *常量池(constant_pool)

#### 常量池数(constant_pool_count)

> 占两个字节(u2)，表示**常量池中常量的数目**

上图中为`0x0026`，转换得到`38`。实际上常量数目为`37`。由于特殊的规定，第0位可以表示**类或接口中未出现的引用**。



#### *常量池数组(constant_pool[])

跟在`常量池数(0x0026)`后面的就是`常量池数组`

> 由`constant_pool_count-1`个`cp_info`结构组成，一个`cp_info`对应一个常量，规范规定了总共有14种类型。

```java
//cp_info结构
cp_info{
   u1 tag;
   u1 info[];
}
```

共14种类型如下：

{% fullimage /images/常量池类型.png,常量池结构,常量池结构%}



`BytecodeDemo`字节码解析出的常量池数据如下：

```java
Constant pool:
   #1 = Methodref          #12.#41        // java/lang/Object."<init>":()V
   #2 = Fieldref           #11.#42        // BytecodeDemo.a:I
   #3 = Fieldref           #43.#42        // LruCache.a:I
   #4 = Fieldref           #11.#44        // BytecodeDemo.b:I
   #5 = Fieldref           #11.#45        // BytecodeDemo.c:I
   #6 = Fieldref           #46.#47        // java/lang/System.out:Ljava/io/PrintStream;
   #7 = String             #48            // Hello World
   #8 = Methodref          #49.#50        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #9 = Methodref          #11.#51        // BytecodeDemo.getResult:(II)I
  #10 = Methodref          #12.#52        // java/lang/Object.clone:()Ljava/lang/Object;
  #11 = Class              #53            // BytecodeDemo
  #12 = Class              #54            // java/lang/Object
  #13 = Class              #55            // java/lang/Cloneable
  #14 = Class              #56            // java/io/Serializable
  #15 = Utf8               a
  #16 = Utf8               I
  #17 = Utf8               b
  #18 = Utf8               c
  #19 = Utf8               <init>
  #20 = Utf8               ()V
  #21 = Utf8               Code
  #22 = Utf8               LineNumberTable
  #23 = Utf8               LocalVariableTable
  #24 = Utf8               this
  #25 = Utf8               LBytecodeDemo;
  #26 = Utf8               main
  #27 = Utf8               ([Ljava/lang/String;)V
  #28 = Utf8               args
  #29 = Utf8               [Ljava/lang/String;
  #30 = Utf8               getResult
  #31 = Utf8               (II)I
  #32 = Utf8               x
  #33 = Utf8               y
  #34 = Utf8               test
  #35 = Utf8               clone
  #36 = Utf8               ()Ljava/lang/Object;
  #37 = Utf8               Exceptions
  #38 = Class              #57            // java/lang/CloneNotSupportedException
  #39 = Utf8               SourceFile
  #40 = Utf8               BytecodeDemo.java
  #41 = NameAndType        #19:#20        // "<init>":()V
  #42 = NameAndType        #15:#16        // a:I
  #43 = Class              #58            // LruCache
  #44 = NameAndType        #17:#16        // b:I
  #45 = NameAndType        #18:#16        // c:I
  #46 = Class              #59            // java/lang/System
  #47 = NameAndType        #60:#61        // out:Ljava/io/PrintStream;
  #48 = Utf8               Hello World
  #49 = Class              #62            // java/io/PrintStream
  #50 = NameAndType        #63:#64        // println:(Ljava/lang/String;)V
  #51 = NameAndType        #30:#31        // getResult:(II)I
  #52 = NameAndType        #35:#36        // clone:()Ljava/lang/Object;
  #53 = Utf8               BytecodeDemo
  #54 = Utf8               java/lang/Object
  #55 = Utf8               java/lang/Cloneable
  #56 = Utf8               java/io/Serializable
  #57 = Utf8               java/lang/CloneNotSupportedException
  #58 = Utf8               LruCache
  #59 = Utf8               java/lang/System
  #60 = Utf8               out
  #61 = Utf8               Ljava/io/PrintStream;
  #62 = Utf8               java/io/PrintStream
  #63 = Utf8               println
  #64 = Utf8               (Ljava/lang/String;)V
```



##### 方法符号引用(CONSTANT_Methodref_info)

> 可用于表示**方法信息包含调用类、名称，入参及返回值类型**
>
> 由三部分组成：
>
> tag(偏移地址): 占1字节 **0x0A**
>
> index(类或接口描述符索引) : 占2字节 例`00 07`
>
> index(名称和类型描述符索引)：占2字节 例`00 17`

字节码文件解析出的整段格式为 `0A 00 07 00 17`

对应常量池 就为 #7，#23 最终执行的是`BytecodeDemo`初始化方法



##### 类或接口符号引用(CONSTANT_Class_info)

> 可用于表示**类的全限定名**
>
> 由两部分组成：
>
> tag(偏移地址): 占1字节 **0x07**
>
> index(全限定名常量项索引) : 占2字节 例`00 1E`

字节码文件解析出的整段格式为 `07 00 1E`

对应常量池 就为 #31 指向`java/lang/Object`



##### 名称和类型描述符索引(CONSTANT_NameAndType_info)

> 可用于表示**方法的名称、入参及返回值类型**
>
> 由三部分组成：
>
> tag(偏移地址): 占1字节 **0x0C**
>
> index(字段或方法 名称常量项索引--常量信息描述符索引) : 占2字节 例`00 0A`
>
> index(字段或方法 描述符索引--常量信息描述符索引)：占2字节 例`00 0B`

字节码文件解析出的整段格式为 `0C 00 0A 00 0B`

对应常量池为 #10 #11 表示 `<init> V`



##### 常量信息描述符索引(CONSTANT_Utf8_info)

> 可用于表示：**文本字符串、类或接口全限定名、字段名称和描述符，方法名称及描述符等常量信息。**
>
> 由三部分组成：
>
> tag(偏移地址): 占1字节 **0x01**
>
> length(字符串长度)：占2字节
>
> bytes(字符串内容)：占`length`字节

字节码文件解析出的整段格式为 `01 00 0B 48 65 6C 6C 6F 20 57 6F 72 6C 64`

字符串长度为11位，对应内容为`Hello World`



##### 参数信息描述符索引(CONSTANT_Fieldref_info)

> 可用于表示**类中的全局变量以及引用其他类中的参数信息**
>
> 由三部分组成：
>
> tag(偏移地址): 占1字节 **0x09**
>
> index(类或接口描述符索引)：占2字节 例`00 06`
>
> index(名称和类型描述符索引)：占2字节 例`00 18`

字节码文件解析出的整段格式为`09 00 06 00 18`

对应内容为：`ByteDemo.a(I)`



### 类访问标志(access_flags)

> 占2字节，紧随`常量池`结构。可用于**表示类或者接口层次的访问信息——Class是类还是接口，是否定义为public，是否为abstract类型。**

具体的标志位以及标志描述如下：

| 类修饰标志     | 标志值 | 描述                                  |
| -------------- | ------ | ------------------------------------- |
| ACC_PUBLIC     | 0x0001 | public类型                            |
| ACC_PRIVATE    | 0x0002 | private类型                           |
| ACC_PROTECTED  | 0x0004 | protected类型                         |
| ACC_STATIC     | 0x0008 | static类型                            |
| ACC_FINAL      | 0x0010 | final类型，表示类不允许被继承         |
| ACC_SUPER      | 0x0020 | 是否允许使用`invokespecail`字节码指令 |
| ACC_INTERFACE  | 0x0200 | 表示该class为一个接口                 |
| ACC_ABSTRACT   | 0x0400 | 表示抽象类                            |
| ACC_SYNTHETIC  | 0x1000 | 这个类不是由用户代码生成              |
| ACC_ANNOTATION | 0x2000 | 表示为注解类型                        |
| ACC_ENUM       | 0x4000 | 表示为枚举类型                        |

**实际的访问标志多是由上述几个标志进行` 或运算`组合而成。**

字节码文件紧随常量池数组后的为 `0x0021`，在上表中无法找出对应的标志，结果是由`ACC_PUBLIC，ACC_SUPER`组合得到。

当前对应的是类所设置的访问标志，后面会讲到`参数(field_info) 、方法(method_info)`中的访问标志，与类中会有些许不同。

### 当前类索引(this_class)

> 占2个字节，指向类的全限定名

字节码文件解析出`00 06`，指向了#6 BytecodeDemo

### 父类索引(super_class)

> 占2个字节，指向父类的全限定名

字节码文件解析出`00 07`，指向了#7 java/lang/Object

### 接口索引(interfaces)

{% fullimage /images/字节码-接口索引结构.png,字节码-接口索引结构,字节码-接口索引结构%}

> 可用于表示**类或接口引用到的接口信息**
>
> 由两部分组成：
>
> interfaces_count(接口引用数量)：占2字节 例`00 02`
>
> interfaces[interfaces_count] (接口名称常量索引)：占2*interfaces_count字节 例`00 0D 00 0E`

```java
.... 
#13 = Class              #55            // java/lang/Cloneable
#14 = Class              #56            // java/io/Serializable
```

字节码文件解析出`00 02 00 0D 00 0E`

对应内容为类实现了`Cloneable、Serializable`两个接口

### 字段表集合(fields)

{% fullimage /images/字节码-字段表结构.png,字节码-字段表结构,字节码-字段表结构%}

> 可用于表示**类或接口声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量**
>
> 由两部分组成：
>
> fields_count(字段个数)：占2字节 例`00 03`
>
> fields[fields_count] (字段信息)：占n字节，由fields_count个`field_info`组成

```java
field_info{
  u2          		access_flags;
  u2          		name_index;
  u2          		descriptor_index;
  u2          		attributes_count;
  attribute_info	attributes[attributes_count];
}
```

#### 字段访问标志(access_flags)

与上面的`类访问标志`相比基本是一致的，除了以下几项是字段所特有的

| 字段访问标志  | 标志值 | 描述                                                         |
| ------------- | ------ | ------------------------------------------------------------ |
| ACC_VOLATILE  | 0x0040 | 表示volatile，可实现`可见性、有序性`<br>不能完全实现`原子性` |
| ACC_TRANSIENT | 0x0080 | 不参与序列化过程                                             |
| ACC_ENUM      | 0x4000 | 表示 该字段为枚举的一个值                                    |

字节码文件解析出数据为`00 00`,为默认标志

#### 字段名称索引(name_index)

>  占2字节，指向常量池中`CONSTANT_Utf8_info`中的有效索引，表示字段名称

字节码文件解析出数据为`00 0F`，为`a`

#### 字段描述符索引(descriptor_index)

> 占2字节，指向常量池中`CONSTANT_Utf8_info`中的有效索引，表示字段属性

字节码文件解析出数据为`00 10`，为`I`

#### 字段额外属性个数(attributes_count)

> 占2字节，表示字段额外属性个数

字节码文件解析出数据为`00 00`，为0

#### 字段额外属性列表(attributes[attributes_count])

> 占n字节，描述字段的额外属性

字节码文件未解析出该字段

`field_info`支持的额外属性格式如下：

##### 常量值(ConstantValue)

> 由`static、final`关键字定义的常量值，在class文件中才有这个属性。

在类加载过程的`准备`阶段时，会直接由设置的值进行初始化，而不使用默认值，仅限`基本数值类型和String`。

```java
ConstantValue_attribute{
 u2 attribute_name_index;//固定 ConstanValue
 u4 attribute_length;
 u2 constantvalue_index;
}
```

###### 属性名称索引(attribute_name_index)

> 占2字节，指向常量池中`CONSTANT_Utf8_info`中的有效索引，表示属性名称

解析为`00 14`，指向#20 表示`ConstantValue`

###### 属性长度(attribute_length)

> 占4字节，值必定为`00 00 00 02`，表示2

###### 常量值索引(constantvalue_index)

> 占2字节，指向常量池中中的有效索引，表示常量值数值

解析为`00 15`，指向#21，表示了`Integer 3`，即常量值为3

| 字段类型                    | 常量池中类型     |
| --------------------------- | ---------------- |
| long                        | CONSTANT_Long    |
| float                       | CONSTANT_Float   |
| double                      | CONSTANT_Double  |
| int,short,char,byte,boolean | CONSTANT_Integer |
| String                      | CONSTANT_String  |



列举出字节码文件中的一部分字段表信息

```java
00 18 | 00 13 | 00 10 | 00 01 | 00 14 00 00 00 02 00 15
表示为
static final int d = 3
```



### 方法表集合(methods)

{% fullimage /images/字节码-方法表结构.png,字节码-方法表结构,字节码-方法表结构%}

> 可用于表示**类或接口中的方法**
>
> 由两部分组成：
>
> methods_count(方法个数)：占2字节，例如`00 05`
>
> methods[methods_count] (方法信息)：占n字节，由methods_count个`method_info`组成

```java
method_info{
  u2          		access_flags;
  u2          		name_index;
  u2          		descriptor_index;
  u2          		attributes_count;
  attribute_info	attributes[attributes_count];
}
```

#### 方法访问标志(access_flags)

相比于`类访问标志`，多了几项`方法访问标志`

| 字段访问标志     | 标志值 | 描述                                                         |
| ---------------- | ------ | ------------------------------------------------------------ |
| ACC_SYNCHRONIZED | 0x0020 | 方法为`synchronized`类型的，将方法包入到`monitor`中          |
| ACC_BRIDGE       | 0x0040 | 为桥接方法，是编译后自动生成的方法<br>在使用泛型时，编译器自动生成桥接方法用于校验泛型转换实际类型 |
| ACC_VARARGS      | 0x0080 | 声明了可变数量的参数                                         |
| ACC_NATIVE       | 0x0100 | 声明Native方法，不是由Java语言实现的                         |

字节码文件解析出数据为`00 01`,表示`public`

#### 方法名称索引(name_index)

> 占2字节，指向常量池中`CONSTANT_Utf8_info`中的有效索引，表示方法名称

字节码文件解析出数据为`00 13`,指向#19 ,表示`<init>`——初始化方法

#### 方法描述符索引(descriptor_index)

> 占2字节，指向常量池中`CONSTANT_Utf8_info`中的有效索引，表示方法属性

字节码文件解析出数据为`00 14`，指向#20,表示`()V`——没有入参，返回参数类型为`void`

#### 方法额外属性个数(attributes_count)

> 占2字节，表示方法额外属性个数

字节码文件解析出数据为`00 01`，有1个额外属性

#### 方法额外属性列表(attributes[attributes_count])

> 占n字节，描述方法的额外属性信息

字节码文件解析出的数据为`00 15`，指向`Code`

##### *Code

> 描述`method_info`相关信息，**method_info必有一个该属性，除了`native和abstract修饰的方法`**。
>
> `Code_attribute`组成了`Code`。

```java
Code_attribute{
 u2 attribute_name_index;//常量池索引，表示额外属性名称，此处为`Code`
 u4 attribute_length;
 u2 max_stack;//???
 u2 max_locals;//
 u4 code_length;//JVM操作指令个数 0<code_length<65535
 u1 code[code_length];//操作指令信息
 u2 exception_table_length;//异常集合长度
  {
    u2 start_pc;
    u2 end_pc;
    u2 handler_pc;
    u2 vatch_type;
  } exception_table[exception_table_length];
  u2 attributes_count;//Code内部属性个数
  attribute_info attributes[attribute_count];
}
```

###### 属性长度(attribute_length)

> 属性值长度，需要排除`attribute_name_index`以及`attribute_length`6个字节长度，其他的累加起来就得到结果。

###### 最大栈深度(max_stack)

> 最大操作数栈，

###### *局部变量最大空间数(max_locals)

> 描述当前方法的局部变量表。单位为`slot`,`long,double`占两个`slot`，其他类型都占一个`slot`

###### 操作指令集(code[])

> 表示当前方法编译后的字节码操作指令集合

主要内容参照 {% post_link Java字节码学习-操作指令%}

###### 异常表集合(exception_table[])

> 表示当前方法需要声明抛出的异常类型
>
> exception_info{
>  u2 start_pc; //异常判断包裹的起始位置(字节码行号) 指向try{
>  u2 end_pc; //异常判断包裹的结束位置(字节码行号) 指向}catch 不包含该位置
>
>  u2 handler_pc;//异常捕获时 处理的位置(字节码行号)
>  u2 catch_type;//捕获的异常类型 若不为0 则表示为 常量池中对应的索引位置 ；为0则表示 是任意 Throwable
> }

一个方法可以抛出的异常类型遵循三点：

- 抛出的异常是`RuntimeException`类型或其子类
- 抛出的异常是`Error`类型或其子类
- 抛出的异常是`Exception`类型或其子类

###### Code中额外属性(attributes[attributes_size])

> Code区块中的额外属性：主要有以下三种

- 行号表(LineNumberTable)

  > 将Code区的字节码操作指令与源代码行号对应，可以在Debug时定位对应源代码。

- 本地变量表(LocalVariableTable)

  > 包含This和局部变量，之所以每一个方法内部都可以调用this，是因为JVM将this作为方法的第一个参数隐式传入。**若为static方法就没有该特性**

- 栈表(StackMapTable)

  > 提高JVM在类型检查的验证过程的效率

  


### 属性表集合(attributes)

> 存放了在该文件中类或接口定义属性的基本信息
>
> attribute_info {
>
>  u2 attribute_name_index; //属性名称
>
>  u4 attribute_length; //属性值的字节长度
>
>  u1 info[attribute_length]; //属性的详细信息
>
> }

常用额外属性如下，按照可使用场景区分

| 属性               | 含义                                                         | 使用位置                               |
| ------------------ | ------------------------------------------------------------ | -------------------------------------- |
| SourceFile         | 记录和当前字节码对应的源代码文件                             | ClassFile                              |
| InnerClasses       | 记录当前类的所有内部类，包括在方法中定义的内部类             | ClassFile                              |
| EnclosingMethod    | 当且仅当一个类是匿名类或者本地类，该类才会包含该属性         | ClassFile                              |
| ConstantValue      | 每个常量字段(final，静态或实例常量)会包含该属性              | field_info                             |
| Code               | 包含一个方法的栈、局部变量，字节码以及与代码相关属性<br>不会在`abstract`,`native`方法中出现 | method_info                            |
| Exceptions         | 记录方法需要检查的异常类型                                   | method_info                            |
| Depreated          | 表示一种弃用状态                                             | ClassFile<br>method_info<br>field_info |
| LineNumberTable    | 获取字节码指令所对应的源码行号                               | Code                                   |
| LocalVariableTable | 获取方法运行时的局部变量                                     | Code                                   |
| StackMapTable      | 记录类型检查时需要用到的信息，如字节码的偏移量、局部变量的验证类型等 | Code                                   |



## 字节码操作指令

{% post_link Java字节码学习-操作指令%}



##  字节码应用

{% post_link Java字节码学习-应用场景%}



## 附录

### 描述符(Descriptor)

> 定义了字段或方法的类型。
>
> *A *descriptor* is a string representing the type of a field or method. Descriptors are represented in the `class` file format using modified UTF-8 strings*

#### 字段描述符(Field Descriptor)

> 定义了`字段、局部变量、返回参数等类型`的字符串，由`FieldType`组成

主要分为以下三种：

##### 基本类型（BaseType）

| 基本类型 | 对应字符 |
| -------- | -------- |
| byte     | B        |
| char     | C        |
| double   | D        |
| float    | F        |
| int      | I        |
| long     | J        |
| short    | S        |
| boolean  | Z        |

例如：I => int



##### 对象类型（ObjectType）

**L${fullClassName};**

例如：Ljava/lang/Object => Object;

嵌套表达：Ljava/util/List<Ljava/lang/String;>; => List&lt;String&gt;

##### 数组类型（ArrayType）

**[${BaseType}** **[${ObjectType}**

例如：[java/lang/String => String[]

嵌套表达：[[I => int[][]



#### 方法描述符(Method Descriptor)

> 定义了`方法参数、方法返回等信息`的字符串

**(${ParameterDescriptor}) ${ReturnDescriptor}**

##### 参数描述符（ParameterDescriptor）

由`FieldType`组成

##### 返回值描述符（ReturnDescriptor）

由`FieldType`组成或者`VoidDescriptor(代指void)`

例如：(IJD)V => void (int a,long b,double c)

## 参考链接

[The class File Format](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4)

[字节码增强技术探索](https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html)

[认识class文件的字节码结构](https://www.jianshu.com/p/e5062d62a3d1)

[字节码格式详解](http://www.blogjava.net/DLevin/archive/2011/09/05/358034.html)]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用指令及作用(速查)</title>
    <url>/2019/12/06/Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[
## log 
git log //显示提交信息
git log --oneline //简要日志输出
git log --oneline -5 //输出最近5次提交日志

## status
git status //显示当前git状态
git status -s //简要信息

git push origin HEAD:refs/for/master //推送代码

## tag
git tag //列举标签

git tag  version //给提交设置标签
git push origin ​version //推送设置标签的动作

## checkout
git checkout //切换分支
git checkout dev //切换本地分支
git checkout remote/master //切换远程分支
git checkout --track origin/master //基于远程分支创建本地分支并跟踪
git checkout -b dev //基于本地分支 创建新分支

## commit
git commit -m "XXX" //提交概要信息
git commit --amend //编辑提交信息
git commit --amend --no-edit //跳过编辑直接提交
git commit --no-verify -m "XXX" //跳过校验直接提交

## reset
git reset --hard commit_sha1 //丢弃回滚提交前的所有改动
git reset --soft commit_sha1 //回滚提交前的改动放回暂存区与工作区
git reset --mixed commit_sha1 //回滚提交前的改动放回工作区并清空暂存区

## revert
git revert commit-sha1 //回滚到某次提交

## rebase （慎用）
只对尚未推送的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。
git rebase 0i git-sha1|branch //进入交互变基模式

## merge 
git merge --ff branchName //合并分支并不创造新的commit节点

git merge --no-ff branchName //保留合并分支的提交记录

## pull

git pull //拉取代码

## push

git push origin HEAD:refs/for/BranchName //推送远程分支

git push -d origin BranchName //删除远程分支

git push -f origin BranchName //强制推送远程分支

git push --force-with-lease //远程分支与本地保持一致时，推送成功，否则失败

## remote

> 维护多个仓库源使用

git remote add origin url //关联远程仓库



## branch

> 操作分支命令

git branch //列举远程分支 

git branch -a //列举所有分支 包括本地分支

上述结果中 `*`表示当前使用分支

git branch -c [oldBranchName] branchName //复制分支

git branch -C [oldBranchName] branchName //强制复制分支

git branch -m [oldBranchName] branchName //移动分支

git branch -M [oldBranchName] branchName //强制移动分支

git branch -d branchName //删除分支

git branch -D branchName //强制删除分支



## stash

> 暂存当前修改的代码 **每次暂存的时候 设置一下描述信息**

git stash push -m “XX” //暂存文件并设置描述信息

git stash apply stash@{0} //使用但保留暂存记录

git stash pop stash@{0} //使用并删除暂存记录

git stash list //列举暂存记录

git stash drop stash@{0} //丢弃指定暂存记录

git stash show stash@{0} //查看指定暂存记录修改内容



## reflog

> 记录所有git操作行为

git reflog -5 //打印最近5次操作



## cherry-pick

> 从其他分支选择需要的commit合并到一个分支中

git cherry-pick commit-sha1 //合并其他分支的提交

git cherry-pick commit-sha1 commit-sha2 //合并多个提交

git cherry-pick startCommit-sha1…endCommitSha1 //按照提交区间进行合并

git cherry-pick (--continue | --skip | --abort | —quit) //后续的操作 继续合并｜跳过｜完全放弃恢复初始状态｜为冲突的合入，冲突的放弃

## rm（慎用）

> 移除版本控制中的文件

git rm —cache file_path //移除缓存中的索引



## diff

> 对提交记录进行比较



## add

> 添加工作目录中的文件到缓存区，缓存区中是需要提交的文件。

git add <file> //加入文件到缓存区

git add <dic> //加入目录到缓存区

git add -p //交互式加入文件

> 使用 `y` 缓存某一处更改，使用 `n` 忽略某一处更改，使用 `s` 将某一处分割成更小的几份，使用 `e` 手动编辑某一处更改，使用 `q` 退出编辑。

git add .

git add -A

> 上述两命令都表示 加入所有文件到缓存区 包括`New File(新增文件),Update File(有修改的文件),Deleted File(已删除文件)`

git add -u //只提交被修改和被删除的文件

## 附录



## 参考链接

[Git文档](https://git-scm.com/book/zh/v2)]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-委托相关知识</title>
    <url>/2019/07/09/Kotlin-%E5%A7%94%E6%89%98%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[
> 委托：有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。

在Kotlin中，对`委托`进行了简化，通过`by`就可以实现委托的效果。例如前面提到的`by lazy`延迟初始化就是利用了`委托`。

Kotlin中主要分为两种：**类委托、委托属性**。

基本语法:

```kotlin
val/var <属性名>:<类型> by <表达式> //<表达式> 指向委托
```

## 类委托

> 在不使用继承的情况下，拓展一个类的功能，使之提供更多的功能。类似`装饰模式`。
> 
> `装饰模式`的缺点就是需要较多的样板代码，装饰类需要实现接口的全部方法，并需要调用到原始对象的方法。

Kotlin可以**零样板代码进行原生支持**，通过`by`关键字进行实现。

```kotlin
interface Base {
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override fun print() {
        print(x)
    }
}

class Derived(b: Base) : Base by b

fun main(args: Array<String>) {
    val b = BaseImpl(10)
    Derived(b).print()
}
```

利用`by`，将新类的接口委托给原始对象，生成后的新类会自动生成接口方法，并默认返回原始类的具体实现。

```java
public final class Derived implements Base {
   // $FF: synthetic field
   private final Base $$delegate_0;

   public Derived(@NotNull Base b) {
      Intrinsics.checkParameterIsNotNull(b, "b");
      super();
      this.$$delegate_0 = b;
   }

   public void print() {
      this.$$delegate_0.print();
   }
}
```

观察上述反编译后的Java代码，看到实际生成的`Derived`已经默认实现了接口方法。可以按照需求去重载某些方法，而不必写过多的样板代码。

## 委托属性

> 将属性的访问器(`get()、set()`)委托给一个符合属性委托约定规则的对象。

委托属性对象规则：

- 对于一个**只读属性(`val`声明)**，委托必须提供一个名为`getValue()`的函数。
  
  ```kotlin
  /**
  * 只读属性
  */
  interface ReadOnlyProperty<in R, out T> { 
    /**
    * [thisRef] 必须与属性所有者类型相同或者是它的超类
    * [property] 必须是KProperty<*>或其超类
    * [T] 返回与属性相同的类型
    */
    operator fun getValue(thisRef: R, property: KProperty<*>): T 
  }
  ```
  
  `ReadOnlyProperty`由Kotlin提供的接口，方便开发者使用于`val`声明变量

- 对于一个**可变属性(`var`声明)**，委托必须额外提供一个`setValue()`
  
  ```kotlin
  /**
  * 可变属性
  */
  interface ReadWriteProperty<in R, T> { 
    operator fun getValue(thisRef: R, property: KProperty<*>): T 
    /**
    * [value] 必须与属性同类型或者超类
    */
    operator fun setValue(thisRef: R, property: KProperty<*>, value: T) 
  }
  ```
  
  `ReadWriteProperty`由Kotlin提供的接口，方便开发者使用于`var`声明变量

使用示例：

```kotlin
class Person{
    var name:String by MyDelegate()
}

class MyDelegate : ReadWriteProperty<Any?,String>{

    override fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "Kotlin"
    }

    override fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {

    }
}
```

## Kotlin自带委托

### 延迟初始化

> 利用`变量 by lazy`可以实现 延迟初始化。

#### 使用示例

```kotlin
class Demo(){
        val sex: String by lazy {
        "male"
    }
}
```

`lazy`接收初始化该值的`lambda`表达式，并返回一个`getValue()`的对象。

#### 原理分析

先分析反编译该段代码后的结果：

```java
public final class Demo {
     @NotNull
   //生成对应参数的委托信息
   private final Lazy sex$delegate;

  static final KProperty[] $$delegatedProperties = 
    new KProperty[]{(KProperty)Reflection.property(
    new PropertyReference1Impl(Reflection.getOrCreateKotlinClass(Bird.class), "sex", "getSex()Ljava/lang/String;"))};

   @NotNull
   public final String getSex() {
      Lazy var1 = this.sex$delegate;
      KProperty var3 = $$delegatedProperties[0];
      boolean var4 = false;
      //在第一次使用的时候 获取对应数据
      return (String)var1.getValue();
   }

  public Demo(){
    //执行指定的初始代码块
     this.sex$delegate = LazyKt.lazy((Function0)null.INSTANCE);
  }
}
```

最终通过获取`lazy`函数的`getValue()`获取所需结果。



### 属性改变通知

> 通过调用`value by Delegates.observable(value)`来监听`value`的数据变化。
> 
> 另外还提供了`value by Delegates.vetoable(value)`也同样起到监听的效果，但是该方法返回一个`Boolean`类型来**判断是否需要对value进行赋值。**

#### 使用示例

```kotlin
		//对age的数据变化进行监听   
		var age: Int by Delegates.observable(age) { property, oldValue, newValue ->
        println("${property.name} oldValue=>$oldValue newValue=>$newValue")
    }

		age = 3 //初始赋值
		age = 4 //age oldValue=>3 newValue=>4
		println(age) // 4

		var age: Int by Delegates.vetoable(age) { property, oldValue, newValue ->
        println("${property.name} oldValue=>$oldValue newValue=>$newValue")
        true// true代表监听并修改数据  false只监听不修改对应数据
    }

		age = 3 //初始赋值
		age = 4 //age oldValue=>3 newValue=>4
    println(age) //为true 4 为false 3
```

#### 原理分析

先分析`Delegates`相关代码的实现

```kotlin
public inline fun <T> observable(initialValue: T, crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Unit):
        ReadWriteProperty<Any?, T> = object : ObservableProperty<T>(initialValue) {
            override fun afterChange(property: KProperty<*>, oldValue: T, newValue: T) = onChange(property, oldValue, newValue)
        }

public inline fun <T> vetoable(initialValue: T, crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Boolean):
            ReadWriteProperty<Any?, T> =
        object : ObservableProperty<T>(initialValue) {
            override fun beforeChange(property: KProperty<*>, oldValue: T, newValue: T): Boolean = onChange(property, oldValue, newValue)
        }
```

`observable`通过`ObservableProperty.afterChange()`来监听变化，`vetoable`通过`ObservableProperty.beforeChange()`来监听变化并对数据的赋值进行拦截

```kotlin
public abstract class ObservableProperty<T>(initialValue: T) : ReadWriteProperty<Any?, T> {
    private var value = initialValue
    //在值修改前调用
    protected open fun beforeChange(property: KProperty<*>, oldValue: T, newValue: T): Boolean = true

    //在值修改后调用
    protected open fun afterChange(property: KProperty<*>, oldValue: T, newValue: T): Unit {}

    public override fun getValue(thisRef: Any?, property: KProperty<*>): T {
        return value
    }

    public override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
        val oldValue = this.value
        //返回false 则不进行赋值操作
        if (!beforeChange(property, oldValue, value)) {
            return
        }
        this.value = value
        //调用继承类复写的 afterChange() 对应外部的则是`onChange`
        afterChange(property, oldValue, value)
    }
}
```

### 可变属性延迟初始化

> `by lazy`只对`val变量`可用，当变量为`var`时则无法使用，这时就需要用到`var value by Delegates.notNull<String>`来表示

#### 使用示例

```kotlin
class Demo{
  var value by Delegates.notNull<String>
  
  init{
    //延迟初始化
    a= "init"
  }
}
```



#### 原理分析

```kotlin

```



## 自定义委托]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>《Kotlin核心编程》读书笔记-基础语法</title>
    <url>/2019/06/19/%E3%80%8AKotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[
> 内容摘自《Kotlin核心编程》第2章，在其基础上对一些概念进行拓展了解

本章主要讲Kotlin一些基础语法.

## 类型声明

### 声明变量

*尽可能采用`val`、不可变对象及纯函数来设计程序。*

```kotlin
val a = "Hello World"
或
val a:String = "Hello World"
```

> `val`：引用不可变。反编译后的Java代码中是通过`final`对变量进行修饰。**声明了只读变量，引用对象不可变，但是可以修改对象中的可变成员。**
> 
> Java中的变量默认是可变的，在开发过程中很容易因为使用方式导致变量发生变化出现不可预期的错误。
> 
> `var`：引用可变。**可以让程序的表达显得直接、易于理解。**

上述代码中的`:String`可以进行省略，由于Kotlin提供了更智能的`Smart Casts`，可以对类型自动进行推导，提升开发效率。

### 声明函数返回类型

```kotlin
//代码块函数体
fun sum(x:Int,y:Int) : Int {
  return x+y
}
或
//表达式函数体
fun sum(x:Int,y:Int):Int = x+y

fun show(text:String) /*: Unit*/{
  //do sth
}
```

函数如果没有指定返回值，默认使用`Unit`类型，如果需要指定返回值类型，就必须要进行声明，否则会抛出异常。

> 暂时可以把`Unit`认为类似于Java中的`void`

## 高阶函数与Lambda

Kotlin天然支持部分函数式特征。**函数是头等公民**

> `高阶函数`：以其他函数作为参数或返回值的函数，高阶函数是一种更加高级的抽象机制，极大的增强了语言的表达能力。

### 函数的类型

函数类型的声明格式非常简单：`(Int) -> Unit`

Kotlin的函数类型声明需要遵循以下几点：

- 通过`->`来组织参数类型和返回值类型，左边是参数类型，右边是返回值类型。
- 必须用一个括号来包裹参数类型
- 返回值类型即使是`Unit`也需要显式声明

`高阶函数`支持返回另一个函数：`(Int)->((Int)->Unit)`

### 方法和成员引用

Kotlin存在一种特殊的语法，可以通过`::`实现对于某个类的方法进行引用。

```kotlin
class Book(val bookName:String)

fun main(args:Array<String>){
    val getBook = ::Book
    println(getBook("Kotlin").bookName)
    //println(getBook("Kotlin")::bookName.get()) 输出Kotlin
}
```

`::Book`等价于`new Book()`  `getBook("Kotlin")`等价于`new Book("Kotlin")`

### 匿名函数

> 只能用在函数的参数中，不支持单独定义

Kotlin支持在缺省函数名的情况下，直接定义一个函数。

```kotlin
//empty其实就是一个入参为 String 出参为 Boolean的函数
fun showName(aName: String, empty: (String) -> Boolean): String {
    return if (empty(aName)) "Empty Name"
    else aName
}

showName("nihao", fun(name: String): Boolean {return name.isEmpty()})
```

其中`fun(name: String): Boolean {...}`就是一个匿名函数，避免创建大量方法

### Lambda表达式

本质是一个**简化表达后的匿名函数**。以表达式形式传递的未声明函数。

```kotlin
val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }
简化：
val sum1 =  { x: Int, y: Int -> x + y }
val sum2: (Int, Int) -> Int = { x, y -> x + y }
```

上述都是Lambda表达式

总结下Lambda的语法：

- 一个Lambda表达式必须通过`{}`包裹
- 如果Lambda声明了参数的类型，且返回值支持类型推导，Lambda变量就可以忽略函数类型声明`类似sum1`
- 如果Lambda声明了函数类型，那么Lambda就可以忽略参数部分的类型声明

#### 单个参数的隐式名称

```kotlin
val list: List<String> = listOf("1", "2", "3")

fun printList(){
  list.forEach{it -> print(it)}
}
```

其中声明了`it`这个关键字，表示的就是`单个参数的隐式名称`。只针对于单个参数时使用

#### Function类型

Kotlin在JVM层设计了`Function类型`，主要就是为了**兼容Java端的Lambda表达式(在JDK8之后添加了支持)**。

后续的更新中会具体讲到该类型的使用

#### `invoke()`

高阶函数可以以`其他函数`作为参数或者返回值，我们调用的`其他函数`实质只是构造了一个`Function类型的对象`，需要调用到`invoke()`才能实质去执行该函数。

### 柯里化风格

> `柯里化`：接收多个参数的函数转变成接收一个单一参数(最初函数的第一个参数)的函数，并且返回接收余下的参数而返回结果的新函数。

```kotlin
fun sum(x:Int,y:Int,z:Int):Int = x+y+z
//柯里化换换
fun sum(x:Int) = {
  y:Int -> {
    z:Int -> x+y+z
  }
}
```

上述两种函数是等价的。

在Kotlin中柯里化只是一种近似的效果，并不是真正意义上的柯里化。

## 面向表达式编程

> 在Kotlin中利用了各种表达式来增强程序的表达以及流程控制能力。

`语句`：程序往往都是由一个个语句组成的。以一行作为一个语句

`表达式`：表达式可以是一个值、常量、变量、操作符、函数，或他们之间的组合，编程语言对其进行解释和计算，以求产生另一个值。

### 表达式比语句更安全

表达式目的是产生另一个值，相比于语句增加了安全性。

### 复合表达式

表达式具备更好的**隔离性**，在使用表达式时就可保证更好的安全性。

> 表达式由于返回的都是值，可以更好的进行组合，可以将一个表达式作为另一个表达式的组成部分，而后形成一个复合表达式。

#### 枚举类

```kotlin
//普通枚举类
enum class RGB { RED, GREEN, BLUE }

enum class RGB(val index:Int){
  RED(1),
  GREEN(2),
  BLUE(3);

  fun getColor():Int{
    return index;
  }
}
```

> 当在枚举类中存在额外的方法或属性定义时，必须强制加上`;`。

定义完成后，对枚举类进行调用

```kotlin
val color = Day.valueOf("GREEN").index //2
或
val color = enumValueOf<Day>("MON").index //2
```

#### `when`表达式

> `when`表达式类似`switch`语句，由`when`关键字开始，用`{}`包含多个逻辑分支，每个分支有`->`连接。按照条件由上到下匹配，直到匹配完为止。否则执行`else`分支的逻辑等价于`switch中的default`。

```kotlin
when(x){
  -2,-1 -> println("负数")
  0 -> println("是0")
  else -> println("其他值")
}
```

**后续会有`when`相关高级用法**

#### `for`循环

> `for`可以对任何提供迭代器(iterator)的对象进行遍历，例如`List、Map`。

```kotlin
for(i in 1..3) println(i) //1 2 3

val list = listOf<Int>(1,2,3)
for(i in list) println(i) // 1 2 3
```

##### 范围表达式

上面讲到的`1..3`就是`范围表达式`的一种。

> 范围表达式需要通过`rangeTo()`实现，通过`..`操作符与某种类型的对象组成，除了整型等基本类型之外，还需要去实现`Comparable`接口。

```kotlin
//顺序打印
for(i in 1..3) print(i) //1 2 3
//指定步长打印
for(i in 1..5 step 2)//1 3 5
//倒序打印
for(i in 5 downTo 1 step 2)//5 3 1
//半开区间
for(i in 1 until 4) //1 2 3
```

上述的`in`关键字除了可以在范围表达式中当做循环使用，还可以用于*检查一个元素是否是一个区间或集合中的成员*。

```kotlin
val list: List<String> = listOf("1", "2", "3")
"2" in list //true
```

补充：

1. 可以通过`withIndex()`输出一个键值元组
   
   ```kotlin
       for ((index, value) in list.withIndex()) {
             println("$index => $value")
       }
   // 0 => 1
   // 1 => 2
   // 2 => 3
   ```

#### 中缀表达式

> 上述讲到了一些`in downTo step`这些的调用方式与普通`.`不同，他们是直接忽略了`.以及()`，这些就称之为`中缀表达式`。

定义一个`中缀函数`必须满足以下要求：

- 必须是某个类型的**拓展函数或者成员方法**
- 只能有一个参数
- 参数必须不是**可变参数**且**参数不能有默认值**

> `可变参数`：支持接收可变数量的参数，在Java中用`Arg...`来进行表示且必须是放在最后一个参数，Kotlin采用的是`vararg`进行表示，可以放在任意位置。

```kotlin
val letters: Array<String> = arrayOf("a", "b", "c")

fun printLetters(vararg letters: String) {
    for (letter in letters)
        print(letter)
}
//使用*传入外部的变量作为可变参数的变量
printLetters(*letters)
```

示例：

```kotlin
class Person {
    infix fun called(name: String) {
        println("my name is $name")
    }

    fun callName(){
//      called("World")
        this called "World"//在接收者自身调用 中缀函数时 需要显式指定 this
    }
}

fun main(args: Array<String>) {
  val p = Person()
  //p.called("Hello")
  p called "Hello" //my name is Hello

  p.callName() //my name is World
}
```

### 字符串的定义和操作

#### 基础操作

```kotlin
val str = "Hello World"

str.length //11
str.subString(0,5)//Hello
str.replace("World","Kotlin") //Hello Kotlin

str[0] //H
str.first() //H
str.last() //d

//是否为空
str.isEmpty()//false
```

#### 进阶操作

1. 定义原生字符串
   
   ```kotlin
       val rawString = """Hello
   World
   """
   ```
   
   利用`""""""`包裹的内容最终打印出的格式与代码定义格式保持一致。

2. 字符串模板

> 字符串中可以包含`模板表达式(一小段代码)`，通过`$`做开头以标记，单纯放入一个参数(`$arg`)，或放置一个表达式(`${expression}`)。
> 
> **大大提升了代码的紧凑性与可读性。**

```kotlin
   val str = "Kotlin"

   print("It is $str") //It is Kotlin

   print("$str length is ${str.length}")//6
```

3. 字符串判等
   
   Koltin判断是否相等主要有两种类型：
   
   - **结构相等**：判断内容是否相等
     
     通过`==`来进行判断，否定是用`!=`表示
   
   - **引用相等**：判断两个对象的引用是否相等
     
     通过`===`进行判断，否定是用`!==`表示
   
   ```kotlin
   var a = "Java"
   var b = "Java"
   
   print(a==b)//true
   print(a===b)//false
   ```

更多操作可以参考[String API](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>《Kotlin核心编程》读书笔记-面向对象</title>
    <url>/2019/06/23/%E3%80%8AKotlin%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[
> 内容摘自《Kotlin核心编程》第3章，在其基础上对一些概念进行拓展了解

本章主要讲Kotlin中一些面向对象的类和方法讲解以及一些相对Java的优化点。

## 类和构造方法

### 定义类

与Java相同使用`class结构体`来声明一个类

```kotlin
class Bird{
  //颜色
  val color :String ="blue"
  //年纪
  var age : Int = 1
  //动作
  fun fly()
}
```

上述代码就定义了一个鸟对象（蓝色、1岁、会飞）。

Kotlin声明类的语法非常类似于Java，但还是存在一些不同

- **不可变属性成员**：通过`val`声明引用不可变的属性成员，在反编译成class时，该参数是由`final`进行修饰
- **属性默认值**：除非显式的声明参数延迟初始化，否则必须指定属性的默认值
- **不同的访问修饰符**：Kotlin类中的成员默认是`public`的，Java的默认可见域是`protected`

### 定义接口

Kotlin中的接口与Java 8类似，既包含抽象方法的声明也包含实现。在Java 8引入了一个新特性-**接口方法支持默认实现**。而Kotlin是兼容Java 6，也提供了这种实现。

Java 8中接口的实现

```Java
interface Flyer{
    public String kind();
    int speed = 0;
    //默认实现
    default public void fly(){
        System.out.println("I can fly");
    }
}
```

其中`fly()`是一个默认方法，其他继承该接口的类都不需要实现该方法。



Kotlin中接口的实现

```kotlin
interface Flyer{
    val speed:Int
    fun kind()
    fun fly(){
        print("I can fly")
    }
}
```

拓展知识：

Kotlin是如何支持接口的默认方法？

首先对Kotlin定义的接口进行转换，转成容易理解的Java代码

```java
public interface Flyer {
   int getSpeed();
   void kind();
   void fly();

   public static final class DefaultImpls {
      public static void fly(Flyer $this) {
         String var1 = "I can fly";
         boolean var2 = false;
         System.out.print(var1);
      }
   }
}
```

Kotlin内部通过一个`DefaultImpls`这个静态内部类提供了`fly()`的默认实现。



Kotlin的方法中还支持声明属性，但内部通过观察反编译的Java代码可知是提供了一个`get()`提供支持，但是无法对接口定义的属性直接进行赋值，也是因为这个原因。

```kotlin
interface Flyer{
  //可通过该方法进行实现
  val speed
     get() = 100
}
```



### 构造类对象

```kotlin
val bird = Bird()
```

在Kotlin中并不会使用到`new`关键字，可以直接进行类的声明

如果构造方法中需要添加参数，直接在`Bird()`内添加参数即可，不需要进行方法的重载而产生多个方法。

要实现这种功能，需要依赖下面提到的Kotlin中的相关构造语法



#### 主从构造函数

Kotlin中的每个类最多存在一个**主构造函数**以及多个**从构造函数**。

##### 主构造函数

`主构造函数`：是类头的一部分，跟在类名之后

```Kotlin
class Person(name:String) {}
或
class Person constructor(name:String){}
```

一般情况下`constructor`可进行省略即第一种方式，特殊情况下必须显示（`存在注解或者可见性修饰符`）。`class Person @Deprecated(message = "111") public constructor(name: String)`(一般不会这样写~)

主构造函数中不能包含任何代码，如果需要初始化要在`init语句块`中实现，在主构造函数中`()`内的属性有两种定义方式：

- `class Person(name:String)`此时的name是局部变量，无法在其他方法中直接进行使用，只可以在`init语句块或属性声明`进行使用

  ```kotlin
  class Person(name:String){
    init{
      val length1 = name.length
    }
    val length2 = name.length
    fun test(){
      // name.length 无法调用
    }
  }
  ```

  将上述代码反编译成Java代码

  ```java
  public final class Person{
    private final int length2;
    public Person(String name){
      int length1 = name.length();
      this.length2 = name.length();
    }
    
    public final void test{
      //name.length 无法调用
    }
  }
  ```

  观察Java代码可知 `init{}`以及声明时相关逻辑都会在`Person(String name)`中执行，所以不会出错。

- `class Person(val name:String)`此时的name是全局变量，可以在任意地方进行使用。

  ```kotlin
  class Person constructor(val name: String) {
      init {
          val length1 = name.length
      }
      val length2 = name.length
      fun test() {
          val length3 = name.length
      }
  }
  ```

  将上述代码反编译成Java代码

  ```java
  public final class Person {
     private final int length2;
     @NotNull
     private final String name;
       @NotNull
     public final String getName() {
        return this.name;
     }
    
     public final void callName() {
        int length3 = this.name.length();
     }
  
     public Person(@NotNull String name) {
        Intrinsics.checkParameterIsNotNull(name, "name");
        super();
        this.name = name;
        int var2 = this.name.length();
        this.length2 = this.name.length();
     }
  }
  ```

   此时的`name`就是一个全局变量，可以在任意地方使用。




##### 从构造函数

`从构造函数`：由两部分组成：对其他构造方法的委托；另一部分由`{}`构成的代码块。**如果存在主构造函数，从构造函数都需要直接或间接委托给主构造函数（通过`this(...)`）。**

```kotlin
class Person constructor(val name: String){
    //委托主构造函数
    constructor(name:String,age:Int):this(name){
       
  }
}
```

`从构造函数`参数不能声明`val/var`。

```kotlin
class KotlinView : View {
      constructor(context:Context):this(context,null){ }
      constructor(context:Context,attrs:AttributeSet?):this(context,attrs,0){ }
      constructor(context:Context,attrs:AttributeSet?，defStyleAttr:Int):super(context,attrs,defStyleAttr){ }
    }
```



#### 构造方法默认参数

Java在方法重载时需要额外的添加方法，导致方法过多。在Kotlin中可以通过给构造方法中的参数指定默认值，从而避免不必要的方法重载。**当省略相应的参数时需要使用默认值**。

```kotlin
class Bird(val weight:Double = 0.00,val age:Int = 1,val color:String = "blue"){}

//调用Bird对象
val bird1 = Bird()//全部是默认值
val bird2 = Bird(weight = 1000.00,color="white") //重1kg 1岁的 白鸟
```

由于参数默认值的存在，在创建一个类对象时，*最好指定参数的名称*（命名参数），否则必须按照实际参数的顺序进行赋值。

例如上述代码中的`weight=1000.00`，就是对`weight`参数进行指定赋值

> `命名参数`：在函数调用时使用命名的函数参数，在函数有大量参数或者默认参数时使用方便。



#### `init`语句块

由于`主构造函数`不能包含任何的代码，所以引入了`init语句块`的语法，可以作为实例的初始化方法。

```kotlin
class Bird(var weight:Double = 0.00,var age:Int = 1,var color:String = "blue"){
    init {
        color = "Bird color is $color"
        println(color)
    }
}
```

对`color`属性在初始化时进行操作。

在构造方法中还可以拥有多个`init语句块`，他们会在对象创建时按照类从上到下的顺序先后执行。

```kotlin
class Bird(var weight:Double = 0.00,var age:Int = 1,var color:String = "blue"){
  init {
    color = "Bird's color is $color"
    println("$color")
  }
  
  init{
    println(weight)
  }
  
  init{
    println(age)
  }
  
}

//输出结果
Bird color is blue
0.0
1
```

多个`init语句块`有利于对初始化的操作进行职能分离，在复杂的业务开发中可以起到很大的作用。

#### 变量延迟初始化

一般地，属性声明为非空类型必须在构造函数中进行初始化，否则无法正常编译。Kotlin可以不用在类对象初始化的时候就必须有值。提供了`by lazy、lateinit`两种语法来实现延迟初始化的效果。

##### `by lazy（懒初始化）`

如果是用`val`声明的变量，可以用该语法来修饰

```kotlin
class Bird(var weight:Double = 0.00,var age:Int = 1,var color:String = "blue"){
  val sex : String by lazy{
    if(color=="yellow") "male" else "female"
  } 
}
```

语法特点如下：

- 修饰变量必须是`val`
- 只有再被首次调用时，才会进行赋值操作，一旦被赋值不会再被修改

`lazy()`接收一个`lambda表达式`并返回一个`lazy<T>`实例的函数，第一次访问该属性时，会执行对应的`lazy`中的`lambda表达式`并记录结果，后续访问时只是返回所记录的值。

另外可以对`lazy`属性进行设置，共支持三种属性：

- `LazyThreadSafetyMode.SYNCHRONIZED(默认属性)`：加上同步锁，在同一时刻只允许一个线程对`lazy`属性进行初始化，所以是**线程安全**。
- `LazyThreadSafetyMode.PUBLICATION`：允许多个线程进行初始化操作
- `LazyThreadSafetyMode.NONE`：若确定初始化总是发生单线程上，可以设置该参数，就不会存在线程方面的开销。

`by lazy`内部实现原理涉及到**属性委托**相关概念，后面会讲到相关内容。

##### `lateinit（延迟初始化）`

`lateinit`允许编译器识别非空类型属性的值然后跳过空检查，使之正常编译。

`lateinit`主要用于`var`声明变量，然而**不支持修饰基本类型(Int,Long)，因为基本类型的属性在类加载后的准备阶段会被初始化为默认值。需要用`Integer`这类包装类来替代。**

```kotlin
class Bird(var weight:Double = 0.00,var age:Int = 1,var color:String = "blue"){
    lateinit var sex : String
}
```

> 使用`lateinit`关键字的时候，只是跳过了编译器的校验，如果在使用时没有进行赋值还是会出错。

##### 拓展

除了`by lazy`还有一种方案可以实现变量延迟初始化，通过使用`Delegates.notNull<T>`，也是利用了`委托`这个概念实现的。

```kotlin
var a by Delegates.notNull<String>()
fun setValue(){
  a="test"
}
```



## 不同的访问控制原则

与Java一样，Kotlin也提供了各种修饰符来描述*类、方法，属性的可见性*。

### 限制修饰符

> 用于指定`类、方法或属性`的修改或者重写权限，就会用到`限制修饰符`。

Kotlin定义的类是默认`final`即不可继承和修改，使程序变得更加安全，但是会在开发过程中带来很多的不便。在Java中类是默认可以被继承，除非主动添加`final`修饰符。

Kotlin提供了`open`修饰符使类可以被继承，若需要一个方法可以被重写，也需要添加`open`修饰。

```kotlin
open class Bird {
  val weight : Double = 500.0
  val age = 1
  open fun fly(){}
}

class Maque : Bird(){
  override fun fly()
}
```

除了`open`限制修饰符，Kotlin提供了`final、abstract`，两者的效果与Java对应修饰符一致。

| 修饰符   | 含义                           | 与Java比较                  |
| -------- | ------------------------------ | --------------------------- |
| open     | 允许被继承或重写               | Java默认类设置              |
| abstract | 抽象类或抽象方法               | 效果一致                    |
| final    | 不允许被继承与重写（默认设置） | 与Java`fianl`修饰符效果一致 |



### 可见性修饰符

> 不管是`类、对象、接口、方法、属性`都具有`可见性修饰符`，Kotlin提供了以下四种修饰符，在不同的场景下有不同的功能。

#### `public`

Kotlin的默认修饰符，表示**声明随处可用**。与Java中的`public`功能一致

#### `protected`

Kotlin设置该修饰符后，只允许`类及子类`访问，在Java中还允许同`包`下类文件访问

#### `private`

表示该类私有，只能在当前文件中进行访问，Java中不允许对类进行`private`修饰

#### `internal`

Kotlin特有修饰符，只允许在**模块中进行访问**。

> 模块：一起编译的Kotlin文件的集合。包括以下几种：
>
> - 一个Eclipse项目
> - 一个Intellij IDEA项目
> - 一个Maven项目
> - 一个Gradle项目
> - 由Ant任务执行编译的代码

提供该修饰符的原因：保证类的安全性，保证只在当前模块中调用，外部如果需要调用只能拷贝源码。



| 修饰符      | 含义                                                         | 与Java比较                           |
| ----------- | ------------------------------------------------------------ | ------------------------------------ |
| `public`    | **Kotlin默认修饰符**<br>全局可见                             | 等同于Java中的`public`效果           |
| `private`   | **私有修饰符**<br>类内修饰，只有本类可见<br>类外修饰，文件内可见 | 只有类内可见                         |
| `protected` | **受保护修饰符**<br>本类及子类可见                           | 作用域除了本类与子类，还包括包内可见 |
| `internal`  | **内部可见修饰符**<br>模块内可见                             | 无                                   |

`private`修饰符功能代码解释

```kotlin
class Book(val bookName: String) {
    //类内修饰
    private val privateBook = 1

    fun main(args: Array<String>) {
        val bird = Maque()
    }
}

//类外修饰
private val privateOutVal = 2

private class Maque : Bird() {
    private val aaa = 1

    override fun fly() {
        println("Maque fly"+ privateOutVal) // Maquefly2
    }
}
```



## 解决多继承问题

Java是不支持类的多继承，Kotlin亦是如此。但是Kotlin可以通过特殊的语法提供多种不同的多继承解决方案。**多继承最大的问题就是导致继承关系的语义混淆**。

### 多继承困惑

容易导致**钻石问题(菱形继承问题)**，在类的多重继承下，会在继承关系下产生歧义。并且会导致代码维护上的困扰以及代码的耦合性增加。

### 接口实现多继承

一个类可以实现多个接口，在Java中是很常见的。Kotlin中的接口还可以`声明抽象的属性`，这个可以帮助Kotlin来通过接口实现多继承。

```kotlin
interface NewFlyer{
    fun fly()
    fun kind() = "flying animals"
}

interface NewAnimal{
    fun eat()
    fun kind() = "flying new animals"
}

class NewBird(val name:String):NewFlyer,NewAnimal{
    override fun fly() {
        println("I can fly")
    }

    override fun kind(): String {
        return super<NewAnimal>.kind()
    }

    override fun eat() {
        println("I can eat")
    }
}

fun main(args:Array<String>){
    val bird = NewBird("Maque")
    println(bird.kind())
}

//输出
flying new animals
```

上述定义的`NewFlyer、NewAnimal`接口，都设置了`kind()`，就会引起继承上的歧义问题。Kotlin通过提供`super<T>`用来指定继承哪个父类接口方法。

### 内部类实现多继承

> 内部类：将一个类的定义放在另一个类的内部，内部类可以继承一个与外部类无关的类，保证了内部类的独立性。内部类会带有一个对外部类对象的引用。

#### Kotlin实现内部类

在Java中是如下实现内部类的

```java
public class OuterJava{
  private String name = "inner class"
  class InnerJava {
    public void printName(){
      System.out.println(name) //inner class
    }
  }
}
```

Kotlin仿照上述实现

```kotlin
class OuterKotlin{
  private val name = "inner class"
  class InnerKotlin {
    fun printName(){
      print("$name") //Unresolved reference ：name
    }
  }
}
```

这个时候，`InnerKotlin`属于嵌套类。

> 嵌套类：不包含对外部类实例的引用，无法调用其外部类的属性。

真正的实现方案

```kotlin
class OuterKotlin{
  private val name = "inner class"
  inner class InnerKotlin {
    fun printName(){
      print("$name") //inner class
    }
  }
}
```

利用`inner`关键字就可以实现内部类。

#### 内部类多继承方案

```kotlin
open class Horse{
    fun runFast(){
        println("like horse runFast")
    }
}

open class Donkey{
    fun runFast(){
        println("like Donkey runFast")
    }
}

class Mule{
    private inner class HorseC:Horse()
    private inner class DonkeyC:Donkey()

    fun runFast(){
        HorseC().runFast()
    }

    fun runSlow(){
        DonkeyC().runFast()
    }
}

fun main(args:Array<String>){
    val mule = Mule()
    mule.runFast()
    mule.runSlow()
}
```

1. 可以在一个类内部定义多个内部类，每个内部类的实例都有自己的独立状态并且与外部的信息相互独立
2. 通过内部类继承外部类，可以在实例对象中获得外部类不同的状态和行为
3. 可以通过`private`修饰内部类，避免其他类访问内部类，保证封装性。

### 使用委托代替多继承

**委托**是Kotlin新引入的语法

## 参考链接

[Kotlin懒加载语法](https://zhuanlan.zhihu.com/p/65914552)

  




]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle学习笔记-Task</title>
    <url>/2019/05/08/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Task/</url>
    <content><![CDATA[
> Gradle的两个重要的概念：`Project`和`Task`，一个`Project`由多个`Task`组成。

## Task

> Gradle脚本中的最小执行单元，也是Gradle中的一个原子操作。

### Task Result(任务结果)

当Task执行时，最终控制台都会输出执行的结果，后面都会带有一个标签，这些标签表示了*是否有Task需要执行，是否执行了Task*等状态。

| 结果标签             | 结果描述                   | 如何触发                                                     |
| -------------------- | -------------------------- | ------------------------------------------------------------ |
| 没有标签<br>EXECUTED | 任务执行完毕               | 任务有动作且被执行                                           |
| UP-TO-DATE           | 任务输出没有改变           | 任务没有动作也没有依赖<br>任务有输入输出但是没有发生变化<br>任务没有动作但存在依赖，且依赖非执行完毕 |
| NO-SOURCE            | 任务不需要执行             | 包含了输入输出，但是没有Sources？？？                        |
| FROM-CACHE           | 在缓存中找到了任务执行结果 | 构建缓存中已存在构建结果                                     |
| SKIPPED              | 任务没有执行               | 指定跳过该任务<br>任务设置了`onlyIf`且返回false<br>任务被禁用`enabled=false` |



### Task Create(创建任务)

```groovy
task createTask1 << {
  println "doLast in createTask1"
}

task createTask2 doLast {
  println "doLast in createTask2"
}

//三种方式皆可
project.task("createTask3").doLast {
  println "doLast in createTask3"
}
project.task("createTask3") doLast {
  println "doLast in createTask3"
}
project.task("createTask3") << {
  println "doLast in createTask3"
}
//通过TaskContainer创建Task
project.tasks.create("createTask4").doLast {
   println "doLast in createTask4"
}
project.tasks.create("createTask4") doLast {
   println "doLast in createTask4"
}
project.tasks.create("createTask4") << {
   println "doLast in createTask4"
}

```

> 其中`<< `等价于`doLast`，但是在`Gradle 5.0`之后该方法已被废弃。

上述只是基础的创建方法，创建时还包括了其他的参数。

| 参数名          | 含义                     | 参数属性                                   |
| --------------- | ------------------------ | ------------------------------------------ |
| name            | 任务名称                 | 必须有值，不能为空                         |
| description     | 任务描述                 | 可以为空                                   |
| group           | 任务所属分组名           | 可以为空                                   |
| type            | 任务的父类               | 默认为`org.gradle.api.DefaultTask`         |
| **dependsOn**   | 任务依赖的其他Task       | 可以为空                                   |
| overwrite       | 是否覆盖已存在的同名任务 | false                                      |
| constructorArgs | 任务构造函数参数         | 可以为空(若依赖父类有构造参数，需要设置值) |
| **action**      | 任务的顺序执行序列       | `doLast(最后执行)`、`doFirst(最先执行)`    |



### Task Action(执行序列)

> 一个`Task`由一系列`Action`组成的，通过设置`action`，实质上就是在创建Task时调用到的`doFirst`、`doLast`这两个方法。

```groovy
task Task1 {
  println "Task configure"
  doFirst {
    println "Task doFirst"
  }
  doLast {
    println "Task doLast"
  }
}
```

上述代码不同的执行方式结果不同

- 执行整个`gradle`文件：

  ```xml
  Task configure
  ```

- 执行`Task1`：`./gradlew Task1`

  ```xml
  Task configure
  Task doFirst
  Task doLast
  ```

观察上述结果，得出以下结论

> 在创建Task时，除了`doFirst`、`doLast`之外的代码，都定义为`Task`的配置项，在脚本的配置阶段都会执行；而`doFirst`、`doLast`代码只会在`Task`真正执行时才会调用(gradle 指定运行该`Task`)。



### Task DependsOn(执行依赖)

> Gradle中的任务执行顺序是不确定的，需要通过task之间的依赖关系，保证被依赖的task优先执行，可通过`dependsOn`来确定依赖关系。

```groovy
task first doLast {
    println("first")
}

task second doLast {
    println("second")
}
//second 依赖于 first
second.dependsOn(first)

//third 依赖于 first,second
task third(dependsOn:[first, second]) doLast {
    println("third")
}

```

此时调用`./gradlew third`

```xml
输出结果
> Task :plugin:first
first

> Task :plugin:second
second

> Task :plugin:third
third
```

由于`third`依赖于`first、second`所以在执行`third`时，`first、second`也需要执行。

### Task Type(任务类型)

> 默认Type为`DefaultTask`，系统还提供了几种常用的类型以供使用，也可以通过自定义Type来实现功能。

#### [Copy](https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Copy.html)

> 将文件复制到目标目录，此任务在复制时也可以执行重命名和过滤文件操作。

```groovy
task CopyFile(type:Copy){
    //源文件目录
    from '../app/src/main'
    //目标目录
    into './src/main/java'
}
```

`from`、`into`是最基础的配置，其他常用包括以下：

| 配置项           | 释义                   | 示例                                                         |
| ---------------- | ---------------------- | ------------------------------------------------------------ |
| include          | 只包含配置的文件       | `include '**/*.java',   '**/*.kt'`                           |
| exclude          | 排除配置的文件         | ` exclude '**/*.xml'`                                        |
| includeEmptyDirs | 是否包括空文件夹       | `true`文件夹下的所有文件夹也会被拷贝进来<br>`false`不会存在空文件夹 |
| rename           | 对指定的文件进行重命名 | `rename 'activity_*.xml' 'rename'`                           |
| with             | 执行一个闭包           | def dataContent = copySpec {<br>     from ('../src/main') { <br>        include '**/*.xml'    <br> } }<br>with dataContent |



#### [Sync](https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Sync.html)

> 与Copy任务类似，不同的是**将源目录中的文件复制到目标目录中，但是会删除目标目录中非复制过来的文件。**

```groovy
task syncFile(type:Sync){
    from '../app/src/main/java'
    rename 'Main*', 'SSS'
    into './src/main/java'

    includeEmptyDirs = false
}
```

可通过设置`preverse`属性，控制哪些文件不会被覆盖

```groovy
task syncFile(type:Sync){
    from '../app/src/main/java'
    rename 'Main*', 'SSS'
    into './src/main/java'

    includeEmptyDirs = false
    preserve {
        include '**/*.xml'
    }
}
```

那么目标目录原有的`xml`不会被删除

#### 其他类型

通过[官网介绍](https://docs.gradle.org/current/dsl/)来查询其他系统支持类型

#### 自定义Type

```groovy
//设置父类
class ParentTask extends DefaultTask{
    String msg = "parent"
    int age
    int score

    @Inject
    ParentTask(int age,int score){
        this.age = age
        this.score = score
    }

    @TaskAction
    void sayHello(){
        println "hello $msg age is $age and score is $score"
    }

}

//设置type即父类为 ParentTask 设置参数为 30,100
task Task1(type:ParentTask,constructorArgs:[30,100])

task Task2(type: ParentTask,constructorArgs: [10,70]){
    msg="wxy"
}

输出结果：
> Task :plugin:Task1
hello parent age is 30 and score is 100

> Task :plugin:Task2
hello wxy age is 10 and score is 70
```

### Task Group(任务分组)&Task Description(任务描述)

> 对任务进行分组整理，使结构清晰明了
>
> 对任务进行描述，说明任务的作用

```groovy
task MyTask(description:"Task的介绍",group:"MyTaskGroup") doLast {
  println "group $group "
}

> Task :plugin:MyTask
group is MyTaskGroup and description is Task的介绍
```

可以通过执行`./gradlew -q tasks --all`查看所有task信息

```xml
MyTaskGroup tasks
-----------------
plugin:MyTask - Task的介绍
```

### Task Overwrite(任务重写)

> 对上面的任务进行覆盖，后续只会执行该任务

```groovy
task MyTask(description:"Task的介绍",group:"MyTaskGroup") doLast {
  println "group is $group and description is $description"
}

task MyTask(overwrite:true) doLast {
  println "Cover Same Task"
}
```

后续只会输出`Cover Same Task`



### Task Enable(任务启用)

> 通过设置`enabled`属性，用于启用和禁用任务，默认为`true`，表示启用。`false`则禁止该任务执行

```groovy
task MyTask {
  enabled false
}
```

运行会提示 `Task :plugin:zipFile SKIPPED`



### [TaskContainer(任务集合)](https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/TaskContainer.html)

> 管理所有的Task实例，可通过`Project.getTasks()`或者`tasks`使用该实例

提供了以下常用的方法

| 方法                                                       | 介绍                          |
| ---------------------------------------------------------- | ----------------------------- |
| `create(name:String) : Task`                               | 创建任务                      |
| `create(name:String,configureClosure:Closure) : Task`      | 创建任务                      |
| `create(options: Map<String, ?>,configure: Closure): Task` | 创建任务                      |
| `findByPath(path: String): Task`                           | 查找任务                      |
| `getByName(name: String): Task`                            | 根据Task名字查找任务          |
| `withType(type: Class): TaskCollection`                    | 根据Type查找任务              |
| `register(String name):TaskProvider`                       | 按需加载任务                  |
| `replace(String name):Task`                                | 替换当前同名任务              |
| `remove(Task task)`                                        | 删除任务                      |
| `whenTaskAdded(action:Closure)`                            | task添加进TaskContainer时监听 |

```groovy
//创建Task
tasks.create("Task1"){}
tasks.create("Task2", Copy.class){
    from '../app/src/main/java'
    into './src/main/java'
}
tasks.create([name:"Task3",group:"customGroup",desription:"desc",dependsOn:["Task1"]]){
  
}

//查找Task
def task1 = tasks.findByName("Task1")
def task2 = tasks.withType(Copy.class)

//替换Task
tasks.replace("Task1"){
  
}

//监听Task添加
tasks.whenTaskAdded { task->
    if(task.name == "Task1" ){
        println "Task1 is added"
    }else{
      println "${task.name} is added"
    }
}
```



### Task增量构建

> Task会缓存每次运行的结果，在下次运行时会检查输出结果是否进行改变，没有发生变化就会跳过当次运行 。为了**提高Gradle的编译速度**。
>
> 在控制台会显示`up-to-date`表示跳过该次执行。

#### Task Input/Output(任务输入/输出)

> 任务需要接收

### Task Other

#### `onlyIf`断言

> `onlyIf`接收一个闭包作为参数，若闭包中返回`true`则执行任务，否则跳过该任务(`SKIPPED`)。**主要用于控制任务的执行场景。**

```groovy
task testOnlyIf{
    println "setOnlyIf"
    doLast{
        println "testOnlyIf run "
    }
}

testOnlyIf.onlyIf{
    if(project.hasProperty("skip")){
         !project.property("skip")
    }
    false
}
```

命令行中输入` ./gradlew testOnlyIf -Pskip=true`则提示`Task :testOnlyIf SKIPPED`。设置`-Pskip=false`则输出`testOnlyIf run `。

> 命令行中`-P`表示为`Project`指定`K-V`格式的属性键值对，使用格式为`-PK=V`

#### `finalizer`任务

> 监听任务结束状态，可以在结束后执行其他任务

```groovy
task taskx {
    doLast{
        println "taskx"
    }
}

task tasky {
    doLast{
        println "tasky"
    }
}

taskx.finalizedBy tasky
```

`./gradlew taskx -q `运行结果为 

```
> Task :plugin:taskx
taskx

> Task :plugin:tasky
tasky

taskx执行完毕就会执行tasky
```

> `Finalizer`即使运行过程中出现异常也不会影响到后续任务的执行，只有一种情况下会出现无法执行后续任务。**当前置任务根本没有执行时，不会触发后续任务执行。**







## 引用

[Gradle官方文档](https://docs.gradle.org/current/userguide/more_about_tasks.html)]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle学习笔记-Project</title>
    <url>/2019/06/14/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Project/</url>
    <content><![CDATA[


> `Project`对应着项目中的`build.gradle`文件，每个gradle文件被解析后都会生成一个Project对象。所有`build.gradle`中定义的属性及方法都可以通过`Project`进行调用。



## 常用属性







## 参考资料

[Project官方文档](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#N153F9)]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle学习笔记-基础</title>
    <url>/2019/04/22/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[
> Gradle是一种自动化构建语言，是一种`DSL(Domain Specific Language 特点领域语言)`，目前是Android的默认构件构建工具，是一个编程框架。

## 作用

> 将`Java/Kotlin(逻辑代码)`、`XML(界面代码)`、`NDK C/C++(JNI)`、`资源文件`，*`RenderScript(并行运算)`*这些文件通过编译过程打包成一个`Apk`。

- 解决自己的问题
- 帮助其他人优化开发流程
- 可以分享出自己的插件

## 特性

| 语言         | **Groovy**先编译成Java类字节码，然后通过JVM来执行该类 |
| ------------ | ----------------------------------------------------- |
| 支持的环境   | Android Studio及命令行调用                            |
| 构建粒度     | 支持多个Project/Module、多个版本、多种构建类型        |
| 可拓展性     | 丰富的API及插件架构                                   |
| 其他构建工具 | Ant、Maven                                            |

## 概念

### GradleWrapper

一个Gradle的封装体，即便机器上没有安装Gradle，也可以执行Gradle的构建工作。在Android项目下分为`gradlew(Mac、Linux下使用)`，`gradlew.bat(Win下使用)`

通过`gradle.properties`配置Gradle参数

```properties
#Fri Feb 15 15:39:54 CST 2019
#Gradle解包后的存储目录
distributionBase=GRADLE_USER_HOME
#Gradle解包后存放位置
distributionPath=wrapper/dists
#Gradle压缩包存储目录
zipStoreBase=GRADLE_USER_HOME
#Gradle压缩包存放位置
zipStorePath=wrapper/dists
#Gradle压缩包下载地址
distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip
```



分别的执行命令为

```bash
//Mac、Linux使用
./gradlew ...task
//win下使用
./gradlew.bat ...task
```



### Closure(闭包)

```gradle build.gradle
repositories {
   google()
   jcenter()
}
```

  `闭包`省略了表达式中的括号，`Groovy`表达式省略括号的规范：

- 所有顶级表达式的括号可以省略
- 当闭包是一个顶级表达式的最后一个参数时，可以省略括号
- 当函数嵌套调用已经有函数没有参数时不能省略

> 闭包和函数的区别：
>
> 闭包：`def addNumbers = { left , right -> left+right }`
>
> 函数：`def addNumbers( left , right ){ left+right }`



###  Project

Gradle为每个`build.gradle`创建一个相应的Project领域对象，在编写Gradle脚本时，实际是在操作诸如Project这样的Gradle领域对象。

一个完整项目中一般包含：

- `settings.gradle`：一个，一般包含了`module及app的引用`

- `build.gradle`：一个`root project`及多个`module project`



`dependencies`：设置Gradle依赖库

- `implememtation`：加入的依赖，表示这个依赖库只能自己用，其他依赖该module的无法引用该库。(*可以提高编译速度。*)
- `api`：加入的依赖，其他引用该Module的也可以使用该库，类似于以前的`compile`

### Tasks

一个Project由一个或多个`Task`组成，它是构建过程中的原子任务，可以是编译Class，上传jar包等。

> 可以在 Gradle文件目录下查看所有Task 或者通过执行 `./gradlew tasks`来查看

task包含以下内容

| 参数        | 含义                 | 默认量             |
| ----------- | -------------------- | ------------------ |
| name        | task名字             | 不能为空，必须指定 |
| type        | task父类             | DefaultTask        |
| overwrite   | 是否替换已存在的task | false              |
| dependsOn   | task依赖的task集合   | []                 |
| group       | task属于哪个组       | null               |
| description | task的描述           | null               |



### Hooks



### Plugin

Gradle插件打包了可以复用的构建逻辑块，这些逻辑可以在不同的项目中构建使用。



 

## Gradle工作流程

{% fullimage /images/Gradle-workflow.png,Gradle工作流程,Gradle工作流程%}

- `Initialzation phase(初始化阶段)`：就是执行`setting.gradle`
- `Configuration phase(配置阶段)`：解析每个`project`中的`build.gradle`，可以在此期间添加一些`Hook`，需要通过API进行添加。配置完成后，内部建立一个有向图来描述Task之间的依赖关系。
- `Execution phase(执行阶段)`：执行任务



## 自定义插件

]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle学习笔记-Groovy基础</title>
    <url>/2019/04/23/Gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Groovy/</url>
    <content><![CDATA[
> Groovy是基于JVM的一种动态语言，语法与Java相近，上手较快。**Groovy完全兼容Java。**又增加了很多动态类型和灵活的特性，是一门比较灵活的动态脚本语言。

## 变量

Groovy中通过`def`定义变量，无需指定变量类型，自动判断。

### 数据类型

```groovy
task printDef << {
//字符串
def str1 = "str"
def str2 = 'str'
def str3 = '''str
    23
        45''' //三引号字符串可以保留文本的换行及缩进
//数值
def intV = 1
def doubleV = 2.0
def floatV = 3.0f

println("字符串 ${str1} ${str2} 数值 ${intV} ${doubleV} ${floatV}")
}

//在控制台输出结果
./gradlew printDef
```

> `println`输出到控制台，只有双引号标记的`${ }`才可以生效。

### 集合

#### List

> Groovy在Java的集合类基础上进行了拓展与增强，并对原有集合完美兼容。

```groovy
task printList << {
  //初始化一个数组 默认ArrayList类型
  def numList = [1,2,3,4,5,6,7]
  //设置List类型为 LinkedList
  def linkList = [1,2,3] as LinkedList
  //输出第一个元素
  println numList[0]
  //输出最后一个元素
  println numList[-1]
  //输出第一到第三个元素
  println numList[0..2]
  //输出倒数第一到倒数第三个元素
  println numList[-1..-3]
  //添加元素
  numList << 5
  numList.add(5)
  //移除元素
  numList.remove(1) //移除第二个元素
  //遍历输出
  numList.each{ print "${it}," }
  //显示索引
  numList.eachWithIndex{ it,i -> print("${i},") }
  //Collect语法
  //查找list元素
  println numList.find{ it>3 }
  //查找list所有符合条件元素
  println numList.findAll{ it>3 }
  //查找list元素并返回下标
  println numList.findIndexOf{ it ==4 }
  println numList.findFirstIndexOf{it==4}
  println numList.findLastIndexOf{it==4}
  //List排序
  numList.sort()
  //List去重
  numList.unique()
}
```

#### Map

> Map用法与List类似，只不过它的值是一个KV键值对。

```groovy
task PrintMap << {
  //初始化Map 默认LinkedHashMap
  def map = [one:"111",two:"222",three:"333"]
  //根据key输出value
  println map["one"] //111
  println map.one //111
  //遍历Map
  map.each {
    println "Key：${it.key} value：${it.value}"
  }
  //判定Map中存在key
  println map.containKey("one") //true
  //判定Map中存在value
  println map.containValue("222")
  //清除Map的内容
  map.clear()
}
```

#### Range

> Groovy提供的一种容器类，是对List的拓展

```groovy
task printRange << {
  //定义一个Range
  def range = 1..5
  
  print range //[1,2,3,4,5]
  //获取range长度
  println range.size() //5
  //获取index为1的元素
  println range.get(1) //2
  //是否包含元素3
  println range.contains(3) //true
  //获取第一个元素
  println range.first()//1
  println range.from()//1
  //获取最后一个元素
  println range.last()//5
  println range.to()//5
  //添加新元素
  range.add(6)
  //移除元素
  range.remove(0)
  //清空数据
  range.clear()
  //遍历range
  range.each {println it}
}
```

## 操作符

### `**`运算符

> 等同于 2^3 = 8

```groovy
2 ** 3 = 8
```

### `?.`占位符

> 用于避免空指针异常

```groovy
def person = new Person()
println person?.name?:"" //为null 则返回空
```

### `.@`操作符

> 直接跳过写的`getXX()`获取对应值

```groovy
class Person {
    String name
    Integer age = 10
    int getAge() { age+10 }
}

task printClass << {
    Person p = new Person();

    p.name = "wxy"
    println p.name //wxy
    println p.@age //10
    println p.age //20
}
```

### 三目运算符

```groovy
def name
//类Java写法
def result = name==null?"null":name
//Groovy写法
def result = name?:"null"
print result
```

###`asType`

> 数据类型转换

```groovy
String string = "23"
//转成int
def toInt = string as int
def toInt = string.asType(Integer)
```

### `<=>`比较操作符

```groovy
assert (1 <=> 1) == 0
assert (1 <=> 2) == -1
assert (2 <=> 1) == 1
```

### `*.`展开运算符

> 得到原集合中各元素的组合后的集合

```groovy
class Person {
  String name
  int age
}

def persons = [new Person("a",1),new Person("b",2),new Person("c",3)]
def names = persons*.name  // [a,b,c]

def names = persons.collect{it.name} //[a,b,c]
```

`*.`操作符是空安全的，支持传入`null`

### `with`操作符

> 简化对同一对象进行赋值的操作

```groovy
class Person {
  String name
  int age
  int score
}

task testWith << {
  Person person = new Person()
  person.with {
    name="a"
    age=12
    score=60
  }
}
```

## 方法

> Groovy中的方法与Java方法相似，但是提供了更便利的实现。

```groovy
task printMethod << {
    add(1,3)
    add 1,4  //1
    println minus (5,2)
}

def add(int a,int b){
    println a+b
}

static int minus(a,b){//3
  println "a=${a} b=${b}"
    a-b //2
}
```

1. 语句后面的分号可以省略
2. 方法中的括号可以省略 *类似注释1*
3. return 可以省略掉 *类似注释2* **最后一行代码为返回值的最终结果**
4. 参数类型可以忽略掉 *类似注释3*

默认方法修饰符为`public`。

## 类

> Groovy类类似于Java类

```groovy
task printClass << {
    Person p = new Person();
    p.increaseAge(2)

    p.name="wxy"
    println p.name
    println p.age
}

class Person {
    String name
    Integer age =10
    int getAge(){ age }
    def increaseAge(Integer years){
        this.age+=years
    }
}
```

1. 默认类的修饰符为`public`
2. 没有可见修饰符的会自动生成对应的`getter/setter`方法
3. 类不需要与它的源文件有相同的名称，建议采用相同的名称



## 语句

### 断言

> 用于进行单元测试

```groovy
tasl test << {
  assert 1+2==6 //进行测试
}
```



### for语句

> 循环语句

```groovy
task testFor << {
  def x= 0
  for(i in 0..3){
    x+=i
  }
  //效果等同于 0..3
  for(i in 0..<4){
    x+=i
  }
  println x //6
  
  x = 0
  def list = [0,1,2,3]
  for (i in list){
    x+=i
  }
  println x //6
  
  x = 0;
  def map =[a:1,b:2,c:3]
  for( i in map.values){
    x+=i
  }
  println x //6
}
```

### time语句

> 用于进行循环输出

```groovy
4.times {
  print it
}

输出0 1 2 3
```

### switch语句

> 选择语句

```groovy
static def returnSwitch(x){
    def result = ""
    switch(x){
        case "ok":
            result = "found ok"
            break
        case String:
            result = "isString"
            break
        case 1..10:
            result = "in range"
            break
        case Integer:
            result = "is Integer"
            break
        case [1,2,3,4]:
            result = "is List"
            break
        default:
            result = "default"
        return result
    }
}
```

`switch`除了Java支持的数据类型`Integer、String`以外，还支持数组类型、区间、列表等

### 捕获异常

> 写法同Java一致

```groovy
    try {
        // do sth
    } catch (EOFException e) {
        e.printStackTrace()
    }

//Groovy写法
    try {
        // do sth
    } catch (e) {//可忽略类型
        e.printStackTrace()
    }
```



## I/O操作

> 对原有Java I/O操作进行了封装，简化了使用方法

### 文件读取

```groovy
task testFileRead << {
    def filePath = "$path"
    def file = new File(filePath)
 //基础使用方式
    //输出所有文本内容
    println file.text 
    //逐行输出
    file.eachLine {
        println it
    }
 //Reader操作方式 
    def line = ""
    file.withReader {reader ->
       while(line = reader.readLine()){
           println line
       }
    }
    //设置编码格式
    file.withReader("utf-8"){reader->
        while(line = reader.readLine()){
            println line
        }
    }
 //InputStream 
    def is = file.newInputStream()
    is.eachLine {
        println it
    }
    //使用完后 需要及时关闭
    is.close()
    // 使用 withInputStream 不需要close流
    file.withInputStream { stream ->
        stream.eachLine {
            println it
        }
    }
}
```

`Reader`：即使读取过程中抛出异常也可以自动关闭IO操作

### 文件写入

```groovy
task testFileWrite << {
  def file = new File("%path")
//基础使用方式
  file.withWriter("utf-8"){writer->
    writer.writeLine "Hello"
    writer.writeLine ","
    writer.writeLine "World"
  }
  file << '''Hello
  ,
  World'''
//OutputStream
    def bytes = [66,22,11] as byte[]
    def out = file.newOutputStream()
    out.write(bytes)
    out.flush()
    out.close()
  
    file.withOutputStream {stream->
        stream.write(bytes)
        stream.write(bytes)
    }
//PrintWriter
    def out = file.newPrintWriter()
    out.write("sasd")
    out.write("sdds")
    out.flush()
    out.close()
  
    file.withPrintWriter { writer ->
        writer.append("ssss")
        writer.println("dfff")
        writer.write("12333")
    }
}
```

### 文件遍历

> 可用于检测文件是否重复，例如代码中的重复资源引用

```groovy
task testFileEach << {
  def file = new File("$path")
  //遍历目录下的文件
  file.eachFile { file->
    println file.name //打印文件名包括文件夹名字，不能嵌套处理
  }
  //遍历嵌套目录
  file.eachFileRecurse{file->
    println file.name //打印文件名 包含嵌套目录及文件
  }
  //按照文件类型 遍历目录
  file.eachFileRecurse(FileType.FILES){file->
    println file.name //只会打印出文件
  }
  //按照正则匹配文件
  
  
}
```

`FileType`包含以下三种类型：

- `FileType.ANY`：可获取所有类型，包含文件、目录
- `FileType.FILES`：只能获取文件类型
- `FileType.DIRECTORIES`：只能获取文件夹类型

## **闭包**

> Groovy中一个重要的特性，是**DSL**的基础。使得代码变得*灵活、轻量、可复用*。

### 基础样式

```groovy
task testClosure << {
    //闭包单参数 默认it 也称为隐含参数 可以指定名称
    customEach{ iii->
        print iii
    }
   /*
    *customEach{
    *   print it
    *}
    */
}

static def customEach(closure/*闭包*/){
    for(int i in 1..10){
        closure(i)
    }
}
```

### 多参数

> 如果闭包中只有一个参数，默认可以使用`it`。也可以自己指定名称。*多参数情况时，就需要列举出所有参数*

```groovy
task testClosure << {
    //闭包多参数
    eachMap{k,v->
        print "${k} : ${v}"
    }
}

static def eachMap(closure){
    def map =["1":1,"2":2]
    map.each {
        closure(it.key,it.value)
    }
}
```

### 闭包调用

```groovy
def closure1 = {
  //定义了闭包的参数
  String name,int age -> 
  println "${name} is ${age}"
}

//调用方式
closure1("wxy",111)
或
closure1.call("wxy",111)

特殊实例：
//无参闭包
def closureSpecial = {
  -> println "special"
}

//调用方式
closureSpecial.call()
closureSpecial()
```

### 闭包委托

> Groovy的闭包有`thisObject、owner、delegate`三个属性，当你在闭包内调用方法时，由他们来确定使用哪个对象来处理。

| 对象       | 含义                                                         | 方法              |
| ---------- | ------------------------------------------------------------ | ----------------- |
| thisObject | 对应于定义闭包的那个类<br>如果在内部类中定义，指向的是内部类 | `getThisObject()` |
| owner      | 对应于定义闭包的那个类或闭包<br>如果在闭包中定义，对应闭包，与`thisObject`一致 | `getOwner()`      |
| delegate   | 默认与`owner`一致<br>可以进行自定义拓展更多功能              | `getDelegate()`   |



```groovy
class OuterClass {
    class InnerClass {
        def outerClosure = {
            def innerClosure = {

            }
            printMsg("innerClosure", innerClosure)
            printMsg("outerClosure", outerClosure)
        }

        void printMsg(flag,closure){
            def thisObject = closure.getThisObject()
            def ownerObject = closure.getOwner()
            def delegate = closure.getDelegate()

            println("${flag} this : ${thisObject.toString()}")
            println("${flag} owner : ${ownerObject.toString()}")
            println("${flag} delegate : ${delegate.toString()}")
        }
    }

    def callInnerMethod(){
        def innerClass = new InnerClass()
        innerClass.outerClosure.call()
        println("outerClosure toString ${innerClass.outerClosure.toString()}")
    }
}

//打印闭包
task printBibao << {
    new OuterClass().callInnerMethod()
}


.....................输出结果.........................
> Task :CustomPlugin:printBibao
innerClosure this : OuterClass$InnerClass@4ee95fee
innerClosure owner : OuterClass$InnerClass$_closure1@1177369d
innerClosure delegate : OuterClass$InnerClass$_closure1@1177369d

outerClosure this : OuterClass$InnerClass@4ee95fee
outerClosure owner : OuterClass$InnerClass@4ee95fee
outerClosure delegate : OuterClass$InnerClass@4ee95fee

outerClosure toString OuterClass$InnerClass$_closure1@1177369d
```

根据上述的输出结果可以对应出上面的表格。

#### **delegate**

> 委托中最关键的就是**delegate**，它负责`将闭包和一个具体的对象关联起来`。

```groovy
task printClosure << {
    Main main = new Main()
    Man man = new Man(name:"sd",age:11)
    println man.toString()

    main.cc.delegate = man
  //main.cc.setResolveStrategy(Closure.DELEGATE_FIRST)
    main.cc.call()
    println man.toString()
}

class Man {
    String name
    int age

    static void eat(food) {
        println "eat ${food}"
    }

    @Override
    String toString() {
        return "Man{ name = ${name} age = ${age} }"
    }
}

class Main {
    static void eat(food){
        println "Main eat $food"
    }

    def cc = {
        name = "wxy"
        age = 12
        eat("ss")
    }
}

输出结果：
Man{ name = sd age = 11 }
Main eat ss
Man{ name = wxy age = 12 }

//设置了 setResolveStrategy(Closure.DELEGATE_FIRST)时
Man{ name = sd age = 11 }
eat ss
Man{ name = wxy age = 12 }
```

上述的执行结果，最终调用到了`Main.eat()`而不是`Man.eat()`，考虑到这个情况，`Closure`提供了`setResolveStrategy()`来控制调用同名方法的来源。

| `setResolveStrategy()`设置对应属性 | 参数含义                                  |
| ---------------------------------- | ----------------------------------------- |
| Closure.OWNER_FIRST(*默认值*)      | 优先在owner中寻找，没有就去delegate中寻找 |
| Closure.DELEGATE_FIRST             | 优先在delegate中寻找，没有就去owner中寻找 |
| Closure.OWNER_ONLY                 | 只在owner中寻找                           |
| Closure.DELEGATE_ONLY              | 只在delegate中寻找                        |
| Closure.TO_SELF                    | ???                                       |

> 在上述实例中，`owner`相当于`Main`，`delegate`相当于`Man`





## 引用

[Apache-Groovy](http://groovy-lang.org/documentation.html#languagespecification)

[搞定Groovy闭包](https://www.jianshu.com/p/6dc2074480b8)

[Groovy 使用完全解析](https://blog.csdn.net/zhaoyanjun6/article/details/70313790)





]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP学习笔记-APT</title>
    <url>/2019/04/17/AOP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-APT/</url>
    <content><![CDATA[
> APT全称`Annotation Processing Tool`-注解处理器，用于在代码编译期间解析注解并生成新的Java文件，减少手动的代码输入。
>
> 主要通过生成注解类所在类的代理类，在运行期直接调用代理类中的方法实现功能。

## 注解处理方案-反射



## 注解处理方案-APT]]></content>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android需要的必备知识</title>
    <url>/2018/12/09/Android%E9%9C%80%E8%A6%81%E7%9A%84%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[
第一关：Binder、AIDL、多进程（建议学习时间：2周）
知识点：Binder原理、AIDL的使用、多进程的定义和特性
学习资料：
① Android开发艺术探索第2章【推荐理由】地球人都知道学Android要看艺术探索。
② [Android Bander设计与实现 - 设计篇 - universus的专栏 - CSDN博客](https://blog.csdn.net/universus/article/details/6211589) 【推荐理由】Binder底层史上最牛逼分析，没有之一。
③ 艺术探索第2章的例子，请一定手动运行一遍并仔细理解，地址：[GitHub - singwhatiwanna/android-art-res: the sourc...](https://github.com/singwhatiwanna/android-art-res)。
第二关：View的绘制（建议学习时间：3天）
知识点：View的measure、layout和draw，View的工作原理
学习资料：
① Android开发艺术探索第4章【推荐理由】地球人都知道学Android要看艺术探索。
② [图解View测量、布局及绘制原理 - 简书](https://www.jianshu.com/p/3d2c49315d68) 【推荐理由】配有流程图，比艺术探索好理解一些。
③ [android ListView 工作原理 - Android - 掘金](https://juejin.im/entry/5819968bda2f60005dda6a2d)【推荐理由】帮大家了解ListView的工作过程，很有价值。
第三关：事件分发（建议学习时间：1周）
知识点：事件分发原理和规则
学习资料：
① Android开发艺术探索第3章【推荐理由】地球人都知道学Android要看艺术探索。
② [Android事件分发机制，大表哥带你慢慢深入 - 简书](https://www.jianshu.com/p/fc0590afb1bf) 【推荐理由】通过实际的例子来讲事件分发，好理解。
③ [Android ViewGroup事件分发机制 - Hongyang - CSDN博客](https://blog.csdn.net/lmj623565791/article/details/39102591) 【推荐理由】张鸿洋写的。
第四关：消息队列（建议学习时间：1天）
要求：Handler、Looper、Thread三者之间的关系；得知道子线程创建Handler为什么会报错，如何才能不报错
学习资料：
① Android开发艺术探索第10章【推荐理由】这块内容不难，艺术探索就够了。
② [源码角度讲解子线程创建Handler报错的原因 - 曹银飞的专栏 - CSDN博客](https://blog.csdn.net/dfskhgalshgkajghljgh/article/details/52601802)【推荐理由】一个实际的例子帮助大家更好地理解。
第五关：Activity难点（建议学习时间：1天）
① setResult和finish的顺序关系
② onSaveInstanceState()和onRestoreInstanceState()
③ onNewIntent()和onConfigurationChanged()
学习资料：
① [setResult()的调用时机 - 沙翁 - 博客园](https://www.cnblogs.com/shaweng/p/3875825.html)【推荐理由】清晰易懂，直接了当。
② [onSaveInstanceState()和onRestoreInstanceState()使用详解...](https://www.jianshu.com/p/27181e2e32d2)【推荐理由】简单好懂。
③ [关于onConfigurationChanged方法及常见问题解决 - 朱小姐。的博客 - CSDN...](https://blog.csdn.net/qq_27570955/article/details/55046934)【推荐理由】简单好懂，文章在郭霖公号投稿了。
④ 艺术探索第1章【推荐理由】地球人都知道学Android要看艺术探索。
第六关：Service难点（建议学习时间：2天）
① 先start再bind，如何停止一个Service
② Service onStartCommand的返回值
③ bindService后，ServiceConnection里面的回调方法运行在哪个线程？它们的调用时机分别是什么？
④ Service的onCreate运行在哪个线程？
学习资料：
① [Android中startService和bindService的区别 - 简书](https://www.jianshu.com/p/d870f99b675c)【推荐理由】详细全面地回答了上面的问题。
② [Service: onStartCommand 诡异的返回值 - CodingMan - CSDN博...](https://blog.csdn.net/veryitman/article/details/7600008)【推荐理由】通过实例来演示onStartCommand那诡异的返回值。
③ Service的onCreate、onStartCommand、onDestory等全部生命周期方法都运行在UI线程，ServiceConnection里面的回调方法也是运行在UI线程，大家一定要记住。【推荐理由】任玉刚说的，你们自己可以打log验证一下
第七关：ContentProvider难点(建议学习时间：3天)
① ContentProvider的生命周期
② ContentProvider的onCreate和CRUD运行在哪个线程？它们是线程安全的吗？
③ ContentProvider的内部存储只能是sqlite吗？
学习资料：
① 艺术探索第9章中ContentProvider的启动、艺术探索第二章中ContentProvider的介绍【推荐理由】详细了解下，艺术探索的内容无需解释
② [android ContentProvider onCreate()在 Application......](https://www.jianshu.com/p/0f1e36507b9d)【推荐理由】此文明确说明了ContentProvider的onCreate早于Application的onCreate而执行。
③ [ContentProvider总结 - 简书](https://www.jianshu.com/p/cfa46bea6d7b)【推荐理由】此文明确说明了ContentProvider的onCreate和CRUD所在的线程
注意：ContentProvider的底层是Binder，当跨进程访问ContentProvider的时候，CRUD运行在Binder线程池中，不是线程安全的，而如果在同一个进程访问ContentProvider，根据Binder的原理，同进程的Binder调用就是直接的对象调用，这个时候CRUD运行在调用者的线程中。另外，ContentProvider的内部存储不一定是sqlite，它可以是任意数据。
第八关：AsyncTask原理(建议学习时间：3天)
要求：知道AsyncTask的工作原理，知道其串行和并行随版本的变迁
① [Android源码分析—带你认识不一样的AsyncTask - 任玉刚 - CSDN博客](https://blog.csdn.net/singwhatiwanna/article/details/17596225) 【推荐理由】只看这一篇文章就够了
② [https://android.googlesource.com/platform/frameworks/base/ /android-8.1.0_r46/core/java/android/os/AsyncTask.java](https://android.googlesource.com/platform/frameworks/base/+/android-8.1.0_r46/core/java/android/os/AsyncTask.java) 【推荐理由】阅读AsyncTask 8.1版本的源码，看看是否有更新

第九关：RemoteViews(建议学习时间：7天)
要求：熟悉RemoteViews并了解其原理
① Android开发艺术探索 第5章【推荐理由】艺术探索是高级工程师进阶必备
② [关于 RemoteViews 跨进程资源访问的勘误 - 掘金](https://juejin.im/post/5c3b588be51d4551de1da844) 【推荐理由】进一步理解RemoteViews的实现，通过它可以实现资源的跨进程访问，艺术探索中的担心是多余的
第十关：Window和ViewRootImpl(建议学习时间：14天)
要求：熟悉Window、WMS和ViewRootImpl的原理
① Android开发艺术探索 第8章【推荐理由】艺术探索是高级工程师进阶必备
② Android进阶解密 第8章 【推荐理由】进阶必备
③ [Android窗口机制（四）ViewRootImpl与View和WindowManager - 简书](https://www.jianshu.com/p/9da7bfe18374)【推荐理由】另一个优秀作者对Window的描述
④ [Android中MotionEvent的来源和ViewRootImpl - 任玉刚 - CSDN博客](https://blog.csdn.net/singwhatiwanna/article/details/50775201) 【推荐理由】另一个角度理解下输入事件和ViewRootImpl的关联
第十一关：刁钻问题汇总 (建议学习时间：一周)
① 子线程访问 UI 却不报错的原因：[Android中子线程真的不能更新UI吗？ - yinhuanxu - CSDN博客](https://blog.csdn.net/xyh269/article/details/52728861)
② 主线程的消息循环是一个死循环，为何不会卡死：[Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ - 知乎](https://www.zhihu.com/question/34652589)
③ Binder、IBinder、IInterface的关系：[把玩Android多进程.pdf_免费高速下载|百度网盘-分享无限制](https://pan.baidu.com/s/1VImj3EXesFXAqT3pskcSig)
注意：主线程的消息循环背后，一切皆是消息，消息机制和Binder是Android系统的两大核心机制，屏幕触摸消息、键盘消息、四大组件的启动等均是由消息驱动。
第十二关：Retrofit原理分析 (建议学习时间：14天)
要求：熟悉Retrofit/OKHttp的工作原理
① [OKHttp源码解析 - 简书](https://www.jianshu.com/p/27c1554b7fee)【推荐理由】okhttp源码分析
② [Retrofit原理解析最简洁的思路 - 知乎](https://zhuanlan.zhihu.com/p/35121326) 【推荐理由】retrofit原理分析
③ [Retrofit是如何工作的？ - 简书](https://www.jianshu.com/p/cb3a7413b448)【推荐理由】另一个retrofit原理分析
④ 自行阅读okhttp/retrofit的源码，并写出一篇原理分析的文章 【推荐理由】源码一定要亲自读一读，并沉淀为自己的知识
第十三关：RxJava原理分析 (建议学习时间：14天)
① [友好 RxJava2.x 源码解析（一）基本订阅流程 - 掘金](https://juejin.im/post/5a209c876fb9a0452577e830)【推荐理由】基本订阅流程，已在玉刚说投稿
② [友好 RxJava2.x 源码解析（二）线程切换 - 掘金](https://juejin.im/post/5a248206f265da432153ddbc) 【推荐理由】线程切换，已在玉刚说投稿
③ [友好 RxJava2.x 源码解析（三）zip 源码分析 - 掘金](https://juejin.im/post/5ac16a2d6fb9a028b617a82a)【推荐理由】zip，已在玉刚说投稿
④ 自行阅读RxJava源码，并写出一篇原理分析的文章 【推荐理由】源码一定要亲自读一读，并沉淀为自己的知识

第十四关：Glide原理分析 (建议学习时间：14天)
① [Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程 - 郭霖的专栏 - ...](https://blog.csdn.net/guolin_blog/article/details/53939176)【推荐理由】glide工作原理，文章很长，郭霖出品
② 自行阅读 glide 4 源码，并写出一篇原理分析的文章 【推荐理由】源码一定要亲自读一读，并沉淀为自己的知识
第十五关：Groovy (建议学习时间：3天)
要求：熟悉groovy的常见语法
① [Gradle从入门到实战 - Groovy基础 - 任玉刚 - CSDN博客](https://blog.csdn.net/singwhatiwanna/article/details/76084580)【推荐理由】groovy语法基础，任玉刚出品
② [The Apache Groovy programming language - Documenta...](http://www.groovy-lang.org/documentation.html) 【推荐理由】官方文档，可当做字典来查阅
第十六关：Gradle插件基础 (建议学习时间：7天)
要求：熟悉gradle语法，可以书写简单的gradle插件
① [全面理解Gradle - 执行时序 - 任玉刚 - CSDN博客](https://blog.csdn.net/singwhatiwanna/article/details/78797506)【推荐理由】gradle执行时序，任玉刚出品
② [全面理解Gradle - 定义Task - 任玉刚 - CSDN博客](https://blog.csdn.net/singwhatiwanna/article/details/78898113)【推荐理由】task定义，任玉刚出品
③ [一篇文章带你了解Gradle插件的所有创建方式](https://mp.weixin.qq.com/s/KCpl0CNgwMv0CgvbadNK6A)【推荐理由】gradle插件的三种创建方式，已在玉刚说投稿
④ [写给 Android 开发者的 Gradle 系列（三）撰写 plugin - 掘金](https://juejin.im/post/5b02113a5188254289190671) 【推荐理由】一个简单的小例子，让大家理解gradle插件的价值
第十七关：设计模式 (建议学习时间：30-60天)
要求：熟悉6大基本原则、23种设计模式，并能在实际中灵活使用
① 《大话设计模式》【推荐理由】强烈建议买一本设计模式的书，好好看看，这事急不得
② [23种设计模式全解析 - 龙鱼鹿 - CSDN博客](https://blog.csdn.net/longyulu/article/details/9159589) 【推荐理由】这是一篇文章，涵盖了全部设计模式，我收藏了好几年了，拿出来给大家看，但是只看这篇文章是远远不够的
③  <https://t.zsxq.com/QzZZZNj>【推荐理由】学习设计模式的精神，任玉刚出品
④ [如何通俗理解设计模式及其思想? - 掘金](https://juejin.im/post/5b3cddb6f265da0f8145c049) 【推荐理由】学习设计模式的精神，却把青梅嗅出品
第十八关：MVC、MVP、MVVM (建议学习时间：14天)
要求：熟悉它们并会灵活使用
① [MVC、MVP、MVVM，我到底该怎么选？ - 掘金](https://juejin.im/post/5b3a3a44f265da630e27a7e6)【推荐理由】3M，理论结合小例子，好理解，玉刚说写作平台文章
② [全面理解Gradle - 定义Task - 任玉刚 - CSDN博客](https://blog.csdn.net/singwhatiwanna/article/details/78898113)【推荐理由】讲解MVP，理论结合小例子，好理解，玉刚说写作平台文章
③ <https://juejin.im/post/5b44d50de51d451925627900>【推荐理由】3M，Mr.S的作品，玉刚说写作平台文章
第十九关：组件化 (建议学习时间：7天)
① [Android 组件化最佳实践 - 掘金](https://juejin.im/post/5b5f17976fb9a04fa775658d)【推荐理由】一篇长文搞定，包括所有内容，分析+实例
第二十关：jni和ndk基础 (建议学习时间：30-60天)
要求：熟悉jni和ndk语法，能进行简单的开发
① 《Android开发艺术探索》第14章【推荐理由】这是最最基本的jni和ndk入门
② [JNI/NDK开发指南 - 技术改变生活（为理想而奋斗，为目标而努力！） - xyang0917 -...](https://blog.csdn.net/xyang81/column/info/blogjnindk)【推荐理由】找了半天，找到一个还凑合的教程，真是资源匮乏呀
③ <https://developer.android.com/ndk/guides/>【推荐理由】官方的ndk入门指南，讲了很多配置选项，推荐看看
④ [Android JNI 编程实践 - 简书](https://www.jianshu.com/p/9b83cc5a5ba8)【推荐理由】讲解了如何注册jin函数表，也需要大家看一下
⑤ 书籍《Android C++高级编程 使用NDK》 【推荐理由】如果要系统学习ndk，还是推荐看看书

第二十一关：安全 (建议学习时间：14天)
要求：熟悉各种发编译+二次打包工具，了解smali
① [浅析Android沙箱模型 - ljheee的博客 - CSDN博客](https://blog.csdn.net/ljheee/article/details/53191397)【推荐理由】了解沙盒机制
② [Smali语法介绍 - 任玉刚 - CSDN博客](https://blog.csdn.net/singwhatiwanna/article/details/19019547)【推荐理由】smali入门，很简单，之前我写的
③ [Smali 介绍 - CTF Wiki](https://ctf-wiki.github.io/ctf-wiki/android/basic_operating_mechanism/java_layer/smali/smali/)【推荐理由】复杂点的smali入门
④ [android逆向分析之smali语法 - L25000的专栏 - CSDN博客](https://blog.csdn.net/L25000/article/details/46842013)【推荐理由】各种工具的使用，以及一个使用apktool进行破解的例子
备注：各种工具软件大家网上自己找，反编译的话推荐jadx，比dex2jar+jd-gui更方便，smali有点复杂，如果不是特别需要，不建议深入学习，事实上，很多人私下研究安全其实就是为了破解。
第二十二关：动态化 (建议学习时间：30-60天)
要求：阅读VirtualAPK的源码，熟悉常见的热修复和插件化原理
① [Android 热修复Nuwa的原理及Gradle插件源码解析 - 区长的专栏 - CSDN博客](https://blog.csdn.net/sbsujjbcy/article/details/50812674)【推荐理由】nuwa原理浅析
② [Android 热修复 Tinker接入及源码浅析 - Hongyang - CSDN博客](https://blog.csdn.net/lmj623565791/article/details/54882693)【推荐理由】Tinker原理解析，鸿洋出品
③ [滴滴插件化方案 VirtualApk 源码解析 - Hongyang - CSDN博客](https://blog.csdn.net/lmj623565791/article/details/75000580)【推荐理由】VirtualAPK四大组件原理解析，鸿洋出品
④ [Notion – The all-in-one workspace for your notes, ...](https://www.notion.so/VirtualAPK-1fce1a910c424937acde9528d2acd537)【推荐理由】VirtualAPK资源加载机制
⑤ [GitHub - tiann/understand-plugin-framework: demos ...](https://github.com/tiann/understand-plugin-framework) 【推荐理由】插件化技术的方方面面，作者是田维术，必看的文章
⑥ [GitHub - didi/VirtualAPK: A powerful and lightweig...](https://github.com/didi/VirtualAPK) 【推荐理由】VirtualAPK引擎和构建部分，必看

应用双开与系统分身]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 注解</title>
    <url>/2019/02/19/Java-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[
{% fullimage /images/Java-注解.png,注解基础知识,注解基础知识%}

## 基础概念

### 元数据

> 元数据是关于数据的数据，元数据是添加到程序元素入方法、字段、类和包上的额外信息。对数据进行说明描述。

元数据可用于以下场景：

- **编写文档**：根据程序元素的注释创建文档
- **代码分析**：通过标识的元数据对代码进行分析(*例如声明方法重载*)
- **编译检查**：让编译器实现基本的编译检查，例如*@notNull——不为空*

**Java平台的元数据体现 就在于注解(Annotation)。**

### 注解概念

> 与Java 5之后引入的一个特性，可以声明在`类、包、字段、方法、局部变量、方法参数等的前面`。多用于**标识/解释代码**。

### 注解作用

- **标记作用**   @Override 标记重写父类方法
- **编译时动态处理，动态生成代码**  @BindView(R.id.view) ButterKnife
- **运行时动态处理，获取注解信息**  @Post("") Retrofit 

## 注解分类

### 元注解

> Android系统内置的注解类型，负责注解其他注解的注解类型

以下介绍4个常用的元注解

#### @Retention

> 保留注解。表示注解被保留的时间长短

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Annotation_Retention{
  
}
```

其中`RetentionPolicy`有三种类型，对应三种保留策略。

| RetentionPolicy(安保留时长排序)         | 含义                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| RetentionPolicy.SOURCE                  | 注解只在源代码阶段保留，编译器编译时会被忽视                 |
| RetentionPolicy.CLASS(**默认保留策略**) | 注解只保留在编译时**编译时注解**                             |
| RetentionPolicy.RUNTIME                 | 注解保留到程序运行时，并且会被加载到JVM中，程序运行时可以获取到他们**运行时注解** |



#### @Documented

> Java文档注解。可以将注解的元素包含到文档中

```java
@Documented
public @interface Annotation_Documented{
  
}
```



#### @Target

> 表示该注解类型的适用程序元素类型。

```java
@Target(ElementType.METHOD)
public @interface Annotation_Target{
  
}
```

*如果未设置@Target类型，默认适用于所有8大元素。*

其中`ElementType`有8种类型，对应8种限制范围。

| ElementType     | 含义               |
| --------------- | ------------------ |
| ANNOTATION_TYPE | 注解类型声明       |
| CONSTRUCTOR     | 构造方法声明       |
| FIELD           | 字段声明           |
| LOCAL_VARIABLE  | 局部变量声明       |
| METHOD          | 方法声明           |
| PACKAGE         | 包声明             |
| PARAMETER       | 参数声明           |
| TYPE            | 类、接口、枚举声明 |



#### @Inherited

> 继承注解。如果某个类使用了`@Inherited`修饰的注解，那么其子类也继承该注解。

```java
@Inherited
public @interface Annotation_Inherited{
  
}
```



Java 8之后新增的元注解

#### @Repeatable

> 可重复注解，被注解的对象可以取多个值。

```java
//容器注解 用于存放其他注解对象
public @interface Job {
    Person[] value();
}

@Repeatable(Job.class)
pulic @interface Person {
    String role() default "";
}

@Person(role="1")
@Person(role="2")
class Test(){
  
}
```



### Java内置注解

>  Java内部已经实现好的注解类型

#### @Override

> 用于告知编译器，该方法需要被覆写。

```java
@Override
public void onPause(){
  
}
```



#### @Deprecated

> 标记对象已经过时，不建议使用。

```java
public class Test{
  @Deprecated
  public void test(){
    
  }
}

Test test = new Test();
```

最终显示：test.~~test()~~;

#### @SuppressWarnings

> 阻止警告注解，被该注解标记时，不会显示`warning`

#### @FunctionalInterface

> Java8后引入，标记该对象可以实现函数式接口。

```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```



### 自定义注解

> 由开发者自己实现注解功能，依赖上面系统提供的注解类型

#### 运行时注解

> 在代码中通过注解进行标记，在运行时通过反射寻找标价进行处理。**由于反射导致运行低效。**

##### 定义注解

```java
//定义 运行时注解
@Retention(RetentionPolicy.RUNTIME)
//支持修饰的是 类、方法、接口等    变量                  方法
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
@interface CustomAnnotation {
    //定义注解支持的类型
    String value() default "";
}
```

##### 注解解析

主要要使用到以下的方法：

| 方法                                                         | 含义                                                  |
| ------------------------------------------------------------ | ----------------------------------------------------- |
| T   getAnnotation(Class annotationClass)                     | 存在`annotationClass`对应的注解时，返回对应的注解对象 |
| Annotation[]   getAnnotations()                              | 返回该元素上的所有注解，包括继承于基类的注解          |
| Annotation[]   getDeclaredAnnotations()                      | 返回自身显式标明的所有注解                            |
| boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) | 存在`annotationClass`对应的注解时，返回true           |

不同位置的注解需要使用不同的解析方式，主要分为3种：

###### 获取类的注解信息

示例代码：

```java
@CustomAnnotation(value = "AnnotationClass")
public class Test{
  
}
```

解析代码：

```java
 public static void getAnnotationClass(Class clazz) {
        boolean hasAnnotation = clazz.isAnnotationPresent(CustomAnnotation.class);
        if (hasAnnotation) {
            CustomAnnotation contentView = clazz.getAnnotation(CustomAnnotation.class);
            System.err.println("Class " + contentView.value());
        }
    }
```



###### 获取方法的注解信息

示例代码：

```java
    @CustomAnnotation(value = "AnnotationMethod")
    private void method() {

    }
```

解析代码：

```java
private static void getAnnotationMethod(Class clazz, String methodName) {
        try {
            //利用反射获取clazz中的对应方法
            Method method = clazz.getDeclaredMethod(methodName);
            if (method != null) {
                //允许访问私有方法
                method.setAccessible(true);
                //获取所有注解类
                Annotation[] ans = method.getDeclaredAnnotations();
                for (int i = 0; i < ans.length; i++) {
                    //存在相同类名的注解类
                    if (ans[i].annotationType() == CustomAnnotation.class) {
                        CustomAnnotation contentView = method.getAnnotation(CustomAnnotation.class);
                        System.err.println("Method " + contentView.value());
                        break;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```



###### 获取变量的注解信息

示例代码：

```java
    @CustomAnnotation(value = "AnnotationVar")
    int annotationVar = 0;
```

解析代码：

```java
    private static void getAnnotationVar(Class clazz, String varName) {
        try {
            //根据变量名获取 变量
            Field field = clazz.getDeclaredField(varName);
            field.setAccessible(true);
            //获取对应注解类
            CustomAnnotation contentView = field.getAnnotation(CustomAnnotation.class);
            if (contentView != null) {
                System.err.println("Field " + contentView.value());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

#### 编译时注解

> 不会对性能产生任何影响，实质就是**生成代码**，在编译时对注解做处理，通过注解获取必要信息，在项目中生成代码，于运行时调用。

##### 定义注解

```java
@Retention(RetentionPolicy.CLASS)
@Target({ElementType.TYPE,ElementType.METHOD})

public @interface MyAnnotation{
    int value() default 0;
}
```

##### 注解解析

关键点在于注解的解析器

```java
@SupportedAnnotationTypes("com.wxy.route.test.MyAnnotation")
public class MyAnnotationProcessor extends AbstractProcessor {
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {

      //在其中执行 解析注解
    }
}
```



## 内容引用

[注解生成Java代码](https://www.jianshu.com/p/5c8d183533fb)

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习笔记-基本概念</title>
    <url>/2019/03/28/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[
## 安装Golang环境

通过`brew install go`]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>final关键字</title>
    <url>/2019/02/26/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[
## Final特性

`final`代表了不可变，被`final`修饰的属性也是不可变状态，一旦被`final`修饰，将无法再改变这个引用。

另外`final`关键字还能保证线程间的同步，下面会基于JVM角度对这个特性进行分析。

## Final使用方法

### 修饰类

> 被`final`修饰的类不可以被继承，例如`String、Integer`，类中的方法也是默认被`final`修饰的。



### 修饰方法

### 修饰变量

## Final在JVM中的体现





## 内容引用

[Final of Java，这一篇差不多了](https://www.jianshu.com/p/f68d6ef2dcf0)

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>WebView相关知识</title>
    <url>/2019/03/12/WebView%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[
<!--webview-->

> WebView是一个基于WebKit引擎，展现Web页面的控件。
>
> 主要提供以下功能：
>
> - 显示和渲染Web页面
> - 直接使用html文件做布局
> - 可以和js进行交互

## WebView基本使用

### 添加权限

```xml AndroidManifest.xml
<uses-permission android:name="android.permission.INTERNET"/>
```



### 生成一个WebView组件

直接引入

```java
WebView webView = new WebView(this);
```

写在xml中引入

```xml
<WebView
    android:id="@+id/wv"
    android:width="match_parent"
    android:height = "match_parent"
      />

WebView webview = (WebView) findViewById(R.id.wv);
```



### 设置WebView基本信息

主要利用`WebSetting、WebViewClient，WebChromeClient`

#### `WebSetting`

> 进行基本属性配置

```java
//声明WebSettings子类
WebSettings webSettings = webView.getSettings();

//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript
webSettings.setJavaScriptEnabled(true);  

//支持插件
webSettings.setPluginsEnabled(true); 

//设置自适应屏幕，两者合用
webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小 
webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小

//缩放操作
webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。
webSettings.setBuiltInZoomControls(true); //设置内置的缩放控件。若为false，则该WebView不可缩放
webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件

//其他细节操作
webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //关闭webview中缓存 
webSettings.setAllowFileAccess(true); //设置可以访问文件 
webSettings.setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口 
webSettings.setLoadsImagesAutomatically(true); //支持自动加载图片
webSettings.setDefaultTextEncodingName("utf-8");//设置编码格式
```



#### `WebViewClient`

> 处理各种通知以及请求事件

```java
webView.setWebViewClient(new WebViewClient(){
      @Override
      public boolean shouldOverrideUrlLoading(WebView view, String url) {①
          view.loadUrl(url);
          return true;
      }
  
      @Override
      public void  onPageStarted(WebView view, String url, Bitmap favicon) {②
         
      }
  
      @Override
      public void onPageFinished(WebView view, String url) {③
         
      }
  
      @Override
      public boolean onLoadResource(WebView view, String url) {④
         
      }
  
  		@Override
      public void onReceivedError(WebView view, int errorCode, String description, String failingUrl){⑤
					//errorCode表示了 加载错误对应的错误码
      }
  
  		@Override    
      public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {⑥

       }    
  });
```

##### `shouldOverrideUrlLoading`

> 复写该方法，避免打开外部浏览器

```java
@Override
      public boolean shouldOverrideUrlLoading(WebView view, String url) {①
          view.loadUrl(url);
          return true;
      }
```



##### `onPageStarted`

> 开始载入页面时回调该方法

##### `onPageFinished`

> 页面载入结束时回调该方法

##### `onLoadResource`

> 页面资源开始加载时调用，并且每次加载时都会调用

##### `onReceivedError`

> 加载页面出现错误时回调，可用于显示不同错误码的展示页面

##### `onReceivedSslError`

> WebView默认是不处理HTTPs请求的，页面会显示空白

```java
		@Override    
    public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {    
        handler.proceed();    //表示等待证书响应
     // handler.cancel();      //表示挂起连接，为默认方式
     // handler.handleMessage(null);    //可做其他处理
    }   
```



#### `WebChromeClient`

> 辅助WebView处理js、网站标题等属性

```java
webview.setWebChromeClient(new WebChromeClient(){

      @Override
      public void onProgressChanged(WebView view, int newProgress) {①
           //newProgress 当前加载进度
      });
  
   		@Override
    	public void onReceivedTitle(WebView view, String title) {②
       	  //title 当前页面标题
    	}
}
```

##### `onProgressChanged`

> 获得当前页面的加载进度

##### `onReceivedTitle`

> 获得当前页面的标题

### 设置WebView要显示的网页

```java
//load本地
webView.loadUrl("file:///android_asset/hellotest.html");
//load在线
webView.loadUrl("http://www.google.com");
```

### 结束时销毁WebView

```java
@Override
    protected void onDestroy() {
        if (webView != null) {
            webView.loadDataWithBaseURL(null, "", "text/html", "utf-8", null);
            webView.clearHistory();

            ((ViewGroup) webView.getParent()).removeView(webView);
            webView.destroy();
            webView = null;
        }
        super.onDestroy();
    }
```

### 拓展

前进/后退网页

```java
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {  
  if (keyCode == KeyEvent.KEYCODE_BACK && webView.canGoBack()) {    
     webView.goBack();// 返回前一个页面   
     return true;   
 	}    
		return super.onKeyDown(keyCode, event);
}
..................................
//是否可以前进                     
Webview.canGoForward()
//前进网页
Webview.goForward()
```



## Android与Js的交互

>  Android与JS间的交互唯一桥梁就是`WebView`。

```html
<!DOCTYPE html>
<html>
   <head>
      <meta charset="utf-8">
      <title>WebView Test</title>  
      <script>
         //用于调用Android中方法
         function callAndroid(){
            myObj.hello("js调用了android中的hello方法");
         }
         //用于测试第二种调用方法 
         function callAndroidWithLoadUrl(){
           document.location="js://showMsg?msg=android"
         }
         //用于调用js方法
         function callJS(){
      			alert("Android调用了JS的callJS方法");
   			 }
         function callJsWithParams(params){
            alert("Android调用了JS的callJsWithParams方法" + params); 
         }
         function callJsWithParamsAndResult(params){
            alert("Android调用了JS的callJsWithParamsAndResult" + params);
            return "Success";
         }
      </script>
   </head>
   <body>
      <button type="button" id="button1" onclick="callAndroid()"></button>
   </body>
</html>
```



### Android调用JS

#### 通过`WebView.loadUrl()`调用

> **Js的调用一定要在`onPageFinished()`回调之后才可调用，否则会导致失败。**

```java
webView.loadUrl("javascript:callJS()");

webView.loadUrl("javascript:callJsWithParams("+params+")")
```

在4.4之前并没有直接提供调用js函数并获取返回值的方法，需要操作的是 **Android调用Js，Js执行完毕后，再通过Js继续调用Android方法返回值。**

#### 通过`WebView.evaluateJavascript()`调用(4.4后新增)

> 该方法效率高于`loadUrl()`，不会导致页面的刷新。

```java
mWebView.evaluateJavascript（"javascript:callJsWithParamsAndResult("+params+")", new ValueCallback<String>() {
        @Override
        public void onReceiveValue(String value) {
            // value 为 Success
        }
    });
```



在具体使用时，可以将两者进行结合使用

```java
// Android版本变量
final int version = Build.VERSION.SDK_INT;
// 因为该方法在 Android 4.4 版本才可使用，所以使用时需进行版本判断
if (version < 18) {
    mWebView.loadUrl("javascript:callJS()");
} else {
    mWebView.evaluateJavascript（"javascript:callJS()", new ValueCallback<String>() {
        @Override
        public void onReceiveValue(String value) {
            
        }
    });
}
```



### JS调用Android

#### 通过`WebView.addJavascriptInterface()`进行对象映射

```java
public class MyObject extends Object{
  @JavascriptInterface
  public void hello(String msg){
    
  }
}
//将Java对象映射到Js上
webView.addJavascriptInterface(new MyObject(), "myObj");
```

**该方法在4.2以下存在严重的安全漏洞问题，下一节中会有相关的解决方法。**

#### 利用`WebViewClient.shouldOverrideUrlLoading()`拦截url

```java
mWebView.setWebViewClient(new WebViewClient() {
                                      @Override
                                      public boolean shouldOverrideUrlLoading(WebView view, String url) {

                                          // 步骤2：根据协议的参数，判断是否是所需要的url
                                          // 一般根据scheme（协议格式） & authority（协议名）判断（前两个参数）
                                          //假定传入进来的 url = "js://webview?arg1=111&arg2=222"（同时也是约定好的需要拦截的）

                                          Uri uri = Uri.parse(url);                                 
                                          // 如果url的协议 = 预先约定的 js 协议
                                          // 就解析往下解析参数
                                          if ( uri.getScheme().equals("js")) {

                                              // 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议
                                              // 所以拦截url,下面JS开始调用Android需要的方法
                                              if (uri.getAuthority().equals("webview")) {

                                                 //  步骤3：
                                                  // 执行JS所需要调用的逻辑
                                                  System.out.println("js调用了Android的方法");
                                                  // 可以在协议上带有参数并传递到Android上
                                                  HashMap<String, String> params = new HashMap<>();
                                                  Set<String> collection = uri.getQueryParameterNames();

                                              }

                                              return true;
                                          }
                                          return super.shouldOverrideUrlLoading(view, url);
                                      }
                                  }
        );
   }
```



#### 利用`WebChromeClient`回调接口的三个方法拦截消息

> 对相关的接口进行拦截，这里拦截的是 Js中的几个提示方法，也就是几种样式的对话框。

| Js中方法    | 作用       | 返回值                   | 对应拦截方法    |
| ----------- | ---------- | ------------------------ | --------------- |
| `alert()`   | 弹出警告框 | 没有                     | `onJsAlert()`   |
| `confirm()` | 弹出确认框 | true/false               | `onJsConfirm()` |
| `prompt()`  | 弹出输入框 | 任意设置返回值*输入内容* | `onJsPrompt()`  |

只有在`onJsPrompt()`中可以返回任意字段，可以在其中进行拦截判断，以调用对应方法。

## WebView执行漏洞

### 任意代码执行漏洞

#### WebView中的`addJavascriptInterface()`接口

> 当Js获取到这个对象后，就可以调用到该对象的所有方法，导致漏洞产生。



#### WebView内置导出的`searchBoxJavaBridge_`对象

> Android3.0以下 系统默认通过`searchBoxJavaBridge_`给WebView添加一个Js映射对象：`searchBoxJavaBridge_`对象

#### WebView内置导出的`accessibility`和`accessibilityTraversal`对象

### 密码明文存储漏洞

当WebView开启密码保存功能时导致漏洞`webView.setSavePassword(true)`，密码会被明文保存到`/data/data/com.package.name/databases/webview.db `中，有泄漏危险。

通过设置`webView.setSavePassword(false)`关闭密码保存提醒功能。

### 域控制不严格漏洞

A应用可以通过B应用导出的Activity让B应用家在一个恶意的file协议的url，从而获取到B应用的内部私有文件，带来数据泄露威胁。

对于不需要使用 file 协议的应用，禁用 file 协议；

```java
// 禁用 file 协议；
setAllowFileAccess(false); 
setAllowFileAccessFromFileURLs(false);
setAllowUniversalAccessFromFileURLs(false);
```

对于需要使用 file 协议的应用，禁止 file 协议加载 JavaScript。

```java
// 需要使用 file 协议
setAllowFileAccess(true); 
setAllowFileAccessFromFileURLs(false);
setAllowUniversalAccessFromFileURLs(false);

// 禁止 file 协议加载 JavaScript
if (url.startsWith("file://") {
    setJavaScriptEnabled(false);
} else {
    setJavaScriptEnabled(true);
}
```

## WebView优化

### WebView内存泄漏

**最好是可以去开启一个单独的进程去使用WebView并且当这个进程结束时，手动调用`System.exit(0)`**。

### 后台无法释放js导致耗电

在Js中可能会有一些动画或音频播放会一直执行，即时WebView挂在后台，这些资源也会继续使用，导致耗电加快。

```java
@Override
public void onResume(){
  super.onResume();
  webView.setJavascriptEnabled(true);
}

@Override
public void onStop(){
  super.onStop();
  webView.setJavascriptEnabled(false);
}
```

### `setBuiltInZoomControls`引起的Crash

当调用`setsetBuiltInZoomControls(true)`时去触摸屏幕，然后显示一个缩放控制图标，这图标几秒后会自动消失，这时去主动退出Activity，就会发生`ZoomButton`找不到依附Window导致异常使程序崩溃。

```java
@Override
public void onDestroy(){
  super.onDestroy();
  //手动进行隐藏，就不会导致崩溃了
  webView.setVisibility(View.GONE);
}
```



### 底部空白

当WebView嵌套在ScrollView里的时候，如果WebView先加载了一个高度很高的网页，再加载一个高度很低的网页，就会造成WebView的高度无法自适应，导致底部出现大量空白的情况。

通过JS注入的方式，获取页面内容的高度，获取到后赋值到WebView的高度上。

```java
mWebView.setWebViewClient(new WebViewClient() {
    @Override
    public void onPageFinished(WebView view, String url) {
        mWebView.loadUrl("javascript:App.resize(document.body.getBoundingClientRect().height)");
        super.onPageFinished(view, url);
    }
});
mWebView.addJavascriptInterface(this, "App");


@JavascriptInterface
public void resize(final float height) {
    getActivity().runOnUiThread(new Runnable() {
        @Override
        public void run() {
            //Toast.makeText(getActivity(), height + "", Toast.LENGTH_LONG).show();
            //此处的 layoutParmas 需要根据父控件类型进行区分，这里为了简单就不这么做了
            
            mWebView.setLayoutParams(new LinearLayout.LayoutParams(getResources().getDisplayMetrics().widthPixels, (int) (height * getResources().getDisplayMetrics().density)));
        }
    });
}
```



## WebView独立进程

> WebView容易导致OOM问题，内存占用很大，还容易有内存泄漏的风险
>
> 由于Android版本的不同，4.0之前用的WebKit的内核，4.0之后就换了 chromium做内核了，内核的不同导致兼容性Crash
>
> WebView和Native版本也不一致，导致Crash

多进程的好处：

- Android每个应用的内存占用是有限制的，占用内存越大越容易被杀死。实现多进程时，可有效减少主进程内存占用
- 子进程的崩溃不会影响到主进程的使用
- 独立的进程的启动与退出不依赖于用户的使用，可以完全独立控制，主进程的退出不影响其使用

//TODO 代码]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>组件间通信——LiveDataBus</title>
    <url>/2019/03/21/%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94LiveDataBus/</url>
    <content><![CDATA[
> `LiveData`是一个可以被观察的数据持有类，可以感知并遵循`Activity、Fragment，Service`等组件的生命周期。由于这种特性可以使他做到在特定生命周期执行特定的操作。

`LiveData`优点：

- **UI和实时数据保持一致**：可以在数据发生改变时立即响应到
- **避免内存泄漏**：当绑定的组件被销毁时，会自动清理数据以及移除引用，避免泄漏



根据上述优点，就可以利用`LiveData`去实现一个组件间通信的方案，这套方案相对于`EventBus`、`RxBus`有着明显的优势，不需要显式的去调用反注册方法(*以免内存泄漏*)，而且其自带生命周期感知，可以在Activity等组件处于前台状态时，进行UI更改，避免浪费资源。



## LiveDataBus的组成

- **消息**：用于在组件中通信所传递的数据，可能是基本类型也可能是自定义Model
- **消息通道**：用消息通道来甄别不同的LiveData(*处理对象*)
- **订阅者**：通过消息通道获取对应的`LiveData`，调用`observe()`进行订阅
- **发布者**：通过消息通道获取对应的`LiveData`，调用`postValue()、setValue()`进行消息发送

{% fullimage /images/LiveDataBus结构.png,LiveDataBus结构,LiveDataBus结构%}



## LiveDataBus的实现

按照上述结构图，可以马上就写出一个大致结构

```kotlin
class LiveDataBus private constructor() {
    //用于存放消息通道
    private val map: MutableMap<String, MutableLiveData<Any>?>

    init {
        map = HashMap()
    }

    fun <T> getChannel(target: String, type: Class<T>): MutableLiveData<T> {
        if (!map.containsKey(target)) {
            map[target] = MutableLiveData()
        }
        return map[target] as MutableLiveData<T>
    }

    fun getChannel(target: String): MutableLiveData<Any> {
        return getChannel(target, Any::class.java)
    }

    companion object {
        val instance: LiveDataBus by lazy { LiveDataBus() }
    }
}
```

对应发送数据方法

```kotlin
//同步发送
LiveDataBus.instance.getChannel("web", String::class.java).value = "ssa"
//异步发送
LiveDataBus.instance.getChannel("web",String::class.java).postValue("ssa")
```

对应接收数据方法

```kotlin
LiveDataBus.instance.getChannel("web", String::class.java)
           .observe(this@MainActivity, Observer { s ->
                Log.e("web", s)
           })
```

但是在实际的使用过程中发现了另一个问题，再打开一个新页面时，如果也存在监听者，就会收到该页面打开前所发送的消息，类似*粘性事件*，但大部分场景下是不需要这样的，所以需要针对这个问题进行改进。

## LiveDataBus改进

根据{% post_link LiveData简析%}这部分源码分析可知，LiveData中的数据分发流程如下图所示：

{% fullimage /images/LiveData-dispatch.png,LiveData Dispatch,LiveData Dispatch%}

根据上述流程分析：调用到`setValue()/postValue()`将用户数据进行发送，然后进入到`dispatchValue()`下进行分发，设置`mVersion++(mVersion表示调用方法次数)`，想下调用到`considerNotify()`内部需要判断`observer.mLastVersion(Observer注册次数)`与`mVersion`大小，如果小于就会调用到对应`Observer.onChanged()`事件进行分发。

*由于初始化时，先会调用到`postValue()/setValue()`此时mVersion+1，就比`mLastVersion`要大，就会触发事件的分发。*

### 改进方案

**只要可以设置`mLastVersion`与`mVersion`保持一致，就不会进行事件的分发。**

此时需要利用**反射**的方式对`LiveData`中的数据进行改变，首先按照需求，先要找到`Observer`，然后修改其中的`mLastVersion`即可。

```java LiveData.java
 @MainThread
    public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<T> observer) {
        if (owner.getLifecycle().getCurrentState() == DESTROYED) {
            // ignore
            return;
        }
        LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);
        //存储所有的Observer对象
        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
        if (existing != null && !existing.isAttachedTo(owner)) {
            throw new IllegalArgumentException("Cannot add the same observer"
                    + " with different lifecycles");
        }
        if (existing != null) {
            return;
        }
        owner.getLifecycle().addObserver(wrapper);
    }
```

需要从`mObservers`中入手，然后找到对应`Observer`即可。

> 除了`observer()`外，还有一个`observerForever()`，该方法是一直存在监听的，而且不会绑定对应的组件，所以可以在任意组件中监听到事件，如果使用时，需要注意销毁。

### 改进代码

```kotlin
package com.wxy.router.eventbus.utils

import android.arch.lifecycle.LifecycleOwner
import android.arch.lifecycle.LiveData
import android.arch.lifecycle.MutableLiveData
import android.arch.lifecycle.Observer

import android.icu.lang.UCharacter.GraphemeClusterBreak.T
import java.lang.Exception
import java.lang.NullPointerException
import java.util.*


class LiveDataBus private constructor() {

    //用于存放消息通道
    private val map: MutableMap<String, BusMutableLiveData<Any>?>

    init {
        map = HashMap()
    }

    fun <T> getChannel(target: String, type: Class<T>): BusMutableLiveData<T> {
        if (!map.containsKey(target)) {
            map[target] = BusMutableLiveData()
        }
        return map[target] as BusMutableLiveData<T>
    }

    fun getChannel(target: String): BusMutableLiveData<Any> {
        return getChannel(target, Any::class.java)
    }

    companion object {
        val instance: LiveDataBus by lazy { LiveDataBus() }
    }

    //Observer装饰类
    class ObserverWrapper<T>() : Observer<T> {

        private var observer: Observer<T>? = null

        constructor(observer: Observer<T>) : this() {
            this.observer = observer
        }

        override fun onChanged(t: T?) {
            observer?.let {
                if (isCallOnObserve()) return@let
                it.onChanged(t)
            }

        }
        //判断当前 Observer类型是否为永久存在，如果是则不予处理
        private fun isCallOnObserve(): Boolean {
            val stackTrace = Thread.currentThread().stackTrace
            if (stackTrace.isNotEmpty()) {
                stackTrace.forEach { stackTraceElement ->
                    if ("android.arch.lifecycle.LiveData" == stackTraceElement.className &&
                        "observeForever" == stackTraceElement.methodName
                    ) {
                        return true
                    }
                }
            }
            return false
        }
    }

    class BusMutableLiveData<T> : MutableLiveData<T>() {
        private val observerMap: MutableMap<Observer<T>, Observer<T>> = hashMapOf()

        override fun observe(owner: LifecycleOwner, observer: Observer<T>) {
            super.observe(owner, observer)
            try {
                hook(observer)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        override fun observeForever(observer: Observer<T>) {
            if (!observerMap.containsKey(observer)) {
                observerMap[observer] = LiveDataBus.ObserverWrapper(observer)
            }
            super.observeForever(observer)
        }
        
        override fun removeObserver(observer: Observer<T>) {
            val realObserver: Observer<T>? = if (observerMap.containsKey(observer)) {
                observerMap.remove(observer)
            } else {
                observer
            }
            realObserver?.let { super.removeObserver(it) }
        }

        private fun hook(observer: Observer<T>) {
            try {
                val classLiveData = LiveData::class.java
                //获取LiveData中的 mObservers 对象
                val fieldObservers = classLiveData.getDeclaredField("mObservers")
                fieldObservers.isAccessible = true

                val objectObservers = fieldObservers.get(this)
                val classObservers = objectObservers.javaClass
                val methodGet = classObservers.getDeclaredMethod("get", Object::class.java)
                methodGet.isAccessible = true
                val objectWrapperEntry = methodGet.invoke(objectObservers, observer)
                var objectWrapper: Any? = null
                if (objectWrapperEntry is Map.Entry<*, *>) {
                    objectWrapper = objectWrapperEntry.value
                }
                if (objectWrapper == null)
                    throw NullPointerException("wrapper can not be null")
                //获取对应Observer对象
                val classObserverWrapper = objectWrapper.javaClass.superclass
                //获取其中 mLastVersion数据
                val fieldLastVersion = classObserverWrapper.getDeclaredField("mLastVersion")
                fieldLastVersion.isAccessible = true
                //获取其中mVersion数据
                val fieldVersion = classLiveData.getDeclaredField("mVersion")
                fieldVersion.isAccessible = true

                val objectVersion = fieldVersion.get(this)
                //重新赋值 使两者相等则事件不会进行分发
                fieldLastVersion.set(objectWrapper, objectVersion)
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }
}
```

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>ANR分析</title>
    <url>/2019/01/28/ANR%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
<!--简要解释一下 ANR？为什么会发生 ANR？如何避免发生 ANR？如何定位 ANR？ANR发生条件？如何分析ANR-->

## ANR概述

> ANR：`Application Not Responding`应用程序未响应，Android会要求一些事件需要在规定时间内处理完成，如果超过预定事件内未能得到有效响应或者响应时间过长，就会造成ANR。

ANR由**消息处理机制**保证，Android在系统层实现了发现ANR的机制，核心原理是**消息调度和超时处理**。

ANR本质是**性能问题**。实际上是对应用程序主线程的限制，要求主线程在限定时间内处理完一些最常见的操作(*启动服务，处理广播，处理输入*)，如果处理超时，则认为主线程已经失去了响应其他操作的能力。

## ANR发生场景

- **输入事件(按键和触摸事件)5s内未处理**：Input event dispatching timed out
- **BroadcastReceiver的`onReceive()`在规定时间内没处理完(*前台广播为10s，后台广播为60s*)**：Timeout of broadcast BoradcastRecord
- **Service在*前台20s后台200s*时间内为启动完成**：Timeout executing service
- **ContentProvider的`publish()`在10s内没有执行完成**：Timeout publishing content providers

## ANR机制

> ANR机制主要分为两部分：**ANR监测机制**，**ANR报告机制**。
>
> - ANR监测机制：Android对于不同的ANR类型(*Broadcast,Service,InputEvent*)都有一套监测机制。
> - ANR报告机制：在监测到ANR后，需要显示ANR对话框，输出日志等

### 输入事件超时监测

#### 输入系统简介

内核将原始事件写入到设备节点中，`InputReader`在期限错循环不断的从`EventHub`中抽取原始输入事件，进行加工处理后将加工所得的事件放入`InputDispatcher`的派发队列中。`InputDispatcher`在其线程循环中将派发队列中的事件取出，查找合适的窗口，将事件写入到窗口的事件接收管道中。

#### 超时监测

{% fullimage /images/输入事件超时监测.webp,输入事件超时监测,输入事件超时监测%}

`InputDispaycher::dispatchOnceInnerLocked()`：根据事件类型选择不同事件的处理方法

`InputDispaycher::findFocusedWindowTargetsLocked()`：内部调用`checkWindowReadyForMoreInputLocked()`检查窗口是否有新能力在接受新的输入事件。

`InputDispatcher::handleTargetsNotReadyLocked()`：进行判断事件5s之内是否分发完毕

当应用主线程被卡住时，再点击其他组件也是无响应，因为事件派发是串行的，上一事件未处理完毕，下一事件不会向下执行。

在`Activity.onCreate()`执行耗时操作，不管用户如何操作都不会发生ANR，因为输入事件相关监听机制尚未建立起来。

输入事件由`InputDispatcher`调度，待处理的输入输出事件都会进入队列中等待，设计了一个等待超时的判断。

### Service超时监测

本身有分析过`Service的启动流程`，在其中了解到`ActiveServices.realStartServiceLocked()`是真正的Service启动流程。

```java
// ../core/java/com/android/server/am/ActiveServices.java  
// How long we wait for a service to finish executing.
    static final int SERVICE_TIMEOUT = 20*1000;

    // How long we wait for a service to finish executing.
    static final int SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * 10;

//真正启动Service
private final void realStartServiceLocked(ServiceRecord r,
            ProcessRecord app, boolean execInFg) throws RemoteException {
        ...
        // 主要是为了设置ANR超时，可以看出在正式启动Service之前开始ANR监测；
        bumpServiceExecutingLocked(r, execInFg, "create");
       // 启动过程调用scheduleCreateService方法,最终会调用Service.onCreate方法；
        app.thread.scheduleCreateService(r, r.serviceInfo,
        // 绑定过程中，这个方法中会调用app.thread.scheduleBindService方法
        requestServiceBindingsLocked(r, execInFg);
        // 调动Service的其他方法，如onStartCommand，也是IPC通讯
        sendServiceArgsLocked(r, execInFg, true);
    }

//设置超时监测                                         
void scheduleServiceTimeoutLocked(ProcessRecord proc) {
        if (proc.executingServices.size() == 0 || proc.thread == null) {
            return;
        }
        Message msg = mAm.mHandler.obtainMessage(
                ActivityManagerService.SERVICE_TIMEOUT_MSG);
        msg.obj = proc;
        // 在serviceDoneExecutingLocked中会remove该SERVICE_TIMEOUT_MSG消息，
        // 当超时后仍没有remove SERVICE_TIMEOUT_MSG消息，则执行ActiveServices. serviceTimeout()方法；
        mAm.mHandler.sendMessageDelayed(msg,
                proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);
        // 前台进程中执行Service，SERVICE_TIMEOUT=20s；后台进程中执行Service，SERVICE_BACKGROUND_TIMEOUT=200s
    }

//在AMS中收到了  SERVICE_TIMEOUT_MSG Message就会触发该方法                                       
void serviceTimeout(ProcessRecord proc) {
    ...
    final long maxTime =  now -
              (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);
    ...
    // 寻找运行超时的Service
    for (int i=proc.executingServices.size()-1; i>=0; i--) {
        ServiceRecord sr = proc.executingServices.valueAt(i);
        if (sr.executingStart < maxTime) {
            timeout = sr;
            break;
        }
       ...
    }
    ...
    // 判断执行Service超时的进程是否在最近运行进程列表，如果不在，则忽略这个ANR
    if (timeout != null && mAm.mLruProcesses.contains(proc)) {
        anrMessage = "executing service " + timeout.shortName;
    }
    ...
    if (anrMessage != null) {
        // 当存在timeout的service，则执行appNotResponding，报告ANR
        mAm.appNotResponding(proc, null, null, false, anrMessage);
    }
}
```

Service启动前会先启动超时监测，如果在指定时间内(*前台20s后台200s*)没有启动完毕，就会调用到`ActiveServices.serviceTimeout()`报告ANR；如果执行完毕，会调用到`ActiveServices.serviceDoneExecutingLocked()`在其中`removeMessages(SERVICE_TIMEOUT_MSG)`移除超时消息。

### ANR报告机制

无论哪种类型的ANR发生后，最终都会调用到`AppErrors.appNotResponding()`。这个方法主要的功能就是**向用户或开发者报告ANR发生了。**最终的表现就是弹出一个对话框，告诉用户当前程序无法响应；并且会输出ANR日志，以供开发者分析。

- **event log**：通过检索"am_anr"关键字，可以找到发生ANR的应用
- **main log**：通过检索"ANR in"关键字，可以找到ANR的信息，日志的上下文会包含CPU的使用情况
- **dropbox**：通过检索"anr"类型，可以找到ANR的信息
- **traces**：发生ANR时，各进程的函数调用栈信息 (*可以通过`adb pull data.anr/traces.txt`导出trace文件*)

ANR报告相关内容主要为以上四种，后续如果需要分析ANR问题，分析ANR往往是从`main log中的CPU使用情况和导出的traces.txt文件`进行分析。

## ANR分析

ANR问题的产生是由于主线程的任务无法在规定事件内无法完成。造成这种情况的原因大致会有以下几点：

- 主线程在做一些耗时的工作
- 主线程被其他线程锁
- cpu被其他线程占用，导致该进程没有被分配到足够的CPU资源

分析思路主要是:

1. `从log中找到ANR发生的信息`：在log中搜索`am_anr或ANR in`找到ANR发生的log，包含了ANR发生的时间，进程，ANRtype。
2. `继续分析CPU usage的信息`：表明了CPU在ANR前后的用量，从各种CPU usage信息中可以分析几点：
   - 如果其他进程占用CPU较多，而发生ANR的进程占用较低，可以认为是 因为CPU资源未分配足够，导致的ANR
   - 如果ANR进程占用CPU较多，可以怀疑是内部一些不合理的代码导致CPU资源大量消耗，如出现了死循环或者后台有大量线程在执行任务，或者存在频繁的文件读写(*iowait*)
   - CPU总用量都不高，该进程和其他线程的占用过高，可能是由于主线程的操作耗时过长，或者主线程被锁导致。
3. `向下继续分析 trace文件`：trace文件记录了发生ANR前后该进程中各个线程的stack。对我们分析ANR问题最有价值的就是主线程的stack(`main`)。一般主线程trace中可能有如下几种情况：
   - 主线程是`running或native`而对应的栈对应了我们应用中的函数，则很有可能是执行该函数发生了超时
   - 主线程是`block`，主线程被锁，可以考虑进行优化代码，解除掉锁的状态。如果是死锁问题，需要及时处理



## ANR避免和检测

默认情况下，Android应用程序通常在单线程上运行——**主线程**。ANR的发生场景主要是在主线程中进行了耗时操作。

> 哪些算作UI主线程？
>
> - Activity的所有生命周期回调都是执行在主线程的
> - Service默认执行在主线程
> - BoradcastReceiver的`onReceive()`回调在主线程
> - 没有使用子线程的Looper的Handler实现的`handleMessage()`
> - AsyncTask除了`doInBackground()`执行在主线程
> - View的`post(runnable)`执行在主线程

**主要原则是不要在主线程中做耗时操作。**



检测可以利用BlockCanary -- 基本原理是利用主线程的消息队列处理机制，通过对比消息分发开始和结束的时间点来判断是否超过设定的时间，超过则判断为线程卡顿。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Fragment相关</title>
    <url>/2018/01/10/Fragment%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[
<!--Activity和Fragment数据交互 Fragment初始化参数调用哪个方法？ Fragment懒加载怎么实现？Fragment重叠问题-->

> Android中展示界面一般是通过`Activity`去实现的，当要实现类似商城类的首页时，就会拿出`Fragment`去实现对应的每个标签页，由`Activity`进行管理。

## Fragment介绍

`Fragment`存在必须依附于`FragmentActivity`使用，并且与`FragmentActivity`一样，拥有自己独立生命周期，同时可以处理用户的交互动作。并且可以在一个`Activity`中动态的添加、替换，移除不同的`Fragment`，同样`Fragment`也可以拥有多个子`Fragment`并对他们进行控制，对于信息的显示有很大的便利性。

## Fragment使用方式

### Fragment初始化

默认提供两种初始化方式：

- `new XXFragment()`

  ```java 
  DemoFragment fragment = new DemoFragment()
  ```

- `xml 引入`

  ```xml
  <fragment
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            class="com.demo.fragment.DemoFragment"/>
  ```

主流使用的是第一种方法，但是并不是推荐的标准用法，如果需要有参数传入的情况下。

在`Fragment`中添加`newInstance()`，然后方法里面传入参数，以后获取Fragment就调用该方法，不要使用`new`方法。

```java DemoFragment.java
public static DemoFragment newInstance(Bundle args) {
    DemoFragment f = new DemoFragment();
    f.setArguments(args);
    return f;
}
```

```java DemoActivity.java
Bundle args = new Bundle();
args.putString(text,Hello);
MyFragment f = MyFragment.newInstance(args)
```

> Fragment会被重新销毁(可能因为内存不足、手机发生了配置变化)，重新创建时会默认调用无参构造函数。
>
> 通过`setArguments()`传递的Bundle也会被保留下来。

### 操作Fragment

```java
//获取FragmentManager对象 这是Activity方式
FragmentManager fragmentManager = getSupportFragmentManager();

//从Fragment中获取 FragmentManager
FragmentManager fragmentManager = getChildFragmentManager()
//开启事务，通过 FragmentTransaction 进行add()、remove()等操作
FragmentTransaction ft = fragmentManager.beginTransaction();
//添加Fragment
ft.add(R.id.fragment,DemoFragment.newInstance());
//提交事务
ft.commit();
```

涉及到了以下类：

`FragmentManager`

在Activity通过`getSupportManager`获取该对象，在`Fragment`中通过`getChildFragmentManager()`获取

`FragmentTransaction`：Fragment操作事务

通过`beginTransaction()`开启事务，事务开启后就可以对`Fragment`进行操作

以下为几种常用的操作方法：

`add()`：添加Fragment到Activity或Fragment中

`hide()/show()`：隐藏和显示Fragment

`remove()`：移除指定Fragment

`replace()`：内部实质是调用`remove()`和`add()`完成Fragment修改过程

`addToBackStack()`：添加当前Fragment到回退栈中，当按下返回键时可以根据回退栈进行操作

`commit()`：提交事务，对Fragment进行操作后都需要`commit()`完成提交后可以生效

`commitAllowingStateLoss()`：也是提交事务的一种，但是不会在其中抛出异常，只是跳过了检测`mStateSaved`是否进行了保存

> 确保`commit()`在`Activity.onPostResume()`或者`FragmentActivity.onResumeFragments()`内调用，而且不要随意使用`commitAllowingStateLoss()`进行代替，不能滥用该方法。因为忽略状态丢失，Activity意外崩溃时就无法还原之前保存的数据。

添加Fragment有两种方法：

通过`replace()`

```java
ft.replace(R.id.fragment,DemoFragment.newInstance())
```

通过`add()`配合`show()、hide()`

```java
ft.add(R.id.fragment,DemoFragment.newInstance());
//显示时调用
ft.show();
//显示其他Fragment时调用
ft.hide()
```

> `replace()`不会保留Fragment的状态，会销毁视图并重新加载，调用时保存的数据都会消失。
>
> `hide()/show()`只是对Fragment进行隐藏/显示，不会影响存储的数据

## Fragment生命周期

{% fullimage /images/Fragment生命周期.png,Fragment生命周期,Fragment生命周期%}

`onAttach()`：Fragment和Activity绑定时调用。**Fragment附加到Activity之后，无法再次调用`setArguments()`**

`onCreate()`：此时可以获取到`setArguments()`传递过来的参数，通过Bundle获取

`onCreateView()`：在Fragment加载布局时调用

```java
 public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(getLayoutResId(), container, false/*不要把View主动添加到container,这个是自动关联的*/);
}

```

`onActivityCreated()`：当Activity的`onCreate()`执行完成后调用

`onDestoryView()`：Fragment中布局被移除时调用

`onDetach()`：Fragmen和Activity解绑时调用



其中还有一个`setRetainInstance()`当调用到该方法时，在Actiivity重新创建时可以完全不销毁`Fragment`，以便Fragment中恢复数据。调用了

`setRetainInstance(true)`后，Fragment恢复时就会跳过`onCreate()`、`onDestroy()`生命周期回调，因此在使用该方法时，`onCreate()`中不要做初始化逻辑。

> 当因为设备配置发生变化时，`FragmentManager`首先销毁队列中的fragment的视图，接着`FragmentManager`会检查`Fragment`中的`retainInstance`属性，如果为false，直接销毁Fragment实例；若设置为true，fragment的视图会被销毁，但fragment本身不会被销毁，处于短暂的保留状态。当Activity需要时会对其进行恢复。

## Fragment通信

### Fragment与Activity通信

1. 如果Activity中包含自己管理的Fragment的引用，可以通过该引用直接访问所有public方法

2. Activity中未保存任何Fragment的引用，通过给每个Fragment设置`Tag或ID`，后面通过调用`FragmentManager.findFragmentByTag()或FragmentManager.findFragmentById()`获取对应Fragment实例

3. 在Fragment通过`getActivity()`获取Activity实例，然后执行操作。

   通过`getActivity()`获取Activity实例，可能会返回`null`导致异常。该方法返回结果只会在`onAttach()`及`onDetach()`会非空，其他时候都有可能为空，所以可以先使用`getContext()`去进行替代，这样比较安全。

   还有一种就是定义一个全局变量，当触发`onAttach()`进行赋值，后续调用直接使用该全局变量

   ```java DemoFragment.java
   Context context ;
   @Override
   public void onAttach(Context context){
     super.onAttach(context);
     this.context = context;
   }
   ```

   

4. **使用接口方式(推荐做法)**

   ```java DemoFragment.java
   //Fragment中定义接口
   public interface ShowMsgListener{
           void showMsg(String str);
       }
   private ShowMsgListener msgListener; 
   
   @Override
       public void onAttach(Activity activity) {
           super.onAttach(activity);
           try {
               if(activity!=null){
                   //获取Activity中实现的接口
                   msgListener=(DemoActivity)activity;
               }
           } catch (ClassCastException e) {
               throw new ClassCastException(activity.toString()
                       + " must implement showMsgListener");
           }
       }
   
   //调用接口
   msgListener.showMsg("From fragment")；
   ```

   ```java DemoActivity.java
   public DemoActivity extends FragmentActivity implements ShowMsgListener{
     @Override
     public void showMsg(String str){
       //拿来做事
     }
   }
   ```

5. Fragment从Activity获取数据



### Fragment与Fragment通信

> Fragment之间的通信需要通过Activity进行关联，不应该是直接的进行通信。

实现通信步骤主要有以下三步：

1. 定义接口
2. Activity实现接口
3. 在接口方法中Activity调用对应Fragment

## Fragment常见问题

### Fragment重叠

当`宿主Activity`因为被系统回收或者配置发生改变导致销毁重建时，会重新执行`onCreate()`，就有可能重新执行一次`Fragment`创建过程，然后又会新建一个`Fragment`。

```java DemoActivity.java
@Override
public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.act_demo);
  FragmentManager fm = getSupportFragmentManager();
  FragmentTransaction ft = fm.beginTransaction();
  DemoFragment demoFragment;
  
  //可能触发 内存重启
  if(savedInstanceState!=null){
    List<Fragment> fragmentList = getSupportFragmentManager().getFragments();
    for(Fragment fragment : fragmentList){
      if(fragment instanceof DemoFragment)
      	demoFragment = (DemoFragment)fragment
    }
    //直接显示已存在的fragment
    ft.show(demoFragment).commit();
  }else{
    demoFragment = DemoFragment.newInstance();
    ft.add(R.id.fragment,demoFragment);
    ft.commit();
  }
}
```

### Fragment懒加载

> 懒加载：只在要使用时才去加载数据，而不是在初始化时就加载完毕。

在加载数据前需要先判断三种状态：

- 数据是否已经加载过
- Fragment是否已经调用到`onCreate()`
- 界面对于用户是否可见



### Fragment.startActivityForResult()

#### Fragment启动，Activity获取结果

```java DemoFragment.java
getActivity().startActivityForResult(...)
```

```java DemoActivity.java
@Override
public void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
}
```



#### Fragment启动，Fragment获取结果

```java DemoFragment.java
startActivityForResult()
  
@Override
public void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
}
```

```java DemoActivity.java
@Override
public void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
}
```

> 要求父Activity必须覆写了`onActivityResult()`且调用了`super.onActivityResult()`。

### Fragment配合ViewPager使用

一般类似资讯类、新闻类App首页都会分成多个标签，在不同的标签会有不同的内容，这个时候就需要配合ViewPager来实现内容展示，关键在于对应的fragment是否需要进行销毁。

可用的Adapter分为两种：

- `FragmentPagerAdapter`：对于不再需要的fragment，选择调用`detach()`，仅销毁视图并不会销毁fragment实例。
- `FragmentStatePagerAdapter`：再切换不同fragment的时候，会把前面的fragment进行销毁，但是在系统销毁前，会存储其Fragment的Bundle，倒是需要重新创建Fragment时，可以从`onSaveInstanceState()`获取保存的数据。

使用`FragmentStatePagerAdapter`比较省内存，但是销毁重建的过程也是需要时间的，如果页面较少可以使用`FragmentPageAdapter`，很多的话还是推荐`FragmentStatePagerAdapter`。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的锁事</title>
    <url>/2019/03/15/Java%E4%B8%AD%E7%9A%84%E9%94%81%E4%BA%8B/</url>
    <content><![CDATA[
Java中提供了种类丰富的锁，定义这些锁可以在适当的场景中发挥更好的作用。

## 乐观锁&悲观锁
### 乐观锁
> 每次去拿取数据的时候认为不会有人进行修改，所以不会去添加锁。只是会在更新数据时去判断是否有其他线程对这个数据进行了修改。通过判断**版本号**检测是否发生了更新，未发生变化直接写入新数据；发生了变化，就需要重复执行**‌读版本号-比较有无发生变化-写入新数据**操作。
> 在Java中一般通过`CAS算法`实现。例如`Atomic*`类内部都是通过`CAS`实现的。
乐观锁适合**读操作多**的场景，不加锁可以大大提升读操作的效率。

#### CAS算法
> `compare and swap(比较与交换)`，是一种无锁算法(*在不使用锁的情况下实现线程间的变量同步*)。

`CAS算法`涉及了三个操作数：

- 需要读写的内存值 **V**
- 进行比较的值 **A**
- 要写入的新值 **B**

**当且仅当V的值等于A时，CAS通过原子方式更新V的值为B。否则不会执行任何操作(`比较与更新为一个原子操作`)，一般情况下为一个`自旋操作`，需要不断进行重试。**

#### 乐观锁缺点

##### ABA问题

`CAS`需要在操作值的时候检查内存值是否发生了变化，没有发生变化才会去更新值。但有一种特殊情况，内存中的值发生了`A->B->A`这类变化，在检查时得到的结果就是没有发生变化，这显然是不合理的。

解决该问题的方法有两种：

- 通过在变量前面添加版本号，每次变量更新时进行版本号增加操作，可以保证监听到值的变化
- 通过`AtomicStampedReference`类解决，需要检查当前引用与预期引用，当前标记与预期标记是否相同，相同则更新。

##### 循环时间长开销大

`CAS`操作不成功时，默认会进行自旋操作(*直到成功为止*)，会一直占用CPU资源造成极大的消耗。

可以通过`处理器的pause指令`进行解决。

> `pause指令`有两个作用：
>
> - 延迟流水线执行
> - 避免退出循环时因为内存顺序冲突引起CPU流水线被清空

##### 只能保证一个共享变量的原子操作

`CAS`只对单个变量有效，无法对多个变量同时生效。

可以通过`AtomicReference`来保证引用对象之间的原子性，把多个变量放于同一个对象里进行CAS操作。

### 悲观锁

> 每次去拿取数据的时候都认为别人会进行修改，所以每次在拿数据的时候都会进行上锁操作，确保数据不会被其他线程修改。在其他线程想要操作该数据时，就会被**阻塞**直到得到锁(*共享资源每次只给一个线程使用，其他线程被阻塞，等到当前线程使用完毕后，其他线程才可以获取锁*)。
>
> 可以通过`Thread.holdsLock()`来获取当前线程是否持有锁。

悲观锁适合**写操作多**的场景，可以保证进行写操作时的数据正确。

其中Java中的`synchronized`及`Lock`就是悲观锁的具体实现。

## 锁的状态

在JVM中锁的状态分为四种：

- 无锁：例如CAS操作
- 偏向锁
- 轻量级锁
- 重量级锁：`synchronized`

锁的进化状态为：**无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁**。`不可退化`

### 对象头

> 锁的每个状态都是有标记的，他们都存储于**对象头的Mark Word**中。

对象头分为两部分：`Mark Word`、`Klass Pointer`

`Mark Word`：存储对象的HashCode，分代年龄、线程ID以及锁标志信息。

{% fullimage /images/MarkWord.png,Mark Word,Mark Word %}

其中四种锁状态主要对应在锁标志位上

| 锁状态   | 锁标志 | 存储内容                                          |
| -------- | ------ | ------------------------------------------------- |
| 无锁     | 01     | 对象的HashCode、分代年龄、是否是偏向锁(0)         |
| 偏向锁   | 01     | 偏向线程ID、偏向时间戳、分代年龄，是否是偏向锁(1) |
| 轻量级锁 | 00     | 指向栈中锁记录的指针                              |
| 重量级锁 | 10     | 指向互斥量(重量级锁)的指针                        |

`Klass Pointer`：对象指向它的类元数据指针，虚拟机通过该指针确定实例。

### 无锁

> 不会对资源进行锁定，所有线程都能访问并修改同一个资源，但是只能有一个线程修改成功在同一时间内。

无锁的特点就是修改操作在循环中进行，线程会不断的去尝试修改共享资源。如果修改成功就直接退出，否则继续循环尝试。

**在已存在线程修改共享资源时，其他线程会进入自旋状态直至修改成功。**

#### 自旋锁

> 如果持有锁的线程能在很短的时间内就释放锁，其他需要等待竞争锁的线程就不需要在**内核态和用户态**之间进行切换，导致进入阻塞状态，其他线程只有执行**自旋**，等待执行操作的线程释放锁之后就可以去直接获取锁，避免线程切换的开销。

##### 优缺点

自旋锁尽可能的减少**阻塞**发生，对于`锁的竞争不激烈且不会占用锁事件过长的操作`性能提升明显，自旋的消耗相对线程的切换小很多。在线程阻塞和唤醒的过程中会发生两次*上下文切换*过程。

> 上下文切换：当CPU执行从一个线程切换到另一个线程时，需要先存储当前线程的本地数据、程序指针等。然后载入另一线程的本地数据、程序指针等，然后开始执行另一个线程。



自旋锁本身是有缺点的，无法代替**阻塞**功能。自旋虽然避免了线程切换的开销，但是需要占用CPU。如果锁被占用的时间很短，自旋锁的效果就会非常好。

但是，如果锁被占用的时间很长，其他自旋等待的线程就会一直占用CPU资源，导致极大的浪费。这时就需要去关闭自旋锁。

*默认设置自旋次数超过10次`-XX:PreBlockSpin进行修改`就会自动关闭并挂起当前线程。*

#### 自适应自旋锁

> 在1.6之前，自旋次数上限是写死的，在1.6之后引入了`自适应自旋锁`，意味着自旋上限不再是固定的，而是根据 **上一次同一个锁上的自旋时间以及锁拥有者的状态进行决定的**。



### 偏向锁

> 一段同步代码一直被同一个线程访问，那么该线程自动获取锁，降低获取锁的代价。

#### 适用场景

始终只有一个线程在执行同步代码块，即使没有执行完，也不会有其他线程去执行同步代码块。**为了在只有一个线程执行同步代码块时提高性能。**

在高并发场景下会直接禁用偏向锁，通过设置`-XX:-UseBiasedLocking`。关闭后，会进入**轻量级锁**。

#### 获取过程

1. 当线程访问同步块代码并获取锁时，会在`Mark Word`中存入当前线程的ID并设置偏向锁标识为1
2. 再次有线程访问该代码块时，先去判断`Mark Word`中偏向锁标识是否为1且线程ID是否一致
3. 若一致，则执行同步代码
4. 不一致时，需要通过`CAS`去获取锁，如果竞争成功，修改`Mark Word`中的线程ID为当前线程
5. 若竞争失败，说明当前还有其他线程在竞争锁。那么就需要释放偏向锁。

#### 释放过程

偏向锁只有遇到其他线程竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。

偏向锁的释放，需要等待**全局安全点(safe-point)-当前时间点没有字节码在执行**，会首先暂停拥有偏向锁的线程，并判断该锁对象是否处于被锁定状态。

释放偏向锁后恢复**无锁**状态或进化到**轻量级锁(标记00)**状态。

### 轻量级锁

> 轻量级锁是由偏向锁升级来的，当偏向锁被另一个线程访问时，偏向锁就会升级为轻量锁。
>
> 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。**轻量级锁并不是用来替代传统重量级锁。**

#### 加锁过程

1. 代码进入同步块的时候，如果同步对象锁状态为无锁状态(标志位01，是否为偏向锁0)，在当前线程的栈帧中建立一个`Lock record`用于存储`Mark Word`，名为`Displaced Mark Word`。
2. 拷贝当前线程对象头的`Mark Word`到`Lock Record`中
3. 拷贝成功后，虚拟机使用`CAS`操作尝试将对象的`Mark Word`更新为指向`Lock Record`指针，并将`Lock Record`指针指向`Mark Word`
4. 更新成功，该线程就拥有了对象的锁，并且设置`Mark Word`的锁标志位为`00`，表明当前处于轻量级锁定状态。



> 如果更新失败，虚拟机首先检查`Mark Word`。

#### 释放锁过程



### 重量级锁



#### 阻塞

## 锁优化

### 锁消除

### 锁粗化

## 其他锁分类

### 公平锁&非公平锁

### 可重入锁&非重入锁

### 独占锁&共享锁

### 读写锁

## 死锁

> 两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们会互相阻塞。

产生死锁的条件有4个：

- 互斥条件：一个资源每次只能被一个线程占用
- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放
- 不剥夺条件：线程已获得的资源，未使用完之前不得强行剥夺
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。



## 内容引用

[JAVA中锁的深入理解与解析](<https://juejin.im/post/5c8a00e56fb9a049a42feb54#heading-21>)

[不可不说的Java“锁”事](<https://juejin.im/post/5bee576fe51d45710c6a51e0#heading-2>)]]></content>
      <tags>
        <tag>Hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程基础</title>
    <url>/2018/12/19/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[
<!--生成者-消费者模式 创建线程 为什么要使用多线程？会有什么问题 线程池概念以及实现原理、四种初始化方案 开线程影响那块区域 进程与线程 多线程断点续传 线程关闭以及防止线程的内存泄漏 线程池上限 为什么要有线程 并发 线程模型 wait和sleep的区别 控制允许并发访问的个数 自己实现线程安全类-->

# Java多线程基础

{% fullimage /images/多线程基础.png,多线程基础,多线程基础%}

## 基础概念

### 进程

> 操作系统结构的基础，是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单位。`进程就是程序的实体`

### 线程

> 线程是进程的一个实体，是CPU调度和分配的基本单位，线程是一个比进程更小的执行单位，一个进程在执行期间可以产生多个线程。`一个进程至少一个线程`。一般应用于高并发场景，可以提高CPU的利用率。

### 多进程

> 每个进程都拥有自己独立的资源，多个进程可在单核处理器上并发执行，在多核处理器并行执行。

### 多线程

> 一个进程可由多个线程组成，多个线程共享进程内资源，多个线程可在单核处理器上并发执行，在多核处理器并行执行。解决多任务同时执行的需求，合理使用CPU资源。**多线程具有不稳定性**

### 并发

> 在一段时间内多个任务同时执行，或者说在一段时间内可以执行多条指令，微观上看起来就是同时运行多个进程。**偏重于多个任务交替执行，有可能串行执行**

### 并行

> 在同一时刻内多个任务同时执行，多核处理器才可以做到。**偏重于同时执行。**

## 线程基础

{% fullimage /images/线程基础.png,线程基础,线程基础%}

### 1. 进程与线程

两者的区别：

- 多个进程间的内部数据和状态都是完全独立的，而多线程是共享一块内存空间和一组系统资源，有可能互相影响
- 线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以**线程的切换负担比进程的切换负担小**
- 进程是重量级的任务，需要分配给他们独立的地址空间，进程间通信以及切换时很复杂的。

### 2. 线程的实现

线程的实现一般有以下3中方法，前面两种比较常见：

- #### 继承Thread类，重写`run()`方法

  > `Thread`本质上是实现了`Runnable`接口的一个实例。**调用`start()`后并不是立即执行代码，而是是线程的状态变为`Runnable`可运行态，何时运行由操作系统决定。**

  主要步骤：

  1. 定义Thread类的子类，重写`run()`方法，`run()`方法内部代表了线程需要完成的任务，所以该方法又称`执行体`
  2. 创建Thread类子类实例，即创建线程对象
  3. 调用线程对象的`start()`启动线程

  ```java
  public class ThreadTest extends Thread{
      public void run(){
          System.out.println("Hello Thread");
      }
      
      public static void main(String[] args){
          Thread thread = new ThreadTest();
          thread.start();
      }
  }
  ```

  拓展：

  只调用`run()`和执行普通方法是一致的。

- ####  实现Runnable接口，并实现`run()`方法

  主要步骤：

  1. 自定义类实现`Runnable`，实现`run()`方法
  2. 创建Thread类子类实例，即创建Thread对象
  3. 调用实例的`start()`

  ```java
  public class RunnableTest implements Runnable{
      public void run(){
          System.out.println("Hello Runnable");
      }
      public static void main(String[] args){
          RunnableTest runnable = new RunnableTest();
          Thread thread = new Thread(runnable);
          thread.start();
      }
  }
  ```

- #### 实现Callable接口，重写`call()`方法需配合`Future`或者`FutureTask`

  主要步骤：

  1. 创建`Callable`接口实现类，并实现`call()`方法
  2. 创建`Callable`实现类的实例，使用`FutureTask`包装`Callable`对象
  3. 使用`FutureTask`对象作为Thread对象的target创建并启动新线程
  4. 调用`FutureTask`对象的`get()`方法获得子线程执行结束后的返回值，**调用`get()`会阻塞线程**

  ```java
  public class TestCallable {
      public static class MyTestCallable implements Callable<String>{
          @Override
          public String call() throws Exception {
              return "Hello Callable";
          }
      }
  
      public static void main(String[] args){
          MyTestCallable myTestCallable = new MyTestCallable();
          //利用futuretask 
          FutureTask<String> futureTask = new FutureTask<>(myTestCallable);
          Thread t =new Thread(futureTask);
          t.start();
          try {
              System.err.println(futureTask.get());
          } catch (InterruptedException | ExecutionException e) {
              e.printStackTrace();
          }
          //利用ExecutorService产生一个线程 结合future
          ExecutorService executorService = Executors.newSingleThreadExecutor();
          Future future = executorService.submit(myTestCallable);
          try {
              System.err.println(future.get());
              executorService.shutdown();
          } catch (InterruptedException | ExecutionException e) {
              e.printStackTrace();
          }
          //利用ExecutorService产生一个线程 结合futureTask
          executorService.submit(futureTask);
          try {
              System.err.println(futureTask.get());
              executorService.shutdown();
          } catch (InterruptedException | ExecutionException e) {
              e.printStackTrace();
          }
      }
  }
  ```

  `Runnable`与`Callable`不同点：

  - `Runnable`不返回执行结果，`Callable`可返回结果
  - `Callable`可以抛出异常
  - `Runnable`可直接由`Thread构造`或者`EXecutorService.submit()`执行

  运行`Callable`可以得到一个Future对象，表示异步计算的结果。提供了检查计算是否完成的方法以等待计算的完成，并检查计算结果。

  ```java
  public interface Future<V> {
      //试图取消任务的执行。mayInterruptIfRunning确定是否应该以试图停止任务的方式中断执行任务流程。true 直接中断 false等待执行完成 
      boolean cancel(boolean mayInterruptIfRunning);
      //任务正常完成前将其取消，返回true
      boolean isCancelled();
      //任务已完成或者因为正常终止、异常，取消而完成，返回true
      boolean isDone();
      //等待计算结果的返回，如果被取消则抛出异常
      V get() throws InterruptedException, ExecutionException;
      //设定执行时间，超过时间则抛出Timeout异常
      V get(long timeout, TimeUnit unit)
          throws InterruptedException, ExecutionException, TimeoutException;
  }
  ```

  #### 三种方法的比较



| 方式             | 优点                                                         | 缺点                                                         |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 继承Thread类     | 编写简单，可以使用`this`直接访问当前线程                     | 1.受限于Java类的单继承，无法继承其他类；<br>2.多个线程之间无法共享方法或实例变量 |
| 实现Runnable接口 | 多个线程可共享一个实现了`Runnable`接口的类，非常适合多个线程处理同一任务 | 1.`run()`没有返回值<br/>2.不能直接捕获运行过程中的异常，需要使用`setDefaultUncaughtExceptionHandler()`捕获子线程的异常 |
| 实现Callable接口 | 多个线程可共享一个实现了`Callable`接口的类，非常适合多个线程处理同一任务；可以有返回值；可以抛出异常 | 编写略微复杂，要访问当前线程需要使用`Thread.currentThread()` |

#### 线程创建的内存代价

> 每当有线程创建时，JVM就需要在内存中分配`虚拟机栈`和`本地方法栈`来记录调用方法的内容，分配`程序计数器`记录指令执行的位置，这样的`内存消耗`就是创建线程的内存代价。

### 3. 线程的状态

Java线程在运行的生命周期中可能处于6种不同的状态：

- #### New(创建)

  线程被创建，还没有调用`start()`，还没有运行

- #### Runnable(可运行)

  一旦调用`start()`，线程处于`Runnable`状态，一个可运行的线程可能处于正在运行或没有运行状态，这取决与操作系统给系统提供运行的时间

- #### Blocked(阻塞)

  表示线程被锁阻塞而等待监视锁(`monitor`)，暂时不能活动

- #### Waiting(等待)

  线程暂时不活动，并不运行任何代码，消耗最少资源并等待线程调度器重新激活它。

- #### Timed Waiting(超时等待)

  在指定等待时间内等待另一个线程执行特定的方法的线程状态

- #### Terminated(终止)

  表示当前线程已执行完毕。导致线程处于终止态有两种情况：

  - `run()`执行完毕正常退出
  - 一个没有捕获的异常终止了`run()`，导致线程终止

{% fullimage /images/Thread-State.png,线程状态,线程状态%}

### 4. 线程的分类

- #### 普通线程(用户线程)

  运行在前台，执行具体的任务，如程序的主线程，链接网络的子线程都是用户线程

- #### 守护线程

  运行在后台，为其他线程提供服务，如果所有的前台线程都死亡，守护线程也随之死亡。当整个虚拟机只剩下后台线程，虚拟机也就退出了。

  应用：JVM虚拟机启动后的后台检测线程，数据库连接池中的检测线程

  最常见的守护线程：`虚拟机中的垃圾回收线程`

### 5. 线程中的常见方法

- #### `start()`

  `start()`方法执行后，表示该线程到达了`Runnable`状态，何时运行还要等待线程调度器调度

  **线程死亡后，不可再次调用`start()`，只能对`New`状态的线程调用且只能调用一次`start()`**

- #### `run()`

  直接调用`run()`，只是调用线程中的代码，多个线程无法并发执行

- #### *`join()`

  主要作用是**等待该线程终止**。`主线程需要等待子线程执行完成之后再结束，也就是在子线程调用了join()方法后面的代码只有子线程结束了才可以执行。` 

- #### *`sleep(long mills)`

  主动放弃占用的处理器资源，进入`Blocked`。使当前执行的线程以指定的毫秒数休眠（`暂时停止执行`），具体取决于定时器和调度程序的精度和准确性。当超过了指定的睡眠时间后，线程进入`Runnable`，等待线程调度器调用。

- #### *`yield()`

  主动放弃占用的处理器资源，进入`Runnable`状态，等待线程调度器调用。**这个方法要注意的是它只会让步给比它优先级高的或者和它优先级相同并处在就绪状态的线程。放弃的时间不确定，可能一会就回重新获取CPU，线程调度器重新调用。**

- #### *`interrupt()`和`isInterrupted()`

  `interrupted()`：请求线程终止，实际线程并不一定会终止，执行后可以将中断标识位设置为false。线程会时不时的检测中断标识位，以判断线程是否应该被中断。

  `isInterrupted()`：检测当前线程是都已经是中断状态，检测中断标识位

- #### `setPriority()`

  设置线程的优先级，**理论上说：线程优先级高的更容易被执行，但也要结合具体的系统。**

  使用`getPriority()`可以查看当前线程的优先级。

- #### `isAlive()`

  检查线程是否处于活动状态，如果线程处于`Runnable(就绪或运行),Blocked(阻塞)`返回`true`，若处于`New(新建),Terminated(终止)`返回`false`

- #### *`wait()/wait(long mills)`

  导致线程进入等待状态，并释放锁。`mills`为等待时间，超过这个时间没有对当前线程进行唤醒(调用`notify()/notifyAll()`)即会自动唤醒。未设置`mills`，则直到被唤醒为止。**只能在同步方法或者同步块内调用，例如`synchronized(lockobj) {...} `**

- #### *`notify()`

  让当前线程通知那些处于等待(`Waiting`)的线程，当前线程执行完毕后释放锁，随机选择一个在该对象上调用`wait()`的线程，解除其阻塞状态。**只能在同步方法或者同步块内调用，例如`synchronized(lockobj) {...} `**

- #### *`notifyAll()`

  让当前线程通知那些处于等待(`Waiting`)的线程，当前线程执行完毕后释放锁，唤醒所有在该对象上调用`wait()`的线程，解除其阻塞状态。**只能在同步方法或者同步块内调用，例如`synchronized(lockobj) {...} `**

> `wait()`和`sleep()`的区别
>
> - `sleep()`来自于Thread类方法，`wait()`来自Object类
> - `sleep()`不会释放锁，`wait()`释放锁，使得其他线程可以使用同步控制块或者方法
>
> - `sleep()`让当前正在执行的线程休眠，等待一定的时间之后，会重新进入`Runnable`。`wait()`使实体所处线程暂停运行，直到被`notify()/notifyAll()`唤醒或者`wait()`的时间到达。

### 6. 线程安全中断

```java
public class InterruptThreadTest extends Thread {
   
    //第一种 判定当前线程的中断标识位是否为true
    @Override
    public void run() {
        long l = 0;
        while (!Thread.currentThread().isInterrupted()) {
            l++;
            System.err.println("l = " + l);
        }
        System.err.println("线程已经停止");
    }
   //第二种 自己设置中断标识位 on
     private static volatile boolean on = true;
    @Override
    public void run() {
        long l = 0;
        while(on){
            l++;
            System.err.println("l = " + l);
        }
        System.err.println("线程已经停止");
    }

    private static void cancel(){
        on = false;
    }

    public static void main(String[] args) {
        try {
            InterruptThreadTest thread = new InterruptThreadTest();
            thread.start();
            TimeUnit.MILLISECONDS.sleep(10);
            //第一种 调用interrupt设置中断标识位为 true
            thread.interrupt();
            //第二种 自己设置中断标识位
            cancel();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### 7. 线程优先级

> 线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使用哪个线程进入运行状态。*低优先级的线程并不意味着不会被运行，只是运行几率会变小。*
>
> 线程优先级具有**继承特性**，比如A线程启动B线程，则B线程与A线程优先级一致
>
> 线程优先级具有**随机性**，线程优先级高的不一定每次都先执行完。
>
> 优先级从`1-10`，10为最高级，1为最低级

### 8. 线程调度策略

- #### 抢占式调度策略

  如果一个优先级比其他任何处于可运行状态的线程都高的线程都进入就绪状态，那么运行时系统就会选择该线程运行。

- #### 时间片轮转调度策略

  从所有处于就绪状态的线程中优先选择优先级最高的线程分配一定的CPU时间运行，该时间过后再去选择其他线程运行。`只有当线程运行结束或者放弃等原因进入阻塞状态，低优先级的线程才有机会执行。`若优先级相同，则调度程序以轮转的方式选择运行的线程。

## 多线程

### 1. 多线程的优缺点

优点：

> 1. 资源利用率好
> 2. 提高程序的执行效率(多个线程同时执行)
> 3. 程序响应更快

缺点：

> 1. 设计更复杂
>
>    多线程程序在访问共享数据时需要小心处理，否则会出现难以修复的bug。线程之间的交互往往非常复杂，不正确的线程同步产生的错误难以被发现并修复(由于线程调度的无序性，可能依赖于某种特殊的线程执行序列)。
>
> 2. 上下文切换的开销
>
>    线程是由CPU进行调度的，CPU的一个时间片内只执行一个线程上下文内的线程。**上下文切换**(`当CPU从执行一个线程切换到执行另一个线程时，需要先存储当前线程的本地数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后开始执行另一个线程。`)这个过程并不廉价，如果没有必要，要尽量减少`上下文切换`的发生。
>
> 3. 更多的资源消耗
>
>    除了CPU执行`上下文切换`的消耗外，线程的执行还有其他的资源消耗。例如**内存同步的开销(线程需要一些内存维持本地栈去存储线程专用数据)**、**创建线程和终止的开销**，**线程调度的开销**等。

拓展：

- 引起**上下文切换**的原因
  - 时间片用完，CPU正常调度下一个任务
  - 被其他线程优先级更高的任务抢占
  - 执行任务遇到阻塞，调度器挂起当前任务，切换执行另一个任务
  - 用户主动挂起线程(`yield()`,`sleep()`)
  - 多任务抢占资源，没有抢到被挂起
  - 硬件中断

- 线程切换的性能代价

  > JVM需要先保存起被挂起线程的上下文环境：将线程执行位置保存在`程序计数器`中，调用方法的信息保存到`栈`中，待执行线程的`程序计数器`和`栈`中信息写入到处理器中。维护线程隔离数据区中的内容在**处理器中的导入导出**，就是线程切换的性能代价。

  减少线程上下文切换的方法：

  - 使用基于CAS的非拥塞算法
  - 无锁并发编程，尽量使用`ThreadLocal`或者不变量，而不是用锁 [安全共享策略](https://www.jianshu.com/p/bb36fee3e55c)
  - 使用`线程池+等待队列`的方式，控制线程数目

### 2. 线程同步

> 如果两个线程竞争统一资源时，并且每一个线程都调用了修改该对象的方法，这种情况通常称为**竞态条件**。导致竞态条件发生的代码区称为**临界区**。
>
> 若一个资源的创建、使用，销毁都在同一个线程内，且不会脱离该线程的控制，则无需同步。

- #### 同步方法 `synchronized`方法锁

- #### 同步代码块 `synvhronized`类锁

- #### wait()和notify() 

- #### volatile

- #### 重入锁 `Lock`

- #### 局部变量 `ThreadLocal`

- #### 阻塞队列 `BlockingQueue`

### 3. 线程通信

> 线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。

- #### wait()/notify()

  在`synchronized`修饰的同步方法或者同步代码块中使用Object类提供的`wait()、notify()，notifyAll()`这三个方法进行线程通信

- #### Condition

  当程序使用`Lock`类同步，系统不存在隐式的同步监视器，只能用Condition控制线程通信

- #### BlockingQueue

  `BlockingQueue`提供了`put(E e)`和`take()`支持阻塞的方法。

体现在`生产者-消费者模式`

生产者-消费者模式的实现

1. wait()/notify()实现

    ```java
   public class ProductCustomerWithWaitNotify{
       private final static int MAX_SIZE = 10;
       private static LinkedList<Object> linkedList = new LinkedList<>();
   
       public static void main(String[] args) {
           new Thread(ProductCustomerWithWaitNotify::produce).start();
           new Thread(ProductCustomerWithWaitNotify::produce).start();
           new Thread(ProductCustomerWithWaitNotify::produce).start();
           new Thread(ProductCustomerWithWaitNotify::produce).start();
           new Thread(ProductCustomerWithWaitNotify::consume).start();
           new Thread(ProductCustomerWithWaitNotify::consume).start();
           new Thread(ProductCustomerWithWaitNotify::consume).start();
           new Thread(ProductCustomerWithWaitNotify::consume).start();
       }
   
       public static void produce() {
           synchronized (linkedList) {
               while (linkedList.size() == MAX_SIZE) {
                   try {
                       linkedList.wait();
                   } catch (Exception e) {
                       e.printStackTrace();
                   }
               }
               linkedList.add(new Object());
               System.err.println("生成新产品，当前个数为" + linkedList.size());
               linkedList.notifyAll();
           }
       }
   
       public static void consume() {
           synchronized (linkedList) {
               while (linkedList.size() == 0) {
                   try {
                       linkedList.wait();
                   } catch (Exception e) {
                       e.printStackTrace();
                   }
               }
               linkedList.remove();
               System.err.println("消费了产品，当前个数为" + linkedList.size());
               linkedList.notifyAll();
           }
       }
   }
   ```

2. Condition()

   

3. BlockingQueue

   ```java
   public class ProductCustomerBlockQueue {
       private int queueSize = 10;
       private ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(queueSize,true);
   
       public static void main(String[] args) {
   
           ProductCustomerBlockQueue blockQueue = new ProductCustomerBlockQueue();
           Producter producter = blockQueue.new Producter();
           Customer customer = blockQueue.new Customer();
   
           producter.start();
           customer.start();
       }
   
       class Customer extends Thread {
           @Override
           public void run() {
               while (true) {
                   try {
                       queue.take();
                       System.err.println("消费哦");
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }
       }
   
       class Producter extends Thread {
           @Override
           public void run() {
               while (true) {
                   try {
                       queue.put(1);
                       System.err.println("生产哦");
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }
       }
   }
   ```


## 线程池

{% post_link Android-Study-Plan-XVII %}

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义ViewGroup实践</title>
    <url>/2019/01/02/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[
# 自定义ViewGrouop - FlowLayout

## 实现方式

- 继承特定ViewGroup，例如`LinearLayout`

  > 比较常见，效果类似于一堆View的组合。
  >
  > **实现比较简单，无需自己处理测量与布局的过程。**

- 继承`ViewGroup`派生特殊layout

  > 主要用于实现自定义的布局，按照自身需求制定不同的显示方法。
  >
  > **实现稍微复杂，还需要对ViewGroup进行处理，主要是自身的`onMeasure()、onLayout()`以及子View的`measure`过程**

## 注意事项

- 注意`wrap_content`的影响
- 注意`margin、pandding`的实现

## 实现步骤

### 创建ViewGroup

##### 继承ViewGroup

```java
public class FlowLayout extends ViewGroup {

    public FlowLayout(Context context) {
        this(context,null);
    }

    public FlowLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
}
```



#### 处理ViewGroup布局

##### 测量ViewGroup大小

通过`onMeasure()`进行ViewGroup的测量，其中需要先对子View进行测量，然后根据子View的结果确认最终ViewGroup的大小。

```java

```



##### 确定ViewGroup位置

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义View实践</title>
    <url>/2019/01/02/%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[
<!--实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展-->

> Android系统默认提供大量的View，但是会因为需求的改动导致原生View不能符合需求，就需要进行自定义控件去使用。
## 实现方式
- 继承特定View

  > 拓展某种已有View的功能就可以在原有View的基础上增加新功能，而且这种实现方式就不需要自己去处理那些注意事项，例如`wrap_content、pandding`等属性。

- 继承View并重写`onDraw()`

  > 当需要实现一些不规则的效果，比如绘制一些图案，按照不同的需求需要实现更多的功能。这种实现方式就需要注意以下事项：
  >
  > - 需要自己支持`wrap_content、padding`
  > - 注意`onDraw()`绘制的性能问题



## 注意事项
在实现过程中会有详细的实现介绍
- 自定义View支持`wrap_content`

  > 在自定View中使用`wrap_content`在显示结果上总是和`match_parent`效果一致，原因在于源码中对View的实现有一种默认处理。

  ```java View.java
  public static int getDefaultSize(int size, int measureSpec) {
          int result = size;
          int specMode = MeasureSpec.getMode(measureSpec);
          int specSize = MeasureSpec.getSize(measureSpec);
  
          switch (specMode) {
          case MeasureSpec.UNSPECIFIED:
              result = size;
              break;
          case MeasureSpec.AT_MOST:
          case MeasureSpec.EXACTLY:
          //这段代码中可以分析得出 一个直接继承View的自定义View 定义为wrap_content和match_parent大小都是一致的.
              result = specSize;
              break;
          }
          return result;
      }
  ```
- 有必要需要支持`padding、margin`属性

  > `android:padding`该属性控制View内部边距，`android:margin`属性控制与父布局的边距。
  >
  > 都需要在`onDraw()`过程中去进行特殊处理。

- 尽量不要在View中使用Handler

  > View内部提供了`post()`可以发送事件，完全替代Handler作用，使用还方便。

- 自定义View如果有线程或动画，需要及时停止

  > 当View中使用了`线程或动画`时，可能因为忘记及时释放，使他们持有了View，从而导致Activity出现内存泄漏问题。

- 需要注意滑动冲突

  > View中使用了滑动时，需要注意滑动冲突问题。

  解决滑动冲突两种方案：`外部拦截法`、`内部拦截法`。



## 实现步骤

### 创建View

#### 继承View

```java
class CustomView extends View{
    /**
    * 自动调用——用于在Java代码new使用的
    */
    public CustomView(Context context){
        super(context);
    }
    /**
    * 自动调用——用于View在xml里使用时调用的
    */
    public CustomView(Context context,AttributeSet attrs/*xml中传进来的属性*/){
        super(context,attrs);
    }
    /**
    * 非自动调用——用于View设置看style属性时，大部分情况下都是调用的双参数函数
    * defStyleAttr 指的时当前Application或Activity所用Theme的默认style
    */
    public CustomView(Context context,AttributeSet attrs,int defStyleAttr){
        super(context,attrs,defStyleAttr);
    }
    /**
    * 在API21 以上时添加的函数
    * 非自动调用
    */
    public CustomView(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
        super(context,attrs,defStyleAttr,defStyleRes)
    }
}
```

继承View之后，系统提供了4个构造函数，每个函数的参数也不尽相同。

```java
public CustomView(Context context)
```

在Activity中进行调用时`CustomView view= new CustomView(this)`

<br>

```java
public CustomView(Context context,AttributeSet attrs/*xml中传进来的属性*/)
```

在xml中调用时触发

```xml
<CustomView
    android:layout_width"wrap_content"
  android:layout_height"wrap_content"/>
```

<br>

```java 
public CustomView(Context context,AttributeSet attrs,int defStyleAttr)
```

这个方法需要第二个构造函数进行显式调用方可生效，传入自定义的Theme

```java
public CustomView(Context context,AttributeSet attrs/*xml中传进来的属性*/){
    this(context,attrs,R.style.theme)
}
```

> 该构造函数的作用：**为View的子类提供该类的基础样式**。

<br>

```java
public CustomView(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes)
```



#### 定义自定义属性

> 自定义View中通常需要支持更多的设置，例如背景颜色，文字内容等属性，设置完毕后就可以对应的显示出来。

通常将所需的自定义属性配置到`res/values/attrs.xml`中，等待自定义View进行引用。

```xml
<declare-styleable name="CustomView">
 	<attr name="color_attr" format="color"/>
    <attr name="boolean_attr" format="boolean"/>
    <attr name="string_attr" format="string"/>
    <!--自定义属性支持组合使用-->
    <attr name="reference_attr" format="color | reference"/>
</declare-styleable>
```

主要介绍常用的几种属性：

| format    | 作用                     | 使用方法                                   |
| --------- | ------------------------ | ------------------------------------------ |
| color     | 设置颜色值例如 `#ffffff` | app:color_attr="#ffffff"                   |
| boolean   | 布尔值                   | app:boolean_attr = "true"                  |
| string    | 字符串                   | app:string_attr="android"                  |
| dimension | 尺寸值                   | app:dimension_attr="36dp"                  |
| float     | 浮点值                   | app:float_attr="1.0"                       |
| integer   | 整型值                   | app:intege_attr="100"                      |
| fraction  | 百分数                   | app:fraction_attr="100%"                   |
| reference | 获取某一资源ID           | app:reference_attr="@drawable/ic_launcher" |
| enum      | 枚举值                   | app:enum_attr="enum_1"                     |

其中`enum`的实现比较特殊：

```xml
<attr name="enum_attr" >
     <enum name="enum_1" value="0"/>
     <enum name="enum_2" value="1"/>
</attr>
```

声明自定义属性完毕后，需要在xml中进行引用

```xml
<CustomView
      android:layout_width="wrap_content"
      android:layout_height="wrap_content"
      app:color_attr="#ffffff"
      app:float_attr="12f"
      app:enum_attr="enum_1"
      app:integer_attr="10"
      app:reference_attr="@color/colorAccent"
      app:dimension_attr="36dp"
      app:boolean_attr="true"
      app:string_attr="android"
/>
```



#### 获取自定义属性

在xml中设置自定义属性完毕后，就需要在自定义View中去获取对应属性的值。

```java
//加载自定义属性集合
TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CustomView);
...  获取具体属性值
// 使用完毕需要进行回收
typedArray.recycle();
```

根据上节中定义的自定义属性，获取方式也不尽相同。

| format    | 如何获取                                                     |
| --------- | ------------------------------------------------------------ |
| color     | typedArray.getColor(R.styleable.CustomView_color_attr, Color.RED); |
| boolean   | typedArray.getBoolean(R.styleable.CustomView_boolean_attr, true); |
| string    | typedArray.getString(R.styleable.CustomView_string_attr);    |
| dimension | floar dimension = typedArray.getDimension(R.styleable.CustomView_dimension_attr,20);*完整结果*<br>int dimension = typedArray.getDimensionPixelOffset(R.styleable.CustomView_dimension_attr,20);*舍弃末尾小数*<br>int dimension = typedArray.getDimensionPixelSize(R.styleable.CustomView_dimension_attr,20);*四舍五入* |
| float     | typedArray.getFloat(R.styleable.CustomView_float_attr, 1f);  |
| integer   | typedArray.getInteger(R.styleable.CustomView_integer_attr, 1); |
| fraction  | typedArray.getFraction(R.styleable.CustomView_fraction_attr,4,5,1); |
| reference | typedArray.getResourceId(R.styleable.CustomView_reference_attr, R.drawable.ic_launcher_background); |
| enum      | typedArray.getInt(R.styleable.CustomView_enum_attr, 0);      |



#### 添加设置属性事件

上述自定义的属性只能在View初始化时可以获取并在xml中进行设置，如果后续想修改对应属性，就需要针对设置属性事件来进行修改和获取。

```java
public boolean getBooleanAttr(){
    return boolean_attr;
}

public void setBooleanAttr(boolean boolean_attr){
    this.boolean_attr= boolean_attr;
    //根据不同的需求去选择刷新界面方法。
    //postInvalidate(); 重新进行绘制
    //invalidate(); 重新进行绘制
    //requestLayout() 对整个布局进行测量-布局-绘制过程
}
```



### 处理View的布局

#### 测量View大小

> 为了让自定义View可以根据不同的情况以合适的宽高进行展示

这里要做的就是对`onMeasure()`进行重写，View是通过该方法确定对应宽高。

```java
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int widthMeasureSpecSize = MeasureSpec.getSize(widthMeasureSpec);      //取出宽度的确切数值 后30bit
        int widthMeasureSpecMode = MeasureSpec.getMode(widthMeasureSpec);      //取出宽度的测量模式 前2bit

        int heightMeasureSpecSize = MeasureSpec.getSize(heightMeasureSpec);    //取出高度的确切数值 后30bit
        int heightMeasureSpecMode = MeasureSpec.getMode(heightMeasureSpec);    //取出高度的测量模式 前2bit

        if (widthMeasureSpecMode == MeasureSpec.AT_MOST && heightMeasureSpecMode == MeasureSpec.AT_MOST) {
            setMeasuredDimension(400, 400);
        } else if (widthMeasureSpecMode == MeasureSpec.AT_MOST) {
            setMeasuredDimension(400, heightMeasureSpecSize);
        } else if (heightMeasureSpecMode == MeasureSpec.AT_MOST) {
            setMeasuredDimension(widthMeasureSpecSize, 400);
        }
}
```

代码中`widthMode/heightMode`对应的有3类，代表的是**测量模式**

| 测量模式    | 定义                                                         |
| ----------- | ------------------------------------------------------------ |
| UNSPECIFIED | 当前控件没有限制，想多大就多大，一般在系统中使用的           |
| EXACTLY     | 表示父控件指定了一个确切的大小，一般定义为`具体大小(20dp)`或`match_parent(父布局大小)` |
| AT_MOST     | 表示没有具体的大小限制，不过指定了上限，一般为父布局大小，一般定义为`wrap_content` |

代码中`widthSize/heightSize`指代的就是 **父布局期望的子View大小**。

代码中针对`AT_MOST`进行了特殊的处理，针对的情况就是使用了`wrap_content`，在Android源码中，系统的处理方案是`AT_MOST和EXACTLY`得到结果是一致的，而导致`wrap_content`属性失效。

> 如果后续也对View的宽高进行修改，就调用`setMeasureDimension()`执行修改。

#### 确定View大小

> View的大小不仅由自身控制，父布局也会有影响，因此获取View大小时最好通过`onSizeChanged()`获取。

```java
@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
}
```

其中`w、h`就是最终的宽、高。

### 绘制View

> 尺寸确定完毕后，接下来就要去绘制View所需的内容，直接把我们相要绘制的内容放在`canvas`上即可

```java
@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    //这个应该放在init()时进行初始化 ，此处只为举例说明
    Paint paint = new Paint();
    paint.setColor(Color.GREEN);
    //开始绘制 画一个圆
    canvas.drawCircle(centerX, centerY, r, paint);
}
```

其中涉及了两个对象：

- **Canvas**：画布对象，决定了要去画什么
- **Paint**：画笔对象，决定了怎么画，比如颜色，粗细等

在注意事项中，还需要注意的是`padding`属性的处理，这部分处理就在`onDraw()`中执行。

```java
 @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        //获取xml中设置的padding属性值
        int paddingTop = getPaddingTop();
        int paddingBottom = getPaddingBottom();
        int paddingStart = getPaddingStart();
        int paddingEnd = getPaddingEnd();
        //得到的结果就是 该View实际可用的绘制大小
        int width = getWidth() - paddingStart - paddingEnd;
        int height = getHeight() - paddingTop - paddingBottom;

    }
```



> 在实现`onDraw()`过程中需要注意，最好不要去生成任何的局部对象，由于View的绘制过程是发生最频繁的，可能由于生成大量临时对象导致频繁GC，影响性能。

### 与用户进行交互

> 如果需要额外的对用户的触摸或者滑动事件去进行支持，这时就需要去实现一些触摸方法。

通过实现`onTouchEvent()`来实现触摸事件响应，实现`GestureDetector`相关接口去实现滑动功能。

**此时需要注意滑动冲突上的处理。**

### 优化自定义View

上述流程实现完毕后，就需要针对实现的自定义View去做一些优化处理，减少问题。

1. 避免不必要的代码

2. 在`onDraw()`中不要出现创建对象的方法

3. 尽可能减少`onDraw()`调用，提升绘制效率。

4. 如果设置了线程或者动画需要及时清理

   > 不处理可能导致内存泄漏的发生
   >
   > 此时可以在`onAttachedToWindow()`时去进行线程或动画初始化等工作
   >
   > 最后在`onDetachedFromWindow()`时去清理掉他们。



]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitmap分析</title>
    <url>/2019/01/28/Bitmap%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
<!--Bitmap 压缩策略 Bitmap大小判断 bitmap的具体压缩过程 bitmap在缓存时的转码过程-->

{% fullimage /images/Bitmap优化.png,Bitmap优化,Bitmap优化%}

## Bitmap简介

位图文件(Bitmap)，扩展名可以是`.bmp或.dlb`。它将图像定义为由像素组成，每个点可以由多种色彩表示，包括2、4、8、16、24和32位色彩。

在安卓系统中bitmap图片一般是以`ARGB_8888`来进行存储的。

| 颜色格式          | 每个像素占用内存(byte) | 每个像素占用内存(bit) |
| ----------------- | ---------------------- | --------------------- |
| ARGB_8888(`默认`) | 4                      | 32                    |
| ALPHA_8           | 1                      | 8                     |
| ARGB_4444         | 2                      | 16                    |
| RGB_565           | 2                      | 16                    |

`ARGB_8888`：分别代表*透明度，红色，绿色，蓝色*，每个值分别用8bit记录

`ALPHA_8`：该像素只保存透明度

`ARGB_4444`：每个值分别用4bit记录

`RGB_565`：不存在透明度

**实际应用中建议使用ARGB_8888和RGB_565(*不需要存储透明度时使用*)。**



## Bitmap占用内存

bitmap占用内存：**所有像素的内存占用总和**。

Android系统提供了两个方法获取占用内存：`getByteCount()`和`getAllocationByteCount()`。

`getByteCount()`：在API12中加入的，代表存储Bitmap需要的最少内存。

`getAllocationByteCount()`：在API19中加入的，代表在内存中为Bitmap分配的内存大小

```java
public final int getAllocationByteCount(){
  if(mBuffer == null){
    return getByteCount();
  }
  return mBuffer.length;
}
```

两者的区别：

- 一般情况下两者是相等的
- 如果通过Bitmap的复用去解码图片，那么被复用的Bitmap的内存比待分配内存的Bitmap大，即`getByteCount()`<`getAllocationByteCount()`。`getByteCount()`表示新解码图片占用内存的大小(*并非实际占用内存大小*)，`getAllocationByteCount()`表示被复用的Bitmap占用的内存大小。

<br>

一般情况下Bitmap占用的内存大小都为：**图片长度 x 图片宽度 x 单位像素占用的字节数**。

`单位像素占用字节数`：指代的是上面描述的编码方式，常用的是`ARGB_8888`即用这个方式编码的Bitmap占用大小就为*图片长度 x 图片宽度 x 4*。

<br>

非一般情况下，例如从资源文件夹(*res/drawable/*)获取图片时，还需要额外考虑一个因素：**Density**。

`Density`：可以理解为相对屏幕密度，一个DIP在160dpi的屏幕上大约为1px，以160dpi为基准线，density的值即为相对于160dpi的相对屏幕密度。

```java
//从资源文件中读取 Bitmap 
public static Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value,
            @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts) {
        validate(opts);
        if (opts == null) {
            opts = new Options();
        }

        if (opts.inDensity == 0 && value != null) {
            final int density = value.density;
            if (density == TypedValue.DENSITY_DEFAULT) {
                opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;
            } else if (density != TypedValue.DENSITY_NONE) {
                opts.inDensity = density;
            }
        }
        
        if (opts.inTargetDensity == 0 && res != null) {
            opts.inTargetDensity = res.getDisplayMetrics().densityDpi;
        }
        
        return decodeStream(is, pad, opts);
    }
```

从源码中可以看出：**加载一张本地资源图片，那么它占用的内存 = 图片长度 x 图片宽度 x inTargetDensity/inDensity x inTargetDensity/inDensity x 单位像素占用字节数。**

其中 `inDensity`代表图片所在文件夹对应的密度；`inTargetDensity`代表了当前的系统密度。

*可以通过设置 `Options`对inTargetDensity 、inDensity进行修改，避免自动计算。 *



## Bitmap复用

### 利用`LruCache`和`DiskLruCache`做内存和磁盘缓存

{% post_link LRUCache原理 %}

### 使用Bitmap复用 -多个Bitmap复用同一块内存

```java
BitmapFactory.Options options = new BitmapFactory.Options();
// 图片复用，这个属性必须设置；
options.inMutable = true;
// 手动设置缩放比例，使其取整数，方便计算、观察数据；
options.inDensity = 320;
options.inTargetDensity = 320;
//生成复用的Bitmap
Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.resbitmap, options);

// 使用inBitmap属性，这个属性必须设置；设置要复用的Bitmap
options.inBitmap = bitmap;
options.inDensity = 320;
// 设置缩放宽高为原始宽高一半；
options.inTargetDensity = 160;
options.inMutable = true;
Bitmap bitmapReuse = BitmapFactory.decodeResource(getResources(), R.drawable.resbitmap_reuse, options);

```

使用`inBitmap`参数实现Bitmap的复用，但复用存在一些限制：*在Android4.4之前只能重用相同大小的Bitmap的内存，4.4之后的只要后来的Bitmap比之前的小即可。*



## Bitmap高效加载

> 核心思想：采用`BitmapFactory.Options`来加载所需尺寸的图片，使其按照一定的采样率将图片缩小后再进行加载。
>
> **防止直接加载大容量的高清Bitmap导致OOM的出现。**

### BitmapFactory

> 提供方法生成Bitmap对象。

- `decodeFile()`：从文件中加载出一个Bitmap对象
- `decodeResource()`：从资源文件夹中加载出一个Bitmap对象
- `decodeStream()`：从输入流中加载出一个Bitmap对象
- `decodeByteArray()`：从字节数组中加载出一个Bitmap对象

> `decodeFile()`和`decodeResource()`间接调用到了`decodeStream()`，最终都是在Native层实现的。

### BitmapFactory.Options

> 里面配置的参数可以实现高效的加载Bitmap。

```java
public static class Options {
    public Options() {
        inDither = false;
        inScaled = true;
        inPremultiplied = true;
    }
    ...      
   public Bitmap inBitmap; //用于实现Bitmap的复用，上文有介绍
   public int inSampleSize;  //采样率 
   public boolean inJustDecodeBounds; //
   public boolean inPremultiplied;   
   public boolean inDither;  //是否开启抖动
   public int inDensity; // 图片所属文件夹对应的dpi
   public int inTargetDensity;  // 目标设备屏幕的dpi           
   public boolean inScaled;    //是否支持缩放
   public int outWidth;   //图片的原始宽度
   public int outHeight;  //图片的原始高度
   ...
}
```

#### inPreferredConfig

> 根据需求选择合适的解码方式，可以有效减小占用内存

`inPreferredConfig`指的就是上面描述到的`ARGB_8888、ARGB_4444、RGB_565、ALPHA_8`，默认用的是`ARGB_8888`。

#### inScaled

> 表示是否支持缩放。*默认为true*

缩放系数的计算方法：`inDensity / inTargetDensity`计算得出。

```java
BitmapFactory.Options options = new BitmapFactory.Options();
options.inDensity = 160;
options.inTargetDensity = 320;
Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.size, options);
int size = bitmap.getByteCount();
```

可以手动的设置`inDensity，inTargetDensity`控制缩放系数。



#### inJustDecodeBounds

> 是否去加载图片

当此参数设置为`true`：BitmapFactory只会加载图片的原始宽高信息，而不会真正的加载图片到内存。

设置为`false`：BitmapFactory加载图片至内存。

> BitmapFactory获取的图片宽高信息会和图片的位置以及程序运行的设备有关，会导致获取到不同结果。



#### inSampleSize

> 采样率，同时作用于宽/高。

当`inSampleSize == 1`，采样后的图片和原来大小一样；为2时，采样后的图片宽高均变为原来的1/2，占用内存大小也就变成了1/4。

`inSampleSize`的取值应该总是**2的指数(2、4、8、16 ...)**，如果传递的`inSampleSize`不为2的指数，那么系统会向下取整并选择一个最接近于2的指数来代替。*传进来3，则对应为2*。

> 注意：需要根据图片的宽高 **实际大小和需要大小**，去计算出需要的缩放比并尽可能取小，避免缩小的过多导致无法铺满控件被拉伸。



##### 获取采样率

1. 设置`BitmapFactory.Options.inJustDecodeBounds = true`并加载图片
2. 从`BitmapFactory.Options`获取图片的原始宽高信息，`outWidth和outHeight`
3. 根据原始宽高并结合目标View的大小得到合适的采样率`inSampleSize`
4. 重新设置`BitmapFactory.Options.inJustDecodeBounds = false`并重新加载图片

```java
public static Bitmap decodeSampledBitmapTromResource(Resource res,int rresId,int reqWidth,int reqHeight){
  final BitmapFactory.Options options = new BitmapFactory.Options();
  options.inJustDecodeBounds = true;
  
  BitmapFacory.decodeResource(res,resId,options);
  options.inSampleSize = calculateInSampleSize(options,reqWidth,reqHeight);
  options.inJustDecodeBounds = false;
  return BitmapFactory.decodeResource(res,resId,options);
}

public static int calculateInSampleSize(BitmapFactory.Options options,int reqWidth,int reqHeight){
  final int height = options.outHeight;
  final int width = options.outWidth;
  int inSampleSize = 1;
  
  if(height > reqHeight || width > reqWidth){
     final int halfWidth = width /2;
     final int halfHeight = height/2;
     while((halfHeight / inSampleSize) >= reqHeight 
           && (halfWidth / inSampleSize) >= reqWidth){
       inSampleSize = inSampleSize << 1;
     }
  }
  return inSampleSize;
}

//使用示例
iv.setImageBitmap(decodeSampledBitmapTromResource(getResources(),R.drawable.bitmap,100,100))
```



## Bitmap压缩

### 质量压缩

> 保持像素的前提下改变图片的位深以及透明度等，来达到压缩图片的目的，**不会减少图片的像素，经过质量压缩的图片文件大小会变小，但是解码成Bitmap占用内存不变。**

```java
public static Bitmap compressImage(Bitmap image , long maxSize) {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    Bitmap bitmap = null;
    // 质量压缩方法，options的值是0-100，这里100表示原来图片的质量，不压缩，把压缩后的数据存放到baos中
    image.compress(Bitmap.CompressFormat.JPEG, 100, baos);
    int options = 90;
    // 循环判断如果压缩后图片是否大于maxSize,大于继续压缩
    while (baos.toByteArray().length  > maxSize) {
        // 重置baos即清空baos
        baos.reset();
        // 这里压缩options%，把压缩后的数据存放到baos中
        image.compress(Bitmap.CompressFormat.JPEG, options, baos);
        // 每次都减少10，当为1的时候停止，options<10的时候，递减1
        if(options == 1){
            break;
        }else if (options <= 10) {
            options -= 1;
        } else {
            options -= 10;
        }
    }
    byte[] bytes = baos.toByteArray();
    if (bytes.length != 0) {
        // 把压缩后的数据baos存放到bytes中
        bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
    }
    return bitmap;
}
```

> 对于Png而言，设置`quality`无效

### 采样率压缩

[采样率](#inSampleSize)

### 缩放法压缩

> Android使用Matrix对图像进行缩放(*减少图片的像素*)、旋转、平移、斜切等变换。Mairix是一个3*3的矩阵

| scaleX(控制缩放) | skewX(控制斜切) | translateX(控制位移) |
| :--------------: | :-------------: | :------------------: |
|      skewY       |     scaleY      |      translateY      |
|        0         |        0        |        scale         |

执行顺序是 ：  `preXXX() -> setXXX() ->postXXX()`

```java
private static Bitmap scale(final Bitmap src, final float scaleWidth, final float scaleHeight, final boolean recycle) {
    if (src == null || src.getWidth() == 0 || src.getHeight() == 0) {
        return null;
    }
    Matrix matrix = new Matrix();
    matrix.setScale(scaleWidth, scaleHeight);
    Bitmap ret = Bitmap.createBitmap(src, 0, 0, src.getWidth(), src.getHeight(), matrix, true);
    if (recycle && !src.isRecycled()) {
        src.recycle();
    }
    return ret;
}
```

## Bitmap加载高清大图

在开发过程中如果需要加载超大图或长图，就无法使用上述方案去进行加载，可能会导致图片细节大量丢失，无法查看。

需要通过`BitmapReginDecoder`去进行加载，该类支持加载图片的部分区域，可以有效的显示具体细节

```java
BitmapRegionDecoder bitmapRegionDecoder = null;
try {
    bitmapRegionDecoder = BitmapRegionDecoder.newInstance(getAssets().open("world.jpg"),
                true);
} catch (IOException e) {
    e.printStackTrace();
}

int screenWidth = getResources().getDisplayMetrics().widthPixels;
int screenHeight = getResources().getDisplayMetrics().heightPixels;
/*以手机屏幕宽高生成一个矩形区域*/
Rect rect = new Rect(0,0,screenWidth,screenHeight);

BitmapFactory.Options options = new BitmapFactory.Options();
/*设置RGB_565格式 取出透明的显示*/
options.inPreferredConfig = Bitmap.Config.RGB_565;

/*加载部分图片*/
Bitmap bitmap = bitmapRegionDecoder.decodeRegion(rect,options);
imageView.setImageBitmap(bitmap);
```

## Bitmap内存回收

> 在Android2.3.3之前，Bitmap的像素数据存放在Native内存，Bitmap对象本身位于Dalvik Heap中。
>
> Android3.0之后，Bitmap的像素数据也被放进了Dalvik Heap中。
>
> `Bitmap.recycle()`：释放与此位图关联的本地对象，并清除对像素数据的引用。这不会同步释放像素数据，只是允许它被垃圾收集，如果没有其他的情况。这个时候如果进行调用会抛出异常。
>
> Android3.0之后就不需要手动调用`recycle()`进行释放，由系统进行控制。



## 内容引用

[Bitmap优化详谈](https://juejin.im/post/5bfbd5406fb9a049be5d2a20#heading-0)

[Android性能优化（五）之细说Bitmap](https://mp.weixin.qq.com/s?__biz=MzI3OTU3OTQ1Mw==&mid=2247483753&idx=1&sn=8b25e2915c72aacdf2e1cfa38aa1cb87&chksm=eb44df3bdc33562d7784753776ba820361d71228b0081e66661c6070008c0038bbabf0558ab8&mpshare=1&scene=23&srcid=0316pLW7Dlj2Y0bHTIUNHY2D%23rd)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit简析</title>
    <url>/2019/03/08/Retrofit%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>SparseArray简析</title>
    <url>/2019/01/28/SparseArray%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
> HashMap在Android开发中是一种常用的数据结构类型，但是占用内存方面相对会比较大，而且复杂的机制导致运行效率也不高。所以Android系统提供了`SparseArray`以及`ArrayMap`来对其进行替代。这也是Android性能优化的一种手段。

## SparseArray

> `SparseArray`可以对key为`Integer`类型的HashMap进行替代。还有
>
> - `LongSparseArray`对key为`Long`型的HashMap
> - `SparseIntArray`对key为`Integer`类型，value为`Integer`类型
> - `SparseLongArray`对key为`Integer`类型，value为`Long`类型
> - `SparseBooleanArray`对key为`Integer`类型，value为`Boolean`类型
>
> 等这些类型。内部实现都是相似的，只是可支持的类型不同。
>
> `SparseArray`允许value为null，并且是*线程不安全的*。

### SparseArray使用场景

- 数据量不大
- 空间比时间重要
- 需要使用到Map型结构，且key为`int`类型



### SparseArray重要参数分析

```java SparseArray.java
	//需要删除的标记    
	private static final Object DELETED = new Object();
	//设置回收标记 实质执行了 删除后的index置为null，协助回收
	private boolean mGarbage = false;
	//保存每个Item的key
    private int[] mKeys;
	//保存每个Item的value，容量和mKeys一致
    private Object[] mValues;
    //保存的数据容量
    private int mSize;
```



### SparseArray源码解析

#### 初始化

```java
//无初始值
SparseArray<String> stringSparseArray = new SparseArray<>();
//设置初始值
SparseArray<String> stringSparseArray = new SparseArray<>(5);
```

对应源码

```java
    //默认构造器 初始化容量为10
	public SparseArray() {
        this(10);
    }

	public SparseArray(int initialCapacity) {
        if (initialCapacity == 0) {
            mKeys = EmptyArray.INT;
            mValues = EmptyArray.OBJECT;
        } else {
            //初始化长度的数组
            mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);
            mKeys = new int[mValues.length];
        }
        mSize = 0;
    }
```

存放的键值对分别放在两个数组`mKeys`、`mValues`，数据是一一对应的。

#### 插入数据

```java
stringSparseArray.put(1,"android");
```

对应源码

```java
public void put(int key, E value) {
        //利用二分查找，找到key应该插入的位置
        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

        if (i >= 0) {
            //找到已存在的值  直接进行覆盖
            mValues[i] = value;
        } else {
            //返回负数  需要取反获取插入的位置
            i = ~i;
            //当前没有越界 且原先该位置的数据已被删除 可以进行复用
            if (i < mSize && mValues[i] == DELETED) {
                mKeys[i] = key;
                mValues[i] = value;
                return;
            }

            if (mGarbage && mSize >= mKeys.length) {
                //压缩空间
                gc();①

                // Search again because indices may have changed.
                //
                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
            }
            //插入数据，可能需要扩容
            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);②
            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
            //存储数据+1
            mSize++;
        }
    }
```

①`gc()`：垃圾回收，对数组进行压缩

```java
private void gc() {
        int n = mSize;
        int o = 0;
        int[] keys = mKeys;
        Object[] values = mValues;
        //遍历values
        for (int i = 0; i < n; i++) {
            Object val = values[i];
            //对应值不为删除标记
            if (val != DELETED) {
                if (i != o) {
                    keys[o] = keys[i];
                    values[o] = val;
                    //防止内存泄露，使用过后置空
                    values[i] = null;
                }
                //重新统计数据量
                o++;
            }
        }
        //标识 GC结束
        mGarbage = false;
        mSize = o;
    }
```

`gc()`实质是内部一个for循环，将value不为`DELETED`的数据重新插入数组中，已实现**对数组的压缩**，同时重置GC标志。

②`GrowingArrayUtils.insert(mKeys, mSize, i, key)`：插入数据 可能需要扩容

```java
    public static int[] insert(int[] array, int currentSize, int index, int element) {
        assert currentSize <= array.length;
        //不需要扩容
        if (currentSize + 1 <= array.length) {
            //将插入位置后的数据向后移一位
            System.arraycopy(array, index, array, index + 1, currentSize - index);
            array[index] = element;
            return array;
        }
        //需要进行扩容操作
        int[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize));
        System.arraycopy(array, 0, newArray, 0, index);
        newArray[index] = element;
        System.arraycopy(array, index, newArray, index + 1, array.length - index);
        return newArray;
    }
    //重新设置数组容量
    public static int growSize(int currentSize) {
        return currentSize <= 4 ? 8 : currentSize * 2;
    }
```

`insert()`内部执行了两段操作：

- 不需要扩容：将需要插入位置的数据向后移一位，然后数据插入到对应位置。
- 需要扩容：扩容数据为原容量的2倍(*容量<=4时，扩容至8，其他情况下为2倍。*)，然后将原数组对应位置前的数据以及之后的数据分别插入扩容后数组。



> `put()`需要通过**二分查找法**找到可以插入的位置，如果当前位置的key相同，则直接覆盖原数据。如果key不相同但是`value`为`DELETED`，可以拿新的数据直接覆盖；如果不是，需要先判断`mGarabge`为true，就需要执行`gc()`压缩数组空间(*有效的数据按照顺序重新排布*)，然后再去插入新数据，过程中可能需要扩容。

#### 获取数据

```java
//获取key对应的数据
stringSparseArray.get(1)
stringSparseArray.get(1,"iOS")
//获取key对应的下标
stringSparseArray.indexOfKey(1)  
//根据下标获取key
stringSparseArray.keyAt(0)
```

对应源码

##### 根据key获取value

```java
	public E get(int key) {
        return get(key, null);
    }

    @SuppressWarnings("unchecked")
    public E get(int key, E valueIfKeyNotFound) {
        //寻找key对应位置
        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

        if (i < 0 || mValues[i] == DELETED) {
            return valueIfKeyNotFound;
        } else {
            return (E) mValues[i];
        }
    }
```



##### 根据key获取index

```java
 	public int keyAt(int index) {
        //需要先判断是否GC
        if (mGarbage) {
            gc();
        }

        return mKeys[index];
    }

    public E valueAt(int index) {
        if (mGarbage) {
            gc();
        }

        return (E) mValues[index];
    }
```



##### 根据index获取key

```java
	public int indexOfKey(int key) {
     //查询下标时，也需要考虑是否先GC
        if (mGarbage) {
            gc();
        }
        //二分查找返回 对应的下标 ,可能是负数
        return ContainerHelpers.binarySearch(mKeys, mSize, key);
    }
    public int indexOfValue(E value) {
     //查询下标时，也需要考虑是否先GC
        if (mGarbage) {
            gc();
        }
        //不像key一样使用的二分查找。是直接线性遍历去比较，而且不像其他集合类使用equals比较，这里直接使用的 ==
        //如果有多个key 对应同一个value，则这里只会返回一个更靠前的index
        for (int i = 0; i < mSize; i++)
            if (mValues[i] == value)
                return i;

        return -1;
    }

```



#### 删除数据

```java
//删除对应key的数据
stringSparseArray.remove(1);
//删除对应index的数据
stringSparseArray.removeAt(0)；
//删除对应区间的数据
stringSparseArray.removeAtRange(0,1);
```

对应源码

##### 根据key删除数据

```java
public void remove(int key) {
        delete(key);
    }

public void delete(int key) {
    //二分查找到对应的index
        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
        //找到了对应位置
        if (i >= 0) {
            if (mValues[i] != DELETED) {
                //打上已删除标记
                mValues[i] = DELETED;
                //标记需要执行 gc()
                mGarbage = true;
            }
        }
    }
```



##### 根据index删除数据

```java
public void removeAt(int index) {
        if (mValues[index] != DELETED) {
            mValues[index] = DELETED;
            mGarbage = true;
        }
    }
```



##### 根据区间删除数据

```java
    public void removeAtRange(int index, int size) {
        final int end = Math.min(mSize, index + size);
        for (int i = index; i < end; i++) {
            removeAt(i);
        }
    }
```



`remove()`相关方法并不是直接删除数据，而是使用`DELETED`占据被删除数据的位置，同时设置`mGarabge=true`，等待调用`gc()`进行数据压缩。

> 设置`DELETED`的目的：如果`put()`时也要用到该位置，就可以不用进行数据复制，而直接放入数据即可。

### SparseArray拓展

- `SparseArray`的key是按照顺序从小到大排列的
- 由于压缩数组的原因，所以占用空间会比`HashMap`小，当数据量上来时，二分查找将会成为其性能瓶颈，所以适合数据量小的情况
- key为`int`类型，省去`Integer`拆箱的性能消耗。
- 由于`SparseArray`没有实现`Serializable`接口，所以不支持序列化即无法进行传递。

]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--ArrayList实现原理及简析</title>
    <url>/2019/01/15/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
{% fullimage /images/ArrayList结构.png,ArrayList结构,ArrayList结构%}

## ArrayList定义

ArrayList是基于`List`接口实现的大小可变的数组，元素允许为任意属性包括`null`。同时非有序，非同步(线程不安全)。主要用于装载数据。

`ArrayList`底层实现是**数组**。

## ArrayList的重要参数分析

```java
//ArrayList 默认容量为10
private static final int DEFAULT_CAPACITY = 10;
//用于ArrayList 空实例时的共享空数组
private static final Object[] EMPTY_ELEMENTDATA = {};
//用于默认大小 共享空数组实例
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA={};
//存储ArrayList元素的数据缓冲区，ArrayList的容量是此数据缓冲区的长度
transient Object[] elementData();
//ArrayList包含的元素个数
private int size;
```

## ArrayList初始化

```java
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
          //创建初始容量为 initialCapacity 的数组
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
           // 初始容量为0  引用空数组实例s
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }

    //构造一个默认10位的数组
    public ArrayList() {
        //初始默认 空数组
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

    public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            //将要插入到集合的元素 复制到数组中
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.         
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
```

在`ArrayList`初始化中，如果不是设置了初始容量，那么数据并不会进行初始化，等到第一次`add()`时进行初始化。

## ArrayList插入数据 - add()

```java
ArrayList<String> list =new ArrayList<>();
list.add("Android");
```

`add(E e)`源码

```java
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //在数组对应位置 放入数据
        elementData[size++] = e;
        return true;
    }

```

`ensureCapacitInternal()`用来判定是否需要扩充来存储数据

```java
    private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

   //未初始化则 返回10  初始化完成 则是传递进来的值
    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        //此时用的是默认构造器 构造的ArrayList
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }

    private void ensureExplicitCapacity(int minCapacity) {
       //修改数量 +1 
        modCount++;

        // 确保数组的容量，如果不够需要进行扩容 未初始化时 elementData.length == 0
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }

```

`grow()`用来进行数组扩容

```java
    private void grow(int minCapacity) {
        // 当前数组的容量
        int oldCapacity = elementData.length;
        //新数组扩容至原来的1.5倍
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        //未初始化 min为10
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        //超出上限 则长度变为 Integer.MAX_VALUE
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // 复制元素到新的数组中
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

### `add(int index,E element)`

```java
public void add(int index, E element) {
    // 判断 index 有没有超出索引的范围
    rangeCheckForAdd(index);
    // 和之前的操作是一样的，都是保证数组的容量足够
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 将指定位置及其后面数据向后移动一位
    System.arraycopy(elementData, index, elementData, index + 1,size - index);
    // 将该元素添加到指定的数组位置
    elementData[index] = element;
    // ArrayList 的大小改变
    size++;
}
```

`rangeCheckForAdd()` 判断要插入数据的index是否超过当前存储数据的上限`size`

```java
    private void rangeCheckForAdd(int index) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
```



{% fullimage /images/ArrayList-add过程.png,ArrayList-add过程,ArrayList-add过程%}



## ArrayList获取数据 - get()

```java
list.get(0);
```

`get()`源码

```java
    public E get(int index) {
        //判定index位置是否在范围内
        rangeCheck(index);

        return elementData(index);
    }
```



## ArrayList删除数据 - remove()

```java
list.remove(0);
//删除内容
list.remove("Android")
```

`remove(int index)`源码

```java
    public E remove(int index) {
        //检查index有没有超出范围
        rangeCheck(index);

        modCount++;
        //保存需要删除的数据 可以返回旧值
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            //把删除的位置后一位数据 向前移
            System.arraycopy(elementData, index+1, elementData, index, numMoved);
        //设置原位置元素为null  方便释放内存
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }
```

`remove(Object o)`源码

```java
    public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            //如果有元素值 == o 找到对应的位置 并移除
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

    private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }
```

## ArrayList清空数据 - clear()

```java
list.clear()
```

`clear()`源码

```java
    public void clear() {
        modCount++;

        // 数组内所有元素置null
        for (int i = 0; i < size; i++)
            elementData[i] = null;

        size = 0;
    }
```

## 拓展

#### ArrayList和LinkedList的区别?

> ArrayList
>
> - 基于**数组**实现，可以用索引实现快速查找。是动态数组，相比于数组容量可以实现动态增长。
> - ArrayList可以插入`null`。
> - ArrayList初始容量为10，以1.5倍大小进行扩容。
> - ArrayList不是线程安全。如果想线程安全可以通过`Collections.synchronizeList()`包裹ArrayList，实质上是对ArrayList的所有操作加了锁。推荐使用`CopyOnWriteArrayList`。
> - 在顺序添加数据以及查找和访问数据上有优势，再删除和插入数据上 需要进行数组复制操作。

<br>

>LinkdedList
>
>- 基于**链表**实现，是双向链表，增删速度快。是一个双向循环链表，也可以被当做堆栈、队列使用。
>- LinkedList比ArrayList更占内存，由于节点存储了数据以及前后两节点的引用
>- LinkedList是线程不安全，也可以通过`Collections.synchronizeList()`包括LinkedList，推荐使用`ConcurrentLinkedQueue`
>- 在数据的删除和插入上有优势

#### ArrayList及LinkedList在插入数据上的比较

- 在头部插入数据：`ArrayList`需要进行一次数组复制(`System.arrayCopy`)而`LinkedList`只要遍历找到头部为止即可。所以`LinkedList`高效。
- 在中部插入数据
  - 插入位置越靠前：`LinkedList`效率越高
  - 插入位置靠中间：`LinkedList`的遍历是从两边开始的，往中靠效率越低。
  - 插入位置越靠后：`ArrayList`效率越高
- 在尾部插入数据：`ArrayList`可能需要触发扩容操作，导致速度不如`LinkedList`。当数据量大时，`ArrayList`不会去频繁的进行扩容，效率就会高于`LinkedList`。

#### ArrayList的序列化

> `transient`可以关闭被修饰字段的序列化。

`elementData`是通过`transient`修饰的，那么内部的`elementData`是无法被序列化的。所以ArrayList内部实现了序列化及反序列化的一系列工作。

```java
    //保存ArrayList中的实例状态到序列中
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException{
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioural compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i<size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }

    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        elementData = EMPTY_ELEMENTDATA;

        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in capacity
        s.readInt(); // ignored

        if (size > 0) {
            // be like clone(), allocate array based upon size not capacity
            int capacity = calculateCapacity(elementData, size);
            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
            ensureCapacityInternal(size);

            Object[] a = elementData;
            // Read in all elements in the proper order.
            for (int i=0; i<size; i++) {
                a[i] = s.readObject();
            }
        }
    }
```

观察源码可知，只是序列化了`ArrayList中已存在的元素，而非整个数组`。]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC,MVP,MVVM的理解</title>
    <url>/2018/04/15/MVC-MVP-MVVM%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[


{% fullimage /images/MVC+-+MVP+-MVVM简析.png,MVC、MVP、MVVM,MVC、MVP、MVVM%}

> 使用架构的目的是：**模块内部的高内聚，模块之间的低耦合。**

## 1.MVC模式

MVC(Model-View-Controller，模型-视图-控制器)是20世纪80年代出现的一种设计模式。他用一种业务逻辑、数据、界面显示分离的方法组织代码。在Android中MVC的角色定义如下：

- Model(模型层)：针对业务模型，建立的数据结构和相关的类，就可以理解为Model。与View无关，与业务相关。主要负责网络请求、数据库处理、I/O操作。

- View(视图层)：一般采用XML文件或者Java代码进行界面的描述。

- Controller(控制器)：Android的控制层一般在Activity，Fragment中或者在由他们控制的其他业务类中。

  {% fullimage /images/pattern/mvc_pattern.png, MVC,MVC %}

优点：

- 实现简单，不需要过于复杂的逻辑以及文件分层

缺点：

- 在Android开发中，Activity不是一个标准的Controller，首要职责为加载应用的布局和初始化界面，并接受用户的请求。随着界面以及代码逻辑的复杂，Activity会越来越庞大。

## 2.MVP模式

MVP(Model-View-Presenter)是MVC的演化版本，对于Android来说，Model层和MVC模式是一种概念，activity或者fragment对应的就是View层，所有用户相关事件处理由Presenter处理。使用Presenter进行解耦操作。

- Model：主要提供数据的存取功能。

- View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件

- Presenter：作为View和Model沟通的桥梁，从Model层检索数据并返回给View层，使得View和Model层完全解耦。Presenter与View可以通过接口来实现通信，只要View层去实现定义好的接口。

  {% fullimage /images/pattern/mvp_pattern.png, MVP,MVP %}

优点：

- View与Model完全分离，修改不会互相影响逻辑
- Presenter可以进行复用，应用于多个View上
- 可以预先定义好Presenter，方便理解结构

缺点：

- View层和Presenter层会交互过于频繁，若Presenter过多的渲染了View，往往导致过于紧密，若View发生改动，Presenter也要发生变更。
- 随着业务的复杂，Presenter的接口会越来越多，有其他的View引用到该Presenter时，也要去实现这些接口


## 3.MVVM模式

MVVM(Model-View-ViewModel)是2015由微软提出的一个UI架构概念。将Presenter改为ViewModel，同时实现View和ViewModel的双向绑定（View的变动，自动反映在ViewModel，反之亦然）。

- Model：主要提供数据的存储过程

- View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件

- ViewModel：功能和Presenter类似，与View和Model双向绑定。只做业务逻辑与业务数据相关的事，内部不持有任何View，也不会引用View中的控件进行UI更新。

  {% fullimage /images/pattern/mvvm_pattern.png, MVVM,MVVM %}

优点：

- 低耦合。View可以独立于Model变化和修改，ViewModel可以绑定不同的View
- 可重用性。把许多的试图逻辑处理放在一个ViewModel中，许多View可以使用该ViewModel
- 独立开发。开发人员可以专注于逻辑和数据的处理
- 可测试性。可以直接针对ViewModel进行单独测试。

缺点：

- 使得Bug很难调试，由于View和Model的双向绑定

> 可以使用Google官方提供的 `LiveData、ViewModel`去实现这套模式。

## 4.如何进行选择

1. 如果项目简单，没什么复杂性，可以使用MVC架构，注意好封装各模块。
2. 对于偏向展示型的App，业务逻辑多在后端实现，可以使用MVVM。
3. 对于业务逻辑复杂且量级比较大的，推荐使用MVVM。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>SharedPreferences简析</title>
    <url>/2019/01/13/SharesPreference%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
{% fullimage /images/SharedPreferences解析.png,SharedPreferences解析,SharedPreferences解析%}

## SharedPreferences基本概念

Android系统提供的一种简易数据持久化的手段，适合**单进程、小批量**的数据存储与访问。最终会在手机的`/data/data/package_name/shared_prefs/`目录(*私有目录外部无法直接访问*)下生成一个xml文件。

SharedPreferences是基于单个xml文件实现的，并且所有持久化的数据都是一次性加载到内存中，如果数据过大，容易导致内存问题。

## SharedPreferences源码解析

### 获取SharedPreferences对象

```java
SharedPreferences sharedPreferences= getSharedPreferences("test",Activity.MODE_PRIVATE);
```

`test`：表明了生成xml文件名为 test.xml

`Activity.MODE_PRIVATE`：该参数表明了文件的访问权限以及数据的写入方式。

| 权限控制格式                  | 作用                                                         | 备注         |
| ----------------------------- | ------------------------------------------------------------ | ------------ |
| Activity.MODE_PRIVATE         | **代表该文件是私有数据，只能被当前应用访问。**<br>写入的内容会覆盖源文件的内容。 | 默认操作模式 |
| Activity.MODE_WORLD_READABLE  | 表示当前文件可以被其他应用读取                               |              |
| Activity.MODE_WORLE_WRITEABLE | 表示当前文件可以被其他应用写入                               |              |
| Activity.MODE_APPEND          | 会检查当前是否有文件存在？<br>在在后面追加内容<br>不存在则去创建新文件 |              |

#### 源码解析

在使用`SharedPreferences`时，需要获取到SharedPreferences对象。

```java ContextImpl.java
 public SharedPreferences getSharedPreferences(String name, int mode) {
        if (mPackageInfo.getApplicationInfo().targetSdkVersion <
                Build.VERSION_CODES.KITKAT) {
            if (name == null) {
                name = "null";
            }
        }

        File file;
       //创建SharedPreferences对象时 锁住当前 Context对象
        synchronized (ContextImpl.class) {
            if (mSharedPrefsPaths == null) {
                //ArrayMap 类似HashMap的使用方式，适用于少量数据
                mSharedPrefsPaths = new ArrayMap<>();
            }
            file = mSharedPrefsPaths.get(name);
            if (file == null) {
                //新建xml文件
                file = getSharedPreferencesPath(name);
                mSharedPrefsPaths.put(name, file);
            }
        }
        return getSharedPreferences(file, mode);
    }

    //放入对应的shared_prefs文件夹
    @Override
    public File getSharedPreferencesPath(String name) {
        return makeFilename(getPreferencesDir(), name + ".xml");
    }

@Override
    public SharedPreferences getSharedPreferences(File file, int mode) {
        checkMode(mode);
        if (getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.O) {
            if (isCredentialProtectedStorage()
                    && !getSystemService(StorageManager.class).isUserKeyUnlocked(
                            UserHandle.myUserId())
                    && !isBuggy()) {
                throw new IllegalStateException("SharedPreferences in credential encrypted "
                        + "storage are not available until after user is unlocked");
            }
        }
        SharedPreferencesImpl sp;
        //保证创建 SharedPreferencesImpl 是线程安全的
        synchronized (ContextImpl.class) {
            final ArrayMap<File, SharedPreferencesImpl> cache = getSharedPreferencesCacheLocked();
            //获取缓存文件
            sp = cache.get(file);
            //当前不存在缓存文件 则新建
            if (sp == null) {
                //构建 SharedPreferencesImpl 对象
                sp = new SharedPreferencesImpl(file, mode);
                //放入缓存中
                cache.put(file, sp);
                return sp;
            }
        }
        if ((mode & Context.MODE_MULTI_PROCESS) != 0 ||
            getApplicationInfo().targetSdkVersion < android.os.Build.VERSION_CODES.HONEYCOMB) {
            //重新加载 xml文件
            sp.startReloadIfChangedUnexpectedly();
        }
        return sp;
    }
```

> 1. 根据传入的`name`在`shared_prefs`生成对应name的xml文件，并存入`mSharedPrefsPaths`中以做缓存。
> 2. 创建文件完毕后，再去创建对应的`SharedPreferencesImpl`对象，创建完毕后一存入`ArrayMap<File,SharedPreferencesImpl>`中作为缓存
> 3. 再次调用相同的参数时，由于缓存的存在，不会重新走一遍上述流程，而是从对应缓存中直接取出结果即可。**缓存机制的存在，不会对性能造成过大影响。**
> 4. 当`mode == Context.MODE_MULTI_PROCESS`或者 `SDK版本小于 2.3`会去判断是否有进程对xml文件进行过修改，然后去重新加载xml文件。

#### `SharedPreferencesImpl`对象的构建

> 最终得到的`SharedPreferences`都是由`SharedPreferencesImpl`创建的。

```java SharedPreferencesImpl.java
//基本构造方法    
SharedPreferencesImpl(File file, int mode) {
        mFile = file;
        //创建备份文件 当用户写入失败时，会从备份文件中恢复
        mBackupFile = makeBackupFile(file);
        mMode = mode;
        //表示数据是否加载完毕
        mLoaded = false;
        //存放xml文件数据
        mMap = null;
        startLoadFromDisk();
    }

//从xml文件读取信息
private void startLoadFromDisk() {
        synchronized (mLock) {
            mLoaded = false;
        }
        //开启异步线程读取数据，防止阻塞主线程
        new Thread("SharedPreferencesImpl-load") {
            public void run() {
                loadFromDisk();
            }
        }.start();
    }
    //从xml文件读取信息
    private void loadFromDisk() {
        synchronized (mLock) {
            if (mLoaded) {
                return;
            }
            //回滚源文件
            if (mBackupFile.exists()) {
                mFile.delete();
                mBackupFile.renameTo(mFile);
            }
        }

        // Debugging
        if (mFile.exists() && !mFile.canRead()) {
            Log.w(TAG, "Attempt to read preferences file " + mFile + " without permission");
        }

        Map map = null;
        StructStat stat = null;
        try {
            stat = Os.stat(mFile.getPath());
            if (mFile.canRead()) {
                BufferedInputStream str = null;
                try {
                    str = new BufferedInputStream(
                            new FileInputStream(mFile), 16*1024);
                    map = XmlUtils.readMapXml(str);
                } catch (Exception e) {
                    Log.w(TAG, "Cannot read " + mFile.getAbsolutePath(), e);
                } finally {
                    IoUtils.closeQuietly(str);
                }
            }
        } catch (ErrnoException e) {
            /* ignore */
        }

        synchronized (mLock) {
            //加载解析数据成功 设置为true
            mLoaded = true;
            if (map != null) {
                mMap = map;
                mStatTimestamp = stat.st_mtime;
                mStatSize = stat.st_size;
            } else {
                mMap = new HashMap<>();
            }
            //唤醒等待数据加载完毕的线程
            mLock.notifyAll();
        }
    }

    static File makeBackupFile(File prefsFile) {
        return new File(prefsFile.getPath() + ".bak");
    }

```

> 1. 加载xml文件是新开启了一个异步线程操作，根据`mLoaded`判断是否加载完毕
> 2. 解析xml文件得到的结果都会放到`mMap`中，是HashMap类型
> 3. 存储文件的修改时间`mStatTimestamp`以及文件大小`mStatSize`是为了判断该文件是否被其他进程所修改，若修改则需重载xml文件
> 4. 数据加载完毕后，释放锁通知其他线程可以使用`SharedPreferences`对象

### 插入数据——`putXX()`

```java
SharedPreferences.Editor mEditor = sharedPreferences.edit();
//插入数据
mEditor.putString("android","first");
//更新数据
mEditor.apply();
//mEditor.commit();
```

#### 获取`Editor`对象

> 写操作都是基于`Editor`这个对象进行操作的

```java SharedPreferences.java
public interface Editor {
    //放入String对象
    Editor putString(String key, @Nullable String value);
    //放入int对象
    Editor putInt(String key, int value);
    ...
    //提交数据修改
    boolean commit(); 
    void apply()
}
```

`Editor`是一个接口，具体实现类在于`EditorImpl`类。

#### 写入不同类型数据

```java SharedPreferencesImpl.java
public final class EditorImpl implements Editor{
    //临时修改的数据存放于此 等到调用 commit()/apply()时合并数据
    private final Map<String, Object> mModified = Maps.newHashMap();
    
    //实现接口中对应方法
    public Editor putString(String key, @Nullable String value) {
            synchronized (mLock) {
                //放入临时文件中
                mModified.put(key, value);
                return this;
            }
        }
}
```

`mModified`用于存放用户新增的数据，调用如`putString()`后，`mModified`就会记录修改后的数据，等到调用到`commit()/apply()`才会写入到磁盘中。

*所有的putXX()操作都由`synchronized`修饰，保证线程安全。*

#### 提交数据更新

提交的方法有两种`commit()`、`apply()`，需要了解他们之间的区别。

##### commit()：同步写入数据

```java SharedPreferencesImpl.java
        public boolean commit() {
            long startTime = 0;

            if (DEBUG) {
                startTime = System.currentTimeMillis();
            }

            MemoryCommitResult mcr = commitToMemory();①

            SharedPreferencesImpl.this.enqueueDiskWrite( mcr, null /* sync write on this thread okay */);②
            try {
                mcr.writtenToDiskLatch.await();
            } catch (InterruptedException e) {
                return false;
            } finally {
                if (DEBUG) {
                    Log.d(TAG, mFile.getName() + ":" + mcr.memoryStateGeneration
                            + " committed after " + (System.currentTimeMillis() - startTime)
                            + " ms");
                }
            }
            notifyListeners(mcr);
            return mcr.writeToDiskResult;
        }
```

`commitToMemory()`：将缓存文件写入内存

```java 
private MemoryCommitResult commitToMemory() {
            long memoryStateGeneration;
            List<String> keysModified = null;
            Set<OnSharedPreferenceChangeListener> listeners = null;
            Map<String, Object> mapToWriteToDisk;
    
    //保证线程安全
    synchronized (SharedPreferencesImpl.this.mLock) {
        //当前正在写入磁盘
        if (mDiskWritesInFlight > 0) {
                    mMap = new HashMap<String, Object>(mMap);
                }
        mapToWriteToDisk = mMap;
        mDiskWritesInFlight++;
    }
    
    synchronized (mLock) {
                    boolean changesMade = false;
                    //只有调用 clear() mClear为true
                    if (mClear) {
                        if (!mMap.isEmpty()) {
                            changesMade = true;
                            mMap.clear();
                        }
                        mClear = false;
                    }
                    //遍历mModified数据 写入到mMap中
                    for (Map.Entry<String, Object> e : mModified.entrySet()) {
                        String k = e.getKey();
                        Object v = e.getValue();
                        if (v == this || v == null) {
                            //更新数据
                            if (!mMap.containsKey(k)) {
                                continue;
                            }
                            mMap.remove(k);
                        } else {
                            if (mMap.containsKey(k)) {
                                Object existingValue = mMap.get(k);
                                if (existingValue != null && existingValue.equals(v)) {
                                    continue;
                                }
                            }
                            //写入数据
                            mMap.put(k, v);
                        }

                        changesMade = true;
                        if (hasListeners) {
                            keysModified.add(k);
                        }
                    }
                    mModified.clear();
                    if (changesMade) {
                        mCurrentMemoryStateGeneration++;
                    }
                    memoryStateGeneration = mCurrentMemoryStateGeneration;
                }
}
```

将`mModified`数据写入到`mMap`中，然后清空`mModified`数据，免得下次使用出现重复数据。最后得到一个`MemoryCommitResult`对象。

> 调用`clear()`方法只是清理了`mMap`里的数据，不影响`mModified`中的数据。

`enqueueDiskWrite()`：将数据写入到磁盘**.xml文件中

```java
private void enqueueDiskWrite(final MemoryCommitResult mcr,
                                  final Runnable postWriteRunnable) {
        //对于commit()而言 isFromSyncCommit = true
        final boolean isFromSyncCommit = (postWriteRunnable == null);
        //负责将数据写入硬盘的xml文件中
        final Runnable writeToDiskRunnable = new Runnable() {
                public void run() {
                    synchronized (mWritingToDiskLock) {
                        /*
                        *  写入数据到磁盘中
                        *  把已存在的文件进行重命名 添加.bak后缀，作为备份文件存在。删除源文件
                        *  新建 源文件，重新写入所有数据，同时记录写入时间
                        *  如果写入文件失败，删除新建的文件，并返回失败
                        *  如果写入文件成功，删除备份文件，返回成功
                        */
                        writeToFile(mcr, isFromSyncCommit);
                    }
                    synchronized (mLock) {
                        mDiskWritesInFlight--;
                    }
                    if (postWriteRunnable != null) {
                        postWriteRunnable.run();
                    }
                }
            };
        //commit()执行方法
        if (isFromSyncCommit) {
            boolean wasEmpty = false;
            synchronized (mLock) {
                //当前如果只有一个写入硬盘的需求
                wasEmpty = mDiskWritesInFlight == 1;
            }
            if (wasEmpty) {
                //直接在当前线程开始写入磁盘操作
                writeToDiskRunnable.run();
                return;
            }
        }
        //开启线程池执行写入任务
        QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);
    }

```

`commit()`先后调用了`commitToMemory()/*写入数据到mMap中，等待写入磁盘*/`、`enqueueDiskWrite()/*将数据写入到磁盘中*/`，通过`writeToFile()`写入到磁盘中并会返回对应写入结果。

**`commit()`执行都是同步的，而且每次都是写入全量的数据，会导致主线程阻塞。**

##### apply()：异步写入数据

```java
        public void apply() {
            final long startTime = System.currentTimeMillis();
            //将数据写入到内存中
            final MemoryCommitResult mcr = commitToMemory();
            final Runnable awaitCommit = new Runnable() {
                    public void run() {
                        try {
                            mcr.writtenToDiskLatch.await();
                        } catch (InterruptedException ignored) {
                        }

                        if (DEBUG && mcr.wasWritten) {
                            Log.d(TAG, mFile.getName() + ":" + mcr.memoryStateGeneration
                                    + " applied after " + (System.currentTimeMillis() - startTime)
                                    + " ms");
                        }
                    }
                };

            QueuedWork.addFinisher(awaitCommit);

            Runnable postWriteRunnable = new Runnable() {
                    public void run() {
                        awaitCommit.run();
                        QueuedWork.removeFinisher(awaitCommit);
                    }
                };
            //开启一个异步线程去执行写入任务
            SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);

            //通知数据写入完成
            notifyListeners(mcr);
        }
```

`apply()`也先调用`commitToMemory()`将更改提交到内存，之后调用`enqueueDiskWriter()`开启写入磁盘任务。

根据上节观察`commit()`如果当前没有线程在写入文件时，就会直接在当前线程开启写入磁盘任务，导致主线程阻塞(*可能发生ANR*)，等待线程执行完毕。

`apply()`是提交任务到线程池后，就直接通知写入成功，不需要等待线程执行完成。

> `apply()`也不是绝对安全的，可能在某些情况下也会导致ANR情况发生。
>
> 例如频繁调用`apply()`也会导致线程堆积，消耗大量资源。

### 获取数据

```java
sharedPreferences.getString("android","");
```

```java SharedPreferencesImpl.java
    @Nullable
    public String getString(String key, @Nullable String defValue) {
       
        synchronized (mLock) {
            //等待数据加载完毕才可以读取数据
            awaitLoadedLocked();
            //从mMap中读取对应key数据
            String v = (String)mMap.get(key);
            //为空则返回 默认值
            return v != null ? v : defValue;
        }
    }

   private void awaitLoadedLocked() {
        if (!mLoaded) {
            // Raise an explicit StrictMode onReadFromDisk for this
            // thread, since the real read will be in a different
            // thread and otherwise ignored by StrictMode.
            BlockGuard.getThreadPolicy().onReadFromDisk();
        }
        //mLoaded 表示数据是否加载完毕
        while (!mLoaded) {
            try {
                mLock.wait();
            } catch (InterruptedException unused) {
            }
        }
    }
```

> `getXX()`是线程安全的，内部使用了`synchronized`进行保证
>
> `getXX()`是直接去读取`mMap`，所以`apply()`写入内存之后就可以直接获取到对应数据
>
> `getXX()`可能由于`awaitLoadedLocked()`发生阻塞，需要等到`loadFromDisk()`执行完毕置`mLoaded = true`时，调用`notifyAll()`解除阻塞。

## SharedPreferences注意事项

根据上述源码分析，在使用`SharedPreferences`时需要注意以下几项来提高使用效率：

- `SharedPreferences`中的文件读取都是一次性加载入内存的，最好不要写入大量的数据以及可以多建几个文件按需加载，减少内存压力以及提高响应时间。
- `SharedPreferences`的数据写入是全量写入的，每次写入都需要删除原文件后新建文件写入，所以不要频繁调用`commit()/apply()`，最好是批量写入。
- 需要读取`SharedPreferences`的数据时，需要等待数据加载完毕才可以使用，造成等待，可以提前去加载`SharedPreferences`对象，减少后续操作等待时间。
- `commit()`是同步执行写入任务的，如果当前只有一个`SharedPreferences`需要操作，就会在主线程执行写入磁盘操作，导致阻塞；`apply()`是异步执行写入任务，等待写入内存操作完成(*赋值mMap*)就直接返回结果。
- `MODE_MULTI_PROCESS`是在每次`getSharedPreferences`时检查磁盘上配置文件上次修改时间和文件大小，一旦所有修改则会重新从磁盘加载文件，所以并不能保证多进程数据的实时同步。



## 内容引用

[Android SharedPreferences最佳实践](<https://juejin.im/post/5c361469f265da61776c29d0>)

[一眼看穿 SharedPreferences](<https://juejin.im/post/5c34615bf265da614171bf8a#heading-3>)

]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Window及WindowManager</title>
    <url>/2019/01/10/%E7%90%86%E8%A7%A3Window%E5%8F%8AWindowManager/</url>
    <content><![CDATA[
{% fullimage /images/WindowWindowManager.png,Window&WindowManager,Window&WindowManager%}

## 1.基本概念

`Window`：他是一个抽象类，具体的实现类为`PhoneWindow`，它对View进行管理。每个Window都会对应一个`View`和一个`ViewRootImpl`，Window通过`ViewRootImpl`与View建立联系。

`WindowManager`：是一个接口类，继承`ViewManager`，主要用于管理Window，具体实现类为`WindowManagerImpl`。实际使用中无法直接访问Window，需要通过`WindowManager`进行操作。

`WindowManagerService`：`WindowManager`的具体工作都会通过`WindowManagerService`进行处理，他们之间通过`Binder`进行跨进程通信，`WindowManager`无法直接调用WMS中的API。



{% fullimage /images/Window&WindowManager&WMS.png,Window&WindowManager&WMS,Window&WindowManager&WMS%}



## 2.Window的属性

### Window的类型(*Type*)

Window有三种类型：

- **Application Window(应用窗口)**：对应一个Activity  `层级范围为1~99`

- **Sub Window(子窗口)**：不能独立存在，需要附着在其他窗口上才行，例如*Dialog,PopupWindow*   `层级范围为1000~1999`
- **System Window(系统窗口)**：需要声明权限才能创建的Window，例如*Toast*   `层级范围为2000~2999`



Window是分层的，层级大的Window会覆盖在层级小的Window上面，上面描述的层级范围对应的是`WindowManager.LayoutParams的type参数`。

通过`layoutParams.type = LayoutParams.TYPE_XXX`可以设置层级。**同时需要声明`<user-permission android:name="android:permission.SYSTEM_ALERT_WINDOW">`**就可以设置系统窗口的type。



### Window的标志(*Flag*)

Window的标志用于控制Window的显示，同时被定义在`WindowManager.LayoutParams`中，以下列举比较常用的：

| FLAG                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| FLAG_NOT_FOCUSABLE    | 表示Window不需要获取焦点，也不需要接收各种输入事件，同时会设置`FLAG_NOT_TOUCH_MODAL`标记，最终事件会传递到下层具有焦点的Window |
| FLAG_NOT_TOUCH_MODAL  | 系统会将当前区域以外的触摸事件向下传递，Window以内的事件自己处理。*一般需要开启，否则其他Window无法接受时间。* |
| FLAG_SHOW_WHEN_LOCKED | 表示Window可显示在锁屏界面。(*例如XX助手*)                   |
| FLAG_KEEP_SCREEN_ON   | 只要窗口可见，屏幕就会一直亮着                               |
| FLAG_FULLSCREEN       | 隐藏所有的屏幕装饰窗口，进入全屏显示                         |

设置Windwo的Flag有三种方法：

1. 通过Window的`addFlags()`

   ```java
   Window mWindow = getWindow();
   window.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
   ```

2. 通过Window的`setFlags()`

   ```java
   Window mWindow = getWindow();
   window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
   ```

   > `addFlags()`内部实现调用的还是`setFlags()`，两者区别不大。

3. 设置`LayoutParams.flags=XX`，并通过`addView()`添加进Window

   ```java
   WindowManager.LayoutParams mLayoutParams = new WindowManager.LayoutParams();
   mLayoutParams.flags = WindowManager.LayoutParams.FLAG_FULLSCREEN;
   WindowManager mWindowManager = (WindowManager)getSystemService(Context.WINDOW_SERVICE);
   TextView tv = new TextView(this);
   mWindowManager.addView(tv,mLayoutParams);
   ```



### Window的位置(*Gravity*)

默认位于屏幕中间

```java
mLayoutParams.gravity = Gravity.LEFT | Gravity.TOP;//配置gravity 居于左上位置
mLayoutParams.x = 100;//相对于gravity 居左100
mLayoutParams.y = 300;//相对于gravity 居上300
```

设置的`x、y`是相对于gravity的位置



### Window软键盘相关模式

窗口之间的叠加是常见的场景，如果弹出窗口为软键盘的话，可能会有显示问题，默认弹出软键盘会覆盖用户的输入框。`WindowManager.LayoutParams`中定义了相关的软键盘弹出模式，下面列举常用的几个：

| SoftInputMode                  | 描述                                                 |
| ------------------------------ | ---------------------------------------------------- |
| SOFT_INPUT_STATE_UNSPECIFIED   | 没有指定状态，系统会自动选择一个                     |
| SOFT_INPUT_STATE_UNCHANGED     | 不会改变软键盘状态                                   |
| SOFT_INPUT_STATE_HIDDEN        | 用户进入窗口，软键盘默认隐藏                         |
| SOFT_INPUT_STATE_ALWAYS_HIDDEN | 窗口获取焦点时，软键盘总是隐藏                       |
| SOFT_INPUT_ADJUST_RESIZE       | 软键盘弹出时，窗口会调整大小                         |
| SOFT_INPUT_ADJUST_PAN          | 软键盘弹出时，窗口不需要调整大小，确保输入焦点是可见 |

```java
getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN)
```

或者设置在`AndroidManifest.xml`中

```xml
<activity
          android:windowSoftInputMode="SOFT_INPUT_ADJUST_PAN"
          />
```



## 3.Window的操作

对Window的访问必须通过`WindowManager`，主要有三大操作：**添加、更新、删除**。这三个方法主要定义在`ViewManger`中

```java
public interface ViewManager
{
    public void addView(View view, ViewGroup.LayoutParams params);
    public void updateViewLayout(View view, ViewGroup.LayoutParams params);
    public void removeView(View view);
}
```

`WindowManager`也是一个接口继承自`ViewManager`

```java
public interface WindowManager extends ViewManager 
```

`WindowManagerImpl`就是`WindowManager`的具体实现类

```java
public final class WindowManagerImpl implements WindowManager {
 ...
    @Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }

    @Override
    public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.updateViewLayout(view, params);
    }
  
      @Override
    public void removeView(View view) {
        mGlobal.removeView(view, false);
    }
  ...
}
```

最终`WindowManagerImpl`对View的操作交由`WindowManagerGlobal`去实现。

{% fullimage /images/WindowManager关系.png,WindowManager关系,WindowManager关系%}

`WindowManagerGlobal`通过`ViewRootImpl`操作Window，`ViewRootImpl`通过`IWindowSession`这个Binder对象与`WindowManagerService`进程间通信去操作Window。

{% post_link WindowManagerService简析%}

### Window添加

> 添加过程需要通过`WindowManager.addView()`来实现，它的真正实现需要通过`WindowManagerGlobal`

```java
    //存储所有Window对应的View
    private final ArrayList<View> mViews = new ArrayList<View>();
    //所有Window对应的ViewRootImpl
    private final ArrayList<ViewRootImpl> mRoots = new ArrayList<ViewRootImpl>();
    //所有Window对应的布局参数 LayoutParams
    private final ArrayList<WindowManager.LayoutParams> mParams =
            new ArrayList<WindowManager.LayoutParams>();
    //存储那些正在被删除的对象
    private final ArraySet<View> mDyingViews = new ArraySet<View>();    

public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        //检测参数是否合法
        if (view == null) {
            throw new IllegalArgumentException("view must not be null");
        }
        if (display == null) {
            throw new IllegalArgumentException("display must not be null");
        }
        if (!(params instanceof WindowManager.LayoutParams)) {
            throw new IllegalArgumentException("Params must be WindowManager.LayoutParams");
        } 
      
        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;
        //如果是子Window还需要调整参数
        if (parentWindow != null) {
            parentWindow.adjustLayoutParamsForSubWindow(wparams);
        } else {
            
            final Context context = view.getContext();
            if (context != null
                    && (context.getApplicationInfo().flags
                            & ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
            }
        }
      
      ...
        //创建ViewRootImpl
        root = new ViewRootImpl(view.getContext(), display);
        view.setLayoutParams(wparams);
        //保存当前界面的参数
        mViews.add(view);
        mRoots.add(root);
        mParams.add(wparams);
      ...
        try {
            //调用 ViewRootImpl.setView() 更新界面并完成Window的添加过程
                root.setView(view, wparams, panelParentView);
            } catch (RuntimeException e) {
                // BadTokenException or InvalidDisplayException, clean up.
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
                throw e;
            }
    }
```

在`WindowManagerGlobal.addView()`主要完成了以下三步：

- 检查参数是否合法，如果是子Window，还需要调整参数
- 创建ViewRootImpl，然后保存当前界面参数
- 调用`ViewRootImpl.setView()`继续完成Window的添加过程

````java
// ../android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
  synchronized (this) {
    ...
      //刷新当前界面
      requestLayout();
    ...
       try {
                    mOrigWindowType = mWindowAttributes.type;
                    mAttachInfo.mRecomputeGlobalAttributes = true;
                    collectViewAttributes();
                    //最终添加Window实现过程
                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);
                } catch (RemoteException e) {
                    mAdded = false;
                    mView = null;
                    mAttachInfo.mRootView = null;
                    mInputChannel = null;
                    mFallbackEventHandler.setView(null);
                    unscheduleTraversals();
                    setAccessibilityFocus(null, null);
                    throw new RuntimeException("Adding window failed", e);
                } finally {
                    if (restore) {
                        attrs.restore();
                    }
                }
  }
}
````

`mWindowSession`的类型是`IWindowSession`是一个Binder对象，用于进行进程间通信，它是`Session`代理对象。

添加完成后，需要通过返回值`res`来判断是否添加成功。若是`WindowManagerGlobal.ADD_PKAY`说明添加成功。

```java
// ../core/java/com/android/server/wm/Session.java
    final WindowManagerService mService;
    @Override
    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,
            Rect outOutsets, InputChannel outInputChannel) {
        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
                outContentInsets, outStableInsets, outOutsets, outInputChannel);
    }
```

`addToDisplay()`最终调用到`WindowManagerService.addWindow()`实现Window添加过程。

{% fullimage /images/Window添加过程.png,Window添加过程,Window添加过程%}

### Window更新

> 更新过程需要通过`WindowManager.updateViewLayout()`，它的真正实现需要通过`WindowManagerGlobal`

```java
// ../android/view/WindowManagerGlobal.java   
public void updateViewLayout(View view, ViewGroup.LayoutParams params) {
        if (view == null) {
            throw new IllegalArgumentException("view must not be null");
        }
        if (!(params instanceof WindowManager.LayoutParams)) {
            throw new IllegalArgumentException("Params must be WindowManager.LayoutParams");
        }

        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;
        //更新View的LayoutParams
        view.setLayoutParams(wparams);

        synchronized (mLock) {
            int index = findViewLocked(view, true);
            ViewRootImpl root = mRoots.get(index);
            mParams.remove(index);
            mParams.add(index, wparams);
            root.setLayoutParams(wparams, false);
        }
    }
```

更新View的LayoutParams之后，还需要更新`ViewRootImpl.setLayoutParams()`

```java
// ../android/view/ViewRootImpl.java
void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView) {
  synchronized(this){
    ...
            if (newView) {
                mSoftInputMode = attrs.softInputMode;
                requestLayout();
            }

            if ((attrs.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)
                    == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
                mWindowAttributes.softInputMode = (mWindowAttributes.softInputMode
                        & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)
                        | (oldSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST);
            }

            mWindowAttributesChanged = true;
            //开始View的测量，布局，绘制流程
            scheduleTraversals();
  }
}
```

在`scheduleTraversals()`调用到`performTraversals()`继续执行更新过程

```java
private void performTraversals() {
  ...
    relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);
  ...
    if(!mStopped){
      int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
      int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); 
      //开始测量过程
      performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    }
    ...
    //layoutRequested 是否需要重新执行布局过程
    final boolean didLayout = layoutRequested && (!mStopped || mReportNextDraw);
    if(didLayout){
      //开始布局过程
      performLayout(lp, mWidth, mHeight);
    }
    ...
    if (!cancelDraw && !newSurface) {
            if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
                for (int i = 0; i < mPendingTransitions.size(); ++i) {
                    mPendingTransitions.get(i).startChangingAnimations();
                }
                mPendingTransitions.clear();
            }
            //开始绘制过程
            performDraw();
        } 
  ...
  
}
```

`performTraversals()`内部实现了Window更新以及View的整个工作过程(*测量-布局-绘制*)。

```java
    private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {
      ...
         int relayoutResult = mWindowSession.relayout(
                mWindow, mSeq, params,
                (int) (mView.getMeasuredWidth() * appScale + 0.5f),
                (int) (mView.getMeasuredHeight() * appScale + 0.5f),
                viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,
                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame,
                mPendingMergedConfiguration, mSurface);
      ...
    }
```

`mWindowSession`的类型是`IWindowSession`是一个Binder对象，用于进行进程间通信，它是`Session`代理对象。

`mWindow`即`W extends IWindow.Stub`发送给WindowManagerService，用来接受WMS信息。

```java
// ../core/java/com/android/server/wm/Session.java
    final WindowManagerService mService;
    public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewFlags,
            int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
            Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,
            MergedConfiguration mergedConfiguration, Surface outSurface) {

        int res = mService.relayoutWindow(this, window, seq, attrs,
                requestedWidth, requestedHeight, viewFlags, flags,
                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,
                outStableInsets, outsets, outBackdropFrame, mergedConfiguration, outSurface);

        return res;
    }

```

`relayout()`最终调用到`WindowManagerService.relayoutWindow()`实现Window更新过程。

{% fullimage /images/Window更新过程.png,Window更新过程,Window更新过程%}

### Window删除

> 删除过程需要通过`WindowManager.removeView()`来实现，它的真正实现需要通过`WindowManagerGlobal`

```java 文件位置../android/view/WindowManagerGlobal.java  
// ../android/view/WindowManagerGlobal.java   
public void removeView(View view, boolean immediate) {
        if (view == null) {
            throw new IllegalArgumentException("view must not be null");
        }

        synchronized (mLock) {
            //找到需要删除的View索引
            int index = findViewLocked(view, true);
            View curView = mRoots.get(index).getView();
            removeViewLocked(index, immediate);
            if (curView == view) {
                return;
            }

            throw new IllegalStateException("Calling with view " + view
                    + " but the ViewAncestor is attached to " + curView);
        }
    }
```

实际调用`removeViewLocked()`执行删除Window操作，内部实现还是依赖了`ViewRootImpl`

```java ../android/view/WindowManagerGlobal.java
 private void removeViewLocked(int index, boolean immediate) {
        //从Window添加过程中保存的 ViewRootImpl数组中获取对应的ViewRootImpl对象
        ViewRootImpl root = mRoots.get(index);
        View view = root.getView();

        if (view != null) {
            InputMethodManager imm = InputMethodManager.getInstance();
            if (imm != null) {
                imm.windowDismissed(mViews.get(index).getWindowToken());
            }
        }
        //在die 中执行删除Window操作
        boolean deferred = root.die(immediate);
        if (view != null) {
            view.assignParent(null);
            if (deferred) {
                //存储即将删除的View
                mDyingViews.add(view);
            }
        }
    }
```

```java ../android/view/ViewRootImpl.java
    boolean die(boolean immediate/*是否同步执行删除*/) {
        // Make sure we do execute immediately if we are in the middle of a traversal or the damage
        // done by dispatchDetachedFromWindow will cause havoc on return.
        if (immediate && !mIsInTraversal) {
            //删除对应Window
            doDie();
            return false;
        }

        if (!mIsDrawing) {
            destroyHardwareRenderer();
        } else {
            Log.e(mTag, "Attempting to destroy the window while drawing!\n" +
                    "  window=" + this + ", title=" + mWindowAttributes.getTitle());
        }
        mHandler.sendEmptyMessage(MSG_DIE);
        return true;
    }
```

`die()`中分为两种移除Window方式：*同步执行、异步执行(通过Handler)*。最终都会执行到`doDie()`

```java ../android/view/ViewRootImpl.java
    void doDie() {
        checkThread();
        synchronized (this) {
            if (mRemoved) {
                return;
            }
            mRemoved = true;
            if (mAdded) {
                //已经添加成功的，需要进行删除
                dispatchDetachedFromWindow();
            }
            ...
            mAdded = false;
        }
        //从保存的那些参数中 移除该View的所有引用
        WindowManagerGlobal.getInstance().doRemoveView(this);
    }
```

`doDie()`主要实现了两个功能：

- `dispatchDetachedFromWindow()`：移除Window
- `doRemoveView()`：移除Window所对应的引用

```java ../android/view/ViewRootImpl.java
 void dispatchDetachedFromWindow() {
    //触发View的 onDetachedFromWindow()
        if (mView != null && mView.mAttachInfo != null) {
            mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false);
            mView.dispatchDetachedFromWindow();
        }
    ...
        try {
            //依靠Session去移除Window
            mWindowSession.remove(mWindow);
        } catch (RemoteException e) {
        }
    ...
        unscheduleTraversals();
 }
```

`mWindowSession`的类型是`IWindowSession`是一个Binder对象，用于进行进程间通信，它是`Session`代理对象。

```java ../core/java/com/android/server/wm/Session.java
    public void remove(IWindow window) {
        mService.removeWindow(this, window);
    }
```

`remove()`最终通过`WindowManagerService.removeView()`实现Window删除逻辑。

{% fullimage /images/Window删除过程.png,Window删除过程,Window删除过程%}

### 总结

> 上述Window的三大操作(*添加、更新和删除*)都会通过一个IPC过程调用`WindowManagerService`去实现具体逻辑。
>
> 三大操作过程也都需要通过`ViewRootImpl`来关联起Window和View，`ViewRootImpl`可以控制内部VIew的*测量、布局与绘制*。
>
> **在上述三大操作中，虽然说是由`WindowManagerGlobal`去实现，但内部是依靠的`ViewRootImpl`，实际执行的是`WindowManagerService`。**{% post_link WindowManagerService简析%}

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView简析</title>
    <url>/2018/12/20/RecycleView%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[{% fullimage /images/RecyclerView机制.png,RecyclerView机制,RecyclerView机制%}
## RecyclerView定义

> RecyclerView是一个新的组件，用来代替ListView组件的。

相比于ListView来说，RecyclerView的最大一个特性就是**灵活性**，主要体现在以下几个方面：

- `多样式`：可以对数据展示进行定制，可以显示成列表，表格或者是瀑布流，你还可以自定义成任何显示样式。
- `局部刷新`：可以刷新指定的Item或者区域
- `刷新动画`：支持对Item的添加和移除添加动画
- `添加装饰`：支持自定义Item之间的分割线效果

相比ListView还有其他的优点：

- 默认实现View的复用，不需要判断`if(convertView == null)`的实现，回收机制更加完善。
- 容易实现拖拽，侧滑删除等效果。(利用`ItemTouchHelper`)

RecyclerView是一个插件式的实现，对各个功能进行解耦，从而扩展性比较好。

## RecyclerView用法

RecyclerView的标准实现流程如下：

- 创建Adapter：

  ```java
  public class DemoAdapter extends RecyclerView.Adapter<DemoAdapter.VH> {
  ...
  }
  ```

  创建一个继承`RecyclerView.Adapter`的Adapter类

- 创建ViewHolder：

  ```java
      static class VH extends RecyclerView.ViewHolder {
          final TextView title;
  
          VH(@NonNull View itemView) {
              super(itemView);
              title = itemView.findViewById(R.id.title);
          }
      }
  ```

  创建一个继承`RecyclerView.ViewHolder`的静态内部类，记为`VH`。内部实现类似`ListView的ViewHolder`。

- 完善以下方法：

  - `VH onCreateViewHolder(ViewGroup parent,int viewType)`：绑定对应的layout id并创建`VH`返回

    ```java
        public DemoAdapter.VH onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_demo, parent, false);
            return new VH(view);
        }
    ```

  - `void onBindViewHolder(VH holder,int position)`：为`VH`设置事件以及数据

    ```java
        public void onBindViewHolder(@NonNull VH holder, int position) {
            holder.title.setText(mData.get(position));
            holder.itemView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    //设置item点击事件
                }
            });
        }
    ```

  - `int getItemCount()`：返回item个数

    ```java
    	  public int getItemCount() {
            return mData.size();
        }
    ```

    

Adapter创建完成后，需要把Adapter设置到RecyclerView上。一般来说需要为RecyclerView进行四大设置：

- **设置Adapter(必须设置)**：给RecyclerView绑定数据源 
- **设置LayoutManager(必须设置)**：给RecyclerView设置显示样式
- **设置Item Decoration(可以设置)**：给RecyclerView设置Item间的分割线
- **设置Item Animator(可以设置)**：给RecyclerView设置Item的添加和删除动画

设置实例：

```java
List<String> data = new ArrayList<>();

RecyclerView rv_demo = (RecyclerView)findViewById(R.id.rv_demo);
rv_demo.setAdapter(new DemoAdapter(data));
rv_demo.setLayoutManager(new LinearLayoutManager(this));//默认竖向显示
```

更新数据：

```java
rv_demo.notifyDataSetChanged();//更新整个视图
//更新局部视图
rv_demo.notifyitemInserted();
rv_demo.notifyItemRemoved();
rv_demo.notifyitemChanged();
```

## RecyclerView源码解析

> RecyclerView的四大组成部分：**Adapter、LayoutManager、ItemAnimator，ItemDecoration**。

### Adapter

> 主要为了给RecyclerView提供数据，将Data与View进行绑定。创建ViewHolder以及数据变化时通知到RecyclerView。通知RecyclerView使用的是*观察者模式*。

在`setAdapter()`时，就会给Adapter注册一个观察者，去通知RecyclerView数据变化

```java
    public void setAdapter(Adapter adapter) {
        // bail out if layout is frozen
        setLayoutFrozen(false);
        setAdapterInternal(adapter, false, true);
        requestLayout();
    }

    private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,
            boolean removeAndRecycleViews) {
        ...
        if (adapter != null) {
            //注册观察者
            adapter.registerAdapterDataObserver(mObserver);
            adapter.onAttachedToRecyclerView(this);
        }
        ...
    }
```

<br>

### LayoutManager

> 负责RecyclerView的布局，其中包含了Item View的获取与回收。后面会分析它的缓存机制。

还是按照绘制流程来看，LayoutManager在RecyclerView中是如何使用的？

> Measure流程

```java
LayoutManager mLayout;   
@Override
    protected void onMeasure(int widthSpec, int heightSpec) {
      if (mLayout.mAutoMeasure) {
            final int widthMode = MeasureSpec.getMode(widthSpec);
            final int heightMode = MeasureSpec.getMode(heightSpec);
            final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY
                    && heightMode == MeasureSpec.EXACTLY;
            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);
       ... 
      }
      ...
    }
```

在`RecyclerView.onMeasure()`中调用到了`LayoutManager.onMeasure()`，然后其中执行到了`RecyclerView.defaultOnMeasure()`

```java
    void defaultOnMeasure(int widthSpec, int heightSpec) {
        // calling LayoutManager here is not pretty but that API is already public and it is better
        // than creating another method since this is internal.
        final int width = LayoutManager.chooseSize(widthSpec,
                getPaddingLeft() + getPaddingRight(),
                getMinimumWidth());
        final int height = LayoutManager.chooseSize(heightSpec,
                getPaddingTop() + getPaddingBottom(),
                getMinimumHeight());

        setMeasuredDimension(width, height);
    }

// LayoutManager.java
        public static int chooseSize(int spec, int desired, int min) {
            final int mode = View.MeasureSpec.getMode(spec);
            final int size = View.MeasureSpec.getSize(spec);
            switch (mode) {
                case View.MeasureSpec.EXACTLY:
                    return size;
                case View.MeasureSpec.AT_MOST:
                    return Math.min(size, Math.max(desired, min));
                case View.MeasureSpec.UNSPECIFIED:
                default:
                    return Math.max(desired, min);
            }
        }
```

最终RecyclerView的`Measure流程`依赖`LayoutManager.chooseSize()`来确定最后的RecyclerView宽高。

> Layout流程

```java
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        Trace.beginSection(TRACE_ON_LAYOUT_TAG);
        dispatchLayout();
        Trace.endSection();
        mFirstLayoutComplete = true;
    }

    void dispatchLayout() {
       ...
        mState.mIsMeasuring = false;
        //第一次开始布局
        if (mState.mLayoutStep == State.STEP_START) {
            //存储ziView状态并确定是否要执行动画
            dispatchLayoutStep1();
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
          //发生了数据变化(notifyDataSetChanges)或者布局变化
        } else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()
                || mLayout.getHeight() != getHeight()) {
            // First 2 steps are done in onMeasure but looks like we have to run again due to
            // changed size.
            mLayout.setExactMeasureSpecsFrom(this);
            //Item布局过程
            dispatchLayoutStep2();
        } else {
            // always make sure we sync them (to ensure mode is exact)
            mLayout.setExactMeasureSpecsFrom(this);
        }
        //执行Item 动画
        dispatchLayoutStep3();
    }
```

观察上述源码发现，涉及布局过程的只有`dispatchLayoutStep2()`，从这个方法继续向下看

```java
    private void dispatchLayoutStep2() {
        ...
        // Step 2: Run layout
        mState.mInPreLayout = false;
        mLayout.onLayoutChildren(mRecycler, mState);
        ...
    }
```

这里涉及到了`LayoutManager.onLayoutChildren()`，由于默认是空实现，我们就拿`LinearLayoutManager`这个子类继续分析

```java
// LinearLayoutManager.java
    @Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
     ...
        int startOffset;
        int endOffset;
        final int firstLayoutDirection;
        if (mAnchorInfo.mLayoutFromEnd) {
            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL
                    : LayoutState.ITEM_DIRECTION_HEAD;
        } else {
            firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD
                    : LayoutState.ITEM_DIRECTION_TAIL;
        }

        onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);
        detachAndScrapAttachedViews(recycler);
        mLayoutState.mInfinite = resolveIsInfinite();
        mLayoutState.mIsPreLayout = state.isPreLayout();
        //是否从底部布局
        if (mAnchorInfo.mLayoutFromEnd) {  
           // 向上布局
            updateLayoutStateToFillStart(mAnchorInfo);
            mLayoutState.mExtra = extraForStart;
            //填充item
            fill(recycler, mLayoutState, state, false);
            startOffset = mLayoutState.mOffset;
            final int firstElement = mLayoutState.mCurrentPosition;
            if (mLayoutState.mAvailable > 0) {
                extraForEnd += mLayoutState.mAvailable;
            }
            //向下布局
            updateLayoutStateToFillEnd(mAnchorInfo);
            mLayoutState.mExtra = extraForEnd;
            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
            fill(recycler, mLayoutState, state, false);
            endOffset = mLayoutState.mOffset;

            if (mLayoutState.mAvailable > 0) {
                // end could not consume all. add more items towards start
                extraForStart = mLayoutState.mAvailable;
                updateLayoutStateToFillStart(firstElement, startOffset);
                mLayoutState.mExtra = extraForStart;
                fill(recycler, mLayoutState, state, false);
                startOffset = mLayoutState.mOffset;
            }
        }else{
          ...
          
        }
      ...
    }
```

确定布局方向后，就需要填充子View，利用`fill()`实现。

```java
    int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {
       //存储当前可用空间
       final int start = layoutState.mAvailable;
       ...
        //计算可用布局宽高
        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
        LayoutChunkResult layoutChunkResult = mLayoutChunkResult;
       //迭代填充Item
        while ((layoutState.mInfinite || remainingSpace > 0) && layoutState.hasMore(state)) {
            layoutChunkResult.resetInternal();
            //布局item
            layoutChunk(recycler, state, layoutState, layoutChunkResult);
            if (layoutChunkResult.mFinished) {
                break;
            }
          layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;
           //子View的回收工作
        }
      ...
    }
```

在`fill()`中循环调用`layoutChunk()`进行布局。每次布局完成后需要计算剩余空间，之后判断是否需要继续布局Item。

向下看Item的布局方法`layoutChunk()`

```java
void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
		LayoutState layoutState, LayoutChunkResult result) {
	// 获取item view
	View view = layoutState.next(recycler);
	// 获取布局参数
	LayoutParams params = (LayoutParams) view.getLayoutParams();
	if (layoutState.mScrapList == null) {
		if (mShouldReverseLayout == (layoutState.mLayoutDirection== LayoutState.LAYOUT_START)) {
			// 增加item view
			addView(view);
		} else {
			addView(view, 0);
		}
	} 
	// 测量item
	measureChildWithMargins(view, 0, 0);
	// 计算item使用的空间
	result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);
	int left, top, right, bottom;
	// 竖直方向布局，计算Item坐标
	if (mOrientation == VERTICAL) {
    //设置了从右向左的布局方式
		if (isLayoutRTL()) {
			right = getWidth() - getPaddingRight();
			left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);
		} else {
			left = getPaddingLeft();
			right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);
		}
		if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
			bottom = layoutState.mOffset;
			top = layoutState.mOffset - result.mConsumed;
		} else {
			top = layoutState.mOffset;
			bottom = layoutState.mOffset + result.mConsumed;
		}   
	} 
  //水平方向布局，计算Item坐标
  else {
     top = getPaddingTop();
     bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);

     if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
          right = layoutState.mOffset;
          left = layoutState.mOffset - result.mConsumed;
     } else {
          left = layoutState.mOffset;
          right = layoutState.mOffset + result.mConsumed;
     }	   
	}
  	// item布局
	layoutDecoratedWithMargins(view, left, top, right, bottom);
  ...
}

//测量子View的布局
        public void measureChildWithMargins(View child, int widthUsed, int heightUsed) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();

            final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
            widthUsed += insets.left + insets.right;
            heightUsed += insets.top + insets.bottom;

            final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),
                    getPaddingLeft() + getPaddingRight()
                            + lp.leftMargin + lp.rightMargin + widthUsed, lp.width,
                    canScrollHorizontally());
            final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),
                    getPaddingTop() + getPaddingBottom()
                            + lp.topMargin + lp.bottomMargin + heightUsed, lp.height,
                    canScrollVertically());
            if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) {
               //子View测量
                child.measure(widthSpec, heightSpec);
            }
        }

        public void layoutDecoratedWithMargins(View child, int left, int top, int right,
                int bottom) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final Rect insets = lp.mDecorInsets;
            //子view布局
            child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,
                    right - insets.right - lp.rightMargin,
                    bottom - insets.bottom - lp.bottomMargin);
        }
```

在`layoutChunk()`中完成了子View的`measure以及layout`过程。

> Draw过程

Draw过程就是下文描述到的`ItemDecoration`，主要完成的就是绘制分割线的过程。

<br>

### ItemAnimator

> RecyclerView能够通过`RecyclerView.setItemAnimator(ItemAnimator animator)`设置添加、删除、移动、改变的动画效果。提供了默认的动画效果`DefaultItemAnimator`。

```java
class CustomItemAnimator : RecyclerView.ItemAnimator(){

  override fun isRunning(): Boolean {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
    
    override fun animatePersistence(
        viewHolder: RecyclerView.ViewHolder,
        preLayoutInfo: ItemHolderInfo,
        postLayoutInfo: ItemHolderInfo
    ): Boolean {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    override fun runPendingAnimations() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    override fun endAnimation(item: RecyclerView.ViewHolder) {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    override fun animateDisappearance(
        viewHolder: RecyclerView.ViewHolder,
        preLayoutInfo: ItemHolderInfo,
        postLayoutInfo: ItemHolderInfo?
    ): Boolean {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    override fun animateChange(
        oldHolder: RecyclerView.ViewHolder,
        newHolder: RecyclerView.ViewHolder,
        preLayoutInfo: ItemHolderInfo,
        postLayoutInfo: ItemHolderInfo
    ): Boolean {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    override fun animateAppearance(
        viewHolder: RecyclerView.ViewHolder,
        preLayoutInfo: ItemHolderInfo?,
        postLayoutInfo: ItemHolderInfo
    ): Boolean {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    override fun endAnimations() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

}
```

- `animateAppearance()`：当ViewHolder出现在屏幕上时被调用(*可能是add或move*)
- `animateDisappearance()`：当ViewHolder消失在屏幕上时被调用(*可能是remove或move*)
- `animatePersistence()`：在没调用`notifyItemChanged()`和`notifyDataSetChanged()`的情况下发生布局改变时被调用
- `animateChange()`：在调用`notifyItemChanged()`或`notifyDataSetChanged()`的情况下发生布局改变时被调用
- `runPendingAnimations()`：RecyclerView的执行方式是每帧执行一次，如果在帧之间添加了多个Item，就会保存Pending动画，等到下一帧一起执行。**前面定义的`animateXXX()`返回true。**
- `isRunning()`：是否有动画要执行或正在执行
- `dispatchAnimationsFinished()`：当全部动画执行完毕时调用

> 对于`ItemAnimator`，最常见的是*闪屏问题* ——当Item中存在图片和文字时，刷新RecyclerView时会出现闪烁问题。
>
> 出现原因是由于调用`notifyDataSetChanged()`，会调用到`DefaultAnimator.animateChangeImpl()`执行change动画，导致透明度发生0-1的变化，发生闪烁。
>
> 解决方法：在`setAdapter()`之前调用`((SimpleItemAnimator)rv.getItemAnimator()).setSupportsChangeAnimations(false)`禁用change动画。

<br>

### ItemDecoration

> RecyclerView通过`addItemDecoration()`添加Item之间的分割线。

如果我们要自己实现一个分割线效果，需要自己创建一个类并继承`RecyclerView.ItemDecoration`，重写一下两个方法：

- `onDraw()`：绘制分割线
- `getItemOffsets()`：设置分割线的宽高

```java
 class CustomDecoration : RecyclerView.ItemDecoration() {
     override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
         //调用在Item绘制完毕前，绘制分割线
     }

     override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) {
         //定义分割线的宽/高，在不同的显示模式下
     }

     override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
        //调用在Item绘制完毕后，绘制分割线
     }
 }
```

接下来分析RecyclerView是如何调用到分割线？

回顾View的绘制流程是*measure->layout->draw*，我们开始分析分割线的调用流程。

由于RecyclerView继承自`ViewGroup`，分割线是作为Item之间的间隔使用，那就要从`measureChild()`开始查看

```java
        public void measureChild(View child, int widthUsed, int heightUsed) {
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            //获取设置的分割线
            final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
            widthUsed += insets.left + insets.right;
            heightUsed += insets.top + insets.bottom;
            //都需要在原基础上 加上分割线的宽/高
            final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),
                    getPaddingLeft() + getPaddingRight() + widthUsed, lp.width,
                    canScrollHorizontally());
            final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),
                    getPaddingTop() + getPaddingBottom() + heightUsed, lp.height,
                    canScrollVertically()); 
            if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) {
                child.measure(widthSpec, heightSpec);
            }
        }

 Rect getItemDecorInsetsForChild(View child) {
        ...
            //调用到设置的 getItemOffsets()
            mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState);
        ...
    }
```

在`measureChild()`找到了引用分割线并设置宽高的地方，接下啦需要找到引用绘制(`onDraw`)的地方

```java
    @Override
    public void onDraw(Canvas c) {
        //调用到父类的 onDraw 即 View.onDraw
        super.onDraw(c);

        final int count = mItemDecorations.size();
        for (int i = 0; i < count; i++) {
            mItemDecorations.get(i).onDraw(c, this, mState);
        }
    }

    @Override
    public void draw(Canvas c) {
        //调用到父类的 draw() 即  View.draw()
        super.draw(c);

        final int count = mItemDecorations.size();
        for (int i = 0; i < count; i++) {
            mItemDecorations.get(i).onDrawOver(c, this, mState);
        }
      ...
    }

// View.java
 public void draw(Canvas canvas) {
  ...
    if (!dirtyOpaque) onDraw(canvas);
  ...
 }
```

上面找到了两个引用了`ItemDecoration`的绘制方法。这里回顾一下`ViewGroup`的Draw流程，先调用自身的`draw()`，然后`drawBackground()`，向下到`onDraw()`，绘制子View`disaptchDraw()`。

根据Draw流程分析，先调用到`RecyclerView.draw()`，发现调用到了`super.draw()`即指向了`View.draw()`这时View调用到自身的`onDraw()`，而RecyclerView重写了该方法，就调用到了`ItemDecoration.onDraw()`，然后走向`dispatchDraw()`绘制子View。绘制完毕后，最后调用到了`ItemDecoration.onDrawOver()`。

综上所述：**`onDraw()`调用在子View绘制前，`onDrawOver()`在绘制之后执行**。

<br>

### 缓存机制

> RecyclerView是以`RecyclerView.ViewHolder`作为单位进行回收。Recycler是RecyclerView回收机制的实现类。

Recycler实现的是**四级缓存**：

- `mAttachedScrap`：缓存已在屏幕上的ViewHolder。   *一级缓存*
- `mCacheViews`：缓存屏幕外的ViewHolder，默认为2个。  *一级缓存*
- `mViewCacheExtension`：需要用户定制，默认不实现。  *二级缓存*
- `mRecyclerPool`：缓存池，`mCacheViews`集合中装满时，会放到这里。技术上可以实现所有`RecyclerViewPool`共用。默认为5个。 *三级缓存*
- `createViewHolder`：创建ViewHolder。*‌四级缓存*

缓存机制主要分为两段流程：**复用机制和回收机制。**

#### 复用机制

>  从`Recycler`获取一个`ViewHolder`

`LayoutManager`通过调用`Recycler.getViewForPosition(pos)`获取`pos`位置上的`view`。

```java
        public View getViewForPosition(int position) {
            return getViewForPosition(position, false);
        }

        View getViewForPosition(int position, boolean dryRun) {
            return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;
        }
        //复用机制的主要方实现
				ViewHolder tryGetViewHolderForPositionByDeadline(int position,
                boolean dryRun, long deadlineNs) {
            //判断位置是否正常
            if (position < 0 || position >= mState.getItemCount()) {
                throw new IndexOutOfBoundsException("Invalid item position " + position
                        + "(" + position + "). Item count:" + mState.getItemCount());
            }
            boolean fromScrapOrHiddenOrCache = false;
            ViewHolder holder = null;
            // 是否设置动画
            if (mState.isPreLayout()) {
                holder = getChangedScrapViewForPosition(position);
                fromScrapOrHiddenOrCache = holder != null;
            }

            if (holder == null) {
                //从 mAttcherScrap 或者 mCachedViews 获取holder
                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);①
                if (holder != null) {
                    //判定ViewHolder是否有效
                    if (!validateViewHolderForOffsetPosition(holder)) {②
                        // recycle holder (and unscrap if relevant) since it can't be used
                        if (!dryRun) {
                            //设置回收标记
                            holder.addFlags(ViewHolder.FLAG_INVALID);
                            if (holder.isScrap()) {
                                removeDetachedView(holder.itemView, false);
                                holder.unScrap();
                            } else if (holder.wasReturnedFromScrap()) {
                                holder.clearReturnedFromScrapFlag();
                            }
                            recycleViewHolderInternal(holder);
                        }
                        holder = null;
                    } else {
                        fromScrapOrHiddenOrCache = true;
                    }
                }
            }
            
            if (holder == null) {
                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
                if (offsetPosition < 0 || offsetPosition >= mAdapter.getItemCount()) {
                    throw new IndexOutOfBoundsException("Inconsistency detected. Invalid item "
                            + "position " + position + "(offset:" + offsetPosition + ")."
                            + "state:" + mState.getItemCount());
                }
                //获取item设置的type
                final int type = mAdapter.getItemViewType(offsetPosition);
                // stable id 就是标识一个viewholder的唯一性
                if (mAdapter.hasStableIds()) {
                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),③
                            type, dryRun);
                    if (holder != null) {
                        // update position
                        holder.mPosition = offsetPosition;
                        fromScrapOrHiddenOrCache = true;
                    }
                }
                //从用户自己设置的 mViewCacheExtension 去寻找对应ViewHolder·
                if (holder == null && mViewCacheExtension != null) {
                    // We are NOT sending the offsetPosition because LayoutManager does not
                    // know it.
                    final View view = mViewCacheExtension
                            .getViewForPositionAndType(this, position, type);
                    if (view != null) {
                        //包装成一个ViewHolder
                        holder = getChildViewHolder(view);
                        if (holder == null) {
                            throw new IllegalArgumentException("getViewForPositionAndType returned"
                                    + " a view which does not have a ViewHolder");
                        } else if (holder.shouldIgnore()) {
                            throw new IllegalArgumentException("getViewForPositionAndType returned"
                                    + " a view that is ignored. You must call stopIgnoring before"
                                    + " returning this view.");
                        }
                    }
                }
                //从 RecyclerViewPool去寻找对应的ViewHolder
                if (holder == null) { // fallback to pool
                    if (DEBUG) {
                        Log.d(TAG, "tryGetViewHolderForPositionByDeadline("
                                + position + ") fetching from shared pool");
                    }
                    holder = getRecycledViewPool().getRecycledView(type);④
                    if (holder != null) {
                        holder.resetInternal();⑤
                        if (FORCE_INVALIDATE_DISPLAY_LIST) {
                            invalidateDisplayListInt(holder);
                        }
                    }
                }
                //从以上三级缓存中都没有找到对应的ViewHolder就只能自己创建了
                if (holder == null) {
                    long start = getNanoTime();
                    if (deadlineNs != FOREVER_NS
                            && !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) {
                        // abort - we have a deadline we can't meet
                        return null;
                    }
                    //创建对应的ViewHolder
                    holder = mAdapter.createViewHolder(RecyclerView.this, type);
                    if (ALLOW_THREAD_GAP_WORK) {
                        // only bother finding nested RV if prefetching
                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);
                        if (innerView != null) {
                            holder.mNestedRecyclerView = new WeakReference<>(innerView);
                        }
                    }

                    long end = getNanoTime();
                    mRecyclerPool.factorInCreateTime(type, end - start);
                    if (DEBUG) {
                        Log.d(TAG, "tryGetViewHolderForPositionByDeadline created new ViewHolder");
                    }
                }
            }

            // This is very ugly but the only place we can grab this information
            // before the View is rebound and returned to the LayoutManager for post layout ops.
            // We don't need this in pre-layout since the VH is not updated by the LM.
            if (fromScrapOrHiddenOrCache && !mState.isPreLayout() && holder
                    .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) {
                holder.setFlags(0, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
                if (mState.mRunSimpleAnimations) {
                    int changeFlags = ItemAnimator
                            .buildAdapterChangeFlagsForAnimations(holder);
                    changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;
                    final ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState,
                            holder, changeFlags, holder.getUnmodifiedPayloads());
                    recordAnimationInfoIfBouncedHiddenView(holder, info);
                }
            }

            boolean bound = false;
            if (mState.isPreLayout() && holder.isBound()) {
                // do not update unless we absolutely have to.
                holder.mPreLayoutPosition = position;
            } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
                if (DEBUG && holder.isRemoved()) {
                    throw new IllegalStateException("Removed holder should be bound and it should"
                            + " come here only in pre-layout. Holder: " + holder);
                }
                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
            }
            //设置对应ViewHolder的 layoutparams
            final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();
            final LayoutParams rvLayoutParams;
            if (lp == null) {
                rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();
                holder.itemView.setLayoutParams(rvLayoutParams);
            } else if (!checkLayoutParams(lp)) {
                rvLayoutParams = (LayoutParams) generateLayoutParams(lp);
                holder.itemView.setLayoutParams(rvLayoutParams);
            } else {
                rvLayoutParams = (LayoutParams) lp;
            }
            rvLayoutParams.mViewHolder = holder;
            rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache && bound;
            return holder;
        }
```

①`getScrapOrHiddenOrCachedHolderForPosition()`：从`mAttchedScrap`或者`mCachedViews`去获取ViewHolder

```java
 ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) {  
   //先从 mAttachedScrap 获取对应的ViewHolder
   for (int i = 0; i < scrapCount; i++) {
                final ViewHolder holder = mAttachedScrap.get(i);
                if (!holder.wasReturnedFromScrap() && holder.getLayoutPosition() == position
                        && !holder.isInvalid() && (mState.mInPreLayout || !holder.isRemoved())) {
                    holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
                    return holder;
                }
            }
    //从隐藏的View中去寻找ViewHolder
    if (!dryRun) {
                View view = mChildHelper.findHiddenNonRemovedView(position);
                if (view != null) {
                    // This View is good to be used. We just need to unhide, detach and move to the
                    // scrap list.
                    final ViewHolder vh = getChildViewHolderInt(view);
                    mChildHelper.unhide(view);
                    int layoutIndex = mChildHelper.indexOfChild(view);
                    if (layoutIndex == RecyclerView.NO_POSITION) {
                        throw new IllegalStateException("layout index should not be -1 after "
                                + "unhiding a view:" + vh);
                    }
                    mChildHelper.detachViewFromParent(layoutIndex);
                    scrapView(view);
                    vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP
                            | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
                    return vh;
                }
            }
     //从mCachedViews去获取对应的ViewHolder
     final int cacheSize = mCachedViews.size();
            for (int i = 0; i < cacheSize; i++) {
                final ViewHolder holder = mCachedViews.get(i);
                // invalid view holders may be in cache if adapter has stable ids as they can be
                // retrieved via getScrapOrCachedViewForId
                if (!holder.isInvalid() && holder.getLayoutPosition() == position) {
                    if (!dryRun) {
                        mCachedViews.remove(i);
                    }
                    if (DEBUG) {
                        Log.d(TAG, "getScrapOrHiddenOrCachedHolderForPosition(" + position
                                + ") found match in cache: " + holder);
                    }
                    return holder;
                }
            }
 }
```

根据`position`从`mAttachedScrap -> hideView -> mCachedViews`的顺序向下获取。

**mCachedViews里面存放的都是已存在的ViewHolder，新位置的是没法获取的。**

②`validateViewHolderForOffsetPosition(holder)`：校验获取的ViewHolder是否有效

```java
        boolean validateViewHolderForOffsetPosition(ViewHolder holder) {
            // if it is a removed holder, nothing to verify since we cannot ask adapter anymore
            // if it is not removed, verify the type and id.
            if (holder.isRemoved()) {
                if (DEBUG && !mState.isPreLayout()) {
                    throw new IllegalStateException("should not receive a removed view unless it"
                            + " is pre layout");
                }
                return mState.isPreLayout();
            }
            if (holder.mPosition < 0 || holder.mPosition >= mAdapter.getItemCount()) {
                throw new IndexOutOfBoundsException("Inconsistency detected. Invalid view holder "
                        + "adapter position" + holder);
            }
            if (!mState.isPreLayout()) {
                // don't check type if it is pre-layout.
                final int type = mAdapter.getItemViewType(holder.mPosition);
                if (type != holder.getItemViewType()) {
                    return false;
                }
            }
            if (mAdapter.hasStableIds()) {
                return holder.getItemId() == mAdapter.getItemId(holder.mPosition);
            }
            return true;
        }
```

判断获取的ViewHolder存在和位置是否正确。

③`getScrapOrCachedViewForId()`：根据`position`获取对应的`itemId`然后获取ViewHolder

```java
ViewHolder getScrapOrCachedViewForId(long id, int type, boolean dryRun) {
            // Look in our attached views first
            final int count = mAttachedScrap.size();
            for (int i = count - 1; i >= 0; i--) {
                final ViewHolder holder = mAttachedScrap.get(i);
                if (holder.getItemId() == id && !holder.wasReturnedFromScrap()) {
                    if (type == holder.getItemViewType()) {
                        holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
                        if (holder.isRemoved()) {
                            if (!mState.isPreLayout()) {
                                holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE
                                        | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED);
                            }
                        }
                        return holder;
                    } else if (!dryRun) {
                        mAttachedScrap.remove(i);
                        removeDetachedView(holder.itemView, false);
                        quickRecycleScrapView(holder.itemView);
                    }
                }
            }
```

利用转化的`itemId`从`mAttachedScrap`获取对应的ViewHolder

④`getRecycledViewPool().getRecycledView()`：从`mRecyclerViewPool`去获取对应的ViewHolder

```java
        public ViewHolder getRecycledView(int viewType) {
            final ScrapData scrapData = mScrap.get(viewType);
            if (scrapData != null && !scrapData.mScrapHeap.isEmpty()) {
                final ArrayList<ViewHolder> scrapHeap = scrapData.mScrapHeap;
                return scrapHeap.remove(scrapHeap.size() - 1);
            }
            return null;
        }
```

存储时会根据不同的`itemType`进行存储，然后取对应ViewHolder时，就不像前面获取ViewHodler需要通过`position或itemId`完整的匹配，只要找到对应`ViewType`并有值，直接取出最后一个ViewHolder缓存进行复用即可。

⑤`holder.resetInternal()`：对从`mRecyclerViewPool`取出的ViewHolder重新进行设置，变成一个全新的ViewHolder

```java
        void resetInternal() {
            mFlags = 0;
            mPosition = NO_POSITION;
            mOldPosition = NO_POSITION;
            mItemId = NO_ID;
            mPreLayoutPosition = NO_POSITION;
            mIsRecyclableCount = 0;
            mShadowedHolder = null;
            mShadowingHolder = null;
            clearPayload();
            mWasImportantForAccessibilityBeforeHidden = View.IMPORTANT_FOR_ACCESSIBILITY_AUTO;
            mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET;
            clearNestedRecyclerViewIfNotNested(this);
        }
```

由于取出的ViewHolder进行了重新设置，所以后续就需要调用`bindViewHolder()`重新进行数据绑定



观察上述源码可知，复用机制简单分为以下几步：

- 从`mAttachedScrap`或`mCachedViews`(*一级缓存*)去获取可复用的ViewHolder
- 如果没有找到可复用的ViewHolder，就会从`mViewacheExtension`(*二级缓存*)去获取可复用的ViewHolder。`如果用户没有定义就跳过这一级。`
- 用户未定义货没有找到可复用的ViewHolder，就会从`mRecyclerPool`(*三级缓存*)去获取可复用的ViewHolder。**这时需要调用`onBindViewHolder()`**
- 从上面三步中都没有获取到，就只能自己调用`createViewHolder`(*四级缓存*)去重新创建一个ViewHolder以供使用，然后在调用`bindViewHolder()`绑定数据。最后调整`ViewHolder。itemView`的布局参数。
- 返回最终得到的ViewHolder。

{% fullimage /images/RecyclerView复用机制.png,RecyclerView复用机制,RecyclerView复用机制%}



#### 回收机制

> 由`Recycler`进行View的回收

```java
        public void recycleView(View view) {
            //传入对应的View 然后通过View获取ViewHolder
            ViewHolder holder = getChildViewHolderInt(view);
            //标记该View要移除
            if (holder.isTmpDetached()) {
                removeDetachedView(view, false);
            }
            //该ViewHolder来自缓存可见的数组
            if (holder.isScrap()) {
                //清除缓存
                holder.unScrap();
            } //holder来自缓存的不可见ViewHolder
            else if (holder.wasReturnedFromScrap()) {
                //清除缓存
                holder.clearReturnedFromScrapFlag();
            }
            //开始回收流程
            recycleViewHolderInternal(holder);
        }
```

回收流程的真正执行逻辑是在`recyclerViewHolderInternal()`

```java
        void recycleViewHolderInternal(ViewHolder holder) {
            ...
            //noinspection unchecked
            final boolean transientStatePreventsRecycling = holder
                    .doesTransientStatePreventRecycling();
            final boolean forceRecycle = mAdapter != null
                    && transientStatePreventsRecycling
                    && mAdapter.onFailedToRecycleView(holder);
            boolean cached = false;
            boolean recycled = false;
            if (DEBUG && mCachedViews.contains(holder)) {
                throw new IllegalArgumentException("cached view received recycle internal? "
                        + holder);
            }
            if (forceRecycle || holder.isRecyclable()) {
                //要求缓存数量>0，并且ViewHolder的标志是有效的额，且非REMOVED或UPDATE，进行缓存
                if (mViewCacheMax > 0 /*大小默认为2*/
                        && !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
                                | ViewHolder.FLAG_REMOVED
                                | ViewHolder.FLAG_UPDATE
                                | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {
                    // Retire oldest cached view
                    int cachedViewSize = mCachedViews.size();
                    //mCacheViews已经满了，就把最前面缓存的ViewHolder放到RecyclerViewPool中
                    if (cachedViewSize >= mViewCacheMax && cachedViewSize > 0) {
                        //移除 mCachedViews的第一条缓存数据
                        recycleCachedViewAt(0);①
                        cachedViewSize--;
                    }

                    int targetCacheIndex = cachedViewSize;
                    if (ALLOW_THREAD_GAP_WORK
                            && cachedViewSize > 0
                            && !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) {
                        // when adding the view, skip past most recently prefetched views
                        int cacheIndex = cachedViewSize - 1;
                        while (cacheIndex >= 0) {
                            int cachedPos = mCachedViews.get(cacheIndex).mPosition;
                            //缓存的时候不能覆盖最近经常使用的缓存 利用LFU算法 -- 最少使用策略
                            if (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) {
                                break;
                            }
                            cacheIndex--;
                        }
                        targetCacheIndex = cacheIndex + 1;
                    }
                    //将最新的ViewHolder缓存数据插入到mCacheViews中复用
                    mCachedViews.add(targetCacheIndex, holder);
                    cached = true;
                }
                //如果没有触发缓存的话 就放进RecyclerViewPool中
                if (!cached) {
                    addViewHolderToRecycledViewPool(holder, true);
                    recycled = true;
                }
            } else {
                // NOTE: A view can fail to be recycled when it is scrolled off while an animation
                // runs. In this case, the item is eventually recycled by
                // ItemAnimatorRestoreListener#onAnimationFinished.

                // TODO: consider cancelling an animation when an item is removed scrollBy,
                // to return it to the pool faster
                if (DEBUG) {
                    Log.d(TAG, "trying to recycle a non-recycleable holder. Hopefully, it will "
                            + "re-visit here. We are still removing it from animation lists");
                }
            }
            // even if the holder is not removed, we still call this method so that it is removed
            // from view holder lists.
            mViewInfoStore.removeViewHolder(holder);
            if (!cached && !recycled && transientStatePreventsRecycling) {
                holder.mOwnerRecyclerView = null;
            }
        }
```

①`recycleCachedViewAt(0)`：移除`mCachedViews`中的第一条数据并放入到`mRecyclerViewPool`中

```java
        void recycleCachedViewAt(int cachedViewIndex) {
            ViewHolder viewHolder = mCachedViews.get(cachedViewIndex);
            addViewHolderToRecycledViewPool(viewHolder, true);
            mCachedViews.remove(cachedViewIndex);
        }
```

`mRecyclerPool`是根据`itemType`进行缓存的，最大上限为5。

观察上述源码可知，回收机制步骤如下：**回收机制是发生在 RecyclerView滚动时进行的。**

- 在RecyclerView滑动时，会调用到`LayoutManager.scrollVerticalBy()`去处理，在`LayoutManager.fill()`中会去完成`复用以及回收ViewHolder`的功能，最终调用到`recyclerView()`开始回收工作
- 回收时，先判断`mCachedViews`是否已满，未满直接放入。如果`mCachedViews`已满，则取出第一个缓存的ViewHolder放入`RecyclerViewPool`中，然后放入新的ViewHolder进行缓存
- 如果因为`ViewHolder`设置了`REMOVED或UPDATED`标志，无法加入`mCacheViews`中，就直接放入到`mRecyclerPool`中。

{% fullimage /images/RecyclerView回收机制.png,RecyclerView回收机制,RecyclerView回收机制%}

#### 拓展

1.RecyclerView的操作场景主要有三种：

- *有无到有*：RecyclerView中没有任何数据，然后调用`setAdapter()`添加数据源后。RecyclerView添加了数据并显示。

  > `Recycler`在这时只是调用到`createViewHolder()`不会发生缓存事件。

- *在原有数据的情况下刷新*：做了下拉刷新操作，只对屏幕上可见的数据源进行替换。

  > 这时ViewHolder会被标记`FLAG_TMP_DETACHED`，然后这时的Viewolder就会被保存到`mAttachedScrap`中等待复用。

- *RecyclerView发生滑动*：RecyclerView发生了上下或者左右滑动操作。

2.RecyclerView滑动场景下的回收复用涉及到的结构有以下两个：`mCachedViews`和`mRecyclerPool`

  `mCachedViews`的优先级高于`mRecyclerPool`，回收时最新的ViewHolder先放入到`mCachedViews`中，没位置了就移除最旧的那个给新的腾地方，最旧的就放到`mRecyclerPool`中。

  复用时也是一样，先从`mCachedViews`去获取对应的ViewHolder，需要匹配`position`，就是需要位置对应才能进行复用。找不到就去`mRecyclerPool`中找，在`mRecyclerPool`中的ViewHolder都跟新的一样，需要重新绑定数据(*bindViewHolder()*)。还没有就要自己创建了(*createViewHolder()*)。

3.`mCachedViews`上限是2

## RecyclerView优化

- **数据处理与视图绑定分离**

  > `bindViewHolder()`是在主线程中进行的，如果里面发生了耗时操作，会影响滑动的流畅性。
  >
  > **`onBindViewHolder()`中应该只进行数据的`set`操作，不需要做其他判断。**

- **数据优化**

  > 1. 分页加载远端数据，对拉取的数据进行缓存，提高二次加载的速度
  > 2. 对于新增或删除数据通过`DiffUtil`，来进行局部数据刷新，而不是每次都去进行全量刷新。

- **布局优化**

  > 1. `减少过度绘制`：减少布局层级，可以考虑使用自定义View来减少层级，或者设置更合理的布局。
  > 2. `减少xml文件`：`inflate`时间：去解析xml都需要经过耗时的IO操作，可以利用代码直接生成对应的布局，利用`new View()`生成。
  > 3. `减少View对象的创建`：需要尽可能简化ItemView，对多ViewType能够共用的部分尽量设计成自定义View，减少View的构造和嵌套。

- **其他优化**

  > 1. 设置高度固定：如果Item高度固定的话，可以使用`RecyclerView.setHasFixedSize(true)`，避免调用`requestLayout()`
  >
  > 2. 共用`RecycledViewPool`：具有相关的Adapter，就可以调用`RecyclerView.setRecycledViewPool(pool)`共用同一个。
  >
  > 3. 加大RecyclerView的缓存：空间换时间
  >
  >    ```java
  >    recyclerView.setItemViewCacheSize(20);
  >    recyclerView.setDrawingCacheEnabled(true);
  >    recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);
  >    ```
  >
  > 4. 增加RecyclerView预留的额外空间：显示范围之外，增加额外的缓存空间。*默认为2。*
  >
  >    ```java
  >    new LinearLayoutManager(this) {
  >        @Override
  >        protected int getExtraLayoutSpace(RecyclerView.State state) {
  >            return size;
  >        }
  >    };
  >    ```
  >
  >    
  >
  > 5. 减少ItemView监听器的创建
  >
  >    > 不要对每个Item都去创建一个监听器，而是根据`android:id`设置不同的操作，共用一个监听器。
  >
  > 6. 优化滑动操作：设置`RecyclerView.addOnScrollListener()`在滑动过程中停止加载
  >
  > 7. 关闭默认动画效果：设置`((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false)`

## RecyclerView拓展

是否需要将ListView替换成RecyclerView?

> 从性能上看，RecyclerView并没有带来明显的提升。如果需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView。只是单纯用于展示数据的话，ListView实现更加简单。

## 内容引用

[基于场景解析RecyclerView的回收复用机制原理](https://www.cnblogs.com/dasusu/p/7746946.html)

[RecyclerView必知必会](https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA?)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>ListView简析</title>
    <url>/2019/01/04/ListView%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[


{% fullimage /images/ListView机制.png,ListView机制,ListView机制%}

## ListView定义

> 专门用于处理那种内容元素很多，手机屏幕无法展示出所有的内容的情况。可以使用列表的形式来展示内容，超出屏幕部分的内容只需要通过手指滑动就可以移到屏幕内了。

ListView相比RecyclerView，有一些优点：

- `addHeaderVew()`，`addFooterView()`添加头尾视图
- `android:divider`设置自定义分割线
- `setOnItemClickListener`设置点击事件

上述功能没有直接在RecyclerView直接提供，要自己实现。*如果只是简单的展示内容，使用ListView相对更简单。*

## ListView用法

- 创建Adapter：在ListView和数据源之间起到了一个桥梁的作用，ListView借用Adapter和数据去打交道。

  > 常见的Adapter有以下几类：
  >
  > - `BaseAdapter`：基础数据适配器。
  > - `SimpleAdapter`：简单适配器，系统自定义了一些方法。
  > - `ArrayAdapter`：数据和UI一对一。
  > - `SimpleCursorAdapter`：用于游标类型的数据源适配。

  一般都会去继承`BaseAdapter`自定义实现功能

  ```java
  public class ListViewAdapter extends BaseAdapter {
      Context context;
      List<String> data;
      LayoutInflater mInflater;
  
      public ListViewAdapter(Context _context, List<String> _data) {
          this.context = _context;
          this.data = _data;
          mInflater = LayoutInflater.from(context);
      }
  
      @Override
      public int getCount() {
          return data == null ? 0 : data.size();
      }
  
      @Override
      public Object getItem(int position) {
          return null;
      }
  
      @Override
      public long getItemId(int position) {
          return position;
      }
      
      //在其中完善 Item的创建以及数据绑定流程
      @Override
      public View getView(int position, View convertView, ViewGroup parent) {
          ViewHolder viewHolder;
          if (convertView == null) {
              convertView = mInflater.inflate(R.layout.item_demo, null);
              viewHolder = new ViewHolder();
              viewHolder.title = convertView.findViewById(R.id.title);
              convertView.setTag(viewHolder);
          } else {
              viewHolder = (ViewHolder) convertView.getTag();
          }
          viewHolder.title.setText(data.get(position));
          return convertView;
      }
  
      private class ViewHolder {
          TextView title;
      }
  }
  ```

- ListView绑定Adapter

  ```java
  listView.addHeaderView(headerView);
  listView.addFooterView(footerView);
  listView.setAdapter(new ListViewAdapter(Activity.this,datas));
  //设置ListView 的 item点击事件
  listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
              @Override
              public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                  
              }
          });
  ```

## ListView源码解析

### 缓存机制

> ListView是以`View`作为单位进行回收。`RecycleBin`是ListView缓存机制的实现类。

RecycleBin实现的是**二级缓存**。

- `View[] mActiveViews`：缓存屏幕上的View，在该缓存中的View不需要调用`getView()`
- `ArrayList<View>[] mScrapViews`：对应了每个`ItemType`，缓存由于滚动而消失的View，此处的View如果被复用，会以参数的形式传给`getView()`。



ListView通过调用`layoutChildren()`对子Item进行布局，一般发生在滑动时刻。

```java
protected void layoutChildren() {
  ...
    final int firstPosition = mFirstPosition;
    final RecycleBin recycleBin = mRecycler;
    //如果数据源发生了改变，就将所有的itemView都回收至scrapView
    if (dataChanged) {
        for (int i = 0; i < childCount; i++) {
            recycleBin.addScrapView(getChildAt(i), firstPosition+i);
        }
    } else {
        //没有发生改变 ，缓存至mActiveViews
        recycleBin.fillActiveViews(childCount, firstPosition);
    }
    //清空所有View 防止第二次layout过程产生一份重复数据
    detachAllViewsFromParent();
    //填充子Item
    switch (mLayoutMode) {
           case LAYOUT_SET_SELECTION:
                if (newSel != null) {
                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
                } else {
                    sel = fillFromMiddle(childrenTop, childrenBottom);
                }
                break;
           ...
    }
    //回收多余的ActiveView
    recycleBin.scrapActiveViews();
}
```

`layoutChildren()`调用`fillXX()`在不同位置填充item。其中的主要实现方法是`makeAndAddView()`实现填充View逻辑。

```java
    private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
            boolean selected) {
        if (!mDataChanged) {
            // 获取缓存在 mActiveViews中的view
            final View activeView = mRecycler.getActiveView(position);
            if (activeView != null) {
                //重新布局子View
                setupChild(activeView, position, y, flow, childrenLeft, selected, true);
                return activeView;
            }
        }

        //从 mCraspViews中去获取或者 重新生成一个View
        final View child = obtainView(position, mIsScrap);

        // This needs to be positioned and measured.
        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);

        return child;
    }
```

如果从`mActiveViews`中获取到了对应的View，就直接取出来，然后调用`setUpChild()`把子View重新attach到ListView上。

如果没有找到合适的View，就需要调用到`obtainView()`，重新执行`getView()`流程生成对应布局，影响加载效率。

```java
View obtainView(int position, boolean[] outMetadata) {
  ...
     //获取刚刚因为滑动而消失的View
     final View transientView = mRecycler.getTransientStateView(position);
        if (transientView != null) {
            final LayoutParams params = (LayoutParams) transientView.getLayoutParams();

            // If the view type hasn't changed, attempt to re-bind the data.
            if (params.viewType == mAdapter.getItemViewType(position)) {
                final View updatedView = mAdapter.getView(position, transientView, this);

                // If we failed to re-bind the data, scrap the obtained view.
                if (updatedView != transientView) {
                    setItemViewLayoutParams(updatedView, position);
                    mRecycler.addScrapView(updatedView, position);
                }
            }

            outMetadata[0] = true;

            // Finish the temporary detach started in addScrapView().
            transientView.dispatchFinishTemporaryDetach();
            return transientView;
        }
      
     //从RecycleBin获取可复用的View
     final View scrapView = mRecycler.getScrapView(position);
        //实质调用 我们自定义的getView事件 scrapView 对应的 就是 convertView ,如果为null ，就需要重新 inflate重新加载布局
        final View child = mAdapter.getView(position, scrapView, this);
        if (scrapView != null) {
            if (child != scrapView) {
                // 生成了一个新的View  要重新插入缓存中
                mRecycler.addScrapView(scrapView, position);
            } else if (child.isTemporarilyDetached()) {
                outMetadata[0] = true;

                // Finish the temporary detach started in addScrapView().
                child.dispatchFinishTemporaryDetach();
            }
        }
  ...
}
```

接下来介绍`getScrapView(position)`的实现，该方法通过`position`得到`ItemType`，然后根据`ItemType`从`mScrapViews`获取可复用的View，如果获取不到，则返回null，

```java
        View getScrapView(int position) {
            final int whichScrap = mAdapter.getItemViewType(position);
            if (whichScrap < 0) {
                return null;
            }
            if (mViewTypeCount == 1) {
                return retrieveFromScrap(mCurrentScrap, position);
            } else if (whichScrap < mScrapViews.length) {
                return retrieveFromScrap(mScrapViews[whichScrap], position);
            }
            return null;
        }

 private View retrieveFromScrap(ArrayList<View> scrapViews, int position) {
            final int size = scrapViews.size();
            if (size > 0) {
                // See if we still have a view for this position or ID.
                // Traverse backwards to find the most recently used scrap view
                for (int i = size - 1; i >= 0; i--) {
                    final View view = scrapViews.get(i);
                    final AbsListView.LayoutParams params =
                            (AbsListView.LayoutParams) view.getLayoutParams();

                    if (mAdapterHasStableIds) {
                        final long id = mAdapter.getItemId(position);
                        if (id == params.itemId) {
                            return scrapViews.remove(i);
                        }
                    } else if (params.scrappedFromPosition == position) {
                        final View scrap = scrapViews.remove(i);
                        clearScrapForRebind(scrap);
                        return scrap;
                    }
                }
                //取出缓存列表的最后一条数据进行复用
                final View scrap = scrapViews.remove(size - 1);
                clearScrapForRebind(scrap);
                return scrap;
            } else {
                return null;
            }
        }
```

得到需要显示的View后，再调用`setUpChild()`显示在界面上

```java
//fromActiveView  isAttachedToWindow为true

private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,
            boolean selected, boolean isAttachedToWindow/*这个View当前是否已显示*/) {
    ...
          if ((isAttachedToWindow && !p.forceAdd) || (p.recycledHeaderFooter
                && p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) {
            attachViewToParent(child, flowDown ? -1 : 0, p);

            if (isAttachedToWindow
                    && (((AbsListView.LayoutParams) child.getLayoutParams()).scrappedFromPosition)
                            != position) {
                child.jumpDrawablesToCurrentState();
            }
        } else {
            p.forceAdd = false;
            if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                p.recycledHeaderFooter = true;
            }
            addViewInLayout(child, flowDown ? -1 : 0, p, true);
            // add view in layout will reset the RTL properties. We have to re-resolve them
            child.resolveRtlPropertiesIfNeeded();
        }
    
}
```



观察上述源码可知，缓存机制简单分为以下几步：

- ListView滑动时，会调用到`layoutChildren()`对子View进行重新布局，如果数据源没有发生改变，需要把当前屏幕上存在的View缓存至`mActiveViews`中；发生了改变的话，就都缓存至`mScrapViews`中。
- 清除掉ListView的所有子View
- 开始进行数据填充，主要实现逻辑是`makeAndAddView()`。这里分为两部分：如果可以从`mActiveViews`获取到View，就直接插入该View；没有获取到合适的View，需要调用`obtainView()`从`mScrapViews`获取可复用的View，然后重新走加载布局(`getView()`)的流程。

{% fullimage /images/ListView缓存过程.png,ListView缓存过程,ListView缓存过程%}

## ListView优化

- `ConverView重用机制`：在`getView()`中使用`convertView`，就不需要每次都去inflate一个View出来，减少内存损耗。
- `ViewHolder`：使用ViewHolder，避免在`getView()`频繁调用使用`findViewById()`，节省内存
- `滑动时不载入图片`：给ListView设置`setOnScrollListener()`，在其中`onScrollStateChanged()`判断是否为滑动状态，是的话就停止加载图片。
- `getView()不执行耗时操作`：`getView()`是执行在主线程的，需要减少耗时操作。
- `设置scrollingCache和animateCache为false`：默认都是开启的，会消耗大量内存。
- `降低Item的层级`

## ListView拓展

### ListView局部刷新

> 平常用到ListView的时候，如果需要对单个Item进行刷新，我们就会调用到`notifyDataSetChanged()`去进行全量刷新，效率很低。

ListView局部刷新有3种方案可以实现：

1. 更新对应View内容

   > 通过`listView.getChildAt(pos)`拿到需要更新的item布局，然后通过`findViewById()`去找到对应的控件进行设置

   ```java
   private void updateItemView(ListView listView,int pos,Data data/*需要更新的内容*/){
     int firstVisiblePosition = listView.getFirstVisiblePosition();
     int lastVisiblePosition = listView.getLastVisiblePosition();
     
     if(pos>=firstVisiblePosition && pos<= lastVisiblePosition){
       View view = listView.getChildAt(pos-firstVisiblePosition);
       TextView textView= view.findViewById(R.id.textView);
       textView.setText(data.getXX());
     }
   }
   ```

2. 通过ViewHolder去设置

   > 通过Item找到对应ViewHolder，通过ViewHolder设置数据

   ```java
   private void updateItemView(ListView listView,int pos,Data data/*需要更新的内容*/){
     int firstVisiblePosition = listView.getFirstVisiblePosition();
     int lastVisiblePosition = listView.getLastVisiblePosition();
     
     if(pos>=firstVisiblePosition && pos<= lastVisiblePosition){
       View view = listView.getChildAt(pos-firstVisiblePosition);
       ViewHolder viewHolder = (ViewHolder)view.getTag();
       TextView textView= iewHolder.textView;
       textView.setText(data.getXX());
     }
   }
   ```

3. 再调用一次`getView()`

   > 调用Adapter的`getView()`，对内部的View进行刷新。*Google官方推荐做法。*

   ```java
   //外部对数据源进行变化，内部自动去更新
   private void updateItemView(ListView listView,int pos,Data data/*需要更新的内容*/){
     int firstVisiblePosition = listView.getFirstVisiblePosition();
     int lastVisiblePosition = listView.getLastVisiblePosition();
     
     if(pos>=firstVisiblePosition && pos<= lastVisiblePosition){
       View view = listView.getChildAt(pos-firstVisiblePosition);
       listViewAdapter.getView(pos,view,listView)
     }
   }
   ```

   

## 内容引用

[RecyclerView必知必会](https://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA?)

[Android ListView工作原理完全解析，带你从源码的角度彻底理解](https://blog.csdn.net/guolin_blog/article/details/44996879)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-线程相关</title>
    <url>/2018/12/21/Android-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[
<!--AsyncTask 内部实现-->

{% fullimage /images/Android中的线程.png,Android线程,Android线程%}

在Android中进程一般指代App，线程又分为

- 主线程：进程所拥有的线程，默认情况下一个进程只有一个线程，这个线程就是主线程。Android中对应UI线程
- 子线程：工作线程，除主线程以外的线程都是工作线程。Android中的子线程的作用是处理耗时任务，比如网络请求，IO操作。

## Thread

{% post_link Java多线程基础%}

## AsyncTask

> 轻量级的异步任务，可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程更新UI。

在Android中实现异步任务机制机制有两种方式：`Handler`和`AsyncTask`。

- Handler机制存在的问题：代码相对臃肿；多任务同时执行时不易控制线程。

AsyncTask的优点：创建异步任务更简单，直接继承它可以方便实现后台异步任务的执行科进度的回调更新UI，而无需编写任务线程和Handler实例就能完成相同的任务。

### AsyncTask的重要参数及方法

AsyncTask是抽象的泛型类

```java
public abstract class AsyncTask<Params,Progress,Result>{
  ...
}
```

三个泛型参数：

- `Params`：表示执行AsyncTask需要传入的参数，可用于在后台任务中使用
- `Progress`：后台执行任务的进度的类型
- `Result`：后台任务的返回结果的类型

不需要传递具体的参数，都可以用`void`代替。

五个核心方法：

- `onPreExecute()`：在主线程中执行，在异步任务执行之前调用，一般可以做一些初始化工作。
- `doInBackground(Params... params)`：在线程池中执行，可用于处理所有的耗时任务。可以通过调用`publishProgress()`来更新任务进度。
- `onProgrssUpdate(Progress... values)`：在主线程中执行，后台任务执行进度发生改变时调用此方法。
- `onPostExecute(Result result)`：在主线程中执行，在异步任务执行完毕并通过return语句返回时被调用。
- `onCancelled()`：在主线程中执行，当异步任务取消时被调用，可用于取消任务时的界面更新。

**不要直接调用上述方法，并且AsyncTask对象必须在主线程创建。一个AsyncTask对象只能执行一次，否则会报异常。**



### AsyncTask使用

实现一个下载文件的AsyncTask

```java
class DownloadTask extends AsyncTask<String, Integer, Boolean> {  
  
    @Override//初始化一个ProgressDialog  
    protected void onPreExecute() {  
        progressDialog.show();  
    }  
  
    @Override//具体的下载逻辑
    protected Boolean doInBackground(String... params) {  
        try {  
            while (true) {  
                int downloadPercent = doDownload(params[0]);  
                publishProgress(downloadPercent);  
                if (downloadPercent >= 100) {  
                    break;  
                }  
            }  
        } catch (Exception e) {  
            return false;  
        }  
        return true;  
    }  
  
    @Override//显示当前的下载进度
    protected void onProgressUpdate(Integer... values) {  
        progressDialog.setMessage("当前下载进度：" + values[0] + "%");  
    }  
  
    @Override//提示任务的执行结果  
    protected void onPostExecute(Boolean result) {  
        progressDialog.dismiss();  
        if (result) {  
            Toast.makeText(context, "下载成功", Toast.LENGTH_SHORT).show();  
        } else {  
            Toast.makeText(context, "下载失败", Toast.LENGTH_SHORT).show();  
        }  
    }  
}
```



```java
DownlaodTask task = new DownloadTask();
//任务启动
task.execute("downloadUrl")；
//任务取消
task.cancel(true);
```

`execute(Params... params)`：必须在主线程中调用，表示开始一个异步任务。**一个AsyncTask只能调用一次该方法**。

`cancel(boolean mayInterruptIfRunning)`：必须在主线程中调用，表示停止一个异步任务。`mayInterruptIfRunning`表示是否立即停止任务，true立即停止，false则等待执行完毕。

### AsyncTask工作原理

#### 新建AsyncTask实例

必须要先新建一个AsyncTask实例，后续才可以去执行启动或停止等操作。

```java
 public AsyncTask() {
        this((Looper) null);
    }

 public AsyncTask(@Nullable Looper callbackLooper) {
        mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()
            ? getMainHandler()
            : new Handler(callbackLooper);

        mWorker = new WorkerRunnable<Params, Result>() {
            public Result call() throws Exception {
                //表示当前任务已被调用
                mTaskInvoked.set(true);
                Result result = null;
                try {
                    //设置线程优先级为  后台线程
                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                    //开始调用后台任务执行
                    result = doInBackground(mParams);
                    Binder.flushPendingCommands();
                } catch (Throwable tr) {
                    //出错取消任务
                    mCancelled.set(true);
                    throw tr;
                } finally {
                    //发送任务执行结果
                    postResult(result);
                }
                return result;
            }
        };
        //实现了 Runnable 和Future接口，因此可以包装 Runnble和 Callable
        mFuture = new FutureTask<Result>(mWorker) {
            @Override
            protected void done() {
                try {
                    postResultIfNotInvoked(get());
                } catch (InterruptedException e) {
                    android.util.Log.w(LOG_TAG, e);
                } catch (ExecutionException e) {
                    throw new RuntimeException("An error occurred while executing doInBackground()",
                            e.getCause());
                } catch (CancellationException e) {
                    postResultIfNotInvoked(null);
                }
            }
        };
    }
    
    //一个Callable对象
    private static abstract class WorkerRunnable<Params, Result> implements Callable<Result> {
        Params[] mParams;
    }
```

新建实例过程中，只是初始化了两个变量`mWorker，mFuture`。

#### 启动AsyncTask

新建实例完成后，就要开始启动任务去执行。

```java
    //标记主线程执行
    @MainThread
    //启动异步任务
    public final AsyncTask<Params, Progress, Result> execute(Params... params) {
        return executeOnExecutor(sDefaultExecutor, params);
    }

    @MainThread
    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,
            Params... params) {
        //如果在任务执行或结束时 重复调用执行 会出错
        if (mStatus != Status.PENDING) {
            switch (mStatus) {
                case RUNNING:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task is already running.");
                case FINISHED:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task has already been executed "
                            + "(a task can be executed only once)");
            }
        }
        //标记运行状态
        mStatus = Status.RUNNING;
        //异步开始前的准备
        onPreExecute();

        mWorker.mParams = params;
        //开始执行任务
        exec.execute(mFuture);

        return this;
    }
 
```

`exec`是传递的一个数据，它指向一个串行线程池。

```java
   public static final Executor SERIAL_EXECUTOR = new SerialExecutor();    
    private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;
    //串行线程池
    private static class SerialExecutor implements Executor {
        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();
        Runnable mActive;

        public synchronized void execute(final Runnable r) {
            //FutureTask 插入 mTasks中
            mTasks.offer(new Runnable() {
                public void run() {
                    try {
                        r.run();
                    } finally {
                        scheduleNext();
                    }
                }
            });
            if (mActive == null) {
                scheduleNext();
            }
        }

        protected synchronized void scheduleNext() {
            if ((mActive = mTasks.poll()) != null) {
                THREAD_POOL_EXECUTOR.execute(mActive);
            }
        }
    }
```



```java
    private static class InternalHandler extends Handler {
        public InternalHandler(Looper looper) {
            super(looper);
        }

        @SuppressWarnings({"unchecked", "RawUseOfParameterizedType"})
        @Override
        public void handleMessage(Message msg) {
            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;
            switch (msg.what) {
                case MESSAGE_POST_RESULT:
                    // 通知任务结束 调用结束之后事件
                    result.mTask.finish(result.mData[0]);
                    break;
                case MESSAGE_POST_PROGRESS:
                    //通知进度更新
                    result.mTask.onProgressUpdate(result.mData);
                    break;
            }
        }
    }

```

**内部静态Handler**。负责将环境从线程池中切换到主线程；通过他来发送任务执行的进度以及执行结束等消息。

```java
    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); // CPU核数
    private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));// 核数为2 核心线程数为 2
    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;//核数为2 最大允许 5
    private static final int KEEP_ALIVE_SECONDS = 30;// 最多存活30s

    private static final ThreadFactory sThreadFactory = new ThreadFactory() {
        private final AtomicInteger mCount = new AtomicInteger(1);

        public Thread newThread(Runnable r) {
            return new Thread(r, "AsyncTask #" + mCount.getAndIncrement());
        }
    };

    private static final BlockingQueue<Runnable> sPoolWorkQueue =
            new LinkedBlockingQueue<Runnable>(128);

    /**
     * An {@link Executor} that can be used to execute tasks in parallel.
     */
    public static final Executor THREAD_POOL_EXECUTOR;

    static {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
                sPoolWorkQueue, sThreadFactory);
        threadPoolExecutor.allowCoreThreadTimeOut(true);
        THREAD_POOL_EXECUTOR = threadPoolExecutor;
    }

```

**真正执行异步任务的线程池。**



`AsyncTask`的任务都是串行执行的，如果需要并行执行，可以使用如下代码：

```java
task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,"");
```

还可以使用自己定义的线程池

```java

Executor exec = new ThreadPoolExecutor(15, 200, 10,
		TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
new DownloadTask().executeOnExecutor(exec);

```

## HandlerThread

> HandlerThread是一个线程类，它继承自Thread。
>
> 它比普通Thread多了**消息循环**效果。

```java
    @Override
    public void run() {
        mTid = Process.myTid();
        Looper.prepare();
        synchronized (this) {
            mLooper = Looper.myLooper();
            notifyAll();
        }
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        Looper.loop();
        mTid = -1;
    }
```

内部就已经实现了`Looper`，通过`Looper.prepare()`创建消息队列，通过`Looper.loop()`开启循环效果。

使用实例

```java
private HandlerThread myHandlerThread ;  
private Handler handler ;  
@Override  
protected void onCreate(Bundle savedInstanceState) {  
    super.onCreate(savedInstanceState);  
   setContentView(R.layout.activity_main);  
   //实例化HandlerThread
   myHandlerThread = new HandlerThread("myHandler") ;  
   //开启HandlerThread
   myHandlerThread.start();  
   //将Handler对象与HandlerThread线程绑定
   handler =new Handler(myHandlerThread.getLooper()){  
       @Override  
        publicvoid handleMessage(Message msg) {  
           super.handleMessage(msg);  
           // do something
        }  
    };  
   
   handler.sendEmptyMessage(1) ;  
   new Thread(new Runnable() {  
       @Override  
        publicvoid run() {  
           handler.sendEmptyMessage(2) ;  
        }  
    }).start();  
}  
@Override  
protected void onDestroy() {  
   super.onDestroy();  
   //终止HandlerThread运行
   myHandlerThread.quit() ;  //立马退出
  //myHandlerThread.quitSafely() //执行完毕后退出
}
```

主要用于在子线程中创建Handler时使用。

## IntentService

> 继承了Service并且是一个抽象类。
>
> IntentService可用于执行后台耗时任务，任务执行完毕后会自动停止，同时由于IntentService是服务的原因，优先级高于线程，更不容易被杀死。

#### 使用实例

```java
public class LocalIntentService extends Service{
  private static final String TAG = "LocalIntentService";
  
  public LocalIntentService(){
    super(TAG);
  }
  
  @Override
  protected void onHandleIntent(Intent intent){
    String action = intent.getExtras().getString("action");
    switch(action){
      case "action1":
        Log.i(TAG,"action1");
        break;
      default:
        break;
    }
  }
  
  @Override
  public void onCreate(){
    Log.i(TAG,"onCreate");
    super.onCreate();
  }
  
  @Override
  public void onStartCommand(Intent intent, int flags, int startId){
    Log.i(TAG,"onStartCommand");
    return super.onStartCommand(intent, flags, startId);
  }
  
  @Override
  public void onDestroy(){
    Log.i(TAG,"onDestroy");
    super.onDestroy();
  }
}
```

在AndroidManifest.xml 中注册

```java
<service android:name=".LocalIntentService">
            <intent-filter >
                <action android:name="com.wxy.service"/>
            </intent-filter>
        </service>
```

在Activity中使用

```java
Intent i = new Intent("com.wxy.service");
Bundle bundle = new Bundle();
bundle.putString("action","action1");
i.putExtras(bundle);
startService(i);
```

#### 源码分析

从IntentService启动开始

```java
 @Override
    public void onCreate() {

        super.onCreate();
        //利用HandlerThread创建线程并启动
        HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");
        thread.start();
      
        mServiceLooper = thread.getLooper();
        //handler与handlerThread创建的Looper进行绑定
        mServiceHandler = new ServiceHandler(mServiceLooper);
    }

    private final class ServiceHandler extends Handler {
        public ServiceHandler(Looper looper) {
            super(looper);
        }

        @Override
        public void handleMessage(Message msg) {
            //获取的消息 交由 onHandleIntent 进行处理
            onHandleIntent((Intent)msg.obj);
            //消息处理完毕后 关闭Service
            stopSelf(msg.arg1);
        }
    }

    @WorkerThread
    protected abstract void onHandleIntent(@Nullable Intent intent);
```

上述源码完成了一次工作线程的创建。

```java

    @Override
    public void onStart(@Nullable Intent intent, int startId) {
        Message msg = mServiceHandler.obtainMessage();
        msg.arg1 = startId;
        msg.obj = intent;
        //把请求发送至消息队列中
        mServiceHandler.sendMessage(msg);
    }

    /**
     * You should not override this method for your IntentService. Instead,
     * override {@link #onHandleIntent}, which the system calls when the IntentService
     * receives a start request.
     * @see android.app.Service#onStartCommand
     */
    @Override
    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
        onStart(intent, startId);
        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;
    }

    @Override
    public void onDestroy() {
        //退出循环 并清空消息
        mServiceLooper.quit();
    }
```

通过`onStartCommand()`将消息(`intent`)依次插入到消息队列中。

从源码中我们可以得知以下要点：

1. **工作任务是顺序执行的**

   由于每执行一个后台任务都必须去启动一次IntentSercvice，每启动一次都会想IntentService中的消息队列插入消息，也就只能按照顺序去执行后台任务。

2. **不建议通过`bindService()`启动IntentService**

   `bindService()`启动的Service不会触发`onStart()/onStartCommand()`执行，所以无法将消息插入到队列中，自然也无法执行任务。

{% fullimage /images/IntentService执行流程.png,IntentService执行流程,IntentService执行流程 %}]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--CopyOnWriteArrayList实现原理及简析</title>
    <url>/2019/01/18/Java-CopyOnWriteArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
{% fullimage /images/CopyOnWriteArrayList简析.png,CopyOnWriteArrayList简析,CopyOnWriteArrayList简析%}

## CopyOnWriteArrayList定义

> ArrayList本身不是线程安全的，在读线程读取ArrayList的数据时，此时在去写入数据，就会触发`fast-fail`机制，抛出`ConcurrentModificationException`异常。也可以使用`Vector`去代替`ArrayList`使用，或者使用`Collections.synchronizeList()`包裹ArrayList。但他们都是使用`synchronized`进行修饰，执行效率不高。
>
> 针对运行效率情况，有了`CopyOnWriteArrayList`。
>
> 适用场景：**读多写少**。

## CopyOnWrite容器

`CopyOnWrite`容器即`写时复制`的容器。*当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行copy，复制出一个新的容器，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新的容器。*

对`CopyOnWrite容器`进行并发读的时候，不需要加锁，因为当前容器不会添加任何元素。所以`CopyOnWrite容器`也是一种**读写分离**的思想，读和写采用不同的容器。*放弃了数据实时性。*



## CopyOnWriteArrayList源码解析

### 重要参数分析

```java
    //利用Lock实现读写分离
    final transient ReentrantLock lock = new ReentrantLock();

    //设置初始化数组引用
    private transient volatile Object[] array;
```

### 初始化

```java
    public CopyOnWriteArrayList() {
        //设置空数组
        setArray(new Object[0]);
    }    

    public CopyOnWriteArrayList(E[] toCopyIn) {
        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
    }

    public CopyOnWriteArrayList(Collection<? extends E> c) {
        Object[] elements;
        if (c.getClass() == CopyOnWriteArrayList.class)
            elements = ((CopyOnWriteArrayList<?>)c).getArray();
        else {
            elements = c.toArray();
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elements.getClass() != Object[].class)
                elements = Arrays.copyOf(elements, elements.length, Object[].class);
        }
        setArray(elements);
    }

```

### 插入数据 - add(E e)

```java
 public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        //锁住写线程，保证同一时刻只有一个线程可以操作
        lock.lock();
        try {
            //获取旧数组引用
            Object[] elements = getArray();
            int len = elements.length;
            //复制旧数组数据到新数组中
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            //添加新的数据
            newElements[len] = e;
            //设置新数据的引用到旧数组上
            setArray(newElements);
            return true;
        } finally {
            //操作完成 解锁
            lock.unlock();
        }
    }
```

1. 采用`ReentrantLock`，保证同一时刻只有一个线程正在进行数组的复制，否则的话内存中会有多份被复制的数据。
2. `volatile`修饰的数组引用，在调用`setArray()`时，线程对数组引用的修改是对其他线程可见的。
3. 插入数据时插到新的数组中的，可以保证读和写操作在两个数组中执行，不会影响数据。

**和ArrayList相比，效率比较低，每次插入一个数组 都需要进行数组复制操作，随着元素的增加，修改代价会越来越大。**

### 获取数据 - get(int index)

```java
public E get(int index) {
  //获取index对应数据
  return get(getArray(), index);
}

private E get(Object[] a, int index) {
  return (E) a[index];
}
```

`get()`没有添加线程安全控制，也没有加锁。因为**get()操作的是旧数组，也不会发生修改操作。**

### 移除数据 - remove(int index)

```java
    public E remove(int index) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            E oldValue = get(elements, index);
            int numMoved = len - index - 1;
            if (numMoved == 0)
                //移除了最后一位 只要复制前面的数据即可
                setArray(Arrays.copyOf(elements, len - 1));
            else {
                //生成一个新数组
                Object[] newElements = new Object[len - 1];
                System.arraycopy(elements, 0, newElements, 0, index);
                System.arraycopy(elements, index + 1, newElements, index,
                                 numMoved);
                setArray(newElements);
            }
            return oldValue;
        } finally {
            lock.unlock();
        }
    }
```

## 拓展

#### CopyOnWriteArrayList的缺点

- **内存占用问题**：在进行写操作时，内存里会有两份数组对象的内存，旧对象和新写入的对象。*可以通过压缩容器中元素的方法来减少大对象的内存消耗。*

- **数据一致性问题**：只能保证最终数据的一致性，不能保证实时一致性。

  [^什么可以用]: 可以保证实时一致性的ArrayList

]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>static关键字分析</title>
    <url>/2019/02/25/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
<!--涉及到内部类、静态内部类-->

{% fullimage /images/static关键字.png,static关键字,static关键字%}

> 一种表示**静态属性**的修饰符。用于**为特定区域分配单一存储空间，不考虑要创建多少对象或者说根本就不创建任何对象**，再就是**想在没有创建对象的情况下也去调用方法**。

## static关键字作用

- 用来修饰类的成员
  - 修饰成员变量——`静态变量`
  - 修饰成员方法——`静态方法`
- 当类被加载时，会优先被加载
- 用来修饰代码块——`静态代码块`，先于类的构造方法之前执行且只会执行一次。用来对静态成员做初始化
- 静态修饰的成员被所有的对象共享
- 调用静态方法或对象时，可以直接通过`类名.成员方法/变量`来进行访问

> 能实现上述作用的原理在于：
>
> 1. 代码都是在编译时 由系统分配内存
> 2. 静态变量编译时，所分配的内存会一直存在，直到程序退出时才会被释放
> 3. 类加载时，静态变量会被放到**方法区**中，被所有的对象实例共用

## static关键字用法

### 修饰类——静态类

> *静态类又名`静态内部类`。*该类独立存在，形式上与外部类有内外关系，实际上没有任何关联，本质是为了 **隐藏自身**。可不依赖外部类进行实例化，只能访问外部类的静态成员变量及成员方法。
>
> `内部类`：定义在类中的另外一个类。隐藏在外部类中且封装性更强，不允许除外部类外的其他类对其进行访问。但可以直接访问到外部类的成员。
>
> `成员内部类`：可以直接使用外部类的所有成员和方法，即时是`private`修饰的。
>
> `局部内部类`：内部类定义在方法内，只能在该方法或条件的作用域才能使用，退出这作用域就无法引用。
>
> `匿名内部类`：只能使用一次，通过用来简化代码编写，还有个前提条件：**必须继承一个父类或实现一个接口。**

```java
public class A{
    //静态内部类
    public static class B{
        
    }
    //普通内部类
    public class C{
        
    }
}
```



### 修饰代码块——静态代码块

> 静态代码块用于初始化一个类的时候做操作用的，和静态变量、静态方法一样会随着类的加载一块执行，而且可以随意摆放位置。对应类加载过程的最后一步：*类初始化(执行`<clinit>`方法)*。

```java
public class Test{
    static int i = 1;
    static {
        //最终得到 为0
        i = 0;
    }
}
```

若存在多个 static代码块，JVM按照他们出现的先后顺序依次执行。**静态代码块只能访问定义在它之前的变量，定义在其后的是不能访问的。**

### 修饰方法——静态方法

> 使用`static`修饰成员方法。通过`ClassName.methodName()`直接访问，由于它在类加载时就存在了，不依赖于任何实例。

```java
public class Test{
    //静态方法
    public static void main(String[] args){
        
    }
}
```

只能访问所属类的静态成员变量和静态方法，不能使用this、super关键字

### 修饰变量——静态变量

> 使用`static`修饰变量。通过`ClassName.propertyName`直接访问静态变量。
>
> 静态变量是 **随着类加载时完成初始化的，在内存中仅有一份，且只分配一次内存**。同时被所有的实例共享静态变量。
>
> `实例变量`：每创建一个实例，JVM就会为实例变量分配一次内存，它与创建它的实例同生共死。

```java
public class Test{
    private static int a = 0;//静态变量
}

可通过Test.a直接访问
```

一般在这两种情况下使用`静态变量`：**对象之间共享数据以及访问数据。**

## static关键字注意事项

- 静态方法不能被覆盖，方法覆盖是动态绑定的，静态方法时在编译时静态绑定的。
- 在静态方法、静态类中无法访问非static变量、方法
- 静态方法可以引用静态的变量或方法，由于 **静态的这些都是在类加载时就加载好，都是可以互相调用到的。*
- 非静态方法中也可以引用静态的变量或方法。

## static关键字使用实例

### 单例模式

```java
public class Singleton{
    private static class SingletonHolder{
        private static final Singletion INSTANCE = new Singleton();
    }
    
    private Singleton(){
        
    }
    
    public static Singleton getInstance(){
        return SingletonHolder.INSTANCE;
    }
}
```

> 为何可以保证线程安全？`虚拟机可以保证一个类的类构造器`<clinit>()`在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。**同一个类加载器下，一个类型只会被初始化一次。**

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>RxJava 使用及解析</title>
    <url>/2019/01/10/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[
<!--dispose做了啥 flatMap和Map有什么区别 如何进行线程切换-->

## RxJava基本知识

> RxJava是一个在JVM上使用可观测的序列来组成异步的、基于事件的程序的库。

通常情况下使用`Handler、AsyncTask`完成异步任务操作，当任务比较多的时候，使用这种方式就会变得相当繁琐，尤其是嵌套式的执行任务(需要上一项先完成)。

RxJava可以实现异步任务执行的前提下保持代码的清晰。通过创建一个`Observable`来完成异步任务，然后组合各种操作符实现不同的链式操作，最终将任务直执行结果发射到`Observer`进行处理。

{% fullimage /images/RxJava基础流程图.png,RxJava基础流程图,RxJava基础流程%}

### 简单示例

```java
 Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {
            @Override
            public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {
                emitter.onNext(1);
                emitter.onNext(2);
                emitter.onComplete();
            }
        });
        observable.subscribe(new Observer<Integer>() {
            @Override
            public void onSubscribe(Disposable d) {
                System.err.println("onSubscribe");
            }

            @Override
            public void onNext(Integer integer) {
                System.out.println("onNext()"+integer);
            }

            @Override
            public void onError(Throwable e) {
                System.err.println("onError");
            }

            @Override
            public void onComplete() {
                System.err.println("onComplete");
            }
        });

输出结果：
onSubscribe
onNext1
onNext2
onComplete
```

`Observable`发射出一个事件，通过`subscribe()`建立与`Observer`的关联，然后回调到具体事件内(`onNext()、onError()、onComplete()`)。

除了`Observable`外，还提供了适用其他场景的基础类：

- `Flowable`：多个流，响应式流和背压

- `Single`：只能发射一条单一的数据，或者一条异常通知，无法发射完成通知。*数据与通知只能发射一个。*

  ```java
    Single<Integer> single = Single.create(new SingleOnSubscribe<Integer>() {
            @Override
            public void subscribe(SingleEmitter<Integer> singleEmitter) throws Exception {
                //发射数据
                singleEmitter.onSuccess(111);
                //发射异常通知
                singleEmitter.onError(new IllegalArgumentException("qwe"));
            }
        });
        single.subscribe(new SingleObserver<Integer>() {
            @Override
            public void onSubscribe(Disposable disposable) {
  
            }
  
            @Override
            public void onSuccess(Integer integer) {
  
            }
  
            @Override
            public void onError(Throwable throwable) {
  
            }
        });
  ```

  

- `Completeable`：只发射一条完成通知，或者一条异常通知，不能发射数据。*完成通知与异常通知只能发射一个。*

  ```java
   Completable completable = Completable.create(new CompletableOnSubscribe() {
           @Override
           public void subscribe(CompletableEmitter completableEmitter) throws Exception {
               //发射完成通知
               completableEmitter.onComplete();
               //发射错误通知
               completableEmitter.onError(new IllegalArgumentException("qwe"));
           }
       });
       completable.subscribe(new CompletableObserver() {
           @Override
           public void onSubscribe(Disposable disposable) {
               
           }
  
           @Override
           public void onComplete() {
  
           }
  
           @Override
           public void onError(Throwable throwable) {
  
           }
       });
  ```

  

- `Maybe`：可发射一条单一的数据，以及一条完成通知，或者一条异常通知.*完成通知和异常通知只能发射一个，且发射数据必须在发射通知之前。*

  ```
  Maybe<Integer> maybe = Maybe.create(new MaybeOnSubscribe<Integer>() {
      @Override
      public void subscribe(MaybeEmitter<Integer> maybeEmitter) throws Exception {
          //发射数据
          maybeEmitter.onSuccess(11);
          //发射完成通知
          maybeEmitter.onComplete();
          //发射错误通知
          maybeEmitter.onError(new IllegalArgumentException("qwe"));
      }
  });
  maybe.subscribe(new MaybeObserver<Integer>() {
      @Override
      public void onSubscribe(Disposable disposable) {
          
      }
  
      @Override
      public void onSuccess(Integer integer) {
  
      }
  
      @Override
      public void onError(Throwable throwable) {
  
      }
  
      @Override
      public void onComplete() {
  
      }
  });
  ```

### 事件类型

`Observable`是通过`ObservableEmitter`来发射事件的，可以发出的事件类型有三种：`onNext()、onError()，onComplete()`。

#### onNext()

> 对应`Observer.onNext()`，用于发射数据

#### onComplete()

> 对应`Observer.onComplete()`，用于发射完成通知

#### onError()

> 对应`Observer.onError()`，用于发射异常通知

他们三者之间满足一定的规则：

- `ObservableEmitter`可以发射无数的`onNext()`事件，`Observer`也可以处理无数`onNext()`事件
- 当`ObservableEmitter`发射出`onComplete()`事件，`Observer`接收到这个事件后，**不会再继续接收后续事件**。
- 当`ObservableEmitter`发射出`onError()`事件，`Observer`接收到这个事件后，**不会再继续接收后续事件**。
- `onComplete()`与`onError()`是**唯一且互斥**的。不能发射分多个`onComplete()`或`onError()`，也不能发射`onComplete()`后再跟上`onError()`。

### 取消订阅

通过`Disposable`实现，在`Observer`的`onSubsccribe()`中返回对象，他有两个方法`isDisposed()`——判断是否停止了观察指定的流，`dispose()`——放弃观察指定的流。

执行`Disposeable.dispose()`后，并不会影响`ObservableEmitter`继续发送事件，但是`Observer`中不会继续接收事件，相当于切断了两者的联系。

## RxJava操作符

如上节示例所示，通过`Observable.create()`就可以创建出一个`Observable`对象，除了`create`外，还有其他的操作符方便我们完成链式操作，下面详解介绍这些操作符。

### 创建操作符

> 用于创建Observable对象，并填充数据

#### create

> 用于从头到尾创建一个Observable对象，发射器内部会调用`onNext()、onComplete()，onError()`方法

```java
public static <T> Observable<T> create(ObservableOnSubscribe<T> source) 
  
 Observable<Integer> observable = Observable.create(new ObservableOnSubscribe<Integer>() {
          @Override
          public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {
              emitter.onNext(1);
              emitter.onNext(2);
              emitter.onComplete();
          }
      });
```

*不推荐使用，使用较为繁琐且不方便操作。*

#### from系列

> 从指定的数据源中获取一个Observable对象

- `fromArray(T... items)`：从数组中获取
- `fromCallable(Callable<? extends T> supplier)`：从Callable对象中获取
- `fromFuture(Future<? extends T> future)`：从Future对象中获取
- `fromIterable(Iterable<? extends T> source)`：从Iterable中获取
- `formPublisher(Publisher<? extends T> publisher)`：从Publisher中获取

```java
Observable<Integer> observable = Observable.fromArray(1,2,3,4);
```

#### just

> 支持发送不同格式的参数，个数从1~10个

```java
public static <T> Observable<T> just(T item) 
 
Observable<Integer> observable = Observable.just(1,2);
```

#### interval&intervalRange

> 每隔指定时间就发射一个Observable对象

`interval`

```java
/**
* initialDelay 发射第一个对象之前的停顿时间
* period 表示每个发射之间停顿多少时间
* unit 时间单位
* scheduler 指定数据发射的线程
*/
public static Observable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler)
其他重载方法：
public static Observable<Long> interval(long initialDelay, long period, TimeUnit unit)
public static Observable<Long> interval(long period, TimeUnit unit)  
   
Observable observable = Observable.interval(1, TimeUnit.SECONDS);
```

`intervalRange`：控制发射的序列在一个范围之内，发射最后一位时停止

```java
/**
* start 发射数据的起始值
* count 需要发射的总个数，且为递增
*/
public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler)
  
Observable<Long> observable =Observable.intervalRange(1,10,1,1, TimeUnit.SECONDS, Schedulers.trampoline());
```

#### range&rangeLong

> 发射指定范围内的连续整数的Observable对象

```java
/**
* start 指定生成序列的开始值
* count 指定生成序列包含的个数
*/
public static Observable<Integer> range(final int start, final int count)
Observable<Integer> observable = Observable.range(1,5);

public static Observable<Long> rangeLong(long start, long count) 
Observable<Long> observable = Observable.range(1,5);  
```

`range`与`rangeLong`的区别在于：前者返回int，后者返回long

#### defer

> 直到有观察者订阅是才创建的`Observable`对象，并未每一个订阅者都创建一个新的`Observable`对象。

```java
public static <T> Observable<T> defer(Callable<? extends ObservableSource<? extends T>> supplier) 
  
Observable<Long> deferObservable = Observable.defer(() -> Observable.just(11L));
```

**可以使用`defer`封装需要被多次执行的函数**

#### empty & never & error

`empty`：创建一个不发射任何数据但是能正常终止的`Observable`对象

```java
public static <T> Observable<T> empty()
  
Observable<Integer> observable = Observable.empty();
```

`error`：创建一个不发射任何数据但是能发出错误的`Observable`对象

```java
public static <T> Observable<T> error(Callable<? extends Throwable> errorSupplier)
  
Observable<Integer> observable = Observable.error(new IllegalArgumentException("qwe"));
```

`never`：创建一个不发射任何数据也不能终止的`Observable`对象

```java
public static <T> Observable<T> never()
  
Observable<Integer> observable = Observable.never()
```

#### repeat&repeatWhen

> 并不是创建一个`Observable`对象，而是重复发射原始的`Observable`数据序列，可能是无限的，如果设置`repeat(n)`可以限制重复次数

```java
//不限次数 
public final Observable<T> repeat()
//限制发射 times 次   
public final Observable<T> repeat(long times)
  
Observable<Integer> observable = Observable.just(1).repeat(3);
```

`repeatWhen`：重复执行同一操作

```java
public final Observable<T> repeatWhen(final Function<? super Observable<Object>, ? extends ObservableSource<?>> handler)

Observable<Long> observable = Observable.just(1L).repeatWhen(objectObservable -> Observable.just(1).repeat(3));

```

#### timer

> 创建一个在制定延迟时间后发射一条数据的`Observable`对象

```java
/**
* delay 设置延时时长
*/
public static Observable<Long> timer(long delay, TimeUnit unit) 
  
Observable<Long> observable = Observable.timer(3,TimeUnit.SECOND);
```

### 变换操作符

#### map

> 将发射的原始`Observable`对象转成一个新的`Observable`对象。

```java
/**
* 泛型T 指代原始数据类型
* 泛型R 指代要转换的数据类型
*/
public final <R> Observable<R> map(Function<? super T, ? extends R> mapper) 

Observable<String> observable = Observable.just(1L)/*这时发射出的是Long型*/.map(aLong -> aLong.toString()/*转化为String型*/);
```

*在定义的`Function()`中进行数据类型转换*

#### flatMap

> 将一个发送事件的原始`Observable`变换为多个发送事件的`Observables`，然后把这些合并到一个单独的`Observable`里。**`flatMap`并不保证事件的顺序，实现的是一对多的转化**

```java
public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper) 

Observable<String> observable = Observable.just(1L,2L,3L,4L,5L)
              .flatMap((Function<Long, ObservableSource<String>>) aLong -> 
                      Observable.just("flatMap"+aLong.toString()));
```

#### concatMap

> 将一个发送事件的原始`Observable`变换为多个发送事件的`Observables`，然后把这些合并到一个单独的`Observable`里。**concatMap可以保证事件的顺序，实现的是一对多的转化**

```java
 public final <R> Observable<R> concatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int prefetch)
   
Observable<String> observable = Observable.just(1L,2L,3L,4L,5L)
              .concatMap((Function<Long, ObservableSource<String>>) aLong -> 
                      Observable.just("flatMap"+aLong.toString()));
```

在使用`concatMap`的时候，内部会新建一个队列对象，会把先发射的数据放入队列中，内部是利用了`AtomicInteger`实现自增，然后输出数据的时候就可以按照顺序。

#### cast

> 将原始的`Observable`对象中的所有数据都强制转换为一个指定的类型(**多态，只能由父类对象转为子类对象**)，然后发射数据

```java
public final <U> Observable<U> cast(final Class<U> clazz) 
  
Observable<String> observable = Observable.just(1L).cast(String.class);
//这样子的转换方式就会抛出异常
```

#### flatMapIterable

> 将原始的任意一个元素转换成一个`Iterable`对象，直接在内部以`Iterable`接口接收数据。

```java
public final <U> Observable<U> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper)

Observable<String> observable = Observable.just(1L,2L,3L,4L,5L)
          .flatMapIterable(new Function<Long, Iterable<? extends String>>() {
              @Override
              public Iterable<? extends String> apply(Long aLong) throws Exception {
                  ArrayList<String> list = new ArrayList<>();
                  list.add(aLong.toString());
                  return list;
              }
          });
```

#### buffer

>  对整个流进行分组，将原先的`Observable`对象转换为一个新的`Observable`对象，每次发生一组值，而不是原先的一个个发送。

```java
/**
* count 成组的个数
* skip 隔几个输出一次 比如 1，2，3 设置skip=1,count=3 输出则为 [1,2,3],[2,3],[3]
*/
public final Observable<List<T>> buffer(int count, int skip)
public final Observable<List<T>> buffer(int count)//skip = count
  
Observable<String> observable = Observable.range(1, 20)
                .buffer(3, 1)
                .map(new Function<List<Integer>, String>() {
                    @Override
                    public String apply(List<Integer> lists) throws Exception {
                        return lists.toString();
                    }
                });
```

#### window

> 与`buffer`功能类似，但它发射出的是`Observable`，这些`Observable`在单独发射数据，都发送完毕后，发出`onComplete()`通知。

```java
public final Observable<Observable<T>> window(long count)
  
Observable.range(1, 10).window(3).subscribe(
        observable -> observable.subscribe(integer -> System.out.println(observable.hashCode() + " : " + integer)));
```



### 过滤操作符

#### filter

> 根据指定规则对发送数据进行过滤

```java
public final Observable<T> filter(Predicate<? super T> predicate)
 
Observable.range(1,10).filter(new Predicate<Integer>() {
            @Override
            public boolean test(Integer integer) throws Exception {
                //只输出大于5的值
                return integer>5;
            }
        })
```



#### elementAt&firstElement&lastElement

> `elementAt`：用于获取数据源中的指定位置的数据
>
> `firstElement`：用于获取数据源中的第一个元素
>
> `lastElement`：用于获取数据源中的最后一个元素

```java
public final Maybe<T> elementAt(long index)

Observable.range(0, 5).elementAt(3);
```



#### distinct&distinctUntilChanged

> `distinct`：对数据源中的重复数据进行过滤
>
> `distinctUntilChanged`：只会过滤相邻的两个相同元素

```java
public final Observable<T> distinct()
  
Observable.just(1,2,3,4,5,6,5).distinct() => 1,2,3,4,5,6  
Observable.just(1,2,3,4,5,6,5).distinctUntilChanged() => 1,2,3,4,5,6,5
```



#### skip&skipLast

> `skip`：对数据源中的前几项进行过滤
>
> `skipLast`：对数据源中的后几项进行过滤，以及最后的一段时间不发射数据。

```java
public final Observable<T> skip(long count)
Observable.just(1,2,3,4,5,6,5).skip(3) => 4,5,6,5
  
//隔一段时间后，开始输出数据  
public final Observable<T> skip(long time, TimeUnit unit)
Observable.just(1,2,3,4,5,6,5).skip(1,TimeUnit.SECONDS) => 1,2,3,4,5,6,5
  
public final Observable<T> skipLast(long count)
Observable.just(1,2,3,4,5,6,5).skipLast(3) => 1,2,3,4
```

#### take&takeLast

> `take`：取出数据源的前几项数据
>
> `takeLast`：取出数据源的后几项数据

```java
public final Observable<T> take(long count)
Observable.just(1,2,3,4,5,6,5).take(3) =>1,2,3
//取出前time秒中输出的数据
public final Observable<T> take(long time, TimeUnit unit)
Observable.just(1,2,3,4,5,6,5).repeat(1).take(100,TimeUnit.MILLISECONDS) => 1,2,3,4,5,6,5

public final Observable<T> takeLast(long count)
Observable.just(1,2,3,4,5,6,5).takeLast(3)
```



#### ignoreElements

> 过滤所有Observable对象发射的数据，只允许`onError()`或`onComplete()`发送

```java
public final Completable ignoreElements()
  
Observable.just(1,2,3,4,5,6,5).ignoreElements().subscribe(new CompletableObserver() {
            @Override
            public void onSubscribe(Disposable disposable) { }
            @Override
            public void onComplete() { }
            @Override
            public void onError(Throwable throwable) { }
        });
```



#### throttleFirst & throttleLast&throttleLatest

> `throttleFirst`：对输出的数据进行限制，按照指定的参数对时间进行分片，然后选择每个时间片中的第一条数据
>
> `throttleLast`：对输出的数据进行限制，按照指定的参数对时间进行分片，然后选择每个时间片中的最后一条数据
>
> `throttleLatest`：读书处的数据进行限制，按照指定的参数对时间进行分片，然后选择每个时间片中的最近数据

```java
public final Observable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler)
 Observable.just(1,2,3,4,5,6,5).delay(50,TimeUnit.MILLISECONDS,Schedulers.trampoline()).
                throttleFirst(100,TimeUnit.MILLISECONDS) => 1,3,5,5
  
public final Observable<T> throttleLast(long skipDuration, TimeUnit unit, Scheduler scheduler)   Observable.just(1,2,3,4,5,6,5).delay(50,TimeUnit.MILLISECONDS,Schedulers.trampoline()).
                throttleLast(100,TimeUnit.MILLISECONDS) => 2,4,6,5
  
public final Observable<T> throttleLatest(long skipDuration, TimeUnit unit, Scheduler scheduler)   
Observable.just(1,2,3,4,5,6,5).delay(50,TimeUnit.MILLISECONDS,Schedulers.trampoline()).
                throttleLatest(100,TimeUnit.MILLISECONDS) => 1,3,5,6
```



#### throttleWithTomeOut

> 数据源发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时才进行发射 

```java
public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler)

 Observable.just(1,2,3,4,5,6,5).delay(120,TimeUnit.MILLISECONDS,Schedulers.trampoline()).
                throttleWithTimeout(200,TimeUnit.MILLISECONDS) => 5  
  
```



#### debounce

> 限制发射频率过快的，它仅在过了一段指定的时间还没发射数据时才发射一个数据。功能与`throttleWithTimeout`相似

```java
public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit) {
        return debounce(timeout, unit);
    }    

public final Observable<T> debounce(long timeout, TimeUnit unit) {
        return debounce(timeout, unit, Schedulers.computation());
    }
```



### 组合操作符

#### startWith&startWithArray

> `startWith`：在指定数据源之前插入数据
>
> `startWithArray`：在指定数据之前插入数组

```java
//插入单个数据
public final Observable<T> startWith(T item)
//插入实现Iterable接口的对象
public final Observable<T> startWith(Iterable<? extends T> items)
  
Observable.just(1,2,3,4).startWith(0) => 0,1,2,3,4

//插入多个数据
public final Observable<T> startWithArray(T... items)
Observable.just(1,2,3,4).startWithArray(0,0,0) => 0,0,0,1,2,3,4
```

#### merge&mergeArray

> `merge`：可以将多个数据源的数据合并起来进行发射，可能导致合并后的数据交错发射。
>
> `mergeArray`：插入的是一个`Observable`数组

```java
public static <T> Observable<T> merge(Iterable<? extends ObservableSource<? extends T>> sources)
  
  
Observable<String > ob1 = Observable.just(1,2,3,4);
Observable<String > ob2 = Observable.just(1,2,3,4);
Observable.mergeArray(ob1,ob2)
```

`mergeError`是一个特殊示例，会等到所有数据发射完毕，才抛出`onError`事件

#### concat&concatArray

> 会将多个`Observable`对象合并到一个`Observable`对象中进行发送且**严格按照顺序发射**。

{% fullimage /images/RxJava-concat.webp,conact操作符,conact操作符%}

```java
Observable<String > ob1 = Observable.just(1,2,3,4);
Observable<String > ob2 = Observable.just(1,2,3,4);
Observable.concatArray(ob1,ob2)
```

#### zip&zipArray&zipIterable

> 按顺序结合两个或多个`Observable`对象，然后返回结果。**严格按照顺序进行发射，他的总发射数与数据项最少的`Observable`对象数据相同。**

```java
Observable.zip(Observable.range(1, 6), Observable.range(1, 5),(integer, integer2) -> integer*integer2).subscribe(o -> System.err.println(o));

1,4,9,16,25
```

{% fullimage /images/RxJava-zip.webp,zip操作符,zip操作符%}

#### combineLastest

> 当两个Observable中的任何一个发送了数据时，使用一个函数结合每个`Observable`的最近数据项，并且基于这个结果发送数据。

{% fullimage /images/RxJava-combineLatest.png,combineLatest操作符,combineLatest操作符%}

```java
Observable.combineLatest(Observable.range(1, 6),Observable.range(1,5),(integer, integer2) -> integer*integer2).subscribe(o -> System.err.println(o));

//此时第一个Observable输出完毕，最终得到6，在与后续的增加数据相乘
6,12,18,24,32
```



### 辅助操作符

#### delay

> 设置数据发射前的停顿时间

```java
public final Observable<T> delay(long delay, TimeUnit unit)

Observable.just(1,2,3,4).delay(200,TimeUnit.MILLISECONDS)
```



#### do系列

> 用于监听数据回调

- `doAfterNext`：在`onNext()`之后回调
- `doOnNext`：调用`onNext()`时回调
- `doOnSubscribe`：观察者订阅时触发
- `doOnError`：调用`onError()`时触发
- `doOnComplete`：调用`onComplete()`时触发
- `doOnTerminate`：Observable终止前触发
- `doOnEach`：每次调用`onNext()`时触发
- `doOnDispose`：调用`Disposable.dispose()`时触发
- `doFinally`：调用`onError()`或`onComplete()`时触发
- `doAfterTerminate`：Observable终止后触发

#### subscribeOn

> 指定发射器所在的线程，即`Observable.onScuscribe`的所处线程，或者叫做事件产生的线程

```java
Observable.just(1).subscribeOn(Schedules.io)
```



#### observeOn

> 指定Subscriber所在线程，或者叫做事件消费的线程。

```java
Observable.just(1).subscribeOn(Schedules.io).obServerOn(AndroidSchedulers.mainThread())
```



#### timeout

> 用来设置一个超时时间，如果在指定时间内没有任何数据被发送出来，就会执行指定的数据项。

```java
Observable.just(1L,2L,3L)
      .timeout(500, TimeUnit.MILLISECONDS, Observable.rangeLong(1, 5))
      .subscribe(System.out::print);
输出结果：123

Thread.sleep(2000);
输出结果：12345
```



### 错误处理操作符

#### catch

> 拦截原始的`onError`通知，把它进行替换为其他的Observable对象，使原来的可以正常终止甚至不终止。

- `onErrorReturn`：在触发`onError`时，调用用户自定义的返回请求，实质上就是在调用一次`onNext`之后结束请求。

  ```java
  Observable.create(new ObservableOnSubscribe<Object>() {
              @Override
              public void subscribe(ObservableEmitter<Object> observableEmitter) throws Exception {
                  observableEmitter.onNext(1);
                  observableEmitter.onNext(2);
                  observableEmitter.onError(new IllegalArgumentException("11"));
                  observableEmitter.onNext(1);
              }
          }).onErrorReturn(new Function<Throwable, Object>() {
  
              @Override
              public Object apply(Throwable throwable) throws Exception {
                  return 123;
              }
          })
    
  输出结果：1 2 123
  ```

  

- `onErrorResumeNext`：在触发`onError`时，立即停止原Observable的数据发射，并采用新的Observable对象进行新的数据发射

  ```java
          Observable.create(observableEmitter -> {
              observableEmitter.onNext(1);
              observableEmitter.onNext(2);
              observableEmitter.onError(new IllegalArgumentException("11"));
              observableEmitter.onNext(1);
          }).onErrorResumeNext(Observable.range(1,3))
            
  输出结果： 1 2 1 2 3
  ```

  

- `onExceptionResumeNext`：如果`onError`触发时收到的不是`Exception`，就会将错误正确传递下去，而不是用用户自定义的Observable对象

  ```java
   Observable.create(observableEmitter -> {
              observableEmitter.onNext(1);
              observableEmitter.onNext(2);
              //observableEmitter.onError(new IllegalArgumentException("11"));
              // 输出结果为 抛出异常
              observableEmitter.onError(new NoSuchMethodError("11"));
              //输出结果为 1 2 1 2 3
              observableEmitter.onNext(1);
          }).onExceptionResumeNext(Observable.range(1,3))
  ```

  

#### retry

> 实现了一种错误重试机制，再出现错误的时候进行重试，可以通过参数指定重试的条件。

{% fullimage /images/RxJava-retry.webp,retry操作符,retry操作符%}

- `retry()`：无限次重试

- `retry(long times)`：指定次数的重试

  ```java
   Observable.create(observableEmitter -> {
              observableEmitter.onNext(1);
              observableEmitter.onNext(2);
              observableEmitter.onError(new IllegalArgumentException("11"));
              observableEmitter.onNext(123);
          }).retry(2);
  输出结果： 1 2 1 2 抛出异常
  ```

  

- `retry(BiPredicate<? super Integer, ? super Throwable> predicate)`：指定一定规则进行重试

  ```java
   Observable.create(observableEmitter -> {
              observableEmitter.onNext(1);
              observableEmitter.onNext(2);
              observableEmitter.onError(new IllegalArgumentException("11"));
              observableEmitter.onNext(123);
          }).retry(new BiPredicate<Integer, Throwable>() {
              @Override
              public boolean test(Integer integer, Throwable throwable) throws Exception {
                  //integer 为重试次数 return true代表继续重试 false 代表抛出异常
                  return integer<2;
              }
          })
  ```



### 条件操作符

#### all&any

> `all`：判断数据源中是否所有数据都满足指定要求，可以使用一个函数表示
>
> `any`：判断数据源中是否存在满足要求的数据

```java
public final Single<Boolean> all(Predicate<? super T> predicate)
Observable.just(1,2,3,4).all(integer -> integer < 5) => true
  
public final Single<Boolean> any(Predicate<? super T> predicate)
Observable.just(1,2,3,4).all(integer -> integer < 2) => true 
```



#### contains&isEmpty

> `contains`：判断数据源中是否包含指定项
>
> `isEmpty`：数据源是否为空

```java
public final Single<Boolean> contains(final Object element)
Observable.just(1,2,3,4).contains(2) => true
  
public final Single<Boolean> isEmpty()
Observable.just(1,2,3,4).isEmpty() => false 
```



#### sequenceEqual

> 用来判断两个Observable对象的发射序列是否相等(*包含数据，发射顺序，终止状态等*)

```java
public static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2) 

Observable.sequenceEqual(Observable.range(1,6),
                Observable.range(1,5))
                .subscribe(new Consumer<Boolean>() {
                    @Override
                    public void accept(Boolean aBoolean) throws Exception {
                        System.err.println(aBoolean);
                    }
                });

输出结果：false
```



#### amb

> 作用于两个或多个`Observable`对象，但是只会发射最初的Observable对象数据。

{% fullimage /images/RxJava-amb.webp,amb操作符,amb操作符%}

```java
Observable.amb(Arrays.asList(Observable.range(1,6),
                Observable.range(1,5)))
   
输出结果： 1 2 3 4 5 6
```

#### defaultIfEmpty

> 当数据源的数据为空时指定发送一个数据

```java
Observable.create(observableEmitter -> {
    observableEmitter.onComplete();
  }).defaultIfEmpty(777)
   
输出结果： 777   
```



### 转换操作符

#### toList&toSortedList

> 将数据发射序列转成列表，`toSortedList`转成升序列表

```java
public final Single<List<T>> toList()
Observable.just(1,2,5,6,4,3).toList() => 1,2,5,6,4,3
  
public final Single<List<T>> toSortedList()
Observable.just(1,2,5,6,4,3).toSortedList() => 1,2,3,4,5,6

//支持自定义比较规则
public final Single<List<T>> toSortedList(final Comparator<? super T> comparator)
Observable.just(1,2,5,6,4,3).toSortedList(Comparator.comparingInt(value -> -value)) => 6,5,4,3,2,1
```



#### toMap&toMultiMap

> 将发射的数据转换成另一个类型的值，转换过程是针对每一个数据项的。**源Observable的每一项数据作为value，然后用户自定义生成key的函数，最终得到Map型的结果。**
>
> `toMultiMap`可以转换成一个集合对象

{% fullimage /images/RxJava-toMap.webp,toMap操作符,toMap操作符%}

```java
Observable.just(1,2,5)
        .toMap(new Function<Integer, Object>() {
            @Override
            public Object apply(Integer integer) throws Exception {
                return integer + 1;
            }
        })
  
输出结果：[2=1，3=2，6=5]

Observable.just(1,2,3)
               .toMultimap(new Function<Integer, Object>() {
                   @Override
                   public Object apply(Integer integer) throws Exception {
                       return integer+1;
                   }
               })
  
输出结果：{2=[1], 3=[2], 4=[3]}
```

#### toFlowable

> 用于讲一个`Observable`对象转成`Flowable`对象。

#### to

> 可以将一个`Observable`对象转成任意类型



## RxJava线程类型

RxJava的线程控制是通过`subscribeOn`以及`observeOn`来进行控制的。接下来列举一下RxJava中提供的线程调度器以及`RxAndroid`提供的主线程调度器。

- `Schedulers.io()`：适用于io操作(*在Android中指代子线程*)，增长或缩减来自适应的线程池，通常用于访问网络，读写文件等操作。采用的线程池是`CachedThreadPool`，是无限制的，但是大量创建线程就会影响性能。
- `Schedulers.computation()`：计算工作默认的调度器，与I/O操作无关
- `Schedulers.newThread()`：代表常规的一个新线程
- `Schedulers.immdiate()`：允许你立即在当前线程执行任务
- `Schedulers.trampoline()`：当我们想执行一个任务时，并非立即执行，使用`trampoline()`执行入队。*将会处理它的队列并且按序运行队列中每一个任务*
- `AndroidSchedulers.mainThread()`：指代Android系统中的主线程

## RxJava基本流程分析

```java
 Observable.create(new ObservableOnSubscribe<Integer>() {
            @Override
            public void subscribe(ObservableEmitter<Integer> observableEmitter) throws Exception {
                observableEmitter.onNext(123);
                observableEmitter.onComplete();
            }
        }).subscribeOn(AndroidSchedulers.mainThread())
   .observerOn(Schedulers.io())
   .subscribe(new Observer<Integer>() {
            @Override
            public void onSubscribe(Disposable disposable) {

            }

            @Override
            public void onNext(Integer integer) {
                System.err.println(integer);
            }

            @Override
            public void onError(Throwable throwable) {

            }

            @Override
            public void onComplete() {

            }
        });
```

以上是最基础的RxJava使用流程，从这段代码中进行原理分析。

### 创建Observable

从`Observable.create()`开始

```java
    public static <T> Observable<T> create(ObservableOnSubscribe<T> source) {
        ObjectHelper.requireNonNull(source, "source is null");
        //大致流程就是 新建了一个ObservableCreate对象
        return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));
    }
```

1. Observable先调用`create()`
2. `create()`中传入`ObservableOnSubscribe`对象
3. 通过`new ObservableCreate()`得到最终Observable对象

```java ObservableCreate.java
   //外部传进来的 ObservableOnSubscribe实例 
   final ObservableOnSubscribe<T> source;
 
    public ObservableCreate(ObservableOnSubscribe<T> source) {
        this.source = source;
    }

    @Override
    protected void subscribeActual(Observer<? super T> observer) {
        CreateEmitter<T> parent = new CreateEmitter<T>(observer);
        observer.onSubscribe(parent);

        try {
            source.subscribe(parent);
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            parent.onError(ex);
        }
    }
```

{% fullimage /images/Observable创建流程.png,Observable创建流程,Observable创建流程%}

### Observable订阅

通过`Observable.subscribe()`执行订阅流程

```java
 public final void subscribe(Observer<? super T> observer) {
        ObjectHelper.requireNonNull(observer, "observer is null");
        try {
            observer = RxJavaPlugins.onSubscribe(this, observer);

            ObjectHelper.requireNonNull(observer, "The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");

            subscribeActual(observer);①
        } catch (NullPointerException e) { // NOPMD
            throw e;
        } catch (Throwable e) {
            Exceptions.throwIfFatal(e);
            RxJavaPlugins.onError(e);
            NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS");
            npe.initCause(e);
            throw npe;
        }
    }

protected abstract void subscribeActual(Observer<? super T> observer);

//ObservableCreate.java 子类实现该方法
protected void subscribeActual(Observer<? super T> observer) {
        CreateEmitter<T> parent = new CreateEmitter<T>(observer);
        //执行Observer的onSubscribe()进行事件分发
        observer.onSubscribe(parent);

        try {
            //向上调用上层的Observer的subscribe()
            source.subscribe(parent);
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            parent.onError(ex);
        }
    }
```

在`subscribe()`中会调用到抽象方法`subscribeActual()`，就拿上节的`ObservableCreate`来说，他的内部就实现了`subscribeActual()`。

在`subscribe()`传入的参数为`Observer`类型即观察者。

{% fullimage /images/Observable订阅流程.png,Observable订阅流程,Observable订阅流程%}

> `Observable.subscribe()`调用到`Observable.subscribeActual()`，由子类进行覆盖重写(**多态**)，在其中执行的代码主要分为两部分：
>
> `Observerable.subscribe`：真正的订阅流程从这里开始
>
> `Observer.onSubscribe`：在其中进行事件分发

### 线程切换

RxJava通过`subscribeOn()`和`observerOn()`来进行线程的切换。如果未去设置线程切换相关参数，那么执行的线程都会为当前线程。

#### Observable.observeOn

> 切换`subscribe()`的运行线程

从`Observable.observeOn()`开始进行分析

```java
public final Observable<T> observeOn(Scheduler scheduler) {
        return observeOn(scheduler, false, bufferSize());
    }

public final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {
        ObjectHelper.requireNonNull(scheduler, "scheduler is null");
        ObjectHelper.verifyPositive(bufferSize, "bufferSize");
        //this 指代了当前的Observable对象， scheduler就是指我们设置的 切换线程
        return RxJavaPlugins.onAssembly(new ObservableObserveOn<T>(this, scheduler, delayError, bufferSize));
    }
```

通过`Observable.observeOn()`运行之后得到了`ObservableObserveOn`对象。

```java ObservableObserveOn.java
    @Override
    protected void subscribeActual(Observer<? super T> observer) {
        if (scheduler instanceof TrampolineScheduler) {
            //无需执行任何线程操作
            source.subscribe(observer);
        } else {
            //scheduler指代传进来的线程调度对象
            Scheduler.Worker w = scheduler.createWorker();
            source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));
        }
    }
```

调用`ObservableObserveOn.subscribeActual()`后，会生成`ObserveOnObserver`对象，由该对象对`ObserveableObserveOn`进行监听

```java ObservableObserveOn.java
  @Override
        public void onNext(T t) {
            if (done) {
                return;
            }
            if (sourceMode != QueueDisposable.ASYNC) {
                //添加当前事件到队列中
                queue.offer(t);
            }
            //执行线程切换
            schedule();
        }

        void schedule() {
            if (getAndIncrement() == 0) {
                worker.schedule(this);
            }
        }
```

例如发送一个`onNext()`事件，就会执行到`schedule()`进行线程切换(如果设置)。`worker`对应新建`ObserveOnObserve`对象时的传入参数——用户自定义的`Schedulers`。此处拿`IoScheduler`举例，用于子线程执行操作。

```java IoScheduler.java
//Scheduler.java
public abstract static class Worker implements Disposable
        @NonNull
        public Disposable schedule(@NonNull Runnable run) {
            return schedule(run, 0L, TimeUnit.NANOSECONDS);
        }
}

static final class EventLoopWorker extends Scheduler.Worker{
@NonNull
        @Override
        public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {
            if (tasks.isDisposed()) {
                // don't schedule, we are unsubscribed
                return EmptyDisposable.INSTANCE;
            }

            return threadWorker.scheduleActual(action, delayTime, unit, tasks);
        }
}

    static final class ThreadWorker extends NewThreadWorker {
        private long expirationTime;

        ThreadWorker(ThreadFactory threadFactory) {
            super(threadFactory);
            this.expirationTime = 0L;
        }

        public long getExpirationTime() {
            return expirationTime;
        }

        public void setExpirationTime(long expirationTime) {
            this.expirationTime = expirationTime;
        }
    }
```

假设设置子线程执行即`Schedulers.io()`，那么会优先调用到`Schedulers.schedule()`由于子类没有实现该方法，所以上溯到父类中的实现。

调用到`schedule()`之后，，就会调用到`IoScheduler.schedule()`中，再切换到了`NewThreadWorker.scheduleActual()`中

```java NewThreadWorker.java
    public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {
        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
        ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);
        if (parent != null) {
            if (!parent.add(sr)) {
                return sr;
            }
        }

        Future<?> f;
        try {
            if (delayTime <= 0) {
              //executor 指代一个线程池对象
                f = executor.submit((Callable<Object>)sr);
            } else {
                f = executor.schedule((Callable<Object>)sr, delayTime, unit);
            }
            sr.setFuture(f);
        } catch (RejectedExecutionException ex) {
            if (parent != null) {
                parent.remove(sr);
            }
            RxJavaPlugins.onError(ex);
        }

        return sr;
    }
```

在`NewThreadWorker.scheduleActual()`主要执行的是使用线程池调用`submit()`或`execute()`去启动线程。经过层层传递最后调用到`ObserveableObserveOn.run()`

```java ObserveableObserveOn.java
        @Override
        public void run() {
            if (outputFused) {
                drainFused();
            } else {
                drainNormal();
            }
        }

void drainNormal() {
           ...
            for (;;) {
                if (checkTerminated(done, q.isEmpty(), a)) {
                    return;
                }

                for (;;) {
                    boolean d = done;
                  ...

                    a.onNext(v);
                }
             ...
            }
        }
```

层层回调到`run()`后，在其中会继续执行`onNext()`此时线程已经切换成功。

**最终实现的是将目标Observe中的`onNext()，onError(),onComplete()`置于指定线程中运行。**

//TODO 流程图

#### Observable.subscribeOn

> 切换`Observable`的运行线程

同上，先从`Observable.subscribeOn()`开始分析

```java Observable.java
    public final Observable<T> subscribeOn(Scheduler scheduler) {
        ObjectHelper.requireNonNull(scheduler, "scheduler is null");
        return RxJavaPlugins.onAssembly(new ObservableSubscribeOn<T>(this, scheduler));
    }
```

操作的对象为`ObservableSubscribeOn`

```java ObservableSubscribeOn.java
    @Override
    public void subscribeActual(final Observer<? super T> observer) {
        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(observer);
        //调用 onSubscribe() 回调
        observer.onSubscribe(parent);
        //此处调用线程切换
        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));
    }
```

这里我们假设使用的是`IoScheduler`，就调用到`IoScheduler.scheduleDirect()`

```java Scheduler.java
public Disposable scheduleDirect(@NonNull Runnable run) {
        return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);
    }

    @NonNull
    public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {
        final Worker w = createWorker();
        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
        DisposeTask task = new DisposeTask(decoratedRun, w);
        w.schedule(task, delay, unit);
        return task;
    }
```

最后调用到`DisposeTask.run()`方法去执行切换

```java Scheduler.java
static final class DisposeTask implements Disposable, Runnable, SchedulerRunnableIntrospection {
public void run() {
            runner = Thread.currentThread();
            try {
                decoratedRun.run();
            } finally {
                dispose();
                runner = null;
            }
        }
}
```

`decoratedRun`指的就是上面传进来的`SubscribeTask`，有执行到了它的`run()`

```java ObservableSubscribeOn.java
    final class SubscribeTask implements Runnable {
        private final SubscribeOnObserver<T> parent;

        SubscribeTask(SubscribeOnObserver<T> parent) {
            this.parent = parent;
        }

        @Override
        public void run() {
            source.subscribe(parent);
        }
    }
```

此时线程已经完成了切换工作。

> 第一次有效。

#### `AndroidSchedulers.mainThread()`

由RxAndroid提供的Android主线程切换器

```java AndroidSchedulers.java
    private static final class MainHolder {
        static final Scheduler DEFAULT
            = new HandlerScheduler(new Handler(Looper.getMainLooper()), false);
    }

    private static final Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(
            new Callable<Scheduler>() {
                @Override public Scheduler call() throws Exception {
                    return MainHolder.DEFAULT;
                }
            });

    /** A {@link Scheduler} which executes actions on the Android main thread. */
    public static Scheduler mainThread() {
        return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);
    }

    /** A {@link Scheduler} which executes actions on {@code looper}. */
    public static Scheduler from(Looper looper) {
        return from(looper, false);
    }
```

`mainThread()`里面新建了一个`Handler`对象用来切换至主线程，还支持通过`from()`设置自定义Looper来切换到其他线程。

RXJava设置线程切换时，需要通过`Scheduler.createWorker()`来生成对应线程切换器

```java HadnlerScheduler.java
final class HandlerScheduler extends Scheduler{
   @Override
    @SuppressLint("NewApi") // Async will only be true when the API is available to call.
    public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
        if (run == null) throw new NullPointerException("run == null");
        if (unit == null) throw new NullPointerException("unit == null");

        run = RxJavaPlugins.onSchedule(run);
        ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);
        Message message = Message.obtain(handler, scheduled);
        if (async) {
            message.setAsynchronous(true);
        }
        handler.sendMessageDelayed(message, unit.toMillis(delay));
        return scheduled;
    }

    @Override
    public Worker createWorker() {
        return new HandlerWorker(handler, async);
    }
}

private static final class HandlerWorker extends Worker {
   public Disposable schedule(Runnable run, long delay, TimeUnit unit) {
            ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);
            Message message = Message.obtain(handler, scheduled);
            message.obj = this; // Used as token for batch disposal of this worker's runnables.
            if (async) {
                message.setAsynchronous(true);
            }
            handler.sendMessageDelayed(message, unit.toMillis(delay));
            if (disposed) {
                handler.removeCallbacks(scheduled);
                return Disposables.disposed();
            }
   }
  
         @Override
        public void dispose() {
            disposed = true;
            handler.removeCallbacksAndMessages(this /* token */);
        }
}
```

在`dispose()`时通过移除对应的消息来取消订阅

### 事件分发

### 取消订阅

通过`Disposable.dispose()`可以取消相关订阅

## 内容引用

[RxJava1](<https://www.jianshu.com/p/a9ebf730cd08>)

[RxJava2](https://juejin.im/post/5a248206f265da432153ddbc#heading-9)

[RxJava3](https://juejin.im/post/5b72f76551882561354462dd#heading-9)

[RxJava4](https://www.cherylgood.cn/?keyword=Rxjava)

[RxJava5](https://www.jianshu.com/p/88aa273d37be)

[RxJava6](https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&mid=2247490701&idx=1&sn=a7cef1ae9c59c3c60af2b15f7939799d&chksm=96cdbdc0a1ba34d605cad73ba1dd0d81059ced9fc1c067b9593403a283414db07cca4d7459fe&mpshare=1&scene=23&srcid=1015rFqxIvHGW6R8HsZQpPwj%23rd)

]]></content>
      <tags>
        <tag>Hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DiskLruCache源码分析</title>
    <url>/2018/12/17/DiskLruCache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[
> 可以将缓存数据持久化的存储到磁盘上，并且使用`LRU算法`维持缓存在一个固定的大小。

## 基本使用



## 原理分析]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2019/02/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[
## 工厂方法模式

> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。



## 抽象工厂模式

]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 泛型</title>
    <url>/2019/01/02/Java-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[
{% fullimage /images/泛型.png,泛型,泛型%}

## 泛型基本概念

> Java泛型是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数(`type parameter`)。声明的类型参数在使用时用具体的类型来替换。
>
> **本质上是编译器为了提供更好的可读性而提供的一种方式，JVM中是不存在泛型的概念的。**

泛型的出现在很大程度上是为了方便集合的使用，使其能够记住元素的数据类型。泛型是对Java语言类型系统的一种拓展，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符。

### 泛型的好处

1. **类型安全**。类型错误可以在编译期直接被捕获到，而不是在运行时抛出`ClassCastException(类型转换错误)`，有助于开发者方便找到错误，提高可靠性。
2. **减少代码中的强制类型转换**。增强代码可读性

## 泛型的类型通配符

> 匹配任意类型的类型实参。**通配符往往用于方法的形参中，不允许在定义和调用中使用。**

### 无界通配符(非限定通配符)——`?`

通配任意一种类型，可以用任意类型进行替代。

```java
public class GenericTest {
    public static void main(String[] args){
        List<? extends Number> list = new ArrayList<Integer>();
        test(list);
    }

    //可以传入任意类型的List
    public static void test(List<?> list){
        for (Object o : list) {
            System.err.println(o);
        }
    }
}
```

### 带限通配符(限定通配符)

> 限制泛型的类型参数的类型，使其满足条件，限制在一些类中。

#### 上限通配符——`? extends T`

> 确保泛型类型必须是T的子类来设定类型的上界。**使用`extends`关键字制定这个类型必须是继承某个类或者实现某个接口，也可以是这个类或者接口本身。**
>
> 使用时

```java
public class GenericTest {
    public static void main(String[] args){
        List<Integer> upList = new ArrayList<>();
        upTest(upList);
    }
    //设定集合中的所有元素必须是Number的子类，例如Integer
    public static void upTest(List<? extends Number> list){
        for (Number number : list) {
            System.err.println(number);
        }
    }
}
```

> 在Java中父类型可以持有子类型。如果一个父类的容器可以持有子类的容器，那么就称之为**协变**。
>
> 可以利用`上限通配符`实现`协变`。

#### 下限通配符——`? super T`

> 确保泛型类型必须是T的父类来设定类型的下界。**使用`super`关键字指定这个类型必须是某个类的父类或者某个接口的父接口，也可以是这个类或者接口本身。**

```java
public class GenericTest {
    public static void main(String[] args){
        List<Number> downList = new ArrayList<>();
        downTest(downList);
    }
    //设定集合中的所有元素必须是Integer的父类，例如Number
    public static void downTest(List<? super Integer> list){
        for (Object o : list) {
            System.err.println(o);
        }
    }
}
```

> 如果一个类的父类型容器可以持有该类的子类型的容器，那么称之为**逆变**。
>
> 可以利用`下限通配符`实现`逆变`。

### PECS原则

> **Producter Extends ，Consumer Super**。

`Producter Extends`：如果你只需要一个只读List，那么使用`? extends T`。

> 无法确定写入类型，所以禁止写入会编译错误。只能对外提供数据。

`Consumer Super`：如果你只需要一个只写List，那么使用`? super T`

> 写入类型都是其父类，是可以确定的。但是无论怎样取出的值都会是`Object`型，是无意义的。

**如果需要同时读取以及写入，就不能使用通配符。**

### 通配符的只读性

通配符代表了不确定的类型，无法了解到这个容器中放的是什么类型的数据，所有只有只读性，不能往里面去添加元素。

## 泛型的类型擦除

> 泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息。成功编译过后的Class文件是不会包含任何泛型信息的，泛型信息不会进入到运行时阶段。
>
> 例如`List<String>`在运行时用`List`表示，为了确保Java 5之前的版本可以进行兼容。

### 实例分析

```java
    public static void typeErasure(){
        Class c1 = new ArrayList<Integer>().getClass();
        Class c2 = new ArrayList<String>().getClass();
        System.err.println(c1 == c2);
    }

运行结果：
true
```

反编译即观察得到的.class

```java
    public static void typeErasure() {
        Class c1 = (new ArrayList()).getClass();
        Class c2 = (new ArrayList()).getClass();
        System.err.println(c1 == c2);
    }
都被转成为ArrayList的类型，原先的泛型都被擦除。
```

### 类型擦除基本过程

1. 找到用来替换类型参数的具体类，一般都是`Object`。如果指定类类型参数的上界话，就会采用上界。

   ```java
   未设置上界：List<Integer>  -->  List<Object>
   设置上界：List<T extends Number> --> List<Number>
   ```

   > 设置边界：重用了 `extends`关键字。可以将类型参数的范围限制到一个子集中。
   >
   > 设置边界时有两个注意事项：
   >
   > - 类必须写在接口之前
   > - 只能设置一个类做边界，其他只能是接口

2. 把代码中的类型参数都替换成具体的类，同时去掉出现的类型声明，即去掉`<>`内容。

   ```java
   List<Integer> --> List
   ```

3. 再生成一些桥接方法。这是由于擦除了类型之后的类可能缺少某些必须方法。

### 类型擦除基本原理

在编译过程中，类型变量的信息是可以拿到的。所以在`set()`中编译器可以做类型检查，非法类型无法通过编译。对于`get()`，由于擦除机制，得到的大部分都为`Object`，编译器会在`get()`之后做一个类型转换，转成对应的类型。

### 类型擦除缺陷

#### 无法创建泛型数组

> Array无法提供编译期的类型安全保障，由于运行期就把泛型擦除了，编译器无法判断类型。

一般是无法创建的，推荐使用`ArrayList`来实现数组。如果硬要创建，就需要用到反射去实现。

```java
class GenericArrayWithType<T> {
    T[] array;

    @SuppressWarnings("unchecked")
    public GenericArrayWithType(Class<T> type, int size) {
        //使用反射中的Array类型 newInstance创建实例对象
        array = (T[]) Array.newInstance(type, size);
    }

    public void put(int index, T item) {
        array[index] = item;
    }
}

GenericArrayWithType<Integer> genericArrayWithType = new GenericArrayWithType<>(Integer.class, 10);
genericArrayWithType.put(0, 2);
```



#### 泛型不能显式地运用在运行时类型的操作当中，例如`instanceOf、new`

> 由于系统中并不会真正生成泛型类，而且在运行时，所有参数的类型信息都已经被擦除。

可以使用显式工厂模式，避免上述问题。



#### 泛型的类型参数不能用在`catch`中

> 异常处理是由JVM在运行时刻进行的。由于类型擦除，JVM无法区分异常类型。对于JVM来说他们是没有区别的，也就无法正常执行对应的`catch`语句。

## 泛型的基本使用

#### 泛型类

> 基本格式 ： 
>
> **访问修饰符 class 类名<限定类型变量名>**
>
> 例如 ： `public class Box<T>`

首先定义一个简单的Box类

```java
public class Box{
  private String object;
  public void set(String object){this.object = object;}
  public String get() {return object;}
}
```

这时的Box类内部只能接收`String`型参数，如果需要其他类型就需要重写另外一个，这时就可以用泛型类解决这个问题。

```java
public class Box<T>{
  private T t;
  public void set(T t){this.t=t;}
  public T get() {return t;}
}
```

这时的Box类便可以支持其他类型参数，可以把`T`折换成任意类型

```java
Box<Integer> integerBox = new Box<Integer>();
Box<String> stringBox = new Box<String>();
```



#### 泛型接口

> 基本格式 ： 
>
> **访问修饰符 interface 接口名<限定类型变量名>**
>
> 例如 ： `public interface Box<T>`

```java
interface Box<T>{
    T create();
}

class IntegerBox implements Box<Integer>{

    @Override
    public Integer create() {
        return null;
    }
}

class StringBox implements Box<String>{

    @Override
    public String create() {
        return null;
    }
}
```

#### 泛型方法

> 基本格式 ： 
>
> **访问修饰符 <T,S> 返回值类型 方法名 (形参列表)**
>
> 例如 ： `public <T> void showBox(T t)`

```java
    public static <T> void show(T t) {
        System.err.println(t);
    }

    //支持返回泛型类型
    public static <T> T show(T t) {
        System.err.println(t);
      return t;
    }
```

泛型方法中定义的形参只能在该方法中使用，但是接口、类中定义的形参可以在这个接口、类中使用。



#### 泛型构造器

> 基本格式 ： 
>
> **访问修饰符 class 类名 {**
>
>   **访问修饰符 <T> 类名 (形参列表){}** 
>
> **}**
>
> 例如 ： `public class Box{`
>
> `public <T> Box (T t){}`
>
> `}`

使用泛型构造器有两种方式：

1. 显式指定泛型参数

   ```java
   new <String>Box("a")
   ```

2. 隐式推断

   ```java
   new Box("a")
   ```

   

### 泛型注意事项

- **任何基本类型都不能作为类型参数**

-  **无法进行重载**

  > 由于擦除的原因，重载方法将产生相同的类型签名。避免这种问题的方法就是换个方法名

  

  

### 内容引用

[Java泛型详解](http://www.importnew.com/24029.html)

[Java泛型进阶](https://www.jianshu.com/p/4caf2567f91d)]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook技术简析</title>
    <url>/2019/02/06/Hook%E6%8A%80%E6%9C%AF%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
说到Hook技术需要先提到逆向工程，主要目的是**在不能轻易获得必要生产信息的情况下，直接从成品分析，推导出产品的设计原理**。

逆向分析又分为

- 静态分析：不执行程序的情况下对程序行为进行分析的技术
- 动态分析：在程序运行时对程序进行调试的技术。*Hook属于动态分析。*

## 代理模式

{% post_link 动态代理模式原理及实现 %}

## Hook技术概述

{% fullimage /images/正常的调用与回调.png,正常的调用与回调,正常的调用与回调%}

对象A直接调用B，对象B结果直接回调给A。

{% fullimage /images/Hook后的调用与回调.png,Hook后的调用与回调,Hook后的调用与回调%}

Hook可以是一个方法或者对象，它位于对象A和B之间，当对象A调用对象B时会在之前做一些处理。也可以用于应用进程调用系统进程时做一些处理，更改他们间的关系。

其中被Hook的对象B，称作**Hook点**。

整个Hook的过程分为三步：

1. **寻找Hook点**。原则上是静态变量或者单例对象(**容易找到并且不易变化的对象**)，尽量Hook Public的对象和方法，非Public不保证每个版本保持一致，可能需要适配。
2. **选择合适的代理方式**。如果是接口可以使用动态代理方式，类的话多考虑使用静态模式。
3. **用代理对象替换原始对象。**

## Hook实例简析

### Hook `startActivity()`

Activity的启动方式有两种

- 一个Activity启动另一个Activity

  ```java
  startActivity(new Intent(this,XXActivity.class));
  ```

  

- 通过Service或者其他非Activity类进行启动Activity(*必须设置 FLAG_NEW_TASK*)

  ```java
   Intent intent = new Intent(this, XXActivity.class);
   intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
   context.startActivity(intent);
  ```

  

#### 1.Hook `Activity.startActivity()`

从源码分析上需要从`startActivity()`开始

```java ../android/app/Activity.java
    @Override
    public void startActivity(Intent intent) {
        this.startActivity(intent, null);
    }

    @Override
    public void startActivity(Intent intent, @Nullable Bundle options) {
        if (options != null) {
            startActivityForResult(intent, -1, options);
        } else {
            startActivityForResult(intent, -1);
        }
    }

 public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
            @Nullable Bundle options) {
        if (mParent == null) {
            options = transferSpringboardActivityOptions(options);
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
          ...
        }
 }
```

最终调用到的是`Instrumentation.execStartActivity()`执行启动下一个Activity的逻辑。

按照Hook过程分析，需要先找到`Hook点`。由于要Hook的就是Activity的启动，所以我们可以设置`Instrumentation`为Hook点，然后使用静态代理模式生成代理对象，最后替换掉原始的`Instrumentation`继续执行启动逻辑。

> 先创建`Instrumentation`代理对象`InstrumentationProxy`

```java
public class InstrumentationProxy extends Instrumentation {
    private static final String TAG = "InstrumentationProxy";
    Instrumentation mInstrumentation;

    public InstrumentationProxy(Instrumentation _instrumentation) {
        mInstrumentation = _instrumentation;
    }
  
    //为了兼容9.0添加该方法
    public Activity newActivity(ClassLoader cl, String className,
                                Intent intent)
            throws InstantiationException, IllegalAccessException,
            ClassNotFoundException {
        return mInstrumentation.newActivity(cl, className, intent);
    }

    public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,
                                            Intent intent, int requestCode, Bundle options) {
        Log.e(TAG, "hook success" + who);
        // 开始调用原始的方法, 调不调用随你,但是不调用的话, 所有的startActivity都失效了.
        // 由于这个方法是隐藏的,因此需要使用反射调用;首先找到这个方法
        try {
            @SuppressLint("PrivateApi") Method execStartActivity = Instrumentation.class.getDeclaredMethod(
                    "execStartActivity",
                    Context.class, IBinder.class, IBinder.class, Activity.class,
                    Intent.class, int.class, Bundle.class);
            execStartActivity.setAccessible(true);
            return (ActivityResult) execStartActivity.invoke(mInstrumentation, who,
                    contextThread, token, target, intent, requestCode, options);
        } catch (Exception e) {
            throw new RuntimeException("do not support!!! pls adapt it");
        }
    }
}
```

> 在需要使用的Activity中实现Hook方法

```java
public class LoadActivity extends AppCompatActivity {

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.act_load);
        //Hook当前Activity使用的Instrumentation
        replaceActivityInstrumentation(LoadActivity.this);
        Button btn_jump = findViewById(R.id.btn_jump);
        btn_jump.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                startActivity(new Intent(LoadActivity.this, MainActivity.class));
            }
        });
    }

    public void replaceActivityInstrumentation(Activity activity) {
        try {
            Field field = Activity.class.getDeclaredField("mInstrumentation");
            field.setAccessible(true);
            Instrumentation instrumentation = (Instrumentation) field.get(activity);
            Instrumentation instrumentationProxy = new InstrumentationProxy(instrumentation);
            field.set(activity, instrumentationProxy);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

> 理论上来说`Hook操作`越早越好，`handleLaunchActivity()`内部开始执行启动流程，然后会调用到`Activity.attach()`内部继续执行。`attachBaseContext()`是最早执行的，但是其中无法去执行Hook操作
>
> ```java
>  final void attach(Context context, ActivityThread aThread,
>             Instrumentation instr, IBinder token, int ident,
>             Application application, Intent intent, ActivityInfo info,
>             CharSequence title, Activity parent, String id,
>             NonConfigurationInstances lastNonConfigurationInstances,
>             Configuration config, String referrer, IVoiceInteractor voiceInteractor,
>             Window window, ActivityConfigCallback activityConfigCallback) {
>         attachBaseContext(context);
>    ...
>       //在这个方法后面又会继续执行赋值，则Hook失效
>       mInstrumentation = instr;
>    ...
>  }
>    
> ```

#### 2.Hook `Context.startActivity()` 

`Context`的具体实现类为`ContextImpl`，`ContextImpl.startActivity()`如下所示

```java ./android/app/ContextImpl.java
    @Override
    public void startActivity(Intent intent) {
        warnIfCallingFromSystemProcess();
        startActivity(intent, null);
    }

    public void startActivity(Intent intent, Bundle options) {
        warnIfCallingFromSystemProcess();
        if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) == 0
                && options != null && ActivityOptions.fromBundle(options).getLaunchTaskId() == -1) {
            throw new AndroidRuntimeException(
                    "Calling startActivity() from outside of an Activity "
                    + " context requires the FLAG_ACTIVITY_NEW_TASK flag."
                    + " Is this really what you want?");
        }
        mMainThread.getInstrumentation().execStartActivity(
                getOuterContext(), mMainThread.getApplicationThread(), null,
                (Activity) null, intent, -1, options);
    }
```

`getInstrumentation()`去获取对应的`Instrumentation`不过这个是可以全局生效的，`ActivityThread`是主线程的管理类，`Instrumentation`是其成员变量，一个进程中只会存在一个`ActivityThread`，因此依然设置`Instrumentation`为Hook点。

可以在`Application`中或者`Activity`中去设置Hook方法

```java
public class App extends Application {

    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        replaceContextInstrumentation();
    }

    @Override
    public void onCreate() {
        super.onCreate();

    }

    public void replaceContextInstrumentation() {
        try {
           //获取ActivityThread类
            @SuppressLint("PrivateApi") Class<?> activityThreadClazz = Class.forName("android.app.ActivityThread");
            //获取其中的静态变量 sCurrentActivityThread 它对应着当前的ActivityThread对象
            Field activityThreadField = activityThreadClazz.getDeclaredField("sCurrentActivityThread");
            activityThreadField.setAccessible(true);
            //获取到 sCurrentActivityThread 对象
            Object currentActivityThread = activityThreadField.get(null);
            Field mInstrumentationField = activityThreadClazz.getDeclaredField("mInstrumentation");
            mInstrumentationField.setAccessible(true);
            Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(currentActivityThread);
            Instrumentation instrumentationProxy = new InstrumentationProxy(mInstrumentation);
            //执行替换操作
            mInstrumentationField.set(currentActivityThread, instrumentationProxy);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```



#### 可能出现的问题

1. 无法进行Hook操作

   ```xml
   E/Instrumentation: Uninitialized ActivityThread, likely app-created Instrumentation, disabling AppComponentFactory
   ```

   出现上述提示，发生的情况是在Android P上运行应用时。

   主要是因为在Android P的源代码中对`Instrumentation.newActivity()`进行了调整

   ```java
   private ActivityThread mThread = null;    
   public Activity newActivity(ClassLoader cl, String className,
             Intent intent)
             throws InstantiationException, IllegalAccessException,
                     ClassNotFoundException {
                 String pkg = intent != null && intent.getComponent() != null
                         ? intent.getComponent().getPackageName() : null;
                 return getFactory(pkg).instantiateActivity(cl, className, intent);
             }
          
             private AppComponentFactory getFactory(String pkg) {
                 if (pkg == null) {
                     Log.e(TAG, "No pkg specified, disabling AppComponentFactory");
                     return AppComponentFactory.DEFAULT;
                 }
                 
                 if (mThread == null) {
                     Log.e(TAG, "Uninitialized ActivityThread, likely app-created Instrumentation,"
                             + " disabling AppComponentFactory", new Throwable());
                     return AppComponentFactory.DEFAULT;
                 }
                 LoadedApk apk = mThread.peekPackageInfo(pkg, true);
                 // This is in the case of starting up "android".
                 if (apk == null) apk = mThread.getSystemContext().mPackageInfo;
                 return apk.getAppFactory();
             }
   ```

   因为只是hook了`execStartActivity()`而`newActivity()`就会抛出如上异常，解决方案就是在我们自定义的`InstrumentationProxy`中去重写`newActivity()`

   ```java
   public Activity newActivity(ClassLoader cl, String className,
                                   Intent intent)
               throws InstantiationException, IllegalAccessException,
               ClassNotFoundException {
   
           return mBase.newActivity(cl, className, intent);
       }
   ```

   

## 内容引用

[Android 9.0相关源码](http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/app/Instrumentation.java)

[Android插件化原理解析](http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/)

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式--静态代理模式和动态代理模式原理及实现</title>
    <url>/2018/04/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[
# 代理模式（委托模式）

> **为其他对象提供一种代理以控制对这个对象的访问**。引入**代理对象**来间接访问**目标对象**

{% fullimage /images/Pattern-Proxy.png,代理模式,代理模式 %}

代理模式优点：

- 职责清晰：真实的角色就是实现实际的业务逻辑，不需关心其他非本职责的事务
- 高扩展性：代理类可以在不做任何修改的情况下继续使用
- 智能化：动态代理演示

代理模式缺点：

1. 在客户端和真实对象之间添加了代理，会造成请求的处理速度变慢
2. 实现代理模式比较复杂，需要额外的工作

代理模式的扩展：

1. 普通代理

   > 客户端只能访问代理角色，而不能直接访问真实角色。

   ```java
   public class Client {
       public static void main(String[] args){
           //屏蔽了GamePlayer的真实角色访问
           GamePlayerProxy gamePlayerProxy = new GamePlayerProxy("wxy");
           gamePlayerProxy.login("wxy","124");
           gamePlayerProxy.killBoss();
           gamePlayerProxy.upgrade();
       }
   }
   ```

   Client只是调用了`GamePlayerProxy`代理角色，而不知道真实角色是谁。**非常适合扩展性要求较高的场景。**

2. 强制代理

   > 通过真实角色来找到代理角色，否则不能访问。**由真实角色来管理代理角色。不允许直接访问真实角色**

   ```java
   public class Client {
       public static void main(String[] args){
           //必须是真实角色的代理对象才可以使用
           IGamePlayer gamePlayerProxy = new GamePlayer("wxy").getProxy();
           //直接生成代理对象无效
           //GamePlayerProxy gamePlayerProxy = new GamePlayerProxy(new GamePlayer("wzr5"));
           gamePlayerProxy.login("wxy","124");
           gamePlayerProxy.killBoss();
           gamePlayerProxy.upgrade();
       }
   }
   ```

3. 代理是有个性的

   > 一个类可以实现多个接口，完成不同任务的整合。**代理类不仅可以实现主题接口，也可以实现其他接口完成不同的任务。**

4. **动态代理**

   > 不需要**显式实现与目标对象类相同的接口**，将这种实现推迟到程序运行时由JVM实现。

   原理：通过Java反射机制的`method.invoke()`调用动态代理类对象方法，从而自动调用目标对象的方法。

   优点：1. 只需要一个代理类就可以解决创建多个静态代理的问题，避免重复代码。2. 更加灵活

   缺点：1. 效率低 `需要通过反射机制，间接调用目标对象方法` 2.应用场景局限`只能针对接口创建代理类，即只能动态代理实现了接口的类`

   应用场景：

   - 需要代理对象数量较多的情况下使用

   - `AOP`-面向切面编程

     > 可以通过预编译的方式在运行期动态代理实现程序功能的统一维护，有效降低业务之间的耦合度，提供程序的可用性并提高了开发的效率。开发中主要用在日志收集，性能分析等。

   使用方法：

   1. 声明调用代理类

      ```java
      public class GamePlayIH<T> implements InvocationHandler {
          //被代理实例
          T obj ;
      
          public GamePlayIH(T _obj) {
              this.obj = _obj;
          }
      
          @Override
          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
              Object result = method.invoke(this.obj, args);
              return result;
          }
      }
      ```

   2. 声明目标对象类的抽象接口

      ```java
      public interface IGamePlayer {
          void login(String user, String pwd);
      
          void killBoss();
      
          void upgrade();
      }
      ```

   3. 声明目标对象类

      ```
      public class GamePlayer implements IGamePlayer {
          private String name = "";
      
          public GamePlayer(String _name) {
              this.name = _name;
          }
      
          @Override
          public void login(String user, String pwd) {
                  System.err.println("登录名为：" + user + "  用户名为：" + this.name + "登录游戏");
          }
      
          @Override
          public void killBoss() {
                 System.err.println(this.name + "打Boss");
          }
      
          @Override
          public void upgrade() {
                  System.err.println(this.name + "升级了");
          }
      }
      ```

   4. 通过动态代理对象，调用目标方法

      ```java
      public class Client {
          public static void main(String[] args) {
              //创建目标对象
              IGamePlayer player = new GamePlayer("wxy");
              //创建调用处理对象
              InvocationHandler handler = new GamePlayIH<>(player);
              //指定产生代理对象的类加载器
              ClassLoader cl = player.getClass().getClassLoader();
              //创建动态代理对象
              IGamePlayer gamePlayerProxy = (IGamePlayer) Proxy.newProxyInstance(cl, new Class[]{IGamePlayer.class}, handler);
              //调用动态代理对象方法
              gamePlayerProxy.login("wxy", "124");
              gamePlayerProxy.killBoss();
              gamePlayerProxy.upgrade();
          }
      }
      ```

`Proxy`：提供用于创建动态代理类和实例的静态方法，并且还是创建出代理类的超类。

`InvocationHandler`：调用处理器接口，自定义`invoke()`，用于实现对真正委托类的代理方法。**生成动态代理类实际调用的是`invoke()`。**]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>热修复基本原理</title>
    <url>/2018/04/07/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[
<!-- <blockquote class="blockquote-center">热修复主要用来解决线上出现大问题的一个补救方案。</blockquote> -->

> 目前流行的热修复方案主要有以下三种：
>
> - 代码修复
> - 资源修复
> - 动态链接库修复

本章主要讲述 第一种方案：**代码修复**。

## 代码修复

> 原理：对出现Bug的类进行修改或替换

### 类加载方案

> 核心思想：使用Android的类加载器，通过类加载器去加载已修复好Bug的Class并对有问题的Class进行覆盖。
>
> **加载完成后需要重启应用才可生效，因为当前在使用的类是无法卸载的即不可替换，只有重启后重新加载才可成功。**

#### 相关概念

- `65536限制`

  随着应用功能越来越复杂，代码量不断地增大，引入的库也会越来越多，可能导致出现异常

  ```
  com.android.dex.DexIndexOverflowException:method ID not in [0,0xffff]：65536
  ```

  应用中是限制了引用方法超过最大数65536个。限制是由于`DVM bytecode`的限制导致的，因为DVM指令集的方法调用指令`invoke-kind`索引最大值为16bits，故为65536个方法。

- `LinearAlloc限制`

  在安装应用时可能会提示`INSTALL_FAILED_DEXOPT`，产生的原因就是`LinearAlloc`限制，LinearAlloc是一个固定的缓存区，超出即会报错。

为了解决上述的两个问题，产生了**DEX分包方案**。主要在打包时将应用代码分成多个Dex，将应用启动时必须的类以及直接引用类放入主Dex中，其他代码放到次Dex中。*应用启动时就先去加载主Dex，然后动态加载次Dex，从而缓解上述限制*。

#### 原理分析

类加载方案需要通过`ClassLoader`的实现类完成。在Android中主要有两种类加载器：

- DexClassLoader

  > 继承自BaseDexClassLoader，支持加载包含classes.dex的jar、apk，zip文件，可以是SD卡的路径。是实现热修复的关键。**注意不要把优化后的文件放在外部存储，可能导致注入攻击。**

  ```java /libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java
  public class DexClassLoader extends BaseDexClassLoader{ 
  public DexClassLoader(String dexPath, String optimizedDirectory,
              String librarySearchPath, ClassLoader parent) {
          super(dexPath, null, librarySearchPath, parent);
      }
  }
  ```

- PathClassLoader

  > 用来加载Android系统类和应用程序的类，**在dalvik上只能加载已安装apk的dex(/data/app目录)，在ART虚拟机上则没有这个限制**。

  ```java /libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java
  public class PathClassLoader extends BaseDexClassLoader {
    public PathClassLoader(String dexPath, ClassLoader parent) {
        super(dexPath,null, null, parent);
    }
  
    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) {
        super(dexPath,null, librarySearchPath, parent);
    }
  }
  ```


##### 上述类加载器都继承自`BaseDexClassLoader`。

  ```java
  public class BaseDexClassLoader extends ClassLoader{
     private final DexPathList pathList;
     public BaseDexClassLoader(String dexPath, File optimizedDirectory,
              String librarySearchPath, ClassLoader parent) {
        super(parent);
        this.pathList = new DexPathList(this, dexPath, librarySearchPath, null);
       ...
     }
    
    ...
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        List<Throwable> suppressedExceptions = new ArrayList<Throwable>();
        //根据类名去找出对应的类文件
        Class c = pathList.findClass(name, suppressedExceptions);
        if (c == null) {
            ClassNotFoundException cnfe = new ClassNotFoundException(
                   "Didn't find class \"" + name + "\" on path: " + pathList);
            for (Throwable t : suppressedExceptions) {
                cnfe.addSuppressed(t);
            }
            throw cnfe;
        }
        return c;
    }
  }
  ```

  主要构造函数介绍：

  - `dexPath`：指`目标类所在的apk、dex或jar文件的路径，也可以是SD卡的路径`，类加载器从该路径加载目标类。如果包含多个路径，路径之间必须用特定的分隔符去分隔，特定的分隔符从`System.getProperty("path.separtor")`获取（默认分割符为":"）。最终将路径上的文件ODEX优化到optimizedDirectory，然后进行加载。
  - `optimizedDirectory`：解压出的dex文件路径，这个路径必须为内部路径，一般情况下的路径为`/data/data/<Package_Name>/`
  - `librarySearchPath`：存放目标类中使用的native文件库，也以":"分割
  - `parent`：父加载器，在Android中以`context.getClassLoader`作为父加载器。

> 在Android8.0之后，`optimizedDirectory`参数失效。由子类去控制解压文件路径。

`findClass()`用来加载dex中的Class文件。内部调用到`DexPathList.findClass()`实现

##### DexPathList

> 内部存储的是一个个的Dex文件地址，方便后续进行寻找调用



```java /libcore/dalvik/src/main/java/dalvik/system/DexPathList.java
final class DexPathList{
   private static final String DEX_SUFFIX = ".dex";
   private static final String zipSeparator = "!/";

    /** class definition context */
    private final ClassLoader definingContext;
    //存储dex文件
    private Element[] dexElements;
  
   public DexPathList(ClassLoader definingContext, String dexPath,
        String libraryPath, File optimizedDirectory) {
    ...
    this.definingContext = definingContext;
    this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,suppressedExceptions);
    ...
}

}
```

保存当前的类加载器`definingContext`，并调用`makeDexElements()`初始化Element数组。

```java
private static Element[] makeDexElements(ArrayList<File> files, File optimizedDirectory, ArrayList<IOException> suppressedExceptions) {
    // 1.创建Element集合
    ArrayList<Element> elements = new ArrayList<Element>();
    // 2.遍历所有dex文件（也可能是jar、apk或zip文件）
    for (File file : files) {
      if(file.isDirectory()){
        elements[elementsPos++] = new Element(file);
      }else if(file.isFile){
        String name = file.getName();
        ...
        // 如果是dex文件
        if (name.endsWith(DEX_SUFFIX)) {
          dex = loadDexFile(file, optimizedDirectory, loader, elements);
          if(dex!=null){
            elements[elementsPos++] = new Elements(dex,null);
          }
        // 如果是apk、jar、zip文件（这部分在不同的Android版本中，处理方式有细微差别）
        } else {
            DexFile dex = null;
          try{
            dex = loadDexFile(file, optimizedDirectory);
          }
            
        }
        ...
        // 3.将dex文件或压缩文件包装成Element对象，并添加到Element集合中
                if (dex == null) {
                    elements[elementsPos++] = new Element(file);
                } else {
                    elements[elementsPos++] = new Element(dex, file);
                }
      }
    }
    // 4.将Element集合转成Element数组返回
  if(elementsPos != elements.length){
    elements = Arrays.copyOf(elements,elementsPos);
  }
    return elements;
}
```

在`makeDexElement`中，将传入的文件(*Dex、apk、zip*)封装成一个个的`Element`对象，然后添加至Element集合中。

> 在Android的类加载器中，他们只会去解析`dex文件`。通过`loadDexFile()`就可以将其他类型的文件转换成`dex文件`以供加载。

`findClass()`：寻找类名相同的类并返回

```java
public Class findClass(String name, List<Throwable> suppressed) {
    for (Element element : dexElements) {
        // 遍历出一个dex文件
        DexFile dex = element.dexFile;

        if (dex != null) {
            Class clazz = element.findClass(name,definingContext,suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
    }
    if (dexElementsSuppressedExceptions != null) {
        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
    }
    return null;
}

static class Element{
  ...
     public Class<?> findClass(String name, ClassLoader definingContext,
                List<Throwable> suppressed) {
       //在dex文件中查找类名相同的类
       return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext,suppressed): null;
        }
  ...
}
```

在`findClass()`中，对Elements数组进行遍历，一旦找到与传入类名相同的类即返回。

> Element内部封装了DexFile，DexFile用于加载Dex文件，因此一个Element对象会对应一个Dex文件。多个Element组成了有序数组`dexElements`。需要查找类时便去遍历`dexElements`，再去调用`findClass()`查找类。在Dex中存储的是一堆Class文件，需要在dex文件中通过`loadClassBinaryName()`去找寻对应的Class文件。*如果没有找到就接着去下一个Element中寻找。*

##### 实现原理

经过上述的源码分析，加载一个类时都会从`dexElements`数组获取到对应的类之后再进行加载。遍历过程由数组头部开始。所以我们可以将已修复好的Class打包成一个Dex文件并放置到`dexElements`数组的第一个位置(*也解决了CLASS_ISPREVERIFIED问题，当打上该标记时该类就无法被替换*)，这样就可以保证已修复好的Class会被优先加载而排在数组后面的Bug类就不会被加载(**由于双亲委托机制**)。

> 双亲委托机制：如果一个类加载器收到了类加载的请求，不会自己去尝试加载这个类，而把这个请求委派给父类加载器去完成，每一层都是如此，依次向上递归，直到委托到最顶层的`Bootstrap ClassLoader`，若父加载器无法处理加载请求（它的搜索范围内没有找到所需的类时），则交由子加载器去加载。
>
> 双亲委托机制的好处：
>
> - 避免重复加载，若Class已被加载则从缓存中获取不会重新加载
> - 更加安全，例如`java.lang.Object`基础类的加载都需要最终委派到`BootstrapClassLoader`进行加载，即时去自定义类加载器进行加载也不会产生多个类。



{% fullimage /images/类加载方案.png,类加载方案,类加载方案%}

#### 修复实战

1. 制作一个有Bug的类

   ```java
   public BugActivity extends AppCompatActivity{
     @Override
       public void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           setContentView(R.layout.act_bug);
           Log.e("Bug", String.valueOf(2/0));
       }
   }
   ```

2. 制作一个Bug修复类

   ```java
   public BugActivity extends AppCompatActivity{
     @Override
       public void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           setContentView(R.layout.act_bug);
           Log.e("Bug", "fix");
       }
   }
   ```

3. 将Bug修复类`BugActivity.class`打包成dex(**DVM只能识别dex文件**)

   `rebuild project`之后在`build->intermediates->javac`可以找到对应的class文件。

   取出该class文件后(`取出时需要带上完整的包名路径`)，就需要通过`SDK/build-tools/XX/dx`将class文件转成dex文件

   ```shell
   //dex文件中放置着对应的class文件及其完整路径 
   Mac：sh dx --dex --output=../dex/classes2.dex ../dex
   Win: dx --dex --output=../dex/classes2.dex ../dex
   //执行完毕后就会生成对应的dex文件 --  classes2.dex
   ```

   此时就可以得到最终需要替换进去的dex文件。

4. 加载dex文件

   > 利用反射机制去修改`DexClassLoader`中的`dexElements`，需要把修复过后的`classes2.dex`插入到头部位置，保证可以优先加载。

   ```java
   public class FixDexUtil {
       //列出修复支持的文件格式
       private static final String DEX_SUFFIX = ".dex";
       private static final String APK_SUFFIX = ".apk";
       private static final String JAR_SUFFIX = ".jar";
       private static final String ZIP_SUFFIX = ".zip";
       
       private static final String DEX_DIR = "odex";
       
       private static final String OPTIMIZE_DEX_DIR = "optimize_dex";
       private static HashSet<File> loadedDex = new HashSet<>();
   
       static {
           //清理已存在的dex
           loadedDex.clear();
       } 
     
        /**
        * 加载补丁，使用默认目录：data/data/包名/files/odex
        *
        * @param context
        */
       public static void loadFixedDex(Context context) {
           loadFixedDex(context, null);
       }
   
       /**
        * 加载补丁
        *
        * @param context       上下文
        * @param patchFilesDir 补丁所在目录
        */
       public static void loadFixedDex(Context context, File patchFilesDir) {
           boolean canFix = false;
           // 遍历所有的修复dex , 因为可能是多个dex修复包
           File fileDir = patchFilesDir != null ?
                   patchFilesDir :
                   new File(context.getFilesDir(), DEX_DIR);// data/data/包名/files/odex（这个可以任意位置）
   
           File[] listFiles = fileDir.listFiles();
           if (listFiles != null && listFiles.length != 0)
               for (File file : listFiles) {
                   if (file.getName().startsWith("classes") &&
                           (file.getName().endsWith(DEX_SUFFIX)
                                   || file.getName().endsWith(APK_SUFFIX)
                                   || file.getName().endsWith(JAR_SUFFIX)
                                   || file.getName().endsWith(ZIP_SUFFIX))) {
   
                       loadedDex.add(file);// 存入集合
                       //有修复包的存在，意味需要修复
                       canFix = true;
                   }
               }
           // dex合并之前的dex
           if (canFix)
               doDexInject(context, loadedDex);
       }
     
      private static void doDexInject(Context appContext, HashSet<File> loadedDex) {
           String optimizeDir = appContext.getFilesDir().getAbsolutePath() +
                   File.separator + OPTIMIZE_DEX_DIR;
           // data/data/包名/files/optimize_dex（这个必须是自己程序下的目录）
   
           File fopt = new File(optimizeDir);
           if (!fopt.exists()) {
               fopt.mkdirs();
           }
           try {
               // 1.加载应用程序dex的Loader
               PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader();
               for (File dex : loadedDex) {
                   // 2.加载指定的修复的dex文件的Loader
                   DexClassLoader dexLoader = new DexClassLoader(
                           dex.getAbsolutePath(),// 修复好的dex（补丁）所在目录
                           fopt.getAbsolutePath(),// 存放dex的解压目录（用于jar、zip、apk格式的补丁）
                           null,// 加载dex时需要的库
                           pathLoader// 父类加载器
                   );
                   // 3.开始合并
                   // 合并的目标是Element[],重新赋值它的值即可
   
                   /**
                    * BaseDexClassLoader中有 变量: DexPathList pathList
                    * DexPathList中有 变量 Element[] dexElements
                    * 依次反射即可
                    */
   
                   //3.1 准备好pathList的引用
                   Object dexPathList = getPathList(dexLoader);
                   Object pathPathList = getPathList(pathLoader);
                   //3.2 从pathList中反射出element集合
                   Object leftDexElements = getDexElements(dexPathList);
                   Object rightDexElements = getDexElements(pathPathList);
                   //3.3 合并两个dex数组
                   Object dexElements = combineArray(leftDexElements, rightDexElements);
   
                   // 重写给PathList里面的Element[] dexElements;赋值
                   Object pathList = getPathList(pathLoader);// 一定要重新获取，不要用pathPathList，会报错
                   setField(pathList, pathList.getClass(), "dexElements", dexElements);
               }
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
   
       /**
        * 反射给对象中的属性重新赋值
        */
       private static void setField(Object obj, Class<?> cl, String field, Object value) throws NoSuchFieldException, IllegalAccessException {
           Field declaredField = cl.getDeclaredField(field);
           declaredField.setAccessible(true);
           declaredField.set(obj, value);
       }
   
       /**
        * 反射得到对象中的属性值
        */
       private static Object getField(Object obj, Class<?> cl, String field) throws NoSuchFieldException, IllegalAccessException {
           Field localField = cl.getDeclaredField(field);
           localField.setAccessible(true);
           return localField.get(obj);
       }
   
       /**
        * 反射得到类加载器中的pathList对象
        */
       private static Object getPathList(Object baseDexClassLoader) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
           return getField(baseDexClassLoader, Class.forName("dalvik.system.BaseDexClassLoader"), "pathList");
       }
   
       /**
        * 反射得到pathList中的dexElements
        */
       private static Object getDexElements(Object pathList) throws NoSuchFieldException, IllegalAccessException {
           return getField(pathList, pathList.getClass(), "dexElements");
       }
   
       /**
        * 数组合并
        */
       private static Object combineArray(Object arrayLhs, Object arrayRhs) {
           Class<?> clazz = arrayLhs.getClass().getComponentType();
           int i = Array.getLength(arrayLhs);// 得到左数组长度（补丁数组）
           int j = Array.getLength(arrayRhs);// 得到原dex数组长度
           int k = i + j;// 得到总数组长度（补丁数组+原dex数组）
           Object result = Array.newInstance(clazz, k);// 创建一个类型为clazz，长度为k的新数组
           System.arraycopy(arrayLhs, 0, result, 0, i);
           System.arraycopy(arrayRhs, 0, result, i, j);
           return result;
       }
     
   }
   ```

   该类中主要的功能：

   1. 获取对应目录中存在的`apk、dex、jar，zip`文件
   2. 将文件转换成`Element`格式并生成一个`elements`数组
   3. 将生成的数组与原先存在的`dexElements`数组进行合并
   4. 合并完成后利用**反射**将数组放置回`ClassLoader`中

   > 如果要加载的文件格式为`apk、jar，zip`需要进行一些特殊处理
   >
   > **这些文件格式中需要有一个`classes.dex`文件，不然会出错**

5. 进行检测以及修复工作

   ```java
   //在项目初始化时便去进行修复检测
   class MyApplication extends Application{
         @Override
       protected void attachBaseContext(Context base) {
           super.attachBaseContext(base);
           //提前进行初始化 提前至 onCreate()之前
           FixDexUtil.loadFixedDex(base, Environment.getExternalStorageDirectory());
       }
   }
   ```

6. 将修复好的`classes2.dex`文件放到对应的目录中，然后重新打开应用，重新观察结果即可。



### 底层替换方案

> 底层替换方案是在已经加载了的类中直接去替换原有方法，是在原来类的基础上进行修改。由于在原有类进行修改限制会比较多，且不能增减原有类的方法和字段，否则会破坏原有类的结构。**底层的替换方案还与反射有所关联。**

传统的底层替换方案，都是直接去修改虚拟机方法实现的具体字段。主要是去操作`ArtMethod`结构体，但是会存在兼容性问题，可能由于厂商对其进行了修改。

优化点就是 直接替换整个`ArtMethod`结构体，这样就不会存在兼容性的问题。

> `ArtMethod`：包含了Java方法的所有信息，包括执行入口、访问权限、所属类和代码执行地址等。

优点：**底层替换方案直接替换了方法，而且是立即生效不需要进行重启操作。**

### Instant Run方案

Instant Run的部署方式有以下三种：

- **Hot Swap**：`效率最高`。代码的增量改变不需要重启App，甚至Activity都不需要重启。修改一个现有方法中的代码多采用这种部署方式。
- **Warm Swap**：App不需要重启，但是Activity需要重启。修改或删除一个现有的资源文件时多采用这种部署方式。
- **Cold Swap**：App需要重启，但是不需要重新安装。添加、删除或修改一个字段和方法或者修改一个类等多采用这种部署方式。

{% fullimage /images/传统编译部署.webp,传统编译部署,传统编译部署%}

{% fullimage /images/Instant Run编译部署.webp,Instant Run编译部署,Instant Run编译部署%}

#### 工作原理

利用**ASM**在每一个方法中注入类似如下的代码：

```java
public interface IncrementalChange {
    Object access$dispatch(String id, Object... args);
}

//注入代码如下
IncrementalChange localIncrementalChange = $change;
if(localIncrementalChange!=null){
  localIncrementalChange.access$dispatch("");
    return;
}
```



`$change`指代了方法是否发生变化，如果发生变化就会调用到`access$dispatch()`生成对应的替换类`Class$override`替代执行原有方法，即完成了对原有方法的修改。



## 内容引用

《深入探索Android热修复技术原理》

《Android进阶解密》]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>WindowManagerService简析</title>
    <url>/2019/01/30/WindowManagerService%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
## WindowManagerService的职责

>  Window的相关操作都是借由`WindowManagerService`实现的，而且它是`WindowManager`的管理者。

### 1.窗口管理

负责窗口的启动、添加和删除。另外窗口的大小和层级也是交由WMS进行管理的。

核心成员：`DisplayContent、WindowToken，WindowState`。

### 2.窗口动画

窗口间进行切换时，窗口动画由WMS的动画子系统来负责，动画子系统的管理者为`WindowAnimator`。

### 3.输入系统的中转站

### 4.Surface管理



]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的GC分析-Dalvik和ART虚拟机</title>
    <url>/2018/05/13/Android%E4%B8%AD%E7%9A%84GC%E5%88%86%E6%9E%90-Dalvik%E5%92%8CART%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[
<!--如何对JVM进行优化 class文件如何转成dex文件-->

## Dalvik虚拟机

> `Dalvik Virtual Machine`，简称Dalvik VM或者 DVM。DVM是Google专门为Android平台开发的虚拟机，是Android的重要组成部分，支持`dex格式`的Java应用程序运行。
>
> `dex格式`是专门为DVM设计的一种压缩格式，适合内存和处理器速度有限的系统。

{% fullimage /images/Android系统架构图.jpg,Android系统架构图,Android系统架构图%}

从架构图中可知，DVM运行在Android的运行时库层。

### DVM与JVM的区别

#### 基于的架构不同

JVM是基于栈的，意味着需要去栈中读写数据，所需的指令会更多，会导致速度变慢，不适用于性能有限的移动设备。

DVM是基于寄存器的，不会有基于栈的虚拟机在复制数据时，使用大量的出入栈指令，同时指令更紧凑，简洁。

#### 执行的字节码不同

Java类被编译成一个或多个.class文件，并打包成jar文件，JVM通过对应的.class和jar文件获取相应的字节码。

**执行顺序为： .java文件 -> .class文件 -> .jar文件**

DVM运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个dex文件中。DVM通过dex文件执行字节码。

**执行顺序为： .java文件 -> .class文件 -> .dex文件**



**dex文件体积小。Android SDK中有一个`dx`工具将Java字节码转换为Dalvik字节码。**

dx工具对Java类文件重新排序，消除在类文件中出现的所有冗余信息，避免虚拟机在初始化时反复进行文件加载与解析。**消除其中的冗余信息，重新组合成一个常量池，所有类文件共享同一个常量池。由于dx工具对常量池的压缩，使得相同的字符串，常量在dex文件中只出现一次，从而减小文件体积。并把所有的.class文件整合到.dex文件中，减少了I/O操作，加快类查找速度。**

{% fullimage /images/执行的字节码区别.png,执行的字节码区别,执行的字节码区别%}

简单来讲，dex格式文件就是将多个class文件中共有的部分统一存放，取出冗余信息。

#### DVM允许在有限的内存中同时允许多个进程

在Android中的每一个应用都运行在一个DVM实例中，每一个DVM实例都运行在一个独立的进程空间中，独立的进程可以防止在虚拟机崩溃时导致所有程序关闭。

#### DVM由Zygote创建和初始化

每当系统需要创建一个应用程序时，Zygote就会fork自身，快速的创建和初始化一个DVM实例，用于应用程序的运行。

#### DVM拥有共享机制

不同应用之间可以在运行时共享相同的类，拥有更高的效率。JVM不支持这种共享机制，不同的程序都是彼此独立的。

#### JIT编译

`Just In Time Compiler`即时编译器，从Android2.2开始支持了`JIT`。

*JIT会对多次运行的代码进行编译，生成相当精简的本地机器码，这样在下次执行相同的逻辑时，直接使用编译之后的本地机器码，而不是每次都需要编译。*

**每次重新打开应用程序，都需要JIT编译。**



### DVM架构

DVM源码位于dalvik/目录下。

{% fullimage /images/DVM架构.png,DVM架构,DVM架构%}

首先Java编译器的.class文件经过`DX工具`转换为.dex文件，.dex文件由类加载器进行处理，接着解释器根据指令集对Dalvik字节码进行解释、执行，最后交于Linux处理。



### DVM运行时堆

DVM运行时堆使用**标记-清除**算法进行GC，它由两个Space以及多个辅助数据结构组成，两个Space分别是`Zygote Space(Zygote Heap)`和`Allocation Space(Active Heap)`。

`Zygote Space`用来管理Zygote进程在启动过程中预加载和创建的各种对象，`Zygote Space`不会触发GC。所有进程都共享该区域，比如系统资源。

`Allocation Space`是在Zygote进程fork第一个子进程之前创建的，它是一种私有进程，Zygote进程及fork的子进程在`Allocation Space`进行对象分配和释放。

还有以下数据结构：

`Card Table`：记录垃圾信息

`Heap Bitmap`：用来记录上次GC存活的对象，另一个用来记录这次GC存活的对象

`Mark Stack`：遍历存活的对象。



### DVM-GC过程

1. 当GC被触发的时候，会去查找所有活动的对象，这个时候整个程序与虚拟机内部的所有线程就会挂起，可以在较少的堆栈里找到所引用的对象。**回收动作和应用程序是同时执行的(非并发执行)。**
2. GC对符合条件的对象进行标记
3. GC对标记的对象进行回收
4. 恢复所有线程的执行现场继续执行

GC的执行会相当快速，但如果出现频繁GC并且内存资源少，就会导致UI卡顿，掉帧。因为是和应用程序同时执行的。

## ART虚拟机

> ART虚拟机是在Android4.4发布的，用来替换Dalvik虚拟机。5.0之后默认采用ART虚拟机。

### ART和DVM的区别

1. DVM每次运行应用时，字节码都需要JIT编译器译为机器码，会使得应用程序运行效率降低。在ART中采用**AOT(ahead of time Compilation，预编译)**，将字节码预先编译成机器码并存储在本地，这样应用程序每次运行就不需要执行编译了，大大提升运行效率。

   `AOT`优点：

   - 系统性能提升明显
   - 应用启动更快，体验更流畅
   - 设备的耗电量降低

   `AOT`缺点：

   - 使得应用程序安装时间变长，尤其是复杂的应用
   - 由于字节码预先编译成机器码，机器码需要的存储空间会多一些，会占用较多的存储空间

   在Android 7.0中加入了`JIT`，不会把字节码全部编译成机器码，而是在运行中将热点代码编译成机器码。从而缩短安装时间及减少安装空间。

2. DVM是为32位CPU设计的，而ART支持64位并兼容32位

3. ART对GC进行了改进，比如更频繁的执行并行垃圾收集，减少GC暂停次数

4. ART的运行时堆空间划分和DVM不同。

### ART的运行时堆

ART的GC类型有多种，主要分为`Mark-Sweep GC(标记-整理)`和`Compacting GC()`。ART运行时堆得空间根据不同的GC类型也有不同的划分，默认采用CMS方案。

{% fullimage /images/ART运行时堆.png,ART运行时堆,ART运行时堆 %}

### ART-GC过程 - 提高内存使用，减少碎片化

1. GC将会锁住Java堆，扫描并进行标记
2. 标记完毕释放Java堆的锁，并且挂起所有线程
3. GC对标记的对象进行回收
4. 恢复所有线程的执行线程继续运行
5. 重复步骤2-4直到结束

Art改善了GC过程：**将其非并发过程改成了部分并发，还有就是堆内存的重新分配管理。**



DVM内存管理特点：**内存碎片化严重，这也是由于标记-清除算法导致的。**

ART的解决方案：在ART中，它将Java分了一块空间`Large Object Space`，专门用来存放大对象。同时ART引入了`moving collector`技术，将不连续的物理内存块进行对其，对齐后碎片问题得到了很好的解决。

使用`Large Object Space`是因为`moving collector`对大块内存的位移时间过长，需要降低时间并提高内存利用率。



### Apk打包流程

{% fullimage /images/android_apk_build.png,android_apk_build,android_apk_build%}

根据流程图可知，apk打包流程分为7步：

1. 通过aapt打包res资源文件，生成`R.java、resource.asrc,res文件`
2. 处理.aidl文件，生成对应的Java接口文件
3. 通过Java Compiler编译R.java、Java源文件，生成.class文件
4. 通过 dx工具，将.class文件以及三方库中的.class文件合并生成 classes.dex
5. 通过apkbuilder工具，将aapt生成的resource.arsc和res文件、assets文件以及classes.dex一起打包生成apk
6. 通过Jarsigner工具，对上面的apk进行debug或release签名
7. 通过Zipalign工具，将签名后的apk进行对齐处理。(*帮助操作系统更高效率的根据请求索引资源，按着有利于系统处理的方式对apk征用的资源文件进行排列*)

### Apk安装流程

Apk开始安装时会执行以下几步：*(例如安装包名为 com.example.wxy 应用名为Demo的apk)*

- 解析APK中的`AndroidManifest.xml`，解析的内容会被存储到`/data/system/packages.xml`和`/data/system/package.list`中。

- `packages.list`中会指名了该apk包应用的默认存储的位置`/data/data/com.example.wxy`,`package.xml`会包含该应用申请的全新，签名和代码所在位置等信息

  ```xml
  /data/system/packages.list
  com.example.wxy.ipc 10021 1 /data/user/0/com.example.wxy.ipc default:targetSdkVersion=28 3003
  ```

  ```xml
   /data/system/packages.xml   
  <package name="com.example.wxy.ipc" codePath="/data/app/com.example.wxy.ipc-OTMEWujgopdNrmJevxTbaA==" nativeLibraryPath="/data/app/com.example.wxy.ipc-OTMEWujgopdNrmJevxTbaA==/lib" publicFlags="810073926" privateFlags="0" ft="1673c5a86e8" it="1673ae27837" ut="1673c5a8ab8" version="1" userId="10021">
          <sigs count="1" schemeVersion="2">
              <cert index="15" />
          </sigs>
          <perms>
              <item name="android.permission.INTERNET" granted="true" flags="0" />
              <item name="android.permission.ACCESS_NETWORK_STATE" granted="true" flags="0" />
              <item name="com.example.wxy.permission.checkBook" granted="true" flags="0" />
          </perms>
          <proper-signing-keyset identifier="16" />
      </package>
  ```

  标记了一个`userId`，Android系统可以利用该值来管理应用

- 根据`packages.xml`指定的`codePath`，创建一个目录，apk被命名为`base.apk`并拷贝到此，其中lib目录用在存放native库。

- 此时应用就可以运行了。为了提升效率，Android系统在应用安装时还会做些优化操作，把所有可运行的dex文件单独提取放在一块并做些优化。

  - 在DVM时，会使用dexopt把base.apk中的dex文件优化为odex，存储在`/data/dalvik-cache`中.
  - 在ART时，则会使用dex2oat优化成oat文件也存储在该目录下，并且文件名一样，但是文件会大很多，因为ART会把dex优化成机器码，所以运行更快。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序算法介绍</title>
    <url>/2018/03/20/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[# 基础排序算法介绍
## 知识点:
- 排序算法稳定性的定义：简单的介绍就是排序前相等的数据先后顺序在排序后的先后顺序位置相同
- 基本交换算法
```java
    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
```
- 时间复杂度：执行算法所需要的计算工作量 $ O(1) $ 意味没有循环即只执行单条语句 $ O(n) $ 执行没有嵌套的循环 $ O(n^2) $ 双重嵌套循环
- 空间复杂度：算法在运行工程中临时占用存储空间的量度

算法 | 平均时间 | 最好 | 最差  | 空间复杂度 | 稳定性
- | :-: | :-: | :-: | :-: | :-: | :-: | -: 
  冒泡排序| $ O(n^2) $ | $ O(n) $ | $ O(n^2) $ | $ O(1) $ | 稳定
  直接插入排序| $ O(n^2) $ | $ O(n) $ | $ O(n^2) $ | $ O(1) $ | 稳定
  折半插入排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(n^2) $ | $ O(1) $ | 稳定
  希尔排序| $ O(nlogn) $ - $ O(n^2) $ | $ O(n^1.3) $ | $ O(n^2) $ | $ O(1) $ | 不稳定
  选择排序| $ O(n^2) $ | $ O(n^2) $ | $ O(n^2) $ | $ O(1) $ | 不稳定
  快速排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(n^2) $ | $ O(nlogn) $ - $ O(n^2) $ | 不稳定
  归并排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(nlogn) $ | $ O(n) $ | 稳定
  堆排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(nlogn) $ | $ O(1) $ | 不稳定

## 排序算法
### 冒泡排序
> 在要排序的一组数中，对当前范围内还未排列好的数据由上而下进行比较，即每当相邻的数与要求的排序方式相反时将数据进行互换
> 改进版的写法就是利用标记法减少循环次数

> 基本写法
```java
private static void bubbleSort(int[] array) {
        int size = array.length;
        for (int i = 0; i < size - 1; i++) {
            for (int j = 1; j < size - i; j++) {
                if (array[j - 1] > array[j]) {
                    swap(array, j, j - 1);
                }
            }
        }
    }
```
> 改进写法
```java
private static void advancedBubbleSort(int[] array) {
        int size = array.length;
        int flag = 0;//设置标记位
        for (int i = 0; i < size - 1; i++) {
            flag = 0;
            for (int j = 1; j < size - i; j++) {
                if (array[j - 1] > array[j]) {
                    flag = 1;
                    swap(array, j, j - 1);
                }
            }
            if (flag == 0)//没有发生数据交换则意味着排序已经结束
                break;
        }
    }
```
----
### 选择排序
> 再一次遍历过程中找到最小值放在排序数据中的首位，每次寻找剩余中最小的直到结束为止。

```java
private static void selectSort(int[] array) {
        int size = array.length;
        for (int i = 0; i < size; i++) {
            int minIndex = i;
            for (int j = i + 1; j < size; j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            swap(array, i, minIndex);
        }
    }
```
----
### 直接插入排序
> 按照顺序选定元素从后往前找，插入一个顺序数列中即可

```java
 private static void InsertSort(int[] array) {
        int size = array.length;
        for (int i = 0; i < size; i++) {
            int temp = array[i];
            for (int j = i; j > 0 && array[j - 1] > array[j]; j--) {//从该元素所在位置 向前移动 直到该元素位于 递增顺序
                array[j] = array[j - 1];
                array[j - 1] = temp;
            }
        }
    }
```
----
### 折半插入排序
> 再往前寻找位置的过程中利用二分法寻找位置

```java
private static void insertBinarySort(int[] array) {
        int size = array.length;
        for (int i = 1; i < size; i++) {
            if (array[i] < array[i - 1]) {//前比后大
                int temp = array[i];
                int low = 0, high = i - 1, mid;
                while (low <= high) {//直到相交或者相反
                    mid = (low + high) / 2;//折中取点
                    if (temp < array[mid]) {//小于中点则位于中点左侧
                        high = mid - 1;
                    } else {
                        low = mid + 1;
                    }
                }
                for (int j = i; j > low; j--) {
                    array[j] = array[j - 1];
                }
                array[low] = temp;//低点使用temp
            }
        }
    }
```
----
### 希尔排序
> 先取`d`为间隔，将原始数组分为d个序列，将间隔的数组放在一个子序列利用插入排序法进行排序 然后缩小间隔`d` 重复上述操作，知道`d`为1时，则排序完成

```java
private static void shellSort(int[] array) {
        int size = array.length;
        for (int d = size / 2; d > 0; d /= 2) {//设置步长
            for (int i = 0; i < size; i += d) {
                int temp = array[i];
                int j = i;
                for (; j >= d && temp < array[j - d]; j -= d) {
                    array[j] = array[j - d];
                }
                array[j] = temp;
            }
        }
    }
```
----
### 基数排序
> 讲一组元素进行桶分配，按照每位数的大小进行排序

```java
    private static void radixSort(int[] array) {
        int size = array.length;
        int max = array[0];//数组中的最大数
        for (int i = 0; i < size; i++) {
            if (array[i] > max)
                max = array[i];
        }

        int time = 0;//最大位数
        while (max > 0) {
            max /= 10;
            time++;
        }

        int k = 0;//索引
        int m = 1;//位值
        int n = 1;//第几位

        int[][] temp = new int[10][size];
        int[] order = new int[10];

        while (m <= time) {
            for (int arr : array) {
                int lsd = (arr / n) % 10;
                temp[lsd][order[lsd]] = arr;
                order[lsd]++;
            }

            for (int i = 0; i < 10; i++) {
                if (order[i] != 0) {
                    for (int j = 0; j < order[i]; j++) {
                        array[k] = temp[i][j];
                        k++;
                    }
                }
                order[i] = 0;
            }

            n *= 10;
            k = 0;
            m++;
        }
    }
```
----
### 快速排序
> 通过排序将待排序记录分成两部分，其中一部分记录的关键字均比另一部分小，然后分别对这两部分进行排序，直到整个序列有序。**快速排序在元素很少时，效率很低**

```java
private static void quickSort(int[] arr,int l,int r){
    if(l>=r)
        return;
    int p=getMiddle(arr,l,r);//取出中点
    quickSort(arr,l,p-1);//对左侧进行排序
    quickSort(arr,p+1,r);//对右侧进行排序
}

    private static int getMiddle(int[] arr, int l, int r) {
        int temp = arr[l];//定义左侧为基点
        int middle = l;
        for (int i = middle + 1; i <= r; i++) {
            if (arr[i] < temp) {
                swap(arr, middle + 1, i);
                middle++;
            }
        }
        swap(arr, l, middle);
        return middle;
    }
```

----

### 归并排序

> 把待排序序列分成若干个有序子序列，然后再把子序列合并成一个有序序列。

```java
    private static void mergeSort(int[] arr, int l, int r) {
        int mid = (l + r) / 2;
        if (l < r) {
            mergeSort(arr, l, mid);
            mergeSort(arr, mid + 1, r);
            merge(arr, l, mid, r);
        }
    }

    private static void merge(int[] arr, int low, int mid, int high) {
        int[] temp = new int[high - low + 1];
        //左指针
        int i = low;
        //右指针
        int j = mid + 1;
        int index = 0;
        //把较小的数 移动到新数组中
        while (i <= mid && j <= high) {
            if (arr[i] < arr[j]) {
                temp[index++] = arr[i++];
            } else {
                temp[index++] = arr[j++];
            }
        }
        //把左边剩余的数移到新数组中
        while (i <= mid) {
            temp[index++] = arr[i++];
        }
        //把右边剩余的数移到新数组中
        while (j <= high) {
            temp[index++] = arr[j++];
        }
        //得到新的数据 覆盖原有部分
        System.arraycopy(temp, 0, arr, low, temp.length);
    }
```

----

### 堆排序

> 将数组构成大堆二叉树，即父节点比子节点大的二叉树，然后每次将根节点放在最后一位，循环遍历

```java
    /**
     * 堆排序
     * @param arr
     */
    private static void heapSort(int[] arr) {
        //预先构建一次大堆二叉树
        buildMaxHeap(arr);
        int length = arr.length;
        for (int i = length - 1; i > 0; i--) {
            swap(arr, 0, i);
            maxHeap(arr, i, 0);
        }
    }
    /**
     * 
     */
    private static void buildMaxHeap(int[] arr) {
        int length = arr.length;
        for (int i = length / 2 - 1; i >= 0; i--) {
            maxHeap(arr, length, i);
        }
    }
    
    /**
     * 构建大堆二叉树节点
     */
    private static void maxHeap(int[] arr, int length, int node) {
        int left = 2 * node + 1;
        int right = 2 * node + 2;

        int maxIndex = node;
        if (left < length && arr[left] > arr[maxIndex]) {
            maxIndex = left;
        }
        if (right < length && arr[right] > arr[maxIndex]) {
            maxIndex = right;
        }
        //如果不是父节点最大，则找到最大的子节点进行调换
        if (maxIndex != node) {
            swap(arr, node, maxIndex);
            maxHeap(arr, length, maxIndex);
        }

    }
```

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式--基本原则</title>
    <url>/2018/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[


{% fullimage /images/设计模式-基本原则.png,设计模式-基本原则,设计模式-基本原则%}

## 单一职责原则（SRP）

> 单一职责原则英文名称为`Single Responsibility Principle`,简称SRP。

优点：

- 类的复杂性降低，实现什么职责都有清晰明确的定义
- 可读性提高，复杂性降低
- 可维护性高

对于开发过程来说，**接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化**。

## 里氏替换原则（LSP）

> 所有引用父类的地方都必须能透明的使用其子类的对象。简单的说就是 **父类能出现的地方子类就可以出现。**

里氏替换原则为良好的继承定义了一个规范，主要包含了4个含义：

- **子类必须完全实现父类的方法**：`如果子类不能完整的实现父类的方法，或者父类方法在子类中已无法实现，建议断开父子继承关系，采用依赖、聚集，组合等方法代替继承。`
- **子类可以有自己的个性**：`里氏替换原则可以正着用，但不能反过来用。子类出现的地方，父类未必可以使用。`
- **覆盖或实现父类的方法时输入参数可以被放大**：`子类中的方法前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松。`
- **覆写或实现父类的方法时输出结果可以被缩小**

在开发过程中尽量避免子类的”个性“，有了之后，与父类的关系就难调和。

## 依赖倒置原则（DIP）

> - 高层模块不应该依赖低层模块，两者都应该依赖其抽象
> - 抽象不应该依赖细节
> - 细节应该依赖于抽象
>
> **面向接口编程**

本质就是通过抽象（接口或者抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的送耦合。

## 接口隔离原则（ISP）

> 接口分为两种：实例接口 和 类接口
>
> 接口尽量细化，同时接口中的方法要尽量少。尽量使用多个专门的接口。

接口隔离原则是对接口进行规范约束，包含以下4层含义：

- 接口要尽量小 **不能违反单一职责原则**
- 接口要高内聚：`高内聚就是提高接口、类，模块的处理能力，减少对外的交互`
- 定制服务：**只提供访问者需要的方法，减少可能引起的风险**
- 接口设计是有限度的：`接口的设计粒度越小，系统越灵活，但是会增加结构复杂度以及开发难度`

在开发过程中可以按照如下规则设计：

- 一个接口只服务于一个子模块或业务逻辑
- 通过业务逻辑压缩接口中的public方法
- 已经被污染的接口尽量去修改
- 根据每个项目或产品去制定拆分标准

## 迪米特法则（LoD）--最少知识原则(LKP)

> 一个对象应该对其他对象有最少的了解

迪米特法则对类的低耦合提出了明确的要求，包含以下4个含义：

- 只和朋友交流：**在类的一个方法中尽量不引入一个类中不存在的对象**
- 朋友间也是有距离的：**尽量不对外公布太多的public方法和非静态的public变量，尽量内敛**
- 是自己的就是自己的：**如果一个方法放在本类中，既不增加类间关系，也不会对本类产生负面影响，就可以放置在本类中**
- 谨慎使用Serializable：**在进行传输对象时需要进行序列化，当修改了属性时，会导致反序列化失败**

迪米特法则核心观念就是**类间解耦，弱耦合**。

## 开闭原则（OCP）—最基础的原则

> 软件实体应该对扩展开放，对修改关闭。`一个软件实体应该通过扩展来实现变化，而不是去修改已有代码。`

**开闭原则并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合**

开闭原则的重要性：

- 减少测试工作量
- 提高复用性
- 提高可维护性
- 面向对象开发

]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式--装饰模式</title>
    <url>/2019/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[
> 动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更加灵活。

{% fullimage /images/装饰模式UML.png,装饰模式UML,装饰模式UML%}

### 装饰模式-组成

`Component抽象构件`

> component是一个接口或者抽象类，定义了我们最核心的对象，也就是最原始的对象。

```java
public abstract class Component{
  //抽象方法
  public abstract void operate();
}
```

`ConcreteComponent具体构件`

> `ConcreteComponent`是最核心、最初始，最基本的接口或者抽象类的实现，需要装饰的就是这个对象。

```java
public class ConcreteComponent extends Component{
  @Override
  public void operate(){
     // do somethins
  }
}
```

`Decorator装饰角色`

> 一般为一个抽象类，`用于实现一个接口或者抽象方法`。在它的属性里面必然有一个`private`变量指向`Component`。

```java
public abstract class Decorator extends Component{
  private Component component = null;
  //构造带有修饰者的函数
  public Decorator(Component _component){
    this.component= _component;
  }
  
  @Override
  public void operate(){
    this.component.operate();
  }
}
```

`ConcreteDecorator具体装饰角色`

> 具体的装饰类。需要把核心的东西装饰成其他东西。

```java
public class ConcreteDecorator extends Decorator{
  public ConcreteDecorator (Component _component){
    super(_component);
  }
  
  private void method(){
    // 为Component拓展方法
  }
  
  public void operate(){
    this.method();
    super.operate();
  }
}
```



实际调用场景

```java
public class Client{
  public static void main(String[] args){
    Component component = new ConcreteComponent();
    //进行装饰
    component = new ConcreteDecorator(component);
    //调用修饰后对象方法
    component.operate();
  }
}
```

### 装饰模式-优点

- 装饰类和被被装饰类可以独立发展，而不会相互耦合。
- 装饰模式是继承关系的一个替代方案。实现`is-a关系(类的父子继承关系)`
- 装饰模式可以动态地拓展一个实现类的功能。**符合 开闭原则。**

### 装饰模式-缺点

**多层的装饰是比较复杂的。**需要减少装饰类的数量，以便降低系统的复杂度。

### 装饰模式-使用场景

- 需要扩展一个类的功能，或者给一个类增加附加功能
- 需要动态地给一个对象增加功能，这些功能也可以动态的进行撤销
- 需要为一批兄弟类进行改装或加装功能]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式--责任链模式</title>
    <url>/2019/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[
> 使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链路传递，直到有对象处理请求为止。

{% fullimage /images/责任链模式UML.png,责任链模式UML,责任链模式UML%}

### 责任链模式-定义

`Handler`：*抽象处理者* 该角色对请求进行抽象，并定义一个方法来设定和返回对下一个处理者的引用。

```java
public abstract class Handler{
  private Handler nextHandler;
  
  public abstract void handleRequest();
  
  public Handler getNextHandler(){
    return this.nextHandler;
  }
  
  public void seNextHandler(Handler _handler){
    this.nextHandler= _nextHandler;
  }
}
```

抽象处理者实现两个职责：

- 定义一个请求的处理方法`handleRequest()`
- 定义一个责任链的编排方法`setNextHandler()`，设置下一个处理者

`ConcreteHandler`：*具体处理器者 该角色接到请求后，可以选择将请求处理掉，或者将请求传给下一个处理者。`由于具体矗立着持有对下一个处理者的引用，因此，如果需要，处理者可以访问下一个访问者`。

```java
public class ConcreteHandler extends Handler{
  @Override
  public void handleRequest(){
    System.out.println(this.toString()+"处理器已处理");
    if(getNextHandler()!=null){
      //转移到下一个处理器处理
      getNextHandler().handleRequest();
    }else{
      //如果没有下一个则本身处理请求
      ...
    }
  }
}
```

具体处理者负责处理请求`handleRequest()`如果存在下一节点可以向下传递。

```java
public class Client {
  public static void main(String[] args){
    Handler h1 = new ConcreteHandler();
    Handler h2 = new ConcreteHandler();
    h1.setNextHandler(h2);
    h1.handleRequest();
  }
}
```

### 责任链模式-优点

- 责任链模式将请求和处理分开。请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌。**提高系统灵活性。**

### 责任链模式-缺点

- **性能降低。**每个请求都是从链头遍历到链尾，特别是在链比较长的时候。
- **不易于调试。**链条比较长，环节比较多的时候，由于采用了类似递归的方式，调试时会比较复杂。

### 责任链模式-使用注意事项

**链中节点数量需要控制，避免超长链的情况。**

一般做法是在`Handler(抽象处理者)`中设置一个最大节点数量，在`setNextHandler()`中判断是否已经超过最大值，超过则拒绝建立链，避免过量节点。

### 责任链模式-应用场景

- 一个请求需要一系列的处理工作。
- 业务流的处理，例如文件审批。
- 对系统进行拓展扩充。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>进程保活介绍</title>
    <url>/2018/04/12/%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[# 进程保活

{% fullimage /images/进程保活.png,进程保活,进程保活%}

进程保活的方式分为两个层面：`提高进程优先级，降低被杀死的概率`,`在进程被杀死后，进行拉活`。
## 1. 进程的优先级
  {% fullimage /images/study_plan/process_level.webp, alt,进程优先级 %}

 `优先级最低的进程首先被杀死、进程的等级会因为其他进程的依赖而提高一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低` 

按重要性分类：

- **前台进程**：进程持有一个正在与用户交互的Activity或者和交互Activity绑定的Service，前台运行的Service（执行`startForeground()`）,执行`onReceive()`的BroadcastReceiver
- **可见进程**：进程持有一个被用户可见但没有显示在最前端的Activity(调用到了`onPause()`)或者和可见Activity绑定的Service
- **服务进程**：进程持有一个`startService()`启动的Service进程，例如播放音乐，下载文件等Service
- **后台进程**：进程持有一个用户不可见的Activity(调用到`onStop()`没有到`onDestroy()`)，进程被存放在一个LRU列表中，即很长时间没用的Activity会被优先杀死
- **空进程**：进程不包含任何活跃的应用组件，唯一的作用是`为了缓存需要，缩短下次启动的时间`


## 2. Android进程回收策略
对于进程的回收，依靠LowmemoryKiller完成，按照OOM_ADJ的阈值级别触发对应的内存回收。
 {% fullimage /images/study_plan/oom_adj.webp, alt,流程图 %}
红色代表易被杀死的进程，绿色不易被杀死。LowmemoryKiller会优先杀死OOM_ADJ较大的进程，优先级相同则进一步受到进程所占内存和进程存活时间的影响。

## 3. 提升进程优先级
- **利用Activity提升权限**：`监控手机锁屏解锁事件，在屏幕锁定时启动一个一像素的Activity，解锁时销毁。`**需把Activity设置成用户无感知**
- **利用Notification提升权限**：`Service的优先级为4，使用setForeground可以设置前台Service，提升进程的优先级，降低被杀的概率。`
	- **注意点**：设置为前台Service时，在通知栏会显示一条通知。
	-  **应对措施**：可以去实现一个内部Service，在LiveService和其内部Service中同时发送相同ID的Notification，然后结束内部Service。内部Service被结束时，Notification也会消失，但是进程的优先级不会发生变化。

## 4. 进程死后拉活的方案
- **利用系统广播拉活**：在发生特定事件是，系统会发送相应的广播，可以在AndroidManifest中静态注册对应的广播监听器，即可在对应事件发生时拉活应用。以下是常见的拉活广播事件：
	- 开机广播：RECEIVE_BOOT_COMPLETED
	- 网络变化：CHANGE_NETWORK_STATE,CHANGE_WIFI_STATE…
	- 文件挂载：MOUNT_UNMOUNT_FILESYSTEMS
	- 屏幕亮灭：SCREEN_ON,SCREEN_OFF
	- 锁屏解锁：RECEIVE_USER_PRESENT
	- 应用安装卸载：PACKAGE_ADDED,PACKAGE_REMOVED
	缺点：
	- 广播接收器容易被系统的管理软件通过“自启管理”禁用场景，从而无法处理
	- 系统广播事件不可控，只能保证有对应事件是拉活进程，但不能保证能否立即拉活。
- **利用第三方应用广播拉活**：该方案接受第三方应用的广播，反编译一些第三方应用，找到他们发送的广播，在自己应用内进行监听，当这些应用发送广播时，即可拉活自己的应用。
	缺点：
	-  需要反编译较多应用来确保效果
	-  第三方应用的广播可能会在日后更新中修改或删除
- **利用系统Service机制拉活**：把Service设置为`START_STICKY`，这个参数可以在Service被杀死后，利用系统机制尝试拉活。
	缺点：
	- Service第一次被异常杀死后会在5秒内重启，第二层被杀死10秒内重启，第三次会在20秒内重启，一旦被杀死达到5次，则系统不会再重新拉活。
	- 进程被Root权限的工具杀死活forcestop，无法重启。
- **利用Native进程拉活**：利用Linux中的fork机制创建Native进程，在Native进程中监控主进程的存活，当主进程挂掉后，在Native进程中立即对主进程拉活。（该进程的生命周期不受Android的管理）。
	适用范围：
	- 在Android5.0以下版本手机效果很好，不受forcestop影响
	- 在5.0以上的手机，Native进场也会被forcestop杀死，假如逻辑跑的比系统快，依然可以拉活。
- **利用JobScheduler机制拉活**：系统在Android5.0以上版本提供了JobScheduler接口，系统会定时调用该进程使应用处理一些操作。
	适用范围：Android5.0以上系统手机，在部分小米手机可能无法拉活。
	```java
	@TargetApi(Build.VERSION_CODES.LOLLIPOP)
	public class KeepLiveService extends JobService {
	    
	    private final static String TAG="KeepLive";
	    
	    private volatile static Service mKeepLiveService= null;
	    
	    @Override
	    public boolean onStartJob(JobParameters jobParameters) {
	        return false;
	    }

	    @Override
	    public boolean onStopJob(JobParameters jobParameters) {
	        return false;
	    }
	}
	```
	```java
	public void startJobscheduler(){
	        try {
	            int jobId=1;
	            JobInfo.Builder builder=new JobInfo.Builder(jobId,
	                    new ComponentName(MyApplication.getApplicationContext(),
	                            KeepLiveService.class));
	            builder.setPeriodic(10);//设置时间间隔
	            builder.setPersisted(true);//重启后需要继续执行
	            JobScheduler js = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);
	            js.schedule(builder.build());
	        }catch (Throwable e){
	            e.printStackTrace();
	        }
	    }
	```

- **利用账号同步进制拉活**：Android系统的账号同步进制会定期同步执行，可以利用同步机制进行进程的拉活。
	适用范围：适用于所有的Android版本，在Android N中进行了一些变动，该方案失效。
- **其他方案**：
	- 利用系统通知权限进行拉活
	- 利用辅助功能拉活，将应用加入厂商白名单
	- 利用推送进行拉活（如小米、华为推送）]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>include、merge及ViewStub相关</title>
    <url>/2019/01/03/include%E3%80%81merge-ViewStub%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[
# 主要解析include、merge及ViewStub

{% fullimage /images/布局优化之xml方面.png,布局优化之xml方面,布局优化之xml方面%}

## include

> 主要为了解决重复定义相同布局的问题。把一套布局封装起来，需要使用时使用<include/>标签引入。提高代码复用性
>
> 使用注意事项：
>
> 1. 如若我们在<include/>中设置了android:id属性，这个id会覆盖原先`<include/>中layout设置的布局id，所以在引用该id时需要注意
> 2. 如果需要在<include/>中需要使用andrdoid:**属性，必须要设置layout_width以及layout_height属性

源码分析：

从Activity创建开始，调用`setContentView()`传入对应xml文件，然后开始解析并绘制。

```java
// ../android/app/Activity.java
public void setContentView(@LayoutRes int layoutResID){
  //getWindow() 对应的就是PhoneWindow 
  getWindow().setContentView(layoutResID);
  initWindowDecorActionBar();
}

// ../com/android/internal/policy/PhoneWindow.java
    @Override
    public void setContentView(int layoutResID) {
        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
        // decor, when theme attributes and the like are crystalized. Do not check the feature
        // before this happens.
        if (mContentParent == null) {
            //初始化 DecorView
            installDecor();
        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            mContentParent.removeAllViews();
        }

        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                    getContext());
            transitionTo(newScene);
        } else {
           //渲染传进来的xml
            mLayoutInflater.inflate(layoutResID, mContentParent);
        }
        mContentParent.requestApplyInsets();
        final Callback cb = getCallback();
        if (cb != null && !isDestroyed()) {
            cb.onContentChanged();
        }
        mContentParentExplicitlySet = true;
    }

// ../android/view/LayoutInflater.java
    public View inflate(XmlPullParser parser, @Nullable ViewGroup root) {
        return inflate(parser, root, root != null);
    }

    public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
        final Resources res = getContext().getResources();
        final XmlResourceParser parser = res.getLayout(resource);
        try {
            return inflate(parser, root, attachToRoot);
        } finally {
            parser.close();
        }
    }

    public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
        synchronized (mConstructorArgs) {
          ...
            final String name = parser.getName();
            //如果是merge标签
            if (TAG_MERGE.equals(name)) {
                    if (root == null || !attachToRoot) {
                        throw new InflateException("<merge /> can be used only with a valid "
                                + "ViewGroup root and attachToRoot=true");
                    }

                    rInflate(parser, root, inflaterContext, attrs, false);
            } else {
              ...
                    rInflateChildren(parser, temp, attrs, true);
            }
          ...
        }
    }

//解析所有子控件
    final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,
            boolean finishInflate) throws XmlPullParserException, IOException {
        rInflate(parser, parent, parent.getContext(), attrs, finishInflate);
    }

    void rInflate(XmlPullParser parser, View parent, Context context,
            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {

        final int depth = parser.getDepth();
        int type;
        boolean pendingRequestFocus = false;

        while (((type = parser.next()) != XmlPullParser.END_TAG ||
                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {

            if (type != XmlPullParser.START_TAG) {
                continue;
            }

            final String name = parser.getName();
            
            if (TAG_REQUEST_FOCUS.equals(name)) {
                pendingRequestFocus = true;
                consumeChildElements(parser);
            } else if (TAG_TAG.equals(name)) {
                parseViewTag(parser, parent, attrs);
              //解析到<include>标签
            } else if (TAG_INCLUDE.equals(name)) {
                if (parser.getDepth() == 0) {
                    throw new InflateException("<include /> cannot be the root element");
                }
               //解析include中包含的布局
                parseInclude(parser, context, parent, attrs);
            } else if (TAG_MERGE.equals(name)) {
                throw new InflateException("<merge /> must be the root element");
            } else {
                final View view = createViewFromTag(parent, name, context, attrs);
                final ViewGroup viewGroup = (ViewGroup) parent;
                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
                rInflateChildren(parser, view, attrs, true);
                viewGroup.addView(view, params);
            }
        }

        if (pendingRequestFocus) {
            parent.restoreDefaultFocus();
        }

      //当系统解析完View之后调用
        if (finishInflate) {
            parent.onFinishInflate();
        }
    }

    private void parseInclude(XmlPullParser parser, Context context, View parent,
            AttributeSet attrs) throws XmlPullParserException, IOException {
      // include标签必须在ViewGroup中使用
      if (parent instanceof ViewGroup) {
         ...
           //解析android:layout 属性
           int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);
            if (layout == 0) {
                final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
                if (value == null || value.length() <= 0) {
                    throw new InflateException("You must specify a layout in the"
                            + " include tag: <include layout=\"@layout/layoutID\" />");
                }
                layout = context.getResources().getIdentifier(
                        value.substring(1), "attr", context.getPackageName());

            }
        
        if (layout == 0) {
            final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
            throw new InflateException("You must specify a valid layout "
                        + "reference. The layout ID " + value + " is not valid.");
            } else {
          if (TAG_MERGE.equals(childName)) {
              rInflate(childParser, parent, context, childAttrs, false);
          } else {
             //继续渲染子布局
              rInflateChildren(childParser, view, childAttrs, true);
              //覆盖原有id
              if (id != View.NO_ID) {
                      view.setId(id);
              }
           }
          ...
          group.addView(view);
        }
      }
    }
```

若存在`<include>`标签，会去解析`<include>`标签中的layout，解析完成后，会把解析得到的View加回到原有布局中。

## merge

> 减少层级布局，可以将<merge>标签下的子View直接添加到<merge>标签的parent中，可以减少不必要的层级。添加的子View遵循父布局的布局方式。
>
> `<merge>`标签一般和`<include>`标签搭配使用，`<merge>`标签不支持设置`android:**`属性，因为它不是View，只是声明了一些View。
>
> *使用`LayoutInflate.inflate(resId,viewroot,attachToRoot)`渲染时，第二个viewroot必须设置，且第三个参数必须为true。*
>
> **<merge>标签最好是替代FlameLayout或者与父布局方向一致的LinearLayout**

上述源码中，`inflate()`执行时判断`name`为`TAG_MERGE`时就会直接调用`rInflate()`

```java
在普通xml中引用merge布局都是 通过include引用的 
 private void parseInclude(XmlPullParser parser, Context context, View parent,
            AttributeSet attrs) throws XmlPullParserException, IOException {
  ...
               final View view = createViewFromTag(parent, name, attrs);  
               // 获取merge标签的parent  
               final ViewGroup viewGroup = (ViewGroup) parent;  
               // 获取布局参数  
               final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);  
               // 递归解析每个子元素  
               rInflate(parser, view, attrs, true);  
               // 将子元素直接添加到merge标签的parent view中  
               viewGroup.addView(view, params);  
  ...
}

```

从上述源码分析中可得 <merge>标签对应的View会直接添加至父容器中，减少一层布局。

拓展：

1. 如果Activity布局的根节点为`FlameLayout`，可以直接替换为`<merge>`标签，执行`setContentView()`后可以减少一层布局
2. 自定义View如果继承`LinearLayout`，可以把自定义View的布局文件根节点设置为`<merge>`

## ViewStub

> ViewStub继承了View，非常轻量级且宽高都为0，因为本身不参与任何的布局和绘制过程。主要用于 一些不常出现的界面可以按需加载，提高加载效率。

源码分析：

```java
// ../android/view/ViewStub.java
public final class ViewStub extends View {
     
     //初始化ViewStub
     public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context);

        final TypedArray a = context.obtainStyledAttributes(attrs,
                R.styleable.ViewStub, defStyleAttr, defStyleRes);
        mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID);
        mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0);
        mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID);
        a.recycle();
        //默认隐藏
        setVisibility(GONE);
        //阻止View的绘制
        setWillNotDraw(true);
    }
  
  ...
    //设置宽高为0
      @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(0, 0);
    }

  //空实现 不会绘制任何内容
    @Override
    public void draw(Canvas canvas) {
    }

    @Override
    protected void dispatchDraw(Canvas canvas) {
    }
  
    public void setVisibility(int visibility) {
        if (mInflatedViewRef != null) {
          //如果已经渲染完成 与普通View逻辑相同
            View view = mInflatedViewRef.get();
            if (view != null) {
                view.setVisibility(visibility);
            } else {
                throw new IllegalStateException("setVisibility called on un-referenced view");
            }
        } else {
            super.setVisibility(visibility);
            if (visibility == VISIBLE || visibility == INVISIBLE) {
                //需要渲染View
                inflate();
            }
        }
    }
  
  //渲染代码
    public View inflate() {
        final ViewParent viewParent = getParent();

        if (viewParent != null && viewParent instanceof ViewGroup) {
            if (mLayoutResource != 0) {
                final ViewGroup parent = (ViewGroup) viewParent;
                //添加并渲染View
                final View view = inflateViewNoAdd(parent);
                //移除原来定义的ViewStub 替换渲染的View上去
                replaceSelfWithView(view, parent);

                mInflatedViewRef = new WeakReference<>(view);
                if (mInflateListener != null) {
                    //监听渲染完成
                    mInflateListener.onInflate(this, view);
                }

                return view;
            } else {
                throw new IllegalArgumentException("ViewStub must have a valid layoutResource");
            }
        } else {
            throw new IllegalStateException("ViewStub must have a non-null ViewGroup viewParent");
        }
    }
  
      private View inflateViewNoAdd(ViewGroup parent) {
        final LayoutInflater factory;
        if (mInflater != null) {
            factory = mInflater;
        } else {
            factory = LayoutInflater.from(mContext);
        }
        //渲染View
        final View view = factory.inflate(mLayoutResource, parent, false);

        if (mInflatedId != NO_ID) {
          //赋值设置的id到ViewStub渲染的View上
            view.setId(mInflatedId);
        }
        return view;
    }

    private void replaceSelfWithView(View view, ViewGroup parent) {
        final int index = parent.indexOfChild(this);
        //移除本身存在的ViewStub
        parent.removeViewInLayout(this);

        final ViewGroup.LayoutParams layoutParams = getLayoutParams();
        //以ViewStub自身设置的 LayoutParams为准 
        if (layoutParams != null) {
            parent.addView(view, index, layoutParams);
        } else {
            parent.addView(view, index);
        }
    }
}
```

根据上述源码发现，`inflate()`只可以调用一次，否则会因移除ViewStub出错。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>布局优化</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式--单例模式</title>
    <url>/2018/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[
# 单例模式

> 一个类只能产生一个对象。确保某一个只有一个实例，而且自行实例化并向整个系统提供这个实例且构造函数私有化。

 {% fullimage /images/Pattern-Singleton.png,单例模式,单例模式 %}

```java
//单例模式通用代码
public class Singleton{
    private static final Singleton singleton = new Singleton();
    private Singleton(){
       
    }
    public static Singleton getSingleton(){
        return singleton;
    }
    public static void doSth(){
        
    }
}
```

## 单例模式优点

1. 由于单例模式只存在一个实例，减少了内存开支
2. 减少了系统的开销
3. 避免对资源的多重占用
4. 在系统设置全局访问点，优化和共享资源访问
5. 允许可变数目的实例，基于单例模式可以进行拓展，可以获得指定个数的对象实例，既节省系统资源，又解决单例对象过多的性能损耗

## 单例模式缺点

1. 单例模式一般没有接口，扩展很困难。
2. 单例模式对测试是不利的，因为单例模式没有完成时，是不能进行测试的。
3. 与单一职责原则有冲突

## 单例模式使用场景

1. 要求生成唯一序列号的环境
2. 在整个项目中需要一个共享访问点或共享数据
3. 创建一个对象需要的消耗资源过多，如访问IO和数据库
4. 需要定义大量的静态常亮和静态方法

## 单例模式的实现条件

1. `构造函数私有`
2. `有一个该类的静态私有对象`
3. `有一个静态的公用函数用于创建或获取本身静态私有对象`
4. **线程同步**

## 单例模式注意事项

1. 在高并发情况下，注意单例模式的线程同步问题
2. 考虑对象的复制情况

## 单例模式实现实例

- 双重校验锁（DCL）--Java5之后可以安心使用该方法

  ```java
  public class Singleton {
      private static volatile Singleton mInstance;
      private Singleton() {
      }
  
      public static Singleton getInstance() {
          if (mInstance == null) {
              synchronized (Singleton.class) {
                  if (mInstance == null) {
                      mInstance = new Singleton();
                  }
              }
          }
          return mInstance;
      }
      
      //反序列化提供的一个特殊方法，可以控制对象的反序列化
      private Object readResolve(){
          return mInstance;//返回实例对象
      }
  }
  ```

  > 在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则`mInstance = new Singleton(); `可能出现`mInstance `尚未被初始化的异常。
  >
  > `mInstance = new Singleton(); `包括三步：`为对象分配内存`，`执行构造方法，初始化实例对象`，`把mInstance的引用指向分配的内存空间`。在JVM的执行过程中并不是原子性的。

- 静态内部类

  ```java
  public class Singleton{
      private static class SingletonHolder{
          private static final Singleton INSTANCE = new Singleton();
      }
      private Singleton(){
          
      }
      public static Singleton getInstance(){
          return SingletonHolder.INSTANCE;
      }
  }
  ```

  > 为何可以保证线程安全？`虚拟机可以保证一个类的类构造器 `<clinit>()`在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。**同一个类加载器下，一个类型只会被初始化一次。**

- 枚举

  ```java
  public enum Singleton {
      INSTANCE;
  }
  ```

  > 防止反序列化重新创建新对象，在Android中不建议使用枚举，大概会增加4倍消耗。



## 单例模式在Android中的体现

```java
//../android/view/inoputmethod/InputMethodManager.java 
public static InputMethodManager getInstance() {
        synchronized (InputMethodManager.class) {
            if (sInstance == null) {
                try {
                    sInstance = new InputMethodManager(Looper.getMainLooper());
                } catch (ServiceNotFoundException e) {
                    throw new IllegalStateException(e);
                }
            }
            return sInstance;
        }
    }
```

]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder系列-ServiceManager相关</title>
    <url>/2018/12/12/Binder%E7%B3%BB%E5%88%97-ServiceManager%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>View的工作原理</title>
    <url>/2018/12/14/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[


<!--MeasureSpec是什么？有什么作用？，自定义View/ViewGroup需要注意什么？invalidate()和postInvalidate()的区别？,invalidate和postInvalidate的区别及使用 Requestlayout，onlayout，onDraw，DrawChild区别与联系  View刷新机制  View绘制流程  计算一个view的嵌套层级（递归）  onMeasure的具体过程，先measure子view还是自己  onDraw的具体过程，先draw子view还是自己  实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展 view的工作原理及measure、layout、draw流程。哪一个流程可以放在子线程中去执行？draw方法中需要注意的问题？Invalidate、postInvalidate、requestLayout应用场景 TextView.setText()调用什么方法去刷新 -->

{% fullimage /images/View工作原理.png,View工作原理,View工作原理%}

<!-- more -->

## DecorView

**DecorView是整个Window界面的最顶层View。** *可以使用Android Studio自带的Layout Inspector查看页面层级*

### DecorView的布局结构

一般情况下`DecorView`会包含一个竖直方向的LinearLayout，该LinearLayout分为上下两个部分，上面是标题栏(`titlebar`)，下面是内容栏(`继承自FrameLayout 且id为content`)。因此我们设置Activity的布局方法叫做`setContentView()`，因为他们都被加进了`id为content的FrameLayout`中。

我们可以利用`ViewGroup content = findViewById(R.android.id.content)`获取conetnt。使用`content.getChildAt(0)`获取设置的Activity布局。

```java
// ../android/app/Activity.java
    public <T extends View> T findViewById(@IdRes int id) {
        //从Window中去获取View
        return getWindow().findViewById(id);
    }

// ../android/view/Window.java
    public <T extends View> T findViewById(@IdRes int id) {
        //从DecorView获取View
        return getDecorView().findViewById(id);
    }
```

所有的View都会从DecorView中开始检索，所以**View层的事件都会先经过DecorView，再传递到我们定义的View上**。

### setContentView()流程

> 通过`setContentView()`将需要加载的布局放到`DecorView`中

```java
//Activity.java
public void setContentView(@LayoutRes int layoutResID) {
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
    }
```

`Activity.setContentView()`调用`PhoneWindow.setContentView()`

```java
    public void setContentView(int layoutResID) {
        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
        // decor, when theme attributes and the like are crystalized. Do not check the feature
        // before this happens.
        if (mContentParent == null) {
            //创建DecorView
            installDecor();
        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            mContentParent.removeAllViews();
        }

        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                    getContext());
            transitionTo(newScene);
        } else {
          //开始加载对应布局
            mLayoutInflater.inflate(layoutResID, mContentParent);
        }
        mContentParent.requestApplyInsets();
        final Callback cb = getCallback();
        if (cb != null && !isDestroyed()) {
            cb.onContentChanged();
        }
        mContentParentExplicitlySet = true;
    }
```

`setContentView()`主要执行以下两步：

#### `installDecor()`创建DecorView

> 基础`DecorView`主要包含两部分，标题`title_bar`和内容`content`

```java
//PhoneWindow.java
 private void installDecor() {
        mForceDecorInstall = false;
        if (mDecor == null) {
            //生成DecoeView
            mDecor = generateDecor(-1);
            ...
        } else {
            mDecor.setWindow(this);
        }
        if (mContentParent == null) {
           //根据DecorView生成子View
            mContentParent = generateLayout(mDecor);
          ...
        }
 }

    protected DecorView generateDecor(int featureId) {
        Context context;
        if (mUseDecorContext) {
            Context applicationContext = getContext().getApplicationContext();
            if (applicationContext == null) {
                context = getContext();
            } else {
                context = new DecorContext(applicationContext, getContext());
                if (mTheme != -1) {
                    context.setTheme(mTheme);
                }
            }
        } else {
            context = getContext();
        }
      // 生成DecorView对象
        return new DecorView(context, featureId, this, getAttributes());
    }

    protected ViewGroup generateLayout(DecorView decor) {
      ...
        int layoutResource;
        int features = getLocalFeatures();
        if ((features & (1 << FEATURE_SWIPE_TO_DISMISS)) != 0) {
            layoutResource = R.layout.screen_swipe_dismiss;
            setCloseOnSwipeEnabled(true);     
        }...
         else{
           layoutResource = R.layout.screen_simple; //默认布局
         }
         mDecor.startChanging();
         //开始加载布局
         mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);
         //根据id找到 content
         ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//com.android.internal.R.id.content
         ...
         return contentParent;
    }

//DecorView.java
    void onResourcesLoaded(LayoutInflater inflater, int layoutResource) {
        final View root = inflater.inflate(layoutResource, null);
        if (mDecorCaptionView != null) {
            if (mDecorCaptionView.getParent() == null) {
                addView(mDecorCaptionView,
                        new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
            }
            mDecorCaptionView.addView(root,
                    new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));
        } else {
            //解析得到的View放到DecorView中
            addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
        }
        mContentRoot = (ViewGroup) root;
    }

```

`installDecor()`主要复杂创建`DecorView`并执行`generateLayout()`生成`contentParent`将自定义的布局放入其中。

#### LayoutInflater.inflate()加载布局

> `LayoutInflater`是一个抽象类，具体实现类为`PhoneLayoutInflater`

通过系统注册服务可以得到`LayoutInflater`的实现类`PhoneLayoutInflater`

```java
    //LayoutInflater.java
    public static LayoutInflater from(Context context) {
        LayoutInflater LayoutInflater =
                (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);//获取系统配置的加载服务
        if (LayoutInflater == null) {
            throw new AssertionError("LayoutInflater not found.");
        }
        return LayoutInflater;
    }

    //系统设置 PhoneInflater 为加载类
    registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,
                new CachedServiceFetcher<LayoutInflater>() {
            @Override
            public LayoutInflater createService(ContextImpl ctx) {
                return new PhoneLayoutInflater(ctx.getOuterContext());
            }});


```



在`setContentView()`生成`DecorView`之后，就需要对设置的`layoutResId`进行加载，使其加入到`content`中

```java
//LayoutInflater.java
   public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {
        return inflate(resource, root, root != null);
   }   

   public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
        final Resources res = getContext().getResources();
        ...
        //构造xml解析器
        final XmlResourceParser parser = res.getLayout(resource);
        try {
            return inflate(parser, root, attachToRoot);
        } finally {
            parser.close();
        }
    }

    public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
        synchronized (mConstructorArgs) {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate");

            final Context inflaterContext = mContext;
            final AttributeSet attrs = Xml.asAttributeSet(parser);
            Context lastContext = (Context) mConstructorArgs[0];
            mConstructorArgs[0] = inflaterContext;
            View result = root;

            try {
                // Look for the root node.
                int type;
                //非xml起始与结尾标记
                while ((type = parser.next()) != XmlPullParser.START_TAG &&
                        type != XmlPullParser.END_DOCUMENT) {
                }
            
                if (type != XmlPullParser.START_TAG) {
                    throw new InflateException(parser.getPositionDescription()
                            + ": No start tag found!");
                }

                final String name = parser.getName();
                //处理<merge>标签
                if (TAG_MERGE.equals(name)) {
                    if (root == null || !attachToRoot) {
                        throw new InflateException("<merge /> can be used only with a valid "
                                + "ViewGroup root and attachToRoot=true");
                    }
                    //传入rootview 解析得到的布局直接加入rootView中
                    rInflate(parser, root, inflaterContext, attrs, false);
                } else {
                    // Temp is the root view that was found in the xml
                    //根据Tag创建对应的View 例如<TextView>
                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                    ViewGroup.LayoutParams params = null;

                    if (root != null) {
                        // Create layout params that match root, if supplied
                        params = root.generateLayoutParams(attrs);
                        if (!attachToRoot) {
                            // Set the layout params for temp if we are not
                            // attaching. (If we are, we use addView, below)
                            temp.setLayoutParams(params);
                        }
                    }

                    // Inflate all children under temp against its context.
                    //创建temp子View
                    rInflateChildren(parser, temp, attrs, true);

                    // We are supposed to attach all the views we found (int temp)
                    // to root. Do that now.
                    if (root != null && attachToRoot) {
                        //将temp添加到rootView中
                        root.addView(temp, params);
                    }

                    // Decide whether to return the root that was passed in or the
                    // top view found in xml.
                    if (root == null || !attachToRoot) {
                        //attachToRoot：将View添加到RootView中，非就是直接返回解析的子View
                        result = temp;
                    }
                }

            } catch (XmlPullParserException e) {
                final InflateException ie = new InflateException(e.getMessage(), e);
                ie.setStackTrace(EMPTY_STACK_TRACE);
                throw ie;
            } catch (Exception e) {
                final InflateException ie = new InflateException(parser.getPositionDescription()
                        + ": " + e.getMessage(), e);
                ie.setStackTrace(EMPTY_STACK_TRACE);
                throw ie;
            } finally {
                // Don't retain static reference on context.
                mConstructorArgs[0] = lastContext;
                mConstructorArgs[1] = null;

                Trace.traceEnd(Trace.TRACE_TAG_VIEW);
            }

            return result;
        }
    }

    void rInflate(XmlPullParser parser, View parent, Context context,
            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {

        final int depth = parser.getDepth();
        int type;
        boolean pendingRequestFocus = false;

        while (((type = parser.next()) != XmlPullParser.END_TAG ||
                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {

            if (type != XmlPullParser.START_TAG) {
                continue;
            }

            final String name = parser.getName();

            if (TAG_REQUEST_FOCUS.equals(name)) {
                pendingRequestFocus = true;
                consumeChildElements(parser);
            } else if (TAG_TAG.equals(name)) {
                parseViewTag(parser, parent, attrs);
            } else if (TAG_INCLUDE.equals(name)) {//<include>
                if (parser.getDepth() == 0) {
                    throw new InflateException("<include /> cannot be the root element");
                }
                parseInclude(parser, context, parent, attrs);
            } else if (TAG_MERGE.equals(name)) {//<merge>
                throw new InflateException("<merge /> must be the root element");
            } else {
                //创建View
                final View view = createViewFromTag(parent, name, context, attrs);
                final ViewGroup viewGroup = (ViewGroup) parent;
                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
                //递归创建子View
                rInflateChildren(parser, view, attrs, true);
                //创建的子View添加会parent
                viewGroup.addView(view, params);
            }
        }

        if (pendingRequestFocus) {
            parent.restoreDefaultFocus();
        }

        if (finishInflate) {
            parent.onFinishInflate();
        }
    }
```

`layoutInflater.inflate()`主要是调用`createViewFromTag()`从xml生成view的



##### inflate(resource,root,attachToRoot)

> `source`：需要加载的layout id
>
> `root`：根布局
>
> *`attachToRoot`：是否添加到`root`中

根据源码分析到，`root`与`attachToRoot`会对`infalte()`结果产生影响以及实现代码会有差异

| `root`与`attachToRoot`参数                    | 表现                                                         | `inflate()`返回结果        |
| --------------------------------------------- | ------------------------------------------------------------ | -------------------------- |
| `root == nuill && attachToRoot == false/true` | 直接显示`source`加载的结果，而且设置的`宽高属性`也会失效     | `source`加载后的`View实例` |
| `root != null && attachToRoot == false`       | 直接显示`source`加载的结果，且设置的`宽高属性`保持           | `source`加载后的`View实例` |
| `root!=null && attachToRoot == true`          | 直接显示`root`并且`source`已被`add`进去且设置的`宽高属性`保持 | `root`                     |



##### * createViewFromTag()

> 主要负责将`<tag>`创建成`View`对象

```java
//LayoutInflater.java
View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,
            boolean ignoreThemeAttr) {
        /**
        * view标签 取class 做为name
        */
        if (name.equals("view")) {
            name = attrs.getAttributeValue(null, "class");
        }

        // 设置View的Theme
        if (!ignoreThemeAttr) {
            final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
            final int themeResId = ta.getResourceId(0, 0);
            if (themeResId != 0) {
                context = new ContextThemeWrapper(context, themeResId);
            }
            ta.recycle();
        }
        //处理 <blink>标签
        if (name.equals(TAG_1995)) {
            // Let's party like it's 1995!
            return new BlinkLayout(context, attrs);
        }

        try {
            View view;
            //通过Factory /Factory2  进行View的实例化
            if (mFactory2 != null) {
                view = mFactory2.onCreateView(parent, name, context, attrs);
            } else if (mFactory != null) {
                view = mFactory.onCreateView(name, context, attrs);
            } else {
                view = null;
            }
            //通过 mPrivateFactory实例化View
            if (view == null && mPrivateFactory != null) {
                view = mPrivateFactory.onCreateView(parent, name, context, attrs);
            }
            //未设置 Factory，走默认创建View的流程
            if (view == null) {
                final Object lastContext = mConstructorArgs[0];
                mConstructorArgs[0] = context;
                try {
                    //<tag>中存在 . 可以判断为自定义View，走View自身的创建流程
                    if (-1 == name.indexOf('.')) {
                        view = onCreateView(parent, name, attrs);
                    } else {
                        view = createView(name, null, attrs);
                    }
                } finally {
                    mConstructorArgs[0] = lastContext;
                }
            }

            return view;
        } 
        ,,,
    }
}
      
```

`createViewFromTag()`主要做了以下几步：

1. 如果为`<view>`标签，读取`class`属性做为类名

   ```xml
   <view class="LinearLayout"/> 等价于<LinearLayout></LinearLayout>
   ```

   

2. 应用`ContenxtThemeWrapper`为View设置主题`Theme`

3. 使用`Factory/Factory2/mPrivateFactory`实例化`View`，相当于**拦截**

   > 实例化`View`的优先顺序为`Factory2 > Factory > mPrivateFactory > PhoneLayoutInflater`

4. 未设置`以上factory`，执行`View`的默认创建流程

   > 主要通过`PhoneLayoutInflater`执行



### Factory/Factory2-拦截View创建

> 在上节有说到`Factory/Factory2`执行相当于拦截的功能，`hook`View创建的流程
>
> `mPrivateFactory`实现了`Factory2`接口，主要用于拦截`<fragment>`标签处理

```java
    private Factory mFactory;
    private Factory2 mFactory2;
    private Factory2 mPrivateFactory;

    public interface Factory {
        public View onCreateView(String name, Context context, AttributeSet attrs);
    }

    public interface Factory2 extends Factory {
        public View onCreateView(View parent, String name, Context context, AttributeSet attrs);
    }
```

`Factory2`相对于`Factory`在`onCreateView()`多传入了`parent`

#### Factroy2

设置`Factroy2`的方法

```java
    public void setFactory2(Factory2 factory) {
        if (mFactorySet) { //只允许设置一次 Factory2
            throw new IllegalStateException("A factory has already been set on this LayoutInflater");
        }
        if (factory == null) {
            throw new NullPointerException("Given factory can not be null");
        }
        mFactorySet = true;
        if (mFactory == null) {
            mFactory = mFactory2 = factory;
        } else {
            //控制factory调用顺序
            mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);
        }
    }
```

```java
    private static class FactoryMerger implements Factory2 {
        private final Factory mF1, mF2;
        private final Factory2 mF12, mF22;

        FactoryMerger(Factory f1, Factory2 f12, Factory f2, Factory2 f22) {
            mF1 = f1;
            mF2 = f2;
            mF12 = f12;
            mF22 = f22;
        }

      //此处对应Factory
        public View onCreateView(String name, Context context, AttributeSet attrs) {
            View v = mF1.onCreateView(name, context, attrs);
            if (v != null) return v;
            return mF2.onCreateView(name, context, attrs);
        }
       //此处对应Factory2
        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
            View v = mF12 != null ? mF12.onCreateView(parent, name, context, attrs)
                    : mF1.onCreateView(name, context, attrs);
            if (v != null) return v;
            return mF22 != null ? mF22.onCreateView(parent, name, context, attrs)
                    : mF2.onCreateView(name, context, attrs);
        }
    }
```

最终都是通过`FactoryMerger`执行的`onCreateView`

##### 何处调用setFactory2()

```java
//AppCompatActivity.onCreate() -> AppCompatDelegate.installViewFactory() ->
//AppCompatDelegateImpl.installViewFactory()
    public void installViewFactory() {
        LayoutInflater layoutInflater = LayoutInflater.from(this.mContext);
        if (layoutInflater.getFactory() == null) {
            LayoutInflaterCompat.setFactory2(layoutInflater, this);
        } else if (!(layoutInflater.getFactory2() instanceof AppCompatDelegateImpl)) {
            Log.i("AppCompatDelegate", "The Activity's LayoutInflater already has a Factory installed so we can not install AppCompat's");
        }

    }

//设置Factory2执行到 onCreateView()
    public final View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
        return this.createView(parent, name, context, attrs);
    }

    public View createView(View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs) {
        if (this.mAppCompatViewInflater == null) {
            TypedArray a = this.mContext.obtainStyledAttributes(styleable.AppCompatTheme);
            String viewInflaterClassName = a.getString(styleable.AppCompatTheme_viewInflaterClass);
            if (viewInflaterClassName != null && !AppCompatViewInflater.class.getName().equals(viewInflaterClassName)) {
                try {
                    Class viewInflaterClass = Class.forName(viewInflaterClassName);
                    this.mAppCompatViewInflater = (AppCompatViewInflater)viewInflaterClass.getDeclaredConstructor().newInstance();
                } catch (Throwable var8) {
                    Log.i("AppCompatDelegate", "Failed to instantiate custom view inflater " + viewInflaterClassName + ". Falling back to default.", var8);
                    this.mAppCompatViewInflater = new AppCompatViewInflater();
                }
            } else {
                this.mAppCompatViewInflater = new AppCompatViewInflater();
            }
        }

        ...
        return this.mAppCompatViewInflater.createView(...);
    }

```

通过`AppCompatViewInflater`去执行View的创建

```java
//AppCompatViewInflater.java
    final View createView(View parent, String name, @NonNull Context context, @NonNull AttributeSet attrs, boolean inheritContext, boolean readAndroidTheme, boolean readAppTheme, boolean wrapContext) {
  ...
     switch (name) {
            case "TextView":
                view = createTextView(context, attrs);
                verifyNotNull(view, name);
                break;
         ...
     }
}

    @NonNull
    protected AppCompatTextView createTextView(Context context, AttributeSet attrs) {
        return new AppCompatTextView(context, attrs);
    }


```

此处可以在使用到`AppCompatActivity`时，将原先的`<TextView>`转换为`AppCompatTextView`



#### mPrivateFactory

> 系统hide对象，无法被外界使用，主要处理`<fragment>`

```java
    public void setPrivateFactory(Factory2 factory) {
        if (mPrivateFactory == null) {
            mPrivateFactory = factory;
        } else {
            mPrivateFactory = new FactoryMerger(factory, factory, mPrivateFactory, mPrivateFactory);
        }
    }
```

##### 何处调用setPrivateFactory()

```java
//Activity.java
final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window, ActivityConfigCallback activityConfigCallback) {
  ...
    mWindow.getLayoutInflater().setPrivateFactory(this); //this 表示当前Activity
  ...
}

    public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
        if (!"fragment".equals(name)) {
            return onCreateView(name, context, attrs);
        }
       //<fragment>标签直接解析执行 onCreateView
        return mFragments.onCreateView(parent, name, context, attrs);
    }

```

#### 拓展使用

系统通过`Factory`提供`hook`方法，方便拦截`LayoutInflater`创建View的过程。支持以下应用场景：

- 支持对自定义标签名称的处理
- 全局替换系统控件为自定义View
- **替换字体**
- **全局换肤**
- **获取控件加载耗时**



### View默认创建流程

> 未设置`Factory/Factory2`就会执行默认的View创建流程

```java
//LayoutInflater.java
    View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,
            boolean ignoreThemeAttr) {
      ...
        if (view == null) {
                final Object lastContext = mConstructorArgs[0];
                mConstructorArgs[0] = context;
                try {
                    if (-1 == name.indexOf('.')) {
                        view = onCreateView(parent, name, attrs);//系统提供View
                    } else {
                        view = createView(name, null, attrs);//自定义View
                    }
                } finally {
                    mConstructorArgs[0] = lastContext;
                }
            }
      ...
    }
```



#### 系统提供View

> 例如`<TextView/>、<Button/>`等

```java
public class PhoneLayoutInflater extends LayoutInflater {
     private static final String[] sClassPrefixList = {
        "android.widget.",
        "android.webkit.",
        "android.app."
    };

     @Override protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException {
        for (String prefix : sClassPrefixList) {
            try {
                View view = createView(name, prefix, attrs);
                if (view != null) {
                    return view;
                }
            } catch (ClassNotFoundException e) {
                // In this case we want to let the base class take a crack
                // at it.
            }
        }

        return super.onCreateView(name, attrs);
    }
  
}

//LayoutInflater.java
    protected View onCreateView(String name, AttributeSet attrs)
            throws ClassNotFoundException {
        return createView(name, "android.view.", attrs);
    }

```

优先判断

- `android.widget.*` 例如`android.widget.TextView`
- `android.webkit.*` 例如`android.webkit.WebView`
- `android.app.*` 例如`android.app.ActionBar`

是否有对应`nmae`的View实例存在

都不存在，就在`android.view.*`找寻对应View实例 例如`android.view.ViewStub`

#### 自定义View

> 例如`android.support.v7.widget.RecyclerView`等

```java
public final View createView(String name, String prefix, AttributeSet attrs)
            throws ClassNotFoundException, InflateException {
       //构建缓存，缓存已加载的View
        Constructor<? extends View> constructor = sConstructorMap.get(name);
        if (constructor != null && !verifyClassLoader(constructor)) {
            constructor = null;
            sConstructorMap.remove(name);
        }
        Class<? extends View> clazz = null;

        try {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
            //新建View构造器
            if (constructor == null) {
                // 得到全限定名 例如android,widget.TextView
                clazz = mContext.getClassLoader().loadClass(
                        prefix != null ? (prefix + name) : name).asSubclass(View.class);

                if (mFilter != null && clazz != null) {
                    boolean allowed = mFilter.onLoadClass(clazz);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                }
                constructor = clazz.getConstructor(mConstructorSignature);
                constructor.setAccessible(true);
                sConstructorMap.put(name, constructor);
            } else {
                // If we have a filter, apply it to cached constructor
                if (mFilter != null) {
                    // Have we seen this name before?
                    Boolean allowedState = mFilterMap.get(name);
                    if (allowedState == null) {
                        // New class -- remember whether it is allowed
                        clazz = mContext.getClassLoader().loadClass(
                                prefix != null ? (prefix + name) : name).asSubclass(View.class);

                        boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                        mFilterMap.put(name, allowed);
                        if (!allowed) {
                            failNotAllowed(name, prefix, attrs);
                        }
                    } else if (allowedState.equals(Boolean.FALSE)) {
                        failNotAllowed(name, prefix, attrs);
                    }
                }
            }

            Object lastContext = mConstructorArgs[0];
            if (mConstructorArgs[0] == null) {
                // Fill in the context if not already within inflation.
                mConstructorArgs[0] = mContext;
            }
            Object[] args = mConstructorArgs;
            args[1] = attrs;
            //根据得到的 constuctor 实例化View对象
            final View view = constructor.newInstance(args);
            //针对ViewStub特殊处理
            if (view instanceof ViewStub) {
                // Use the same context when inflating ViewStub later.
                final ViewStub viewStub = (ViewStub) view;
                viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
            }
            mConstructorArgs[0] = lastContext;
            return view;

        } 
  ...
    }
```

#### 执行流程

`View默认创建`流程分为：

- `<tag>`不包含`.`，用于处理`<TextView>、<WebView>`等标签，此时需要拼接`android.widget. 或 android.webkit. 或 android.app. `前缀(**实现位于`PhoneLayoutInflater`**)，都没有找到对应的`View实例`时，就会在添加`android.view.`再去加载。
- `<tag>`包含`.`，此时的实例View分为以下几步：
  - 构建View的缓存，缓存的是`constructor`，根据`name`获取`constructor`
  - 缓存中不存在时，需要根据`prefix+name`获取View的`constructor`，并存入缓存中
  - 根据`constructor`构造`View实例`——`constructor.newInstance()`
  - 如果需要处理`ViewStub`，为`ViewStub`指定加载类



![执行流程](/images/LayoutInflater过程.jpg)

## ViewRootImpl

> *ViewRoot对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程均需通过ViewRoot完成。*

### ViewRootImpl创建时机

当Activity创建时，最终是调用到`ActivityThread`的`handleLaunchActivity`来创建Activity。

```java
// ../android/app/ActivityThread.java
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
 ...
      //创建一个Activity 会调用到onCreate()方法 从而完成DecroView的创建
      Activity a = performLaunchActivity(r, customIntent);
        if (a != null) {
            r.createdConfig = new Configuration(mConfiguration);
            reportSizeConfigurations(r);
            Bundle oldState = r.state;
            
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
            ...
        }
    ...
}
```

上述方法后续调用到了`handleResumeActivity()`,在这个方法中调用到了`WindowManager.addView()`将View传递至WindowManager

```java
// ../android/app/ActivityThread.java
final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
         ActivityClientRecord r = mActivities.get(token);
        if (!checkAndUpdateLifecycleSeq(seq, r, "resumeActivity")) {
            return;
        }
        unscheduleGcIdler();
        mSomeActivitiesChanged = true;

        // 在这里会调用到生命周期中的onResume方法
        r = performResumeActivity(token, clearHide, reason);
        ...
            if(r!=null){
                ...
                final Activity a = r.activity;
                ...
                //获得当前Activty的Window对象
                r.window = r.activity.getWindow();
                //获得当前Window的DecorView
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                //获得当前Activity的WindowManager对象
                ViewManager wm = a.getWindowManager();
                WindowManager.LayoutParams l = r.window.getAttributes();
                a.mDecor = decor;
                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
                l.softInputMode |= forwardBit;
                if (r.mPreserveWindow) {
                    a.mWindowAdded = true;
                    r.mPreserveWindow = false;
                    ViewRootImpl impl = decor.getViewRootImpl();
                    if (impl != null) {
                        impl.notifyChildRebuilt();
                    }
                }
                if (a.mVisibleFromClient) {
                    if (!a.mWindowAdded) {
                        a.mWindowAdded = true;
                        //将DecorView添加到PhoneWindow中
                        wm.addView(decor, l);
                    } else {
                        a.onWindowAttributesChanged(l);
                    }
                }

            // If the window has already been added, but during resume
            // we started another activity, then don't yet make the
            // window visible.
            } else if (!willBeVisible) {
                if (localLOGV) Slog.v(
                    TAG, "Launch " + r + " mStartedActivity set");
                r.hideForNow = true;
            }    
            }
...
    }
```

后续调用到了`wm.addView()`。将对应的DecorView传递进去。

```java
// ../android/view/WindowManagerImpl.java
public final class WindowManagerImpl implements WindowManager {
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    private final Window mParentWindow;
    ...
    @Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        //调用到了WindowManagerGlobal中的addView
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }   
    ...
}

// ../android/view/WindowManagerGlobal.java
public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        ...

        ViewRootImpl root;
        View panelParentView = null;
        synchronized (mLock) {
            ...
            //创建了ViewRootImpl实例
            root = new ViewRootImpl(view.getContext(), display);//初始化了ViewRootImpl对象
            view.setLayoutParams(wparams);
            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
            // do this last because it fires off messages to start doing things
            try {
                //调用setView 将传进来的DecorView添加到PhoneWindow中。 
                root.setView(view, wparams, panelParentView);
            } catch (RuntimeException e) {
                // BadTokenException or InvalidDisplayException, clean up.
                if (index >= 0) {
                    removeViewLocked(index, true);
                }
                throw e;
            }
        }
    }
```

经过`ActivityThread.handleResumeActivity() -> WindowManagerGlobal.addView() `创建了`ViewRootImpl`对象

### 与DecorView的关系

上述流程走完后，就把DecorView加载到了Window中。**这个流程中将ViewRootImpl对象与DecorView进行了关联**。

```java
//view 表示 DecorView 
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
     synchronized(this){
         //传进来的DecorView作为全局变量使用
          mView = view;
         ...
          // Schedule the first layout -before- adding to the window
                // manager, to make sure we do the relayout before receiving
                // any other events from the system.
          //绘制整个布局
          requestLayout();   
         ...
          //设置ViewRootImpl为DecorView的parentView 
          view.assignParent(this);
     }   
 }
```

执行到`ViewRootImpl.setView()`设置`DecorView,assignParent(root)`。表示**ViewRootImpl是DecorView的parent**。



> `Activity`、`Window(PhoneWindow)`、`View(DecorView)`、`ViewRootImpl`之间的关系？
>
> `PhoneWindow`是`Window`的唯一子类，在`Activity.attach()`构建的实例，是**Activity与View交互的中间层**
>
> `DecorView`是`所有View`的最顶层，`ViewRootImpl`是`DecorView`的`parent`，**掌管View的各种事件，例如`刷新、点击`事件等**

## View的绘制流程触发

调用了`ViewRootImpl.setView(decorView)`将DecorView与ViewRootImpl进行了关联。View的绘制流程就是从ViewRoot开始的。

```java
 public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
     synchronized(this){
         //传进来的DecorView作为全局变量使用
          mView = view;
         ...
          // Schedule the first layout -before- adding to the window
                // manager, to make sure we do the relayout before receiving
                // any other events from the system.
          //绘制整个布局
          requestLayout();   
         ...
          //设置ViewRootImpl为DecorView的parentView 
          view.assignParent(this);
     }   
 }

//请求刷新整个布局
    @Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            checkThread();
            mLayoutRequested = true;
            scheduleTraversals();
        }
    }

    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //添加同步屏障
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            if (!mUnbufferedInputDispatch) {
                scheduleConsumeBatchedInput();
            }
            notifyRendererOfFramePending();
            pokeDrawLockIfNeeded();
        }
    }

    final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            doTraversal();
        }
    }
    final TraversalRunnable mTraversalRunnable = new TraversalRunnable();

    void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            //移除同步屏障
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            if (mProfile) {
                Debug.startMethodTracing("ViewAncestor");
            }
            //这里开始View的绘制流程
            performTraversals();

            if (mProfile) {
                Debug.stopMethodTracing();
                mProfile = false;
            }
        }
    }
```

`ViewRootImpl.setView()`中最后调用到了`performTraversals()`在这个方法中开始View的绘制流程

```java
private void performTraversals() {
  ...
   boolean layoutRequested = mLayoutRequested && (!mStopped || mReportNextDraw);
   
   ...
   if (!mStopped || mReportNextDraw) {
      int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
	  int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
      ...
        if(layoutRequested){
          //开始Measure过程，定义View的宽高
          performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
          ...
        }
   }
  
    final boolean didLayout = layoutRequested && (!mStopped || mReportNextDraw);
    if(didLayout){
        //开始Layout过程，决定View的位置
        performLayout(lp, mWidth, mHeight);
        ...
    }
    
     if (!cancelDraw && !newSurface) {
            if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
                for (int i = 0; i < mPendingTransitions.size(); ++i) {
                    mPendingTransitions.get(i).startChangingAnimations();
                }
                mPendingTransitions.clear();
            }
            //开始Draw过程，决定了View的显示，这个过程结束才可以看到内容
            performDraw();
     }
}        
```

通过以上流程分析：**View的绘制流程是从`ViewRootImpl`中开始的，先调用`performTraversals()`开始绘制，随后调用内部的`performMeasure()`开始Measure过程，调用`performLayout()`，开始Layout过程，最后调用`performDraw()`开始Draw，完成后就可以现在在屏幕上。**



![View绘制流程](/images/View绘制流程.png)

如上图所示，`performTraversals()`依次调用`performMeasure()，performLayout(),performDraw()`完成View的绘制。



## View工作流程

> 主要是指`measure(测量)`,`layout(布局)`,`draw(绘制)`三大流程。

### measure-测量

> 起点位于`performMeasure()`。

#### MeasureSpec

> MeasureSpec代表一个32位int值，高2位代表SpecMode(测量模式)，低30位代表SpecSize(某种测量模式下的规格大小)。

作用：父控件提供给子View的一个参数，作为设定自身大小参考，实际大小还是有子View自身决定。

![MeasureSpec结构](/images/MeasureSpec结构)

##### 结构

```java
 public static class MeasureSpec {
        private static final int MODE_SHIFT = 30;
        private static final int MODE_MASK  = 0x3 << MODE_SHIFT;

        /** @hide */
        @IntDef({UNSPECIFIED, EXACTLY, AT_MOST})
        @Retention(RetentionPolicy.SOURCE)
        public @interface MeasureSpecMode {}
     
      public static final int UNSPECIFIED = 0 << MODE_SHIFT;
      public static final int EXACTLY     = 1 << MODE_SHIFT;
      public static final int AT_MOST     = 2 << MODE_SHIFT;

      @MeasureSpecMode
       public static int getMode(int measureSpec) {
            //noinspection ResourceType
            return (measureSpec & MODE_MASK);
        }
          
       public static int getSize(int measureSpec) {
            return (measureSpec & ~MODE_MASK);
        }
```

`SpecMode`分为三类：

- `UNSPECIFIED`：**未指定模式**。父控件不对子控件家人和我束缚，子元素可以为任意大小，一般用于系统内部的测量。比如`ScrollView`
- `EXACTLY`：**精确模式**。父控件为子View指定精确大小，希望子View完全按照自己给的尺寸处理大小。一般是设置了`明确的值`或是`MATCH_PARENT`
- `AT_MOST`：**最大模式**。父控件为子View指定最大尺寸，希望子View不要超过这个尺寸。一般对应`WRAP_CONTENT`



##### MeasureSpec与LayoutParams的关系

每一个View，都持有一个MeasureSpec，里面保存了View的尺寸。我们也可以使用`LayoutParams`指定View的尺寸。所以在View测量的时候，系统会将`LayoutParams`在父容器的约束下转换成`MeasureSpec`，然后根据转换后的值确定宽高。

**转换后的MeasureSpec是由LayoutParams和父容器的MeasureSpec一起决定的。**

| 下：childLayoutParams 右：parentSpecMode | EXACTLY                                    | AT_MOST                                    | UNSPECIFIED           |
| ---------------------------------------- | ------------------------------------------ | ------------------------------------------ | --------------------- |
| 固定大小                                 | Exactly<br>childSize                       | Exactly<br/>childSize                      | Exactly<br/>childSize |
| match_parent                             | Exactly<br/>parentSize(父容器剩余空间)     | AT_MOST<br/>parentSize(最大父容器剩余空间) | UNSPECIFIED<br>0      |
| wrap_content                             | AT_MOST<br/>parentSize(最大父容器剩余空间) | AT_MOST<br/>parentSize(最大父容器剩余空间) | UNSPECIFIED<br/>0     |

根据`ViewGroup.getChildMeasureSpec()`得出上表。

###### DecorView转换MeasureSpec

> DecorView的转换由Window的尺寸和自身的LayoutParams决定。

```java
// ../android/view/ViewRootImpl.java
private void performTraversals() {
    ...
       //DecorView Measure过程
       int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
       int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
       performMeasure(childWidthMeasureSpec,childHeightMeasureSpec)
    ...  
}

//在方法中生成了DecoeView的MeasureSpec 根据Window的尺寸和自身的LayoutParams
private static int getRootMeasureSpec(int windowSize/*Window尺寸*/, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {
       
        case ViewGroup.LayoutParams.MATCH_PARENT:
            //MeasureSpec中的specSize就是窗口尺寸,specMode为EXACTLY 精确模式
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            //MeasureSpec中的specSize为窗口尺寸,specMode为aT_MOST 最大模式，最大值为窗口尺寸
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            //MeasureSpec中的specSize为固定尺寸,specMode为EXACTLY 精确模式
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
    }

```



#### View的measure过程

主要是由`measure()`方法完成

```java
// ../android/view/View.java
public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
    //这个类是final的，所以子类无法重写该方法
    ...
    onMeasure(widthMeasureSpec,heightMeasureSpec);
    ...
    mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;//不设置该标记会导致 View无法布局
    ...
}
```

在`measure()`中调用`onMeasure()`去进行实际的测量

```java
//../android/view/View.java
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(
            getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    }

   //设置View的宽高
   protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
        boolean optical = isLayoutModeOptical(this);
        if (optical != isLayoutModeOptical(mParent)) {
            Insets insets = getOpticalInsets();
            int opticalWidth  = insets.left + insets.right;
            int opticalHeight = insets.top  + insets.bottom;

            measuredWidth  += optical ? opticalWidth  : -opticalWidth;
            measuredHeight += optical ? opticalHeight : -opticalHeight;
        }
        setMeasuredDimensionRaw(measuredWidth, measuredHeight);
    }

    private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {
        mMeasuredWidth = measuredWidth;
        mMeasuredHeight = measuredHeight;
        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
    }

    //返回View的MeasureSpec中的specSize
    public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST://wrap_content
        case MeasureSpec.EXACTLY://match_parent / XX 
        //这段代码中可以分析得出 一个直接继承View的自定义View 定义为wrap_content和match_parent大小都是一致的.
            result = specSize;
            break;
        }
        return result;
    }

    protected int getSuggestedMinimumHeight() {
        return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());
    }

//如果View没有设置背景，返回minWidth值，默认为0。若设置了背景就取背景宽度和最小宽度中的最大值返回。
    protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
    }

    
// ../android/graphics/drawable/Drawable.java
public int getMinimumWidth(){
    final int intrinsicWidth = getIntrinsicWidth();
    return intrinsicWidth > 0 ? intrinsicWidth : 0;
}


```



![View-Measure](/images/View-Measure.png)

结合上述流程图，简单分析View的Measure过程

- 系统在绘制开始时回去调用`View.measure()`，这个类是final的们无法被重写
- 后续调用`View.onMeasure()`,自定义View时可以按照自己的需求对这个方法进行重写
- `onMeasure()`中调用到`setMeasureDimension()`对View进行宽高的设置
- 需要使用`getDefaultSize()`去获取最终显示出的宽高
- 在`getDefaultSize()`中需要对传进来的`MeasureSpec`进行分析处理
  - SpecMode若为`UNSPECIFIED`，则最终尺寸为传进来的`SpecSize`
  - SpecMode为`AT_MOST`,`EXACTLY`，还需要额外判断View是否有背景
    - 有背景，最终尺寸就为View的最小尺寸和背景尺寸的最大值
    - 没背景，最终尺寸就为View的最小尺寸
- 取到最终尺寸后，数据回溯到`onMeasure()`中，即完成测量(`Measure`)过程

在上述分析中，自定义View中使用`wrap_content`时，specMode为`AT_MOST`，尺寸为父控件剩余大小，效果与使用`match_parent`一致。这也是自定义View中常碰到的问题 *为何自定义View是wrap_content无效？* 解决方法就是 自己重写`onMeasure()`对`wrap_content`特殊处理。

```java
public void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
    super.onMeasure(widthMeasureSpec,heightMeasureSpec);
    int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
    int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
    int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
    int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
    
    if(widthSpecMode = MeasureSpec.AT_MOST && heightSpecMode = MeasureSpec.AT_MOST){
        setMeasureDimension(mWidth,mHeight);
    }else if(widthSpecMode = MeasureSpec.AT_MOST){
        setMeasureDimension(mWidth,heightSpecSize);
    }else if(heightSpecMode = MeasureSpec.AT_MOST){
        setMeasureDimension(widthSpecSize,mHeight);
    }
    
}
```

#### ViewGroup的measure过程

> 除了完成自身的measure过程之外，还要去遍历调用所有子元素的measure方法，各个子元素再去递归执行这个过程。
>
> **先Measure子View，再Measure自己**

ViewGroup中没有定义`onMeasure()`，定义了一个`measureChildren()`。

```java
// ../android/view/ViewGroup.java
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
        final int size = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i < size; ++i) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {
                //遍历对每一个子元素进行测量过程
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
            }
        }
    }
```

循环调用`measureChild()`

```java
// ../android/view/ViewGroup.java
protected void measureChild(View child, int parentWidthMeasureSpec,
            int parentHeightMeasureSpec) {
        //获得子View的LayoutParams
        final LayoutParams lp = child.getLayoutParams();
        //
        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }

 //子View的MEasureSpec由父View的MEasureSpec以及自身的LayoutParams共同决定
    public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        //padding代指父View已占用的空间，子View无法使用，所以子View的空间需要减去padding部分
        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    }
```

由于ViewGroup有不同布局的需要，很难统一，所以没有提供统一的`onMeasure()`方法，而是让子类自己去实现`onMeasure()`。



![ViewGroup-Measure](/images/ViewGroup-Measure.png)

根据上述流程图，简单总结一下：

- ViewGroup调用自身的`measureChildren()`，里面遍历自己的子View
- 遍历后调用`measureChild()`，准备给每一个子View计算它的`MeasureSpec`
- 调用`getChildMeasureSpec()`计算子View的`MeasureSpec`，需要结合父布局的`MeasureSpec`以及子View的`LayoutParams`共同得出结果
- 调用子View的`measure()`，完成子View的测量过程。
- 合并子View的测量值，得到ViewGroup的测量值

#### 拓展

1. 在Activity启动时获取View的尺寸？
   - 在 Activity#onWindowFocusChanged 回调中获取宽高。<br>`当Activity得到焦点或失去焦点的时候，这个方法都会被频繁调用`
   - view.post(runnable)，在 runnable 中获取宽高。
     `利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。`
   - ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。
     `监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露`
   - 调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高<br>`手动对view进行measure来得到View的尺寸。`

### layout-布局

>ViewGroup用来确定子元素的位置，当ViewGroup位置被确定后，在`onLayout()`中遍历所有子View，并调用其`layout()`。
>
>**先layout自身后layout子元素。**

#### View的layout过程

主要是由View的`layout()`方法实现

```java
// ../android/view/View.java   
public void layout(int l, int t, int r, int b) {
        if ((mPrivateFlags3 & PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
        }
        
        //左上角顶点距父容器左边的距离
        int oldL = mLeft;
        //左上角顶点距父容器上边的距离
        int oldT = mTop;
        //右下角顶点距父容器上边的距离
        int oldB = mBottom;
        //右下角顶点距父容器上边的距离
        int oldR = mRight;
        //
        boolean changed = isLayoutModeOptical(mParent) ?
                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

        if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
            onLayout(changed, l, t, r, b);
            ...
        }
        ...
    }

//由于子View下是没有子类了，所以该方法内不没有任何代码实现 一般自定义View是不需要重写该方法的
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    
    }

private boolean setOpticalFrame(int left, int top, int right, int bottom) {
        Insets parentInsets = mParent instanceof View ?
                ((View) mParent).getOpticalInsets() : Insets.NONE;
        Insets childInsets = getOpticalInsets();
        //根据特效边框重新计算四个顶点的位置，然后调用setFrame重新计算
        return setFrame(
                left   + parentInsets.left - childInsets.left,
                top    + parentInsets.top  - childInsets.top,
                right  + parentInsets.left + childInsets.right,
                bottom + parentInsets.top  + childInsets.bottom);
    }

protected boolean setFrame(int left, int top, int right, int bottom) {
             boolean changed = false;

        if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
            changed = true;

            // Remember our drawn bit
            int drawn = mPrivateFlags & PFLAG_DRAWN;

            int oldWidth = mRight - mLeft;
            int oldHeight = mBottom - mTop;
            int newWidth = right - left;
            int newHeight = bottom - top;
            boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);

            // Invalidate our old position
            invalidate(sizeChanged);
            //重新计算View的四个顶点距父布局左上边框的距离
            mLeft = left;
            mTop = top;
            mRight = right;
            mBottom = bottom;
            mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);
            ...
        }
}


//判断当前View是否存在阴影或者外发光等边框效果
public static boolean isLayoutModeOptical(Object o) {
        return o instanceof ViewGroup && ((ViewGroup) o).isLayoutModeOptical();
    }
```



![View-Layout](/images/View-Layout.png)

按照流程图总结一下：

- View调用`layout()`开始布局过程(`确定最终宽高以及四个顶点的位置`)
- 根据是否有边缘效果(`例如发光，阴影`)
  - 有边缘效果，调用`setOpticalFrame()`去除边缘的影响，最终还是调用`setFrame()`设立自己的四个顶点
  - 无边缘效果，调用`setFrame()`设立自己的四个顶点
- 最后调用`onLayout()`最终确立宽高以及四点坐标。



#### ViewGroup的layout过程

当有子View存在的时候，需要遍历子View进行`layout`过程。即需要在`onLayout()`方法实现子View的`layout`。

```java
//源码与上述相同 由于ViewGroup中所有子View的layout都需要实现，所以需要实现 onLayout() 方法
protected void onLayout(boolean changed,int left,int top,int right,int bottom){
    //遍历子View
    for (int i =0 ; i <getChildCount();i++){
        View child = getChildAt(i);
        
        //在这里可以添加 顶点变化逻辑
        int childTop = Top;
        int childLeft = Left;
        int childBottom = Bottom;
        int childRight = Right;
         
        ...
        setChildFrame(child,childLeft,childTop,childRight,childBottom);
    }
}

private void setChildFrame(child,int l,int t,int r,int b){
    //按照上一节流程走
    child.layout(l,t,r,b);
}
```

![ViewGroup-Layout](/images/ViewGroup-Layout.png)

按照流程图简单总结一下：

- 先调用ViewGroup的`layout()`，先对ViewGroup进行布局过程
- 在ViewGroup的`onLayout()`中实现子View的遍历布局过程
- 对遍历的子View按照ViewGroup的要求进行顶点坐标的计算，计算完成后调用子View的`layout()`



拓展：

1. View的测量宽/高(`getMeasureWidth()/getMeasureHeight()`)与最终得到的宽/高(`getWidth()/getHeight()`)有什么区别？

   ```java
   //	获得View在测量过程中的宽
   public final int getMeasuredWidth() {
           return mMeasuredWidth & MEASURED_SIZE_MASK;
       }
   //	获得View在测量过程中的高
   public final int getMeasuredHeight() {
           return mMeasuredHeight & MEASURED_SIZE_MASK;
       }
   //	上节 measure 源码分析中就是调用了该方法 进行View的测量
   private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {
           mMeasuredWidth = measuredWidth;
           mMeasuredHeight = measuredHeight;
           mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
       }
   //获得View最终宽
   public final int getWidth() {
           return mRight - mLeft;
       }
   //获得View最终高
   public final int getHeight() {
           return mBottom - mTop;
       }
   ```

   > 两者的比较



| 类型                                                      | 何时赋值            | 赋值方法                                  | 使用场景                        |
| :-------------------------------------------------------- | ------------------- | ----------------------------------------- | ------------------------------- |
| View测量结束宽/高<br>getMeasureWidth()/getMeasureHeight() | View的`measure`过程 | `setMeasureDimension()`                   | 在`onLayout()`获取View的宽/高   |
| View最终宽/高<br>getWidth()/getHeight()                   | View的`layout`过程  | `layout()`对top,left,right,bottom进行操作 | `onLayout()`结束后获取最终宽/高 |

   **一般情况下，二者返回的数据是相同的，除非人为对View的`layout()`进行重写。**

   ```java
   public void layout(int l,int t,int r,int b){
       super.layout(j,t,r+100,b+100);
   }
   ```

   上述代码就会导致View最终结果与测量时不同。

### draw-绘制

> draw作用主要将View绘制在屏幕上面
>
> **draw过程，先draw自身再draw子View**



#### View的draw过程

View的draw过程，从`View.draw()`开始

```java
// ../android/view/View.java
public void draw(Canvas canvas) {
    //标记当前View是否需要绘制背景
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&
                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    
    int saveCount;
        //1. 绘制背景
    if (!dirtyOpaque) {
            drawBackground(canvas);
        }
    final int viewFlags = mViewFlags;
    //是否有水平边缘
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    //是否有竖直边缘
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if(!horizontalEdges && !verticalEdges){
       // 3.绘制View本身
          if (!dirtyOpaque) onDraw(canvas);

       // 4.绘制子View
          dispatchDraw(canvas);
        
       // 6.绘制装饰 例如滚动条
          onDrawForeground(canvas);
        
    ...
       return; 
    }
    
    //如果有竖直边缘或者水平边缘 例如divide
    
    // 2. 保存当前Canvas层
        saveCount = canvas.getSaveCount();
        int solidColor = getSolidColor();
        if (solidColor == 0) {
            final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;
            if (drawTop) {
                canvas.saveLayer(left, top, right, top + length, null, flags);
            }
            if (drawBottom) {
                canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
            }
            if (drawLeft) {
                canvas.saveLayer(left, top, left + length, bottom, null, flags);
            }
            if (drawRight) {
                canvas.saveLayer(right - length, top, right, bottom, null, flags);
            }
        } else {
            scrollabilityCache.setFadeColor(solidColor);
        }
    ...
        // 3.绘制View本身
          if (!dirtyOpaque) onDraw(canvas);

       // 4.绘制子View
          dispatchDraw(canvas);
    
    ...
        // 5.绘制边缘效果 例如阴影
        canvas.restoreToCount(saveCount);
    ...
        
       // 6.绘制装饰 例如滚动条
          onDrawForeground(canvas);
    ...
    
}

//绘制View本身的背景
private void drawBackground(Canvas canvas) {
        final Drawable background = mBackground;
        if (background == null) {
            return;
        }
        //设置View的背景边界
        setBackgroundBounds();
        ...
          
        final int scrollX = mScrollX;
        final int scrollY = mScrollY;
        if ((scrollX | scrollY) == 0) {
            background.draw(canvas);
        } else {
            //将画布偏移 然后在偏移后的画布上进行背景绘制
            canvas.translate(scrollX, scrollY);
            background.draw(canvas);
            canvas.translate(-scrollX, -scrollY);
        }
    }

//绘制View本身的内容
protected void onDraw(Canvas canvas) {
    // 默认空实现 需要子类复写该方法以实现内容的绘制 ，自定义View中必须执行该方法
    }

//绘制子View的内容
protected void dispatchDraw(Canvas canvas) {
    //由于View不存在子View，所以不需要实现
    }

//绘制装饰 例如滚动条 前景图片
public void onDrawForeground(Canvas canvas) {
        onDrawScrollIndicators(canvas);
        onDrawScrollBars(canvas);

        final Drawable foreground = mForegroundInfo != null ? mForegroundInfo.mDrawable : null;
        if (foreground != null) {
            if (mForegroundInfo.mBoundsChanged) {
                mForegroundInfo.mBoundsChanged = false;
                final Rect selfBounds = mForegroundInfo.mSelfBounds;
                final Rect overlayBounds = mForegroundInfo.mOverlayBounds;

                if (mForegroundInfo.mInsidePadding) {
                    selfBounds.set(0, 0, getWidth(), getHeight());
                } else {
                    selfBounds.set(getPaddingLeft(), getPaddingTop(),
                            getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());
                }

                final int ld = getLayoutDirection();
                Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),
                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);
                foreground.setBounds(overlayBounds);
            }

            foreground.draw(canvas);
        }
    }
```

![View-Draw](/images/View-Draw.png)

结合上述流程图分析Draw过程：

- 先调用`View.draw()`方法开始Draw流程
- 如果需要`dirtyOpaque`，就绘制背景`drawBackground()`
- 如果需要显示边缘效果，就进行保存画布`canvas.saveLayer()`
- 如果需要`dirtyOpaque`，绘制自身的内容`onDraw()` -- **自定义View必须实现**
- 调用`dispatchDraw()`绘制子View
- 如果需要显示边缘效果，绘制后，还原画布`canvas.restore()`
- 调用`drawForeground()`绘制装饰，例如滚动条或前景

#### ViewGroup的draw过程

ViewGroup的draw过程主要调整了上述源码中的`dispatchDraw()`，在其内部进行了子View的遍历以及绘制过程

```java
 // ../android/view/ViewGroup.java
protected void dispatchDraw(Canvas canvas) {
        boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
        final int childrenCount = mChildrenCount;
        final View[] children = mChildren;
    ...
        for (int i = 0; i < childrenCount; i++) {
            while (transientIndex >= 0 && mTransientIndices.get(transientIndex) == i) {
                final View transientChild = mTransientViews.get(transientIndex);
                if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE ||
                        transientChild.getAnimation() != null) {
                    more |= drawChild(canvas, transientChild, drawingTime);
                }
                transientIndex++;
                if (transientIndex >= transientCount) {
                    transientIndex = -1;
                }
            }

            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                more |= drawChild(canvas, child, drawingTime);
            }
        }
    ...
}

//绘制子View
protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
      //调用子View的draw方法
      return child.draw(canvas, this, drawingTime);
}


```

![ViewGroup-Draw](/images/ViewGroup-Draw.png)

结合上述流程图分析ViewGroup的Draw过程：

- draw过程与上述`View的draw过程一致`
- `dispatchDraw()`默认实现，内部包含了子View的遍历以及绘制

拓展：

1. `View.setWillNotDraw()`有什么意义?

   ```java
       public void setWillNotDraw(boolean willNotDraw) {
           //设置 不需绘制 标记位
           setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);
       }
   ```

   如果一个View不需要绘制任何内容，设置这个标记为`true`，系统就会进行相应优化。

   ***View默认不开启`willNotDraw`标记位，ViewGroup默认开启。***
   
2. `ViewGroup`修改子View绘制顺序

   ```java ViewGroup.java
   protected void dispatchDraw(Canvas canvas){
     ...
       //设置自定义绘制顺序
      final ArrayList<View> preorderedList = usingRenderNodeProperties
                   ? null : buildOrderedChildList();
           //是否允许自定义绘制顺序
           final boolean customOrder = preorderedList == null
                   && isChildrenDrawingOrderEnabled();
           for (int i = 0; i < childrenCount; i++) {
               while (transientIndex >= 0 && mTransientIndices.get(transientIndex) == i) {
                   final View transientChild = mTransientViews.get(transientIndex);
                   if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE ||
                           transientChild.getAnimation() != null) {
                       more |= drawChild(canvas, transientChild, drawingTime);
                   }
                   transientIndex++;
                   if (transientIndex >= transientCount) {
                       transientIndex = -1;
                   }
               }
   
               final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
               final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
               if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                   more |= drawChild(canvas, child, drawingTime);
               }
           }
     ...
   }

       protected boolean isChildrenDrawingOrderEnabled() {
           return (mGroupFlags & FLAG_USE_CHILD_DRAWING_ORDER) == FLAG_USE_CHILD_DRAWING_ORDER;
       }
   //设置是否允许自定义绘制顺序
       protected void setChildrenDrawingOrderEnabled(boolean enabled) {
           setBooleanFlag(FLAG_USE_CHILD_DRAWING_ORDER, enabled);
       }
   
    //初始子View的绘制顺序 按照z轴的值调整绘制顺序，z轴从大到小绘制
       ArrayList<View> buildOrderedChildList() {
           final int childrenCount = mChildrenCount;
           if (childrenCount <= 1 || !hasChildWithZ()) return null;
   
           if (mPreSortedChildren == null) {
               mPreSortedChildren = new ArrayList<>(childrenCount);
           } else {
               // callers should clear, so clear shouldn't be necessary, but for safety...
               mPreSortedChildren.clear();
               mPreSortedChildren.ensureCapacity(childrenCount);
           }
   
           final boolean customOrder = isChildrenDrawingOrderEnabled();
           for (int i = 0; i < childrenCount; i++) {
               // add next child (in child order) to end of list
               final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
               final View nextChild = mChildren[childIndex];
               final float currentZ = nextChild.getZ();
   
               // insert ahead of any Views with greater Z
               int insertIndex = i;
               while (insertIndex > 0 && mPreSortedChildren.get(insertIndex - 1).getZ() > currentZ) {
                   insertIndex--;
               }
               mPreSortedChildren.add(insertIndex, nextChild);
           }
           return mPreSortedChildren;
       }
   
       //确定当前子View的绘制顺序
       private int getAndVerifyPreorderedIndex(int childrenCount, int i, boolean customOrder) {
           final int childIndex;
           if (customOrder) {
               final int childIndex1 = getChildDrawingOrder(childrenCount, i);
               if (childIndex1 >= childrenCount) {
                   throw new IndexOutOfBoundsException("getChildDrawingOrder() "
                           + "returned invalid index " + childIndex1
                           + " (child count is " + childrenCount + ")");
               }
               childIndex = childIndex1;
           } else {
               childIndex = i;
           }
           return childIndex;
       }
   //需要重写该方法，调整绘制顺序
       protected int getChildDrawingOrder(int childCount, int i) {
           return i;
       }
   
   //调整当前子View顺序
       private static View getAndVerifyPreorderedView(ArrayList<View> preorderedList, View[] children,
               int childIndex) {
           final View child;
           if (preorderedList != null) {
               child = preorderedList.get(childIndex);
               if (child == null) {
                   throw new RuntimeException("Invalid preorderedList contained null child at index "
                           + childIndex);
               }
           } else {
               child = children[childIndex];
           }
           return child;
       }
   ```
   
   根据上述源码，默认的绘制**按照z轴从大到小的顺序**进行绘制，如果需要修改绘制顺序的话，需要执行以下两步：
   
   1. `setChildrenDrawingEnabled(true)`打开自定义设置开关
   2. 继承`ViewGroup`后，重写`getChildDrawingOrder()`方法，设置对应的绘制顺序
   
   常用的`RecyclerView`、`ViewPager`都实现了该方法，其中`RecyclerView`通过设置`ChildDrawingOrderCallback`也可以实现这个功能。

## 自定义View

> 自定义View需要了解View的层次、View的事件分发机制以及View的工作流程。

### 分类

#### 1.继承View重写`onDraw()`

> 主要用于实现一些不规则的效果，不方便通过布局的组合方法可以直接实现，往往需要静态或者动态的显示一些不规则图形(圆形啥的)。
>
> 特殊形状的这种就需要重写`onDraw()`实现。**一般需要额外支持wrtap_content，并且也需要处理padding方法。**

#### 2.继承ViewGroup派生特殊的Layout

> 主要用于实现自定义的布局，除了常用的一些布局外。实现的是几种View的组合形式
>
> **实现稍微复杂，需要合适的处理ViewGroup的`onMeasure()，onLayout()`以及子View的`onMeasure()，onLayout()`**

#### 3.继承特定的View(例如TextView)

> 这种比较常见，一般用于拓展已有View的功能。
>
> **实现比较简单，无需自己处理wrap_content以及padding**

#### 4.继承特定的ViewGroup(例如LinearLayout)

> 比较常见，当某种效果看起来很像几种View组合在一起的时候
>
> **实现比较简单，无需自己处理测量以及布局过程**

### 注意事项

#### 1.让View支持wrap_content

> 直接继承View或ViewGroup的控件，不重写`onMeasure()`并对`AT_MOST`进行处理，就无法达到需要的显示效果。

#### 2.需要的话，让View支持padding

> 直接继承View的控件，需要在`draw`过程处理padding属性，不然padding属性无法起作用。
>
> 直接继承ViewGroup的控件，需要在`onMeasure()，onLayout()`处理自身的padding以及子View的margin

#### 3.尽量不要在View中使用Handler

> View内部提供了`post`方法，可以替代Handler使用

#### 4.View中如果有线程或动画，需要及时停止

> 1. 不处理有可能造成内存泄漏，View不可见时也需要停止线程和动画
> 2. 包含View的Activity启动时，View的`onAccachedToWindow()`会调用
> 3. 包含View的Activity退出或当前View被移除时，调用`View.onDetachedFromWindow()`时关闭线程和动画

#### 5.View若有滑动冲突情况，需要处理

### 实例

{% post_link 自定义View实践%}

{% post_link 自定义ViewGroup实践%}

## 拓展

### 如何触发View的重新绘制？

通过调用`invalidate()/postInvalidate()`或`requestLayout()`实现。

#### requestLayout

> 在需要刷新`View`的布局时会调用该函数。不应该在布局的过程中调用这个函数。
>
> 这个请求可能会在以下场景执行：当前布局结束、当前帧绘制完成，下次布局发生时

```java
//View.java
    public void requestLayout() {
        if (mMeasureCache != null) mMeasureCache.clear();

        if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == null) {
            // Only trigger request-during-layout logic if this is the view requesting it,
            // not the views in its parent hierarchy
            ViewRootImpl viewRoot = getViewRootImpl();
            if (viewRoot != null && viewRoot.isInLayout()) {
                if (!viewRoot.requestLayoutDuringLayout(this)) {
                  //如果当前在layout过程中，且调用了 requestLayout，就需要直接返回
                  //等待下一次信号到来时执行
                    return;
                }
            }
            mAttachInfo.mViewRequestingLayout = this;
        }
        //设置强制刷新标记
        mPrivateFlags |= PFLAG_FORCE_LAYOUT;//该标记可执行onMeasure()
        mPrivateFlags |= PFLAG_INVALIDATED;//

        if (mParent != null && !mParent.isLayoutRequested()) {
            //向父布局继续请求刷新布局
            mParent.requestLayout();
        }
        if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == this) {
            mAttachInfo.mViewRequestingLayout = null;
        }
    }


```

`mParent`对应父节点，一层层向上递归调用父节点`requestLayout()。`直到调用`ViewRootImpl.requestLayout()`结束.

```java
//ViewRootImpl.java
    @Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
          //检查当前是否主线程
            checkThread();
            mLayoutRequested = true;
            scheduleTraversals();
        }
    }
```

调用到`scheduleTraversals()`就是开始了`View的绘制流程`。

一开始调用的`performMeasure()`

```java
//ViewRootImpl.java
    private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
       ...
        try {
            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }


//View.java
    public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
      ...
        //需要执行onMeasure
        final boolean forceLayout = (mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;
      ...
        if (forceLayout || needsLayout) {
          ...
            onMeasure(widthMeasureSpec, heightMeasureSpec);
          ...
            //添加 PFLAG_LAYOUT_REQUIRED标记，表示需要执行 layout流程
             mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
        }
    }
```

继续向下调用`performLayout()`

```java
//ViewRootImpl.java
    private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,
            int desiredWindowHeight) {
       //正在执行layout流程
       mInLayout = true;

       final View host = mView;//对应DecorView
       //在layout过程中 尚未执行requestLayout的view
       int numViewsRequestingLayout = mLayoutRequesters.size();
       if (numViewsRequestingLayout > 0) {
          //寻找mPrivateFlags为PFLAG_FORCE_LAYOUT的View
           ArrayList<View> validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,
                        false);
                if (validLayoutRequesters != null) {
                  //当前View重新measure
                     measureHierarchy(host, lp, mView.getContext().getResources(),
                            desiredWindowWidth, desiredWindowHeight);     
                  //重新执行layout
                     host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());  
                  ...
                    //寻找尚未设置 PFLAG_FORCE_LAYOUT的View
                     validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true);                   
                     if (validLayoutRequesters != null) {
                        final ArrayList<View> finalRequesters = validLayoutRequesters;
                        // 执行requestLayout在下一帧执行时
                        getRunQueue().post(new Runnable() {
                            @Override
                            public void run() {
                                int numValidRequests = finalRequesters.size();
                                for (int i = 0; i < numValidRequests; ++i) {
                                    final View view = finalRequesters.get(i);
                                    Log.w("View", "requestLayout() improperly called by " + view +
                                            " during second layout pass: posting in next frame");
                                    view.requestLayout();
                                }
                            }
                        });
                    }                 
                }
       }
      
    }
```

主要执行了三步：

- 执行`DecorView`的`layout`过程
- 执行调用过`requestLayout()`的View(包含`PFLAG_FORCE_LAYOUT`标志)的`measure`和`layout`
- 还没调用过`requestLayout()`的View加入到队列中，等待下一帧绘制时执行

```java
//View.java
    public void layout(int l, int t, int r, int b) {
      //判断当前位置是否发生变化
        boolean changed = isLayoutModeOptical(mParent) ?
                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);      
      //位置发生变化。或 需要layout
        if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
          //回调onLayout()
            onLayout(changed, l, t, r, b);
          ...
         //移除 PFLAG_LAYOUT_REQUIRED标志 在measure过程添加   
          mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;
          ...
        }
      ...
        //layout过程完成后 移除 PFLAG_FORCE_LAYOUT标志
        mPrivateFlags &= ~PFLAG_FORCE_LAYOUT;        
      
    }

    protected boolean setFrame(int left, int top, int right, int bottom) {
      //位置发生变化时，就需要执行 invalidate()重绘View
      if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
         boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);
          //需要重绘视图
            invalidate(sizeChanged);
      }
    }
```



>`requestLayout()`主要执行了以下几步：
>
>- 添加`PFLAG_FORCE_LAYOUT`和`PFLAG_INVALIDATED`标记
>- `measure`执行需要判断`PFLAG_FORCE_LAYOUT`标记是否存在
>- `measure`执行后，添加`PFLAG_LAYOUT_REQUIRED`标记，可以去执行`onLayout()`
>- `layout`执行后，移除`PFLAG_LAYOUT_REQUIRED`和`PFLAG_FORCE_LAYOUT`标记
>- 在`layout`过程中，如果位置发生了变化，会执行到`invalidate()`，可能会执行`draw`过程；如果未发生变化，就不会执行`draw`过程

#### invalidate/postInvalidate

> `invalidate()`必须在主线程调用。`postInvalidate()`可以在子线程调用(通过handler发送消息到主线程调用)
>
> 主要用于请求View的重绘，只会影响到View的`draw`过程

```java
//View.java
    public void postInvalidate() {
        postInvalidateDelayed(0);
    }

    public void dispatchInvalidateDelayed(View view, long delayMilliseconds) {
        Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);
        mHandler.sendMessageDelayed(msg, delayMilliseconds);
    }

    @Override
    public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_INVALIDATE:
                    ((View) msg.obj).invalidate();//继续执行到invalidate()
                    break;
                ...
            }
    }

    public void invalidate() {
        invalidate(true);
    }
```

最终执行到`invalidateInternal()`

```java
//View.java
    void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,
            boolean fullInvalidate) {
        ...
        //当前View不可见
        if (skipInvalidate()) {
            return;
        }

        if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)
                || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)
                || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED//当前没有执行invalidate
                || (fullInvalidate && isOpaque() != mLastIsOpaque)) {
          //需要全量重绘
            if (fullInvalidate) {
                mLastIsOpaque = isOpaque();
              //添加重绘标记
                mPrivateFlags &= ~PFLAG_DRAWN;
            }
           //添加当前View重绘标记
            mPrivateFlags |= PFLAG_DIRTY;
           //是否刷新缓存
            if (invalidateCache) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            }

            // Propagate the damage rectangle to the parent view.
            final AttachInfo ai = mAttachInfo;
            final ViewParent p = mParent;
            if (p != null && ai != null && l < r && t < b) {
                final Rect damage = ai.mTmpInvalRect;
                damage.set(l, t, r, b);
              //设置重绘区域 并把自身传递到父布局
                p.invalidateChild(this, damage);
            }
          ...
        }
    }
```

上述代码修改标记完成后，调用父类的`invalidateChild()`将需要重绘的区域(`脏区域`)传入。(`ViewGroup以及ViewRootImpl都继承自ViewParent类`)

> 脏区域：*为了保证绘制的效率，控件树仅对需要绘制的区域进行重绘，需要重绘的区域成为`脏区域`*。

```java
//ViewGroup.java
    public final void invalidateChild(View child, final Rect dirty) {
      //开启硬件加速
        if (attachInfo != null && attachInfo.mHardwareAccelerated) {
            // 更新DisplayList
            onDescendantInvalidated(child, child);
            return;
        }      
         //当前View是否 不透明
        final boolean isOpaque = child.isOpaque() && !drawAnimation &&
                    child.getAnimation() == null && childMatrix.isIdentity(); 
        //全不透明 标记为 PFLAG_DIRTY_OPAQUE
        //部分透明 标记为 PFLAG_DIRTY
        int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;
      ...
        do {
                View view = null;
                if (parent instanceof View) {
                    view = (View) parent;
                }

                if (drawAnimation) {
                    if (view != null) {
                        view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                    } else if (parent instanceof ViewRootImpl) {
                        ((ViewRootImpl) parent).mIsAnimating = true;
                    }
                }

                // If the parent is dirty opaque or not dirty, mark it dirty with the opaque
                // flag coming from the child that initiated the invalidate
                if (view != null) {
                    if ((view.mViewFlags & FADING_EDGE_MASK) != 0 &&
                            view.getSolidColor() == 0) {
                        opaqueFlag = PFLAG_DIRTY;
                    }
                    if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {
                        view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;
                    }
                }
                //递归调用父布局的重绘方法
                parent = parent.invalidateChildInParent(location, dirty);
                //计算需要重绘区域
                dirty.set((int) Math.floor(boundingRect.left),
                                (int) Math.floor(boundingRect.top),
                                (int) Math.ceil(boundingRect.right),
                                (int) Math.ceil(boundingRect.bottom));                
          ...
            } while (parent != null);
      
    }

//ViewGroup.java
    public ViewParent invalidateChildInParent(final int[] location, final Rect dirty) {
        if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != 0) {
          //将子View转换为当前View显示的位置
          ...
        }
    }
```

当`parent==null`时，表示已经到了最顶层`ViewRootImpl`

```java
//ViewRootImpl.java
    public ViewParent invalidateChildInParent(int[] location, Rect dirty) {
      //检查当前是否主线程
        checkThread();
        if (DEBUG_DRAW) Log.v(mTag, "Invalidate child: " + dirty);

        if (dirty == null) {
            invalidate();
            return null;
        } else if (dirty.isEmpty() && !mIsAnimating) {
            return null;
        }
       ...
      //更新屏幕对应脏区域
        invalidateRectOnScreen(dirty);

        return null;
    }

    private void invalidateRectOnScreen(Rect dirty) {
        final Rect localDirty = mDirty;
        if (!localDirty.isEmpty() && !localDirty.contains(dirty)) {
            mAttachInfo.mSetIgnoreDirtyState = true;
            mAttachInfo.mIgnoreDirtyState = true;
        }

        // Add the new dirty rect to the current one
        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);
        // Intersect with the bounds of the window to skip
        // updates that lie outside of the visible region
        final float appScale = mAttachInfo.mApplicationScale;
        final boolean intersected = localDirty.intersect(0, 0,
                (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));
        if (!intersected) {
            localDirty.setEmpty();
        }
        if (!mWillDrawSoon && (intersected || mIsAnimating)) {
          //执行绘制流程
            scheduleTraversals();
        }
    }
```

通过`scheduleTraversals()`执行绘制流程，由于未设置`PFLAG_FORCE_LAYOUT`无法执行`measure`过程，如果位置没有发生变化后续`layout`也无法执行。

最后调用`performDraw()`

```java
//ViewRootImpl.java
    private void performDraw() {
      ...
        boolean canUseAsync = draw(fullRedrawNeeded);
    }

    private boolean draw(boolean fullRedrawNeeded) {
        if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) {
            if (mAttachInfo.mThreadedRenderer != null && mAttachInfo.mThreadedRenderer.isEnabled()) {
              //硬件绘制
              ...
                mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this, callback);              
            } else {
              //软件绘制
              ...
              if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,
                        scalingRequired, dirty, surfaceInsets)) {
                    return false;
                }
            }
          ...
    }
```

向下调用到`View.draw()`

```java
//View.java
    public void draw(Canvas canvas) {
        final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&
                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
        if (!dirtyOpaque) {
            drawBackground(canvas);//绘制背景
        }
        if (!dirtyOpaque) onDraw(canvas);//绘制自身
        dispatchDraw(canvas); //绘制子View 
        onDrawForeground(canvas);//绘制前景
    }
```

关键在于是否持有`PFLAG_DIRTY_OPAQUE`标志，这个标志主要是在`invalidate()`打上的。

> `invalidate()`通过设置`PFLAG_INVALIDATED`和`PFLAG_DRAWING_CACHE_VALID`标记，然后执行`invalidateChild()`通过层层向上调用`parent.invalidateChildInParent()`把需要重新绘制的区域传递上去，直到达到`ViewRootImpl`为止。最后调用到`invalidateRectOnScreen()`传入最终需要重新绘制的区域，开始执行绘制流程。
>
> **invalidate()会打上`PFLAG_DIRTY_OPAQUE`标记，只有这个标记才会执行`onDraw()`。**

#### 两者区别

`rquestLayout()`和`invalidate()`都可以触发整个绘制流程，但是触发`measure`、`layout`、`draw`各条件都不同

- `measure`过程触发：`mPrivateFlags`包含`PFLAG_FORCE_LAYOUT`
- `layout`过程触发：`mPrivateFlags`包含`PFLAG_LAYOUT_REQUIRED(measure执行后添加)`或者`位置发生变化`
- `draw`过程触发：`mPrivateFlags`包含`PFLAG_DIRTY_OPAQUE`

`requestLayout()`主要用来设置`PFLAG_FORCE_LAYOUT`标志，会执行到`measure、layout`过程，如果位置发生变化则可能执行`draw`过程

`invalidate()`主要用来设置`PFLAG_DIRTY_OPAQUE`标志，若发生位置变化会执行`layout`过程，继续往后执行`draw`过程



### include、merge、ViewStub作用以及实现

{% post_link include、merge-ViewStub相关%}

### View的层级计算

```java
//实际形成一个二叉树 递归计算深度    
private int maxViewDeep(View view) {
        if (!(view instanceof ViewGroup)) {
            return 0;
        }

        ViewGroup vp = (ViewGroup) view;
        if (vp.getChildCount() == 0) {
            return 0;
        }

        int max = 0;
        int count = vp.getChildCount();
        for (int i = 0; i < count; i++) {
            int deep = maxViewDeep(vp.getChildAt(i)) + 1;
            if (deep > max) {
                max = deep;
            }
        }
        return max;
    }
```



### AsyncLayoutInflater异步加载

{% post_link Android布局优化-AsyncLayoutInflater简析 AsyncLayoutInflater%}

### inflate()时，`root`与`attachToRoot`的结果源码



### `MeasureSpec.UNSPECIFIED`使用场景

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android布局优化-AsyncLayoutInflater简析</title>
    <url>/2020/11/02/Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96-AsyncLayoutInflater%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[
![AsyncLayoutInflater](/images/AsyncLayoutInflater.png)

布局加载过程中存在两个耗时点：

1. 布局文件读取慢，涉及IO操作
2. 根据`<tag>`创建View慢(`createViewFromTag()`)，使用反射的方式创建View。*布局嵌套层数越多，控件个数越多，反射的次数就会越多*。

当XML文件过大、嵌套过深时，就会导致页面发生卡顿甚至ANR。

解决方案有两种：

1. **直接解决**：不使用IO操作以及反射
2. **侧面缓解**：把耗时操作放到子线程，等待加载完毕返回主线程展示即可。下面提到的`AsyncLayoutInflater`就是使用这个方案。

## AsyncLayoutInflater

采用**异步加载**的方式去加载布局，可以节省主线程时间，并且在异步加载完毕后回到主线程。

## 使用方法

```java
        new AsyncLayoutInflater(this).inflate(R.layout.XX, null, new AsyncLayoutInflater.OnInflateFinishedListener() {
            @Override
            public void onInflateFinished(@NonNull View view, int i, @Nullable ViewGroup viewGroup) {
                setContentView(view);
            }
        });
```

## 基本原理

### 构造方法

```java
public final class AsyncLayoutInflater {
    LayoutInflater mInflater;//布局加载器
    Handler mHandler;//处理加载完成消息
    InflateThread mInflateThread;//执行加载任务

     public AsyncLayoutInflater(@NonNull Context context) {
        mInflater = new BasicInflater(context);
        mHandler = new Handler(mHandlerCallback);
        mInflateThread = InflateThread.getInstance();
    }
}
```

#### BasicInflater

自定义加载器。实现类似`PhoneLayoutInflater(默认布局加载器)`

```java

    private static class BasicInflater extends LayoutInflater {
      //优先在这三个包下加载
        private static final String[] sClassPrefixList = {
            "android.widget.",
            "android.webkit.",
            "android.app."
        };

        BasicInflater(Context context) {
            super(context);
        }

        @Override
        public LayoutInflater cloneInContext(Context newContext) {
            return new BasicInflater(newContext);
        }

        @Override
        protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException {
            for (String prefix : sClassPrefixList) {
                try {
                  //加载View
                    View view = createView(name, prefix, attrs);
                    if (view != null) {
                        return view;
                    }
                } catch (ClassNotFoundException e) {
                    // In this case we want to let the base class take a crack
                    // at it.
                }
            }

            return super.onCreateView(name, attrs);
        }
    }
```



#### InflateThread

创建子线程，将`布局加载`请求加入`阻塞队列`中，按照插入顺序执行`LayoutInflater.inflate()`加载过程

```java
    private static class InflateThread extends Thread {
        private static final InflateThread sInstance;
        static {
            sInstance = new InflateThread();
            sInstance.start();
        }
      //阻塞队列 最多支持10个加载请求
        private ArrayBlockingQueue<InflateRequest> mQueue = new ArrayBlockingQueue<>(10);
      //对象池，缓存InflateThread对象
        private SynchronizedPool<InflateRequest> mRequestPool = new SynchronizedPool<>(10);    
      //对象池获取缓存对象
        public InflateRequest obtainRequest() {
            InflateRequest obj = mRequestPool.acquire();
            if (obj == null) {
                obj = new InflateRequest();
            }
            return obj;
        }
      //对象池回收对象，便于下次复用
        public void releaseRequest(InflateRequest obj) {
            obj.callback = null;
            obj.inflater = null;
            obj.parent = null;
            obj.resid = 0;
            obj.view = null;
            mRequestPool.release(obj);
        }      
      //将inflate请求添加到 阻塞队列中
        public void enqueue(InflateRequest request) {
            try {
                mQueue.put(request);
            } catch (InterruptedException e) {
                throw new RuntimeException(
                        "Failed to enqueue async inflate request", e);
            }
        }
      //需要执行的任务
        public void runInner() {
            InflateRequest request;
            try {
              //阻塞队列获取 任务，没任务则阻塞
                request = mQueue.take();
            } catch (InterruptedException ex) {
                // Odd, just continue
                Log.w(TAG, ex);
                return;
            }

            try {
              //调用BasicInflater去加载布局
                request.view = request.inflater.mInflater.inflate(
                        request.resid, request.parent, false);
            } catch (RuntimeException ex) {
                // Probably a Looper failure, retry on the UI thread
                Log.w(TAG, "Failed to inflate resource in the background! Retrying on the UI"
                        + " thread", ex);
            }
          //构建消息发送到Handler
            Message.obtain(request.inflater.mHandler, 0, request)
                    .sendToTarget();
        }

        @Override
        public void run() {
            while (true) {
                runInner();
            }
        }      
    }
```

`InflateThread`不管最后`inflate()`执行成功或失败，都会把结果发回到Handler进行处理。

```java
    private Handler.Callback mHandlerCallback = new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
          //获取加载结果
            InflateRequest request = (InflateRequest) msg.obj;
            if (request.view == null) {
              //异步加载失败，在主线程进行加载过程
                request.view = mInflater.inflate(
                        request.resid, request.parent, false);
            }
          //加载完成回调
            request.callback.onInflateFinished(
                    request.view, request.resid, request.parent);
          //回收加载请求
            mInflateThread.releaseRequest(request);
            return true;
        }
    };
```

`Handler`收到消息后，根据`InflateRequest.view`是否为空，判断接下执行步骤：

如果为空，回到主线程进行布局加载任务，加载完成后回调`onInflateFinished()`

不为空，直接回调`onInflateFinished()`

### inflate()

发起异步加载布局请求

```java
    @UiThread
    public void inflate(@LayoutRes int resid, @Nullable ViewGroup parent,
            @NonNull OnInflateFinishedListener callback) {
        if (callback == null) {
            throw new NullPointerException("callback argument may not be null!");
        }
      //构建InflateRequest对象
        InflateRequest request = mInflateThread.obtainRequest();
        request.inflater = this;
        request.resid = resid;
        request.parent = parent;
        request.callback = callback;
      //插入加载请求到阻塞队列
        mInflateThread.enqueue(request);
    }
```

#### InflateRequest

主线程和子线程之间传递的数据模型，主要封装了`异步加载`需要的参数

```java
    private static class InflateRequest {
        AsyncLayoutInflater inflater;//加载器
        ViewGroup parent;//父布局
        int resid;//布局id
        View view;//加载完成的View
        OnInflateFinishedListener callback;//加载完成回调

        InflateRequest() {
        }
    }
```

#### OnInflateFinishedListener

布局加载完成后回调

```java
    public interface OnInflateFinishedListener {
        void onInflateFinished(@NonNull View view, //加载完成的View
                               @LayoutRes int resid,
                @Nullable ViewGroup parent);
    }
```



> 使用`AsyncLayoutInflater`加载布局后，将需要加载的`layoutId`以及`OnInflateFinishedListener`构造成`InflateRequest`，插入到`InflateThread`的阻塞队列中，等待执行。任务执行完毕后，返回执行结果(`成功返回加载后的View，失败返回null`)。
>
> 通过`Handler`发送结果回到主线程，返回结果为`null`，则在主线程再次执行`布局加载`，得到结果后直接回调`onInflateFinished()`。

## 局限及改进

### 局限

1. `AsyncLayoutInflater`构造的`View`，无法直接使用`handler`或者调用`looper.myLooper`，因为没有进行初始化
2. `AsyncLayoutInflater`构造的`View`，不会自动加到`parent`中，需要手动加入
3. `AsyncLayoutInflater`不支持设置`Factory/Factory2`，未设置`mPrivateFactory`所以不支持包含`<fragment>`的布局
4. 最多支持10个布局加载，超出的布局需要等待。



### 改进

> `AsyncLayoutInflater`是`final`的，无法被继承。需要`copy`一份代码进行修改。

针对`4`可以内部替换成线程池，将加载布局请求放入线程池管理

针对`3`可以修改`BasicInflater`实现，内部支持`factory`设置

```java
        BasicInflater(Context context) {
            super(context);
            if (context instanceof AppCompatActivity) {
                // 加上这些可以保证AppCompatActivity的情况下，super.onCreate之前
                // 使用AsyncLayoutInflater加载的布局也拥有默认的效果
                AppCompatDelegate appCompatDelegate = ((AppCompatActivity) context).getDelegate();
                if (appCompatDelegate instanceof LayoutInflater.Factory2) {
                    LayoutInflaterCompat.setFactory2(this, (LayoutInflater.Factory2) appCompatDelegate);
                }
            }
        }
```



## 参考链接

[AsyncLayoutInfalter](https://www.jianshu.com/p/8548db25a475)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android硬件加速</title>
    <url>/2020/10/27/Android%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[
![Android硬件加速xmind](/images/Android硬件加速.png)

## 软硬件绘制的分歧点

绘制过程入口位于`ViewRootImpl.performDraw()`中

```java
//viewRootImpl.java
    private void performDraw() {
      ...
        try {
            //调用draw()执行实际的绘制工作
            boolean canUseAsync = draw(fullRedrawNeeded);
            if (usingAsyncReport && !canUseAsync) {
                mAttachInfo.mThreadedRenderer.setFrameCompleteCallback(null);
                usingAsyncReport = false;
            }
        } finally {
            mIsDrawing = false;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }
```

`ViewRootImpl.draw()`实际执行的绘制工作

```java
//ViewRootImpl.java
private boolean draw(boolean fullRedrawNeeded) {
  ...
    final Rect dirty = mDirty;//需要重新绘制的区域
  ...
    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) {
            //是否支持硬件加速
            if (mAttachInfo.mThreadedRenderer != null && mAttachInfo.mThreadedRenderer.isEnabled()) {
              ...
                mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this, callback);//硬件绘制
            } else {
              ...
                //软件绘制
                if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,
                        scalingRequired, dirty, surfaceInsets)) {
                    return false;
                }
            }
      ...
    }
  ...
  
}
```

## 软件绘制

![Android绘制-软件绘制](/images/Android绘制-软件绘制.png)

### ViewRootImpl软件绘制相关

> 未开启`硬件加速`时，执行到`drawSoftware()`

```java
    private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
            boolean scalingRequired, Rect dirty, Rect surfaceInsets) {
        // Draw with software renderer.
        final Canvas canvas;
      
       canvas = mSurface.lockCanvas(dirty);//获取用于绘制的Canvas
       ...
       mView.draw(canvas);//将mView的内容绘制到Canvas
       ...
       //将Canvas的内容显示到屏幕上,向SurfaceFlinger服务Queue一个Graphic Buffer
       surface.unlockCanvasAndPost(canvas);
    }
```

此处的`mView`对应的就是`DecorView`

```java
//DecorView.java
    @Override
    public void draw(Canvas canvas) {
        super.draw(canvas);

        if (mMenuBackground != null) {
            mMenuBackground.draw(canvas);
        }
    }
```

执行到`super.draw()`，`DecorView`继承自`FrameLayout`，等价于执行到`ViewGroup.draw()`。

```java
//View.java
    public void draw(Canvas canvas) {
      ...
        if (!dirtyOpaque) {
          //绘制背景
            drawBackground(canvas);
        }
        //绘制自身
        if (!dirtyOpaque) onDraw(canvas);
        //绘制子View 只有ViewGroup会实现该方法
        dispatchDraw(canvas);
        //绘制前景
        onDrawForeground(canvas);
      ...
    }
```

```java
//ViewGroup.java
    protected void dispatchDraw(Canvas canvas) {
      ...
        final ArrayList<View> preorderedList = usingRenderNodeProperties
                ? null : buildOrderedChildList();//绘制顺序按照Z值从大到小排列
        final boolean customOrder = preorderedList == null
                && isChildrenDrawingOrderEnabled();//允许自定义绘制顺序
        for (int i = 0; i < childrenCount; i++) {
            while (transientIndex >= 0 && mTransientIndices.get(transientIndex) == i) {
                final View transientChild = mTransientViews.get(transientIndex);
                if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE ||
                        transientChild.getAnimation() != null) {
                    more |= drawChild(canvas, transientChild, drawingTime);
                }
                transientIndex++;
                if (transientIndex >= transientCount) {
                    transientIndex = -1;
                }
            }

            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);//根据自定义顺序获取当前绘制的View的绘制顺序
            final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                more |= drawChild(canvas, child, drawingTime);
            }
        }
    }
    //绘制子View
    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
        return child.draw(canvas, this, drawingTime);
    }
```

`DecorView`是最顶层的View，自`drawSoftware()`开始绘制。

### View软件绘制相关

上一节后面执行到了`child.draw()`，`child`为`View`

```java
//View.java
boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) {
        final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
        //是否支持硬件绘制 显然当前情况不支持
        boolean drawingWithRenderNode = mAttachInfo != null
                && mAttachInfo.mHardwareAccelerated
                && hardwareAcceleratedCanvas;
  
         ...
           //后续绘制缓存会分析
          if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
             if (layerType != LAYER_TYPE_NONE) {
                 // If not drawing with RenderNode, treat HW layers as SW
                 layerType = LAYER_TYPE_SOFTWARE;
                 buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
         }
         //缓存可用 且 非硬件绘制条件下
         final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
         ...
         if (!drawingWithDrawingCache) {
            if (drawingWithRenderNode) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                ((DisplayListCanvas) canvas).drawRenderNode(renderNode);
            } else {
                // ViewGroup 不需要绘制背景直接 绘制子View
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            }
        }
       ...
}
```



```java
//View.java
        if ((changed & DRAW_MASK) != 0) {
            if ((mViewFlags & WILL_NOT_DRAW) != 0) {
                if (mBackground != null
                        || mDefaultFocusHighlight != null
                        || (mForegroundInfo != null && mForegroundInfo.mDrawable != null)) {
                    mPrivateFlags &= ~PFLAG_SKIP_DRAW;
                } else {
                    mPrivateFlags |= PFLAG_SKIP_DRAW;
                }
            } else {
                mPrivateFlags &= ~PFLAG_SKIP_DRAW;
            }
            requestLayout();
            invalidate(true);
        }
```

### 软件绘制流程



![软件绘制流程](/images/软件绘制流程.jpg)

## 硬件绘制



> 默认开启`硬件加速`，可以通过配置`android:hardwareAccelerated="false"`关闭硬件加速
>
> `把View中绘制的计算工作交给GPU来处理，就是把drawXX()相关的方法进行转换。`

`硬件绘制`主要包含两步：

- `构建阶段`

  > 遍历所有View，将需要绘制的操作缓存下来，构建`DisplayList`。交给`RenderThread`使用GPU进行硬件加速渲染。

- `绘制阶段`

  > 构建好的`DisplayList`交给`RenderThread`使用GPU进行硬件加速渲染，绘制的内容保存在`Graphic Buffer`并交由`SurfaceFlinger`显示。



### 控制硬件加速

![硬件绘制-控制硬件加速](/images/硬件绘制-控制硬件加速.png)

> 硬件绘制需要在`开启硬件加速`的条件下才可以执行

可以在以下级别控制`硬件加速`：

- **应用**

  在`AndroidManifest.xml`配置如下属性

  ```xml
  <application android:hardwareAccelerated="true" ...>
  ```

  

- **Activity**

  在`AndroidManifest.xml`配置如下属性

  ```xml
    <application android:hardwareAccelerated="true">
          <activity ... />
          <activity android:hardwareAccelerated="false" /> //控制某个Activity关闭硬件加速
      </application>
  ```

  

- **窗口Window**

  配置如下代码

  ```java
      getWindow().setFlags(
          WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
          WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
  ```

  

- **视图View**

  为单个视图停用硬件加速

  ```java
  myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
  ```

  

### DisplayList

![硬件绘制-DisplayList](/images/硬件绘制-DisplayList.png)

> 本质上是一个**缓冲区**，里面`记录即将执行的绘制命令序列`。

`DisplayList`的存在有两个好处：

1. 在绘制下一帧时，若View没有发生变化，就不必执行相关绘制API，直接复用上次的`DisplayList`。

2. 在绘制下一帧时，若View发生变化，但只是一些简单属性发生变化，就不需重建`DisplayList`，直接修改`DisplayList`相关属性即可。

   针对以下属性，都不需重建`DisplayList`

   - `alpha`：更改层的不透明度
   - `x`、`y`、`translationX`、`translationY`：更改层的位置
   - `scaleX`、`scaleY`：更改层的大小
   - `rotation`、`rotationX`、`rotationY`：更改层在 3D 空间里的方向
   - `pivotX`、`pivotY`：更改层的转换原点

以上在使用`DisplayList`的过程都不需要执行`onDraw()`。

![img](/images/DisplayList结构.png)

### RenderNode

> 在Android 5.0后引入，是对`DisplayList`以及`View显示属性`的封装。

**通常一个`RenderNode`对应一个`View`，包含了View自身及其子View的所有DisplayList。**

其中还有一个`RootRenderNode`，里面包含着`View层次结构中所有View的DisplayList信息`。

### ViewRootImpl硬件绘制相关

> 只有当前View支持`硬件加速`时，才可以进入`硬件绘制`
>
> `if (mAttachInfo.mThreadedRenderer != null && mAttachInfo.mThreadedRenderer.isEnabled())`

![硬件绘制-构建DisplayList](/images/硬件绘制-构建DisplayList.png)

#### ThreadedRenderer.draw()

> `ThreadedRenderer`在UI线程创建，主要执行了两步：
>
> - 构建View的DrawOp树，就是`DisplayList`。`DrawOp 表示 Drawing Operations`
> - 与渲染线程(`RenderThread`)进行通信

```java
  //ThreadedRenderer.java
    void draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks,
            FrameDrawingCallback frameDrawingCallback) {
        attachInfo.mIgnoreDirtyState = true;

        final Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;
        choreographer.mFrameInfo.markDrawStart();
        //构建View的DrawOp树
        updateRootDisplayList(view, callbacks);

        ...
        final long[] frameInfo = choreographer.mFrameInfo.mFrameInfo;
        if (frameDrawingCallback != null) {
            nSetFrameCallback(mNativeProxy, frameDrawingCallback);
        }
        //通知RenderThread线程绘制
        int syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);
        ...
    }
```

#### updateRootDisplayList()

> 构建`DrawOp`树，构建`RootDisplayList`

```java
    private void updateRootDisplayList(View view, DrawCallbacks callbacks) {
       //更新View的displayList
        updateViewTreeDisplayList(view);

        if (mRootNodeNeedsUpdate || !mRootNode.isValid()) {
           //获取DisplayCanvas
            DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);
            try {
                final int saveCount = canvas.save();
                canvas.translate(mInsetLeft, mInsetTop);
                callbacks.onPreDraw(canvas);

                canvas.insertReorderBarrier();
               //displayListCanvas缓存View对应的drawOp节点
                canvas.drawRenderNode(view.updateDisplayListIfDirty());
                canvas.insertInorderBarrier();

                callbacks.onPostDraw(canvas);
                canvas.restoreToCount(saveCount);
                mRootNodeNeedsUpdate = false;
            } finally {
               //RootRenderNode填充所有节点
                mRootNode.end(canvas);
            }
        }
    }

    private void updateViewTreeDisplayList(View view) {
        view.mPrivateFlags |= View.PFLAG_DRAWN;
        view.mRecreateDisplayList = (view.mPrivateFlags & View.PFLAG_INVALIDATED)//invalidate()对应标记
                == View.PFLAG_INVALIDATED;//初始DecorView默认为 true
        view.mPrivateFlags &= ~View.PFLAG_INVALIDATED;
        view.updateDisplayListIfDirty();//更新节点
        view.mRecreateDisplayList = false;
    }
```

#### DecorView.updateDisplayListIfDirty()

> `updateRootDisplayList()`中对应的View就是`DecorView`，是所有View的顶层。

```java
//View.java
@NonNull
    public RenderNode updateDisplayListIfDirty() {
      ...
        if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0
                || !renderNode.isValid()
                || (mRecreateDisplayList)) {
          ...
          final DisplayListCanvas canvas = renderNode.start(width, height);
          try {
                if (layerType == LAYER_TYPE_SOFTWARE) {//是否强制软件绘制
                    buildDrawingCache(true);
                    Bitmap cache = getDrawingCache(true);//获取绘制缓存
                    if (cache != null) {//缓存有效，复用缓存
                        canvas.drawBitmap(cache, 0, 0, mLayerPaint);
                    }
                } else {
                    // Fast path for layouts with no backgrounds
                    //ViewGroup不需要绘制，直接调用dispatchDraw
                    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                        dispatchDraw(canvas);
                        drawAutofilledHighlight(canvas);
                         ...
                    } else {
                      //ViewGroup(需要绘制) / View 直接调用draw
                        draw(canvas);
                    }
                }
            } finally {
               //缓存构建完成，放入渲染节点
                renderNode.end(canvas);
                setDisplayListProperties(renderNode);
            }
          
        }
      
    }
```

`DecorView`执行`updateDisplayListIfDirty()`，调用到`draw(Canvas)`，然后向下递归调用到`child.draw()`

`updateRootDisplayList()`主要执行以下几步：

- 更新`DecorView`操作缓存(DisplayList)——`updateViewTreeDisplayList(decorView)`
- 利用`DisplayCanvas`构建并缓存所有的`DrawOp(View的绘制操作)`——`mRootNode.start()`
- 将`DisplayListCanvas`缓存的`DrawOp`填充到`RenderNode(View)`——`View.updateDisplayListIfDirty()`
- 将`DecorView`的缓存`DrawOp`填充到`RootRenderNode`中——`mRootNode.end()`



![硬件绘制-updateDisplayListIfDirty()](/images/硬件绘制-updateDisplayListIfDirty.png)

### View硬件绘制相关

上一节中，通过`DecorView`递归调用`子View.updateDisplayListIfDirty()`不断填充`DisplayList`到对应View的`RenderNode`

```java
//View.java
public View(Context context) {
  ...
     //初始化渲染节点
     mRenderNode = RenderNode.create(getClass().getName(), new ViewAnimationHostBridge(this));
  ...
}

    boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) {
       final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();

        boolean drawingWithRenderNode = mAttachInfo != null
                && mAttachInfo.mHardwareAccelerated
                && hardwareAcceleratedCanvas;
        ...
        if (drawingWithRenderNode) {
           //继续执行到updateDisplayListIfDirty
            renderNode = updateDisplayListIfDirty();
            if (!renderNode.isValid()) {
                renderNode = null;
                drawingWithRenderNode = false;
            }
        }
    }

    public RenderNode updateDisplayListIfDirty() {
        final RenderNode renderNode = mRenderNode;
        if (!canHaveDisplayList()) {
            // can't populate RenderNode, don't try
            return renderNode;
        }

        if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 //绘制缓存无效
                || !renderNode.isValid() //渲染节点没有DisplayList
                || (mRecreateDisplayList)) { //需要刷新DisplayList
            // Don't need to recreate the display list, just need to tell our
            // children to restore/recreate theirs
            if (renderNode.isValid() //只要draw过一次后，一直返回true
                    && !mRecreateDisplayList) {//调用一些只需要displayList属性修改的方法
                //不需要重建 DisplayList
                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchGetDisplayList();

                return renderNode; // no work needed
            }

            // If we got here, we're recreating it. Mark it as such to ensure that
            // we copy in child display lists into ours in drawChild()
            mRecreateDisplayList = true;

            int width = mRight - mLeft;
            int height = mBottom - mTop;
            int layerType = getLayerType();
           //获取DisplayListCanvas
            final DisplayListCanvas canvas = renderNode.start(width, height);

            try {
                if (layerType == LAYER_TYPE_SOFTWARE) {//软件绘制，绘制缓存存在直接复用
                    buildDrawingCache(true);
                    Bitmap cache = getDrawingCache(true);
                    if (cache != null) {
                        canvas.drawBitmap(cache, 0, 0, mLayerPaint);
                    }
                } else {
                    computeScroll();

                    canvas.translate(-mScrollX, -mScrollY);
                    //添加 缓存有效标记
                    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
                    mPrivateFlags &= ~PFLAG_DIRTY_MASK;

                    //ViewGroup不需要绘制，直接调用dispatchDraw
                    if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                        dispatchDraw(canvas);
                        drawAutofilledHighlight(canvas);
                         ...
                    } else {
                      //ViewGroup(需要绘制) / View 直接调用draw
                        draw(canvas);
                    }
                }
            } finally {
               //RenderNode 收集DisplayList
                renderNode.end(canvas);
                setDisplayListProperties(renderNode);
            }
        } else {
            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        }
        return renderNode;
    }

    //是否会有DisplayList = 是否开启硬件加速
    public boolean canHaveDisplayList() {
        return !(mAttachInfo == null || mAttachInfo.mThreadedRenderer == null);
    }

    //只有flag标记为 PFLAG_INVALIDATED ，调用需要 重建DisplayList
    mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
```

根据上述源码可判断`View需要重新构建DisplayList(执行draw())`有以下条件：

1. `(mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0`当前View绘制缓存无效

   **mPrivateFlags没有`PFLAG_DRAWING_CACHE_VALID`标记**

2. `renderNode.isValid()==false` View对应的`DisplayList`尚未构建或者被销毁

   **只要View绘制过一次，就会一直返回true。除非`detached`**

3. `mRecreateDisplayList==true` View需要重新构建`DisplayList`

   **mPrivateFlags持有`PFLAG_INVALIDATED`标记**

能满足以上条件的就是调用`View.invalidate()`

```java
//View.java
    public void invalidate() {
        invalidate(true);
    }

    public void invalidate(boolean invalidateCache) {
        invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);
    }

    void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,
            boolean fullInvalidate) {
      ...
            if (invalidateCache) {
                mPrivateFlags |= PFLAG_INVALIDATED; //添加PFLAG_INVALIDATED标志
                mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;//移除PFLAG_DRAWING_CACHE_VALID标志
            }
      
    }
```





#### dispatchGetDisplayList()

只会在不重建`DisplayList`情况下调用

```java
//View.java
// 只会在ViewGroup下实现，更新子View的DisplayList
    protected void dispatchGetDisplayList() {}


//ViewGroup.java
    @Override
    protected void dispatchGetDisplayList() {
        final int count = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i < count; i++) {
            final View child = children[i];
           //View可见 || 设置动画
            if (((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null)) {
                recreateChildDisplayList(child);//调用子
            }
        }
        ...
    }

    private void recreateChildDisplayList(View child) {
        child.mRecreateDisplayList = (child.mPrivateFlags & PFLAG_INVALIDATED) != 0;//没有PFLAG_INVALIDATED 返回true
        child.mPrivateFlags &= ~PFLAG_INVALIDATED; //移除 PFLAG_INVALIDATED标志
        child.updateDisplayListIfDirty();
        child.mRecreateDisplayList = false; //执行完后 重置状态
    }
```

### RenderThread渲染UI

构建完`RootRenderNode`的`DisplayList——DrawOp树`之后，就需要准备渲染。*利用GPU将DisplayList绘制到屏幕上*。

![img](/images/CPU GPU通信模型)

根据图示渲染过程主要分为5阶段：

1. UI线程创建OpenGL渲染需要的命令及数据——`构建DrawOp树`
2. CPU将数据共享给GPU，使用`匿名共享内存`
3. 通知GPU渲染
4. swapBuffers，并通知`SurfaceFlinger`开始合成图层
5. SurfaceFlinger开始合成图层



### 硬件绘制流程



![硬件绘制流程](/images/硬件绘制流程.jpg)

如上图所示：

> 硬件绘制的流程，主要包含两个步骤：**录制 、 回放**。
>
> `录制`：需要View的`draw()`参与，需要记录View的绘制步骤，并编译为**绘制指令**(`drawOp`)
>
> `回放`：还原绘制内容，只需要还原**绘制指令**，而且这个绘制指令是可以修改的，修改的过程是不需要重新触发`draw()`。

## 软件绘制VS硬件绘制

| 渲染场景                       | 软件绘制                 | 硬件绘制                                                     | 效果分析                                                 |
| ------------------------------ | ------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| 页面初始化                     | 绘制所有View             | 创建所有`DisplayList`                                        | GPU负责复杂的计算任务                                    |
| 调用背景透明TextView.setText() | 重绘脏区所有View         | TextView及每一级父View重建`DisplayList`                      | 重叠的兄弟节点不需要进行重绘，GPU会自行处理              |
| TextView逐帧播放动画           | 每帧动画都要重绘脏区View | 第一帧需要重建`DisplayList`<br>后续只要更新对应的`DisplayList`即可 | 刷新每帧性能提升                                         |
| 修改TextView透明度             | 重绘脏区所有View         | 直接调用`RenderNode.setAlpha()`即可                          | 只触发`DecorView.updateDisplayListIfDirty`，不再往下遍历 |



## 绘制缓存

![绘制缓存](/images/Android绘制-绘制缓存.png)

> 绘图缓存是指一个`Bitmap(软件绘制)`和`(硬件绘制)`，保存的是控件及其子控件的一个快照。
>
> 可以通过`View.setLayerType()`设置使用何种类型的缓存。
>
> `LAYER_TYPE_NONE`：视图正常渲染，不受屏幕外缓冲区支持。**默认值**
>
> `LAYER_TYPE_SOFTWARE`：标识这个View有一个`Software Layer`，在一定条件下，会变成`bitmap`对象。
>
> `LAYER_TYPE_HARDWARE`：标识这个VIew有一个`Hardware Layer`，通过GPU来实现。依赖`硬件加速`实现，如果未开启`硬件加速`，按照`Software Layer`实现。

### 软件绘制缓存

```java
//View.java
    boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) {
     ...
        Bitmap cache = null;
        int layerType = getLayerType(); // layerType默认为LAYER_TYPE_NONE
        if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {//软件绘制条件
             if (layerType != LAYER_TYPE_NONE) {//必须设置 `LAYER_TYPE_SOFTWARE` 或 LAYER_TYPE_HARDWARE 缓存生效
                 // If not drawing with RenderNode, treat HW layers as SW
                 layerType = LAYER_TYPE_SOFTWARE;//设置 软件layer
                 buildDrawingCache(true);//构建缓存
            }
            cache = getDrawingCache(true);
        }
    }

    public void buildDrawingCache(boolean autoScale) {
       buildDrawingCacheImpl(autoScale);
    }

    private void buildDrawingCacheImpl(boolean autoScale) {
     ...
       quality = Bitmap.Config.ARGB_8888;//默认缓存bitmap图像类型
       bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(),
                        width, height, quality);
       bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);
       if (autoScale) {
          mDrawingCache = bitmap;
       } else {
          mUnscaledDrawingCache = bitmap;
       }
      ...
    }
```

要启用`软件绘制缓存`，必须调用`View.setLayerType()`设置`LAYER_TYPE_HARDDWARE、LAYER_TYPE_SOFTWARE`。通过`buildDrawingCache()`生成`绘制缓存`，对应会生成两个缓存对象：

- `mDrawingCache`：根据兼容模式进行放大或缩小
- `mUnscaledDrawingCache`：反映了控件的真实尺寸，多用作控件截图。

后续通过`getDrawingCache()`获取缓存内容。

```java
//View.java
boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) {
 final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode; //是否使用缓存
 ...
 if(!drawingWithDrawingCache) {//未使用缓存
    if (drawingWithRenderNode) {//硬件绘制
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        ((DisplayListCanvas) canvas).drawRenderNode(renderNode);
    } else {//软件绘制
        // 需要回调到`onDraw()`
        if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            dispatchDraw(canvas);
        } else {
            draw(canvas);
        }
    }
 }else if(cache!=null){
   canvas.drawBitmap(cache...)//将缓存绘制于画布上
 }
}
```



### 硬件绘制缓存

`DisplayList`可以理解为缓存，开启`硬件加速`时，只要每次回放`DisplayList`即可。



### 绘制缓存的开启原则

- 不要为`十分轻量级的控件`启用绘制缓存。可能缓存绘制的开销 > 控件重绘开销
- 为`很少发生内容改变的控件`启用绘制缓存。避免`invalidate()`时产生额外的缓存绘制操作
- 当父控件需要频繁改变子控件的位置或变换时对`子控件`启用绘制缓存，避免频繁重绘子控件。通过`ViewGroup.setChildrenDrawingWithCache()`启用子控件绘制缓存。



## 属性动画更新相关

![Android绘制-属性动画更新相关](/images/Android绘制-属性动画更新相关.png)

在{%post_link Android动画-属性动画%}中讲到最后通过反射调用`View.setXX()`去执行动画。

```java
//view.java
    public void setScaleX(float scaleX) {
        if (scaleX != getScaleX()) {
            scaleX = sanitizeFloatPropertyValue(scaleX, "scaleX");
            invalidateViewProperty(true, false);
            mRenderNode.setScaleX(scaleX);//更新对应View的displayList
            invalidateViewProperty(false, true);

            invalidateParentIfNeededAndWasQuickRejected();
            notifySubtreeAccessibilityStateChangedIfNeeded();
        }
    }
```

关键在于`invalidateViewProperty()`调用界面刷新

```java
    void invalidateViewProperty(boolean invalidateParent, boolean forceRedraw) {
        if (!isHardwareAccelerated()
                || !mRenderNode.isValid()
                || (mPrivateFlags & PFLAG_DRAW_ANIMATION) != 0) {//软件绘制
            if (invalidateParent) {
                invalidateParentCaches();
            }
            if (forceRedraw) {
                mPrivateFlags |= PFLAG_DRAWN; // force another invalidation with the new orientation
            }
            invalidate(false);
        } else {
            damageInParent();//硬件绘制
        }
    }

    protected void damageInParent() {
        if (mParent != null && mAttachInfo != null) {
            mParent.onDescendantInvalidated(this, this);//一层层向上层调用
        }
    }
```

`mParent`一般指向`ViewGroup`

```java
//ViewGroup.java
    public void onDescendantInvalidated(@NonNull View child, @NonNull View target) {
      ...
        if ((target.mPrivateFlags & ~PFLAG_DIRTY_MASK) != 0) {
            // We lazily use PFLAG_DIRTY, since computing opaque isn't worth the potential
            // optimization in provides in a DisplayList world.
            mPrivateFlags = (mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DIRTY;

            // simplified invalidateChildInParent behavior: clear cache validity to be safe...
            //标记缓存无效
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
      ...
        if (mParent != null) {
          //继续向顶层View请求
            mParent.onDescendantInvalidated(this, target);
        }
    }
```

在`onDescendantInvalidated()`主要移除了`PFLAG_DRAWING_CACHE_VALID`标志

最顶层的View是`DecorView`，而`ViewRootImpl`就是`DecorView的parent`

```java
//ViewRootImpl.java
    @Override
    public void onDescendantInvalidated(@NonNull View child, @NonNull View descendant) {
        if ((descendant.mPrivateFlags & PFLAG_DRAW_ANIMATION) != 0) {
            mIsAnimating = true;
        }
        invalidate();
    }

    void invalidate() {
        mDirty.set(0, 0, mWidth, mHeight);
        if (!mWillDrawSoon) {
            scheduleTraversals();//开始执行绘制流程
        }
    }
```

总结：属性动画最后反射调用`View.setXX()`更新View属性时，调用到`invalidateViewProperty()`，主要实现的功能就是`移除PFLAG_DRAWING_CACHE_VALID`标志。在执行绘制过程中，在回到`View.updateDisplayListIfDirty()`时

```java
 public RenderNode updateDisplayListIfDirty() {
   ...
      if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 //满足该条件
                || !renderNode.isValid()
                || (mRecreateDisplayList)) {
            // Don't need to recreate the display list, just need to tell our
            // children to restore/recreate theirs
            if (renderNode.isValid()
                    && !mRecreateDisplayList) {//未设置 PFLAG_INVALIDATED标志
                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchGetDisplayList();//只要刷新DisplayList

                return renderNode; // no work needed
            }
        ...
 }
```

**在开启硬件加速的条件下，属性动画更新过程中不会回调`onDraw()`**



## 关键节点

### `DisplayList`初始化

`DisplayListCanvas.start()` -> `DisplayListCanvas.obtain()`->`nCreateDisplayListCanvas`

```c++
//android_view_DisplayListCanvas.cpp
static jlong android_view_DisplayListCanvas_createDisplayListCanvas(jlong renderNodePtr,
        jint width, jint height) {
    RenderNode* renderNode = reinterpret_cast<RenderNode*>(renderNodePtr);
    return reinterpret_cast<jlong>(Canvas::create_recording_canvas(width, height, renderNode));
}

//Canvas.cpp
Canvas* Canvas::create_recording_canvas(int width, int height, uirenderer::RenderNode* renderNode) {
    if (uirenderer::Properties::isSkiaEnabled()) {
        return new uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);
    }
    return new uirenderer::RecordingCanvas(width, height);
}

//Properrties.cpp
bool Properties::isSkiaEnabled() {
    auto renderType = getRenderPipelineType();//分为三种类型 SkiaGL SkiaVulkan OpenGL(默认)
    return RenderPipelineType::SkiaGL == renderType || RenderPipelineType::SkiaVulkan == renderType;
}
```

```c++
//RecordingCanvas.cpp
RecordingCanvas::RecordingCanvas(size_t width, size_t height)
        : mState(*this), mResourceCache(ResourceCache::getInstance()) {
    resetRecording(width, height);
}

void RecordingCanvas::resetRecording(int width, int height, RenderNode* node) {
    LOG_ALWAYS_FATAL_IF(mDisplayList, "prepareDirty called a second time during a recording!");
    mDisplayList = new DisplayList();//初始化DisplayList

    mState.initializeRecordingSaveStack(width, height);

    mDeferredBarrierType = DeferredBarrierType::InOrder;
}
```



### 插入DrawOp到DisplayList

`DisplayListCanvas`内部也包含了各种`drawXX()`，例如`drawLines()、drawText()`等。在调用这些方法后，会把对应的绘制操作转换为`drawOp`

```c++
//DisplayListCanvas.java
public final class DisplayListCanvas extends RecordingCanvas {
 ...
   //所有绘制方法由RecordCanvas实现
    public void drawCircle(CanvasProperty<Float> cx, CanvasProperty<Float> cy,
            CanvasProperty<Float> radius, CanvasProperty<Paint> paint) {
        nDrawCircle(mNativeCanvasWrapper, cx.getNativeContainer(), cy.getNativeContainer(),
                radius.getNativeContainer(), paint.getNativeContainer());
    }
}

//RecordingCanvas.java
    @Override
    public final void drawLine(float startX, float startY, float stopX, float stopY,
            @NonNull Paint paint) {
        nDrawLine(mNativeCanvasWrapper, startX, startY, stopX, stopY, paint.getNativeInstance());
    }

```

`drawCircle()和drawRoundRect()`由`DisplayListCanvas`实现。其他的绘制方法交由`RecordingCanvas`实现。

```c++
//android_view_DisplayListCanvas.cpp
static void android_view_DisplayListCanvas_drawCircleProps(jlong canvasPtr,
        jlong xPropPtr, jlong yPropPtr, jlong radiusPropPtr, jlong paintPropPtr) {
    Canvas* canvas = reinterpret_cast<Canvas*>(canvasPtr);
    CanvasPropertyPrimitive* xProp = reinterpret_cast<CanvasPropertyPrimitive*>(xPropPtr);
    CanvasPropertyPrimitive* yProp = reinterpret_cast<CanvasPropertyPrimitive*>(yPropPtr);
    CanvasPropertyPrimitive* radiusProp = reinterpret_cast<CanvasPropertyPrimitive*>(radiusPropPtr);
    CanvasPropertyPaint* paintProp = reinterpret_cast<CanvasPropertyPaint*>(paintPropPtr);
    canvas->drawCircle(xProp, yProp, radiusProp, paintProp);
}
```



```c++
//RecordingCanvas.h
    virtual void drawLine(float startX, float startY, float stopX, float stopY,
                          const SkPaint& paint) override {
        float points[4] = {startX, startY, stopX, stopY};
        drawLines(points, 4, paint);
    }

//RecordingCanvas.cpp
void RecordingCanvas::drawLines(const float* points, int floatCount, const SkPaint& paint) {
    if (CC_UNLIKELY(floatCount < 4 || paint.nothingToDraw())) return;
    floatCount &= ~0x3;  // round down to nearest four
 
    addOp(alloc().create_trivial<LinesOp>(
            calcBoundsOfPoints(points, floatCount), *mState.currentSnapshot()->transform,
            getRecordedClip(), refPaint(&paint), refBuffer<float>(points, floatCount), floatCount));
}
```

通过`addOp()`将`DrawLine`的绘制操作缓存到`displayList`。



## 参考链接

{% post_link View的工作原理 View的绘制过程%}

[Android官方文档-硬件加速](https://developer.android.com/guide/topics/graphics/hardware-accel?hl=zh-cn)

[DisplayList构建过程分析](https://blog.csdn.net/Luoshengyang/article/details/45943255)

[Android硬件加速原理与实现简介](https://tech.meituan.com/2017/01/19/hardware-accelerate.html)

[RenderThread与OpenGL GPU渲染](https://www.jianshu.com/p/dd800800145b)

[Android 中的 Hardware Layer 详解](https://www.androidperformance.com/2019/07/27/Android-Hardware-Layer/)

<!-- https://www.jianshu.com/p/abfaea892611 ， https://blog.csdn.net/jinzhuojun/article/details/54234354 https://www.jianshu.com/p/40f660e17a73 -->

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android事件分发</title>
    <url>/2020/10/21/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    <content><![CDATA[
> View的事件分发本质就是**[MotionEvent](#1-MotionEvent)事件的分发过程**。当一个MotionEvent产生后，系统需要把该事件传递给一个具体的View.

### 点击事件传递规则

点击事件的传递顺序为：**Activity(Window) --> ViewGroup --> View**

事件分发过程中有3个重要的方法:

- `dispathTouchEvent(MotionEvent event)`

  用来进行事件的分发。

- `onInterceptTouchEvent(MotionEvent event)`

  用来进行事件的拦截，在`dispatchOnTouchEvent()`内部中调用，返回结果表明是否拦截事件，*View中是没有该方法的*

- `onTouchEvent(MotionEvent event)`

  用来处理点击事件，在`dispatchOnTouchEvent()`内部中调用，返回结果表明是否消耗当前事件

> 在Android系统中，可以处理事件传递的类有以下三种：
>
> - **Activity**：包含`dispatchTouchEvent`，`onTouchEvent`方法
> - **ViewGroup**：包含`dispatchTouchEvent`，`onInterceptTouchEvent`，`onTouchEvent`
> - **View**：包含`dispatchTouchEvent`，`onTouchEvent`方法

可以用如下伪代码体现：

```java
public boolean dispatchTouchEvent(MotionEvent event){
    boolean consume = false;
    if(onInterceptTouchEvent(ev)){
        //被拦截调用自身的onTouchEvent()处理点击事件
        consume = onTouchEvent(event);
    }else{
        //没有拦截继续放行，执行子View的dispatchTouchEvent()
        consume = child.dispatchTouchEvent(event);
    }
    return consume;
}
```

{% fullimage /images/TouchEvent-Transmit.png,事件分发,事件分发%}



- `super`：调用父类方法
- `true`：消费事件，即事件不会往下传递
- `false`：不消费事件，事件继续往下传递(`onInterceptTouchEvent()`)/交由父布局处理事件(`onTouchEvent`，`dispatchTouchEvent`)

简单的总结一下流程：**Activity.dispatchTouchEvent() -> ViewGroup.dispatchTouchEvent() -> ViewGroup.onInterceptTouchEvent() -> View.dispatchTouchEvent() ->  View.onTouch() -> View.onTouchEvent() -> View.onClick()**

### 事件分发的源码解析

#### Activity的事件分发机制

当一个点击事件发生时，事件最先传递到的就是`Activity.dispatchTouchEvent(MotionEvent ev)`中进行事件分发。*具体工作是由Activity的Window来完成的。*

```java
// ..android/app/Activity.java
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        //若dispatchTouchEvent返回true，事件到此结束，返回false，继续向下传递
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }

//当activity在栈顶时，点击，触摸或者点击通知栏都会触发 
    public void onUserInteraction() {
    }

// ../com/android/internal/policy/PhoneWindow.java
/**
* getWindow().superDispatchTouchEvent(ev)
* getWindow()指向的是Window对象的一个实例，在Android中Window的唯一实现就是PhoneWindow
*/
    @Override
    public boolean superDispatchTouchEvent(MotionEvent event) {
        //mDecor 是DecorView的一个实例，DecoeView就是顶层View中的实例对象
        return mDecor.superDispatchTouchEvent(event);
    }

//../com/android/internal/policy/DecorView.java
/**
*  mDecor.superDispatchTouchEvent(event)
*  mDecor 是DecorView的一个实例对象，DecorView是PhoneView的一个内部类，并且继承自FrameLayout
*/
    public boolean superDispatchTouchEvent(MotionEvent event) {
        //调用父类的方法即FrameLayout.dispatchTouchEvent = ViewGroup.dispatchTouchEvent()，由父类去处理事件分发
        return super.dispatchTouchEvent(event);
    }


```

`onUserInteraction()`用户点击屏幕时最先被触发。

{% fullimage /images/Activity-Dispatch.png,Activity事件分发,Activity事件分发%}

总结一下：按照上述流程图，当一个点击事件进来时，Activity上的事件流程如下：

- 调用`Activity.dispatchTouchEvent()`，然后调用`onUserInteraction()`
- 调用`getWindow()即PhoneWindow.superDispatchTouchEvent()`
- 调用`mDecor即DecorView.superDispatchTouchEvent()`
- 调用DecorView父类即**`ViewGroup.dispatchTouchEvent()`** 在这里实现了事件从Activity传递至ViewGroup

#### ViewGroup事件分发机制

上述Activity事件分发，后面会走到`ViewGroup.dispatchTouchEvent()`

```java
@Override
public boolean dispatchTouchEvent(MotionEvent event){
    ...
        
//---- ViewGroup会在ACTION_DOWN时重置GroupFlags以免影响后续对ACTION_DOWN事件的处理----
     if (actionMasked == MotionEvent.ACTION_DOWN) {
                cancelAndClearTouchTargets(ev);
                resetTouchState();
      }
//--------
    
//----判断当前事件是否需要拦截----   
      final boolean intercepted;
      if (actionMasked == MotionEvent.ACTION_DOWN  //必须是ACTION_DOWN事件，若为其他UP或MOVE事件不触发拦截机制
                    || mFirstTouchTarget != null) { //mFirstTouchTarget 若当前事件被拦截，则该值为null 反之不会空
                //FLAG_DISALLOW_INTERCEPT：禁止ViewGroup拦截除了DOWN以外的事件
                //可由View调用requestDisallowInterceptTouchEvent设置标记
                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
       } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
       }
//--------    
    ...
//----ViewGroup不拦截分发事件，事件向下分发交由子View进行处理----        
                           final View[] children = mChildren;
                        //遍历当前ViewGroup下的所有子View 遍历为倒序，意味着从外到内遍历
                        for (int i = childrenCount - 1; i >= 0; i--) {
                            final int childIndex = getAndVerifyPreorderedIndex(
                                    childrenCount, i, customOrder);
                            final View child = getAndVerifyPreorderedView(
                                    preorderedList, children, childIndex);

                            // If there is a view that has accessibility focus we want it
                            // to get the event first and if not handled we will perform a
                            // normal dispatch. We may do a double iteration but this is
                            // safer given the timeframe.
                            if (childWithAccessibilityFocus != null) {
                                if (childWithAccessibilityFocus != child) {
                                    continue;
                                }
                                childWithAccessibilityFocus = null;
                                i = childrenCount - 1;
                            }
//如果View不可见或触摸点的坐标不在子View范围内，跳过本次循环
                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                ev.setTargetAccessibilityFocus(false);
                                continue;
                            }

                            newTouchTarget = getTouchTarget(child);
                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            }

                            resetCancelNextUpFlag(child);
//事件传递下来后，调用dispatchTransformedTouchEvent，事件就会传递到View中                     
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j < childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
//返回true的话                                
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }

                            // The accessibility focus didn't handle the event, so clear
                            // the flag and do a normal dispatch to all children.
                            ev.setTargetAccessibilityFocus(false);
                        }
    
    ...
//如果 mfirstTouchTarget为空，ViewGroup默认拦截同一时间序列中的所有事件        
        if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
            //child默认为空，直接调用父类的 dispatchTouchEvent()
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            } else {
        ...
        }
    ...
    
}

//是否拦截事件分发
public boolean onInterceptTouchEvent(MotionEvent ev) {
        //触发条件需要有 鼠标输入触发 正常操作都是触摸方式 所以可以看做默认false
        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
                && ev.getAction() == MotionEvent.ACTION_DOWN
                && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
                && isOnScrollbarThumb(ev.getX(), ev.getY())) {
            return true;
        }
        return false;
    }

//事件向下分发 子View或者子ViewGroup
private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        final boolean handled;

        // Canceling motions is a special case.  We don't need to perform any transformations
        // or filtering.  The important part is the action, not the contents.
        final int oldAction = event.getAction();
        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
                //如果没有子View，向上回溯调用父类的dispatchTouchEvent
                handled = super.dispatchTouchEvent(event);
            } else {
                //包含子View，调用子类的dispatchTouchEvent
                handled = child.dispatchTouchEvent(event);
            }
            event.setAction(oldAction);
            return handled;
        }
    ...
}

//mFirstTouchTarget其实是一种单链表结构
private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
        target.next = mFirstTouchTarget;
        mFirstTouchTarget = target;
        return target;
}
```

{% fullimage /images/ViewGroup-Dispatch.png,ViewGroup事件分发,ViewGroup事件分发%}

根据上述流程图，总结一下：

- 点击事件从上层传递到ViewGroup，先调用`ViewGroup.dispatchTouchEvent()`
- 判断`ViewGroup.onInterceptTouchEvent()`是否拦截点击事件
  - 默认不拦截，则将事件继续向子View传递，然后调用`View.dispatchTouchEvent()`
  - 被拦截返回`true`，调用`super.dispatchTouchEvent()`返给父布局处理，并且ViewGroup自身也处理事件，比如`onTouch(),onClick(),onTouchEvent()`等事件

> 通常情况下ViewGroup的`onInterceptTouchEvent()`返回false，不会拦截用户操作。
>
> 不过要注意的是 拦截的是 一个用户的操作序列：*从用户手指按下到手指抬起为止。*
>
> - 拦截了Down事件，后续的事件都会交由`ViewGroup.onTouchEvent()`处理
> - 拦截了其他事件，会给之前序列头部的`ACTION_DOWN`事件发送一个`ACTION_CANCEL`类型事件，通知子View无法执行后续事件，回归初始状态。(**例如点击ListView中的一个Item的Button，再滑动ListView，Button就会恢复初始状态。**)

#### View事件分发机制

上述ViewGroup事件分发后，就会调用到`View.dispatchTouchEvent()`

```java
// ../android/view/View.java
public boolean dispatchTouchEvent(MotionEvent event) {
 ...
    boolean result = false;
    
     if (onFilterTouchEventForSecurity(event)) {
            if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {
                result = true;
            }
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null 
                && li.mOnTouchListener != null //View设置了onTouch事件
                && (mViewFlags & ENABLED_MASK) == ENABLED //View是可操作状态的 isEnable=true
                && li.mOnTouchListener.onTouch(this, event)//View的onTouch返回为true
               ){
                result = true;
            }
            //如果result为true即上述条件通过 这个if条件就不会向下执行意味着onTouchEvent()不会被调用
            if (!result && onTouchEvent(event)) {
                result = true;
            }
        }
    ...
        return result;
}


 public boolean onTouchEvent(MotionEvent event) {
     final int action = event.getAction();
     //只要设置了点击事件 clickable = true
     final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE
                || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
     //当View点击事件被禁止时，直接消耗点击事件
     if ((viewFlags & ENABLED_MASK) == DISABLED) {
            if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
                setPressed(false);
            }
            mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
            // A disabled view that is clickable still consumes the touch
            // events, it just doesn't respond to them.
            return clickable;
        }
     ...
      //监听点击事件，并且需要配置Click事件才可以触发
      if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
          switch (action) {
                  //当手指从屏幕离开时，触发对应的点击事件
              case MotionEvent.ACTION_UP:
                  //没有配置点击事件的话 直接返回
                  if (!clickable) {
                        removeTapCallback();
                        removeLongPressCallback();
                        mInContextButtonPress = false;
                        mHasPerformedLongPress = false;
                        mIgnoreNextUpEvent = false;
                        break;
                    }
                  boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                        // take focus if we don't have it already and we should in
                        // touch mode.
                        boolean focusTaken = false;
                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                            focusTaken = requestFocus();
                        }
                        ...
                        if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                            // This is a tap, so remove the longpress check
                            removeLongPressCallback();

                            // Only perform take click actions if we were in the pressed state
                            if (!focusTaken) {
                                // Use a Runnable and post this rather than calling
                                // performClick directly. This lets other visual state
                                // of the view update before click actions start.
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                if (!post(mPerformClick)) {
                                    performClick();
                                }
                            }
                        }
                        ...
                    }
                  break;
          ...
          }
      }
 }

//实际点击事件的触发位置
public boolean performClick() {
        final boolean result;
        final ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnClickListener != null) {
            playSoundEffect(SoundEffectConstants.CLICK);
            //调用对应的点击事件
            li.mOnClickListener.onClick(this);
            result = true;
        } else {
            result = false;
        }
        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
        notifyEnterOrExitForAutoFillIfNeeded(true);
        return result;
    }
```

{% fullimage /images/View-Dispatch.png,View事件分发,View事件分发%}



根据上述流程图，总结一下：

- 点击事件从ViewGroup传递到View，调用`View.dispatchTouchEvent()`
- 判断当前View是否设置`OnTouchListener`，并且设置了`onTouch()`返回值，默认返回false
  - 返回`true`，代表事件被`onTouch()`消费，不会继续往下传递
  - 返回`false`，事件继续向下传递，调用`View.onTouchEvent()`，后续若设置点击事件，则继续调用`performClick()`，最后执行`onClick()`事件

拓展：

> 1. 如果有一个控件是`DISABLED`，注册的`onTouch()`事件不会被执行。若要监听点击事件，只能实现它的`onTouchEvent()`
> 2. 点击事件优先级： `onTouch()` > `onTouchEvent()` > `performClick()` > `onClick()` 



#### 总结

1. 点击事件传递从`dispatchTouchEvent()`开始，在不修改默认返回值时，事件会按照嵌套层次由外向内传递，到达最内层View时，由最内层View`onTouchEvent()`处理
2. 事件在传递过程中，返回参数设为`true`，事件会被提前消费，不向下继续传递
3. View的点击事件触发顺序为  `onTouch()` > `onTouchEvent()` > `performClick()` > `onClick()` 

#### 拓展

1. *Touch事件的后续(例如`ACTION_MOVE`,`ACTION_UP`)层级传递*
   - 若`dispatchTouchEvent()`返回true，那么能收到`ACTION_DOWN`的函数也可以收到后续事件
   - 若`onTouchEvent()`返回true，那么其他事件不再往下传递，而是直接传给自己的`onTouchEvent()`并结束本次事件传递

## ]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>View的事件体系</title>
    <url>/2018/12/25/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[
<!--MeasureSpec是什么？有什么作用？，自定义View/ViewGroup需要注意什么？invalidate()和postInvalidate()的区别？,invalidate和postInvalidate的区别及使用 Requestlayout，onlayout，onDraw，DrawChild区别与联系 View刷新机制 View绘制流程 计算一个view的嵌套层级 onMeasure的具体过程，先measure子view还是自己 onDraw的具体过程，先draw子view还是自己 实现一个自定义view，其中含有若干textview，textview文字可换行且自定义- - view的高度可自适应拓展 view的工作原理及measure、layout、draw流程。哪一个流程可以放在子线程中去执行？draw方法中需要注意的问题？Invalidate、postInvalidate、requestLayout应用场景-->



![View的事件体系](/images/View的事件体系.png)



> 在Android中任何一个与用户交互或者展示内容的控件都是由View拓展实现的。

## View的基础知识

View是Android中所有控件的基类，也包括ViewGroup。ViewGroup可以理解为View的组合，内部可以包含很多View以及ViewGroup，通过这种关系就形成了一个View树。

![ViewTree](/images/View-Tree.png)

上层的控件主要负责测量与绘制下层的控件，并传递交互事件。

### 1. View的位置参数

#### 1.Android坐标系

> 在Android中，将屏幕左上角的顶点作为坐标原点，向右为X轴增大方向，向下为Y轴增大方向

![ViewTree](/images/Android-Position.png)

#### 2.View坐标系

> View的位置由它的四个顶点决定，分别对应View的4个属性：`left(左上角横坐标)、top(左上角纵坐标)、right(右下角横坐标)，bottom(右下角纵坐标)`。
>
> **这些坐标都是相对于View的父容器决定的。**

![](/images/View-Position.png)

```java
Left = getLeft();
Right = getRight();
Top = getTop();
Bottom = getBottom();
width = Right - Left;
height = Bottom - Top;
```

在Android3.0之后添加了几个新参数`x,y,translationX,translationY`。

```java
//X对应左上角横坐标 translationX指代x轴偏移量
x = left + translationX;
//y对应左上角纵坐标 translationY指代y轴偏移量
y = top + translationY;

```

`left是View的初始坐标，不会改变的；x是View偏移后的坐标，偏移后就会发生变化`

Android系统也提供了相应的方法可以直接获取对应参数。但是，不能在初始时就去获取，由于那时View还没有开始绘制，获取的都是0；

如何获取可以参考这个 {% post_link Android-Study-Plan-V %}

### 2.View触控

#### 1.MotionEvent

`MotionEvent`：提供点击事件的事件行为以及事件发生的x,y坐标，典型事件由：

- **ACTION_DOWN**：监听用户手指按下的操作，一次按下标志触摸事件的开始。
- **ACTION_MOVE**：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。
- **ACTION_UP**：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。
- **ACTION_CANCEL**：当用户保持按下操作，并把手指移动到了控件外部局域时且父View处理事件触发。

> 事件列：从手指接触屏幕到离开屏幕，产生的一系列事件。
>
> 任何事件列都是**从ACTION_DOWN开始到ACTION_UP结束，中间会穿插着ACTION_MOVE事件**

![View-Touch-Position](/images/View-Touch-Position.png)

```java
getX 以及 getY 返回当前触摸点距离View左上角的x，y坐标 -- 相对坐标
getRawX 以及 getRawY 返回当前触摸点距离整个屏幕的x,y坐标 -- 绝对坐标
```

#### 2.TouchSlop

`TouchSlop`：系统所能识别的被人误是**滑动的最小距离**。当手指在屏幕上滑动时，如果滑动的距离小于这个值，就不会认为在进行滑动操作。

利用`ViewConfiguration.get(getContext()).getScaledTouchSlop()`获取该常亮

#### 3.VelocityTracker

`VelocityTracker`：速度追踪，用于追踪在手指滑动过程中的速度，包括水平和垂直方向的速度

样例演示:

```java
//创建速度追踪对象
VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(event);
//计算速度
velocityTracker.computeCurrentVelocity(1000);
//获取水平速度
float xVelocity = velocityTracker.getXVelocity();
//获取垂直速度
float yVelocity = velocityTracker.getYVelocity();
//重置并回收内存
velocityTracker.clear();
velocityTracker.recycle();
```

#### 4.GestureDetector

`GestureDetector`：手势检测，用于辅助检测用户的单击、滑动、长按，双击等行为。

样例演示：

```java
GestureDetector mGestureDetector = new GestureDetector(this);//实例化一个GestureDetector对象
mGestureDetector.setIsLongpressEnabled(false);// 解决长按屏幕后无法拖动的现象

//接管目标View的onTouchEvent事件
public boolean onTouchEvent(MotionEvent event){
    ...
    boolean consume = mGestureDetector.onTouchEvent(event);
    return consume
}

```



## View的滑动

> Android由于手机屏幕比较小，为了呈现更多的内容就需要滑动来展示。

### 1.使用scrollTo()/scrollBy()

> `scrollTo()`以及`scrollBy()`是由View本身提供的滑动方法。**只对View的内容进行滑动，而不能使View本身滑动。**

```java
    public void scrollTo(int x, int y) {
        if (mScrollX != x || mScrollY != y) {
            int oldX = mScrollX;
            int oldY = mScrollY;
            mScrollX = x;
            mScrollY = y;
            invalidateParentCaches();
            onScrollChanged(mScrollX, mScrollY, oldX, oldY);
            if (!awakenScrollBars()) {
                postInvalidateOnAnimation();
            }
        }
    }

    public void scrollBy(int x, int y) {
        scrollTo(mScrollX + x, mScrollY + y);
    }
```

`scrollTo(x,y)`表示移动到一个具体的坐标点 绝对滑动

`scrollBy(x,y)`表示移动的增量为x,y，即在原有位置上移动x,y的距离 相对滑动

`mScrollX和mScrollY分别表示View在X,Y方向的滚动距离。`

`mScrollX`：View的左边缘减去View的内容的左边缘  **从右向左为正，反之为负**

`mScrollY`：View的上边缘减去View的内容的上边缘  **从下向上为正，反之为负** 

### 2.使用动画

> 通过动画给View增加平移效果。通过改变View自身的`translationX`和`translationY`属性达到滑动效果。

普通动画：新建`translate.xml`动画文件，定义好tranlate属性即可实现滑动动画。

普通动画并不能修改View的位置参数，只是执行了一个动画，实际位置还是初始地方。

属性动画：`ObjectAnimator.ofFloat(view,"translationX",0,300).setDuration(1000).start();`即可实现动画

属性动画真正对View的位置参数进行修改，所以对应时间都是跟随的。

### 3.改变布局参数

> 改变View的`LayoutParams`使得View重新布局。

滑动时，可以对`LaqyoutParams`的`margin`相关参数进行加减就可以实现滑动。

### 4.*弹性滑动

> 上述提到的方案除了动画，滑动都是很生硬的，就是闪烁过去的。所以需要实现弹性滑动(渐进式滑动)。

#### 1. *`Scroller`

使用实例：

```java
Scroller scroller = new Scroller(mContext); //实例化一个Scroller对象

private void smoothScrollTo(int dstX, int dstY) {
  int scrollX = getScrollX();//View的左边缘到其内容左边缘的距离
  int scrollY = getScrollY();//View的上边缘到其内容上边缘的距离
  int deltaX = dstX - scrollX;//x方向滑动的位移量
  int deltaY = dstY - scrollY;//y方向滑动的位移量
  scroller.startScroll(scrollX, scrollY, deltaX, deltaY, 1000); //开始滑动
  invalidate(); //刷新界面
}

@Override//计算一段时间间隔内偏移的距离，并返回是否滚动结束的标记
public void computeScroll() {
  if (scroller.computeScrollOffset()) { 
    scrollTo(scroller.getCurrX(), scroller.getCurY());
    postInvalidate();//通过不断的重绘不断的调用computeScroll方法
  }
}

```

工作原理：

构造`Scroller`对象时，内部没有做什么，只是保存了我们传递的参数

```java
public Scroller(Context context) {
        this(context, null);
    }
public Scroller(Context context, Interpolator interpolator) {
        this(context, interpolator,
                context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.HONEYCOMB);
    }
public Scroller(Context context, Interpolator interpolator, boolean flywheel) {
        mFinished = true;
        if (interpolator == null) {
            mInterpolator = new ViscousFluidInterpolator();
        } else {
            mInterpolator = interpolator;
        }
        mPpi = context.getResources().getDisplayMetrics().density * 160.0f;
        mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction());
        mFlywheel = flywheel;

        mPhysicalCoeff = computeDeceleration(0.84f); // look and feel tuning
    }
```

保存完参数后，就需要调用`Scroller`的`startScroll()`方法，传入对应参数进行滑动

```java
public void startScroll(int startX, int startY, int dx, int dy, int duration) {
        mMode = SCROLL_MODE;
        mFinished = false;
        //滑动持续时间
        mDuration = duration;
        //滑动开始时间
        mStartTime = AnimationUtils.currentAnimationTimeMillis();
        //滑动起点
        mStartX = startX;
        mStartY = startY;
        //滑动终点
        mFinalX = startX + dx;
        mFinalY = startY + dy;
        //滑动距离
        mDeltaX = dx;
        mDeltaY = dy;
        mDurationReciprocal = 1.0f / (float) mDuration;
    }
```

调用`startScroll()`后，我们调用了`invalidate()`导致View进行了重绘，重绘过程中调用了`draw()`方法，`draw()`中调用了对应的`computeScroll()`方法。`computeScroll()`中又调用了`Scroller`的`computeScrollOffset()`方法，使`Scroller`对应的`mCurrX以及mCurrY`发生变化，配合View自身的`scrollTo()`产生滑动事件。后续继续调用了`postInvalidate()`使View重绘，按照上述流程继续执行，直到动画完成为止。

**关键方法为`startScroll()`及`computeScroll()`**



![Scroller-Process.png](/images/Scroller-Process.png)

总结一下原理：**Scroller并不能使View进行滑动，他需要配合View的computeScroll()方法才能完成滑动效果。在computeScroll()中不断让View进行重绘，每次重绘需要计算滑动持续的时间，根据这个时间计算出应该滑动到的位置，然后调用了View本身的scrollTo()配合位置进行滑动，多次的短距离滑动形成了弹性滑动的效果。**

#### 2. 动画

[动画](#2-使用动画)

#### 3. 延时策略

> 通过发生一系列延时消息而达到一种渐进式的效果，具体可以使用`Handler,View.postDelayed()或者Thread.sleep()`实现

*如果要求精确的话，不建议使用延时策略实现。*

## View的事件分发机制

{%post_link Android事件分发%}



## View的滑动冲突

### 滑动冲突场景

#### 外部滑动和内部滑动方向不一致

*外层ViewGroup是可以横向滑动的，内层View是可以竖向滑动的。*例如：ViewPager嵌套ListView

#### 外部滑动和内部滑动方向一致

*外层ViewGroup是可以竖向滑动的，内层View是也可以竖向滑动的。*例如：ScrollView嵌套ListView

#### 两种情况的嵌套

### 滑动冲突处理规则

#### 内外滑动方向不一致 处理规则

**根据滑动是水平滑动还是竖直滑动来判断由谁来拦截事件。**可以得到滑动过程中两个点的坐标，依据滑动路径与水平方向形成的夹角(`斜率`)判断，或者水平和竖直方向滑动的距离差进行判断。*在ViewPager中当斜率小于0.5时判断为水平滑动。*

#### 内外滑动方向一致 处理规则

一般从业务上找突破点。根据业务需求，规定何时让外部View拦截事件何时由内部View拦截事件。

#### 嵌套滑动 处理规则

滑动规则更复杂，所以还是要从业务代码上下手。

### 滑动冲突解决方案

#### 外部拦截法

> 点击事件都先经过**父容器的拦截处理**，如果父容器需要此事件就拦截，不需要就放行

需要重写父容器的`onInterceptTouchEvent()`，在方法内部做相应的拦截。

```java
public boolean onInterceptTouchEvent(MotionEvent ev){
    boolean intercepted = false;
    int x = (int)ev.getX();
    int y = (int)ev.getY();
    
    switch(ev.getAction()){
        //ACTION_DOWN必须返回false，否则后续事件无法向下传递
        case MotionEvent.ACTION_DOWN:
        intercepted = false;
          break;
        case MotionEvent.ACTION_MOVE:
        if(父容器需要处理该事件){
            intercepted = true;
        }else{
            intercepted = false;
        }
          break;
        //ACTION_UP事件必须返回false，否则子容器无法相应 onClick事件
        case MotionEvent.ACTION_UP:
        intercepted = false;
          break;
        default:
          break;
    }
        return intercepted;
}
```

是否拦截需要在`ACTION_MOVE`中进行判断，父容器需要拦截事件返回true，反之返回false。

#### 内部拦截法

> 父容器不拦截任何事件，所有事件交由子容器进行处理，如果子容器需要就消耗事件，不需要就返给父容器处理。

需要同时重写父容器的`onInterceptTouchEvent()`以及子容器的`dispatchTouchEvent()`。需要配合**`requestDisallowInterceptTouchEvent`**

```java
//子View
public boolean dispatchTouchEvent(MotionEvent ev){
    int x= (int)ev.getX();
    int y= (int)ev.getY();
    
switch(ev.getAction()){
        //ACTION_DOWN必须返回false，否则后续事件无法向下传递
        case MotionEvent.ACTION_DOWN:
            //使父布局跳过所有拦截事件
        	parent.requestDisallowInterceptTouchEvent(true);
         	break;
        case MotionEvent.ACTION_MOVE:
          	int deltaX = x - mLastX;
            int deltaY = y- mLastY ;
    		if(父容器需要处理事件){
        		parent.requestDisallowInterceptTouchEvent(false);
            }
          	break;
        //ACTION_UP事件必须返回false，否则子容器无法相应 onClick事件
        case MotionEvent.ACTION_UP:
        	intercepted = false;
           	break;
        default:
         	break;
    }
    mLastX = x;
    mLastY = y;
    return super.dispatchTouchEvent(ev);
}

//父容器
public boolean onInterceptTouchEvent(MotionEvent event){
    int action = event.getAction();
    if(action == MotionEvent.ACTION_DOWN){
        return false;
    }else{
        return true;
    }
}


```

两种方法相比较而言，`外部拦截法`相比`内部拦截法`实现起来更加简单，而且符合View的事件分发，推荐使用`外部拦截法`。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp-HTTPDNS实践</title>
    <url>/2020/02/19/OKHTTP-HTTPDNS%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>设计方案</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler机制源码解析</title>
    <url>/2018/05/14/Handler%E6%9C%BA%E5%88%B6%E5%8D%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[
> 主要的内容包括Handler的机制以及四个组成部分和源码的分析
>
> 下面的代码分析都是基于Android8.0 - Oreo的源代码

![Android消息机制](/images/Android消息机制.png)

<!-- more -->

## 1.  消息机制简介

在应用启动时，会执行`main()`方法，`main()`会创建一个Looper对象，然后开启一个死循环，目的是**不断从消息队列`MessageQueue`里面取出`Message`对象并处理。**

在Android中使用消息机制，会优先想到的是Handler。Handler可以轻松的将一个任务切换到Handler所在的线程去执行。在多线程的应用场景中，**可以将工作线程中需要更新UI的操作信息传递到主线程去执行**，从而实现工作线程更新UI的操作，最终实现异步消息的处理。

{% fullimage /images/study_plan/handler_process.png, Handler执行流程图,Handler执行流程图 %} 

## 2. Handler机制模型

消息机制主要包含**Handler、Message、MessageQueue，Looper**这四个类。

### Handler：消息辅助类

主要功能将`Message`对象发送到`MessageQueue`中，同时将自己的引用赋值给`Message#target`(Handler.sendMessage())。也可以实现`handleMessage()`方法处理回调。

### Message：消息实体

需要传递的消息也可以传递数据。

`Message`分为三种：

- 同步消息(`默认消息`)
- 异步消息(`setAsynchronous(true)`)
- 同步屏障消息

### MessageQueue：消息队列

**内部实现并不是队列，而是利用单链表去实现因为在插入和删除数据有优势。**用于存储Handler发给来的消息(`Message`)以及取出。`内部使用单链表实现`

### Looper：消息循环

与线程绑定，不止局限于主线程，绑定的线程来处理`Message`。不断循环执行`Looper.loop()`，从`MessageQueue`中读取`Message`，按分发机制将消息分发出去给目标处理(将`Message`发到`Handler.dispatchMessage`方法去处理)。

## 3. Handler运行流程

{% fullimage /images/study_plan/handler_run_process.png, Handler运行流程图,Handler运行流程图 %} 

![Handler运行流程](/images/study_plan/handler_run_process.png)

工作流程：**异步通信准备==>消息入队==>消息循环==>消息处理**

1. **异步通信准备**

   > 假定在主线程创建Handler，则会直接在主线程中创建`Looper`,`MessageQueue`和`Handler`对象。**Looper和MessageQueue对象均属于其`创建线程`（由主线程创建则属于主线程）。**创建`Looper`时会自动创建`MessageQueue`对象，创建好`MessageQueue`对象后，`Looper`自动进入循环。`Handler`自动绑定`Looper`以及`MessageQueue`。
   >
   > `Looper`对象的创建方法一般通过`Looper.prepareMainLooper()`和`Looper.prepare()`方法。

2. **消息入队**

   > 工作线程通过`Handler`发送`Message`到`MessageQueue`中。消息内容一般是UI操作，通过`Handler.sendMessage(Message message)`或`Handler.post(Runable r)`发送。加入`MessageQueue`一般通过`MessageQueue.enqueueMessage(Message msg,long when)`操作。

3. **消息循环**

   > 分为**消息出队**和**消息分发**两个步骤
   >
   > - 消息出队：`Looper`从`MessageQueue`中循环取出`Message`
   > - 消息分发：`Looper`将取出的`Message`分发给创建消息的`Handler`
   >
   > **消息循环过程中，`MessageQueue`为空，则线程堵塞**

4. **消息处理**

   > `Handler`接受发过来的`Message`并处理。

## 4. Handler使用过程的注意点

1. 在工作线程中创建自己的消息队列时必须要调用`Looper.prepare()`,并且**在一个线程中只可以调用一次**，然后需要调用`Looper.loop()`,开启消息循环。

   > 在开发过程中基本不会调用上述方法，因为默认会调用主线程的Looper，然后一个线程中只能有一个Looper对象和一个MessageQueue。

2. **要注意Handler可能引起的内存泄漏**(在下面会介绍到为何会引发泄漏)。

   错误的写法:

   ```java
   private final Handler mHandler = new Handler(){        
       @Override
       public void handleMessage(Message msg) {            
           super.handleMessage(msg);
          }
       };
   
   ```

   **非静态的内部类和匿名内部类都会隐式的持有其外部类的引用，而静态内部类不会持有外部类的引用。**

   正确的写法：

   > 继承`Handler`时候要么放在单独的类文件中，要么直接使用静态内部类。

   ```java
   //需要在静态内部类中调用外部类时，可以直接使用  `弱引用`  进行处理
   private static final class MyHandler extends Handler{
       private final WeakReference<MyActivity> mWeakReference；
       public MyHandler(MyActivity activity){
            mWeakReference = new WeakReference<>(activity);
       }
       @Override
       public void handlerMessage(Message msg){
           super.handlerMessage(msg);
           MyActivity activity = mWeakReference.get();
       }
   }
   //调用方法
   private MyHandler mHandler = new MyHandler(this);
   ```


## 5. Handler源码解析

### 1.**创建循环器对象（`Looper`）和创建消息队列对象(`MessageQueue`)**

> 创建Looper对象主要有两个方法：`Looper.prepareMainLooper()`和`Looper.prepare()`
>
> 创建MessageQueue对象方法：**创建Looper对象时会自动创建MessageQueue**

```java
// 源码位置:../core/java/android/os/Looper.java

final MessageQueue mQueue;
final Thread mThread;
//Looper对象创建时会自动创建一个MessageQueue对象。
private Looper(boolean quitAllowed) {
     mQueue = new MessageQueue(quitAllowed);
     mThread = Thread.currentThread();
    }

//为当前线程(子线程)创建一个Looper对象 需要在子线程中主动调用该方法
public static void prepare() {
        prepare(true);
    }

private static void prepare(boolean quitAllowed) {
    //判断sThreadLocal是否为null，不为空则直接跑出异常 可以保证一个线程只可以调用一次prepare方法
    if (sThreadLocal.get() != null) {
          throw new RuntimeException("Only one Looper may be created per thread");
       }
    sThreadLocal.set(new Looper(quitAllowed));
    }

//为主线程创建一个Looper对象 该方法会在主线程创建时自动调用
public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException("The main Looper has already been prepared.");
            }
            sMainLooper = myLooper();
        }
    }
```

总结：

1. 创建`Looper`对象时会自动创建`MessageQueue`对象

2. 主线程的Looper对象是自动生成的，而子线程需要调用`Looper.prepare()`创建`Looper`对象

   > 创建主线程是调用了`ActivityThread`的`main()`方法。
   >
   > 然后按照流程调用了`Looper.prepareMainLooper()`和`Looper.loop()`。所以主线程不需要调用代码生成Looper对象。
    ```java
    //源码位置: ../core/java/android/app/ActivityThread.java
     public static void main(String[] args) {
         ...
          Looper.prepareMainLooper();
          Looper.loop();
         ...
     }
    ```

3. Handler的主要作用是(`在主线程更新UI`)，所以**Handler主要是在主线程创建的**。

4. Looper与Thread是通过`ThreadLocal`关联的。由于`ThreadLocal`是与线程直接关联的，参考`prepare()`。

5. 子线程创建Handler对象:无法在子线程直接调用Handler无参构造方法**Handler创建时需要绑定Looper对象**  。需要使用`HandlerThread`。

### 2.**开启Looper即消息循环**

> 创建了`Looper和MessageQueue`对象后，自动进入消息循环，使用`Looper.loop()`方法开始消息循环。

```java
//源码位置：../core/java/android/os/Looper.java
public static void loop(){
    //现获取Looper实例，保证调用loop时已有Looper，否则抛出异常
    final Looper me = myLooper();
    if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
       }
    //获取对应Looper实例创建的MessageQueue对象
    final MessageQueue queue = me.mQueue;
    ...
     //开启消息循环-无限循环   
     for (;;) {
            //从MessageQueue取出Message对象
            Message msg = queue.next(); // might block
            //取出消息为null，则退出循环
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }
         //把Message分发给相应的target
         try {
                msg.target.dispatchMessage(msg);
                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
            } finally {
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }
         //释放消息占据的资源
          msg.recycleUnchecked();
     }
}

```

`loop()`方法是一个死循环，唯一跳出循环的方法是从`MessageQueue`获取的消息对象为空。

### **3.创建Handler对象**

>创建Handler对象即可以进行消息的发送与处理

```java
//源码位置：.../core/java/android/os/Handler.java 
//Handler默认构造方法
public Handler() {
        this(null, false);
 }

public Handler(Callback callback, boolean async) {
        if (FIND_POTENTIAL_LEAKS) {
            final Class<? extends Handler> klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
                    (klass.getModifiers() & Modifier.STATIC) == 0) {
                Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
                    klass.getCanonicalName());
            }
        }
        //从当前线程的ThreadLocal获取Looper对象
        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }
        //获取当前Looper的消息队列
        mQueue = mLooper.mQueue;
        mCallback = callback;
        //设置消息是否为异步处理方式
        mAsynchronous = async;
    }

public Handler(Looper looper, Callback callback, boolean async) {
        mLooper = looper;
        mQueue = looper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }

```

`Handler的无参构造方法会默认关联当前线程的Looper对象和MessageQueue对象，设置callback回调方法为null，且消息处理方式为同步处理。`

### **4.创建消息对象**

>Handler发送Message并且进入MessageQueue循环，创建方式分为两种`new Message()`和`Message.obtain()`。通常使用`Message.obtain()`。这种方式**有效避免创建重复Message对象**。

```java
//创建消息对象
Message msg = Message.obtain();
msg.what = 1;
msg.obj = "test";

//源码位置 .../core/java/android/os/Message.java
    /** Constructor (but the preferred way to get a Message is to call {@link #obtain() Message.obtain()}).
    */
//new Message 方法
public Message() {
    }

private static final Object sPoolSync = new Object();
//维护一个Message池，用于复用Message对象
private static Message sPool;
//obtain方法 直接从池内获取Message对象，避免new占用内存
public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                //直接从池中取出
                return m;
            }
        }
        //无可复用对象，则重新new获取
        return new Message();
    }
```

### **5.发送消息(Message)**

> Handler主要有以下几种发送消息的方式:
>
> - `sendMessage(Message msg)`
> - `sendMessageDelayed(int what, long delayMillis)`
> - `post(Runnable r)`
> - `postDelayed(Runnable r, long delayMillis)`
> - `sendMessageAtTime(Message msg, long uptimeMillis) `
>
> 最终都是会调用到`sendMessageAtTime(Message msg, long uptimeMillis)`然后继续调用到`enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)`放入MessageQueue

```java
//源码位置：.../core/java/android/os/Handler.java 
//post方法
public final boolean post(Runnable r)
    {
       return  sendMessageDelayed(getPostMessage(r), 0);
    }
public final boolean postAtTime(Runnable r, long uptimeMillis)
    {
        return sendMessageAtTime(getPostMessage(r), uptimeMillis);
    }
public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)
    {
        return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);
    }
public final boolean postDelayed(Runnable r, long delayMillis)
    {
        return sendMessageDelayed(getPostMessage(r), delayMillis);
    }
//利用post()方式发送消息，需要转换为Message向下传递
private static Message getPostMessage(Runnable r, Object token) {
        Message m = Message.obtain();
        m.obj = token;
        //将runnable赋值到callback上 以便后续判断是post还是sendMessage方式发送的消息
        m.callback = r;
        return m;
    }

//sendMessage方法
public final boolean sendMessage(Message msg)
    {
        return sendMessageDelayed(msg, 0);
    }

public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis < 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }

//所有的发送消息有关方法 都会调用到这个方法
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        //获取MessageQueue对象 
        MessageQueue queue = mQueue;
        //获取对象为空 抛出异常
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + " sendMessageAtTime() called with no mQueue");
            Log.w("Looper", e.getMessage(), e);
            return false;
        }
        //对象不为空 调用enqueueMessage方法
        return enqueueMessage(queue, msg, uptimeMillis);
    }

//该方法为了 向MessageQueue插入Message
private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        // 把当前的Handler设置为 消息标记位 即把消息派发给相对应的Handler实例
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        //调用MessageQueue的enqueueMessage方法
        return queue.enqueueMessage(msg, uptimeMillis);
    }
```

总结：

- 发送消息时`Message.when`表示期望该消息被分发的时间即`SystemClock.uptimeMillis() + delayMillis`。`SystemClock.uptimeMills`代表自系统开机到调用到该方法的时间差。
- `Message.when`利用时间差来表达期望事件分发的时间，所以使用的是一个相对时间。
- 使用`sendMessageDelayed()`发送消息时，该消息会立即进入`MessageQueue`中，并标记`mBlocked`为true，阻塞线程。`MessageQueue`中是按照希望被分发时间排序的，时间越小排在越前。

### **6.消息入队**

发送消息最后调用到的是`MessageQueue.enqueueMessage()`将发送的消息加入到`MessageQueue`中

```java
//源码位置：..core/java/android/os/MessageQueue.java
//内部是一个单链表有序序列，由 Message.when 作为排序依据，该值为一个相对时间。
boolean enqueueMessage(Message msg, long when) {
    ...
    synchronized (this) {
            //正在退出 回收Message
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + " sending message to a Handler on a dead thread");
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            // p == null判断当前队列中是否有消息，插入消息作为队列头 
            // when == 0||when < p.when 队列当前处于等待状态 唤醒队列
            if (p == null || when == 0 || when < p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // Inserted within the middle of the queue.  Usually we don't have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                //当前队列有消息，按照消息创建时间插入到队列中
                needWake = mBlocked && p.target == null && msg.isAsynchronous();
                Message prev;
                //从对列头部开始遍历
                for (;;) {
                    prev = p;
                    p = p.next;
                    //循环到队列尾部或者出现一个when小于当前Message的when
                    if (p == null || when < p.when) {
                        break;
                    }
                    //如果是异步消息 且 存在同步屏障
                    if (needWake && p.isAsynchronous()) {
                        needWake = false;//不需要唤醒 队列
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
  }
```

总结：

- 新消息进入时，优先判定当前队列中是否有消息
  - 没有消息，则新进入消息放入队列头部
  - 有消息，则对新消息以及原消息对列的头消息进行执行时间比较，若小于则置于队列头部
- 消息进入消息队列后，会唤醒消息队列进行等待

### **7.获取消息**

> 发送了消息后，MessageQueue维护了消息队列，在Looper中通过`loop()`不断获取Message。通过`next()`获取Message.

```java
//源码位置：..core/java/android/os/MessageQueue.java
Message next(){
    //该参数用于确定消息队列中是否有消息 下一个消息到来前需要等待的时长
    int nextPollTimeoutMillis = 0;
     for (;;) {
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }
            //该方法位于native层 若nextPollTimeoutMillis为-1 代表消息队列处于等待状态 阻塞操作
            nativePollOnce(ptr, nextPollTimeoutMillis);
            ...
            synchronized (this) {
                ...
                 Message msg = mMessages;
                 if (msg != null) {
                    if (now < msg.when) {
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // Got a message.
                        mBlocked = false;
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        msg.next = null;
                        //标记消息使用状态 flag |= FLAG_IN_USE
                        msg.markInUse();
                        //返回一条消息
                        return msg;
                    }
                } else {
                    // No more messages.
                    nextPollTimeoutMillis = -1;
                }
                //消息正在退出
                if (mQuitting) {
                    dispose();
                    return null;
                }
            }
     }
}
```

### **8.分发消息**

> 分发消息到对应的Handler实例并根据传入的Message做对应的操作

```java
//源码位置：.../core/java/android/os/Handler.java 

public void dispatchMessage(Message msg) {
        //若callback不为空，则代表使用了post(Runnable r)方式发送了消息，执行handleCallback方法
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            //代表使用了sendMessage()方式发送了消息，调用handleMessage方法
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }

//创建Handler实例时复写 自定义消息处理方法
public void handleMessage(Message msg) {
    }

//直接回调runnable对象的run()
private static void handleCallback(Message message) {
        message.callback.run();
    }
```

总结：

- `msg.target.dispatchMessage(msg)`中`msg.target`指向的就是对应Handler实例，
- 消息分发的优先级：
  1. Message的回调方法`message.callback.run()`
  2. Handler中Callback的回调方法`mCallback,handleMessage(msg)`
  3. Handler的默认方法`handleMessage()`

### **9.Message回收**

> 上面讲到了新建Message推荐使用`obtain()`，因为可以有效的复用消息，其中里面复用的就是`sPool`变量，它是在Message回收的时候进行赋值的。

```java
//源码位置 .../core/java/android/os/Message.java
/*package*/ boolean isInUse() {
        return ((flags & FLAG_IN_USE) == FLAG_IN_USE);
    }

public void recycle() {
        //正在使用 无法回收
        if (isInUse()) {
            if (gCheckRecycle) {
                throw new IllegalStateException("This message cannot be recycled because it "
                        + "is still in use.");
            }
            return;
        }
        recycleUnchecked();
    }

void recycleUnchecked() {
        // Mark the message as in use while it remains in the recycled object pool.
        // Clear out all other details.
        //置为使用标记
        flags = FLAG_IN_USE;
        what = 0;
        arg1 = 0;
        arg2 = 0;
        obj = null;
        replyTo = null;
        sendingUid = -1;
        when = 0;
        target = null;
        callback = null;
        data = null;

        //将Message放在了列表里，缓存的对象由obtain()拿出来复用
        synchronized (sPoolSync) {
            if (sPoolSize < MAX_POOL_SIZE) {
                next = sPool;
                sPool = this;
                sPoolSize++;
            }
        }
    }
```

### **10.Looper退出**

> `Looper.loop()`内部由一个无限循环组成，默认情况下不会退出循环。需要退出就需要调用`quit()`或者`quitSafely()`。

```java
//源码位置 .../core/java/android/os/Looper.java
    public void quit() {
        mQueue.quit(false);
    }

    public void quitSafely() {
        mQueue.quit(true);
    }

//源码位置 .../core/java/android/os/MessageQueue.java
void quit(boolean safe) {
        if (!mQuitAllowed) {
            throw new IllegalStateException("Main thread not allowed to quit.");
        }

        synchronized (this) {
            if (mQuitting) {
                return;
            }
            mQuitting = true;

            if (safe) {
                removeAllFutureMessagesLocked();
            } else {
                removeAllMessagesLocked();
            }

            // We can assume mPtr != 0 because mQuitting was previously false.
            //唤醒等待线程
            nativeWake(mPtr);
        }
    }

//直接移除MessageQueue中的所有消息
 private void removeAllMessagesLocked() {
        Message p = mMessages;
        while (p != null) {
            Message n = p.next;
            //回收未被处理的消息
            p.recycleUnchecked();
            p = n;
        }
        //由于消息为null 则return 出无限循环
        mMessages = null;
    }

//直接移除未处理的消息 已经在执行的继续处理
private void removeAllFutureMessagesLocked() {
        final long now = SystemClock.uptimeMillis();
        Message p = mMessages;
        if (p != null) {
            //还未处理的Message
            if (p.when > now) {
                removeAllMessagesLocked();
            } else {
                Message n;
                for (;;) {
                    n = p.next;
                    if (n == null) {
                        return;
                    }
                    if (n.when > now) {
                        break;
                    }
                    p = n;
                }
                //不接收后续消息
                p.next = null;
                do {
                    p = n;
                    n = p.next;
                    p.recycleUnchecked();
                } while (n != null);
            }
        }
    }
```



## 6. Handler异步消息与同步屏障

### 异步消息

`Handler`构造函数

```java
 public Handler() {
        this(null, false);
    }   
 
 public Handler(Callback callback, boolean async/*是否异步*/) {
        if (FIND_POTENTIAL_LEAKS) {
            final Class<? extends Handler> klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
                    (klass.getModifiers() & Modifier.STATIC) == 0) {
                Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread " + Thread.currentThread()
                        + " that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;//设置异步标志
    }
```

`mAsynchronus`异步标志默认为`false`，在以下代码中使用

```java
    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);//设置异步消息
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }

```

设置消息为`异步消息`有两种方式：

- `new Handler(true)`：所有发出去的消息都会`setAsynchronous(true)`**对应方法都为@hide，不推荐使用**
- `msg.setAsynchonous(true)`：手动设置消息为异步

#### 使用场景

- View的刷新(`Chorgographer`发送的都是异步消息)



### 同步屏障

> `同步屏障`：挡住普通消息，使得`异步消息`可以被更快处理

#### 添加同步屏障

```java
//MessageQueue.java
    public int postSyncBarrier() {
        return postSyncBarrier(SystemClock.uptimeMillis());
    }

    private int postSyncBarrier(long when) {
        // Enqueue a new sync barrier token.
        // We don't need to wake the queue because the purpose of a barrier is to stall it.
        synchronized (this) {
            final int token = mNextBarrierToken++;
            //没有赋值target，后面需要通过判断target == null，判断是否为同步屏障消息
            final Message msg = Message.obtain();
            msg.markInUse();
            msg.when = when;
            msg.arg1 = token;

            Message prev = null;
            Message p = mMessages;
            if (when != 0) {
                while (p != null && p.when <= when) {
                    prev = p;
                    p = p.next;
                }
            }
            //插入同步屏障
            if (prev != null) { // invariant: p == prev.next
                msg.next = p;
                prev.next = msg;
            } else {
                msg.next = p;
                mMessages = msg;
            }
            return token;//用来取消同步屏障
        }
    }
```

`同步屏障`也是消息的一种，特殊之处在于`target==null`。`target`表示了`消息需要分发的对象`，而`同步屏障`不需要被分发。而且不会唤醒`消息队列`。



上面有说到[获取消息](#7-获取消息)通过`MessageQueue.next()`

```java
//MessageQueue.java
Message next() {
        // Return here if the message loop has already quit and been disposed.
        // This can happen if the application tries to restart a looper after quit
        // which is not supported.
        final long ptr = mPtr;
        if (ptr == 0) {
            return null;
        }

        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;
        for (;;) {
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }
            //唤醒队列
            nativePollOnce(ptr, nextPollTimeoutMillis);

            synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
                if (msg != null && msg.target == null) {
                    //同步屏障，找到下一个 异步消息
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null && !msg.isAsynchronous());
                }
                if (msg != null) {
                    if (now < msg.when) {
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // Got a message.
                        mBlocked = false;
                        if (prevMsg != null) {
                          //取出异步消息
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        msg.next = null;
                        if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                        msg.markInUse();
                        return msg;
                    }
                } else {
                    // No more messages.
                    nextPollTimeoutMillis = -1;
                }

                // Process the quit message now that all pending messages have been handled.
                if (mQuitting) {
                    dispose();
                    return null;
                }
               ...
            }
           ...
        }
    }
```

`Looper`通过循环调用`MessageQueue.next()`不断获取队头的`message`，执行一个再去取下一个。当`next()`获取队头消息为`同步屏障`时，就会向后遍历队列，获取`异步消息`优先执行，如果没有找到`异步消息`，就会让`next()`进入阻塞状态，主线程也会处于`空闲状态`，直到有`异步消息`进入队列，或者`移除同步屏障`。

#### 移除同步屏障

添加完`同步屏障`后，如果一直都没有消息处理，主线程就会进入空闲状态并且无法处理其他普通消息，此时就需要移除`同步屏障`，保证正常的消息处理。

```java
//MessageQueue.java
public void removeSyncBarrier(int token) {
        // Remove a sync barrier token from the queue.
        // If the queue is no longer stalled by a barrier then wake it.
        synchronized (this) {
            Message prev = null;
            Message p = mMessages;
            //根据token找到对应的 同步屏障消息，并移除
            while (p != null && (p.target != null || p.arg1 != token)) {
                prev = p;
                p = p.next;
            }
            if (p == null) {
                throw new IllegalStateException("The specified message queue synchronization "
                        + " barrier token has not been posted or has already been removed.");
            }
            final boolean needWake;
            if (prev != null) {
                prev.next = p.next;
                needWake = false;
            } else {
                mMessages = p.next;
                needWake = mMessages == null || mMessages.target != null;
            }
            p.recycleUnchecked();

            // If the loop is quitting then it is already awake.
            // We can assume mPtr != 0 when mQuitting is false.
            if (needWake && !mQuitting) {
                nativeWake(mPtr);
            }
        }
    }
```

移除`同步屏障`消息后，再次唤醒消息队列。

## 7. 主线程的消息循环

Android的主线程就是`ActivityThread`，主线程的入口方法为`main()`。

```java
// ../android/app/ActivityThread.java
public static void main(String[] args) {
 ...
        //创建主线程的Looper对象
        Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        if (false) {
            Looper.myLooper().setMessageLogging(new
                    LogPrinter(Log.DEBUG, "ActivityThread"));
        }

        // End of event ActivityThreadMain.
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        //该方法后 不能在写方法因为会被阻塞  开启主线程的消息循环
        Looper.loop();
}

//主要处理四大组件的启动和停止等过程
 private class H extends Handler {
  ...
    public void handleMessage(Message msg) {
     ...
     //处理主线程消息
    }
 }
```



> 主线程间的消息循环模型：

`ActivityThread`通过`ApplicationThread`和`AMS(ActivityManagerService)`进行进程间通信，`AMS`以进程间通信的方式完成`ActivityThread`的请求后回调`ApplicationThread`中的`Binder()`，然后`ApplicationThread`向`ActivityThread.H`发送消息，`H`收到消息后会把`ApplicationThread`中的逻辑切换到`ActivityThread`中去执行，这时就切换到了主线程。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac软件清单</title>
    <url>/2020/09/17/Mac%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[
### 电池管理软件

[bclm-Github](https://github.com/zackelia/bclm)

AIDente

]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Android动画-属性动画</title>
    <url>/2020/10/12/Android%E5%8A%A8%E7%94%BB-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[
> 对作用对象进行了扩展，可以对任何对象做动画，甚至可以没有对象。

![属性动画简析xmind](/images/属性动画简析xmind.png)

## 1.与View动画进行比较

- View动画的作用对象`只能是View`，属性动画可以作用于`所有Java对象`
- View动画并没有改变View的属性，只是改变了View的视觉效果，并不具有交互性(*例如：无法响应动画后的点击事件。*)；属性动画是真正的对View的属性进行了修改，可以方便后续的交互操作。
- View动画的效果比较单一，只能实现一些`平移，缩放，旋转等简单动画效果`，复杂的效果可能就需要`自定义View动画`去实现；属性动画拓展性强，可以基本实现所有的动画效果。

## 2.使用属性动画

> 使用XML方式

``` xml
<set
  android:ordering=["together" | "sequentially"]>
    <objectAnimator
        android:propertyName="string"
        android:duration="int"
        android:valueFrom="float | int | color"
        android:valueTo="float | int | color"
        android:startOffset="int"
        android:repeatCount="int"
        android:repeatMode=["repeat" | "reverse"]
        android:valueType=["intType" | "floatType"]/>

    <animator
        android:duration="int"
        android:valueFrom="float | int | color"
        android:valueTo="float | int | color"
        android:startOffset="int"
        android:repeatCount="int"
        android:repeatMode=["repeat" | "reverse"]
        android:valueType=["intType" | "floatType"]/>

</set>
```

`<set>`：表示动画集合，对应`AnimatorSet`

`android:ordering`：表示子动画的播放顺序

- `together`：子动画同时播放
- `sequentially`：子动画按照定义顺序先后播放

### 使用`ObjectAnimator`实现

> XML方式

`<objectAnimator>`：对象动画，对应`ObjectAnimator`

- `android:propertyName`：属性动画作用的属性名称

  | 属性         | 作用                   | 数值类型 |
  | ------------ | ---------------------- | -------- |
  | alpha        | 控制View的透明度       | float    |
  | translationX | 控制View的水平方向位移 | float    |
  | translationY | 控制View的竖直方向位移 | float    |
  | rotation     | 控制View的Z轴旋转度数  | float    |
  | rotationX    | 控制View的X轴旋转度数  | float    |
  | rotationY    | 控制View的Y轴旋转度数  | float    |
  | scaleX       | 控制View的X轴缩放倍数  | float    |
  | scaleY       | 控制View的Y轴缩放倍数  | float    |

- `android:duration`： 动画持续时长。

- `android:startOffset`：设置动画执行之前的等待时长。

- `android:repeatCount`：动画重复执行的次数。

  - 默认为**0**，表示只播放一次。
  - 设置为**-1或infinite**，表示无限重复。

- `android:repeatMode`：动画重复执行的模式。可选值：

  -  **restart**：表示连续重复，为默认值。
  -  **reverse** ：表示逆向重复。

- `android:valueFrom`：动画初始值。

- `android:valueTo`：动画结束值。

- `android:valueType`：动画值类型。可选值：

  - intType：表示属性的类型为 整形
  - floatType：表示属性的类型为浮点型 *默认值*
  - 不设置：如果表示颜色，无需设置

> Java创建

```java
ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(view,propertyName/*对应属性操作，可以为任意值*/,float... values/*动画的初始值以及结束值，不定长度*/);

mObjectAnimator.setDuration(duration);
mObjectAnimator.setStartDelay(delay);
mObjectAnimator.setRepeatCount(repeatCount);
mObjectAnimator.setRepeatMode(repeatMode);
mObjectAnimator.start();
```

##### 应用代码

> XML方式

```xml
// objectAnim.xml
<objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"  
    android:valueFrom="1"   // 初始值
    android:valueTo="0"  // 结束值
    android:valueType="floatType"  // 变化值类型 ：floatType & intType
    android:propertyName="alpha" // 对象变化的属性名称

/>
```

```java
// 载入XML动画
Animator animator = AnimatorInflater.loadAnimator(context, R.animator.objectAnim);  
// 设置执行动画对象
animator.setTarget(view);  
animator.start();
```

> Java方式

```java
ObjectAnimator mObjectAnimator = ObjectAnimator.ofFloat(view,"alpha",0,1);

mObjectAnimator.setDuration(1000);
mObjectAnimator.setStartDelay(100);
mObjectAnimator.setRepeatCount(0);
mObjectAnimator.setRepeatMode(ValueAnimator.RESTART);
mObjectAnimator.start();
```



### 使用`ValueAnimator`实现

`<animator>`：对应`ValueAnimator`

相比于`<objectAnimator>`少了一个`android:propertyName`，其他含义相同。

> Java创建

```java
ValueAnimator anim = ValueAnimator.ofInt(int... values);
//ValueAnimator anim = ValueAnimator.ofFloat(float... values);
//ValueAnimator anim = ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values);

anim.setDuration(duration);
anim.setStartDelay(delay);
anim.setRepeatCount(repeatCount);
anim.setRepeatMode(repeatMode);
anim.start();
```

##### 应用代码

```java
ValueAnimator anim = ValueAnimator.ofInt(0, 3);
        // 设置动画运行的时长
        anim.setDuration(500);       
        // 设置动画延迟播放时间
        anim.setStartDelay(500);
        // 设置动画重复播放次数 = 重放次数+1    
        anim.setRepeatCount(0); 
        anim.setRepeatMode(ValueAnimator.RESTART);
        anim.addUpdateLinstener(new ValueAnimator.AnimatorUpdateListener(){
  				@Override
  				public void onAnimationUpdate(ValueAnimator animation){
    				int currentValue = (Integer)animation.getAnimatedValue；
            //在其中对View进行相关属性设置 利用currentValue
              ...
            view.requestLayout();
  				}
				})
        anim.start();
```



### 使用动画集合`AnimatiorSet`实现

> 利用集合类`AnimatorSet`，内部可以随意组合继承`Animator类`的子类，而且可以定制顺序。

##### 应用代码

```java
// 平移动画
ObjectAnimator translation = ObjectAnimator.ofFloat(mButton, "translationX", curTranslationX, 300,curTranslationX);  
// 旋转动画
ObjectAnimator rotate = ObjectAnimator.ofFloat(mButton, "rotation", 0f, 360f);  
// 透明度动画
ObjectAnimator alpha = ObjectAnimator.ofFloat(mButton, "alpha", 1f, 0f, 1f);  

AnimatorSet animSet = new AnimatorSet();  
// 设置动画执行顺序
animSet.play(translation).with(rotate).before(alpha);  
animSet.setDuration(5000);  
animSet.start();
```



### 使用`ViewPropertyAnimator`实现

> 专门针对VIew操作的属性动画，可以直接由view进行调用，相当于一个简单的实现方式。

##### 应用代码

```java
//设置View 透明度以及平移
view.animate().alpha(0).translationX(100).setDuration(500).start(); 
```

### 注意内存泄露

> 在使用属性动画中的无限循环动画(`setRepeatCount(ValueAnimator.INFINITE)`)时，需要在合适的场合(`Activity关闭、View的detach`)取消动画

```java
    @Override
    protected void onDestroy() {
        super.onDestroy();
        if(animator.isRunning()){
          animator.cancel();
        }
    }
```

## 3.理解插值器和估值器

### 1.插值器(`Interpolator`)

> 根据时间流逝的百分比计算出当前属性值改变的百分比。确定了动画效果变化的模式，如匀速变化、加速变化等。

系统内部预置了一些常用的插值器：

- `LinearInterpolator` : 线性插值器 - 匀速运动
- `AccelerateDecelerateInterpolator`：加速减速插值器 - 两头慢中间快
- `DecelerateInterpolator`：减速插值器 - 越来越慢

可以应用的对象：

- View动画： 上文有提到，对应设置属性为`android:interpolator`
- 属性动画：实现*非匀速运动*的方法

自定义插值器：

> 可以高度定制化自己需要的运行轨迹。

实现：需要实现`Interpolator/TimeInterpolator`接口并复写`getInterpolation()`方法。

> 1. 补间动画 实现 `Interpolator`接口；属性动画实现`TimeInterpolator`接口
> 2. `TimeInterpolator`接口是属性动画中新增的，用于兼容`Interpolator`接口，这使得所有过去的`Interpolator`实现类都可以直接在属性动画使用。

接口说明：

```java
public interface TimeInterpolator {    
    float getInterpolation(float input);  
}  

public interface Interpolator extends  TimeInterpolator{  
}

input 变化范围为0~1 
返回值float型的  用于估值器计算的
```



实现示例：*自定义插值器的关键在于`input`根据动画的进度(0%~100%)通过逻辑计算，得到当前属性值改变的百分比。*

```java
public class DecelerateAccelerateInterpolator implements TimeInterpolator {

    @Override
    public float getInterpolation(float input) {
        float result;
        if (input <= 0.5) {
            result = (float) (Math.sin(Math.PI * input)) / 2;
        } else {
            result = (float) (2 - Math.sin(Math.PI * input)) / 2;
        }
        return result;
    }
```



### 2.估值器(`Evaluator`)

> 根据当前属性改变的百分比来计算改变后的属性值

系统提供了一些估值器：

- `IntEvaluator`：整形估值器
- `FloatEvaluator`：浮点型估值器
- `ArgbEvaluator`：Color属性估值器

可以应用的对象：

**属性动画专属**

使用方法：

```java
ValueAnimator anim = ValueAnimator.ofInt(int... values);  //使用的是 IntEvaluator
ValueAnimator anim = ValueAnimator.ofFloat(float... values); //使用的是 FloatEvaluator
ValueAnimator anim = ValueAnimator.ofArgb(int... values);// 使用的是 ArgbEvaluator
//需要自定义 估值器
ValueAnimator anim = ValueAnimator.ofObject(TypeEvaluator evaluator, Object... values);
```



自定义估值器：

> 除了`int,float,color`类型之外的类型做动画，需要用到自定义估值器

接口说明：

```java
public interface TypeEvaluator<T> {
    /**
    * @param fraction   估值小数 插值器的返回值
    * @param startValue 起始值
    * @param endValue   结束值
    */
    public T evaluate(float fraction, T startValue, T endValue);
}
```

实现实例：

先定义自定义对象

```java
class Point {
    // 设置两个变量用于记录坐标的位置
    private float x;
    private float y;

    // 构造方法用于设置坐标
    public Point(float x, float y) {
        this.x = x;
        this.y = y;
    }

    // get方法用于获取坐标
    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }
}
```

定义估值器

```java
class PointEvaluator implements TypeEvaluator<Point> {

    @Override
    public Point evaluate(float fraction, Point startValue, Point endValue) {
        float x = startValue.getX() + fraction * (endValue.getX() - startValue.getX());
        float y = startValue.getY() + fraction * (endValue.getY() - startValue.getY());
        return new Point(x, y);
    }
}
```

使用估值器

```java
Point startPoint = new Point(100, 100);// 初始点为圆心(100, 100)
Point endPoint = new Point(300, 300);// 结束点为(300, 300)
ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);
anim.setDuration(5000);
anim.start();
```

## 4.属性动画监听器

> 可以监听属性动画的播放过程，包括`起始，结束，取消，重复`。

```java
public static interface AnimatorListener {
  //动画开始
  void onAnimationStart(Animation animation);
  //动画结束
  void onAnimationEnd(Animation animation);
  //动画取消
  void onAnimationCancel(Animation animation);
  //动画重复
  void onAnimationRepeat(Animation animation);
}

调用方式
animator.addListener(new AnimatorListener(){
 ...
})；
```

拓展：

`AnimatorListenerAdapter`：`AnimatorListener`的适配器类，主要为了解决**实现接口繁琐**的问题。在大多数情况下，我们可能只要监听动画的开始和结束事件。如果直接继承`AnimatorListener`接口，就需要实现额外的方法。

```java
public abstract class AnimatorListenerAdapter implements Animator.AnimatorListener,
        Animator.AnimatorPauseListener {

    @Override
    public void onAnimationCancel(Animator animation) {
    }

    @Override
    public void onAnimationEnd(Animator animation) {
    }

    @Override
    public void onAnimationRepeat(Animator animation) {
    }

    @Override
    public void onAnimationStart(Animator animation) {
    }

    @Override
    public void onAnimationPause(Animator animation) {
    }

    @Override
    public void onAnimationResume(Animator animation) {
    }
}

使用方式
animator.addListener(new AnimatorListenerAdapter(){
    @Override
    public void onAnimationStart(Animator animation) {
      //只实现开始监听
    }
})
```



#### `AnimatorUpdateListener`：监听整个动画过程，每播放一帧，就会回调一次。

```java
public static interface AnimatorUpdateListener {
   void onAnimationUpdate(ValueAnimator animation)；
}
```

利用这个特性，我们可以去对得到的数据进行处理。

上文中，自定义估值器，我们设置了一个`Point`对象，它的动画过程就是`Point`对象内部`x,y`变化的过程，我们就可以利用这个接口实时的去获取内部`x,y`进行操作。利用`ValueAnimator.getAnimatedValue()`就可以获取到对应的对象。

## 5.对任意属性做动画

上文中我们提到`android:propertyName`里面填的就是 属性动画可以支持的属性，假如我们要对View的宽度做动画，应该如何实现？

**属性动画的原理：属性动画要求动画作用的对象必须提供该属性的`get()和set()`方法，属性动画根据外界传递的该属性的初始值和结束值，以动画的效果多次去调用`set()`，每次传入的值不一样，随着时间推移，会越来越接近结束值。**

根据上述原理，我们可以得出一个结果。要想动画生效，必须支持两个条件：

- `Object`必须提供`set()`，如果动画没有传递初始值，那么还要提供`get()`，因为系统要去获取初始值，计算最终值。（*不满足则直接Crash*）
- `Object`设置的`set()`必须可以让View产生变化，比如UI上会发生变化。(*不满足则不会发生变化*)

针对上述条件，可以有3种解决方法：

1. #### 给你的对象加上`get(),set()`，如果你有权限的话

   > 继承原始类，直接给继承类加上`get(),set()`，从而实现给对象加上该属性的`get(),set()`

2. #### 用一个类来包装原始对象，间接提供`get(),set()`

   > 本质上是采用了设计模式中的装饰模式，即通过包装拓展对象的功能。

   示例：一开始就提到了对View的宽度进行动画效果，用这种方案就是找一个类来进行包装。

   ```java
   public class AnimActivity extends Activity {
     ImageView imageView;
     ViewWrapper wrapper;
     
     @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           setContentView(R.layout.activity_main);
           imageView = (ImageView) findViewById(R.id.imageView);        
           // 创建包装类,并传入动画作用的对象
           wrapper = new ViewWrapper(imageView);        
           imageView.setOnClickListener(new View.OnClickListener() {
               @Override
               public void onClick(View v) {
                   ObjectAnimator.ofInt(wrapper, "width"/*对应我们设置的getWidth()和setWidth()*/, 500).setDuration(3000).start();
               }
           });
       }
     
       // 提供ViewWrapper类,用于包装View对象
       private static class ViewWrapper {
           private View mTarget;
   
           // 构造方法:传入需要包装的对象
           public ViewWrapper(View target) {
               mTarget = target;
           }
   
           // 为宽度设置get（） & set（）
           public int getWidth() {
               return mTarget.getLayoutParams().width;
           }
   
           public void setWidth(int width) {
               mTarget.getLayoutParams().width = width;
               //对View重新布局
               mTarget.requestLayout();
           }
       }
   }
   ```

3. #### 采用`ValueAnimator`，监听动画过程，利用返回值动态调整View属性

   > `ValueAnimator`本身不作用于任何对象，直接使用它不会有任何效果。做到的就是对一个View的属性进行变化。在动画过程中修改属性值，就类似于对对象做了动画。

   ```java
   public class AnimActivity extends Activity{
     @Override
     protected void onCreate(Bundle savedInstanceState){
       setContentView(R.layout.main);
       view.post(new Runnable(){
         @Override
         public void run(){
           performAnimator(view,view.getWidth,500);
         }
       })
     }
     
     private void performAnimatior(final View target,final int start,final int end){
       ValueAnimator valueAnimator = ValueAnimator.ofInt(1,100);
       valueAnimator.addUpdateListener(new AnimatorUpdateListener(){
          private IntEvaluator mEvaluator = new IntEvaluator();
          @Override
         public void onAnimationUpdate(ValueAnimator animator){
           int currentValue = (Integer)animator.getAnimatedValue();
           float fraction = animator.getAnimatedFraction();
           target.getLayoutParams().width = mEvaluator.evaluate(fraction,start,end);
           target.requestLayout();
         }
       });
       valueAnimator.setDuration(5000).start();
     }
   }
   ```

## 6.属性动画工作原理

![属性动画执行流程](/images/属性动画执行流程.png)

> 属性动画要求动画作用的对象必须提供该属性的`set()`方法，属性动画就会根据你传递的该属性的初始值和最终值，以动画的效果多次去调用`set()`。每次传递给`set()`的值都不一样，确切的来说是随着时间的推移，传递的值越来越接近最终值。如果动画不提供初始值，那就需要定义`get()`，以供系统去获取初始值。

接下来就从入口处开始分析。



`ObjectAnimator.ofFloat(view,"alpha",0f,1f).start()`意味着动画开始。

```java
// ../android/animation/ObjectAnimator.java
public void start() {
  //如果动画已经执行，则停止动画
  AnimationHandler.getInstace().autoCancelBasedOn(this);
  super.start()
}
```

`super.start()`就调用到父类`ValueAnimator.start()`

### ValueAnimator.start()

> 属性动画执行

```java
// ../android/animation/ValueAnimator.java
public void start(){
  start(false);
}

    private void start(boolean playBackwards) {
        if (Looper.myLooper() == null) {
            throw new AndroidRuntimeException("Animators may only be run on Looper threads");
        }
        mReversing = playBackwards;
        mSelfPulse = !mSuppressSelfPulseRequested;
        // Special case: reversing from seek-to-0 should act as if not seeked at all.
        if (playBackwards && mSeekFraction != -1 && mSeekFraction != 0) {
            if (mRepeatCount == INFINITE) {
                // Calculate the fraction of the current iteration.
                float fraction = (float) (mSeekFraction - Math.floor(mSeekFraction));
                mSeekFraction = 1 - fraction;
            } else {
                mSeekFraction = 1 + mRepeatCount - mSeekFraction;
            }
        }
        mStarted = true;
        mPaused = false;
        mRunning = false;
        mAnimationEndRequested = false;
        mLastFrameTime = -1;
        mFirstFrameTime = -1;
        mStartTime = -1;
        addAnimationCallback(0);

        if (mStartDelay == 0 || mSeekFraction >= 0 || mReversing) {
            startAnimation();//开始动画并回调`onAnimationStart`
            if (mSeekFraction == -1) {
                setCurrentPlayTime(0);
            } else {
                setCurrentFraction(mSeekFraction);
            }
        }
    }
```

#### startAnimation()

> 初始化一些变量以及回调`onAnimationStart()`

```java
    private void startAnimation() {
        ...
        mAnimationEndRequested = false;
        initAnimation();
        mRunning = true;
        if (mSeekFraction >= 0) {
            mOverallFraction = mSeekFraction;
        } else {
            mOverallFraction = 0f;
        }
        if (mListeners != null) {
            notifyStartListeners();
        }
    }

    private void notifyStartListeners() {
        if (mListeners != null && !mStartListenersCalled) {
            ArrayList<AnimatorListener> tmpListeners =
                    (ArrayList<AnimatorListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onAnimationStart(this, mReversing);//回调onAnimationStart
            }
        }
        mStartListenersCalled = true;
    }
```



### addAnimationCallback(0)

> 真正执行动画的部分代码

```java
    private void addAnimationCallback(long delay) {
        if (!mSelfPulse) {
            return;
        }
        getAnimationHandler().addAnimationFrameCallback(this, delay);
    }

    public AnimationHandler getAnimationHandler() {
        return AnimationHandler.getInstance();
    }
```

#### addAnimationFrameCallback()

```java
//AnimationHandler.java
    private final Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() {
        @Override
        public void doFrame(long frameTimeNanos) {
            doAnimationFrame(getProvider().getFrameTime());
            if (mAnimationCallbacks.size() > 0) {//回调为0时候
                getProvider().postFrameCallback(this);//注册下一次的刷新事件监听
            }
        }
    };

    public void addAnimationFrameCallback(final AnimationFrameCallback callback, long delay) {
        if (mAnimationCallbacks.size() == 0) {
            getProvider().postFrameCallback(mFrameCallback);
        }
        if (!mAnimationCallbacks.contains(callback)) {
            mAnimationCallbacks.add(callback);
        }

        if (delay > 0) {
            mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));
        }
    }

    private AnimationFrameCallbackProvider getProvider() {
        if (mProvider == null) {
            mProvider = new MyFrameCallbackProvider();
        }
        return mProvider;
    }
```

注册`mFrameCallback`到`Choreographer`的待执行队列里，并向底层注册一个屏幕刷新信号事件`onVsync()`

此时的`mAnimationCallbacks`持有的是`ValueAnimator`集合

#### postFrameCallback()

> 注册监听

```java
//AnimationHandler.java
    private class MyFrameCallbackProvider implements AnimationFrameCallbackProvider {

        final Choreographer mChoreographer = Choreographer.getInstance();

        @Override
        public void postFrameCallback(Choreographer.FrameCallback callback) {
            mChoreographer.postFrameCallback(callback);
        }

        @Override
        public void postCommitCallback(Runnable runnable) {
            mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, null);
        }

        @Override
        public long getFrameTime() {
            return mChoreographer.getFrameTime();
        }

        @Override
        public long getFrameDelay() {
            return Choreographer.getFrameDelay();
        }

        @Override
        public void setFrameDelay(long delay) {
            Choreographer.setFrameDelay(delay);
        }
    }
```

`AnimationHandler`通过`Choreographer`向底层注册监听下一个`屏幕刷新信号`，接收到信号时`mFrameCallback`执行，调用`doAnimationFrame()`。如果还有动画未执行完毕，继续注册监听下一个`屏幕刷新信号`。

### Choreographer.postFrameCallback()

> 动画的核心类

```java
//Choreographer.java
    public void postFrameCallback(FrameCallback callback) {
        postFrameCallbackDelayed(callback, 0);
    }

    public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {
        if (callback == null) {
            throw new IllegalArgumentException("callback must not be null");
        }

        postCallbackDelayedInternal(CALLBACK_ANIMATION,
                callback, FRAME_CALLBACK_TOKEN, delayMillis);
    }

```

其中`postCallbackDelayedInternal()`内部相关的代码可以参考{% post_link View的刷新机制%}



### AnimationHandler.doAnimationFrame()

> 每次在`Vsync`信号来临时会执行到`doFrame()`对应执行到`doAnimationFrame()`

```java
    private void doAnimationFrame(long frameTime) {
        long currentTime = SystemClock.uptimeMillis();
        final int size = mAnimationCallbacks.size();
        for (int i = 0; i < size; i++) {
            final AnimationFrameCallback callback = mAnimationCallbacks.get(i);
            if (callback == null) {
                continue;
            }
            if (isCallbackDue(callback, currentTime)) {
                callback.doAnimationFrame(frameTime);
                if (mCommitCallbacks.contains(callback)) {
                    getProvider().postCommitCallback(new Runnable() {
                        @Override
                        public void run() {
                            commitAnimationFrame(callback, getProvider().getFrameTime());
                        }
                    });
                }
            }
        }
        cleanUpList();
    }

        @Override
        public void postCommitCallback(Runnable runnable) {
            mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, null);
        }
```

#### cleanUpList()

> 清理已经执行完毕的动画

```java
    private void cleanUpList() {
        if (mListDirty) {
            for (int i = mAnimationCallbacks.size() - 1; i >= 0; i--) {
                if (mAnimationCallbacks.get(i) == null) {
                    mAnimationCallbacks.remove(i);
                }
            }
            mListDirty = false;
        }
    }
```



#### ValueAnimator.commitAnimationFrame()

> `callback`有效时，执行对应callback的`commitAnimationFrame()`，此时`callback`为`ValueAnimator`

```java
    public void commitAnimationFrame(long frameTime) {
        if (!mStartTimeCommitted) {
            mStartTimeCommitted = true;
            long adjustment = frameTime - mLastFrameTime;
            if (adjustment > 0) {
                mStartTime += adjustment;
                if (DEBUG) {
                    Log.d(TAG, "Adjusted start time by " + adjustment + " ms: " + toString());
                }
            }
        }
    }
```

**为了修正动画的第一帧时间**

`Choreographer`内部持有多个队列，分别是`CALLBACK_INPUT(输入事件)`、`CALLBACK_ANIMATION(动画事件)`、`CALLBACK_TRAVERSAL(绘制事件)`，`CALLBACK_COMMIT(完成后的提交操作)`。此时`commitAnimationFrame()`执行在`CALLBACK_COMMIT`队列中，位于最后。

当有事件来后，先执行的是`动画事件`，如果页面太复杂，导致绘制时间过长，就可能导致下一个`Vsync`信号到来时，动画执行时会丢失前面几帧，利用`commitAnimationFrame`就可以及时修正第一帧的时间，使动画完整执行。

### ValueAnimator.doAnimationFrame()

> `callback`有效时，执行对应callback的`doAnimationFrame()`，此时`callback`为`ValueAnimator`

```java
//ValueAnimator.java 
public final boolean doAnimationFrame(long frameTime) {
        if (mStartTime < 0) {
            // First frame. If there is start delay, start delay count down will happen *after* this
            // frame.
            mStartTime = mReversing //动画是否反复
                    ? frameTime
                    : frameTime + (long) (mStartDelay * resolveDurationScale());
        }

        // Handle pause/resume
        if (mPaused) {
            mPauseTime = frameTime;
            removeAnimationCallback();
            return false;
        } else if (mResumed) {
            mResumed = false;
            if (mPauseTime > 0) {
                // Offset by the duration that the animation was paused
                mStartTime += (frameTime - mPauseTime);
            }
        }

        //动画尚未执行时
        if (!mRunning) {
            // If not running, that means the animation is in the start delay phase of a forward
            // running animation. In the case of reversing, we want to run start delay in the end.
            if (mStartTime > frameTime && mSeekFraction == -1) {
                // This is when no seek fraction is set during start delay. If developers change the
                // seek fraction during the delay, animation will start from the seeked position
                // right away.
                return false;
            } else {
                // If mRunning is not set by now, that means non-zero start delay,
                // no seeking, not reversing. At this point, start delay has passed.
                mRunning = true;
                startAnimation();//开始动画
            }
        }

        if (mLastFrameTime < 0) {
            if (mSeekFraction >= 0) {
                long seekTime = (long) (getScaledDuration() * mSeekFraction);
                mStartTime = frameTime - seekTime;
                mSeekFraction = -1;
            }
            mStartTimeCommitted = false; // allow start time to be compensated for jank
        }
        mLastFrameTime = frameTime;
        // The frame time might be before the start time during the first frame of
        // an animation.  The "current time" must always be on or after the start
        // time to avoid animating frames at negative time intervals.  In practice, this
        // is very rare and only happens when seeking backwards.
        final long currentTime = Math.max(frameTime, mStartTime);//判断当前动画执行的时间
        boolean finished = animateBasedOnTime(currentTime);//动画是否执行完毕

        if (finished) {
            endAnimation();
        }
        return finished;
    }
```

#### endAnimation()

> 动画执行完毕后的清理工作，并且回调`onAnimationEnd`监听

```java
private void endAnimation() {
        if (mAnimationEndRequested) {
            return;
        }
        removeAnimationCallback();

        mAnimationEndRequested = true;
        mPaused = false;
        boolean notify = (mStarted || mRunning) && mListeners != null;
        if (notify && !mRunning) {
            // If it's not yet running, then start listeners weren't called. Call them now.
            notifyStartListeners();
        }
        mRunning = false;
        mStarted = false;
        mStartListenersCalled = false;
        mLastFrameTime = -1;
        mFirstFrameTime = -1;
        mStartTime = -1;
        if (notify && mListeners != null) {
            ArrayList<AnimatorListener> tmpListeners =
                    (ArrayList<AnimatorListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onAnimationEnd(this, mReversing);//回调 onAnimationEnd
            }
        }
        // mReversing needs to be reset *after* notifying the listeners for the end callbacks.
        mReversing = false;
    }

//AnimationHelper.java
//移除动画执行监听
    public void removeCallback(AnimationFrameCallback callback) {
        mCommitCallbacks.remove(callback);
        mDelayedCallbackStartTime.remove(callback);
        int id = mAnimationCallbacks.indexOf(callback);
        if (id >= 0) {
            mAnimationCallbacks.set(id, null);
            mListDirty = true;
        }
    }
```



#### ValueAnimator.animateBasedOnTime()

> 根据当前时间计算并实现当前帧的动画

```java
    boolean animateBasedOnTime(long currentTime) {
        boolean done = false;
        if (mRunning) {
            final long scaledDuration = getScaledDuration();
            final float fraction = scaledDuration > 0 ?
                    (float)(currentTime - mStartTime) / scaledDuration : 1f; 
            final float lastFraction = mOverallFraction;
            final boolean newIteration = (int) fraction > (int) lastFraction;
            final boolean lastIterationFinished = (fraction >= mRepeatCount + 1) &&
                    (mRepeatCount != INFINITE);
            if (scaledDuration == 0) {
                // 0 duration animator, ignore the repeat count and skip to the end
                done = true;
            } else if (newIteration && !lastIterationFinished) {
                // Time to repeat
                if (mListeners != null) {
                    int numListeners = mListeners.size();
                    for (int i = 0; i < numListeners; ++i) {
                        mListeners.get(i).onAnimationRepeat(this);
                    }
                }
            } else if (lastIterationFinished) {
                done = true;
            }
            mOverallFraction = clampFraction(fraction);
            float currentIterationFraction = getCurrentIterationFraction(
                    mOverallFraction, mReversing);
            animateValue(currentIterationFraction);
        }
        return done;
    }
```

##### clampFraction()

> 根据当前时间以及动画第一帧时间还有动画持续的时长来计算当前的动画进度。
>
> 确保动画进度的取值在`0-1`之间。

```java
    private float clampFraction(float fraction) {
        if (fraction < 0) {
            fraction = 0;
        } else if (mRepeatCount != INFINITE) {
            fraction = Math.min(fraction, mRepeatCount + 1);//得到重复执行后的累加进度
        }
        return fraction;
    }

    //保证返回值位于 0-1之间
    private float getCurrentIterationFraction(float fraction, boolean inReverse) {
        fraction = clampFraction(fraction);
        int iteration = getCurrentIteration(fraction);
        float currentFraction = fraction - iteration;
        return shouldPlayBackward(iteration, inReverse) ? 1f - currentFraction : currentFraction;
    }
```



### ValueAnimator.animateValue()

> 前面计算得到当前动画进度后，需要应用该值到View上

```java
    void animateValue(float fraction) {
        fraction = mInterpolator.getInterpolation(fraction);
        mCurrentFraction = fraction;
        int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            mValues[i].calculateValue(fraction);
        }
        if (mUpdateListeners != null) {
            int numListeners = mUpdateListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                mUpdateListeners.get(i).onAnimationUpdate(this);//通知动画的监听回调
            }
        }
    }
```

#### getInterpolation()

> 根据设置的插值器获取应当达到的进度

### PropertyValuesHolder.calculateValue()

> 根据进度计算最终需要用到的数值

```java
    Keyframes mKeyframes = null; //关键帧   

    void calculateValue(float fraction) {
        Object value = mKeyframes.getValue(fraction);
        mAnimatedValue = mConverter == null ? value : mConverter.convert(value);
    }
```

在执行`ObjectAnimator.start()`之前，需要先执行`ObjectAnimator.ofFloat(float... values)`

```java
//ValueAnimator.java
    public void setFloatValues(float... values) {
        if (values == null || values.length == 0) {
            return;
        }
        if (mValues == null || mValues.length == 0) {
            setValues(PropertyValuesHolder.ofFloat("", values));
        } else {
            PropertyValuesHolder valuesHolder = mValues[0];
            valuesHolder.setFloatValues(values);
        }
        // New property/values/target should cause re-initialization prior to starting
        mInitialized = false;
    }

//PropertyValuesHolder.java
    public void setFloatValues(float... values) {
        mValueType = float.class;
        mKeyframes = KeyframeSet.ofFloat(values);
    }
```

所以`mKeyFrames.getValue(XX)`中的`mKeyFrames`为`KeyframeSet.ofFloat()`

#### KeyframeSet.ofFloat()

> `KeyframeSet`关键帧集合，根据传入的节点，生成`FloatkeyframeSet`

```java
//KeyframeSet.java
    public static KeyframeSet ofFloat(float... values) {
        boolean badValue = false;
        int numKeyframes = values.length;
        FloatKeyframe keyframes[] = new FloatKeyframe[Math.max(numKeyframes,2)];//关键帧集合
        if (numKeyframes == 1) {//只有一个关键帧，生成两个一致的帧
            keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f);
            keyframes[1] = (FloatKeyframe) Keyframe.ofFloat(1f, values[0]);
            if (Float.isNaN(values[0])) {
                badValue = true;
            }
        } else {//超过一个关键帧，按照传入数量，生成对应数量的帧集合
            keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f, values[0]);
            for (int i = 1; i < numKeyframes; ++i) {
                keyframes[i] =
                        (FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]);
                if (Float.isNaN(values[i])) {
                    badValue = true;
                }
            }
        }
        if (badValue) {
            Log.w("Animator", "Bad value (NaN) in float animator");
        }
        return new FloatKeyframeSet(keyframes);
    }

```

#### FloatKeyframeSet.getValue()

> 根据当前进度，返回关键帧数值

```java
//FloatKeyframeSet.java
class FloatKeyframeSet extends KeyframeSet implements Keyframes.FloatKeyframes {
    public FloatKeyframeSet(FloatKeyframe... keyframes) {
        super(keyframes);
    }

    @Override
    public Object getValue(float fraction) {
        return getFloatValue(fraction);
    }

   @Override
    public float getFloatValue(float fraction) {
        if (fraction <= 0f) {//初始点
            final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);//第一帧
            final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(1);//第二帧
            ...
            return mEvaluator == null ?
                    prevValue + intervalFraction * (nextValue - prevValue) :
                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
                            floatValue();
        } else if (fraction >= 1f) {//终点
            final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 2);//倒数第二帧
            final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 1);//倒数第一帧
            ...
            return mEvaluator == null ?
                    prevValue + intervalFraction * (nextValue - prevValue) :
                    ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
                            floatValue();
        }
        FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
        for (int i = 1; i < mNumKeyframes; ++i) {//其中位置
            FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(i);
            if (fraction < nextKeyframe.getFraction()) {
                ...
                return mEvaluator == null ?
                        prevValue + intervalFraction * (nextValue - prevValue) :
                        ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).
                            floatValue();
            }
            prevKeyframe = nextKeyframe;
        }
        // shouldn't get here
        return ((Number)mKeyframes.get(mNumKeyframes - 1).getValue()).floatValue();
    }
  
  ...
}
```

`getFloatValue()`根据以下情况返回不同结果：

- `起点`：取出第一和第二帧，得到对应进度
- `终点`：取出倒数第二和第一帧，得到对应进度
- `中间点`：遍历找到输入进度`fraction`位于第一帧和第几关键帧之间，然后计算关键帧转换得到的进度



### ObjectAnimator.animateValue()

> `ValueAnimator`子类`ObjectAnimator`重写了该方法

```java
    void animateValue(float fraction) {
        final Object target = getTarget();
        if (mTarget != null && target == null) {
            // We lost the target reference, cancel and clean up. Note: we allow null target if the
            /// target has never been set.
            cancel();
            return;
        }

        super.animateValue(fraction);
        int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            mValues[i].setAnimatedValue(target);
        }
    }
```

`super.animaterValue()`指的就是前面的`ValueAnimator.animateValue()`，在计算得到进度之后，`ObjectAnimator`是对对象生效的，接下来

需要将值赋予`target`

#### PropetryValuesHolder.setAnimatedValue()

> 针对`target`进行赋值操作

```java
    void setAnimatedValue(Object target) {
        if (mProperty != null) {
            mProperty.set(target, getAnimatedValue());
        }
        if (mSetter != null) {
            try {
                mTmpValueArray[0] = getAnimatedValue();
                mSetter.invoke(target, mTmpValueArray);
            } catch (InvocationTargetException e) {
                Log.e("PropertyValuesHolder", e.toString());
            } catch (IllegalAccessException e) {
                Log.e("PropertyValuesHolder", e.toString());
            }
        }
    }
```

拿`ObjectAnimator.ofFloat(view,View.SCALE_X,0f,1f)`为例，分析`setAnimatedValue()`执行结果

```java
    void setupSetter(Class targetClass) {
        Class<?> propertyType = mConverter == null ? mValueType : mConverter.getTargetType();
        mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", propertyType);
    }

    private Method setupSetterOrGetter(Class targetClass,
            HashMap<Class, HashMap<String, Method>> propertyMapMap,
            String prefix, Class valueType) {
      ...
        setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);
      ...
    }

    private Method getPropertyFunction(Class targetClass, String prefix, Class valueType) {
        Method returnVal = null;
        String methodName = getMethodName(prefix, mPropertyName); //方法名setScaleX() 
        ... //反射获取方法
       
    }
```

> `PropertyValuesHolder`负责**保存动画过程中所需要操作的属性和值**。`ObjectAnimator.ofFloat(Object target,String propertyName.float... values)`内部的参数会被封装成`PropertyValuesHolder`实例。

![属性动画执行过程](/images/属性动画执行过程.jpg)



## 7.View.setXX()

- `alpha`：更改View的不透明度
- `x`、`y`、`translationX`、`translationY`：更改View的位置
- `scaleX`、`scaleY`：更改View的缩放
- `rotation`、`rotationX`、`rotationY`：更改View在3D空间的方向
- `pivotX`、`pivotY`：更改View的转换原点



## 8.参考链接

[源码解读Android属性动画](http://gityuan.com/2015/09/06/android-anaimator-4/)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-AbstractQueuedSynchronizer简介</title>
    <url>/2020/09/13/Java-AbstractQueuedSynchronizer%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[
![AQS原理](/images/AQS原理xmind.png)

## AQS简介

AQS全称为`AbstractQueuedSynchronizer`，意为`抽象队列同步器`。

- `Abstract`：抽象类，只实现主要逻辑，其他交由子类实现
- `Queued`：`FIFO`队列存储数据
- `Synchronizer`：同步

在`Lock`中，是非常重要的核心组件。`AQS`是用来构建锁和同步器的框架，使用`AQS`可以简单且高效构建同步器。我们常见的`ReentrantLock、CountdownLatch`都是基于`AQS`构建的。

`AQS`主要做了三件事情：

1. 同步状态的管理
2. 线程的阻塞和唤醒
3. 同步队列的维护

## AQS同步方式

从使用层面来讲，AQS同步方式分为以下两种：

### 独占模式(Exclusive)

资源是独占的，一次只能有一个线程获取。

例如`ReentrantLock`



### 共享模式(Share)

资源是共享的，可以被多个线程同时获取并访问，还可以指定允许访问的资源个数。

例如`CountdownLatch`、`Semaphore`



### 混合模式(mixed)

将两种模式混合在一起进行使用，可以在特定条件下进行`独占`或`共享`资源。

例如`ReentrantReadWhiteLock`



## AQS的数据结构

AQS依赖内部的一个`FIFO双端队列`实现同步状态(`state`)的管理，并且使用了`head`和`tail`分别表示队列的首尾节点。

![AQS-等待队列](/images/AQS-等待队列.png)

队列中储存的是`Node`节点，其中包含了**当前线程以及等待状态信息**。

### state

> 表示资源当前状态。

```java
private volatile int state; //资源标识
```

同时定义了了几个关于`state`的方法，提供给子类覆盖实现自身逻辑。

例如：

`ReentrantLock`：表示的资源为`独占锁`，`state=0`表示没持有锁，`state=1`表示锁被占用，`state>1`表示了锁重入次数。

`CountdownLatch`：表示的资源为`计数`，`state=0`表示计数器归零，可以被其他线程访问资源，`state>0`表示所有线程访问资源时都需要阻塞。

```java
getState()//获取同步状态
  
setState(int newState)//设置同步状态
  
compareAndSetState(int expect,int update)//基于CAS，原子设置当前状态
```



### Node

> AQS内部等待队列的节点

```java
    /*     
     * <pre>
     *      +------+  prev +-----+       +-----+
     * head |      | <---- |     | <---- |     |  tail
     *      +------+       +-----+       +-----+
     * </pre>
     */  
static final class Node {
   //标记当前节点(线程)位于共享模式下等待
   static final Node SHARED = new Node();
   //标记当前节点(线程)位于独占模式下等待
   static final Node EXCLUSIVE = null;
   //表示当前线程状态是取消的
   static final int CANCELLED =  1;
   //表示当前线程正在等待锁，需要被唤醒
   static final int SIGNAL    = -1;
   //表示当前线程等待某一条件
   static final int CONDITION = -2;
   //表示当前线程有资源可用，需要继续唤醒后续节点(CountdownLatch下使用)
   static final int PROPAGATE = -3;
   //节点中线程的状态，默认为0
   volatile int waitStatus;
   //当前节点的前一个节点
   volatile Node prev;
   //当前节点的后一个节点
   volatile Node next;
   //当前节点封装的线程信息
   volatile Thread thread;
   //等待队列中的下一个等待节点
   Node nextWaiter;
   
   //判断是否为共享模式
   final boolean isShared() {
            return nextWaiter == SHARED;
        }
  
   Node(Thread thread, Node mode) {     // Used by addWaiter
            this.nextWaiter = mode;
            this.thread = thread;
        }
  
}
```

![AQS-Node](/images/AQS-Node.png)

`prev`：当前节点的上一个节点

`next`：当前节点的下一个节点

`thread`：当前节点持有的线程

`waitStatus`：当前节点的状态

`nextWaiter`：下一个处于`CONDITION`状态的节点

`Node`是一个变体`CLH`的节点，`CLH`应用了自旋锁，节点保存了当前阻塞线程的信息。如果他的前驱节点释放了，就需要通过修改`waitStatus`字段出队前驱节点，让当前节点尝试获取锁。若有新的等待线程要入队，就会加入到队列的尾部。

其中`waitStatus`有以下几种状态：

| waitStatus | 值   | 描述                                                         |
| ---------- | ---- | ------------------------------------------------------------ |
| SIGNAL     | -1   | 表示当前节点的后续节点被阻塞或即将被阻塞，当前节点释放或取消后需要唤醒后续节点。*一般是后续节点来设置前驱节点的。* |
| CANCELLED  | 1    | 表示当前节点超时或被中断，需要移出等待队列                   |
| CONDITION  | -2   | 表示当前节点在`Condition`队列中，阻塞等待某个条件唤醒        |
| PROPAGATE  | -3   | 适用于共享模式(连续的操作节点依次进入临界区)，用于将唤醒后续线程传递下去，**为了完善和增强锁的唤醒机制。** |
| INIT       | 0    | 节点初始创建处于该状态                                       |

[CLH队列](https://blog.csdn.net/HalfImmortal/article/details/107432756)

> 通过`Node`可以实现两个队列
>
> - 通过`prev`、`next`实现双向队列
> - 通过`nextWaiter`实现`Condition`的单向等待队列

### ConditionObject

> 用于实现`Condition`功能的内部类，直接作用于线程，对线程进行调度

```java
    public class ConditionObject implements Condition, java.io.Serializable {
        private static final long serialVersionUID = 1173984872572414699L;
        /** First node of condition queue. */
        private transient Node firstWaiter;
        /** Last node of condition queue. */
        private transient Node lastWaiter;
      ...
    }
```

由`Node`组成的单向队列。

<!--后续原理描述会分析内部实现。 -->

## AQS原理解析

### 子类实现方法

`AQS`的设计是基于**模板方法模式(定义基本功能后，将一些实现延迟到子类)**的，所以其中一些方法必须交由子类去实现。

#### isHeldExclusively()-是否独占资源

该线程是否正在独占资源。*只有需要用到`Condition`才需要去实现该方法*

#### tryAcquire()-获取独占资源

**独占方式**获取资源，成功获取返回`true`，失败返回`false`

#### tryRelease()-释放独占资源

**独占方式**释放资源，成功释放返回`true`，失败返回`false`

#### tryAcquireShared()-获取共享资源

**共享方式**获取资源

- 返回`负数`，表示资源获取失败
- 返回`0`，表示获取成功，但没有多余资源可获取
- 返回`>0`，表示获取成功，且有剩余资源

#### tryReleaseShared()-释放共享资源

**共享方式**释放资源

- 释放资源后，允许唤醒后续等待节点，返回`true`
- 释放资源后，没有后续等待节点，返回`false`



子类主要实现上述几个方法，主要逻辑还是在`AQS`内部进行实现。



### 获取资源-独占模式

![AQS-独占模式-获取资源](/images/AQS-独占模式-获取资源.png)

获取资源的入口是`acquire(int arg)`。`arg`是要获取资源的个数

- `独占模式`：arg = 1
- `共享模式`：arg >= 0

```java
    public final void acquire(int arg) {
        if (!tryAcquire(arg) && //1⃣️
            acquireQueued( //2⃣️
              addWaiter(Node.EXCLUSIVE), arg) //3⃣️
            )
            selfInterrupt();
    }
```

#### tryAcquire(int arg)

子类实现的模板方法，在介绍`ReentrantLock`时会分析内部实现

#### addWaiter(Node.EXCLUSIVE)

只有在`tryAcquire()`获取资源失败时，才会执行到该方法，将当前线程初始化为一个`Node`节点，加入到`等待队列`中。其中`Node.EXCLUSIVE`表示当前锁是独占的。

```java
static final Node EXCLUSIVE = null;

//为当前线程创建指定模式的节点
   private Node addWaiter(Node mode) {
       //生成对应的Node节点
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            //采用尾插法
            node.prev = pred;
          //使用CAS尝试交换节点
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
     //等待队列为空，或者CAS交换失败，插入队列
        enq(node);
        return node;
    }

//插入数据到队列中
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;//初始化等待队列
            } else {
                node.prev = t;//新进节点放在队列尾部
                if (compareAndSetTail(t, node)) {//交换尾节点与插入节点
                    t.next = node;
                    return t;
                }
            }
        }
    }
```

这一步的操作是为了，在等待队列的尾部插入新`Node`节点，但是可能存在多个线程同时争夺资源的情况，因为在插入节点时需要做线程安全操作，这里就是通过`CAS`保证线程操作的安全性。

![AQS-独占模式-等待队列](/images/AQS-独占模式-等待队列.jpg)



1. 执行`tryAcquire()`失败后，将当前线程初始化为一个`Node`节点，加入到`AQS`等待队列中-调用`addWaiter()`
2. 第一次加入等待队列，此时尚未初始化完成，`head`，`tail`都为`null`
3. 就需要在执行`enq()`将等待队列初始化，并插入`Node`节点，**头节点为空线程**
4. 后续再有新的申请进来后，`Node`节点直接插入到等待队列的尾部

> 为什么头节点为空线程？
>
> 此处的头节点`head`起到了一个**哨兵**的作用，`免去后续查找过程中的越界判断`。

#### acquireQueued(node,arg)

经过`addWaiter()`之后，线程加入到等待队列中，但是线程还没有被挂起等待，而`acquireQueued()`去执行线程挂起的相关操作。

```java
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();//获取前一个节点
              //前一个节点是 head，再尝试获取一次锁  
              if (p == head && tryAcquire(arg)) {
                    setHead(node);//获取资源后，设置当前节点为头节点
                    p.next = null; // 原先头节点置为null，移出等待队列
                    failed = false;
                    return interrupted;
                }
              //获取锁失败了，就将自己挂起进入`waiting`状态，直到`unpark`调用
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

若前一个节点是`head`，那么再次调用`tryAcquire()`去竞争锁；竞争失败了，就执行`shouldParkAfterFailedAcquire()`判断是否将自己的线程挂起

```java
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;//前一个节点的状态
        if (ws == Node.SIGNAL)//前一个节点处于 阻塞挂起状态，当前线程可以挂起
            return true;
        if (ws > 0) {//前一个节点处于取消状态
            do {
                node.prev = pred = pred.prev;//移出已被取消的节点
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {//前一个节点处于 初始化或者 PRPPAGATE，当前需要一个信号才能将当前线程挂起。
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
```

> 线程能否挂起的判断条件：
>
> **前一个节点的`waitStatus`必须是`SIGNAL(-1)`，因为后面`unlock()`会去唤醒`waitStatus`为`SIGNAL`的线程去争夺锁。**

若`shouldParkAfterFailedAcquire()`判断需要将当前线程挂起，则继续执行`parkAndCheckInterrupt()`挂起当前线程。

```java
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);//当前线程被挂起
        return Thread.interrupted();//返回中断标记并对当前线程进行复位
    }
```

`parkAndCheckInterrupt()`内部调用到了`LockSupport.park()`，该方法主要用于中断一个线程。

> `LockSupport`是`Java 6`后引入的一个类，提供了基本的`线程同步原语`。
>
> 内部实际调用了`Unsafe`的函数。
>
> 主要提供了两个方法：
>
> - `park()`：阻塞当前线程
> - `unpark(thread)`：使`thread`停止阻塞

在后续新增的节点进入`AQS等待队列`后，是通过`LockSupport.park()`使线程进入阻塞状态。

`LockSupport.park()`遇到以下情况时，会立即中断阻塞状态

- 其他线程调用了`unpark()`停止了当前线程的阻塞状态
- 其他线程中断了当前线程

```java
    public static void main(String[] args) throws InterruptedException{
        Thread t1 = new Thread(()->{
            LockSupport.park();
            System.err.println("当前park无效 "+Thread.currentThread().isInterrupted());
            LockSupport.park();
            System.err.println("park无效");
           
        },"t1");
        t1.start();
        Thread.sleep(1000);
        t1.interrupt();
    }

输出结果：
  当前park无效 true
  park无效
```

结合以上代码的运行结果可知以下几点：

- 当一个线程`park()`时，其他线程中断该线程时，线程会立即恢复，且中断标记为`true`还不会抛出`InterruptedException`异常
- 当一个线程的中断标记为`true`时，调用`park()`无法挂起线程

所以这就是为什么`parkAndCheckInterrupt()`返回了`Thread.interrupted()`去重置中断标记。

> `interrupt()`：打一个中断标记，但不会中断当前线程
>
> `isInterrupted()`：返回当前线程的中断标记，如果执行过`interrupt()`则返回`true`，表示当前线程被中断过
>
> `interrupted()`：返回当前线程的中断标记，如果执行过`interrupt()`则返回`true`，表示当前线程被中断过。**但是多执行了一步复位操作，后续调用`isInterrupted()`返回`false`。**

若不执行`线程复位`操作，后续对当前线程执行`LockSupport.park()`时，挂起操作无法生效，就会导致发生死循环，耗尽资源。

![AQS-获取资源](/images/AQS-获取资源.jpg)

> 简单文字概述`AQS-获取资源过程`
>
> 1. 尝试获取资源——`tryAcquire()`
> 2. 获取资源失败，请求入队列——`addWaiter(Node.EXCLUSIVE)`
>    1. 根据传入的模式(`EXCUSIVE`)创造节点(`Node`)
>    2. 判断尾节点(`tail`)是否存在，不存在使用`enq(node)`初始化节点`head、tail`；存在`tail`，请求节点插入尾部
>    3. 使用`CAS自旋`插入请求到尾端，插入失败的话，调用`enq(node)`自旋插入直到成功
> 3. 请求入队列后，需要不断去获取资源——`acquireQueued(node)`
>    1. 不断获取当前节点的上一个节点是否为`head`，若是，则表示当前节点为`请求节点`
>    2. 若是`请求节点`，不断的调用`tryAcquire()`获取资源，获取成功执行`setHead()`
>    3. 若当前非`head`后的第一个`请求节点`或者`tryAcquire()`请求资源失败，需要通过`shouldParkAfterFailedAcquire()`判断当前节点是否需要阻塞(`判断前一个节点waitStatus == NODE.SIGNAL`)
>    4. 若需要阻塞则执行`parkAndCheckInterrupt()`实质执行`LockSupport.park()`

#### cancelAcquire()

`acquireQueued()`执行到`finally`时就会执行该方法

```java
private void cancelAcquire(Node node) {
        // Ignore if node doesn't exist
        if (node == null)
            return;

        node.thread = null;

        // 已被取消的节点都移出等待队列
        Node pred = node.prev;
        while (pred.waitStatus > 0)
            node.prev = pred = pred.prev;
        //找到有效节点的下一个节点
        Node predNext = pred.next;
        //设置当前节点为取消
        node.waitStatus = Node.CANCELLED;

        // If we are the tail, remove ourselves.
        if (node == tail && compareAndSetTail(node, pred)) {
            //当前为尾节点 直接移除
            compareAndSetNext(pred, predNext, null);
        } else {
            int ws;
            if (pred != head && //不是头节点
                ((ws = pred.waitStatus) == Node.SIGNAL || //处于SIGNAL状态
                 (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&//pred设置为SIGNAL状态成功
                pred.thread != null) { //并且有 等待线程
                Node next = node.next;
                if (next != null && next.waitStatus <= 0)
                    compareAndSetNext(pred, predNext, next);
            } else {
              //当前为头节点的下一个有效节点
                unparkSuccessor(node);
            }

            node.next = node; // help GC
        }
    }
```

//TODO 补齐流程分析

### 释放资源-独占模式

![AQS-独占模式-释放资源](/images/AQS-独占模式-释放资源.png)

释放资源的入口是`release(int arg)`，`arg`为释放资源的个数

```java
    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)//头节点不为空，且状态不为新建
                unparkSuccessor(h);//唤醒后续节点
            return true;
        }
        return false;
    }
```

#### tryRelease()

子类实现的模板方法，在介绍`ReentrantLock`时会分析内部实现

#### unparkSuccessor()

`tryRelease()`解锁成功后，执行该方法

```java
private void unparkSuccessor(Node node) {
       //获取当前节点的等待状态
        int ws = node.waitStatus;
        if (ws < 0)
          //小于0 ，则重置为0
            compareAndSetWaitStatus(node, ws, 0);

        Node s = node.next;
        if (s == null || s.waitStatus > 0) {//节点不存在或被取消
            s = null;
           //唤醒后续节点,如果还存在挂起的节点
            for (Node t = tail; t != null && t != node; t = t.prev)//等待队列从后往前遍历
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
          //取消对应线程的挂起状态
            LockSupport.unpark(s.thread);
    }
```

如果不存在后续节点或后续节点被取消，就会从`AQS等待队列`的末尾从后往前遍历，就是为了**避免找不到节点的情况**，有可能在构造节点时，尚未构造`next`的值，导致无法继续向后遍历，但是向前的话一开始节点构造时就会设置`prev`节点数据。

找到了需要被唤醒的节点(`waitStatus == SIGNAL(-1)`)后，执行`LockSupport.unpark()`唤醒节点对应线程。

#### acquireQueued()

上面的方法执行到`LockSupport.unpark()`后，就会唤醒对应的线程

```java
 private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);//当前线程被挂起
        return Thread.interrupted();//返回中断标记并对当前线程进行复位
    }

 final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();//获取前一个节点
              //前一个节点是 head，再尝试获取一次锁  
              if (p == head && tryAcquire(arg)) {
                    setHead(node);//获取资源后，设置当前节点为头节点
                    p.next = null; // 原先头节点置为null，移出等待队列
                    failed = false;
                    return interrupted;
                }
              //获取锁失败了，就将自己挂起进入`waiting`状态，直到`unpark`调用
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

此时`parkAndCheckInterrupt()`会继续执行，代码执行回到`acquireQueued()`的for循环中

此时资源已被释放，后续线程执行`tryAcquire()`就会获取资源成功，向下执行到`setHead()`并跳出了当前的循环

```java
    private void setHead(Node node) {
        head = node;
        node.thread = null;
        node.prev = null;
    }
```

`setHead()`重置了一下`head`节点的属性，将当前节点置为了`head`节点，原先的就移出队列，等待回收。

`return interrupted`继续回到上层方法`acquire()`中，中断掉当前线程，`release()`执行完毕。

![AQS-独占模式-释放资源](/images/AQS-独占模式-释放资源.jpg)

> 简单文字描述AQS-资源释放过程
>
> 1. 通过`tryRelease()`释放资源，返回`true`表示资源已经被释放了，通知其他节点可以获取资源
> 2. 释放成功后，执行`unparkSuccessor()`取消其他线程的阻塞状态
> 3. 通过`从后往前遍历(入队列采用尾插法)`直到找到一个`有效节点(waitStatus<=0)`，在执行`LockSupport.unpark()`取消对应节点`thread`的阻塞状态



### 获取资源-共享模式

![AQS-共享模式-获取资源](/images/AQS-共享模式-获取资源.png)

获取共享资源的入口是`acquireShared()/acquireSharedInterruptibly()`

```java
    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)
            doAcquireShared(arg);
    }

    public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
    }
```

其中`acquireShared()`和`acquireSharedInterruptibly()`的区别在于后者可以**响应中断**，请求线程被中断时，就会抛出异常结束请求。

#### tryAcquireShared()

子类实现的模板方法，在介绍`CountdownLatch`时会分析内部实现

#### doAcquireShared()

只有在`tryAcquireShared()`返回值小于0(`获取共享资源失败`)时执行，`tryAcquireShared()`有三种返回结果：

- `小于0`：获取共享资源失败
- `等于0`：获取共享资源成功，但后续节点无法获取共享资源
- `大于0`：获取共享资源成功，后续节点也可能继续获取共享资源。*需要检查后续节点请求的可用性*

```java
    private void doAcquireShared(int arg) {
        final Node node = addWaiter(Node.SHARED);//添加共享节点
        boolean failed = true;//判断是否需要取消节点
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();//获取前一个节点
                if (p == head) {
                    int r = tryAcquireShared(arg);//再次尝试获取共享资源
                    if (r >= 0) {//请求共享资源成功
                        //设置当前节点为头节点，并尝试唤醒后续节点
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                //是否需要阻塞当前节点请求
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

获取共享资源失败后，先调用`addWaiter(Node.SHARED)`添加共享节点到等待队列，在循环中不断判断`preNode == head`，如果符合继续尝试获取共享资源，若获取成功，执行`setHeadAndPropagate()`去设置头节点并唤醒后续节点；获取失败，则当前线程判断是否需要挂起(`preNode.waitStatus == Node.SIGNAL(-1)`)，需要挂起执行`LockSupport.park()`。

#### setHeadAndPropagate()

获取到共享资源后调用该方法，主要的作用是`设置当前节点为头节点，同时唤醒后续节点`

```java
    private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head; // Record old head for check below
        setHead(node);//设置头节点
        
        if (propagate > 0 //后续节点可以获取资源
            || h == null || h.waitStatus < 0 ||
            (h = head) == null || h.waitStatus < 0) { //后续的节点可以被唤醒
            Node s = node.next;
            if (s == null || s.isShared())//后续节点为共享状态
                doReleaseShared();//释放共享资源
        }
    }
```

`propagate > 0`是`tryAcquireShared()`的返回值，`>0`表示后续节点可以继续获取资源

`waitStatus < 0`此时存在两种情况

- `waitStatus == SIGNAL(-1)`下一个节点可以被唤醒
- `waitStatus == PROPAGATE(-3)`继续传播状态



#### doReleaseShared()

获取共享资源后且`tryAcquireShared()> 0 `表示后续节点也可以获取资源，并且`waitStatus < 0 即 -1`可以唤醒后续等待的线程

```java
    private void doReleaseShared() {
        for (;;) {
            Node h = head;
            //等待队列已初始化
            if (h != null && h != tail) {//队列至少存在了2个节点
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {//后续线程可以被唤醒
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    unparkSuccessor(h);//唤醒后续节点
                }
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))//当前节点为最后一个节点，将唤醒状态继续向下传播
                    continue;                // loop on failed CAS
            }
            //头节点没有发生变化，直接结束当前循环
            if (h == head)                   // loop if head changed
                break;
        }
    }
```

在等待队列存在后续线程的情况下，继续唤醒后续线程(`unparkSuccessor()`)。或者由于多个线程同时释放，导致`head.waitStatus==0`，需要设置`waitStatus`为`PROPAGATE`将唤醒状态继续向下传递，保证后续其他线程执行`setHeadAndPropagate()`时可以继续释放等待线程。

![AQS-获取共享锁](/images/AQS-获取共享锁.jpg)

> 简单文字描述AQS-获取共享资源
>
> 1. 通过`tryAcquireShared()`尝试获取资源
> 2. 若`tryAcquireShared()`返回值`<0`表示获取资源失败，向下继续调用`doAcquireShared()`
> 3. 请求入队列执行`addWaiter(Node.SHARED)`，操作步骤同`AQS获取资源过程`
> 4. 请求入队列后，需要不断去获取资源
>    1. 不断获取当前节点的上一个节点是否为`head`，若是，则表示当前节点为`请求节点`
>    2. 若是`请求节点`，不断调用`tryAcquireShared()`继续获取共享资源
>       - 获取成功，执行`setHeadAndPropagate()`去设置头节点，并且唤醒后续节点——`doReleaseShared()`
>       - 获取失败，执行`LockSupport.unpark()`挂起当前线程



### 释放资源-共享模式

![AQS-共享模式-释放资源](/images/AQS-共享模式-释放资源.png)

释放共享资源的入口是`releaseShared()`

```java
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
```

#### tryReleaseShared()

子类实现的模板方法，在介绍`CountdownLatch`时会分析内部实现

#### doReleaseShared()

参考 [doReleaseShared](#doReleaseShared)

### Condition

{%post_link Java-AQS-Condition原理及解析%}

## 总结

1. AQS到底是什么？

   > `AQS`内部维护一个`CLH队列(FIFO)`来管理锁，将`当前线程(thread)以及等待状态信息(waitStatus)`封装成一个`Node节点`添加到`等待队列`中。
   >
   > 提供了`tryAcquire(),tryRelease(),tryAcquireShared(),tryReleaseShare()`等模板方法交由子类实现，去控制`资源的获取与释放`。
   >
   > `AQS`默认实现子类获取/释放资源后的操作，包括`Node节点的出入队列`。

2. AQS获取资源失败的操作

   > 线程尝试获取锁失败后，，将`当前线程(thread)以及等待状态信息(waitStatus)`封装成一个`Node节点`添加到`等待队列`中。接着会不断循环尝试获取锁(`前置节点为head`)，如果不是进入阻塞状态，直至被唤醒。

3. AQS等待队列数据结构

   > `CLH队列`：
   >
   > - CLH锁是一个自旋锁，可以保证无饥饿性，提供`FIFO`的公平性。基于链表实现。
   > - 不断轮询`前置节点`的状态，如果前置节点被释放就结束自旋。
   
4. AQS等待队列插入节点顺序

   > **尾插法**
   >
   > `addWaiter(node)`就是插入节点的主方法
   >
   > ```java
   >     private Node addWaiter(Node mode) {
   >         Node node = new Node(Thread.currentThread(), mode);
   >         // Try the fast path of enq; backup to full enq on failure
   >         Node pred = tail;
   >         if (pred != null) {
   >             node.prev = pred;//node.prev = tail
   >             if (compareAndSetTail(pred, node)) { //tail = node 大致如此
   >                 pred.next = node;
   >                 return node;
   >             }
   >         }
   >         enq(node);
   >         return node;
   >     }
   > ```
   >
   > 先执行的是`node.prev = pred(实际为tail)`，然后再是CAS操作，这是由于**CAS在执行过程中可能存在一瞬间的需要替换的值为null**，会使得一瞬间的队列数据不一致。

## 参考链接

[JUC必知ReentrantLock和AQS同步队列实现原理分析](https://juejin.im/post/6878135436561088520#heading-28)

[AbstractQueuedSynchronizer源码解读](https://www.cnblogs.com/micrari/p/6937995.html)

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-ReentrantLock原理及解析</title>
    <url>/2018/12/19/Java-ReentrantLock%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[




一般的锁都是配合`synchronized`使用的，实际上在`java.util.concurrent.locks`还提供了其他几个锁的实现，拥有更加强大的功能和更好的性能。

## 锁的分类

### 可重入锁

> `可重入锁`：任意线程在获取该锁后能够再次获取锁时不会被阻塞。
>
> **当前线程恶可以反复加锁，但必须释放同样多次数的锁，否则会导致锁不会释放。可以避免`死锁`**

#### 原理

通过组合自定义同步器(`AQS`)实现锁的获取与释放

- 再次进行`lock()`，需要判断当前是否为已获得锁的线程，如果是，计数+1
- 执行`unlock()`，计数-1

在释放锁后，如果计数不为0，就会导致程序卡死。

#### 分类

- `synchronized`修饰的方法或代码块
- `ReentrantLock`

### 公平锁与非公平锁

#### 公平锁

**多个线程按照申请锁的先后顺序获取锁**。内部持有一个等待队列，按照`FIFO`取出线程获取锁。

实现：`ReentrantLock(true)`

#### 非公平锁

**多个线程不是按照申请锁的先后顺序去获取锁。**

`非公平锁`的性能高于`公平锁`，但是可能发生**线程饥饿(某个线程长时间无法获得锁)**。

实现：`synchronized`和`ReentrantLock(false)默认非公平`

### 读写锁和排他锁

#### 读写锁

**同一时刻允许多个读线程访问。**分为了**读锁**和**写锁**，`读锁`允许多个线程获取读锁，访问同一个资源；`写锁`只允许一个线程获取写锁，不允许同时访问同一资源。

**在读多写少的情况下，大大提高了性能。**

> 即使用读写锁，在写线程访问时，所有读线程和其他写线程都会被阻塞。

实现：`ReentrantReadWhiteLock`

#### 排他锁

**同一时刻只允许一个线程访问**。

实现：`ReentrantLock`、`synchronized`



### 死锁

> 两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，他们都将无法推进下去。

死锁形成必须要求四个条件：

- **互斥条件**：一个资源每次只能被一个线程使用

- **请求与保持条件**：一个线程引请求资源而阻塞时，对已获得的资源保持不放
- **不剥夺条件**：线程已获得的资源，在未使用完之前，不能强行剥夺
- **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系



## Lock接口

>  在Java中锁是用来控制多个线程访问共享资源的方式。在Java SE5.0之后新增Lock接口。提供了与`synchronized`关键字类似的同步功能，只是在使用时需要显式的获取和释放锁，缺点就是无法像`synchronized`可以隐式的释放锁，但是可以自由操作获取锁和释放锁。

### `synchronized`的不足之处

- 如果只是只读操作，应该多线程一起执行会更好，但是`synchronized`在**同一时间只能一个线程执行**。
- `synchronized`无法知道线程是否获取锁，而且无法主动进行释放锁
- 使用`synchronized`获取锁后，如果发生阻塞，就会导致所有线程等待锁释放

### 提供方法

#### `lock()`-获取锁

> 执行时，如果锁处于空闲状态，当前线程获得锁。如果锁已被其他线程持有，将禁用当前线程，直到该线程获取锁。
>
> **不会响应中断，直到获取锁成功才会进行响应。**

#### `lockInterruptibly()`-获取锁，响应中断

> **获取锁时，优先响应中断，而不是先去进行获取。**

#### `tryLock()`-非阻塞获取锁

> 非阻塞获取锁，立即返回获取锁结果，`true`-成功，`false`-失败

#### `tryLock(time,unit)`-指定时间获取锁

> 指定时间获取锁，会响应中断
>
> - `time`内获取锁立即返回`true`
> - `time`内线程中断会立即返回获取锁结果
> - `time`时间结束后，立即返回获取锁结果

#### `unlock()`-释放锁

> 当前线程释放持有锁，**锁只能由持有者释放，如果并未持有锁，执行解锁方法，就会抛出异常**。

#### `newCondition()`-获取锁条件

> 返回该锁的`Condition`实例，实现**多线程通信**。该组件会与当前锁绑定，当前线程只有获取了锁，才能调用组件的`await()`方法，调用后，线程释放锁。





## ReentrantLock

> 一个可重入的互斥锁，具备一样的线程重入特性







#### 特性

- 尝试获得锁
- 获取到锁的线程能够响应中断

## 读写锁

> ReentrantLock是完全互斥排他的，这样其实效率不高

## 使用方式

```java
public class ReenTrantLockTest implements Runnable {
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void test() {
        try {
            //获得同步锁
            lock.lock();
            System.err.println("获取锁" + System.currentTimeMillis());
            condition.await();
            System.err.println();
        } catch (
                InterruptedException e) {
            e.printStackTrace();
        } finally {
            //释放同步锁
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ReenTrantLockTest test = new ReenTrantLockTest();
        Thread t1 = new Thread(test);
        Thread t2 = new Thread(test);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.err.println("结束");
    }

    @Override
    public void run() {
        test();
    }
}
```

相比`synchronized`增加了一些高级功能：

- **等待可中断**：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，去操作其他事情。

- **公平锁**：`多个线程在等待同一个锁时，必须按照申请锁的时间来依次获得锁。` `synchronized`是非公平锁，即`在锁被释放时，任何一个等待锁的线程都有机会获得锁。`这样就有可能会产生 **饥饿现象(有些线程可能永远无法获得锁)**。`ReenTrantLock`默认非公平锁，在构造时修改参数即可变为公平锁。

  ```java
  public class LockFairTest implements Runnable {
      //true为公平锁  false为非公平锁 默认false
      private static Lock lock = new ReentrantLock(true);
      AtomicInteger iii = new AtomicInteger(0);
  
      @Override
      public void run() {
          while (iii.get() < 20) {
              lock.lock();
              iii.getAndIncrement();
              try {
                  System.err.println(Thread.currentThread().getName() + "获得锁");
              } finally {
                  lock.unlock();
              }
          }
      }
  
      public static void main(String[] args) {
          LockFairTest test = new LockFairTest();
  
          Thread t1 = new Thread(test);
          Thread t2 = new Thread(test);
          Thread t3 = new Thread(test);
          Thread t4 = new Thread(test);
  
          t1.start();
          t2.start();
          t3.start();
          t4.start();
      }
  }
  输出结果：
  公平锁：
  Thread-0获得锁
  Thread-1获得锁
  Thread-2获得锁
  Thread-3获得锁
  非公平锁：
  Thread-2获得锁
  Thread-2获得锁
  Thread-2获得锁
  Thread-2获得锁
  ```

- **锁绑定多个条件**：一个`ReenTrantLock`对象可以通过多次调用`newCondition()`同时绑定多个`Condition`对象。在`synchronized`只能实现一个隐含的条件，要多关联只能额外添加锁。

## 总结

- Lock类可以实现线程同步，获得锁需要执行`lock`，释放锁使用`unlock`
- Lock分为公平锁(按照顺序)和不公平锁(不按顺序)
- Lock还有读锁和写锁。**读读共享，写写互斥，读写互斥**。

## 自定义重入锁

```java
public class CustomReetrantLock {
    boolean isLocked = false;
    Thread lockedBy = null;
    int lockedCount = 0;

    public synchronized void lock() throws InterruptedException {
        Thread callThread = Thread.currentThread();
        while (isLocked && lockedBy != Thread.currentThread()) {
            wait();
        }
        isLocked = true;
        lockedCount++;
        lockedBy = callThread;
    }

    public synchronized void unLock() {
        if (Thread.currentThread() == this.lockedBy) {
            lockedCount--;
            if (lockedCount == 0) {
                isLocked = false;
                notify();
            }
        }
    }
}

```

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-线程池</title>
    <url>/2019/09/13/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[


![Java线程池](/images/Java-线程池mind.png)

### 基础概念

- **线程**：进程中负责执行的执行单元，一个进程中至少有一个线程,**操作系统能够进行调度的最小单位**
- **进程**：一个执行中的程序的实例
- **多线程**：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU确定，因此多线程具有不确定性
- **线程池**： 基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象回归池中，避免反复创建线程对象所带来的性能开销，节省系统资源。

###  线程池的概念

在执行一个异步任务或并发任务时，往往会通过`new Thread()`方法去开启一个子线程去执行任务，等到子线程操作完成后在利用`Handler`切换至主线程。但是利用这种方法我们无法对自己创建的子线程进行有效的管理，然后由于过多的创建子线程，他们之间相互竞争会导致资源的过度占用。线程池的出现就是为了来对子线程进行管理。

### 为什么要使用线程池

- **降低资源消耗。**通过重复利用已创建的线程降低线程创建和销毁造成的消耗
- **提高响应速度。**当任务到达时，任务可以不需要等到线程创建就可以立即执行
- **提高线程的可管理性。**线程是稀缺资源，大量创建会导致系统资源过度消耗且会降低系统的稳定性，线程池可以有效控制线程数，并进行统一的分配、调优和监控。

###  线程池的构造参数与对象成员变量

![线程池构造参数](/images/Java-线程池构造参数.png)

`Executors`提供了基础的四类线程池方法，最终都是通过`ThreadPoolExecutor`类完成。对于这个类的描述`他维护了一个线程池，对于提交Executor中的任务，不是创建新的线程而是使用池内的线程来执行任务。可以显著减少对于任务执行的开销。`

1. ThreadPoolExecutor构造函数介绍

   ```java
   public ThreadPoolExecutor(int corePoolSize,
                                 int maximumPoolSize,
                                 long keepAliveTime,
                                 TimeUnit unit,
                                 BlockingQueue<Runnable> workQueue,
                                 ThreadFactory threadFactory,
                                 RejectedExecutionHandler handler)
   ```

   参数介绍：

   - **`corePoolSize 核心线程数`** 表示线程池中的基本线程数量即核心线程数量。一般情况下核心线程会一直存活在线程池中，即便他们处于闲置状态。只有在`ThreadPoolExecutor的allowCoreThreadTimeOut设置为true`的时候，会有一个超时策略（超过设置好的超时时间，闲置的核心线程会被终止）。**当创建的线程数小于corePoolSize时，不管有没有空闲线程都会创建新的线程**。

   - **`maximumPoolSize 最大线程数`**  表示线程池中允许的最大创建线程数，当活动的线程数达到数值后，后续新任务会被阻塞。**使用有界队列时，未达到该值则会创建新的线程，使用无界队列时该值无效。**

   - **`keepAliveTime 非核心线程闲置时的超时时长`** 表示空闲非核心线程的最大存活时间，一旦超过即被销毁。**当`ThreadPoolExecutor的allowCoreThreadTimeOut设置为true`的时候，该参数也可作用于核心线程**

   - **`unit 存活时间的时间单位`** 用于指定keepAliveTime参数的时间单位，为一个枚举类型。包含下列参数：`NANOSECONDS（纳秒）`,`MICROSECONDS（微秒）`,`MILLSECONDS（毫秒）`,`SECONDS（）秒`,`MINUTES（分）`,`HOURS（时）`,`DAYS（天）`

   - **`workQueue 线程池中的任务队列`** 该队列是`java.util.BlockingQueue<E>`的一个实例，是一种阻塞队列用来存放等待执行的任务。通过`execute()`方法将提交的Runnable对象存储进去。根据具体实现类的不同可以分为以下三种队列策略：

     - `容量为0即直接提交策略--SynchronousQueue`：等待队列容量为0 ，所有需要阻塞的任务必须等待池内的某个线程有空闲才可以继续执行，否则阻塞。`CachedThreadPool`使用该队列策略。
     - `容量无限即无界队列策略--LinkedBlockingQueue`：等待队列的长度无穷大，在这种策略下不会出现多余corePoolSize的线程被创建，所以maximumPoolSize以及handler无效，因为不存在队列满的情况。不过也有缺点：**线程的执行速度会比提交速度慢，会导致无界队列快速增长，直到系统资源耗尽。**`fixedThreadPool`采用了这种队列策略。
     - `容量有限即有界队列策略--指定了容量的任何BlockingQueue`：等待队列的长度为限制长度，指定了容量后可以**防止过多的资源被消耗**。 

   - **`threadFactory 线程工厂`**：是一个接口可以为线程池提供新线程的创建。由同一个threadFactory创建的线程同属于一个ThreadGroup，优先级都为Thread.NORM_PRIORITY，以及为非进程守护状态。默认都是采用`Executors.defaultThreadFactory()`返回值。

   - **`handler 拒绝策略`**：当**使用有界队列时且队列任务被填满后并且线程数也达到了最大值，就会触发拒绝策略**。如果任务被拒绝执行，则会调用`RejectedExecutionHandler.rejectedExecution()`方法，默认调用`AbortPolicy`拒绝策略，也可以由用户自定义。JDK中定义了4种拒绝策略：

     - `AbortPolicy`**处理程序遭到拒绝则直接抛出`RejectedExecutionException`异常然后丢弃该任务。**

       实现源码：

       ```java
        public static class AbortPolicy implements RejectedExecutionHandler {
               /**
                * Creates an {@code AbortPolicy}.
                */
               public AbortPolicy() { }
               public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                   throw new RejectedExecutionException("Task " + r.toString() +
                                                        " rejected from " +
                                                        e.toString());
               }
           }
       ```

       样例演示：

       ```java
        static class TestRunnable implements Runnable {
               private int id;
       
               TestRunnable(int id) {
                   this.id = id;
               }
       
               @Override
               public void run() {
                   System.err.println(Thread.currentThread().getName()+" 当前线程id="+ this.id);
                   try {
                       Thread.sleep(1000);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }
       
       public static void abortPolicyDemo() {
               ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                       1, 1, 60, TimeUnit.SECONDS,
                       new ArrayBlockingQueue<Runnable>(1), new ThreadPoolExecutor.AbortPolicy());
       
               threadPoolExecutor.submit(new TestRunnable(1));
               threadPoolExecutor.submit(new TestRunnable(2));
               threadPoolExecutor.submit(new TestRunnable(3));
               threadPoolExecutor.shutdown();
           }
       
       运行结果：添加进程时直接抛出异常但是没有影响后续的进行
       pool-1-thread-1 当前线程id=1
       Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@4b1210ee rejected from java.util.concurrent.ThreadPoolExecutor@4d7e1886[Running, pool size = 1, active threads = 1, queued tasks = 1, completed tasks = 0]
           at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)
           at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)
           at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)
           at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)
           at threadpool.ThreadPoolDemo.abortPolicyDemo(ThreadPoolDemo.java:140)
           at threadpool.ThreadPoolDemo.main(ThreadPoolDemo.java:13)
       pool-1-thread-1 当前线程id=2
       ```

     - `CallerRunsPolicy`**在调用`execute`方法的调用者所在线程来执行被拒绝的任务，提供简单的反馈控制机制，可以减缓新任务的提交速度。**

       实现源码：

       ```java
       public static class CallerRunsPolicy implements RejectedExecutionHandler {
               /**
                * Creates a {@code CallerRunsPolicy}.
                */
               public CallerRunsPolicy() { }
               public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                   if (!e.isShutdown()) {
                       r.run();
                   }
               }
           }
       ```

       样例演示：

       ```java
         public static void callerRunsPolicyDemo(){
               ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                       1, 1, 60, TimeUnit.SECONDS,
                       new ArrayBlockingQueue<Runnable>(1), new ThreadPoolExecutor.CallerRunsPolicy());
       
               threadPoolExecutor.submit(new TestRunnable(1));
               threadPoolExecutor.submit(new TestRunnable(2));
               threadPoolExecutor.submit(new TestRunnable(3));
               threadPoolExecutor.shutdown();
           }
       
       运行结果：task2执行在了主线程，由于被拒绝执行所以在调用者线程执行了任务
       pool-1-thread-1 当前线程id=1
       main 当前线程id=3
       pool-1-thread-1 当前线程id=2
       ```

     - `DiscardPolicy`**被拒绝即无法执行的任务被直接删除**

       实现源码：   

       ```java
       public static class DiscardPolicy implements RejectedExecutionHandler {
                     /**
                      * Creates a {@code DiscardPolicy}.
                      */
                     public DiscardPolicy() { }
                     public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                     }
                 }
       ```

       样例演示：

       ```java
           public static void discardPolicyDemo(){
               ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                       1, 1, 60, TimeUnit.SECONDS,
                       new ArrayBlockingQueue<Runnable>(1), new ThreadPoolExecutor.DiscardPolicy());
       
               threadPoolExecutor.submit(new TestRunnable(1));
               threadPoolExecutor.submit(new TestRunnable(2));
               threadPoolExecutor.submit(new TestRunnable(3));
               threadPoolExecutor.shutdown();
           }
       
       运行结果：由于被拒绝执行在该策略下被直接抛弃
       pool-1-thread-1 当前线程id=1
       pool-1-thread-1 当前线程id=2
       ```

     - `DiscardOldestPolicy`**判断线程池是否被关闭，没有则丢弃最老的一个请求，再尝试提交当前任务。**

       实现源码：

       ```java
        public static class DiscardOldestPolicy implements RejectedExecutionHandler {
                     /**
                      * Creates a {@code DiscardOldestPolicy} for the given executor.
                      */
                     public DiscardOldestPolicy() { }
                     public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
                         if (!e.isShutdown()) {
                             e.getQueue().poll();
                             e.execute(r);
                         }
                     }
                 }
       ```

       样例演示：

       ```java
           public static void discardOldestPolicyDemo(){
               ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                       1, 1, 60, TimeUnit.SECONDS,
                       new ArrayBlockingQueue<Runnable>(1), new ThreadPoolExecutor.DiscardOldestPolicy());
       
               threadPoolExecutor.submit(new TestRunnable(1));
               threadPoolExecutor.submit(new TestRunnable(2));
               threadPoolExecutor.submit(new TestRunnable(3));
               threadPoolExecutor.submit(new TestRunnable(4));
               threadPoolExecutor.shutdown();
           }
       
       运行结果：???
       pool-1-thread-1 当前线程id=1
       pool-1-thread-1 当前线程id=4
       ```

     - `CustomRejectPolicy 自定义拒绝策略`**可以用来记录运行日志或者记录无法处理的任务**

       样例演示：

       ```java
       /**
       * 自定义拒绝策略，实现RejectedExecutionHandler接口即可
       */
       static class CustomRejectedPolicy implements RejectedExecutionHandler{
               @Override
               public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                   if (!executor.isShutdown()){
                           System.err.println("自定义异常日志记录:  "+  r.toString());
                   }
               }
           }
       
       public static void customPolicyDemo(){
               ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                       1, 1, 60, TimeUnit.SECONDS,
                       new ArrayBlockingQueue<Runnable>(2), new CustomRejectedPolicy());
       
           //使用execute是因为使用submit时会被封装成RunnableFuture对象
               threadPoolExecutor.execute(new TestRunnable(1));
               threadPoolExecutor.execute(new TestRunnable(2));
               threadPoolExecutor.execute(new TestRunnable(3));
               threadPoolExecutor.execute(new TestRunnable(4));
       
               threadPoolExecutor.shutdown();
           }
       
       运行结果：由于4号被拒绝，记录日志
       自定义异常日志记录:  java.util.concurrent.FutureTask@4b1210ee
       pool-1-thread-1 当前线程id=1
       pool-1-thread-1 当前线程id=2
       pool-1-thread-1 当前线程id=3
       ```

     - 额外参数扩展 `allowCoreThreadTimeOut 允许核心线程过期 `默认值为false（线程池已不被使用，但是其中还有活着的线程，则该线程池无法被回收，会造成内存泄露）。所以用户可以显式调用`shutDown()`或者该值设置为true，则会被回收。

2. ThreadPoolExecutor的使用

   向线程池提交一个任务的方式有两种：

   - `execute`：这种方法提交任务，是没有返回值的即无法判断在线程池中是否完成该任务

     ```java
      threadPoolExecutor.execute(new TestRunnable(1));
     ```

   - `submit`：使用`submit`方法提交任务时，会返回一个future，可以通过这个future来判断任务是否执行成功也可以根据`future的get()`方法获取返回值。**若子线程任务没完成，`get()`方法会阻塞直到任务完成，若使用`get(long timeout,TimeUnit unit)`则会阻塞一段时间后返回，可能尚未完成任务。**

     ```java
      Future<Integer> future = fixedThreadPool.submit(new Callable<Integer>() {
     
                     @Override
                     public Integer call() throws Exception {
                         System.err.println(Thread.currentThread().getName() + " , index = " + index);
                         return 2;
                     }
                 });
     
                 try {
                     System.err.println("Future return :" + future.get().toString());
                 } catch (Exception e) {
                     e.printStackTrace();
                 }
     ```

3. 线程池的关闭

   线程池关闭方法有两种：

   - `shutdown()`：将线程池的状态置为SHUTDOWN状态，然后中断没有正在执行的线程。

     ```java
     public void shutdown() {
             final ReentrantLock mainLock = this.mainLock;
             mainLock.lock();
             try {
                 checkShutdownAccess();
                 advanceRunState(SHUTDOWN);
                 interruptIdleWorkers();
                 onShutdown(); // hook for ScheduledThreadPoolExecutor
             } finally {
                 mainLock.unlock();
             }
             tryTerminate();
         }
     ```

   - `shutdownNow()`：将线程池的状态设为STOP状态，中断所有任务包括执行中的线程，并返回等待执行的任务列表。

     ```java
     public List<Runnable> shutdownNow() {
             List<Runnable> tasks;
             final ReentrantLock mainLock = this.mainLock;
             mainLock.lock();
             try {
                 checkShutdownAccess();
                 advanceRunState(STOP);
                 interruptWorkers();
                 tasks = drainQueue();
             } finally {
                 mainLock.unlock();
             }
             tryTerminate();
             return tasks;
         }
     ```

     中断线程需要采用`interrput`方法，**无法响应中断的任务可能永远无法终止。**

     当需要立即中断所有线程并且不在乎任务是否执行完成时，可以使用`shutdownNow`方法。

4. 线程池的拓展

   `ThreadPoolExecutor`默认提供三个空方法，可以通过重写这三个方法来监控线程池。

   ```java
   //任务执行前 记录任务开始前时间
   protected void beforeExecute(Thread t, Runnable r) { }
   //任务执行后 记录任务结束时间
   protected void afterExecute(Runnable r, Throwable t) { }
   //线程池关闭 记录线程池关闭事件以及执行过的线程数量
   protected void terminated() { }
   ```

   样例演示：

   ```java
   class CustomThreadPoolExecutor extends ThreadPoolExecutor{
   
           public CustomThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
               super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
           }
   
           @Override
           protected void beforeExecute(Thread t, Runnable r) {
               super.beforeExecute(t, r);
               System.err.println("beforeExecute"+r.toString());
           }
   
           @Override
           protected void afterExecute(Runnable r, Throwable t) {
               super.afterExecute(r, t);
               System.err.println("afterExecute"+r.toString());
           }
   
           @Override
           protected void terminated() {
               super.terminated();
               System.err.println("线程关闭");
           }
       }
   ```

###  线程池的分类以及各自的特性

![Java-常见线程池](/images/Java-常见线程池.png)

利用`Executors`类提供了四种不同的线程池，他们都是直接或者间接配置`ThreadPoolExecutor`来实现功能。下面分别介绍着四个线程池

####  `newFixedThreadPool` 

> 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就不会发生变化，如果某个线程因为异常而结束，则会补充一个新进程。
>
> 由于只设置核心线程大小，所以可以**更快的响应外界请求**
>
> 线程池的大小设置，可以使用`Runtime.getRuntime().availableProcessors()`

- 实现源码

  ```java
  /**
  * 设置了核心线程，并且没有超时机制，使用LinkedBlockingQueue则任务队列大小是无上限的
  */
  public static ExecutorService newFixedThreadPool(int nThreads) {
          return new ThreadPoolExecutor(nThreads, nThreads,
                                        0L, TimeUnit.MILLISECONDS,
                                        new LinkedBlockingQueue<Runnable>());
      }
  ```

- 样例演示

  ```java
  public static void fixedThreadPoolDemo(){
          ExecutorService fixedThreadPool= Executors.newFixedThreadPool(3);
          for (int i = 0; i <6 ; i++) {
              final int index=i;
              fixedThreadPool.execute(new Runnable() {
                  @Override
                  public void run() {
                      System.err.println(Thread.currentThread().getName()+" , index = "+index);
                  }
              });
  
              try{
                  Thread.sleep(1000);
              }catch(Exception e){
                  e.printStackTrace();
              }
          }
      }
  
  运行结果：整个过程都在pool-1的线程池中运行,然后复用线程
  pool-1-thread-1 , index = 0
  pool-1-thread-2 , index = 1
  pool-1-thread-3 , index = 2
  pool-1-thread-1 , index = 3
  pool-1-thread-2 , index = 4
  pool-1-thread-3 , index = 5
  ```

- 适用场景

  用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。

#### `newCachedThreadPool`

> 可根据需要创建新线程的线程池，但是在一起构造的线程可用时将重用他们。对于很多短期异步任务的程序而言，这类线程池可以提高性能。
>
> 如果现有线程没有可用的，则会创建一个新的线程并添加到池中，终止并从缓存中移除那些超过60s没有使用的线程。**因此，长时间保持空闲的newCachedThreadPool线程池是不存在任何线程的，所以这时候几乎不占用系统资源。**

- 实现源码

  ```java
  /**
  * 核心线程数为0 线程最大为Int的最大值所以可以认定为线程池最大线程无限大，设置了超时时间为60s。任务队列采用了阻塞队列(必须池内有空闲线程才可以执行)
  */
  public static ExecutorService newCachedThreadPool() {
          return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                        60L, TimeUnit.SECONDS,
                                        new SynchronousQueue<Runnable>());
      }
  ```

- 样例演示

  ```java
  public static void cachedThreadPoolDemo(){
          ExecutorService cachedThreadPool= Executors.newCachedThreadPool();
          for (int i = 0; i <6 ; i++) {
              final int index=i;
              cachedThreadPool.execute(new Runnable() {
                  @Override
                  public void run() {
                      System.err.println(Thread.currentThread().getName()+" , index = "+index);
                  }
              });
  
              try{
                  Thread.sleep(1000);
              }catch(Exception e){
                  e.printStackTrace();
              }
          }
      }
  
  运行结果：整个过程都在同一个线程pool-1-thread-1中执行，后面线程复用前面的线程
  pool-1-thread-1 , index = 0
  pool-1-thread-1 , index = 1
  pool-1-thread-1 , index = 2
  pool-1-thread-1 , index = 3
  pool-1-thread-1 , index = 4
  pool-1-thread-1 , index = 5
  ```

- 适用场景

  并发执行大量短期的小任务，或者负载较轻的服务器

####  `newScheduledThreadPool`

> 创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。

- 实现源码

  ```java
  public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
      return new ScheduledThreadPoolExecutor(corePoolSize);
  }
  /**
  * 核心线程数固定，非核心线程数为无限大，当非核心数处于闲置状态的时候会被立即回收
  */
  public ScheduledThreadPoolExecutor(int corePoolSize) {
      super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
            new DelayedWorkQueue());
  }
  ```

- 样例演示

  ```java
   public static void scheduleThreadPoolDemo() {
          ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);
       //延迟一定时间后执行Runnable任务
          scheduledThreadPool.schedule(new Runnable() {
              @Override
              public void run() {
                  System.err.println(Thread.currentThread().getName() + " delay 2s");
              }
          }, 2, TimeUnit.SECONDS);
       //延迟一定时间后执行Callable任务
          scheduledThreadPool.schedule(new Callable<Object>() {
              @Override
              public Object call() throws Exception {
                  return null;
              }
          }, 2, TimeUnit.SECONDS);
       //延迟一定时间（initialDelay）后,以(period)时间间隔执行任务
          scheduledThreadPool.scheduleAtFixedRate(new Runnable() {
              @Override
              public void run() {
                  System.err.println(Thread.currentThread().getName() + " every 3s");
              }
          }, 1, 1, TimeUnit.SECONDS);
       //延迟一定时间（initialDelay）后,以(delay即上一个任务执行结束到下一个任务开始的间隔)执行
          scheduledThreadPool.scheduleWithFixedDelay(new Runnable() {
              @Override
              public void run() {
                  System.err.println(Thread.currentThread().getName() + " delay 3s");
              }
          }, 1, 1, TimeUnit.SECONDS);
      }
  
  运行结果：
  pool-1-thread-1 every 3s
  pool-1-thread-2 delay 3s
  pool-1-thread-3 delay 3s 1
  pool-1-thread-2 every 3s
  ```

- 适用场景

  用于需要多个后台线程执行周期任务，同时需要限制线程数量

####  `newSingleThreadExecutor`

> 创建一个单线程池，该线程池中只有一个线程在工作，其他任务都会依次在任务中排列中等候依次执行，任务是串行执行的。此线程池保证所有的任务的执行顺序按照任务提交顺序执行(FIFO-先进先出)。

- 实现源码

  ```java
  /**
  * 只有一个核心线程，对任务队列没有大小限制，将所有外界任务统一到一个线程执行所有我们不需要处理线程同步的问题。
  */
  public static ExecutorService newSingleThreadExecutor() {
          return new FinalizableDelegatedExecutorService
              (new ThreadPoolExecutor(1, 1,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>()));
      }
  ```

- 样例演示

  ```java
   public static void singleThreadPoolDemo(){
          ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor();
          for (int i = 0; i < 6; i++) {
              final int index = i;
              singleThreadExecutor.execute(new Runnable() {
                  @Override
                  public void run() {
                      System.err.println(Thread.currentThread().getName() + " , index = " + index);
                  }
              });
  
              try {
                  Thread.sleep(1000);
              } catch (Exception e) {
                  e.printStackTrace();
              }
          }
      }
  
  运行结果：所有的任务都是在pool-1-thread-1中依次运行
  pool-1-thread-1 , index = 0
  pool-1-thread-1 , index = 1
  pool-1-thread-1 , index = 2
  pool-1-thread-1 , index = 3
  pool-1-thread-1 , index = 4
  pool-1-thread-1 , index = 5
  ```

- 适用场景

  用于串行执行任务的场景，每个任务需要顺序执行



|                                  | newCachedThreadPool                                         | newFixedThreadPool                                           | newSingleThreadExecutor                                     | newScheduledThreadPool                                       |
| -------------------------------- | ----------------------------------------------------------- | ------------------------------------------------------------ | ----------------------------------------------------------- | ------------------------------------------------------------ |
| corePoolSize/<br>maximumPoolSize | 0/Integer.MAX<br> `创建非核心线程`执行任务                  | n/n<br>`创建核心线程`执行任务                                | 1/1<br>`只创建1个核心线程`执行任务                          | n/Integer.MAX                                                |
| workQueue                        | SynchronousQueue                                            | LinkedBlockingQueue(Integer.MAX)                             | LinkedBlockingQueue(Integer.MAX)                            | DelayedQueue                                                 |
| keepAliveTime                    | 60s<br />即使没有任务进来，线程也会被很快回收               | 0ms<br />没有任务的情况下，线程会一直被阻塞等待任务          | 0ms<br />没有任务的情况下，线程会一直被阻塞等待任务         | 10s                                                          |
| 适用场景                         | 并发执行大量短期的小任务，或者负载较轻的服务器              | 用于负载较重的服务器，合理的利用服务器资源                   | 用于串行执行任务的场景，每个任务按照**先来先执行**的原则    | 用于执行后台周期性任务                                       |
| 缺点                             | 最大线程数为`Integer.MAX`，导致创建大量请求，消耗服务器资源 | 等待队列长度为`Integer.MAX`，导致大量请求堆积，消耗服务器资源 | 最大线程数为`Integer.MAX`，导致创建大量请求，消耗服务器资源 | 等待队列长度为`Integer.MAX`，导致大量请求堆积，消耗服务器资源 |



### 线程池的生命周期

> 线程池的生命周期是**伴随线程池的运行，由内部进行维护的**。
>
> 由两个值进行维护
>
> - `runState`：运行状态
> - `workerCount`：线程数量

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```

`ctl`结合两个关键参数，来保证运行状态的一致。

高三位：`runState`，低29位：`workerCount`，两个变量互相不干扰。

![图3 线程池生命周期](/images/582d1606d57ff99aa0e5f8fc59c7819329028.png)



| 运行状态                      | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| RUNNING(`线程池运行状态`)     | 可以接受新任务，并且也能处理阻塞队列的任务                   |
| SHUTDOWN(`线程池关闭状态`)    | 不再接受新的任务，但是依然可以处理阻塞队列的任务             |
| STOP(`线程池停止状态`)        | 不再处理阻塞队列的任务，并且中断正在进行的任务               |
| TIDYING(`线程池正在终止状态`) | 所有任务都已停止，`workerCount`为0                           |
| TERMINATED(`线程池终止状态`)  | 线程池已停止运行，所有工作线程都被销毁，所有任务都已被清空或执行完毕 |

源码内部提供了如下方法去获取当前线程池的状态

```java ThreadPoolExecutor.java
    private static int runStateOf(int c)     { return c & ~CAPACITY; } //运行状态
    private static int workerCountOf(int c)  { return c & CAPACITY; } //工作线程数量
    private static int ctlOf(int rs, int wc) { return rs | wc; } //当前runstate与workercount的和
```

![img](/images/640)



### 线程池的执行流程

![图2 ThreadPoolExecutor运行流程](/images/77441586f6b312a54264e3fcf5eebe2663494.png)

1. 判断`corePoolSize(核心线程数)`是否已到达，没到达则可以创建一个新线程执行任务
2. 判断`workQueue(工作队列)`是否已满，没满则添加入阻塞队列等待执行
3. 判断`maximumPoolSize(最大线程数)`是否已到达，没到达则创建一个新线程执行任务。
4.  已经达到了`maximumPoolSize(最大线程数)`或者线程池不处于`RUNNABLE`状态，执行`handler(任务拒绝策略)`

### 线程池实现原理

![Java线程池原理](/images/Java-线程池原理.png)

#### 添加任务

线程池通过调用`submit()`或`execute()`提交线程任务，其中`submit()`可以拿到线程执行结果，内部通过`execute()`实现。

```java
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        //1.当前工作线程 < 核心线程时
        if (workerCountOf(c) < corePoolSize) {
            //直接创建新的Worker执行任务
            if (addWorker(command, true))
                return;
            //重新获取运行状态
            c = ctl.get();
        }
        //2.线程池处于running状态，任务加入 工作队列
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            //线程不处于running状态，直接执行拒绝任务策略
            if (! isRunning(recheck) && remove(command))
                reject(command);
            //当无可用工作线程时，创建新的工作线程执行任务
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //无法添加任务，可能线程池被终止，或者最大线程已经满了
        else if (!addWorker(command, false))
            //执行拒绝策略
            reject(command);
    }
```

> 为什么执行`isRunning()`两次？
>
> 多线程环境下，线程池状态时刻发生变化，很可能刚获取的线程池状态突然就发生改变了。
>
> 万一线程池处于非`RUNNING`状态，那么任务永远不会执行。

添加任务都是通过`addWorker()`执行

```java
    private boolean addWorker(Runnable firstTask, boolean core/*是否核心线程*/) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 当线程池处于 STOP、TIDYING、TERMINATED状态时，无法添加新任务
            // 或者处于SHUTDOWN时，阻塞队列还有任务就需要继续执行完毕
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                //获取工作线程数量
                int wc = workerCountOf(c);
                //比较工作线程数量，若超出不予执行
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            //新建工作对象
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                  //启动新任务
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            //线程启动失败，移除worker
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

1. 线程池处于`RUNNABLE状态`或者`SHUTDOWN状态并且阻塞队列还有任务`，需要添加新线程执行任务
2. `Worker`封装了线程对象
3. 线程启动失败，则移除对应`Worker`

##### `Worker`

> 内部封装了`线程`对象，并且本身也是一个`Runnable`对象。

```java
   private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {

        /** Worker实际执行的线程 */
        final Thread thread;
        /** 初始化的任务，可以为null */
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;

        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker. */
        public void run() {
            runWorker(this);
        }
     
    ...
    }
```

`Worker`持有两个对象：

- `thread`：用来执行任务
- `firstTask`：保存传入的第一个任务，如果该值非空，则优先执行该任务。若为空，就需要创建一个工作线程去执行`workQueue`中的任务

`Worker`继承了`AQS`来实现`独占锁`功能，可以保证线程的执行状态是正确的。

获取独占锁，表示**当前线程正在执行中，任务不可以被中断**。

未获取独占锁，表示**当前线程没有处理任务，可以进行线程中断**。中断后就可以安全的进行线程回收。

#### 执行任务

`addWorker()`添加任务完毕后，就需要执行任务`runWorker()`

```java
final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
           //存在firstTask则先执行，否则从getTasks()获取阻塞队列的任务
            while (task != null || (task = getTask()) != null) {
                w.lock();
                //检测线程池状态
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                   //可重写该方法监听任务执行状态
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                      //执行任务
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                       //可重写该方法监听任务执行状态
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
          //线程池无任务可以执行
            processWorkerExit(w, completedAbruptly);
        }
    }
```

若`firstTask`不为null，则优先执行`firstTak`。`fistTask`未设置时，从`getTasks()`获取`workQueue`中的任务去执行。

```java
    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // 是否允许核心线程超时释放 或者 当前工作线程数大于核心线程
            boolean timed = allowCoreThreadTimedout || wc > corePoolSize;

            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : //等待 keepAliveTime 后释放线程
                    workQueue.take(); //使用take()获取任务，阻塞线程，直到拿到任务为止
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```

线程池里的线程从`workQueue阻塞队列`里拿任务，如果存在非核心线程且`workQueue`没有任务，非核心线程就会等到`keppAliveTime`时间后被释放。如果当前仅有核心线程存在时，设置了`allowCoreThreadTimedout(true)`，核心线程也会被释放。否则就会通过`take()`一致阻塞直到拿到任务为止。

核心线程不会被释放的原因：**通过`workQueue.take()`一直阻塞线程**。

<br>

核心线程与非核心线程的区别：

这两者之间并没有明显的标志区分，根据上面的代码可以发现，两者的区别在于**核心线程可以无限等待获取任务(阻塞队列take())，非核心线程要限时获取任务(keepAliveTime之内)**。核心线程其实指代的就是`0~corePoolSize`之间创建的线程，`corePoolSize~maximumPoolSie`表示的就是非核心线程。







![图7 Worker执行任务](/images/03268b9dc49bd30bb63064421bb036bf90315.png)

通过调用`execute(runnable)`传进去的`runnable`对象不是直接通过`new Thread(runnable).start()`的方式去执行，而是通过一个**正在运行的线程**去执行`runnable.run()`。根据上述源码中的`runWorker()`，在执行完`firstTask`后就会调用`getTask()`获取任务去执行，如果`getTask()`没有获取到任务，就会在等待`keepAliveTime`之后关闭非核心线程，核心线程通过`workQueue.take()`阻塞线程避免自身被回收。

#### 线程回收

`getTask()`获取不到任务时，执行`processWorkerExit()`进行线程回收

```java
     private void processWorkerExit(Worker w, boolean completedAbruptly) {
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            //减少工作线程数
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }
        //尝试终止线程池
        tryTerminate();

        int c = ctl.get();
       //线程池处于RUNNABLE或SHUTDOWN状态
        if (runStateLessThan(c, STOP)) {
            if (!completedAbruptly) {
                //根据是否配置 allowCoreThreadTimeout 来判断线程池的最小保留线程数
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                //阻塞队列还有任务的话，至少保留一个线程去执行任务
                if (min == 0 && ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) >= min)
                    return; // replacement not needed
            }
            //因为线程中断，导致没有线程执行阻塞队列任务
            //尝试新建线程去执行任务
            addWorker(null, false);
        }
    }
```



#### 任务拒绝

当线程池处于`非RUNNABLE`状态或者`workerCount > maximumPoolSize`时，就会执行`reject(runnable)`拒绝策略

```java
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command)) //当前不是RUNNABLE，移除当前任务
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))//添加非核心线程失败，表示已经超出了maximumPoolSize
            reject(command);
    }

    final void reject(Runnable command) {
        handler.rejectedExecution(command, this);
    }

    public static class AbortPolicy implements RejectedExecutionHandler {
        /**
         * Creates an {@code AbortPolicy}.
         */
        public AbortPolicy() { }

        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            throw new RejectedExecutionException("Task " + r.toString() +
                                                 " rejected from " +
                                                 e.toString());
        }
    }
```

通过自定义类实现`RejectedExecutionHandler`接口，执行对应的拒绝策略。默认拒绝策略是`AbortPolicy`。

#### 总结

![img](/images/640-1293801.)

线程里容纳了一定的`Worker(执行任务的线程)`。根据线程池状态的不同，有新任务加入时，执行不同的操作。

- 核心线程未满(`workerCount < corePoolSize`)，创建`核心线程`执行任务
- 核心线程已满(`workerCount>= corePoolSize`)，将任务添加到`workQueue`中
- `workQueue`已满(`workerCount< maximumPoolSize`)，创建`非核心线程`执行任务
- 最大任务队列已满(`workerCount = maximumPoolSize`)，执行`handler`拒绝策略



线程执行任务时，先执行`Worker的firstTask`，后续从`getTask()`获取任务去执行，根据线程池的容量区间获取任务的方式也不同

- 容量区间位于`0~corePoolSize(核心线程)`，执行`workQueue.take()`阻塞获取任务，不会被回收。*若设置`allowCoreThreadTimeout(true)`也会被回收*
- 容量区间位于`corePoolSize~maximumPoolSize(非核心线程)`，执行`workQueue.poll(keepAliveTime)`获取任务，超出`keepAliveTime`该线程就会被回收



### 线程池中的线程策略

#### 增长策略

默认情况下，线程池是根据任务先**创建足够核心线程数的线程去执行任务**，当核心线程满了时**将任务放入等待队列**。待队列满了的时候，继续**创建新线程执行任务直到达到最大线程数停止**。此时再进入新任务的话，那就只能**执行拒绝策略或是抛出异常**。

#### 收缩策略

当线程池内的线程数大于核心线程数并且当前存在空闲线程并且空闲线程的空闲时间大于`keepAliveTime`时，会对空闲线程进行回收，直到线程数量等于核心线程数(`corePoolSize`)为止。

###  线程池的使用注意

1. 线程池不要用`Executors`的方式去创建，应该利用`ThreadPoolExecutor`的方式，这样可以帮助更好理解实现方式以及避免资源消耗过度的问题。

   **`fixThreadPool以及singleThreadPool`,由于设置的等待队列长度为Integer.MAX_VALUE，导致大量请求堆积，消耗大量资源。**

   **`cachedThreadPool以及scheduledThreadPool`,由于运行允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的请求，消耗大量资源。**

2. 针对具体情况去配置线程池参数，不同的任务类别应采用不同规模的线程池，任务类别分为3种：

   - **`CPU密集型任务(需要进行大量计算，处理)`**：线程池中线程个数尽量少，不应大于CPU核心数，避免出现每个线程都需要长时间使用但是线程过多去抢占资源。建议`corePoolSize`为**n+1**

   - **`IO密集型任务(主要时间都在IO，CPU空闲时间比较多)`**：线程池可以配置尽量多的线程，由于CPU大部分时间空闲，可以提高CPU的利用率。建议`corePoolSize`为**2n**

   - **`混合型任务`**：如果可以拆分，则拆分成一个CPU密集型以及IO密集型任务，只要执行任务效率相差不大。若相差太大则没必要拆分。

###  补充知识

1. `submit()`和`execute()`区别

   `submit()`返回一个`future`，根据`future`可以判断任务是否完成--实现`Callable`接口

   `execute()`无返回值。只是执行了任务，不知道结果如何 -- 实现`Runnable`接口

2. `BlockingQueue`介绍

   {% post_link Java-BockingQueue阻塞队列 %}

3. `AbstractQueuedSynchronizer`介绍

   {% post_link Java-AbstractQueuedSynchronizer简介 %}
   
4. 为什么存在`newSingleThreadExecutor`?不能使用`newFixedThreadPool(1)`代替

   再次对比一下两者的源码

   ```java
   /*     
   * Creates an Executor that uses a single worker thread operating
        * off an unbounded queue, and uses the provided ThreadFactory to
        * create a new thread when needed. Unlike the otherwise
        * equivalent {@code newFixedThreadPool(1, threadFactory)} the
        * returned executor is guaranteed not to be reconfigurable to use
        * additional threads.
          */
   public static ExecutorService newSingleThreadExecutor() {
           return new FinalizableDelegatedExecutorService
               (new ThreadPoolExecutor(1, 1,
                                       0L, TimeUnit.MILLISECONDS,
                                       new LinkedBlockingQueue<Runnable>()));
       }
   
   
   
       public static ExecutorService newFixedThreadPool(int nThreads) {//nThreads为1
           return new ThreadPoolExecutor(nThreads, nThreads,//1 , 1
                                         0L, TimeUnit.MILLISECONDS,
                                         new LinkedBlockingQueue<Runnable>());
       }
   ```

   两者之间最大的差异就在于包装类的区别：

   - `newSingleThreadExecutor`——FinalizableDelegatedExecutorService
   - `newFixedThreadPool`——ThreadPoolExecutor

   ```java
    private static class FinalizableDelegatedExecutorService
               extends DelegatedExecutorService {
           FinalizableDelegatedExecutorService(ExecutorService executor) {
               super(executor);
           }
           protected void finalize() {
               super.shutdown();
           }
       }
       private static class DelegatedExecutorService
               extends AbstractExecutorService {
           // Android-added: @ReachabilitySensitive
           // Needed for FinalizableDelegatedExecutorService below.
           @ReachabilitySensitive
           private final ExecutorService e;
           DelegatedExecutorService(ExecutorService executor) { e = executor; }
           public void execute(Runnable command) { e.execute(command); }
           public void shutdown() { e.shutdown(); }
           public List<Runnable> shutdownNow() { return e.shutdownNow(); }
           public boolean isShutdown() { return e.isShutdown(); }
           public boolean isTerminated() { return e.isTerminated(); }
          ...
       }
   
   ```

   `DelegatedExecutorService`就是`ExecutorService接口实现类`的包装类，包装后的对象仅仅暴露`ExecutorService`接口方法，而`FinalizableDelegatedExecutorService`屏蔽了大多数实现方法，避免被强制转换时修改配置导致行为出现问题。

   ```java
       private static void testFixed(){
           ExecutorService s = Executors.newFixedThreadPool(1);
           ((ThreadPoolExecutor)s).setCorePoolSize(2);
           System.err.println("ss "+((ThreadPoolExecutor) s).getCorePoolSize());
       }
   
       private static void testSingle(){
           ExecutorService s = Executors.newSingleThreadExecutor();
           ((ThreadPoolExecutor)s).setCorePoolSize(2);
           System.err.println("ss"+((ThreadPoolExecutor) s).getCorePoolSize());
       }
   
   输出结果：
     ss 2
   Exception in thread "main" java.lang.ClassCastException: java.util.concurrent.Executors$FinalizableDelegatedExecutorService cannot be cast to java.util.concurrent.ThreadPoolExecutor
   	at thread.TestThreadPool.testSingle(TestThreadPool.java:31)
   	at thread.TestThreadPool.main(TestThreadPool.java:20)
   
   ```

   观察上面的结果，可以看出`newSingleThreadExecutor`与`newFixedThreadPool`最大区别在于，前者不可配置参数，可以保证**任务的串行执行**，后者在运行的过程中可以通过强制类型转换得到`ThreadPoolExecutor`去进行参数的重新配置，导致**任务可能变成并行执行**。使应用的执行逻辑出现错误，导致应用异常。

5. ss

   

###  内容引用

[线程池](https://juejin.im/post/5bdbbc3d6fb9a0224a5e486f#heading-14)

[线程池深入解析](https://mp.weixin.qq.com/s/HpMu_QI_N-J18fNJG96yzA)

[Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-BockingQueue阻塞队列</title>
    <url>/2018/12/24/Java-BockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[
![BlockingQueue阻塞队列](/images/BlockingQueue 阻塞队列xmind.png)

## Queue接口

`Queue队列`的特征是`FIFO——先进先出`。只有队尾可以进行插入操作，只有队头可以进行删除操作。

![img](/images/822721-20200318104019498-382557009.png)



Java中的`Queue`继承了`Collection`接口，并额外实现了以下方法

```java
public interface Queue<E> extends Collection<E> {
  boolean add(E e); 
  boolean offer(E e);
  E remove();
  E poll();
  E element();
  E peek();
}
```



### 队列插入数据操作(`add/offer`)

> 将新数据插入队尾

`add`：如果队列满时，插入队尾数据，就会抛出`IllegalStateExecption`

`offer`：如果队列满时，插入队尾数据，不会抛出异常，会返回`false`

### 队列删除数据操作(`remove/poll`)

> 获取队头元素并删除

`remove`：当队列为空时，删除元素时，会抛出`NoSuchElementException`

`poll`：当队列为空时，删除元素时，不会抛出异常，只会返回`null`

### 队列检查数据操作(`element/peek`)

> 获取队头元素但并不删除

`element`：当队列为空时，获取队头元素，会抛出`NoSuchElementException`

`peek`：当队列为空时，获取队头元素，不会抛出异常，只会返回`null`



|                | 抛出异常    | 特殊值                 |
| -------------- | ----------- | ---------------------- |
| 插入           | `add()`     | `offer()` 返回 `false` |
| 删除           | `remove()`  | `poll()` 返回`null`    |
| 获取数据(检查) | `element()` | `peek()` 返回`null`    |



## BlockingQueue接口

**系统提供的用于多线程环境下存、取共享变量的一种容器。**

`BlockingQueue阻塞队列`实现了`Queue接口`，相比于`Queue`提供了额外的功能：

- 获取队头元素时，如果队列为空，执行线程会处于阻塞状态，直到队列非空——`对应删除和检查操作`
- 添加队尾元素时，如果队列已满，执行线程会处于阻塞状态，直到队列不满——`对应插入操作`

当触发上述两种情况的出现时，按照不同的设置方式，提供了以下几种处理方案：

- 抛出异常
- 返回特殊值(返回`null`或`false`)
- 阻塞当前线程直到可以执行
- 阻塞线程设置最大超时时间，若超过该时间，线程就会继续执行，放弃当次操作



### 阻塞队列插入数据操作(`put/offer(time)`)

> 对应阻塞队列在队列已满插入数据时的`阻塞`或者`超时处理`

`put`：如果队列满时，插入队尾数据，会阻塞当前线程`直到队列非满`

`offer(time)`：如果队列满时，插入队尾数据，会阻塞当前线程`直到队列非满或者达到了超时时间`,达到超时时间则返回`false`

### 阻塞队列删除数据操作(`take()/poll(time)`)

> 对应阻塞队列在队列为空时获取数据时的`阻塞`或`超时处理`

`take()`：当队列为空时，删除元素时，会阻塞当前线程`直到队列非空`

`poll(time)`：当队列为空时，删除元素时，会阻塞当前线程`直到队列非空或者达到了超时时间`，达到超时时间返回`null`



### ~~阻塞队列检查数据操作~~



|                | 抛出异常    | 特殊值                 | 阻塞     | 超时                     |
| -------------- | ----------- | ---------------------- | -------- | ------------------------ |
| 插入           | `add()`     | `offer()` 返回 `false` | `put()`  | `offer(time)`返回`false` |
| 删除           | `remove()`  | `poll()` 返回`null`    | `take()` | `poll(time)`返回`null`   |
| 获取数据(检查) | `element()` | `peek()` 返回`null`    | /        | /                        |



### 注意点

1. 阻塞队列无法插入`null`，否则抛出空指针异常
2. 可以访问阻塞队列中的任意元素，尽量避免使用`remove(object)`移除对象



## `BlockingQueue`实现类

在{% post_link Java-线程池%}中的`workQueue`设置的就是`BlockingQueue`接口的实现类，

例如

- `ArrayBlockingQueue`：数组构成的有界阻塞队列
- `LinkedBlockingQueue`：链表构成的有界阻塞队列，如果不设置大小的话，近似`无界阻塞队列`
- `SynchronousQueue`：不存储任何元素的阻塞队列
- `PriorityBlockingQueue`：支持优先级排序的无界阻塞队列




## `BlockingQueue`原理

`BlockingQueue`只是一个接口，真正的实现都是在`XXBloxckingQueue`中的，想要分析对应的原理就需要从实现类进行分析



#### `ArrayBlockingQueue`

> 由数组实现的有界阻塞队列，大小一旦确定就无法改变队列的长度。

##### 关键成员变量

```java
    /** The queued items 维护队列元素的数组*/
    final Object[] items; 

    /** items index for next take, poll, peek or remove 移除数据的数组下标*/
    int takeIndex;

    /** items index for next put, offer, or add 插入数据的数组下标*/
    int putIndex;

    /** Number of elements in the queue 数组长度*/
    int count;

    /** Main lock guarding all access 数据并发控制类*/
    final ReentrantLock lock;

    /** Condition for waiting takes 控制take操作是否让线程等待*/
    private final Condition notEmpty;

    /** Condition for waiting puts 控制put操作是否让线程等待*/
    private final Condition notFull;
```

`ArrayBlockingQueue`阻塞功能的实现就是依赖了`ReentrantLock`以及`Condition`实现了`等待机制`。

具体可参考{% post_link Java-ReenTrantLock%}

##### 构造函数

```java
public ArrayBlockingQueue(int capacity) {
        this(capacity, false);
    }    

public ArrayBlockingQueue(int capacity, boolean fair) {
        if (capacity <= 0)
            throw new IllegalArgumentException();
        this.items = new Object[capacity];
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    }
```

`capacity`：设置阻塞队列的数组容量

`fair`：设置线程并发是否公平(`默认配置非公平锁`)

> 当前锁被一个线程持有时，其他线程会被挂起等待锁的释放，等待时加入等待队列。
>
> `公平锁`：当锁释放时，等待队列的前端线程会优先获取锁
>
> `非公平锁`：当锁释放时，等待队列中的所有线程都会去尝试获取锁

在`ArrayBlockingQueue`初始化时，构造`ReentrantLock`锁以及两个`Condition`对象控制数据插入、删除时的阻塞。

##### 实现方法

`offer()` 非阻塞添加数据

```java
 public boolean offer(E e) {
        Objects.requireNonNull(e);//检查将要添加的数据是否为null
        final ReentrantLock lock = this.lock;
        lock.lock();//上锁
        try {
            if (count == items.length)//队列已满
                return false;
            else {
                enqueue(e);//数据加入队列
                return true;
            }
        } finally {
            lock.unlock();//解锁
        }
    }

//数据入队
    private void enqueue(E x) {
        // assert lock.getHoldCount() == 1;
        // assert items[putIndex] == null;
        final Object[] items = this.items;
        items[putIndex] = x;//数组赋值
        //如果此时放入的是最后一个下标的数据，重置下标为0，下一次从第一个开始放元素
        if (++putIndex == items.length) putIndex = 0;
        count++;
        notEmpty.signal();//通知 数组非空 
    }
```

`offer()`添加数据时，将当前线程上锁。

- 在当前队列已满时，直接返回`false`
- 当前队列未满时，调用`enqueue()`添加数据，`putIndex`设置对应数据且`putIndex++`。 然后通知阻塞的消费线程`notEmpty`



`poll()` 非阻塞取出数据

```java
    public E poll() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return (count == 0) ? null : dequeue();//当前队列非空 取出数据
        } finally {
            lock.unlock();
        }
    }

    private E dequeue() {
        // assert lock.getHoldCount() == 1;
        // assert items[takeIndex] != null;
        final Object[] items = this.items;
        @SuppressWarnings("unchecked")
        E x = (E) items[takeIndex];
        items[takeIndex] = null;
        //如果此时取出的是最后一个下标的数据，重置下标为0，下一次从第一个开始取出元素
        if (++takeIndex == items.length) takeIndex = 0;
        count--;
        if (itrs != null)
            itrs.elementDequeued();//数据迭代减少，保证遍历线程安全
        notFull.signal();//通知 数组不满
        return x;
    }
```

`poll()`取出数据时，将当前线程上锁

- 当前队列为空的时候，直接返回null
- 当前队列非空的时候，调用`dequeue()`将`takeIndex`元素出队，设置`takeIndex`处元素为`null`且`takeIndex--`。然后通知阻塞的生产线程`notFull`



`offer(time)`不超时阻塞添加数据

```java
    public boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException {

        Objects.requireNonNull(e);
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length) {
                if (nanos <= 0L)
                    return false;
                nanos = notFull.awaitNanos(nanos);
            }
            enqueue(e);
            return true;
        } finally {
            lock.unlock();
        }
    }
```

`offer(time)`添加数据时，将当前线程上锁

- 在当前队列已满时，阻塞生产线程`notFull`，超过`time`后，队列还是满的话，直接返回`false`
- 当前队列未满时，调用`enqueue()`添加数据，`putIndex`设置对应数据且`putIndex++`。 然后通知阻塞的消费者`notEmpty`



`poll(time)`不超时阻塞取出数据

```java
    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0) {
                if (nanos <= 0L)
                    return null;
                nanos = notEmpty.awaitNanos(nanos);
            }
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
```

`poll(time)`取出数据时，将当前线程上锁

- 当前队列为空的时候，阻塞消费线程`notEmpty`，超过`time`后，队列还是空的话，直接返回`null`
- 当前队列非空的时候，调用`dequeue()`将`takeIndex`元素出队，设置`takeIndex`处元素为`null`且`takeIndex--`。然后通知阻塞的生产者`notFull`



###### `put()`阻塞添加数据

```java
    public void put(E e) throws InterruptedException {
        Objects.requireNonNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();//生产者线程上锁
        try {
            while (count == items.length)
                notFull.await();//等待消费者线程通知
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
```

`put()`添加数据时

- 当前队列已满时，阻塞当前线程，等待`notFull`通知(`队列未满`)
- 当前队列未满时，调用`enqueue()`添加数据，`putIndex`设置对应数据且`putIndex++`。 然后通知阻塞的消费者`notEmpty`



###### `take()`阻塞获取数据

```java
    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();//消费者线程上锁
        try {
            while (count == 0)
                notEmpty.await();//等待生产者线程通知
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
```

`take()`获取数据时

- 当前队列为空时，阻塞当前线程，等待`notEmpty`通知(`队列新增数据`)
- 当前队列非空的时候，调用`dequeue()`将`takeIndex`元素出队，设置`takeIndex`处元素为`null`且`takeIndex--`。然后通知阻塞的生产者`notFull`



其中`Condition`的`await/signal`类似于`Object`的`wait/notify`实现等待与通知的功能。

在分析`enqueue()`和`dequeue()`时，发现底层数组不会进行扩容，而是在到达边缘时，重置`index`为0，重复利用数组。

![ArrayBlockingQueue循环数组](/images/ArrayBlockingQueue循环数组.jpg)

从上述源码对`ArrayBlockingQueue`进行总结：

**底层数据结构是一个 数组，生产者和消费者由同一个锁(`ReetrantLock`)控制，生产和消费效率低。**



#### LinkedBlockingQueue

> 由链表实现的阻塞队列，默认最大长度为`Integer.MAX`。

##### 关键成员变量

```java
    /** The capacity bound, or Integer.MAX_VALUE if none 链表最大长度*/
    private final int capacity;

    /** Current number of elements 当前元素个数*/
    private final AtomicInteger count = new AtomicInteger();

    /**
     * Head of linked list.
     * Invariant: head.item == null
     * 链表头节点
     */
    transient Node<E> head;

    /**
     * Tail of linked list.
     * Invariant: last.next == null
     * 链表尾节点
     */
    private transient Node<E> last;

    /** Lock held by take, poll, etc 控制消费并发*/
    private final ReentrantLock takeLock = new ReentrantLock();

    /** Wait queue for waiting takes 控制take线程等待 非空条件*/
    private final Condition notEmpty = takeLock.newCondition();

    /** Lock held by put, offer, etc 控制生产并发*/
    private final ReentrantLock putLock = new ReentrantLock();

    /** Wait queue for waiting puts 控制put线程等待 非满条件*/
    private final Condition notFull = putLock.newCondition();
```

`LinkedBlockingQueue`采用了两把锁`putLock、takeLock`，分别进行控制，提高了并发性能。

##### 构造函数

```java
    public LinkedBlockingQueue() {
        this(Integer.MAX_VALUE);
    }

    public LinkedBlockingQueue(int capacity) {
        if (capacity <= 0) throw new IllegalArgumentException();
        this.capacity = capacity;
        last = head = new Node<E>(null);
    }
```

`capacity`：设置单链表长度上限，若不设置该值，默认为`Integer.MAX`

构造函数初始化了底层的链表结构。

##### 实现方法

`offer()`非阻塞添加数据

```java
    public boolean offer(E e) {
        if (e == null) throw new NullPointerException();
        final AtomicInteger count = this.count;
        if (count.get() == capacity) //达到上限直接返回false
            return false;
        int c = -1;
        Node<E> node = new Node<E>(e);
        final ReentrantLock putLock = this.putLock;
        putLock.lock();//线程上锁
        try {
            if (count.get() < capacity) {
                enqueue(node);//插入链表
                c = count.getAndIncrement();
                if (c + 1 < capacity)
                    notFull.signal();//唤醒 等待的入队线程
            }
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            signalNotEmpty();//唤醒等待的 出队线程
        return c >= 0;
    }

    private void enqueue(Node<E> node) {
        // assert putLock.isHeldByCurrentThread();
        // assert last.next == null;
        last = last.next = node;//赋值操作
    }
```

`offer`添加数据时，当队列已满时，直接返回`false`。未满时，插入新数据后，`count`自加后唤醒`notFull、notEmpty`。

`poll()`非阻塞获取数据

```java
    public E poll() {
        final AtomicInteger count = this.count;
        if (count.get() == 0)
            return null;//队列为空返回null
        E x = null;
        int c = -1;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lock();
        try {
            if (count.get() > 0) {
                x = dequeue();//出队
                c = count.getAndDecrement();
                if (c > 1)
                    notEmpty.signal();//通知非空线程
            }
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            signalNotFull();//通知非满线程
        return x;
    }

    private E dequeue() {
        // assert takeLock.isHeldByCurrentThread();
        // assert head.item == null;
        Node<E> h = head;
        Node<E> first = h.next;
        h.next = h; // help GC
        head = first;
        E x = first.item;
        first.item = null;
        return x;
    }
```

`poll`获取数据时，队列为空时，直接返回`null`。队列非空时，获取数据后，数据出队，`count`自减后，先后唤醒`notEmpty`、`notFull`。



###### `put()`阻塞添加数据

```java
    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        // Note: convention in all put/take/etc is to preset local var
        // holding count negative to indicate failure unless set.
        int c = -1;
        Node<E> node = new Node<E>(e);
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count;
        putLock.lockInterruptibly();
        try {
            while (count.get() == capacity) {
                notFull.await();//队列已满时，等待非满通知
            }
            enqueue(node);//插入新数据
            c = count.getAndIncrement();//数据自增
            if (c + 1 < capacity)
                notFull.signal();//通知非满线程
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            signalNotEmpty();//通知非空线程
    }
```

`put()`添加数据时，队列已满时，会进行阻塞等待直到队列非满。

###### `take()`阻塞获取数据

```java
    public E take() throws InterruptedException {
        E x;
        int c = -1;
        final AtomicInteger count = this.count;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();
        try {
            while (count.get() == 0) {
                notEmpty.await();//队列为空时，等待非空通知
            }
            x = dequeue();//出队
            c = count.getAndDecrement();
            if (c > 1)
                notEmpty.signal();//通知非空线程
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            signalNotFull();//通知非满线程
        return x;
    }
```

`take()`获取数据时，队列为空时，会进行阻塞等到直到队列非空。

![img](/images/v2-8bc04760ad1133e7630717dbc38c1cc7_1440w.jpg)

从上述源码对`LinkedBlockingQueue`进行总结：

**`LinkedBlockingQueue`底层数据结构为`单链表`，内部持有两个`Lock：putLock、takeLock`，相互之间不会干扰执行，提高了并发性能。**

##### 与`ArrayBlockingQueue`比较

|              | ArrayBlockingQueue                               | LinkedBlockingQueue                                          |
| ------------ | ------------------------------------------------ | ------------------------------------------------------------ |
| 构造方法     | 必须指定构造大小<br>指定后无法修改               | 默认大小为`Integer.MAX`<br>可以指定大小                      |
| 底层数据结构 | 数组                                             | 单链表                                                       |
| 锁           | 出队入队使用同一把锁<br>数据的删除和添加操作互斥 | 出队使用`takeLock`，入队使用`putLock`<br>数据删除、添加操作不干扰，提升并发性能 |



#### SynchronousQueue

> 容量为0，无法储存数据的阻塞队列。提供了公平与非公平锁的设置。

##### 关键成员变量

```java
//针对不同操作定义的统一接口
private transient volatile Transferer<E> transferer;

    abstract static class Transferer<E> {
       //e为空则表示 需要获取数据；e不为空表示 需要添加数据
        abstract E transfer(E e, boolean timed, long nanos);
    }
```



##### 构造函数

```java
    public SynchronousQueue() {
        this(false);//默认非公平构造
    }

    public SynchronousQueue(boolean fair) {
        //公平与非公平对应两种实现形式
        transferer = fair ? new TransferQueue<E>() : new TransferStack<E>();
    }
```



##### 实现方法

数据操作`offer()/poll() put()/take()`

```java
    public boolean offer(E e) {
        if (e == null) throw new NullPointerException();
        return transferer.transfer(e, true, 0) != null;
    }

    public E poll() {
        return transferer.transfer(null, true, 0);
    }

    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        if (transferer.transfer(e, false, 0) == null) {
            Thread.interrupted();
            throw new InterruptedException();
        }
    }

    public E take() throws InterruptedException {
        E e = transferer.transfer(null, false, 0);
        if (e != null)
            return e;
        Thread.interrupted();
        throw new InterruptedException();
    }
```

上述的数据操作方法都涉及到了两部分内容：

- `transferer`：数据调度
- `transfer`：数据执行

###### TransferQueue

> `SynchronousQueue`的**公平**实现，内部实现使用队列，可以保证先进先出的特性。

基本实现方法：

当前队列为空的时候或者存在了与即将添加的`QNode`操作模式一致(`isData一致`)的节点，线程进行同步等待，`QNode`添加到队列中。

继续等待与队列头部`QNode`操作互补(`写操作(isData = true)，等待一个读操作(isData = false)`)的`QNode`节点

新添加的`QNode`节点与队头`QNode`操作互补时，尝试通过`CAS`更新等待节点的item字段，然后让队头等待节点出列，并返回节点元素和更新队头节点。

如果队列中的节点的`waiter`等待线程被取消，节点也会被清理出队列。

![TransferQueue公平队列](/images/TransferQueue.jpg)

`isData`：true 表示`put`操作，false表示`take`操作。

`next`：下一个节点

`waiter`：当前等待的线程

`item`：元素信息





###### TransferStack

> `SynchronousQueue`非公平实现，内部实现使用**栈**，实现了`先进后出`的特性。

基本实现方法：

当前栈为空或者存在了与即将添加的`SNode`模式相同的节点(`mode一致`)，线程进行同步等待，`SNode`添加到栈中

继续等待与栈顶`SNode`操作互补(`写操作(mode = DATA)，读操作(mode=REQUEST)`)的节点

出现与栈顶`SNode`操作互补的节点后，新增`SNode`节点的`mode`会变为`FULFILLING`，与栈顶节点匹配，匹配完成后，将俩节点都弹出并返回匹配节点的结果。

如果栈顶元素找到匹配节点，就会继续向下帮助匹配(`此时上一个匹配操作还没结束又进入一个新的请求`)



![TranferStack](/images/TransferStack.jpg)

`next`：下一个元素

`item`：元素信息

`waiter`：当前等待的线程

`match`：匹配的节点

`mode`：`DATA(1)`-添加数据、`REQUEST(0)`-获取数据、`FULFILLING(2)`-互补模式



##### 特点

- `SynchronousQueue`容量为0，无法进行数据存储
- 每次写入数据时，写线程都需要等待；直到另一个线程执行读操作，写线程会返回数据。*写入元素不能为null*
- `peek()`返回`null`；`size()`返回`0`；无法进行迭代操作
- 提供了`公平`，`非公平`两种策略处理，分别是基于`Queue-TransferQueue`与`Stack-TransferStack`实现。



#### 原理介绍

绝大多数都是利用了**Lock锁的多条件(Condition)阻塞控制**。

拿`ArrayBlockigQueue`进行简单描述就是：

1. `put`和`take`操作都需要先**获取锁**，无法获取的话就要一直自旋拿锁，直到获取锁为止
2. 在拿到锁以后。还需要判断当前队列是否可用(`队列非满且非空`)，如果队列不可用就会被阻塞，并**释放锁**
3. 阻塞的线程被唤醒时，依然需要在拿到锁之后才可以继续执行，否则，自旋拿锁，拿到锁继续判断当前队列是否可用(**使用while判断**)



## 使用场景

##### 生产-消费模型

```java
public class PCDemo {
    private int queueSize = 10;
    private ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(queueSize, true);

    public static void main(String[] args) {

        PCDemo blockQueue = new PCDemo();
        Producter producter = blockQueue.new Producter();
        Customer customer = blockQueue.new Customer();

        producter.start();
        customer.start();
    }

    class Customer extends Thread {
        @Override
        public void run() {
            while (true) {
                try {
                    queue.take();
                    System.err.println("消费哦，剩余空间为" + queue.size());
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    class Producter extends Thread {
        @Override
        public void run() {
            while (true) {
                try {
                    queue.put(1);
                    System.err.println("生产哦，剩余空间为" + (queueSize - queue.size()));
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

##### 线程池

{% post_link Java-线程池%}

## 拓展知识

### Guarded Suspension（保护性暂时挂起）

**当服务进程准备好时，才提供服务。**

![img](/images/java-concurrent-guarded-suspension.png)

本质是一种**等待唤醒机制的实现**，也称为**多线程的if**

基本实现代码

```java
public class GuardedObject<T>{
  private T obj;
  private final ReetrantLock lock = new ReentrantLock();
  private final Condition done = lock.newCondition();
  
  public T get(Predicate<T> p){
    lock.lock();
    try{
      while(!p.test(obj)){
        done.await(); //等待事件执行
      }
    }catch(Exception e){
      e.printStacktrace();
    }finally{
      lock.unlock();
    }
    return obj;
  }
  
  public void onChange(T obj){
    lock.lock();
    try{
      this.obj = obj;
      done.signAll();//数据发生变化，进行通知
    }finally{
      lock.unlock();
    }
  }
}
```



## 参考链接

[SynchronousQueue-公平模式](https://www.cnblogs.com/dwlsxj/archive/2004/01/13/Thread.html)

[SynchronousQueue](https://www.jianshu.com/p/a565b0b25c43)

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC-Mediasoup编译记录</title>
    <url>/2020/09/24/WebRTC-Mediasoup%E7%BC%96%E8%AF%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[


### 下载相关文件

- [libmediasoupclient](https://github.com/versatica/libmediasoupclient)
- [webrtc](https://webrtc.googlesource.com/src)

### 参考文档

[compile_webrtc](https://github.com/mail2chromium/Compile_WebRTC_Library_For_Android)

[mediasoup doc](https://mediasoup.org/documentation/v3/libmediasoupclient/installation/)



### 编译webrtc

```shell
//编译工具下载
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
export PATh="$PATH:${HOME}/depot_tools" //配置环境变量

//下载webrtc源码
mkdir webrtc_android
cd webrtc_android
git clone https://webrtc.googlesource.com/src
fetch --nohooks webrtc_android
gclient sync

//编译webrtc源码
cd src
./build/install-build-deps.sh

gn gen out/Debug --args='target_os="android" target_cpu="arm"'
// gn gen out/Release --args='is_debug=false is_component_build=false rtc_include_tests=false target_os="android" target_cpu="arm"'

autoninja -C out/Debug
//autoninja -C out/Release
```

对应文件输出目录：

./out/Debug/lib_java/sdk/android/libwebrtc.jar 

./out/Debug/libjingle_peerconnection_so.so

上面这俩是Android需要用到的sdk

./out/Debug/lib.unstripped/libjingle_peerconnection_so.so

./out/Debug/obj/libwebrtc.a //静态链接




### 编译libmediasoupclient

#### 下载代码

git clone https://github.com/versatica/libmediasoupclient

cd libmediasoupclient/

#### 编译配置

```shell
cmake . -Bbuild \
-DLIBWEBRTC_INCLUDE_PATH:PATH=PATH_TO_LIBWEBRTC_SOURCES \     # src源代码目录
-DLIBWEBRTC_BINARY_PATH:PATH=PATH_TO_LIBWEBRTC_BINARY         # 编译出libwebrtc.a目录
```

示例配置

cmake . -Bbuild   -DLIBWEBRTC_INCLUDE_PATH:PATH=/home/zaze/Desktop/webrtc_android/src   -DLIBWEBRTC_BINARY_PATH:PATH=/home/zaze/Desktop/webrtc_android/src/out/Debug/obj

运行命令后，再执行

```shell
make -C build/
```

在`./build/`目录下会生成`libmediasoupclient.a`文件取出备用



### 获取libmediasoupclient sdk

基于[mediasoup-client-android](https://github.com/haiyangwu/mediasoup-client-android)进行编译，注意以下关键点：

- clone后的项目里面的`mediasoup-client/deps/webrtc/lib`里面的`libwebrtc.a`文件都是有误的，需要从`https://github.com/haiyangwu/webrtc-android-build`获取对应版本的文件，下载完成后替换原有的`libs`目录



TODO:后续替换为最新版的`libmediasoupclient`和`webrtc`

]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-流量统计</title>
    <url>/2020/09/15/Android-%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[
## 流量统计

Android目前提供了两种流量计算方案

- `TrafficStats`
- `NetworkStatsManager`

这两种方案有着各自的优缺点与限制，下面简单的记录一下

![流量统计](/images/流量统计.png)

### TrafficStats

> Android API8后提供的该类，可以获取**设备重启以来的流量信息**。

```java
public class TrafficStats {
  public static long getMobileRxBytes() //移动网络接受的总流量
  public static long getMobileTxBytes() //移动网络发送的总流量
  public static long getTotalTxBytes() //发送的总数据流量
  public static long getTotalRxBytes() //接收的总数据流量
  public static long getUidRxBytes(int uid) //指定uid接收的流量
  public static long getUidTxBytes(int uid) //指定uid发送的流量
}
```

以上为`TrafficStats`提供的基本方法

根据上述方法可以大致得到当前设备使用的流量数据，`getMobileXX()`获取移动网络数据，`getTotalXX()`获取总流量数据，所以`getTotalXX()-getMobileXX()`大致可以得到Wifi的使用数据。还可以通过指定`getUidXX()`获取指定应用的流量数据。

优点：

- 调用方法简单，无需特别权限

缺点：

- 无法获取某个时间段内的流量消耗

  统计的是设备启动以来的流量数据，无法判断是从哪个时间段开始的流量统计

- 无法获取指定应用的wifi类型流量数据

  虽然可以通过监听网络变化去获取对应数据，实际可操作性不高

#### 简单原理介绍

上述方法内部实现都是通过`getStatsService()`进行调用

```java
    private synchronized static INetworkStatsService getStatsService() {
        if (sStatsService == null) {
            sStatsService = INetworkStatsService.Stub.asInterface(
                    ServiceManager.getService(Context.NETWORK_STATS_SERVICE));
        }
        return sStatsService;
    }

    public static long getTotalTxPackets() {
        try {
            return getStatsService().getTotalStats(TYPE_TX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
```

通过AIDL调用到`NetWorkStatsService`

```java
public class NetworkStatsService extends INetworkStatsService.Stub {
 ...
@Override
    public long getTotalStats(int type) {
        long nativeTotalStats = nativeGetTotalStat(type, checkBpfStatsEnable());
        if (nativeTotalStats == -1) {
            return nativeTotalStats;
        } else {
            // Refer to comment in getIfaceStats
            return nativeTotalStats + getTetherStats(IFACE_ALL, type);
        }
    }
}
   //判断是否启用 bpf流量监控
   mUseBpfTrafficStats = new File("/sys/fs/bpf/traffic_uid_stats_map").exists();

    private boolean checkBpfStatsEnable() {
        return mUseBpfTrafficStats;
    }
```

`bpf流量监控`是在Android 9之后提供的，需要在Android P上的设备才可以使用。老的监控方式逐渐被废弃。

通过JNI调用`com_android_server_net_NetworkStatsService.cpp`

```c++
//流量记录文件路径
static const char* QTAGUID_IFACE_STATS = "/proc/net/xt_qtaguid/iface_stat_fmt";
static const char* QTAGUID_UID_STATS = "/proc/net/xt_qtaguid/stats";

static jlong getTotalStat(JNIEnv* env, jclass clazz, jint type, jboolean useBpfStats) {
    Stats stats = {};

    if (useBpfStats) {
        if (bpfGetIfaceStats(NULL, &stats) == 0) {
            return getStatsType(&stats, (StatsType) type);
        } else {
            return UNKNOWN;
        }
    }

    if (parseIfaceStats(NULL, &stats) == 0) {
        return getStatsType(&stats, (StatsType) type);
    } else {
        return UNKNOWN;
    }
}
```

在Android 9之前，通过读取`/proc/net/xt_qtaguid/stats`文件内容进行解析获取对应流量数据。

Android9 之后，通过读取`/sys/fs/bpf/traffic_uid_stats_map`获取数据

#### 使用实例

```java
public class TrafficStatsHelper {


    public static long getAllRxBytes() {
        return TrafficStats.getTotalRxBytes();
    }

    public static long getAllTxBytes() {
        return TrafficStats.getTotalTxBytes();
    }

    public static long getAllRxBytesMobile() {
        return TrafficStats.getMobileRxBytes();
    }

    public static long getAllTxBytesMobile() {
        return TrafficStats.getMobileTxBytes();
    }

    public static long getAllRxBytesWifi() {
        return TrafficStats.getTotalRxBytes() - TrafficStats.getMobileRxBytes();
    }

    public static long getAllTxBytesWifi() {
        return TrafficStats.getTotalTxBytes() - TrafficStats.getMobileTxBytes();
    }

    public static long getPackageRxBytes(int uid) {
        return TrafficStats.getUidRxBytes(uid);
    }

    public static long getPackageTxBytes(int uid) {
        return TrafficStats.getUidTxBytes(uid);
    }
}

调用实例：
TrafficStats.getUidRxBytes(Process.myUid()) //当前不支持外部获取对应应用的流量信息，如果有需求需要使用NetWorkStatsManager
```









### NetworkStatsManager

> Android 6.0之后新增加的类，可以获取历史的流量信息，并且支持查询时间段的流量数据

```java
public Bucket querySummaryForDevice(int networkType, String subscriberId,
            long startTime, long endTime)  //获取当前设备指定网络类型以及时间间隔内的所有流量信息

public NetworkStats queryDetailsForUid(int networkType, String subscriberId,
            long startTime, long endTime, int uid) //获取某id下的所有流量信息
  
public static class Bucket {
 ...
        public long getRxBytes() { //接收的流量
            return mRxBytes;
        }

        public long getTxBytes() { //发送的流量
            return mTxBytes;
        }
}
```

以上为`NetworkStatsManager`的主要调用方法

根据上述提供的方法，可以得到设备一直的流量数据，并且支持按照`networkType`区分和`startTime~endTime`获取指定时间段的流量数据。

优点：

- 可以获取指定类型以及时间段的流量数据

缺点：

- 需要申请特殊权限以及做权限适配
- 使用较复杂

#### 简单原理介绍

INetworkStatsSession.aidl -> getDeviceSummaryForNetwork

NetworkStatsService.java

NetworkStatsCollection.java -> getHistory()

#### 使用实例

```java
AndroidManifest.xml 配置权限
  
    <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
    <uses-permission
        android:name="android.permission.PACKAGE_USAGE_STATS"
        tools:ignore="ProtectedPermissions"/>
          
申请权限
    private void requestPermissions() {
        //检测有无 查看应用使用情况权限
        if (!hasPermissionToReadNetworkHistory()) {
            return;
        }
        //检测有无获取 READ_PHOBE_STATE 权限
        if (!hasPermissionToReadPhoneStats()) {
            //申请对应权限
            requestPhoneStateStats();
        }
    }

 private boolean hasPermissionToReadNetworkHistory() {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
            return true;
        }
        final AppOpsManager appOps = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);
        int mode = appOps.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS,
                android.os.Process.myUid(), getPackageName());
        if (mode == AppOpsManager.MODE_ALLOWED) {
            return true;
        }
        appOps.startWatchingMode(AppOpsManager.OPSTR_GET_USAGE_STATS,
                getApplicationContext().getPackageName(),
                new AppOpsManager.OnOpChangedListener() {
                    @Override
                    @TargetApi(Build.VERSION_CODES.M)
                    public void onOpChanged(String op, String packageName) {
                        int mode = appOps.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS,
                                android.os.Process.myUid(), getPackageName());
                        if (mode != AppOpsManager.MODE_ALLOWED) {
                            return;
                        }
                        appOps.stopWatchingMode(this);
                        Intent intent = new Intent(StatsActivity.this, StatsActivity.class);
                        if (getIntent().getExtras() != null) {
                            intent.putExtras(getIntent().getExtras());
                        }
                        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
                        getApplicationContext().startActivity(intent);
                    }
                });
        requestReadNetworkHistoryAccess();
        return false;
    }

    private void requestReadNetworkHistoryAccess() {
        Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);
        startActivity(intent);
    }

//上述权限申请完毕后，调用对应方法获取流量数据
     public long getPackageBytesWithNetTypeAndFlow(Context context, boolean isRx/*Rx、Tx*/,
                                                  int networkType/*TYPE_MOBILE，TYPE_WIFI*/) {
        NetworkStats networkStats = null;
        try {
            networkStats = networkStatsManager.queryDetailsForUid(networkType, getSubscriberId(context, networkType),
                    0, System.currentTimeMillis(), packageUid);
        } catch (RemoteException e) {
            return -1;
        }
        long bytes = 0L;
        NetworkStats.Bucket bucket = new NetworkStats.Bucket();
        while (networkStats.hasNextBucket()) {
            networkStats.getNextBucket(bucket);
            bytes += isRx ? bucket.getRxBytes() : bucket.getTxBytes();
        }
        networkStats.close();
        return bytes;
    }

    private String getSubscriberId(Context context, int networkType) {
        if (ConnectivityManager.TYPE_MOBILE == networkType) {
            TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            return tm.getSubscriberId();
        }
        return "";
    }
```



## 参考链接

[TrafficStats流程分析](https://www.jianshu.com/p/061f8889a888)

[ePBF流量监控](https://source.android.google.cn/devices/tech/datausage/ebpf-traffic-monitor)

[NetStads Demo]( https://github.com/RobertZagorski/NetworkStats.git )]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC音频处理模块相关</title>
    <url>/2020/08/14/WebRTC%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[
**[WebRTC源码](https://webrtc.googlesource.com/src/)**基于提交版本`4c2f9c9`

WebRTC音频处理模块，负责在传输音频时对音频进行一定的处理，例如`降噪、增益、回声消除`，整体模块代码位于`modules/audio_processing`。

按照以下模块分别介绍，各模块的功能以及相关配置和源码解析

默认音频处理配置如下：

```c++
 AudioOptions options;
    options.echo_cancellation = true;//回声消除
    options.auto_gain_control = true;//自动增益
    options.noise_suppression = true;//降噪
    options.highpass_filter = true;//高通滤波器开启 
    options.stereo_swapping = false;//立体声
    options.audio_jitter_buffer_max_packets = 200;//jitter_buffer相关配置
    options.audio_jitter_buffer_fast_accelerate = false;
    options.audio_jitter_buffer_min_delay_ms = 0;
    options.audio_jitter_buffer_enable_rtx_handling = false;
    options.typing_detection = true;//键盘声音检测
    options.experimental_agc = false;//实验性增益控制
    options.experimental_ns = false;//实验性降噪
    options.residual_echo_detector = true;//残留回声检测
```

> 高通滤波器：只允许某一频率以上的信号无衰减的通过滤波器，去掉了信号中低于该概率的不必要成分或者说去掉了低于该频率的干扰信号。

## WebRTCVoiceEngine初始化过程

> 在配置后面的可选项之前，需要先行初始化`WebRTCVoiceEngine`，保证配置参数可以生效。 



## AEC(回声消除)

> WebRTC中的`AEC`模块分为这几部分：`AECM(移动设备使用)`、`AEC3(实验模块)`、`AEC(PC使用)`，源码位于`modules/audio_processing/aec3、./aecm`

### 硬件AEC

> 由硬件设备提供的`AEC`功能，当开启该功能时会主动屏蔽掉软件实现的`AEC`功能.

通过配置`JavaAudioDeviceModule`实现硬件回声消除功能

```java
return JavaAudioDeviceModule.builder(context)
                .setUseHardwareAcousticEchoCanceler(true)//开启硬件降噪
                .createAudioDeviceModule();

# org.webrtc.audio.WebRtcEffects
//判断是否支持硬件AEC
public static boolean isAcousticEchoCancelerSupported() {
        return VERSION.SDK_INT < 18 ? false : isEffectTypeAvailable(AudioEffect.EFFECT_TYPE_AEC, AOSP_ACOUSTIC_ECHO_CANCELER);
    }
```



### 软件AEC

```java
return JavaAudioDeviceModule.builder(context)
                .setUseHardwareAcousticEchoCanceler(false)//开启硬件降噪
                .createAudioDeviceModule();
```



### AEC Native代码

```java
//Native获取当前是否开启硬件AEC    
@CalledByNative
    boolean isAcousticEchoCancelerSupported() {
        return this.isAcousticEchoCancelerSupported;
    }
```

在此处获取Java层配置的参数

```c++
// 源码位置：/sdk/android/src/jni/audio_device/audio_record_jni.cc
bool AudioRecordJni::IsAcousticEchoCancelerSupported() const {
  RTC_DCHECK(thread_checker_.IsCurrent());
  return Java_WebRtcAudioRecord_isAcousticEchoCancelerSupported(
      env_, j_audio_record_);
}
```

```c++
//源码位置：/sdk/android/src/jni/audio_device/audio_device/audio_device_module.cc
  bool BuiltInAECIsAvailable() const override {
    RTC_LOG(INFO) << __FUNCTION__;
    if (!initialized_)
      return false;
    bool isAvailable = input_->IsAcousticEchoCancelerSupported();
    RTC_LOG(INFO) << "output: " << isAvailable;
    return isAvailable;
  }
```

判断是否启用硬件AEC

```c++
pc/peer_connection_factory.cc -> channel_manager.cc -> media_engine.cc ->webrtc_voice_engine.cc
从media_engine.cc调用
//WebRTCVoiceEngine初始化
void WebRtcVoiceEngine::Init() {
  RTC_DCHECK(worker_thread_checker_.IsCurrent());
  RTC_LOG(LS_INFO) << "WebRtcVoiceEngine::Init";

  // TaskQueue expects to be created/destroyed on the same thread.
  low_priority_worker_queue_.reset(
      new rtc::TaskQueue(task_queue_factory_->CreateTaskQueue(
          "rtc-low-prio", webrtc::TaskQueueFactory::Priority::LOW)));

  // Load our audio codec lists.
  RTC_LOG(LS_VERBOSE) << "Supported send codecs in order of preference:";
  send_codecs_ = CollectCodecs(encoder_factory_->GetSupportedEncoders());
  for (const AudioCodec& codec : send_codecs_) {
    RTC_LOG(LS_VERBOSE) << ToString(codec);
  }

  RTC_LOG(LS_VERBOSE) << "Supported recv codecs in order of preference:";
  recv_codecs_ = CollectCodecs(decoder_factory_->GetSupportedDecoders());
  for (const AudioCodec& codec : recv_codecs_) {
    RTC_LOG(LS_VERBOSE) << ToString(codec);
  }

#if defined(WEBRTC_INCLUDE_INTERNAL_AUDIO_DEVICE)
  // No ADM supplied? Create a default one.
  if (!adm_) {
    adm_ = webrtc::AudioDeviceModule::Create(
        webrtc::AudioDeviceModule::kPlatformDefaultAudio, task_queue_factory_);
  }
#endif  // WEBRTC_INCLUDE_INTERNAL_AUDIO_DEVICE
  RTC_CHECK(adm());
  webrtc::adm_helpers::Init(adm());

  // Set up AudioState.
  {
    webrtc::AudioState::Config config;
    if (audio_mixer_) {
      config.audio_mixer = audio_mixer_;
    } else {
      config.audio_mixer = webrtc::AudioMixerImpl::Create();
    }
    config.audio_processing = apm_;
    config.audio_device_module = adm_;
    audio_state_ = webrtc::AudioState::Create(config);
  }

  // Connect the ADM to our audio path.
  adm()->RegisterAudioCallback(audio_state()->audio_transport());

  // Set default engine options.
  {
    AudioOptions options;
    options.echo_cancellation = true;
    options.auto_gain_control = true;
    options.noise_suppression = true;
    options.highpass_filter = true;
    options.stereo_swapping = false;
    options.audio_jitter_buffer_max_packets = 200;
    options.audio_jitter_buffer_fast_accelerate = false;
    options.audio_jitter_buffer_min_delay_ms = 0;
    options.audio_jitter_buffer_enable_rtx_handling = false;
    options.typing_detection = true;
    options.experimental_agc = false;
    options.experimental_ns = false;
    options.residual_echo_detector = true;
    bool error = ApplyOptions(options);
    RTC_DCHECK(error);
  }

  initialized_ = true;
}

//源码位置：/sdk/android/src/meida/engine/webrtc_voice_engine.cc
webrtc::AudioDeviceModule* WebRtcVoiceEngine::adm() {
  RTC_DCHECK(worker_thread_checker_.IsCurrent());
  RTC_DCHECK(adm_);
  return adm_.get();
}

//指向AudioProcessing配置
webrtc::AudioProcessing* WebRtcVoiceEngine::apm() const {
  RTC_DCHECK(worker_thread_checker_.IsCurrent());
  return apm_.get();
}
webrtc::AudioProcessing* ap = engine()->apm();
...
bool WebRtcVoiceEngine::ApplyOptions(const AudioOptions& options_in) {
  ...
//默认配置 options.echo_cancellation 为true
  if (options.echo_cancellation) {
    // Check if platform supports built-in EC. Currently only supported on
    // Android and in combination with Java based audio layer.
    const bool built_in_aec = adm()->BuiltInAECIsAvailable();//开启硬件AEC就为true
    if (built_in_aec) {
      // Built-in EC exists on this device. Enable/Disable it according to the
      // echo_cancellation audio option.
      const bool enable_built_in_aec = *options.echo_cancellation;
      if (adm()->EnableBuiltInAEC(enable_built_in_aec) == 0 &&
          enable_built_in_aec) {
        // Disable internal software EC if built-in EC is enabled,
        // i.e., replace the software EC with the built-in EC.
        options.echo_cancellation = false;
        RTC_LOG(LS_INFO)
            << "Disabling EC since built-in EC will be used instead";
      }
    }
  }
...
  //如果编译android源码，默认启用AECM
  #elif defined(WEBRTC_ANDROID)
  use_mobile_software_aec = true;
#endif
...
  //配置apm(AudioDeviceModule)参数
  if (options.echo_cancellation) {
    apm_config.echo_canceller.enabled = *options.echo_cancellation;
    apm_config.echo_canceller.mobile_mode = use_mobile_software_aec;
  }
...
  ap->ApplyConfig(apm_config);
  return true;
}
```

`options.echo_cancellation`参数配置完毕后需要应用参数

```c++
//源码位置：modules/audio_processing/audio_processing_impl.cc
void AudioProcessingImpl::ApplyConfig(const AudioProcessing::Config& config) {
  ...
  if (aec_config_changed) {
    InitializeEchoController();
  }
  ...
}

//初始化 AEC配置 
void AudioProcessingImpl::InitializeEchoController() {
  //是否启动回声消除
   bool use_echo_controller =
      echo_control_factory_ ||
      (config_.echo_canceller.enabled && !config_.echo_canceller.mobile_mode);
  
  if (use_echo_controller) {
    // Create and activate the echo controller.
    if (echo_control_factory_) {
      submodules_.echo_controller = echo_control_factory_->Create(
          proc_sample_rate_hz(), num_reverse_channels(), num_proc_channels());
      RTC_DCHECK(submodules_.echo_controller);
    } else {
      //AEC3模块
      EchoCanceller3Config config =
          use_setup_specific_default_aec3_config_
              ? EchoCanceller3::CreateDefaultConfig(num_reverse_channels(),
                                                    num_proc_channels())
              : EchoCanceller3Config();
      submodules_.echo_controller = std::make_unique<EchoCanceller3>(
          config, proc_sample_rate_hz(), num_reverse_channels(),
          num_proc_channels());
    }
    ...
  }

 ...
   //移动端AECM模块设置
   if (config_.echo_canceller.mobile_mode) {
    // Create and activate AECM.
    size_t max_element_size =
        std::max(static_cast<size_t>(1),
                 kMaxAllowedValuesOfSamplesPerBand *
                     EchoControlMobileImpl::NumCancellersRequired(
                         num_output_channels(), num_reverse_channels()));

    std::vector<int16_t> template_queue_element(max_element_size);

    aecm_render_signal_queue_.reset(
        new SwapQueue<std::vector<int16_t>, RenderQueueItemVerifier<int16_t>>(
            kMaxNumFramesToBuffer, template_queue_element,
            RenderQueueItemVerifier<int16_t>(max_element_size)));

    aecm_render_queue_buffer_.resize(max_element_size);
    aecm_capture_queue_buffer_.resize(max_element_size);

    submodules_.echo_control_mobile.reset(new EchoControlMobileImpl());

    submodules_.echo_control_mobile->Initialize(proc_split_sample_rate_hz(),
                                                num_reverse_channels(),
                                                num_output_channels());
    return;
  }
  submodules_.echo_control_mobile.reset();
  aecm_render_signal_queue_.reset();
  
}
```

#### AEC3

> TODO 简单算法介绍

参考类为`src/api/audio/echo_canceller3/echo_canceller3_config.cc`(AEC3配置项)

`echo_canceller3.cc`实际生效类



#### AECM

> AEC的移动端精简版，降低了计算的复杂度，相比于原版会有更明显的回声

参考类为`echo_control_mobile_impl.cc`

提供了如下配置项：

```c++
int16_t MapSetting(EchoControlMobileImpl::RoutingMode mode) {
  switch (mode) {
    case EchoControlMobileImpl::kQuietEarpieceOrHeadset:
      return 0;
    case EchoControlMobileImpl::kEarpiece:
      return 1;
    case EchoControlMobileImpl::kLoudEarpiece:
      return 2;
    case EchoControlMobileImpl::kSpeakerphone:
      return 3;
    case EchoControlMobileImpl::kLoudSpeakerphone:
      return 4;
  }
  RTC_NOTREACHED();
  return -1;
}
```





## NS(降噪)

> 主要源代码位于`modules/audio_processing/ns`

### 硬件NS

> 由硬件设备提供的NS功能，开启硬件降噪时，软件降噪关闭

通过配置`JavaAudioDeviceModule`实现硬件降噪功能

```java
return JavaAudioDeviceModule.builder(context)
                .setUseHardwareNoiseSuppressor(true)//开启硬件降噪
                .createAudioDeviceModule();

# org.webrtc.audio.WebRtcEffects
//判断是否支持硬件NS
    public static boolean isNoiseSuppressorSupported() {
        return VERSION.SDK_INT < 18 ? false : isEffectTypeAvailable(AudioEffect.EFFECT_TYPE_NS, AOSP_NOISE_SUPPRESSOR);
    }
```



### 软件NS

```java
return JavaAudioDeviceModule.builder(context)
                .setUseHardwareNoiseSuppressor(false)//开启硬件降噪
                .createAudioDeviceModule();
```



### NS Native代码

```java
//Native获取当前是否支持 硬件NS
@CalledByNative
    boolean isNoiseSuppressorSupported() {
        return this.isNoiseSuppressorSupported;
    }
```

获取Java端配置的参数

```c++
// 源码位置：/sdk/android/src/jni/audio_device/audio_record_jni.cc
bool AudioRecordJni::IsNoiseSuppressorSupported() const {
  RTC_DCHECK(thread_checker_.IsCurrent());
  return Java_WebRtcAudioRecord_isNoiseSuppressorSupported(env_,
                                                           j_audio_record_);
}

//源码位置：/sdk/android/src/jni/audio_device/audio_device/audio_device_module.cc
bool BuiltInNSIsAvailable() const override {
    RTC_LOG(INFO) << __FUNCTION__;
    if (!initialized_)
      return false;
    bool isAvailable = input_->IsNoiseSuppressorSupported();
    RTC_LOG(INFO) << "output: " << isAvailable;
    return isAvailable;
  }
```

判断是否启用硬件NS





## AGC(音频增益)

gain_controller1、gain_controller2

## VAD(静音检测)

 Voice_detection

## Other(其他模块)

### HighPassFilter(高通滤波）

## jitter_buffer



## WebRTC内部消息模型



## 相关链接

[AEC原理与实现](https://www.cnblogs.com/LXP-Never/p/11703440.html)]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Hot 100</title>
    <url>/2020/08/03/LeetCode-Hot-100/</url>
    <content><![CDATA[
LeetCode 1：两数之和

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] result = new int[2];

        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(target-nums[i])){
               int value = map.get(target-nums[i]);
               result[0] = value;
               result[1] = i;
               break;
            }
            map.put(nums[i],i);
        }

        return result;
        
    }
}
```



LeetCode 2：两数相加

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Android匿名共享内存-Ashmem</title>
    <url>/2020/10/31/Android%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-Ashmem/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java-CountDownLatch原理及解析</title>
    <url>/2020/10/08/Java-CountDownLatch%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java-AQS-Condition原理及解析</title>
    <url>/2020/10/08/Java-AQS-Condition%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Kotlin-泛型</title>
    <url>/2020/09/21/Kotlin-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Kotlin协程原理</title>
    <url>/2020/09/04/Kotlin%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>设计模式整体回顾</title>
    <url>/2020/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%95%B4%E4%BD%93%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机网络基础</title>
    <url>/2018/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[
<!--TCP三次握手、四次挥手。 http请求报文结构、响应报文，状态码。 http2.0相比于http1.0的新特性，推送、多路复用、消息头压缩等 。Https的原理？Tcp和Udp的区别？Http的报文结构？cookie是用来干嘛的？有哪些响应码，分别都代表什么意思？有自己实现过Socket协议吗？互联网的实现主要分为几层，http、ftp、tcp、ip分别位于哪一层。http和https的区别为什么tcp要经过三次握手，四次挥手socket了解过吗 TCP保证可靠传输的实现：停止等待协议、滑动窗口协议、流量控制、拥塞控制等 HTTPS SSL
TCP/IP三次握手 Tcp 三次握手四次挥 get 与 post 的区别--->

<!--7 Http和Https的区别？-->
<!--1）Https是ssl加密传输，Http是明文传输-->
<!--2）Https是使用端口443，而Http使用80-->
<!--3）HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全-->
<!--4）Https协议需要到CA申请证书-->
<!--8 加密算法有哪些？对称加密和非对称加密的区别？-->
<!--MD5，SHA1，Base64，RSA，AES，DES-->
<!--对称：使用相同密钥，需要在网络传输，安全性不高。-->
<!--非对称：使用一对密钥，公钥和私钥，私钥不在网络传输，因此安全性高。-->
<!--9 TCP的三次握手？两次行不行？为什么？TCP攻击知道吗？如何进行攻击？-->

{% fullimage /images/计算机网络基础.png,TCP、UDP协议,TCP、UDP协议%}

## 网络分层

> 将网络节点所要完成的数据的发送或转发、打包或拆包，以及控制信息的加载或拆出等工作，分别由不同的硬件或软件模块来完成。

计算机网络体系结构分为3种：`OSI体系结构`、`TCP/IP体系结构`、`五层体系结构`。

> - `OSI体系结构`：概念清楚并且理念完整，但复杂且不实用
> - `TCP/IP体系结构`：包含了一系列构成互联网基础的网络协议，是`Intenet`的核心协议并且被广泛应用于局域网和广域网
> - `五层体系结构`：融合了`OSI`与`TCP/IP`的体系结构。

{% fullimage /images/计算机网络体系结构.png,计算机网络体系结构,计算机网络体系结构%}

以下主要分析 `五层协议`

{% fullimage /images/网络模型(五层协议).png,网络模型(五层协议),网络模型(五层协议)%}

### 物理层

> 传输数据单位为比特(`bite`)，负责比特流在节点间的传输，即负责物理传输。例如光纤等

具体协议：无

### 数据链路层

> 控制网络层与物理层之间的通信，主要功能是如何在不可靠的物理线路上进行数据的可靠传递。
>
> 链路层使用的信道主要有两种类型：
>
> - 点对点信道
> - 广播信道

具体协议：逻辑链路控制 LLC、媒体介入控制 MAC

### 网络层

> 如何将数据从发送方到接收方。将`数据报`从一台主机移动到另一台主机。

具体协议：IP协议、因特网控制报文协议ICMP

### 传输层/运输层

> 为两台主机上的应用程序提供通用的数据传输服务，传输内容为`应用层报文`。

具体协议：传输控制协议 TCP、用户数据报协议 UDP

### 应用层

> 网络应用程序和网络协议储存的分层。网络应用程序接收到传输层的数据后，就需要进行解读。

具体协议：文件传输协议 FTP、超文本传输协议 HTTP、域名系统 DNS

## TCP协议

> `Transmission Control Protocol`——传输控制协议 **主要用于传输层**

### 特点

| 特点       | 具体描述                                                     |
| ---------- | ------------------------------------------------------------ |
| 面向连接   | 使用TCP传输数据前，必须先建立TCP连接；传输完成后在释放连接   |
| 面向字节流 | 虽然应用程序和TCP的交互是一次一个数据块，但TCP只把数据看外一连串无结构的字节流。数据以流的形式传输 |
| 全双工通信 | 建立TCP连接后，通信双方都能发送数据                          |
| 可靠       | 通过TCP传输的数据：不丢失、无差错、不重复，按序到达          |

### 优缺点

优点：数据传输可靠

缺点：效率低（因为连接过程比较复杂）

### 应用场景

- 传输文件：HTTP、HTTPS、FTP等协议
- 传输邮件：POP、SMTP等协议

### 报文段格式

报文段分为两部分：

TCP首部：全部功能体现于此，最小长度为20字节。

TCP数据：传输的数据

| TCP首部字段                              | 作用                                           | 备注                                                         |
| ---------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 序号<br>Sequence Number(**seq**)         | 本报文段所发送数据的第一个字节序号             | 占4字节                                                      |
| 确认号<br>Acknowledgment Number(**ACK**) | 期望收到对方下一个报文段的第一个数据字节的序号 | 占4字节<br>若ACK为n，代表到序号n-1之前的数据都已正确收到     |
| 同步位<br>**SYN**                        | 连接建立时用于同步序号                         | SYN = 1,ACK = 0，表示是连接请求报文段<br>SYN = 1,ACK = 1，表示连接请求响应报文段 |
| 终止控制位<br>**FIN**                    | 释放连接                                       | FIN = 1表示此报文段的发送方已发送数据完毕并要求释放连接      |



### 建立连接过程——三次握手

{% fullimage /images/TCP三次握手过程.webp,TCP三次握手过程,TCP三次握手过程%}

客户端主动打开连接，服务器被动打开连接，然后进入`LISTEN(监听)`状态，等待接收客户端的请求。

#### 第一次握手——客户端发送连接请求报文段到服务端

设置`SYN = 1，seq = x`；然后客户端进入`SYN-SENT(同步已发送)`状态，等待服务端确认。

#### 第二次握手——服务器收到客户端请求连接报文段，对报文段内容进行确认

设置`ack = x+1、SYN = 1，seq为y`一并加入报文段中，发送给客户端；然后服务端进入`SYN_RCVD(同步已接收)`状态。

#### 第三次握手——客户端收到服务端确认连接报文段，然后向服务端发送连接确认报文段

客户端收到服务端发出的`SYN+ACK`报文段；然后设置`ACK = y+1`，在向服务端发出`ACK`报文段，确认连接。然后客户端和服务端都进入`ESTABLISHED(TCP连接成功)`状态。

完成上述TCP的三次握手过程后，TCP连接建立完成，即可传送应用层数据。

> 由于TCP是全双工通信，服务端和客户端在任何时候都可以互相发送数据。
>
> 如果三次握手期间，任何一次没有收到对方的回复，都需要进行重发。**超时重发机制**

#### 为什么需要进行三次握手？

**防止服务端因接受了早已失效的连接请求报文，从而一直等待客户端请求，最终导致死锁，形成资源浪费。**

> SYN洪范攻击：利用了TCP的三次握手机制。模拟多个客户端发起连接请求，然后不处理服务端返回请求，这样就会导致服务端持续挂起，大量请求时会快速耗尽服务器资源，导致死机。
>
> 服务端的TCP资源分配发生在第二次握手结束时；客户端的TCP资源分配发生在第三次握手结束时。
>
> 如何对这种攻击进行防范？
>
> **优化主机系统设置，如降低SYN timeout时间；设置cookie，如果短时间内连续收到同IP请求，则对该IP的请求进行抛弃。**

### 释放连接过程——四次挥手

{% fullimage /images/TCP四次挥手过程.webp,TCP四次挥手过程,TCP四次挥手过程%}

#### 第一次挥手——客户端向服务端发送连接释放报文段

设置`FIN = 1`发送至服务端；客户端进入`FIN_WAIT_1(终止等待1)`状态，此时客户端没有数据在需要发送了。

#### 第二次挥手——服务端收到连接释放报文段，再向客户端发送连接释放确认报文段

设置`ACK = 1`发送至客户端；服务端进入`CLOSE_WAIT(关闭等待)`状态，客户端收到连接释放确认请求后，会进入`FIN_WAIT_2(终止等待2)`状态，等待服务端的释放连接请求。

**此时客户端 -> 服务端的连接已断开**

#### 第三次挥手——若服务端没有再发送数据，则发出释放连接的报文段

设置`FIN = 1`发送至客户端，请求关闭连接；服务端进入`LAST_ACK(最后确认)`状态。

#### 第四次挥手——客户端收到服务端的连接释放报文段，再向服务端发出连接释放确认报文段

客户端收到服务端连接释放请求，再向服务端发送释放连接确认报文段，客户端进入`TIME_WAIT(时间等待)`状态。

服务端收到释放连接确认报文段后，服务端进入`CLOSED(关闭)`状态。

客户端等待`2MSL`后依然没有收到回复，客户端进入`CLOSED(关闭)`状态。

#### 为什么TCP释放需要四次挥手？

**为了保证通信双方都通知到对方释放并断开连接。释放连接后，相互都无法发送和接收消息。**

#### 为什么需要等待`2MSL`时间没有回复在关闭？

> MSL：最长报文段寿命

1. 为了保证客户端发送的最后一个连接释放确认报文可以到达服务端，使得服务端可以释放连接
2. 防止**早已失效的连接请求报文**出现在本次连接中。在`2MSL`时间内，在本连接中产生的所有报文都会消失。



### 可靠性保证

主要分析的是如何保证TCP传输的可靠性。

> 无论发送方以多块的速度发送数据，接收方总来得及处理收到的数据。

#### 核心思想

> **出错重传**：出现差错时，让发送方重新传输数据
>
> **速度匹配**：当接收方来不及接收收到的数据时，通知发送方降低发送数据的效率。

#### 滑动窗口协议

> 是**传输层进行流控**的一种措施，接收方通过告知发送放自己的窗口大小，从而控制发送方的发送速度，达到防止发送方发送速度过快导致自己被淹没的目的。

滑动窗口分为以下两部分：

| 类型     | 定义                                                 | 作用                                                         |
| -------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| 发送窗口 | 任意时刻，发送方维持的一组连续的，允许发送帧的帧序号 | 对发送方进行流量控制                                         |
| 接收窗口 | 任意时刻，接收方维持的一组连续的，允许接收帧的帧序号 | 控制可以接收的数据帧以及不可接收的数据帧<br>接收方只有当收到的数据帧的序号落入接收窗口才允许收下该数据帧；否则，丢弃。 |

##### 工作原理

对于TCP的发送方

每收到一个确认帧，发送窗口就向前滑动一个帧的距离。当发送窗口内没有可以发送的帧时(窗口内的帧全部为已发送但未收到确认的帧)，发送方停止发送，直到收到接收方发送的确认帧使发送窗口移动，然后发送窗口内还有可以发送的帧则继续发送。

> 发送缓存内的数据可以分为4类：
>
> - 已经发送并得到确认帧
> - `已经发送还未收到确认帧`
> - `未发送但对端允许发送`
> - 未发送且对端不允许发送
>
> `已经发送还未收到确认帧、未发送但对端允许发送`就是发送窗口

{% fullimage /images/滑动窗口协议-发送窗口.png,滑动窗口协议-发送窗口,滑动窗口协议-发送窗口%}

其中黑框部分就是**发送窗口**。

对于TCP的接收方

收到发送方的数据帧后，接收窗口向前移动一个帧位置，并发回确认帧到发送端，若收到的数据帧不在接收窗口内，则丢弃。

> 接收缓存内的数据可以分为3类：
>
> - 已接收数据帧
> - `未接受准备接收`
> - 未接受且为准备接收
>
> `未接受准备接收`就是接收窗口

{% fullimage /images/滑动窗口协议-接收窗口.png,滑动窗口协议-接收窗口,滑动窗口协议-接收窗口%}

其中黑框部分就是**接收窗口**。

##### 重要性

1. 只有接收窗口向前滑动，并且发送了确认帧到发送端时，发送窗口可以向前滑动
2. 当接收窗口的大小为1时，可以保证帧有序接收



#### 自动重传协议ARQ

分为以下3类：

- 停止-等待协议：发送窗口大小为1，接收窗口大小为1；**单帧滑动窗口**

  > 发送方每发送一帧，要等到接收方返回的确认帧才可以继续发送下一帧
  >
  > 接收方每接收一帧，都要返回一个确认帧到发送方，表示可以接收下一帧
  >
  > 接收方不返回确认帧，发送方一直等待

- 后退N帧协议：发送窗口大小>1，接收窗口大小为1

  > 发送方连续发送多个数据帧，不需要等到接收方确认
  >
  > 接收方采用**累计确认&后退N帧**的原理，只允许按顺序接收帧
  >
  > **累计确认**：收到多个数据帧后，只对按顺序到达的最后一帧发送确认帧，不必所有都去发送确认帧
  >
  > **后退N帧**：退回已发送过的N帧

- 选择重传协议：发送窗口大小>1，接收窗口大小>1

  > 发送方连续发送多个数据帧，不需要等到接收方确认
  >
  > 接收窗口与发送窗口一样大，接收窗口直到数据填满再返回确认帧，否则需要发送方进行重传。



#### 流量控制&拥塞控制

##### 流量控制

> 接收方根据自己接收缓存的大小，动态调整发送窗口大小，从而控制发送方的发送速率。

容易出现**死锁问题**。当报文段在传送过程中丢失时，此时会出现发送方一直等待接收 接收方的非零窗口通知，然后接收方一直在等待发送方的数据，形成了死锁。

解决方案：TCP为每一个连接设有一个持续计时器(*persistence timer*)，只要TCP连接的一方收到对方的零窗口通知，就启动该计时器，若计时器计时结束，就会发出一个零窗口探测报文段。对方就会给出此时的窗口值：为0则需重新设置计时器，不为0 就要打破死锁。

##### 拥塞控制

> 防止过多的数据注入到网络中，使得网络中的路由器和链路不至于过载。

具体解决方案分为两种：

###### 慢开始和拥塞避免

慢开始

> 当主机开始发送数据时，由小到大逐渐增大**拥塞窗口(发送窗口)数值**，从而由小到大逐渐增大发送报文段。

拥塞避免

> 使得拥塞窗口**按线性规律缓慢增长**；没经过一个往返时间*RTT*，发送方的拥塞窗口加1。

###### 快重传和快恢复

快重传

> 接收方 每收到一个失序的报文段后，就立即发出**重复确认**，而不是等到自己发出数据时再带上确认数据
>
> 发送方 只要连续收到3个**重复确认**就立即重传对方尚未收到的报文段，不必等到设置的重传计时器到点。

快恢复

> **是一个非常激进的算法。**
>
> 先执行**乘法减小算法**，设置**慢开始门限(`ssthresh`)**为当前发送窗口大小的一半
>
> 再设置**拥塞窗口(`cwnd`)**为**慢开始门限(`ssthresh`)**的一半
>
> 再执行**加法增大算法**，执行拥塞避免算法，线性加大发送窗口。

## UDP协议

> `User Datagram Protocol`——用户数据报协议 **主要用于传输层**

### 特点

| UDP特点    | 具体描述                                                 |
| ---------- | -------------------------------------------------------- |
| 无连接     | 使用UDP传输数据，不需要建立连接                          |
| 不可靠     | UDP的数据包发送后，不管其是否会到达接收方                |
| 面向报文   | 数据 以**数据报文(包)**的形式传输                        |
| 无拥塞控制 | 由于是不可靠传输，不管是否到达接收方，所以不需要拥塞控制 |

### 优缺点

优点：速度快

缺点：消息易丢失(*尤其是网络较差时*)

### 应用场景

**要求通信速度快，且不在乎结果。**

> 域名转换 DNS协议、文件传输 FTP协议

当前的游戏、视频、即时通信工具也多用UDP协议传输数据，但也会辅以TCP协议进行数据完善。

### 报文段格式

分为两部分：**首字段、数据字段**。

| 字段     | 作用                              | 描述            |
| -------- | --------------------------------- | --------------- |
| 源端口   | 源端口号，需要对方回信时使用      |                 |
| 目的端口 | 目的端口号，终点交付报文时使用    |                 |
| 长度     | UDP用户数据报的长度               | 最小值 8        |
| 校验和   | 检测UDP用户数据报在传输中是否有错 | 出错则丢弃      |
| 伪首部   | 计算校验和（不会发送出去）        | 不在UDP首部范围 |

### 与TCP协议的区别

1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5. TCP首部开销20字节;UDP的首部开销小，只有8个字节
6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道



## HTTP协议

{% fullimage /images/HTTP协议.png,HTTP协议,HTTP协议%}

> `HyperText Trsnsfer Protocol`——超文本传输协议 **主要用于应用层**。基于TCP协议传输，端口号为80
>
> **HTTP是一个在计算机世界专门在两点之间传输文字，图片、音频等超文本数据的约定与规范。**

### 版本

#### HTTP1.0

- 默认短连接
- 除了GET命令外还增加了POST、HEAD命令

#### HTTP1.1 (**目前最流行版本**)

- 默认长连接
- 增加更多的请求头和响应头
- 增加身份认证、状态管理功能
- 支持分块传输编码

#### HTTP2.0

- **新的二进制格式**：之前都是用解析文本的方式
- **多路复用**
- **服务端推送**：在客户端请求资源时，会把相关资源一起发给客户端，就不需要客户端再次请求。
- **消息头压缩**：客户端和服务端同时维护和更新一个首部字段表，避免重复传输

### 响应状态码

> 位于服务端返回**响应报文**中的第一行，包含了状态码以及原因短语，用来告知客户端请求结果。

| 状态码 | 类别                           | 含义                     |
| ------ | ------------------------------ | ------------------------ |
| 1XX    | Informational(信息性状态码)    | 接收请求正在处理         |
| 2XX    | Success(成功状态码)            | 请求正常处理完毕         |
| 3XX    | Redirection(重定向状态码)      | 需要进行附加操作完成请求 |
| 4XX    | Client Error(客户端错误状态码) | 服务器无法处理请求       |
| 5XX    | Server Error(服务端错误状态码) | 服务器处理请求出错       |

#### 1XX 信息性状态码

- **100 Continue** ：客户端继续发送请求

#### 2XX 成功状态码

- **200 OK**：请求成功
- **204 No Content**：请求成功处理，但没有返回数据
- **206 Partial Content**：客户端进行了范围请求，响应报文包含了`Content-Range`

#### 3XX 重定向状态码

- **301 Moved Permanently**：永久性重定向
- **302 Found**：临时性重定向

#### 4XX 客户端错误状态码

- **400 Bad Request**：请求报文存在语法错误
- **401 Unauthorized**：用户认证失败
- **403 Frobidden**：请求拒绝
- **404 Not Found**

#### 5XX 服务端出错状态码

- **500 Internal Server Error**：服务器执行请求时发生错误
- **503 Server Unavaliable**：服务器无法处理请求

### HTTP请求方法

> 位于**请求报文**第一行，包含了方法字段

| 请求方法 | 作用                           | 描述                                                         |
| -------- | ------------------------------ | ------------------------------------------------------------ |
| GET      | 获取资源                       | 客户端需要从服务器读取资源时使用<br>一般用于获取/查询信息<br>通过URL传递且参数长度是有限制的<br>请求格式 ` /test/result?key=key&page=1`<br>请求是安全的，因为只读，不会改变服务器数据 |
| POST     | 传输实体主体                   | 客户端向服务端提供信息时使用<br>可以附带数据，用于更新服务器数据<br>将请求参数封装在请求数据中，可传输大量数据<br>传参方式更加安全，但是请求是不安全的，会导致服务器数据发生改变 |
| HEAD     | 获取报文首部                   | 不返回报文实体部分，主要用于确认URL有效性以及资源更新日期    |
| PUT      | 上传文件                       | 自身不带验证机制，存在安全性问题。**一般不使用**             |
| PATCH    | 对资源部分进行修改             | 可以部分对资源进行修改                                       |
| DELETE   | 删除文件                       | 自身不带验证机制，存在安全性问题。                           |
| OPTIONS  | 查询支持的方法                 | 查询指定的URL可以提供的方法。<br>返回示例：`Allow: GET , POST` |
| CONNECT  | 要求与代理服务器通信时建立隧道 | 对通信内容进行加密后通过网络隧道传输                         |
| TRACE    | 追踪路径                       | 将通信路径返回给客户端                                       |



### HTTP报文结构

> 分为两部分：
>
> - **请求报文**：用于发送请求时
> - **响应报文**：用于响应请求时

#### 请求报文

{% fullimage /images/HTTP_RequestMessage.png,请求报文,请求报文%}

##### 请求行

声明请求方法、主机域名和协议版本

> 基本格式： **Method Request-URI HTTP-Version CRLF**
>
> Method：表示请求方法，例如`GET、POST...`
>
> Request-URI：统一资源标识符，例如`https://leo-wxy.github.io/`
>
> HTTP-Version：HTTP协议版本，例如`HTTP/1.1 HTTP/2.0`
>
> CRLF：表示回车和换行，`\r\n`
>
> 示例数据： `GET http://leo-wxy.github.io/ HTTP/1.1 `

##### 请求头

声明客户端、服务器/报文的部分信息

> 基本格式：**header(字段名) : value(值)**

报文通用Header(*可用于请求报文和响应报文*)

| 首部字段名    | 描述                                                      |
| ------------- | --------------------------------------------------------- |
| Cache-Control | 控制缓存的行为                                            |
| Connection    | 允许发送指定连接的选项。例如`close`响应完成后，关闭服务器 |
| Date          | 表示消息产生的日期和时间                                  |

请求报文Header

| 首部字段名      | 描述                 |
| --------------- | -------------------- |
| Host            | 请求资源所在服务器   |
| User-Agent      | HTTP客户端程序的信息 |
| Accept          | 用户可处理的媒体类型 |
| Authorization   | Web认证信息          |
| Accept-Encoding | 优先的内容编码       |

POST请求时的实体首部字段

| 首部字段名     | 描述                                 |
| -------------- | ------------------------------------ |
| Allow          | 可支持的HTTP方法                     |
| Content-Length | 请求体/响应体的长度，单位字节        |
| Content-Type   | 请求体/响应体的类型，例如`text/html` |

##### 请求数据(请求体)

存放客户端发送给服务器的数据信息，如果为`GET`请求则没有该结构

使用方式共3种：

- 数据交换
- 键值对
- 分部分形式

##### 请求报文示例

| 请求行     | **GET /test/index.html HTTP/1.1** |
| ---------- | --------------------------------- |
| **请求头** | Host : www.github.io              |
|            | User-Agent : Mozilla/5.0          |
| **空行**   | (用于隔开请求头和请求体)          |
| **请求体** | id=0&page=1                       |

#### 响应报文

{% fullimage /images/HTTP_ResponseMessage.png,响应报文,响应报文%}

##### 状态行

声明协议版本、状态码和描述

> 基本格式： **HTTP-Version Status-Code Reason-Parse CRLF**
>
> HTTP-Version：HTTP协议版本，例如`HTTP/1.1 HTTP/2.0`
>
> Status-Code：服务器返回的状态码，对应上面的[响应状态码](#响应状态码)
>
> Reason-Parse：状态码的文本描述，对应上面的[响应状态码](#响应状态码)
>
> CRLF：表示回车和换行，`\r\n`
>
> 示例数据： `HTTP/1.1 404 Not Found `

##### 响应报头

声明客户端，服务端报文的部分信息

> 基本格式：**header(字段名) : value(值)**

常见响应报头Header

| 首部字段名 | 描述                                       |
| ---------- | ------------------------------------------ |
| Location   | 客户端重定向URL，用在更换域名时            |
| Server     | HTTP服务器的安装信息，与User-Agent是对应的 |
| Age        | 推算资源创建经过的时间                     |

##### 响应正文

存放返给客户端的数据信息

使用方式共3种：

- 数据交换
- 键值对
- 分部分形式

##### 响应报文示例
| 状态行       | HTTP/1.1 200 OK            |
| ------------ | -------------------------- |
| **响应报头** | Connection : keep-alive    |
|              | Server : Nginx             |
| **空行**     | (用于隔开响应头和响应正文) |
| **响应正文** | {"error":false,"result":1} |

### Cookie

HTTP/1.1中引入了Cookie来保存状态信息。

Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被带上，用于告知服务器两个请求来自同一浏览器。每次都携带，会带来额外的性能开销。

### 长连接

HTTP/1.1之后默认支持长连接。*数据传输完成后TCP连接不会断开，继续使用该通道传输数据。*

#### 如何建立长连接？

设置HTTP Header：Connection

> Connection对应两种值：Connection : close 或 Connection ： Keep-Alive
>
> `close`：表示不使用长连接
>
> `keep-alive`：表示开启长连接，还有两个Header设置长连接相关属性
>
> - `Keep-Alive:max`：设置连接失败最大尝试次数，超过则断开
> - `Keep-Alive:time`：设置最大超时时间，超过则断开

#### 关闭长连接

- 判断传输数据是否达到了`Content-Length`指示的大小
- 根据`chunked编码`判断，若`chunked编码`在最后有一个空块，表明本次传输结束

## HTTPS

{% fullimage /images/HTTPS.png,HTTPS基础知识,HTTPS基础知识%}

HTTP有以下安全问题：

- 使用明文进行通信，内容可能会被窃听
- 不验证通信方的身份，通信方的身份可能遭遇伪装
- 无法验证报文的完整性，报文内容可能被篡改

HTTPS是建立在`SSL/TLS安全协议上的`，这套协议运行在`TCP协议`上；会对传输的内容进行加密；使用端口443。

通过使用SSL，HTTPS就具有了**加密(防窃听)、认证(防伪装)，完整性保护(防止报文被篡改)**功能。

### 加密

#### 对称密钥加密

> 加密和解密使用同一密钥。

优点：运算速度快

缺点：无法安全的将密钥传给客户端，安全性不高

具体算法：

DES算法，RC5算法、AES算法

{% fullimage /images/对称密钥加解密过程.png,对称密钥加解密过程,对称密钥加解密过程%}

#### 非对称密钥加密

> 加密和解密使用不同的密钥。分别是**公钥，私钥**。
>
> 公钥所有人都可以获得，通信方得到公钥后，就可以对发送内容进行加密，然后传递至服务端，服务端就可以利用私钥进行解密。
>
> 私钥还可以对服务端返回内容进行签名，利用公钥去验证签名是否正确，防止被人篡改。

优点：可以更安全的将公钥传输给客户端，服务端持有私钥，不会暴露

缺点：加密解密速度慢

具体算法：

RSA算法

{% fullimage /images/非对称密钥加解密过程.png,非对称密钥加解密过程,非对称密钥加解密过程%}

#### HTTPs采用的加密方式

HTTPS采用了**混合加密机制**，使用`非对称闭钥的公钥`加密对称密钥来保证传输的安全性，之后服务端使用私钥解密出`对称加密密钥`，然后双方使用对称密钥来加密报文进行互相传输。

{% fullimage /images/HTTPS加密过程.png,HTTPS加密过程,HTTPS加密过程%}

步骤1：客户端发起HTTPS请求

步骤2：服务端配置非对称加密的公钥、私钥

步骤3：传送公钥到客户端

步骤4：客户端判断公钥是否有效，无效则显示警告。证书没有问题则会生成一个随机值，使用传递的公钥进行加密

步骤5：客户端传送加密后的随机值到服务端

步骤6：服务端使用私钥解密传递过来的数据，得到客户端生成的随机值，利用该随机值对传输数据进行加密

步骤7：服务端传输加密后的数据到客户端

步骤8：客户端使用上次生成的随机值对服务端传输的数据进行解密,整套流程结束。

#### 中间人攻击

> 服务端在传输公钥的时候，可能中途被拦截，然后中间人对公钥进行篡改。这时在向下传递的公钥就完全是错误的，导致后续流程全部产生问题。

### 认证

> 通过使用**证书**来对通信方进行认证。
>
> `数字证书认证机构(CA,Certificate Authority)`是客户端和服务端都可以信任的第三方机构。
>
> 服务端向CS申请公钥，CA对申请者身份认证通过后，会对公钥进行数字签名，然后分配公钥，再将公钥与证书进行绑定。进行HTTPS通信时，服务器吧证书也发给客户端，客户端可以利用证书对传递的公钥进行验证，验证通过后就可以继续后续的通信。

### 完整性保护

> SSL提供报文摘要功能进行完整性保护。

HTTP的报文摘要功能是通过`MD5`实现的，中途被篡改了，然后重新MD5，客户端是无法感知内容已经发送变化。

HTTPs 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

### HTTPS缺点

1. HTTPS协议握手阶段比较费时，因为需要进行加密/解密过程
2. SSL证书是需要钱的，越高级的越贵
3. HTTPS加密范围有限，而且证书也不是一定可以完全信任的。

## Socket

Socket是通信的基石，是对`TCP/IP协议`的封装，是接口而非协议。创建Socket连接时可以指定传输层协议TCP或者UDP；

Socket建立连接过程分为三步：

1. 服务端监听
2. 客户端请求
3. 连接确认

应用层可以和传输层通过Socket，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。



## DNS协议



## 其他

### 地址栏中输入url会发生什么

- 浏览器向DNS服务器请求解析该url中的域名对应的IP地址
- 解析得到IP地址后，根据IP地址和端口，与服务器建立TCP连接
- 浏览器发出读取文件的HTTP请求
- 服务器对浏览器请求做出响应，返回html文本到浏览器
- 根据Header中的`Connection`判断是否需要释放TCP连接，若为`close`则关闭连接；为`keep-alive`则保持该连接一段时间，可以继续接受服务器数据
- 浏览器解析服务端返回的html文本并显示

### `CDN`

> 全称为`Content Delivery Network(内容分发网络)`，使用到了`HTTP协议`里的缓存和代理技术，代替源站响应客户端的请求。
>
> ​	



## 参考链接

[计算机网络高频面试解析 ](https://juejin.im/post/5e38160a6fb9a07c7c2d4e78)

[HTTP协议](https://juejin.im/post/5e1870736fb9a02fef3a5dcb)

]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LruCache原理</title>
    <url>/2018/12/14/LRUCache%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[
# LruCache

> 一般来说，缓存的策略主要包含缓存的`添加、获取和删除`。但由于缓存的大小都是有上限的。缓存慢了之后，要想继续添加 ，就需要删除一些旧的缓存以提供空间。
>
> 所以使用到了`LruCache`缓存算法，即**最近最少使用**算法，当缓存满时，会优先淘汰掉 最近最少使用的缓存对象。

**LruCache的核心原理就是利用了LinkedHashMap**。

## LruCache的使用

```java
        int maxMemory = (int)(Runtime.getRuntime().totalMemory()/1024);
        //设置LruCache缓存的大小
        int cacheSize = maxMemory/8;
        LruCache memoryCache = new LruCache<String,Bitmap>(cacheSize){
            @Override
            protected int sizeOf(@NonNull String key, @NonNull Bitmap value) {
                //重写sizeof方法，计算需要缓存的图片大小
                return value.getRowBytes() * value.getHeight() / 1024;
            }
        };
```

## LruCache的实现原理

`LruCache内部需要维护好一个缓存对象列表，其中对象的排列方式应该按照访问顺序排列的，即一直没访问的对象，要放在队尾，最近访问的对象就会放在对头，最晚被淘汰。`

查看源码中发现内部是利用了`LinkedHashMap`去缓存对象的。

```java
//LruCache构造方法
private final LinkedHashMap<K, V> map;    
public LruCache(int maxSize) {
        if (maxSize <= 0) {
            throw new IllegalArgumentException("maxSize <= 0");
        } else {
            this.maxSize = maxSize;
            this.map = new LinkedHashMap(0, 0.75F, true);
        }
    }

//LinkedHashMap的构造方法
public LinkedHashMap(/*map初始化大小*/int initialCapacity,
                         /*初始负载因子*/float loadFactor,
                         /*accessOrder意为访问顺序，若为true按照访问顺序排列，false则为插入顺序排列*/
                     boolean accessOrder) {
        super(initialCapacity, loadFactor);
        this.accessOrder = accessOrder;
    }

```

在`LruCache`构造方法中，设置了`maxSize`以及创建一个`LinkedHashMap`对象用来存储对象。

`LruCache`中需要移除最近最少使用的对象，即为优先删除访问最早对象，所以应该按照访问顺序排列，为true。

```java
//LruCache获取key对应的value 
public final V get(K key) {
        if (key == null) {
            throw new NullPointerException("key == null");
        }

        V mapValue;
        synchronized (this) {
            //返回不为null，就将其移到队列头部
            mapValue = map.get(key);
            if (mapValue != null) {
                hitCount++;
                return mapValue;
            }
            missCount++;
        }
        //当获取不到value的时候，会调用create()
        V createdValue = create(key);
        if (createdValue == null) {
            return null;
        }

        synchronized (this) {
            createCount++;
            mapValue = map.put(key, createdValue);

            if (mapValue != null) {
                // There was a conflict so undo that last put
                map.put(key, mapValue);
            } else {
                size += safeSizeOf(key, createdValue);
            }
        }

        if (mapValue != null) {
            entryRemoved(false, key, createdValue, mapValue);
            return mapValue;
        } else {
            trimToSize(maxSize);
            return createdValue;
        } 
   
 }
```

LruCache的`get()`实际调用的就是`LinkedHashMap`对应的`get(key)`

```java
public V get(Object key) {
        Node<K,V> e;
        if ((e = getNode(hash(key), key)) == null)
            return null;
        //如果按照访问顺序排列 则需要将该get对象移到尾部
        if (accessOrder)
            afterNodeAccess(e);
        return e.value;
    }

    /**
     * The head (eldest) of the doubly linked list.
     */
transient LinkedHashMapEntry<K,V> head;

    /**
     * The tail (youngest) of the doubly linked list.
     */
transient LinkedHashMapEntry<K,V> tail;
//将节点移到双端链表的尾部
void afterNodeAccess(Node<K,V> e) { // move node to last
        LinkedHashMap.Entry<K,V> last;
        if (accessOrder && (last = tail) != e) {
            LinkedHashMap.Entry<K,V> p =
                (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
            p.after = null;。 
            if (b == null)
                head = a;
            else
                b.after = a;
            
            if (a != null)
                a.before = b;
            else
                last = b;
            
            if (last == null)
                head = p;
            else {
                p.before = last;
                last.after = p;
            }
            tail = p;
            ++modCount;
        }
    }
```

先调用`getNode()`获取key对应节点，如果不存在则返回null。若存在并且需要按照访问顺序排列，就把找到的节点移到双端链表的尾部。

 ```java
public final V put(K key, V value) {
        if (key == null || value == null) {
            throw new NullPointerException("key == null || value == null");
        }

        V previous;
        synchronized (this) {
            putCount++;
            //增加已有缓存大小
            size += safeSizeOf(key, value);
            //返回关键过这个key的对象
            previous = map.put(key, value);
            //若存在已关联对象 则恢复原先缓存大小
            if (previous != null) {
                size -= safeSizeOf(key, previous);
            }
        }

        if (previous != null) {
            entryRemoved(false, key, previous, value);
        }
        //每次put后，需要重新调整缓存大小避免超过上限
        trimToSize(maxSize);
        return previous;
    }

 ```

在调用`put`过后，需要调用一次`trimToSize()`调整缓存对象。

```java
    public void trimToSize(int maxSize) {
        while(true) {
            Object key;
            Object value;
            synchronized(this) {
                if (this.size < 0 || this.map.isEmpty() && this.size != 0) {
                    throw new IllegalStateException(this.getClass().getName() + ".sizeOf() is reporting inconsistent results!");
                }
                //直到缓存大小size<=最大缓存值maxSize
                if (this.size <= maxSize || this.map.isEmpty()) {
                    return;
                }
                //取出双链表中的头元素
                Entry<K, V> toEvict = (Entry)this.map.entrySet().iterator().next();
                key = toEvict.getKey();
                value = toEvict.getValue();
                //移除头部元素
                this.map.remove(key);
                this.size -= this.safeSizeOf(key, value);
                ++this.evictionCount;
            }

            this.entryRemoved(true, key, value, (Object)null);
        }
    }
```

原理总结：

内部是利用了`LinkedHashMap`来实现一个`最近最少使用算法`，在每次调用`put`和`get`时，都会算作一次对`LinkedHashMap`的访问，当设置`accessOrder`为`true`时，就会按照访问顺序排列，就会把每次访问的元素放在尾部，当缓存值达到阈值`maxSzie`后，就会去删除`LinkedHashMap`的首部元素，来降低内存占用。

`LinkedHashMap`在`HashMap`基础上使用了一个双端链表维持有序的节点。



## 自定义LRUCache

]]></content>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>常见名词概念</title>
    <url>/2019/12/11/%E5%B8%B8%E8%A7%81%E5%90%8D%E8%AF%8D%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Android崩溃优化</title>
    <url>/2019/07/20/Android%E5%B4%A9%E6%BA%83%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Gradle操作小记</title>
    <url>/2018/04/03/Gradle%E6%93%8D%E4%BD%9C%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[
> 显示所有依赖关系解析树
```gradle
./gradlew app:dependencies
```

> 生成项目
```gradle
./gradlew clean assembleEnvTestReleaseChannels -PchannelList=default
```
> 清理项目

```groovy
./gradlew clean
```

> api与implementation的区别
`api`：完全等同于原先的`compile`指令，使用了该命令编译的依赖项目，其他项目依赖于该项目时也可以使用该命令编译的依赖项目。
`implementation`：使用了该命令编译的依赖项目，其他项目依赖于该项目时无法使用该命令编译的依赖项目。即该依赖是隐藏在项目内部的，不会对外开放。

```groovy
./gradlew build --refresh-dependencies
```

]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashMap简析</title>
    <url>/2019/03/08/LinkedHashMap%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ArrayMap简析</title>
    <url>/2019/03/08/ArrayMap%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Binder系列-ContentProvider</title>
    <url>/2018/12/13/Binder%E7%B3%BB%E5%88%97-ContentProvide/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Android Study Plan II - Service</title>
    <url>/2018/03/18/Android-Study-Plan-II/</url>
    <content><![CDATA[# Android学习计划
话题：清晰地理解Service。
1、Service的start和bind状态有什么区别？
2、同一个Service，先startService，然后再bindService，如何把它停止掉？
3、你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？
4、Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？

# 答案
{% fullimage /images/study_plan/service_lifecycle.png, alt,Service生命周期 %}
## 1.Service的start和bind状态有什么区别？
start启动Service,service有独立的生命周期，不依赖启动组件；
多次调用start方法，会重复调用onStartCommand方法；（判断service是否正在运行以避免多次调用）
start启动的Service，需要stopService或stopSelf来停止（IntentService会自动调用）。
> 生命周期:onCreate()-\>onStartCommand()-\>onDestory()

bind绑定的Service，依赖于启动组件，销毁后随之消失；
多次bind，只会调用一次onBind方法
> 生命周期:onCreate()-\>onBind()-\>onUnBind()-\>onDestory()

## 2.同一个Service，先startService，然后再bindService，如何把它停止掉？
调用stopService和unbindService方法，顺序无关，当最后一次调用时，会进入Service的onDestory方法
## 3.你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？
4种返回值
```java
//版本兼容，在Service被杀死后，并不保证onStartCommand会被再一次调用
//Service被kill后，Service被重建，即会调用onCreate()
public static final int START_STICKY_COMPATIBILITY = 0;

/**在Service被杀死后，系统会尝试重启Service但不保存intent，会用一个null对象调用  
onStartCommand方法（注意intent判空），除非有一些被发送的Intent对象在等待   Service被kill后，Service被重建、重启，即会调用onCreate()>onStartCommand()，intent对象为null。
启动服务，试用于媒体播放器之类，无限期等待*/
public static final int START_STICKY = 1;

/**常规操作，除非被杀死之前还有组件调用startService，否则不保留状态并重启Service  
直到接受到新的Intent对象，这个服务才会被重新创建
Service被kill后，Service没有重启*/
public static final int START_NOT_STICKY = 2;

/**Service被杀死后，系统将会组织一次重启Service，在杀死前的最后一次传递的intent会被重新执行，不会传递空的intent  
任意等待中的Intent对象会依次被发送。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。 */
public static final int START_REDELIVER_INTENT = 3;
```
## 4.Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？
Service默认运行在主线程，所以生命周期的方法都会运行在主线程
## 5.Service种类
> 按运行地点分类：`本地服务`和`远程服务`
> 本地服务：依附主进程，主进程被kill后就会自动销毁
> 远程服务：运行在一个独立进程，需要利用AIDL通信需要占用一定资源而且是常驻形式

> 按运行类型分类：`前台服务`和`后台服务`
> 前台服务：会在通知栏显示相关通知，当服务终止时通知栏消息即消失起到一定通知作用
> 后台服务：不会显示在前台，用户无感知，服务终止也不会有任何提示

> 按使用方式分类：`startService`，`bindService`和`混合使用`
> startService：用于启动服务执行后台任务，不需要通信，停止需要stopService
> bindService：启动的服务需要进行通信，unbindService停止
> 混合使用：停止服务需同时调用stopService，unbindService
## 6.IntentService介绍
继承Service的一个异步请求类，在IntentService有一个工作进程处理耗时操作，启动方式和普通Service一样。任务执行完毕后，IntentService会自动关闭。每次只会执行一个而不至于堵塞UI线程。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2018/12/27/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Android-简单实现Router功能</title>
    <url>/2018/12/24/Android-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0Router%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>实现自定义图片加载框架</title>
    <url>/2018/12/17/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据结构-链表</title>
    <url>/2018/04/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[
# 数据结构-链表

> 链表是一种基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)，简单来说链表并不像数组存储在一个连续的内存地址空间里，他们可以是不连续的因为他们每个节点保存着下一个节点的引用（地址），所以较之数组来说这是一个优势。

## 1.单链表

> 单链表是链表的一种，由节点组成，每个节点包含到下一个节点的指针。

> 单链表特点：
>
> - 链表增删元素时间复杂度度为O(1)，查找一个元素复杂度为O(n)
> - 单链表不需要预先分配空间，避免空间浪费
> - 单链表不能进行回溯操作，例如读取倒数几个节点的值

{% fullimage /images/structures/single_linkedlist.png,单链表,单链表 %}

```java
/**
* 表示一个节点
*/
public class Node {
    //数据域
    public int data;
    //下一节点
    public Node next;

    public Node() {

    }

    public Node(int data) {
        this.data = data;
    }

    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }
}
```

### 单链表的基本操作

- 链表添加元素

  - 添加头部
  - 添加尾部

- 链表删除元素

  - 删除指定位置
  - 删除倒数第K个节点

- 链表查询元素

  - 指定索引
  - 查询倒数第K个节点

- 其他操作

  - 寻找链表中间元素

  - 旋转单链表

  - 翻转单链表

  - 单链表排序

    - 冒泡排序
    - 插入排序

  - 链表相加求和

  - 删除重复元素


## 2.双循环链表]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Study Plan VIII - Java引用类型</title>
    <url>/2018/03/18/Android-Study-Plan-VIII/</url>
    <content><![CDATA[# Android学习计划
话题：Java基础知识学习
1、Java中有哪几种引用？它们的含义和区别是什么？
2、请用Java实现一个线程安全且高效的单例模式。

# 答案
## 1. Java中有哪几种引用？它们的含义和区别是什么？
- 强引用（StrongReference）：`无论内存是否充足，都不会被回收`强引用指的是在代码中普遍存在的类似`Object object=new Object();`这类的引用，只要有这类的存在，垃圾回收器永远不会回收该对象，这也是导致OOM异常出现的主要原因。若想中断强引用可以把对象置为`null`。
- 弱引用（WeakReference）：`内存不足时，会被回收`弱引用用来修饰非必需对象，弱引用所关联的对象生命周期只到下一次垃圾回收前，无论内存是否充足都会被回收关联对象。
```java
String s=new String("abc");
WeakReference<String> weakReference=new WeakReference<>(s);
//当内存回收时 调用weakRefrence=null 并且 System.gc();
```
- 软引用（SoftReference）：`无论内存是否充足，都会被回收`软引用用来修饰一些有用但非必需的对象，软引用所关联的对象将会在系统即将发生OOM前，会把对象进行二次回收，若回收完内存还是不足则会发生OOM异常。`可实现内存敏感的高速缓存`
```java
	String s=new String("abc");
	SoftReference<String> softReference=new SoftReference<>(s);
	//当内存不足时 会调用 softRefrence=null  并且 System.gc();
```
- 虚引用（PhantomReference）：`任何时候都会被回收`虚引用不会决定对象的生命周期，虚引用关联的对象任何时候都可能被垃圾回收器回收。虚引用的作用是：跟踪对象被垃圾回收器回收的活动，虚引用本身加入引用队列中，记录引用对象是都被回收。

## 2. 请用Java实现一个线程安全且高效的单例模式。
> 单例：一个类有且仅有一个实例，并且自行实例化向整个系统提供。目的为
>
> - 减少内存的占用
> - 阻止对象实例化自己的单例对象副本，从而确保所有对象访问统一实例
> - 控制了实例化过程所以可以灵活化控制实例过程。
>
>  线程安全：再多线程访问时采用加锁机制，当一个线程访问该数据时，其他线程不能访问该数据，直到读取完毕才可以访问。不会出现数据不一致和数据污染。

> 双重校验锁（DCL）

```java
public class Singleton {
    private static volatile Singleton mInstance;
    private Singleton() {
    }

    public static Singleton getInstance() {
        if (mInstance == null) {
            synchronized (Singleton.class) {
                if (mInstance == null) {
                    mInstance = new Singleton();
                }
            }
        }
        return mInstance;
    }
}
```
> 在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则`mInstance = new Singleton(); `可能出现`mInstance `尚未被初始化的异常。
> `mInstance = new Singleton(); `包括三步：`为对象分配内存`，`执行构造方法，初始化实例对象`，`把mInstance的引用指向分配的内存空间`。在JVM的执行过程中并不是原子性的。
> 保护序列化与反序列化安全的写法：
```java
/**
*反序列化提供的一个特殊方法，可以控制对象的反序列化。
*/
private Object readResolve(){
        return mInstance;//返回实例对象
    }
```

> 静态内部类：
>
> `为何可以保证线程安全？`虚拟机可以保证一个类的类构造器 `<clinit>()`在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。**同一个类加载器下，一个类型只会被初始化一次。**

```java
public class Singleton {
    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.sInstance;
    }

    private static class SingletonHolder {
        private static Singleton sInstance = new Singleton();
    }
}
```

> 枚举写法（在Android中不推荐使用，对内存的消耗较大）
枚举法的好处：1.实例创建线程安全 2.防止被反射创建多个实例 3. 没有序列化的问题

```java
public enum Singleton{
    INSTANCE;
    
    public void fun() {
       //do sth
    }
}
```


## 3. 拓展知识
- Kotlin实现的单例模式：`object Singleton{}`，本质是饿汉加载，在类加载时就会创建单例。问题在于构造方法过多时，初始化会变慢以及资源的浪费。

- Kotlin实现懒汉式加载：
```kotlin
class Singleton private constructor(){
    companion object {
        val instance: Singleton by lazy { Singleton() }
    }
}
```
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Study Plan IX - ClassLoaderß</title>
    <url>/2018/03/18/Android-Study-Plan-IX/</url>
    <content><![CDATA[# Android学习计划
话题：Android中的ClassLoader
1、Android中有哪几种ClassLoader？它们的作用和区别是什么？
2、简述ClassLoader的双亲委托模型
3、简述双亲委托模型在热修复领域的应用
# 答案
## 1.Android中有哪几种ClassLoader？它们的作用和区别是什么？

> 在Android程序中，.dex文件就是一群.class文件。

{% fullimage /images/study_plan/android_classloader.png, alt,SingleTop %}

- **BootClassLoader**

  > BootClassLodaer是ClassLoader内部实现类，是只能包内可见，我们是无法调用的。在无父构造器传入的情况下，默认构建一个PathClassLoader且父构造器为BootClassLoader
  >
   ```java
   private static ClassLoader createSystemClassLoader() {
           String classPath = System.getProperty("java.class.path", ".");
           String librarySearchPath = System.getProperty("java.library.path", "");
           return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
       }
   ```

- **URLClassLoader**

  > 只能用于加载jar文件，但是在dalvik（Android5.0之前的虚拟机）无法直接识别jar，所以Android中无法使用这个加载器。

- **BaseDexClassLoader**

  > 用于加载各种dex中的类
  >
   ```java
   public class BaseDexClassLoader extends ClassLoader {
       public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) {
           throw new RuntimeException("Stub!");
       }
       ...
   }
   ```
  >
  > 主要构造函数介绍：
  >
  > - dexPath：指`目标类所在的apk、dex或jar文件的路径，也可以是SD卡的路径`，类加载器从该路径加载目标类。如果包含多个路径，路径之间必须用特定的分隔符去分隔，特定的分隔符从`System.getProperty("path.separtor")`获取（默认分割符为":"）。最终将路径上的文件ODEX优化到optimizedDirectory，然后进行加载。
  > - optimizedDirectory：解压出的dex文件路径，这个路径必须为内部路径，一般情况下的路径为`/data/data/<Package_Name>/`
  > - librarySearchPath：存放目标类中使用的native文件库，也以":"分割
  > - parent：父加载器，在Android中以`context.getClassLoader`作为父加载器。

- **DexClassLoader**

  > 继承自BaseDexClassLoader，支持加载包含classes.dex的jar、apk，zip文件，可以是SD卡的路径。是实现热修复的关键。**注意不要把优化后的文件放在外部存储，可能导致注入攻击。**

- **PathClassLoader**

  > 用来加载Android系统类和应用程序的类，**在dalvik上只能加载已安装apk的dex(/data/app目录)，在ART虚拟机上则没有这个限制**。

    ```java
  public class PathClassLoader extends BaseDexClassLoader {
    public PathClassLoader(String dexPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
        throw new RuntimeException("Stub!");
    }

    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) {
        super((String)null, (File)null, (String)null, (ClassLoader)null);
        throw new RuntimeException("Stub!");
    }
  }
    ```

    > 在PathDexClassLoader的构造方法中optimizedDirectory为null，因为默认参数为`/data/dalvik-cache`目录。

- **InMemoryDexClassLoader**

  > 用于加载内存中的dex文件(在API26中添加)
  >
   ```java
   public final class InMemoryDexClassLoader extends BaseDexClassLoader {
      public InMemoryDexClassLoader(ByteBuffer[] dexBuffers, ClassLoader parent) {
          super((String)null, (File)null, (String)null, (ClassLoader)null);
          throw new RuntimeException("Stub!");
      }
       public InMemoryDexClassLoader(ByteBuffer dexBuffer, ClassLoader parent) {
           super((String)null, (File)null, (String)null, (ClassLoader)null);
           throw new RuntimeException("Stub!");
       }
   }
   ```


- **DelegateClassLoader**

  > 是一个先查找在委托的类加载器(API27添加)，按照以下顺序实现加载：
  >
  > 1. 首先判断该类是否被加载
  > 2. 搜索此类的类加载器是否加载过这个类
  > 3. 使用当前加载器去尝试加载类
  > 4. 最后委托给父加载器加载


## 2.简述ClassLoader的双亲委托模型 

{% post_link JVM相关及其拓展-三 %}

## 3.简述双亲委托模型在热修复领域的应用

一个ClassLoader文件可以有多少Dex文件，每个Dex文件是一个Element，多个Dex文件组成一个有序数组DexElements，当找类的时候会按照顺序遍历Dex文件，然后在当前遍历的Dex文件中找出类。由于双亲委托模型机制的存在，只要找到类就会停止检索并返回，找不到就会查询下一个Dex，所以只要我们先找到并加载修复Bug的文件，则有bug的Dex文件不会被加载。

注意点：假设有个A类，引用了B类。发布过程中发现B类有bug，若想要发个新的B类，需要阻止A加上这个类标志CLASS_ISPREVERIFIED。

##  4. 基本热修复代码实现 ]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Study-Plan-动态权限</title>
    <url>/2018/08/26/Android-Study-Plan-%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Study-Plan-XVIII -- 基础网络原理</title>
    <url>/2018/05/31/Android-Study-Plan-XVIII/</url>
    <content><![CDATA[
# Android学习计划

## 网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Study-Plan-XV -- 四大组件</title>
    <url>/2018/05/13/Android-Study-Plan-XV/</url>
    <content><![CDATA[
# Android学习计划

## Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？

### Android四大组件：

1. **`Activity`**

   > Activity的主要作用是展示一个界面并和用户直接交互。

   activity的启动由Intent触发（**需要在AndroidManifest.xml中注册**）。Intent分为两种：

   - 显示Intent：直接跳转至指定的Activity类

     ```java
     // 构造方法中直接传入Component
     Intent intent=new Intent(this,Activity.class);
     startActivity(intent);
     
     // 调用SetComponent方法
     ComponentName componentName=new Component(this,Activity.class);
     Intent intent=new Intent();
     intent.setComponentName(componentName);
     startActivity(intent);
     
     // 使用setClass方法
     Intent intent=new Intent();
     intent.setClassName(this,Activity.class);
     startActivity(intent);
     ```

   - 隐式Intent：不明确指定启动哪个Activity，而是利用Activity配置的Action，Data，Category来让系统进行选择(`筛选是根据所有的<intent-filter>来筛选`)

     ```java
      <activity android:name=".MainActivity">
                 <intent-filter>
                     <action android:name="TestActivity" />
                     <category android:name="android.intent.category.DEFAULT" />
                 </intent-filter>
     </activity>
     
     // setAction方法
     Intent intent=new Intent();
     intent.setAction("TestActivity");
     startActivity(intent);
     
     //直接构造Action
     Intent intent=new Intent("TestActivity");
     startActivity(intent);
     
     //在使用隐式调用时需要注意该Action是否存在,所以需要做try-catch防止异常发生
     //利用这个方法可以判断是否有处理该Action的Activity存在
     intent.resolveActivity(getPackageManager())
     ```

2. **`Service`**

   Service主要用于在后台执行一系列需要耗时的任务，需要单独的线程去完成，因为Service本身是运行在主线程的。Service不会与UI进行交互，其他的组件也可以启动Service，即便用户切换了应用，Service依然后台运行。（**需要在AndroidManifest.xml中注册**），Service有两种启动方式：

   - `startService`：启动一个Service，系统回调`onStartCommand()方法`，需要调用`stopService()`来停止Service
   - `bindService`：绑定一个Service，调用`unBindService()`来取消绑定，或者关闭绑定的组件也可以停止

3. **`BroadcastReceiver`**

   [完整介绍](https://www.jianshu.com/p/ca3d87a4cdf3)

   广播主要用于在不同的组件甚至不用的应用间进行消息传递，不与用户产生交互，工作在系统内部。

   广播的注册方式有两种：

   - 静态注册 （**需要在AndroidManifest.xml中注册**）

     ```xml 
     <receiver android:name=".MyReceiver"
               android:enabled=["true" | "false"]
     <!--此broadcastReceiver能否接收其他App的发出的广播-->
     //默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false
         android:exported=["true" | "false"]
         android:label="string resource"
     <!--具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收-->
         android:permission="string"
               >
     <intent-filter>
         <action android:name="com.test"/>
     </intent-filter>
     </receiver>
     ```

   - 动态注册

     ```java
     //最好在onResume中注册广播  
     @Override
       protected void onResume(){
           super.onResume();
           
           mBroadcastReceiver=new BroadcastReceiver();
           IntentFilter intentFilter=new IntentFilter();
           intentFilter.addAction("com.test");
           this.registerReceiver(mBroadcastReceiver,intentFilter);
       }
     
     //在onPause中取消注册
     @Override
     protected void onPause(){
         super.onPause();
         
         this.unregisterReceiver(mBroadcastReceiver);
     }
     
     ```

4. **`ContentProvider`**

   [相关链接](https://www.jianshu.com/p/ea8bc4aaf057)

   主要用于给不同的应用提供共享数据,（**需要在AndroidManifest.xml中注册**）

   ```xml
   <provider 
             android:name="wxy.provider.MyContentProvider"
             android:authorities="wxy.provider"
             android:exported="true" 
             <!--是否可被其他应用使用 -->
             >
   </provider>
   ```

   ContentProvider默认执行在主线程，需要实现以下方法

   - `onCreate()`：初始化Provider
   - `query()`：查询数据 **需异步操作**
   - `insert()`：插入数据
   - `update()`：更新Provider的数据
   - `delete()`：删除Provider的数据
   - `getType()`：返回指定Uri中的数据MIME类型

   相关的操作可能会被多个线程并发调用需要注意线程安全。



### 开启多进程

Android的四大组件都可以开启多进程，只要在AndroidManifest.xml中配置`android:process="any"`，需要配置`android:exported`属性]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Study-Plan-XIX</title>
    <url>/2018/06/12/Android-Study-Plan-XIX/</url>
    <content><![CDATA[
# Android学习计划

## AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Study-Plan-XX</title>
    <url>/2018/06/25/Android-Study-Plan-XX/</url>
    <content><![CDATA[
# Android学习计划

## 大尺寸图片加载问题：给定一个1000px*2000px的大图，如何进行正常加载且不会导致OOM。

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Study-Plan-XIV</title>
    <url>/2018/04/16/Android-Study-Plan-XIV/</url>
    <content><![CDATA[# Android学习计划
##用过RxJava和RxAndroid吗？RxAndroid切换线程是怎么实现的？]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android触摸事件分发</title>
    <url>/2018/04/09/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    <content><![CDATA[
# 1.触摸事件的类型

对应的类是`MotionEvent`，主要有以下三个类型：

- **ACTION_DOWN**：监听用户手指按下的操作，一次按下标志触摸事件的开始。
- **ACTION_MOVE**：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。
- **ACTION_UP**：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。
- **ACTION_CANCEL**：当用户保持按下操作，并把手指移动到了控件外部局域时且父View处理事件触发。

# 2.事件传递的三个阶段

- **分发（Dispatch）**：事件的分发对应着`dispatchTouchEvent`方法，所有触摸事件由这个方法进行分发

  ```java
  public boolean dispatchTouchEvent(MotionEvent ev)
  ```

  在这个方法中，根据当前视图的需求来进行事件的分发给子视图还是直接消费不往下传递，返回`true`表示事件被消费，不往下传递。返回值为`super.dispatchTouchEvent`表示继续往下传递。

- **拦截（Intercept）**:事件的拦截对应着`onInterceptTouchEvent`方法，这个事件只在ViewGroup及其子类中存在。

  ```java
  public boolean onInterceptTouchEvent(MotionEvent ev)
  ```

  根据具体的逻辑，返回`true`表示拦截该事件，不继续把事件分发给子视图，交由自身的`onTouchEvent`进行处理，返回值为`false或super.onInterceptTouchEvent`表示继续往下传递。

- **消费（Consume）**：事件的消费对应着`onTouchEvent`方法

  ```java
  public boolean onTouchEvent(MotionEvent ev)
  ```

  返回值为`true`时，表示当前视图可以处理事件，不会向上传递给父视图；返回值为`false`表示当前视图不处理这个事件，事件传递给父视图的`onTouchevent`进行处理。

> 在Android系统中，可以处理事件传递的类有以下三种：
>
> - **Activity**：包含`dispatchTouchEvent`，`onTouchEvent`方法
> - **ViewGroup**：包含`dispatchTouchEvent`，`onInterceptTouchEvent`，`onTouchEvent`
> - **View**：包含`dispatchTouchEvent`，`onTouchEvent`方法

# 3.View的事件传递机制

View包括TextView，ImageView等子类，不包括ViewGroup。

```java
/**
* Custom TextView with touchevent
*/
public class MyTextView extends AppCompatTextView {
    public static final String TAG="MyTextView";
    ...
     @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN");
                break;
            case MotionEvent.ACTION_UP:
                Log.e(TAG,"dispatchTouchEvent_ACTION_UP");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE");
                break;
            case MotionEvent.ACTION_CANCEL:
                Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL");
                break;
        }
        return super.dispatchTouchEvent(event);②
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.e(TAG,"onTouchEvent_ACTION_DOWN");
                break;
            case MotionEvent.ACTION_UP:
                Log.e(TAG,"onTouchEvent_ACTION_UP");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.e(TAG,"onTouchEvent_ACTION_MOVE");
                break;
            case MotionEvent.ACTION_CANCEL:
                Log.e(TAG,"onTouchEvent_ACTION_CANCEL");
                break;
        }
        return super.onTouchEvent(event);④
    }    
}
```

```java
public class MainActivity extends AppCompatActivity {
    public static final String TAG="MainActivity";
    MyTextView mtv;
     @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mtv= (MyTextView) findViewById(R.id.mtv);
        mtv.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Log.e(TAG,"MyTextView_onclick");
            }
        });

        mtv.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View view, MotionEvent event) {
                switch (event.getAction()) {
                    case MotionEvent.ACTION_DOWN:
                        Log.e(TAG,"MyTextView_onTouch_ACTION_DOWN");
                        break;
                    case MotionEvent.ACTION_UP:
                        Log.e(TAG,"MyTextView_onTouch_ACTION_UP");
                        break;
                    case MotionEvent.ACTION_MOVE:
                        Log.e(TAG,"MyTextView_onTouch_ACTION_MOVE");
                        break;
                    case MotionEvent.ACTION_CANCEL:
                        Log.e(TAG,"MyTextView_onTouch_ACTION_CANCEL");
                        break;
                }
                return false;③
            }
        });
    }
 @Override
    public void onUserInteraction() {
        super.onUserInteraction();
        Log.e(TAG,"onUserInteraction");
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN");
                break;
            case MotionEvent.ACTION_UP:
                Log.e(TAG,"dispatchTouchEvent_ACTION_UP");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE");
                break;
            case MotionEvent.ACTION_CANCEL:
                Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL");
                break;
        }
        return super.dispatchTouchEvent(event);①
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.e(TAG,"onTouchEvent_ACTION_DOWN");
                break;
            case MotionEvent.ACTION_UP:
                Log.e(TAG,"onTouchEvent_ACTION_UP");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.e(TAG,"onTouchEvent_ACTION_MOVE");
                break;
            case MotionEvent.ACTION_CANCEL:
                Log.e(TAG,"onTouchEvent_ACTION_CANCEL");
                break;
        }
        return super.onTouchEvent(event);
    }
}
```

- 常规输出：(返回的都为默认值)

  - 点击MyTextView区域

  ```java
   E/MainActivity: dispatchTouchEvent_ACTION_DOWN
   E/MyTextView: dispatchTouchEvent_ACTION_DOWN
   E/MainActivity: MyTextView_onTouch_ACTION_DOWN
   E/MyTextView: onTouchEvent_ACTION_DOWN
   E/MainActivity: dispatchTouchEvent_ACTION_UP
   E/MyTextView: dispatchTouchEvent_ACTION_UP
   E/MainActivity: MyTextView_onTouch_ACTION_UP
   E/MyTextView: onTouchEvent_ACTION_UP
   E/MainActivity: MyTextView_onclick
  ```

  - 点击MyTextView外部区域

  ```java
   E/MainActivity: dispatchTouchEvent_ACTION_DOWN
   E/MainActivity: onTouchEvent_ACTION_DOWN
   E/MainActivity: dispatchTouchEvent_ACTION_MOVE
   E/MainActivity: onTouchEvent_ACTION_MOVE
   E/MainActivity: dispatchTouchEvent_ACTION_UP
   E/MainActivity: onTouchEvent_ACTION_UP
  ```

- ① **Activity的dispatchTouchEvent()**`return true;或return false;`

  ```java
   E/MainActivity: dispatchTouchEvent_ACTION_DOWN
   E/MainActivity: dispatchTouchEvent_ACTION_MOVE
   E/MainActivity: dispatchTouchEvent_ACTION_MOVE
   E/MainActivity: dispatchTouchEvent_ACTION_UP
  ```

  > 不会再继续分发触摸事件，及后续控件的触摸事件都不会响应。

- ② **View的dispatchTouchEvent()**`return true;`不会调用MyTextView的`onClick`事件

  ```java
   E/MainActivity: dispatchTouchEvent_ACTION_DOWN
   E/MyTextView: dispatchTouchEvent_ACTION_DOWN
   E/MainActivity: MyTextView_onTouch_ACTION_DOWN
   E/MyTextView: onTouchEvent_ACTION_DOWN
   E/MainActivity: dispatchTouchEvent_ACTION_UP
   E/MyTextView: dispatchTouchEvent_ACTION_UP
   E/MainActivity: MyTextView_onTouch_ACTION_UP
   E/MyTextView: onTouchEvent_ACTION_UP
  ```

  **View的dispatchTouchEvent()**`return false;`只响应MyTextView的`ACTION_DOWN`事件，后续的处理由MainActivity的`onTouchEvent`执行

  ```java
   E/MainActivity: dispatchTouchEvent_ACTION_DOWN
   E/MyTextView: dispatchTouchEvent_ACTION_DOWN
   E/MainActivity: onTouchEvent_ACTION_DOWN
   E/MainActivity: dispatchTouchEvent_ACTION_MOVE
   E/MainActivity: onTouchEvent_ACTION_MOVE
   E/MainActivity: dispatchTouchEvent_ACTION_UP
   E/MainActivity: onTouchEvent_ACTION_UP
  ```

- ③**Activity中View的onTouch()**`return true;`不往下分发事件及不会调用到`onClick`事件

  ```java
   E/MainActivity: dispatchTouchEvent_ACTION_DOWN
   E/MyTextView: dispatchTouchEvent_ACTION_DOWN
   E/MainActivity: MyTextView_onTouch_ACTION_DOWN
   E/MainActivity: dispatchTouchEvent_ACTION_UP
   E/MyTextView: dispatchTouchEvent_ACTION_UP
   E/MainActivity: MyTextView_onTouch_ACTION_UP
  ```

- ④ **View的onTouchEvent()**`return true;`不触发`onClick`事件

  ```java
   E/MainActivity: dispatchTouchEvent_ACTION_DOWN
   E/MyTextView: dispatchTouchEvent_ACTION_DOWN
   E/MainActivity: MyTextView_onTouch_ACTION_DOWN
   E/MyTextView: onTouchEvent_ACTION_DOWN
   E/MainActivity: dispatchTouchEvent_ACTION_UP
   E/MyTextView: dispatchTouchEvent_ACTION_UP
   E/MainActivity: MyTextView_onTouch_ACTION_UP
   E/MyTextView: onTouchEvent_ACTION_UP
  ```

  **View的onTouchEvent()**`return false;`只响应MyTextView的`ACTION_DOWN`事件，后续的处理由MainActivity的`onTouchEvent`执行

  ```java
   E/MainActivity: dispatchTouchEvent_ACTION_DOWN
   E/MyTextView: dispatchTouchEvent_ACTION_DOWN
   E/MainActivity: MyTextView_onTouch_ACTION_DOWN
   E/MyTextView: onTouchEvent_ACTION_DOWN
   E/MainActivity: onTouchEvent_ACTION_DOWN
   E/MainActivity: dispatchTouchEvent_ACTION_UP
   E/MainActivity: onTouchEvent_ACTION_UP
  ```

{% fullimage /images/study_plan/Activity-View dispatch.png, View的事件传递,View的事件传递 %}

> 总结：
>
> - 触摸事件传递从dispatchTouchEvent开始，在不修改默认返回的数值时，事件会按照嵌套层次由外向内传递，到达最内层的View时，就由它的onTouchEvent处理。
>
> - 若事件在传递过程中，返回参数设为true，则导致事件提前被消费，内层View无法处理事件
>
> - View的事件触发顺序为先执行onTouch方法，最后执行onClick方法。onTouch返回false，则会响应onClick，否则事件不会继续传递。
>
> - View的点击事件流程：
>
>   **Activity.dispatchTouchEvent() -> View.dispatchTouchEvent()->View.onTouch()->View.onTouchEvent()->View.onClick()**

# 4.ViewGroup事件传递机制

ViewGroup作为View的容器存在，ViewGroup包括LinearLayout，RelativeLayout等。

```java
/**
* Custom ViewGroup with touchEvent
*/
public class MyRelativeLayout extends RelativeLayout {
    public static final String TAG="MyRelativeLayout";
    public MyRelativeLayout(Context context) {
        super(context);
    }

    public MyRelativeLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN");
                break;
            case MotionEvent.ACTION_UP:
                Log.e(TAG,"dispatchTouchEvent_ACTION_UP");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE");
                break;
            case MotionEvent.ACTION_CANCEL:
                Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL");
                break;
        }
        return super.dispatchTouchEvent(event);
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.e(TAG,"onInterceptTouchEvent_ACTION_DOWN");
                break;
            case MotionEvent.ACTION_UP:
                Log.e(TAG,"onInterceptTouchEvent_ACTION_UP");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.e(TAG,"onInterceptTouchEvent_ACTION_MOVE");
                break;
            case MotionEvent.ACTION_CANCEL:
                Log.e(TAG,"onInterceptTouchEvent_ACTION_CANCEL");
                break;
        }
        return super.onInterceptTouchEvent(event);⑥
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                Log.e(TAG,"onTouchEvent_ACTION_DOWN");
                break;
            case MotionEvent.ACTION_UP:
                Log.e(TAG,"onTouchEvent_ACTION_UP");
                break;
            case MotionEvent.ACTION_MOVE:
                Log.e(TAG,"onTouchEvent_ACTION_MOVE");
                break;
            case MotionEvent.ACTION_CANCEL:
                Log.e(TAG,"onTouchEvent_ACTION_CANCEL");
                break;
        }
        return super.onTouchEvent(event);
    }
}
```

- 常规模式（全为默认值）

  ```log
   E/MainActivity: dispatchTouchEvent_ACTION_DOWN
   E/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWN
   E/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWN
   E/MyTextView: dispatchTouchEvent_ACTION_DOWN
   E/MainActivity: MyTextView_onTouch_ACTION_DOWN
   E/MyTextView: onTouchEvent_ACTION_DOWN
   E/MainActivity: dispatchTouchEvent_ACTION_UP
   E/MyRelativeLayout: dispatchTouchEvent_ACTION_UP
   E/MyRelativeLayout: onInterceptTouchEvent_ACTION_UP
   E/MyTextView: dispatchTouchEvent_ACTION_UP
   E/MainActivity: MyTextView_onTouch_ACTION_UP
   E/MyTextView: onTouchEvent_ACTION_UP
   E/MainActivity: MyTextView_onclick
  ```

- ViewGroup.onInterceptTouchEvent()返回true

  ```java
   E/MainActivity: dispatchTouchEvent_ACTION_DOWN
   E/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWN
   E/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWN
   E/MainActivity: MyRelativeLayoutonTouch_ACTION_DOWN
   E/MyRelativeLayout: onTouchEvent_ACTION_DOWN
   E/MainActivity: dispatchTouchEvent_ACTION_UP
   E/MyRelativeLayout: dispatchTouchEvent_ACTION_UP
   E/MainActivity: MyRelativeLayout_onTouch_ACTION_UP
   E/MyRelativeLayout: onTouchEvent_ACTION_UP
  ```

{% fullimage /images/study_plan/Activity-ViewGroup-View dispatch.png, View的事件传递,View的事件传递 %}

> 总结:
>
> - 对于一个包裹在ViewGroup中的View，点击发生的触摸流程为：
>
>   **Activity.dispatchTouchEvent()->ViewGroup.dispatchTouchEvent()->ViewGroup.onInterceptTouchEvent()->View.dispatchTouchEvent()->View.onTouch()->View.onTouchEvent()->View.onClick()**
>
> - dispatchTouchEvent事件分发逻辑如下：
>
>  如果 return true，事件会分发给当前 View 并由 dispatchTouchEvent 方法进行消费，同时事件会停止向下传递；
>  如果 return false，事件分发分为两种情况：
>  1.如果当前 View 获取的事件直接来自 Activity，则会将事件返回给 Activity 的 onTouchEvent 进行消费；
>  2.如果当前 View 获取的事件来自外层父控件，则会将事件返回给父 View 的  onTouchEvent 进行消费。
>
> - onInterceptTouchEvent 的事件拦截逻辑如下：
>    如果 onInterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理；
>     如果 onInterceptTouchEvent 返回 false或super.onInterceptTouchEvent(ev)，则表示将事件放行，当前 View 上的事件会被传递到子 View 上，再由子 View 的 dispatchTouchEvent 来开始这个事件的分发；
> - onTouchEvent 的事件响应逻辑如下：
>      如果事件传递到当前 View 的 onTouchEvent 方法，而该方法返回了 false，那么这个事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，如果传递到上面的 onTouchEvent 也返回 false，这个事件就会“消失”，而且接收不到下一次事件。
>      如果返回了 true 则会接收并消费该事件。
>      如果返回 super.onTouchEvent(ev) 默认处理事件的逻辑和返回 false 时相同。

# 5.源码分析

//TODO

# 6.实例分析

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Study Plan V</title>
    <url>/2018/03/18/Android-Study-Plan-V/</url>
    <content><![CDATA[# Android学习计划
话题：关于View的知识

1、View的getWidth()和getMeasuredWidth()有什么区别吗？
2、如何在onCreate中拿到View的宽度和高度？

# 答案
## 1. View的getWidth()和getMeasuredWidth()有什么区别吗？
- `getWidth()`通过`setFrame`方法来决定四个顶点位置，初始化`mLeft,mTop,mRight,mBottom`四个参数，这四个值固定则位置确定。必须在layout过程结束才有值。
```java
 /**
     * Return the width of the your view.
     *
     * @return The width of your view, in pixels.
     * 利用屏幕上的右坐标减去左边的坐标 
     */
    @ViewDebug.ExportedProperty(category = "layout")
    public final int getWidth() {
        return mRight - mLeft;
    }
 
   protected boolean setFrame(int left, int top, int right, int bottom) {
 ...
            mLeft = left;
            mTop = top;
            mRight = right;
            mBottom = bottom;
...
  }
```

- `getMeasuredWidth`是在view的绘制流程中的`measure`结束后有值，获取的是view的测量宽高。`mMeasuredWidth `是在`setMeasuredDimensionRaw `方法中赋值的
```java
public static final int MEASURED\_SIZE\_MASK = 0x00ffffff;  
/**
     * Like {@link #getMeasuredWidthAndState()}, but only returns the
     * raw width component (that is the result is masked by
     * {@link #MEASURED_SIZE_MASK}).
     *
     * @return The raw measured width of this view.
     */
    public final int getMeasuredWidth() {
        return mMeasuredWidth & MEASURED_SIZE_MASK;//与任何数字的运算得到的结果是mMeasuredWidth
    }
 
private void setMeasuredDimensionRaw(int measuredWidth, measuredHeight) {
        mMeasuredWidth = measuredWidth;
        mMeasuredHeight = measuredHeight;
 
        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
    }
```

- 一般情况下 `getMeasuredWidth `和`getWidth`的值是相同的，从源码中可以看出`setMeasuredDimensionRaw `会对`mMeasuredWidth `进行赋值，当调用了`onMeasure`，会调用到`setMeasuredDimensionRaw `则获取的结果将会不相同
```java
public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
  boolean optical = isLayoutModeOptical(this);
	if (optical != isLayoutModeOptical(mParent)) {
		Insets insets = getOpticalInsets();
	   int oWidth  = insets.left + insets.right;
		int oHeight = insets.top  + insets.bottom;
		widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);
		heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);
	}
 ...
  if (forceLayout || needsLayout) {
		// first clears the measured dimension flag
		mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET;

	   resolveRtlPropertiesIfNeeded();

		int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);
		if (cacheIndex < 0 || sIgnoreMeasureCache) {
			// measure ourselves, this should set the measured dimension flag back
			onMeasure(widthMeasureSpec, heightMeasureSpec);
		   mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
		} else {
			long value = mMeasureCache.valueAt(cacheIndex);
			// Casting a long to int drops the high 32 bits, no mask needed
		   setMeasuredDimensionRaw((int) (value >> 32), (int) value);
			mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
		}

		// flag not set, setMeasuredDimension() was not invoked, we raise
		// an exception to warn the developer
		if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {
			throw new IllegalStateException("View with id " + getId() + ": "
				   + getClass().getName() + "#onMeasure() did not set the"
					+ " measured dimension by calling"
					+ " setMeasuredDimension()");
		}

		mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;
  }
  ...
  }
  ```

- view的绘制流程`measure` `layout` `draw`
  {% fullimage /images/study_plan/view_process.png, alt,流程图 %}
  - `measure`为了计算出控件树中的各个控件要显示的内容以及大小，起点为`ViewRootImpl 的 measureHierarchy ()`。
	-  SpecMode : `EXACTLY(确切大小)` `AT_MOST(子view的大小不得超过SpecSize)` `UNSPECIFIED(对子view尺寸不做限制)`
		```java
		/**
		         * Measure specification mode: The parent has not imposed any constraint
		         * on the child. It can be whatever size it wants.
		         */
		        public static final int UNSPECIFIED = 0 << MODE_SHIFT;

		        /**
		         * Measure specification mode: The parent has determined an exact size
		         * for the child. The child is going to be given those bounds regardless
		         * of how big it wants to be.
		         */
		        public static final int EXACTLY     = 1 << MODE_SHIFT;

		        /**
		         * Measure specification mode: The child can be as large as it wants up
		         * to the specified size.
		         */
		        public static final int AT_MOST     = 2 << MODE_SHIFT;
		```
- `layout` 从根view开始，递归的完成控件树的布局工作，确定view的位置。先递归的对子view进行布局，在完成父布局的位置设置

  -  `draw` 从根view开始进行绘制，利用`Viwe.draw()`


## 2.如何在onCreate中拿到View的宽度和高度？
- 在 Activity#onWindowFocusChanged 回调中获取宽高。

- view.post(runnable)，在 runnable 中获取宽高。
	`利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。`
- ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。
	`监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露`
- 调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高。

## 补充知识点
- matchParent无法measure(在view的measure过程中，需要知道parentSize即父容器的剩余空间，所以无法得出measure的大小)
- [深入理解View绘制流程][1]

[1]:	https://www.cnblogs.com/jycboy/p/6219915.html#autoid-7-1-0]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Study Plan IV</title>
    <url>/2018/03/18/Android-Study-Plan-IV/</url>
    <content><![CDATA[# Android学习计划
 话题：关于startActivityForResult
1、startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode以及intent含义是什么？
2、Activity A启动B的时候，在B中何时该执行setResult ？setResult可以位于Activity的finish方法之后吗？

# 答案
## 1.  startActivityForResult 使用场景是什么？ requestCode、 resultCode 含义是什么？

### 1.1  使用场景
- 用户开始新的活动，并且希望得到新活动的某些信息。比如选择照片、选择联系人、选择收货地址、进行某块数据编辑工作等。

### 1.2  requestCode
- 解决的是「区分多个异步任务」的问题。与其他异步 API 的设计类似，如果没有这个信息，那么 Activity 在收到响应时会进入混乱的状态。比如他不知道自己得到的是选择照片还是选择联系人的结果。
- 该信息会发送到 AMS 那边的 ActivityRecord.requestCode 变量进行记录，Client 端新 Activity 并不知道这个信息。
-   为什么 `requestCode`\< 0 时收不到结果？
	- ActivityStarter 收到 startActivityLocked 时，写入ActivityRecord.resultTo 变量为空[对应源码][1]
``` java
        ActivityRecord sourceRecord = null;
        ActivityRecord resultRecord = null;
        if (resultTo != null) {
            sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);
            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,
                    "Will send result to " + resultTo + " " + sourceRecord);
            if (sourceRecord != null) {
                if (requestCode >= 0 && !sourceRecord.finishing) {
                    resultRecord = sourceRecord;
                }
            }
        }
```
-  在 ActivityStack 收到 finishActivityResultsLocked 时，读取 ActivityRecord.resultTo 变量为空，结果数据不会添加到源 ActivityRecord.results 变量
-  在 ActivityStack 收到 resumeTopActivityInnerLocked 时，读取 ActivityRecord.results 数组为空，不会分发结果数据，这样源 Activity 也就没有结果回调了

### 1.3 resultCode
- 异步调用结果码，告诉调用者成功/失败/其它信息
- 该信息由被调用 Activity / framework 写入，并经过 AMS 传递给源 Activity
- `RESULT_CANCELED=0` `RESULT_OK=-1` `RESULT_FIRST_USER=1`
### 1.4 intent
- 用于存储需要传递的数据
- 大小不得大于1M

## 2. A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？
### 2.1 setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中
Activity 构造器阶段
大部分在显示调用finish()或者onBackPressed()
	```java
	  public final void setResult(int resultCode, Intent data) {//进行赋值
	       synchronized (this) {
	           mResultCode = resultCode;
	          mResultData = data;
	       }
	    }
	
	 // Home 键 + 不保留后台 Activity 可触发 onDestroy
	protected void onDestroy() {
	        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onDestroy " + this);
	        mCalled = true;
	
	        // dismiss any dialogs we are managing.
	        if (mManagedDialogs != null) {
	            final int numDialogs = mManagedDialogs.size();
	            for (int i = 0; i < numDialogs; i++) {
	                final ManagedDialog md = mManagedDialogs.valueAt(i);
	                if (md.mDialog.isShowing()) {
	                    md.mDialog.dismiss();
	                }
	            }
	            mManagedDialogs = null;
	        }
	
	        // close any cursors we are managing.
	        synchronized (mManagedCursors) {
	            int numCursors = mManagedCursors.size();
	            for (int i = 0; i < numCursors; i++) {
	                ManagedCursor c = mManagedCursors.get(i);
	                if (c != null) {
	                    c.mCursor.close();
	                }
	            }
	            mManagedCursors.clear();
	        }
	
	        // Close any open search dialog
	        if (mSearchManager != null) {
	            mSearchManager.stopSearch();
	        }
	
	        if (mActionBar != null) {
	            mActionBar.onDestroy();
	        }
	
	        getApplication().dispatchActivityDestroyed(this);
	    }
	
	 private void finish(int finishTask) {
	        if (mParent == null) {
	            int resultCode;
	            Intent resultData;
	            synchronized (this) {
	                resultCode = mResultCode;
	                resultData = mResultData;
	            }
	            if (false) Log.v(TAG, "Finishing self: token=" + mToken);
	            try {
	                if (resultData != null) {
	                    resultData.prepareToLeaveProcess(this);
	                }
	                if (ActivityManager.getService()
	                        .finishActivity(mToken, resultCode, resultData, finishTask)) {
	                    mFinished = true;
	                }
	            } catch (RemoteException e) {
	                // Empty
	            }
	        } else {
	            mParent.finishFromChild(this);
	        }
	    } 
	    ```
### 2.2 否
-  如果位于 finish 之后执行，信息已经无法放到传递的数据中
-   从代码可以看出 setResult 和 finish 类似生产者/消费者模型，setResult 负责写入数据，finish 负责读取数据

### 2.3 线程安全问题
- Activity.mResultCode 和 Activity.mResultData 变量由 Activity 对象的锁进行保护
- 支持后台线程和 UI 线程分别进行 setResult 和 finish
- 但是为什么需要加锁保护这两个信息？需要「解决什么问题」？

### 2.4 API 设计/数据组装问题
 - 底层 AMS 提供的接口的参数是 setResult 和 finish 的参数的组合形式，但是 Activity 为什么把一个接口拆分成两个接口给开发者使用？

- 使用方便。很多情况下调用者只关心 finish ，不需要理解太多的信息

### 2.5 启动模式冲突
- 5.0以上 singleTask和singleInstance失效，重复启动时会重新创建实例
- 以下 则会直接收到`RESULT_CANCELED`

## 3. API 内部原理/数据处理流程
{% fullimage /images/study_plan/study_plan_4.png, alt,流程图 %}
> 关键节点：
-  Client 端通过 AMP 把数据发送给 Server 端 AMS Binder 实体
-  AMS 把数据包装成 ActivityResult 并保存在源 ActivityRecord 的 results 变量中
- AMS 通过 ApplicationThreadProxy 向 Client 端发送 pause 信息让栈顶 Activity 进入 paused 状态，并等待 Client 端回复或超时
- AMS 接收 Client 端已 paused 信息，恢复下一个获取焦点的 Activity ，读取之前保存在 ActivityRecord.results 变量的数据派发给 Client 端对应的 Activity
- Client 端数据经过 ApplicationThread 对象、ActivityThread 对象的分发最后到达 Activity

## 4. startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题
### 4.1 基本原则
> 源 Activity 和目标 Activity 无法在跨 Task 情况下通过 onActivityResult 传递数据
### 4.2 Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调
 [源码链接][2]
### 4.3 Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调
[源码链接][3]   
### 4.4 通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task

[1]:	http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#266
[2]:	http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#1196
[3]:	http://androidxref.com/4.4.4_r1/xref/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java#1399]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android-Study-Plan-XI</title>
    <url>/2018/03/19/Android-Study-Plan-XI/</url>
    <content><![CDATA[# Android学习计划
话题：Okhttp和Retrofit

1、介绍这两个框架的作用和联系
PS：这个问题几乎Android面试必问]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Study Plan VI</title>
    <url>/2018/03/18/Android-Study-Plan-VI/</url>
    <content><![CDATA[# Android学习计划
话题：关于Gradle的知识
1、如何理解Gradle？Grade在Android的构建过程中有什么作用？
2、实践如下问题。

问题：我们都知道，Android中时常需要发布渠道包，需要将渠道信息附加到apk中，然后在程序启动的时候读取渠道信息。
动态指定一个渠道号（比如1001），那么构建的apk中，请在它的AndroidManifest.xml文件里面的application节点下面添加如下meta-data，请写一段Gradle脚本来自动完成：
```xml
 <application android:allowBackup="false" android:supportsRtl="true">
        <meta-data android:name=“channel" android:value=“1001" />
</application>
```

要求：当通过如下命令来构建渠道包的时候，将渠道号自动添加到apk的manifest中。
./gradlew clean assembleRelease -P channel=1001

]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
