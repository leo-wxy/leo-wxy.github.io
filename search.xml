<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android-Study-Plan-XX]]></title>
    <url>%2F2018%2F06%2F25%2FAndroid-Study-Plan-XX%2F</url>
    <content type="text"><![CDATA[Android学习计划大尺寸图片加载问题：给定一个1000px*2000px的大图，如何进行正常加载且不会导致OOM。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XIX]]></title>
    <url>%2F2018%2F06%2F12%2FAndroid-Study-Plan-XIX%2F</url>
    <content type="text"><![CDATA[Android学习计划AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树]]></title>
    <url>%2F2018%2F06%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础]]></title>
    <url>%2F2018%2F05%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XVIII -- 基础网络原理]]></title>
    <url>%2F2018%2F05%2F31%2FAndroid-Study-Plan-XVIII%2F</url>
    <content type="text"><![CDATA[Android学习计划网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XVII — 线程池]]></title>
    <url>%2F2018%2F05%2F31%2FAndroid-Study-Plan-XVII%2F</url>
    <content type="text"><![CDATA[Android学习计划线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？基础概念 线程：进程中负责执行的执行单元，一个进程中至少有一个线程,操作系统能够进行调度的最小单位 进程：一个执行中的程序的实例 多线程：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU确定，因此多线程具有不确定性 线程池： 基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象回归池中，避免反复创建线程对象所带来的性能开销，节省系统资源。 1. 线程池的概念在执行一个异步任务或并发任务时，往往会通过new Thread()方法去开启一个子线程去执行任务，等到子线程操作完成后在利用Handler切换至主线程。但是利用这种方法我们无法对自己创建的子线程进行有效的管理，然后由于过多的创建子进程，他们之间相互竞争会导致资源的过度占用。线程池的出现就是为了来对子进程进行管理。 2. 线程池的实现原理Executors提供了基础的四类线程池方法，最终都是通过ThreadPoolExecutor类完成。对于这个类的描述他维护了一个线程池，对于提交Executor中的任务，不是创建新的线程而是使用池内的线程来执行任务。可以显著减少对于任务执行的开销。 ThreadPoolExecutor构造函数介绍 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 参数介绍： corePoolSize 核心线程数 表示线程池中的基本线程数量即核心线程数量。一般情况下核心线程会一直存活在线程池中，即便他们处于闲置状态。只有在ThreadPoolExecutor的allowCoreThreadTimeOut设置为true的时候，会有一个超时策略（超过设置好的超时时间，闲置的核心线程会被终止）。当创建的线程数小于corepoolSize时，不管有没有空闲线程都会创建新的线程。 maximumPoolSize 最大线程数 表示线程池中允许的最大创建线程数，当活动的线程数达到数值后，后续新任务会被阻塞。使用有界队列时，未达到该值则会创建新的线程，使用无界队列时该值无效。 keepAliveTime 非核心线程闲置时的超时时长 表示空闲非核心线程的最大存活时间，一旦超过即被销毁。**当ThreadPoolExecutor的allowCoreThreadTimeOut设置为true的时候，该参数也可作用于核心线程 unit 存活时间的时间单位 用于指定keepAliveTime参数的时间单位，为一个枚举类型。包含下列参数：NANOSECONDS（纳秒）,MICROSECONDS（微秒）,MILLSECONDS（毫秒）,SECONDS（）秒,MINUTES（分）,HOURS（时）,DAYS（天） workQueue 线程池中的任务队列 该队列是java.util.BlockingQueue&lt;E&gt;的一个实例，是一种阻塞队列用来存放等待执行的任务。通过execute()方法将提交的Runnable对象存储进去。根据具体实现类的不同可以分为以下三种队列策略： 容量为0即直接提交策略--SynchronousQueue：等待队列容量为0 ，所有需要阻塞的任务必须等待池内的某个线程有空闲才可以继续执行，否则阻塞。CachedThreadPool使用该队列策略。 容量无限即无界队列策略--LinkedBlockingQueue：等待队列的长度无穷大，在这种策略下不会出现多余corePoolSize的线程被创建，所以maximumPoolSize以及handler无效，因为不存在队列满的情况。不过也有缺点：线程的执行速度会比提交速度慢，会导致无界队列快速增长，直到系统资源耗尽。fixedThreadPool采用了这种队列策略。 容量有限即有界队列策略--指定了容量的任何BlockingQueue：等待队列的长度为限制长度，指定了容量后可以防止过多的资源被消耗。 threadFactory 线程工厂：是一个接口可以为线程池提供新线程的创建。由同一个threadFactory创建的线程同属于一个ThreadGroup，优先级都为Thread.NORM_PRIORITY，以及为非进程守护状态。默认都是采用Executors.defaultThreadFactory()返回值。 handler 拒绝策略：当使用有界队列时且队列任务被填满后并且线程数也达到了最大值，就会触发拒绝策略。如果任务被拒绝执行，则会调用RejectedExecutionHandler.rejectedExecution()方法，默认调用AbortPolicy拒绝策略，也可以由用户自定义。JDK中定义了4种拒绝策略： AbortPolicy处理程序遭到拒绝则直接抛出RejectedExecutionException异常然后丢弃该任务。 实现源码： 1234567891011public static class AbortPolicy implements RejectedExecutionHandler &#123; /** * Creates an &#123;@code AbortPolicy&#125;. */ public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString()); &#125; &#125; 样例演示： 123456789101112131415161718192021222324252627282930313233343536373839 static class TestRunnable implements Runnable &#123; private int id; TestRunnable(int id) &#123; this.id = id; &#125; @Override public void run() &#123; System.err.println(Thread.currentThread().getName()+" 当前线程id="+ this.id); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;public static void abortPolicyDemo() &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1), new ThreadPoolExecutor.AbortPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.shutdown(); &#125;运行结果：添加进程时直接抛出异常但是没有影响后续的进行pool-1-thread-1 当前线程id=1Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@4b1210ee rejected from java.util.concurrent.ThreadPoolExecutor@4d7e1886[Running, pool size = 1, active threads = 1, queued tasks = 1, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112) at threadpool.ThreadPoolDemo.abortPolicyDemo(ThreadPoolDemo.java:140) at threadpool.ThreadPoolDemo.main(ThreadPoolDemo.java:13)pool-1-thread-1 当前线程id=2 CallerRunsPolicy在调用execute方法的调用者所在线程来执行被拒绝的任务，提供简单的反馈控制机制，可以减缓新任务的提交速度。 实现源码： 1234567891011public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; /** * Creates a &#123;@code CallerRunsPolicy&#125;. */ public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125; &#125; 样例演示： 123456789101112131415 public static void callerRunsPolicyDemo()&#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1), new ThreadPoolExecutor.CallerRunsPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.shutdown(); &#125;运行结果：task2执行在了主线程，由于被拒绝执行所以在调用者线程执行了任务pool-1-thread-1 当前线程id=1main 当前线程id=3pool-1-thread-1 当前线程id=2 DiscardPolicy被拒绝即无法执行的任务被直接删除 实现源码： 12345678public static class DiscardPolicy implements RejectedExecutionHandler &#123; /** * Creates a &#123;@code DiscardPolicy&#125;. */ public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125; &#125; 样例演示： 1234567891011121314 public static void discardPolicyDemo()&#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1), new ThreadPoolExecutor.DiscardPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.shutdown(); &#125;运行结果：由于被拒绝执行在该策略下被直接抛弃pool-1-thread-1 当前线程id=1pool-1-thread-1 当前线程id=2 DiscardOldestPolicy判断线程池是否被关闭，没有则丢弃最老的一个请求，再尝试提交当前任务。 实现源码： 123456789101112public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; /** * Creates a &#123;@code DiscardOldestPolicy&#125; for the given executor. */ public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125; &#125; 样例演示： 123456789101112131415 public static void discardOldestPolicyDemo()&#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1), new ThreadPoolExecutor.DiscardOldestPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.submit(new TestRunnable(4)); threadPoolExecutor.shutdown(); &#125;运行结果：???pool-1-thread-1 当前线程id=1pool-1-thread-1 当前线程id=4 CustomRejectPolicy 自定义拒绝策略可以用来记录运行日志或者记录无法处理的任务 样例演示： 12345678910111213141516171819202122232425262728293031/*** 自定义拒绝策略，实现RejectedExecutionHandler接口即可*/static class CustomRejectedPolicy implements RejectedExecutionHandler&#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; if (!executor.isShutdown())&#123; System.err.println("自定义异常日志记录: "+ r.toString()); &#125; &#125; &#125;public static void customPolicyDemo()&#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2), new CustomRejectedPolicy()); //使用execute是因为使用submit时会被封装成RunnableFuture对象 threadPoolExecutor.execute(new TestRunnable(1)); threadPoolExecutor.execute(new TestRunnable(2)); threadPoolExecutor.execute(new TestRunnable(3)); threadPoolExecutor.execute(new TestRunnable(4)); threadPoolExecutor.shutdown(); &#125;运行结果：由于4号被拒绝，记录日志自定义异常日志记录: java.util.concurrent.FutureTask@4b1210eepool-1-thread-1 当前线程id=1pool-1-thread-1 当前线程id=2pool-1-thread-1 当前线程id=3 额外参数扩展 allowCoreThreadTimeOut 允许核心线程过期默认值为false（线程池已不被使用，但是其中还有活着的线程，则该线程池无法被回收，会造成内存泄露）。所以用户可以显式调用shutDown()或者该值设置为true，则会被回收。 ThreadPoolExecutor的使用 向线程池提交一个任务的方式有两种： execute：这种方法提交任务，是没有返回值的即无法判断在线程池中是否完成该任务 1threadPoolExecutor.execute(new TestRunnable(1)); submit：使用submit方法提交任务时，会返回一个future，可以通过这个future来判断任务是否执行成功也可以根据future的get()方法获取返回值。若子线程任务没完成，get()方法会阻塞直到任务完成，若使用get(long timeout,TimeUnit unit)则会阻塞一段时间后返回，可能尚未完成任务。 1234567891011121314Future&lt;Integer&gt; future = fixedThreadPool.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; System.err.println(Thread.currentThread().getName() + " , index = " + index); return 2; &#125; &#125;); try &#123; System.err.println("Future return :" + future.get().toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 线程池的关闭 线程池关闭方法有两种： shutdown()：将线程池的状态置为SHUTDOWN状态，然后中断没有正在执行的线程。 12345678910111213public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); &#125; shutdownNow()：将线程池的状态设为STOP状态，中断所有任务包括执行中的线程，并返回等待执行的任务列表。 123456789101112131415public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(STOP); interruptWorkers(); tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks; &#125; 中断线程需要采用interrput方法，无法响应中断的任务可能永远无法终止。 当需要立即中断所有线程并且不在乎任务是否执行完成时，可以使用shutdownNow方法。 线程池的拓展 ThreadPoolExecutor默认提供三个空方法，可以通过重写这三个方法来监控线程池。 123456//任务执行前 记录任务开始前时间protected void beforeExecute(Thread t, Runnable r) &#123; &#125;//任务执行后 记录任务结束时间protected void afterExecute(Runnable r, Throwable t) &#123; &#125;//线程池关闭 记录线程池关闭事件以及执行过的线程数量protected void terminated() &#123; &#125; 样例演示： 123456789101112131415161718192021222324class CustomThreadPoolExecutor extends ThreadPoolExecutor&#123; public CustomThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); &#125; @Override protected void beforeExecute(Thread t, Runnable r) &#123; super.beforeExecute(t, r); System.err.println("beforeExecute"+r.toString()); &#125; @Override protected void afterExecute(Runnable r, Throwable t) &#123; super.afterExecute(r, t); System.err.println("afterExecute"+r.toString()); &#125; @Override protected void terminated() &#123; super.terminated(); System.err.println("线程关闭"); &#125; &#125; 3. 为什么要使用线程池 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗 提高响应速度。当任务到达时，任务可以不需要等到线程创建就可以立即执行 提高线程的可管理性。线程是稀缺资源，大量创建会导致系统资源过度消耗且会降低系统的稳定性，线程池可以有效控制线程数，并进行统一的分配、调优和监控。 4. 线程池的分类以及各自的特性利用Executors类提供了四种不同的线程池，他们都是直接或者间接配置ThreadPoolExecutor来实现功能。下面分别介绍着四个线程池 newFixedThreadPool 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就不会发生变化，如果某个线程因为异常而结束，则会补充一个新进程。 由于只设置核心线程大小，所以可以更快的响应外界请求 线程池的大小设置，可以使用Runtime.getRuntime().availableProcessors() 实现源码 12345678/*** 设置了核心线程，并且没有超时机制，使用LinkedBlockingQueue则任务队列大小是无上限的*/public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 样例演示 1234567891011121314151617181920212223242526public static void fixedThreadPoolDemo()&#123; ExecutorService fixedThreadPool= Executors.newFixedThreadPool(3); for (int i = 0; i &lt;6 ; i++) &#123; final int index=i; fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.err.println(Thread.currentThread().getName()+" , index = "+index); &#125; &#125;); try&#123; Thread.sleep(1000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;运行结果：整个过程都在pool-1的线程池中运行,然后复用线程pool-1-thread-1 , index = 0pool-1-thread-2 , index = 1pool-1-thread-3 , index = 2pool-1-thread-1 , index = 3pool-1-thread-2 , index = 4pool-1-thread-3 , index = 5 适用场景 用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。 newCachedThreadPool 可根据需要创建新线程的线程池，但是在一起构造的线程可用时将重用他们。对于很多短期异步任务的程序而言，这类线程池可以提高性能。 如果现有线程没有可用的，则会创建一个新的线程并添加到池中，终止并从缓存中移除那些超过60s没有使用的线程。因此，长时间保持空闲的newCachedThreadPool线程池是不存在任何线程的，所以这时候几乎不占用系统资源。 实现源码 12345678/*** 核心线程数为0 线程最大为Int的最大值所以可以认定为线程池最大线程无限大，设置了超时时间为60s。任务队列采用了阻塞队列(必须池内有空闲线程才可以执行)*/public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 样例演示 1234567891011121314151617181920212223242526public static void cachedThreadPoolDemo()&#123; ExecutorService cachedThreadPool= Executors.newCachedThreadPool(); for (int i = 0; i &lt;6 ; i++) &#123; final int index=i; cachedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.err.println(Thread.currentThread().getName()+" , index = "+index); &#125; &#125;); try&#123; Thread.sleep(1000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;运行结果：整个过程都在同一个线程pool-1-thread-1中执行，后面线程复用前面的线程pool-1-thread-1 , index = 0pool-1-thread-1 , index = 1pool-1-thread-1 , index = 2pool-1-thread-1 , index = 3pool-1-thread-1 , index = 4pool-1-thread-1 , index = 5 适用场景 并发执行大量短期的小任务，或者负载较轻的服务器 newScheduledThreadPool 创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。 实现源码 12345678910public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;/*** 核心线程数固定，非核心线程数为无限大，当非核心数处于闲置状态的时候会被立即回收*/public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 样例演示 12345678910111213141516171819202122232425262728293031323334353637 public static void scheduleThreadPoolDemo() &#123; ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3); //延迟一定时间后执行Runnable任务 scheduledThreadPool.schedule(new Runnable() &#123; @Override public void run() &#123; System.err.println(Thread.currentThread().getName() + " delay 2s"); &#125; &#125;, 2, TimeUnit.SECONDS); //延迟一定时间后执行Callable任务 scheduledThreadPool.schedule(new Callable&lt;Object&gt;() &#123; @Override public Object call() throws Exception &#123; return null; &#125; &#125;, 2, TimeUnit.SECONDS); //延迟一定时间（initialDelay）后,以(period)时间间隔执行任务 scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.err.println(Thread.currentThread().getName() + " every 3s"); &#125; &#125;, 1, 1, TimeUnit.SECONDS); //延迟一定时间（initialDelay）后,以(delay即上一个任务执行结束到下一个任务开始的间隔)执行 scheduledThreadPool.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; System.err.println(Thread.currentThread().getName() + " delay 3s"); &#125; &#125;, 1, 1, TimeUnit.SECONDS); &#125;运行结果：pool-1-thread-1 every 3spool-1-thread-2 delay 3spool-1-thread-3 delay 3s 1pool-1-thread-2 every 3s 适用场景 用于需要多个后台线程执行周期任务，同时需要限制线程数量 newSingleThreadExecutor 创建一个单线程池，该线程池中只有一个线程在工作，其他任务都会依次在任务中排列中等候依次执行，任务是串行执行的。此线程池保证所有的任务的执行顺序按照任务提交顺序执行(FIFO-先进先出)。 实现源码 123456789/*** 只有一个核心线程，对任务队列没有大小限制，将所有外界任务统一到一个线程执行所有我们不需要处理线程同步的问题。*/public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 样例演示 1234567891011121314151617181920212223242526 public static void singleThreadPoolDemo()&#123; ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 6; i++) &#123; final int index = i; singleThreadExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.err.println(Thread.currentThread().getName() + " , index = " + index); &#125; &#125;); try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;运行结果：所有的任务都是在pool-1-thread-1中依次运行pool-1-thread-1 , index = 0pool-1-thread-1 , index = 1pool-1-thread-1 , index = 2pool-1-thread-1 , index = 3pool-1-thread-1 , index = 4pool-1-thread-1 , index = 5 适用场景 用于串行执行任务的场景，每个任务需要顺序执行 5. 线程池的执行流程 判断corePoolSize(核心线程数)是否已到达，没到达则可以创建一个新线程执行任务 判断工作队列是否已满，没满则添加入队列等待执行 判断maximum(最大线程数)是否已到达，没到达则创建一个新线程执行任务。已满则执行拒绝策略。 6. 线程池的使用注意 线程池不要用Executors的方式去创建，应该利用ThreadPoolExecutor的方式，这样可以帮助更好理解实现方式以及避免资源消耗过度的问题。 fixThreadPool以及singleThreadPool,由于设置的等待队列长度为Integer.MAX_VALUE，导致大量请求堆积，消耗大量资源。 cachedThreadPool以及scheduledThreadPool,由于运行允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的请求，消耗大量资源。 针对具体情况去配置线程池参数，不同的任务类别应采用不同规模的线程池，任务类别分为3种： CPU密集型任务(需要进行大量计算，处理)：线程池中线程个数尽量少，不应大于CPU核心数，避免出现每个线程都需要长时间使用但是线程过多去抢占资源。 IO密集型任务(主要时间都在IO，CPU空闲时间比较多)：线程池可以配置尽量多的线程，由于CPU大部分时间空闲，可以提高CPU的利用率。 混合型任务：如果可以拆分，则拆分成一个CPU密集型以及IO密集型任务，只要执行任务效率相差不大。若相差太大则没必要拆分。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XVI -- AIDL]]></title>
    <url>%2F2018%2F05%2F31%2FAndroid-Study-Plan-XVI%2F</url>
    <content type="text"><![CDATA[Android学习计划Android中AIDL的作用是什么？他所支持的参数类型是什么？默认情况下AIDL的调用过程是同步还是异步的？如何指定AIDL异步调用？]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler机制及源码解析]]></title>
    <url>%2F2018%2F05%2F14%2FHandler%E6%9C%BA%E5%88%B6%E5%8D%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[主要的内容包括Handler的机制以及四个组成部分和源码的分析1. 消息机制简介在应用启动时，会执行main()方法，main()会创建一个Looper对象，然后开启一个死循环，目的是不断从消息队列MessageQueue里面取出Message对象并处理。 在Android中使用消息机制，会优先想到的是Handler。Handler可以轻松的将一个任务切换到Handler所在的线程去执行。在多线程的应用场景中，可以将工作线程中需要更新UI的操作信息传递到主线程去执行，从而实现工作线程更新UI的操作，最终实现异步消息的处理。 2. Handler机制模型消息机制主要包含Handler、Message、MessageQueue，Looper这四个类。 Handler：消息辅助类。主要功能将Message对象发送到MessageQueue中，同时将自己的引用赋值给Message#target(Handler.sendMessage())。也可以实现handleMessage()方法处理回调。 Message：消息实体。需要传递的消息也可以传递数据。 MessageQueue：消息队列。内部实现并不是队列，而是利用单链表去实现因为在插入和删除数据有优势。用于存储Handler发给来的消息(Message)以及取出。 Looper：与线程绑定，不止局限于主线程，绑定的线程来处理Message。不断循环执行Looper.loop()，从MessageQueue中读取Message，按分发机制将消息分发出去给目标处理(将Message发到Handler.dispatchMessage方法去处理)。 3. Handler运行流程 工作流程：异步通信准备==&gt;消息入队==&gt;消息循环==&gt;消息处理 异步通信准备 假定在主线程创建Handler，则会直接在主线程中创建Looper,MessageQueue和Handler对象。Looper和MessageQueue对象均属于其创建线程（由主线程创建则属于主线程）。创建Looper时会自动创建MessageQueue对象，创建好MessageQueue对象后，Looper自动进入循环。Handler自动绑定Looper以及MessageQueue。 Looper对象的创建方法一般通过Looper.prepareMainLooper()和Looper.prepare()方法。 消息入队 消息循环 消息处理]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的GC分析-Dalvik和ART虚拟机]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E4%B8%AD%E7%9A%84GC%E5%88%86%E6%9E%90-Dalvik%E5%92%8CART%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XV -- 四大组件]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid-Study-Plan-XV%2F</url>
    <content type="text"><![CDATA[Android学习计划Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？Android四大组件： Activity Activity的主要作用是展示一个界面并和用户直接交互。 activity的启动由Intent触发（需要在AndroidManifest.xml中注册）。Intent分为两种： 显示Intent：直接跳转至指定的Activity类 1234567891011121314// 构造方法中直接传入ComponentIntent intent=new Intent(this,Activity.class);startActivity(intent);// 调用SetComponent方法ComponentName componentName=new Component(this,Activity.class);Intent intent=new Intent();intent.setComponentName(componentName);startActivity(intent);// 使用setClass方法Intent intent=new Intent();intent.setClassName(this,Activity.class);startActivity(intent); 隐式Intent：不明确指定启动哪个Activity，而是利用Activity配置的Action，Data，Category来让系统进行选择(筛选是根据所有的&lt;intent-filter&gt;来筛选) 12345678910111213141516171819 &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="TestActivity" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;// setAction方法Intent intent=new Intent();intent.setAction("TestActivity");startActivity(intent);//直接构造ActionIntent intent=new Intent("TestActivity");startActivity(intent);//在使用隐式调用时需要注意该Action是否存在,所以需要做try-catch防止异常发生//利用这个方法可以判断是否有处理该Action的Activity存在intent.resolveActivity(getPackageManager()) Service Service主要用于在后台执行一系列需要耗时的任务，需要单独的线程去完成，因为Service本身是运行在主线程的。Service不会与UI进行交互，其他的组件也可以启动Service，即便用户切换了应用，Service依然后台运行。（需要在AndroidManifest.xml中注册），Service有两种启动方式： startService：启动一个Service，系统回调onStartCommand()方法，需要调用stopService()来停止Service bindService：绑定一个Service，调用unBindService()来取消绑定，或者关闭绑定的组件也可以停止 BroadcastReceiver 完整介绍 广播主要用于在不同的组件甚至不用的应用间进行消息传递，不与用户产生交互，工作在系统内部。 广播的注册方式有两种： 静态注册 （需要在AndroidManifest.xml中注册） 12345678910111213&lt;receiver android:name=".MyReceiver" android:enabled=["true" | "false"]&lt;!--此broadcastReceiver能否接收其他App的发出的广播--&gt;//默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false android:exported=["true" | "false"] android:label="string resource"&lt;!--具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收--&gt; android:permission="string" &gt;&lt;intent-filter&gt; &lt;action android:name="com.test"/&gt;&lt;/intent-filter&gt;&lt;/receiver&gt; 动态注册 123456789101112131415161718//最好在onResume中注册广播 @Override protected void onResume()&#123; super.onResume(); mBroadcastReceiver=new BroadcastReceiver(); IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction("com.test"); this.registerReceiver(mBroadcastReceiver,intentFilter); &#125;//在onPause中取消注册@Overrideprotected void onPause()&#123; super.onPause(); this.unregisterReceiver(mBroadcastReceiver);&#125; ContentProvider 相关链接 主要用于给不同的应用提供共享数据,（需要在AndroidManifest.xml中注册） 1234567&lt;provider android:name="wxy.provider.MyContentProvider" android:authorities="wxy.provider" android:exported="true" &lt;!--是否可被其他应用使用 --&gt; &gt;&lt;/provider&gt; ContentProvider默认执行在主线程，需要实现以下方法 onCreate()：初始化Provider query()：查询数据 需异步操作 insert()：插入数据 update()：更新Provider的数据 delete()：删除Provider的数据 getType()：返回指定Uri中的数据MIME类型 相关的操作可能会被多个线程并发调用需要注意线程安全。 开启多进程Android的四大组件都可以开启多进程，只要在AndroidManifest.xml中配置android:process=&quot;any&quot;，需要配置android:exported属性]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(五)]]></title>
    <url>%2F2018%2F05%2F09%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%94%2F</url>
    <content type="text"></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap实现原理及解析]]></title>
    <url>%2F2018%2F05%2F09%2FHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android消息机制]]></title>
    <url>%2F2018%2F05%2F09%2FAndroid%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(四)]]></title>
    <url>%2F2018%2F05%2F04%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略垃圾收集器1.概述垃圾收集(Garbage Collection,GC)：自动管理回收不再引用的内存数据需要完成的三件事情： 哪些内存需要回收 什么时候回收 如何回收 Java语言会自动管理和回收不再引用的内存数据，由垃圾回收机制来完成。Java自身提供了内存管理机制，应用程序不需要去关注内存如何释放，内存用完后，GC会去自动进行处理，不需要人为干预出现错误。 在JVM相关及其拓展（一）章节中介绍了JVM的内存区域。 其中程序计数器、虚拟机栈，本地方法栈随线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作，因此每一个栈帧分配多少内存基本是在类结构确定下来就已经是已知的。因此这几个区域的内存分配和回收都具备确定性。所以不需要过多考虑回收的问题，在方法结束或者线程结束后，内存就随着回收了，也就实现了内存的自动清理。 而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序运行期间才知道会创建哪些对象，这部分的内存分配和回收是动态的。垃圾收集器关注的就是这部分的内存。 2.判断对象是否可以回收 在堆里面存放着几乎所有的对象实例，垃圾收集器在回收前需要去判断对象是否还被引用来决定是否回收，即找到那些不再被任何途径使用的对象。 引用计数算法(Refrence Counting) 给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时候计数器为0的对象是不能再被引用的，可以被当做垃圾收集。 优点：实现简单，判断效率高缺点：无法检测出对象之间相互循环引用，开销大（会发生频繁且大量的引用变化，带来大量的额外运算）。 可达性分析算法(Reachability Analysis) 通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的节点为引用链，当一个对象到GC Roots没有任何引用链相连（从GC Roots到这个对象不可达）时，则证明此对象是不可用的。 在Java语言中，可作为GC Roots的对象包括以下几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象（Native对象） 优点：更加精确严谨可以分析出循环引用的情况缺点：实现复杂，效率低，分析过程中需要GC停顿（因为应用关系不能发生改变，需要停止所有Java线程） 3.对象是生存还是死亡 真正宣告一个对象死亡，至少要经历两次标记过程 第一次标记： 对象在进行可达性分析算法后没有发现与GC Roots相连接的引用链，将会被第一次标记并进行第一次筛选。筛选的条件是此对象是否有必要执行finalize()方法。 没必要执行 对象没有覆盖finalize()方法，或者finalize()方法已被虚拟机调用过。 有必要执行 对象会被放置在一个F-Queue的队列中，稍后会由一个JVM自动建立的、低优先级的Finalizer线程去执行。 第二次标记： GC对F-Queue中的对象进行第二次小规模的标记，finalize()是对象摆除被回收的最后方法 若对象要避免自己被回收，需要重新与引用链上的任何一个对象建立关系即可，譬如把自己（this）赋值给某个变量或者对象的成员变量，那就会移除被回收的集合 如果没有摆除，则基本上会被回收。任何一个对象的finalize()方法只会被系统自动调用一次，再次调用finalize()方法则不会再次执行。 1234567891011121314151617181920212223242526272829303132333435363738public class FinalizeEscapeGC &#123; public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() &#123; System.err.println("It is live"); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.err.println("finalize is executed"); FinalizeEscapeGC.SAVE_HOOK = this; &#125; public static void main(String[] args) throws Throwable &#123; SAVE_HOOK = new FinalizeEscapeGC(); SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.err.println("It is over"); &#125; //将对象的引用链重新置为null，则拯救失败 SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.err.println("It is over"); &#125; &#125; &#125; finalize() 运行代价高昂，不确定性大，无法保证各个对象的调用顺序。 4.回收方法区 永久代的垃圾收集主要分为两部分：废弃常量和无用的类 废弃常量：假如常量池中存在一个常量，但是没有任何对象引用该常量，在发生回收的时候，该常量就会被系统清理出常量池，常量池中的其他类（接口）、方法、字段的符号引用类似。 无用的类：需要同时满足以下条件 该类的所有实例已被回收，Java堆中不存在该类的任何实例 加载该类的ClassLoader已被回收 该类对应的Class对象没有在任何地方被引用，也无法在任何地方通过反射访问到该类的方法 5.垃圾收集算法 标记-清除算法(Mark-Sweep) 最基础的收集算法 算法分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足有两个：一个是效率问题（标记和清除两个过程的效率都不高）；另一个是空间问题（标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作）。 复制算法(Copying) 将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象移到另一块上面，然后把已使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时就不需考虑内存碎片等情况。 缺点：可用内存会减少一半；效率会随存活对象的升高而降低（当对象存活率较高的时候，需要更多的copy操作，导致效率降低） 现在的商业虚拟机都采用这种收集算法来回收新生代。 提供了改良算法（基于弱代理论①）：不是按照1:1的比例去划分内存空间，而是分为较大的Eden空间和两块较小的Survivor空间，在回收时将Eden和Survivor存活的对象移至到另一块Survivor空间上。HotSpot中Eden和Survivor的大小比例为8:1。在一般场景下足够使用，当Survivor空间不够使用时，需要依赖其他内存(代指老年代)进行分配担保②。 ①弱代理论：1. 大多数分配了内存的对象存活不会太久，在年轻代就会死掉；2. 很少有对象从年老代变成年轻代。 ②分配担保：如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。 标记-整理算法(Mark-Compact) 标记过程与“标记-清除”算法一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理端边界以外的内存。 优点：1. 效率不随对象存活率升高而降低。 2. 不像标记-清除算法会产生大量的内存碎片（因为会进行一次整理，将存活对象集中到一端）。 缺点：除了需要进行标记，还需要整理过程，执行效率更低。 分代收集算法(Generational Collection) 根据对象存活周期的不同将内存划分为几块，一般是把Java堆分成新生代和老年代和持久代(JDK8中移除)，这样就可以根据各个年代的特点采用最适当的收集算法。新生代中每次垃圾收集都会有大量的对象被回收，只有少量存活，就可以使用复制算法。 老年代中因为对象存活率较高，没有额外空间进行分配担保，所以必须使用“标记-清理”或者“标记-整理”算法。 新生代(Young Generation)：所有新生对象都会放在新生代，新生代的目标是尽快收集生命周期短的对象，每次GC过后只有少量存活。新生代发生的GC叫做Minor GC（频率较高，新生代Eden区满才触发）。新生代细分为Eden、From Survivor、To Survivor三块空间（三块空间大小并非均分，默认比例为8:1:1）。 老年代(Tenured Generation)：新生代发生几次GC后依然存活的对象会放到老年代中，所以老年代中的对象生命周期较长。内存也比新生代大很多（大概2:1）,当老年代内存满时会触发Full GC/Major GC(针对新生代和老年代触发，经常会伴随至少一次的Minor GC，收集频率较低且耗时长，一般慢10倍以上)。 持久代(Permanent Generation)：用于存放静态文件，如Java类，方法等，对GC没有影响。 拓展：别处也有介绍 Full GC针对整个堆空间（包含新生代，老年代，永久代（如果包含））的回收。而Major GC是针对老年代的内存回收。 Minor GC：新生代是堆的一部分，对象首先在新生代中分配。新生代填满时，垃圾收集器会暂停所有的应用程序，回收新生代空间。不再使用的对象会被回收，仍然使用的对象移动至其他地方。 Full GC：对象不断的移至老年代，最终老年代也被填满，JVM需要找到老年代不再使用的对象，并进行回收。会导致应用长时间的停顿。 6.垃圾收集器 收集算法是内存回收的方法论，垃圾收集器就为内存回收的具体实现。 在两个收集器之间存在连线，则意味着他们之间可以搭配使用。 Serial收集器 该收集器是最基本、发展历史最悠久的收集器。这个收集器是一个单线程收集器（不仅是他只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是他在进行垃圾收集时必须停止其他的工作线程(Stop The World)，直到收集结束。进行Full GC时，还会对老年代空间对象进行压缩整理。）。 是虚拟机运行在Client端的默认新生代收集器 有着优于其他收集器的地方： 简单而高效 没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集效率 关键控制参数： -XX:SurvivorRatio：设置两个Survivor区和Eden区的比值(8表示 1:1:8) -XX:PretenureSizeThreshold：设定对象超过多少岁时进入老年代 -XX:HandlePromotionFailure：设置是否允许担保失败 ParNew收集器 ParNew收集器其实是Serial收集器的多线程版本。除了使用多线程进行垃圾收集之外，其他科Serial收集器完全一样。 该收集器是运行在Server模式下的虚拟机中的首选的新生代收集器，其中有一个重要的原因就是：除了Serial收集器外，目前只有它能和CMS收集器配合工作。随着可以使用的CPU数量增加，GC时系统资源的有效利用还是有好处的。默认开启的收集线程数与CPU的数量相同 并行（Parallel）：指多条垃圾收集器线程并行工作，但此时用户线程仍处于等待状态 并发（Concurrent）：指用户线程与垃圾收集器同时执行，用户程序仍继续运行，而垃圾收集器执行于另一个CPU上。 关键控制参数： -XX:UserParNewGC：是否开启ParNew收集器 Parallel Scavenge收集器 Parallel Scavenge收集器是一个新生代收集器，使用了复制算法以及并行的多线程收集器。 该收集器的目标是：达到一个可控制的吞吐量（ThroughPut）①。 停顿时间越短越适合需要与用户交互的程序，良好的响应速度可以提升用户体验，高吞吐量就可以高效率的利用CPU时间，主要适合在后台运算而不需要太多交互的任务。 吞吐量：CPU用于运行用户代码时间与CPU总消耗时间的比值。 关键控制参数： -XX:UseAdaptiveSizePolicy：开关参数，当打开时就不需要去指定新生代大小以及Eden与Survivor比例，晋升老年代对象岁数大小等参数，触发GC自适应调节策略(虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数已提供最适合的停顿时间或者最大的吞吐量) Serial Old收集器 是Serial收集器的老年代版本，同样是一个单线程收集器。使用“标记-整理算法” 该收集器主要为了给Client模式下的虚拟机使用。如果在Server模式下，还有以下用途： 在JDK1.5及之前的版本搭配Paraller Scavenge收集器 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用 Parallel Old收集器 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”。 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge + Parallel Old组合。 CMS收集器（Concurrent Mark Sweep） 以获取最短回收停顿时间为目标的收集器。基于“标记-清除算法”实现。整体上来说内存回收过程是与用户线程一起并发执行的。 运作过程比较复杂，分为4个步骤： 初始标记：仅仅标记一下GC Roots能关联到的对象，速度很快 触发Stop The World 并发标记：进行GC Roots Tracing的过程 重新标记：修正并发标记期间因用户程序继续运做而导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记长一些，但短于并发标记时间 触发Stop The World 并发清除：可以和用户线程一起工作 CMS收集器有3个明显的缺点： 对CPU资源非常敏感 面向并发设计的程序都对CPU资源比较敏感。在并发阶段，虽然不会导致用户线程停顿，但是会因为占了一部分CPU资源而导致线程变慢，吞吐量会降低。CMS默认启动的回收线程数量为(CPU数量+3)/4 无法处理浮动垃圾（Floating Garabge） 由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就有新的垃圾产生，即浮动垃圾(这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉他们，只能留到下一次GC进行清理)。 因此CMS收集器不能像其他收集器一样等到老年代几乎完全满了在进行收集，需要预留一部分空间提供并发收集时使用。 JDK1.5默认设置下，CMS收集器到老年代到了68%即会激活，到1.6时提高到了92%。 要是CMS运行期间预留的内存无法满足程序需要，就会出现一次Concurrent Mode Failure失败，虚拟机将会启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，停顿时间就会变得很长了。 产生的空间碎片 由于CMS是基于“标记-清除”算法实现的收集器。这种方式会产生大量的空间碎片，碎片过多时将会给对象分配来很大麻烦，往往会出现老年代还有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。 关键控制参数： -XX:CMSInitiatingOccupancyFraction：设置CMS触发阈值即老年代对象占用空间 G1收集器 全称Garbage-First收集器，通过-XX:+UseG1GC参数来启用，在JDK9中，被提议为默认收集器 G1收集器是一款面向服务端的垃圾收集器，设计目标是为了取代CMS收集器。具备如下特点： 并行与并发：使用多个CPU来缩短停顿时间，也会通过并发的方式让Java程序继续运行 分代收集：分代概念在G1中得以保留，可以不需要其他的收集器配合管理整个堆，可以采用不同的方式去处理新创建的对象和旧对象。 空间整合：整体基于“标记-整理”算法，局部（两个Region之间）采用“复制”算法实现 可预测的停顿：除了追求低停顿外，还可建立可预测的时间停顿模型，用户可以指定期望停顿的时间 Region在G1收集器之前其他收集器进行收集的范围都是整个新生代或者老年代，而G1可以通用。使用G1收集器，Java堆的内存布局就与其他收集器不同，将整个Java堆划分为多个大小相等的独立区域（Region），虽然保留了新生代老年代的概念，但他们都变成了一部分Region的集合。 可停顿的时间模型可以实现有计划的避免在整个Java堆中进行全区域的垃圾收集。跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region空间。可以保证G1收集器在有限时间内获得尽可能高的收集效率。 Remembered SetRegion不可能是独立的，由于可能会被其他对象引用。在G1中，Region之间的对象引用以及其他收集器中的新生代老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。每一个Region都会对应一个Remembered Set，虚拟机发现在对Reference进行读写操作时，产生一个Write Barrier暂时中断写操作，检查对象引用是否位于不同的Region中，若是则通过CardTable记录相关引用信息到Remembered Set中。在进行内存回收时，在GC Roots中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。 G1运作步骤 初始标记：标记一下GC Roots能直接关联的对象，需要停顿线程 并发标记：从GC Roots开始进行可达性分析，找出存活的对象耗时较长 最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，需要停顿线程，可并行执行 筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间来指定回收计划。 如果应用追求吞吐量，那并不会带来特别的好处 7.拓展 垃圾回收过程 对象在Eden进行内存分配 当Eden区满了，在创建对象会触发Minor GC(执行Minor GC时，Eden空间存活的对象会被复制到To Survivor·空间，并且之前经过一次Minor GC在From Survivor存活并年轻的对象也会被复制到To Survivor空间。如果存活对象的分代年龄超过阈值，则会晋升到老年代。)]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-链表]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据结构-链表 链表是一种基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)，简单来说链表并不像数组存储在一个连续的内存地址空间里，他们可以是不连续的因为他们每个节点保存着下一个节点的引用（地址），所以较之数组来说这是一个优势。 1.单链表 单链表是链表的一种，由节点组成，每个节点包含到下一个节点的指针。 单链表特点： 链表增删元素时间复杂度度为O(1)，查找一个元素复杂度为O(n) 单链表不需要预先分配空间，避免空间浪费 单链表不能进行回溯操作，例如读取倒数几个节点的值 12345678910111213141516171819202122/*** 表示一个节点*/public class Node &#123; //数据域 public int data; //下一节点 public Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125;&#125; 单链表的基本操作 链表添加元素 添加头部 添加尾部 链表删除元素 删除指定位置 删除倒数第K个节点 链表查询元素 指定索引 查询倒数第K个节点 其他操作 寻找链表中间元素 旋转单链表 翻转单链表 单链表排序 冒泡排序 插入排序 链表相加求和 删除重复元素 ​ ​]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(三)]]></title>
    <url>%2F2018%2F04%2F16%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[1.虚拟机类加载器定义：在类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码块称为“类加载器”。 例如：编写的是.java文件，代码运行后变成.class文件，类加载器就是加载.class文件。 Java类加载器分类：1.系统提供的类加载器 Bootstrap ClassLoader(启动类加载器)：由C/C++实现的加载器，用于加载虚拟机运行时所需要的系统类，如java.lang.*、java.uti.*等系统类。它负责将存放在&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。 这个加载器由于是C实现的，所以无法被Java程序直接引用。并且不继承java.lang.ClassLoader。 Extension ClassLoader(扩展类加载器)：这个加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的，或者被javax.ext.dirs系统变量所指定的路径中的所有类库。 Application ClassLoader(应用程序类加载器)：这个加载器由sun.misc.Launcher$AppClassLoader实现。可以加载用户类路径上的指定类库，通过ClassLoader.getSystemClassLoader()方式获取，没有定义过自己的类加载器，则默认是这个。 Custom ClassLoader(自定义加载器)：通过集成java.lang.ClassLoader来实现自己的加载器。 2.双亲委托模型 工作流程：如果一个类加载器收到了类加载的请求，不会自己去尝试加载这个类，而把这个请求委派给父类加载器去完成，每一层都是如此，依次向上递归，直到委托到最顶层的Bootstrap ClassLoader，若父加载器无法处理加载请求（它的搜索范围内没有找到所需的类时），则交由子加载器去加载。 简单流程介绍 自定义类加载器先从缓存中查看Class文件是否被加载，如果加载则返回Class，没有加载则委托给父类加载 一直委托到Bootstrap ClassLoader,在Bootstrap ClassLoader没有找到Class文件，则在自己的规定路径&lt;JAVA_HOME&gt;\lib或者-Xbootclasspath选项指定路径的jar包进行查询，找到则返回Class，没有就交由子加载器去加载。 最后交由我们自定义的类加载器去加载，还找不到则抛出ClassNotFoundException异常。 代码模型实现： 123456789101112131415161718192021222324252627282930313233343536373839404142protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 检查请求的类是否已被加载过 Class&lt;?&gt; c = findLoadedClass(name); //对应的类已被加载则不会往下进行 if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //父加载器不为null，调用父加载器的load方法 c = parent.loadClass(name, false); &#125; else &#123; //父加载器为null，则调用系统的BootstrapClassLoader c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader //父类加载器无法加载则抛出ClassNotFoundException异常 &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. //父类加载器无法加载则调用本身的findClass()方法去加载 long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 好处： 避免重复加载，若该Class已加载则从缓存中直接读取 更加安全，例如java.lang.Object，无论哪一个类加载器去加载这个类，最终都会委派给Bootstrap ClassLoader去进行加载，所以我们自定义的Object类并不会被加载而导致系统中出现多个Object类。 3.破坏双亲委托模型双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载实现方式。 在JDK1.2发布之前，还没有双亲委托机制 由模型自身缺陷所导致的 用户对于程序动态性导致的，例如代码热替换，模块热部署 4.自定义ClassLoader 自定义需要加载的类 12345public class Jobs &#123; public void say() &#123; System.err.println("自定义加载器加载"); &#125;&#125; 自定义完成后需调用javac Jobs.java去生成对应的Jobs.class文件以用来加载。 实现自定义的ClassLoader 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.io.*;public class DiskClassLoader extends ClassLoader &#123; private String path; public DiskClassLoader(String path) &#123; this.path = path; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class clazz = null; byte[] classData = loadClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; //用来将获取的字节码数组转为class的实例 clazz = defineClass(name, classData, 0, classData.length); &#125; return clazz; &#125; /** * 获得class文件的字节码数组 * @param name * @return */ private byte[] loadClassData(String name) &#123; String fileName = getFileName(name); File file = new File(path, fileName); System.err.println(fileName); InputStream inputStream = null; ByteArrayOutputStream byteArrayOutputStream = null; try &#123; inputStream = new FileInputStream(file); byteArrayOutputStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int length = 0; while ((length = inputStream.read(buffer)) != -1) &#123; byteArrayOutputStream.write(buffer, 0, length); &#125; return byteArrayOutputStream.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //读取流后需要关闭，以免造成内存泄露 try &#123; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (byteArrayOutputStream != null) &#123; byteArrayOutputStream.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; private String getFileName(String name) &#123; int index = name.indexOf('.'); if (index == -1) &#123; return name + ".class"; &#125; else &#123; return name.substring(index + 1) + ".class"; &#125; &#125;&#125; 自定义的ClassLoader需要读取对应Class的字节流数组，以便产生实例。注意不要忘记对流的关闭。 使用自定义的ClassLoader去加载类 123456789101112131415161718192021222324252627282930import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class CustomClassLoaderTest&#123; public static void main(String[] args) &#123; DiskClassLoader diskClassLoader = new DiskClassLoader("需要加载的class的地址"); try &#123; //对class文件进行加载 Class c = diskClassLoader.loadClass("Jobs"); if (c != null) &#123; try &#123; Object object = c.newInstance(); System.err.println(object.getClass().getClassLoader()); Method method = c.getDeclaredMethod("say", null); method.invoke(object, null); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在对应的文件夹下是否已存在Jobs.java文件： 123//存在要加载的Java文件sun.misc.Launcher$AppClassLoader@18b4aac2自定义加载器加载 123//不存在对应的Java文件DiskClassLoader@d716361自定义加载器加载 ​ 以上就为自定义ClassLoader的基本步骤，也是热修复框架中ClassLoader的雏形。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XIV]]></title>
    <url>%2F2018%2F04%2F16%2FAndroid-Study-Plan-XIV%2F</url>
    <content type="text"><![CDATA[Android学习计划##用过RxJava和RxAndroid吗？RxAndroid切换线程是怎么实现的？]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC,MVP,MVVM的理解]]></title>
    <url>%2F2018%2F04%2F15%2FMVC-MVP-MVVM%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.MVC模式MVC(Model-View-Controller，模型-视图-控制器)是20世纪80年代出现的一种设计模式。他用一种业务逻辑、数据、界面显示分离的方法组织代码。在Android中MVC的角色定义如下： Model(模型层)：针对业务模型，建立的数据结构和相关的类，就可以理解为Model。与View无关，与业务相关。 View(视图层)：一般采用XML文件或者Java代码进行界面的描述。 Controller(控制器)：Android的控制层一般在Activity，Fragment中或者在由他们控制的其他业务类中。 缺点： 在Android开发中，Activity不是一个标准的Controller，首要职责为加载应用的布局和初始化界面，并接受用户的请求。随着界面以及代码逻辑的复杂，Activity会越来越庞大。 view层和model层是相互感知的，意味之间存在很大的耦合。 2.MVP模式MVP(Model-View-Presenter)是MVC的演化版本，对于Android来说，Model层和MVC模式是一种概念，activity或者fragment对应的就是View层，所有用户相关事件处理由Presenter处理。 Model：主要提供数据的存取功能。 View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件 Presenter：作为View和Model沟通的桥梁，从Model层检索数据并返回给View层，使得View和Model层完全解耦。Presenter与View可以通过接口来实现通信，只要View层去实现定义好的接口。 缺点： View层和Presenter层会交互过于频繁，若Presenter过多的渲染了View，往往导致过于紧密，若View发生改动，Presenter也要发生变更。 3.MVVM模式MVVM(Model-View-ViewModel)是2015由微软提出的一个UI架构概念。将Presenter改为ViewModel，同时实现View和ViewModel的双向绑定（View的变动，自动反映在ViewModel，反之亦然）。 Model：主要提供数据的存储过程 View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件 ViewModel：功能和Presenter类似，与View和Model双向绑定 优点： 低耦合。View可以独立于Model变化和修改，ViewModel可以绑定不同的View 可重用性。把许多的试图逻辑处理放在一个ViewModel中，许多View可以使用该ViewModel 独立开发。开发人员可以专注于逻辑和数据的处理 可测试性。可以直接针对ViewModel进行单独测试。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程保活介绍]]></title>
    <url>%2F2018%2F04%2F12%2F%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[进程保活进程保活的方式分为两个层面：提高进程优先级，降低被杀死的概率,在进程被杀死后，进行拉活。 1. 进程的优先级 日常细节记录 2. Android进程回收策略对于进程的回收，依靠LowmemoryKiller完成，按照OOM_ADJ的阈值级别触发对应的内存回收。 红色代表易被杀死的进程，绿色不易被杀死。LowmemoryKiller会优先杀死OOM_ADJ较大的进程，优先级相同则进一步受到进程所占内存和进程存活时间的影响。 3. 提升进程优先级 利用Activity提升权限：监控手机锁屏解锁事件，在屏幕锁定时启动一个一像素的Activity，解锁时销毁。需把Activity设置成用户无感知 利用Notification提升权限：Service的优先级为4，使用setForeground可以设置前台Service，提升进程的优先级，降低被杀的概率。 注意点：设置为前台Service时，在通知栏会显示一条通知。 应对措施：可以去实现一个内部Service，在LiveService和其内部Service中同时发送相同ID的Notification，然后结束内部Service。内部Service被结束时，Notification也会消失，但是进程的优先级不会发生变化。 4. 进程死后拉活的方案 利用系统广播拉活：在发生特定事件是，系统会发送相应的广播，可以在AndroidManifest中静态注册对应的广播监听器，即可在对应事件发生时拉活应用。以下是常见的拉活广播事件： 开机广播：RECEIVE_BOOT_COMPLETED 网络变化：CHANGE_NETWORK_STATE,CHANGE_WIFI_STATE… 文件挂载：MOUNT_UNMOUNT_FILESYSTEMS 屏幕亮灭：SCREEN_ON,SCREEN_OFF 锁屏解锁：RECEIVE_USER_PRESENT 应用安装卸载：PACKAGE_ADDED,PACKAGE_REMOVED缺点： 广播接收器容易被系统的管理软件通过“自启管理”禁用场景，从而无法处理 系统广播事件不可控，只能保证有对应事件是拉活进程，但不能保证能否立即拉活。 利用第三方应用广播拉活：该方案接受第三方应用的广播，反编译一些第三方应用，找到他们发送的广播，在自己应用内进行监听，当这些应用发送广播时，即可拉活自己的应用。 缺点： 需要反编译较多应用来确保效果 第三方应用的广播可能会在日后更新中修改或删除 利用系统Service机制拉活：把Service设置为START_STICKY，这个参数可以在Service被杀死后，利用系统机制尝试拉活。 缺点： Service第一次被异常杀死后会在5秒内重启，第二层被杀死10秒内重启，第三次会在20秒内重启，一旦被杀死达到5次，则系统不会再重新拉活。 进程被Root权限的工具杀死活forcestop，无法重启。 利用Native进程拉活：利用Linux中的fork机制创建Native进程，在Native进程中监控主进程的存活，当主进程挂掉后，在Native进程中立即对主进程拉活。（该进程的生命周期不受Android的管理）。 适用范围： 在Android5.0以下版本手机效果很好，不受forcestop影响 在5.0以上的手机，Native进场也会被forcestop杀死，假如逻辑跑的比系统快，依然可以拉活。 利用JobScheduler机制拉活：系统在Android5.0以上版本提供了JobScheduler接口，系统会定时调用该进程使应用处理一些操作。 适用范围：Android5.0以上系统手机，在部分小米手机可能无法拉活。 1234567891011121314151617@TargetApi(Build.VERSION_CODES.LOLLIPOP)public class KeepLiveService extends JobService &#123; private final static String TAG="KeepLive"; private volatile static Service mKeepLiveService= null; @Override public boolean onStartJob(JobParameters jobParameters) &#123; return false; &#125; @Override public boolean onStopJob(JobParameters jobParameters) &#123; return false; &#125;&#125; 1234567891011121314public void startJobscheduler()&#123; try &#123; int jobId=1; JobInfo.Builder builder=new JobInfo.Builder(jobId, new ComponentName(MyApplication.getApplicationContext(), KeepLiveService.class)); builder.setPeriodic(10);//设置时间间隔 builder.setPersisted(true);//重启后需要继续执行 JobScheduler js = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); js.schedule(builder.build()); &#125;catch (Throwable e)&#123; e.printStackTrace(); &#125; &#125; 利用账号同步进制拉活：Android系统的账号同步进制会定期同步执行，可以利用同步机制进行进程的拉活。 适用范围：适用于所有的Android版本，在Android N中进行了一些变动，该方案失效。 其他方案： 利用系统通知权限进行拉活 利用辅助功能拉活，将应用加入厂商白名单 利用推送进行拉活（如小米、华为推送）]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(二)]]></title>
    <url>%2F2018%2F04%2F12%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[虚拟机类加载机制1.定义虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 2.类的生命周期 类从被加载到虚拟机内存中开始，到卸载除内存为止，生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)。其中验证、准备、解析统称为连接(Linking) 加载、验证、准备、初始化和卸载阶段执行顺序为确定的，类的加载过程必须按照这个顺序开始。解析阶段不一定：在某些情况下可以在初始化阶段之后开始，为了支持Java语言的运行时绑定。 初始化阶段，虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”： 遇到new ,getstatic,putstatic或invokestatic指令时，类没有进行初始化，则需要先触发初始化。最常见的Java代码场景：使用new关键字实例化对象、读取或设置一个类的静态字段、调用一个类的静态方法。 使用java.lang.reflect进行反射调用的时候。 初始化一个类时，发现父类还没有初始化，先触发父类初始化方法。 虚拟机启动时，用户指定一个要执行的主类(包含main()方法的类)，先初始化该类。 使用动态语言支持时，若java.lang.invoke,MethodHandle实例最后解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且该类没有进行初始化。 3.类加载的过程 加载虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 验证（若代码被反复验证和使用过，可以使用-Xverify:none来关闭大部分的类验证措施，缩短虚拟机加载时间） 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致需要完成以下4个阶段的检验动作： 文件格式验证验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。主要目的是保证输入的字节流能正确的解析并存储于方法区之内，格式上符合描述一个Java类信息的要求。在这个阶段字节流进入内存中的方法区后续不再操作字节流。 元数据验证对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范 字节码验证通过数据流和控制流分析，确定程序语义是合法且符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机的安全的事件。 符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化发生在解析阶段。对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验。确保解析动作能正常执行 准备 准备阶段是正式为变量分配内存并设置类初始变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个时候进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量。初始值通常情况下是数据类型的零值，如 1public static int value = 123;//在准备阶段过程中初始值为0，而不是123。 特殊情况：若类字段的属性表中有ConstantValue属性，那么准备阶段value就会初始化为ConstantValue指定的值，如 1public static final int value = 123;//在准备阶段过程中初始值为123。 解析 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析阶段中会涉及到直接引用(直接指向目标的指针、相对偏移量或者是一个能直接定位到目标的句柄)，符号引用(以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可)。 解析动作主要针对类或接口（CONSTANT_Class_info）、字段（CONSTANT_Fieldref_info）、类方法（CONSTANT_Methodref_info）、接口方法（CONSTANT_InterfaceMethodref_info）、方法类型（CONSTANT_MethodType_info）、方法句柄（CONSTANT_MethodHandle_info）、调用点限定符（CONSTANT_InvokeDynamic_info）。 初始化 初始化是类加载过程的最后一步。到这里才真正开始执行类中定义的Java程序代码。 执行类构造器&lt;clinit&gt;()方法的过程。 &lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。 &lt;clinit&gt;()方法与类的构造函数不同，他不需要显示的调用父类构造器，因此虚拟中第一个被执行的&lt;clinit&gt;()方法的类肯定是java.long.object。 初始化过程就是对变量进行赋值及执行静态代码块。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展（一）]]></title>
    <url>%2F2018%2F04%2F10%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[1. JVM内存区域 JVM在执行Java程序的过程中会把管理的内存分为若干个数据局域。 程序计数器(Program Counter Register)：一块较小的内存空间，可看作为当前线程所执行的字节码的行号指示器。每条线程都需要一个独立的程序计数器，所以为线程私有区域。没有规定任何OutOfMemoryError情况的区域。线程执行Java方法，则记录正在执行的虚拟机字节码指令地址，若为Native方法，则计数器值则为Undefined Java虚拟机栈(VM Stack)：虚拟机栈是线程私有的，生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表(存放编译器可知的各种基本数据类型boolean,byte,char,int,long,float,double,short,对象引用和returnAddress类型)，操作树栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。这个区域存在两种异常情况：StackOverflowError：请求栈深度大于虚拟机所允许的深度，OutOfMemoryError：无法申请到足够的内存 本地方法栈(Native Method Stack)：虚拟机执行Native方法的服务，和虚拟机栈类似存在两个异常情况。 Java堆(Heap)：JVM管理内存中最大的一块。是被所有线程共享的一块区域，在虚拟机启动时创建。唯一目的存放对象实例，几乎所有对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为”GC堆”。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，则抛出OutOfMemoryError异常。 方法区(Method Area)：方法区与Java堆一样，是各个线程共享的内存区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。同Java堆一样会抛出OutOfMemoryError异常。 运行时常量池(Runtime Constant Pool)：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一个是常量池（存放编译器生成的各种字面量和符号引用）。有一个重要特征是具有动态性，运行期也可以将新的常量放入池中。受到方法区内存的限制，也会抛出OutOfMemoryError异常。 直接内存(Direct Memory)：不属于虚拟机运行时数据区的一部分。 拓展： 程序计数器，虚拟机栈，本地方法栈随着线程生命周期变化，生则生，死则死。 程序计数器，虚拟机栈，本地方法栈不需要过多考虑内存回收问题，随着方法结束或者线程结束时，内存随着就会回收。 2.HotSpot虚拟机对象创建，布局以及访问对象的创建 在语言层面上，创建对象只需要一个new关键字。 在虚拟机中，分为以下几步： 遇到一条new指令时，先去检查指令对应参数是否在常量池中可以定位到一个符号的引用，并且检查指令的参数是否已被加载、解析和初始化过。若无则需要执行相应的类加载过程。 类加载检查通过后，将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，这块内存由Java堆中划分出来。内存的分配方式由Java堆中内存是否规整决定（已使用的内存和空闲内存是否相互交错）。规整则使用 指针碰撞（把指针向空闲空间挪动对象大小的距离），不规整则使用空闲列表（虚拟机内维护一个列表用来记录内存块中的可用区域，然后找到一块足够大的空间划分给对象实例）。 处理并发安全问题。除了如何分配内存，还需要考虑虚拟机中对象创建是非常频繁的行为，就会涉及到线程安全。解决这个问题有两种方案： 对分配内存空间的行为进行同步处理 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓存(TLAB)。哪个线程需要分配内存就在哪个TLAB上分配，只有TLAB用完了，才同步申请另一块内存。 内存分配完成后，虚拟机将需要分配到的内存空间都初始化为零值（不包括对象头）。这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 虚拟机对对象进行设置，将类的元数据信息、对象的哈希码、对象的GC分代年龄信息存入对象头中。 执行init方法初始化。从虚拟机角度来说，对象已经产生完成，从Java方面来说才刚刚开始，要等到new指令执行并\&lt;init>方法执行后，把对象按照意愿初始化后，真正可用的对象生成完毕。 对象的内存布局在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding) 对象头存储自身的运行时数据 存储内容 标志位 状态 对象哈希码、对象分代年龄 01 未锁定 指向锁记录的指针 00 轻量级锁定 指向重量级锁的指针 10 膨胀 空，不需要记录信息 11 GC标记 偏向线程ID，偏向时间戳，对象分代年龄 01 可偏向 类型指针对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象为一个Java数组，则对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。 实例数据里面是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。在分配策略中，相同宽度的字段总是会被分配在一起。 对齐填充并非必然存在的，也没有特别的含义。仅仅起着占位符的作用。当实例数据部分没有对齐时，需要对齐填充来补全。 对象的访问Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式是句柄访问和直接指针访问。 使用句柄访问：Java堆中会划分出一块内存来作为句柄池，refrence中存储的对象就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 句柄访问的最大好处是refrence中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，refrence本身不会有修改。 使用直接指针访问：Java堆对象需要考虑如何放置访问类型数据的相关信息，而refrence中存储的直接就是对象地址。 直接访问的最大好处是速度快，节省了一次指针定位的时间开销，在Java HotSpot虚拟机中很常用。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理模式原理及实现]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android触摸事件分发]]></title>
    <url>%2F2018%2F04%2F09%2FAndroid%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1.触摸事件的类型对应的类是MotionEvent，主要有以下三个类型： ACTION_DOWN：监听用户手指按下的操作，一次按下标志触摸事件的开始。 ACTION_MOVE：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。 ACTION_UP：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。 ACTION_CANCEL：当用户保持按下操作，并把手指移动到了控件外部局域时且父View处理事件触发。 2.事件传递的三个阶段 分发（Dispatch）：事件的分发对应着dispatchTouchEvent方法，所有触摸事件由这个方法进行分发 1public boolean dispatchTouchEvent(MotionEvent ev) 在这个方法中，根据当前视图的需求来进行事件的分发给子视图还是直接消费不往下传递，返回true表示事件被消费，不往下传递。返回值为super.dispatchTouchEvent表示继续往下传递。 拦截（Intercept）:事件的拦截对应着onInterceptTouchEvent方法，这个事件只在ViewGroup及其子类中存在。 1public boolean onInterceptTouchEvent(MotionEvent ev) 根据具体的逻辑，返回true表示拦截该事件，不继续把事件分发给子视图，交由自身的onTouchEvent进行处理，返回值为false或super.onInterceptTouchEvent表示继续往下传递。 消费（Consume）：事件的消费对应着onTouchEvent方法 1public boolean onTouchEvent(MotionEvent ev) 返回值为true时，表示当前视图可以处理事件，不会向上传递给父视图；返回值为false表示当前视图不处理这个事件，事件传递给父视图的onTouchevent进行处理。 在Android系统中，可以处理事件传递的类有以下三种： Activity：包含dispatchTouchEvent，onTouchEvent方法 ViewGroup：包含dispatchTouchEvent，onInterceptTouchEvent，onTouchEvent View：包含dispatchTouchEvent，onTouchEvent方法 3.View的事件传递机制View包括TextView，ImageView等子类，不包括ViewGroup。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** Custom TextView with touchevent*/public class MyTextView extends AppCompatTextView &#123; public static final String TAG="MyTextView"; ... @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"dispatchTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL"); break; &#125; return super.dispatchTouchEvent(event);② &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG,"onTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onTouchEvent_ACTION_CANCEL"); break; &#125; return super.onTouchEvent(event);④ &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MainActivity extends AppCompatActivity &#123; public static final String TAG="MainActivity"; MyTextView mtv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mtv= (MyTextView) findViewById(R.id.mtv); mtv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Log.e(TAG,"MyTextView_onclick"); &#125; &#125;); mtv.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View view, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG,"MyTextView_onTouch_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"MyTextView_onTouch_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"MyTextView_onTouch_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"MyTextView_onTouch_ACTION_CANCEL"); break; &#125; return false;③ &#125; &#125;); &#125; @Override public void onUserInteraction() &#123; super.onUserInteraction(); Log.e(TAG,"onUserInteraction"); &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"dispatchTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL"); break; &#125; return super.dispatchTouchEvent(event);① &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG,"onTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onTouchEvent_ACTION_CANCEL"); break; &#125; return super.onTouchEvent(event); &#125;&#125; 常规输出：(返回的都为默认值) 点击MyTextView区域 123456789E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MyTextView: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyTextView: dispatchTouchEvent_ACTION_UPE/MainActivity: MyTextView_onTouch_ACTION_UPE/MyTextView: onTouchEvent_ACTION_UPE/MainActivity: MyTextView_onclick 点击MyTextView外部区域 123456E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MainActivity: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_MOVEE/MainActivity: onTouchEvent_ACTION_MOVEE/MainActivity: dispatchTouchEvent_ACTION_UPE/MainActivity: onTouchEvent_ACTION_UP ① Activity的dispatchTouchEvent()return true;或return false; 1234E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_MOVEE/MainActivity: dispatchTouchEvent_ACTION_MOVEE/MainActivity: dispatchTouchEvent_ACTION_UP 不会再继续分发触摸事件，及后续控件的触摸事件都不会响应。 ② View的dispatchTouchEvent()return true;不会调用MyTextView的onClick事件 12345678E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MyTextView: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyTextView: dispatchTouchEvent_ACTION_UPE/MainActivity: MyTextView_onTouch_ACTION_UPE/MyTextView: onTouchEvent_ACTION_UP View的dispatchTouchEvent()return false;只响应MyTextView的ACTION_DOWN事件，后续的处理由MainActivity的onTouchEvent执行 1234567E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_MOVEE/MainActivity: onTouchEvent_ACTION_MOVEE/MainActivity: dispatchTouchEvent_ACTION_UPE/MainActivity: onTouchEvent_ACTION_UP ③Activity中View的onTouch()return true;不往下分发事件及不会调用到onClick事件 123456E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyTextView: dispatchTouchEvent_ACTION_UPE/MainActivity: MyTextView_onTouch_ACTION_UP ④ View的onTouchEvent()return true;不触发onClick事件 12345678E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MyTextView: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyTextView: dispatchTouchEvent_ACTION_UPE/MainActivity: MyTextView_onTouch_ACTION_UPE/MyTextView: onTouchEvent_ACTION_UP View的onTouchEvent()return false;只响应MyTextView的ACTION_DOWN事件，后续的处理由MainActivity的onTouchEvent执行 1234567E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MyTextView: onTouchEvent_ACTION_DOWNE/MainActivity: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MainActivity: onTouchEvent_ACTION_UP 总结： 触摸事件传递从dispatchTouchEvent开始，在不修改默认返回的数值时，事件会按照嵌套层次由外向内传递，到达最内层的View时，就由它的onTouchEvent处理。 若事件在传递过程中，返回参数设为true，则导致事件提前被消费，内层View无法处理事件 View的事件触发顺序为先执行onTouch方法，最后执行onClick方法。onTouch返回false，则会响应onClick，否则事件不会继续传递。 View的点击事件流程： Activity.dispatchTouchEvent() -&gt; View.dispatchTouchEvent()-&gt;View.onTouch()-&gt;View.onTouchEvent()-&gt;View.onClick() 4.ViewGroup事件传递机制ViewGroup作为View的容器存在，ViewGroup包括LinearLayout，RelativeLayout等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*** Custom ViewGroup with touchEvent*/public class MyRelativeLayout extends RelativeLayout &#123; public static final String TAG="MyRelativeLayout"; public MyRelativeLayout(Context context) &#123; super(context); &#125; public MyRelativeLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"dispatchTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL"); break; &#125; return super.dispatchTouchEvent(event); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG,"onInterceptTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onInterceptTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onInterceptTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onInterceptTouchEvent_ACTION_CANCEL"); break; &#125; return super.onInterceptTouchEvent(event);⑥ &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: Log.e(TAG,"onTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onTouchEvent_ACTION_CANCEL"); break; &#125; return super.onTouchEvent(event); &#125;&#125; 常规模式（全为默认值） 12345678910111213E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWNE/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWNE/MyTextView: dispatchTouchEvent_ACTION_DOWNE/MainActivity: MyTextView_onTouch_ACTION_DOWNE/MyTextView: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyRelativeLayout: dispatchTouchEvent_ACTION_UPE/MyRelativeLayout: onInterceptTouchEvent_ACTION_UPE/MyTextView: dispatchTouchEvent_ACTION_UPE/MainActivity: MyTextView_onTouch_ACTION_UPE/MyTextView: onTouchEvent_ACTION_UPE/MainActivity: MyTextView_onclick ViewGroup.onInterceptTouchEvent()返回true 123456789E/MainActivity: dispatchTouchEvent_ACTION_DOWNE/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWNE/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWNE/MainActivity: MyRelativeLayoutonTouch_ACTION_DOWNE/MyRelativeLayout: onTouchEvent_ACTION_DOWNE/MainActivity: dispatchTouchEvent_ACTION_UPE/MyRelativeLayout: dispatchTouchEvent_ACTION_UPE/MainActivity: MyRelativeLayout_onTouch_ACTION_UPE/MyRelativeLayout: onTouchEvent_ACTION_UP 总结: 对于一个包裹在ViewGroup中的View，点击发生的触摸流程为： Activity.dispatchTouchEvent()-&gt;ViewGroup.dispatchTouchEvent()-&gt;ViewGroup.onInterceptTouchEvent()-&gt;View.dispatchTouchEvent()-&gt;View.onTouch()-&gt;View.onTouchEvent()-&gt;View.onClick() dispatchTouchEvent事件分发逻辑如下： 如果 return true，事件会分发给当前 View 并由 dispatchTouchEvent 方法进行消费，同时事件会停止向下传递；如果 return false，事件分发分为两种情况：1.如果当前 View 获取的事件直接来自 Activity，则会将事件返回给 Activity 的 onTouchEvent 进行消费；2.如果当前 View 获取的事件来自外层父控件，则会将事件返回给父 View 的 onTouchEvent 进行消费。 onInterceptTouchEvent 的事件拦截逻辑如下： 如果 onInterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理； 如果 onInterceptTouchEvent 返回 false或super.onInterceptTouchEvent(ev)，则表示将事件放行，当前 View 上的事件会被传递到子 View 上，再由子 View 的 dispatchTouchEvent 来开始这个事件的分发； onTouchEvent 的事件响应逻辑如下： 如果事件传递到当前 View 的 onTouchEvent 方法，而该方法返回了 false，那么这个事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，如果传递到上面的 onTouchEvent 也返回 false，这个事件就会“消失”，而且接收不到下一次事件。 如果返回了 true 则会接收并消费该事件。 如果返回 super.onTouchEvent(ev) 默认处理事件的逻辑和返回 false 时相同。 5.源码分析//TODO 6.实例分析]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热修复基本原理]]></title>
    <url>%2F2018%2F04%2F07%2F%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle操作小记]]></title>
    <url>%2F2018%2F04%2F03%2FGradle%E6%93%8D%E4%BD%9C%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[显示所有依赖关系解析树1./gradlew app:dependencies 生成项目1./gradlew clean assembleEnvTestReleaseChannels -PchannelList=default 清理项目 1./gradlew clean]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XIII -- JVM垃圾回收]]></title>
    <url>%2F2018%2F04%2F03%2FAndroid-Study-Plan-XIII%2F</url>
    <content type="text"><![CDATA[Android学习计划简单描述下jvm的垃圾回收策略，比如引用计数、标记清除等策略JVM相关及其拓展(四)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常细节记录]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%97%A5%E5%B8%B8%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[强引用置为null时，不会立即回收对象，帮助回收器加快回收。但是会帮助GC 等到下次回收周期时即会回收 死锁的四个必要条件：互斥，占有且等待，不可抢占，循环等待 CAS(原子操作)是乐观锁用到的主要机制，乐观锁是不用加锁去执行操作，如果产生冲突则失败重试，直到成功为止，也叫做“自旋”。与乐观锁相对应的是悲观锁，synchronized就是悲观锁，也叫“独占锁”需要加锁进行操作，并且加锁代码块中的只能有一个线程进行操作。 点击App图标，系统最开始执行的是ActivityThread的main()方法 应用的启动方式： 冷启动：启动应用时，后台没有该应用的进程。系统创建一个新的进程来进行重新分配。 热启动：启动应用时，后台已有该应用的进程。 Application的生命周期：onCreate()//应用开始时执行-&gt;onLowMemory()//内存低时执行-&gt;onTrimMemory()//关闭应用时执行 onTerminate()//在真机上不会调用 进程相关： 优先级最低的进程首先被杀死、进程的等级会因为其他进程的依赖而提高一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低 按重要性分类： 前台进程：进程持有一个正在与用户交互的Activity或者和交互Activity绑定的Service，前台运行的Service（执行startForeground()）,执行onReceive()的BroadcastReceiver 可见进程：进程持有一个被用户可见但没有显示在最前端的Activity(调用到了onPause())或者和可见Activity绑定的Service 服务进程：进程持有一个startService()启动的Service进程，例如播放音乐，下载文件等Service 后台进程：进程持有一个用户不可见的Activity(调用到onStop()没有到onDestroy())，进程被存放在一个LRU列表中，即很长时间没用的Activity会被优先杀死 空进程：进程不包含任何活跃的应用组件，唯一的作用是为了缓存需要，缩短下次启动的时间 统计应用启动时间：adb shell am start -W [packageName]/[packageName.MainActivity] volatile作用是可见性(当一个线程修改了某一个全局变量的值，其他线程能否知道这个修改)，有序性（禁止指令重排优化,防止代码执行指令被重新排序）。volatile并不能保证线程安全即保证不了线程间操作的原子性。 SharedPreference中apply和commit方法的区别：commit同步保存更改，apply异步保存到磁盘，原子提交，性能较高，但不保存结果。SharedPreference不支持多线程操作，MODE_MULTI_PROCESS这个标记位并没有实际作用。可以利用ContentProvider去实现多进程，方案后续会有介绍。 MD5不是加密算法，是一种散列算法。加密算法一般是对称加密算法 使用ADB启动Activity：adb shell am start -n 包名/需启动Activity路径 Fragment中replace与add区别： replcae：把容器内所有内容进行替换，都需要重新走一遍fragment的生命周期 add：添加不会清空容器内的内容。 在三星手机上，进行原生分享文件时需要设置mimeType invalidate()、postInvalidate()和requestLayout()的区别： invalidate()：当子View调用invalidate方法时，会给View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递至ViewRootImpl中，最终触发performTraversals方法，进行View的重绘（即调用onDraw方法）。该方法只能在UI线程中调用 postInvalidate()：与invalidate作用一致，都是使View进行重绘，该方法是在非UI线程中调用的。内部主要实现是提供一个Handler实现，然后直接调用了invalidate方法，继续执行重绘流程。 requestLayout()：调用了这个方法会重新执行View的绘制流程，即重新执行测量(onMeasure)，布局(onLayout)，绘制(onDraw)方法。利用责任链模式-不断向上传递该事件，直到找到能处理该事件的上级。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XII]]></title>
    <url>%2F2018%2F04%2F01%2FAndroid-Study-Plan-XII%2F</url>
    <content type="text"><![CDATA[Android学习计划从源码的角度描述下Activity的启动过程]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity生命周期相关]]></title>
    <url>%2F2018%2F04%2F01%2FActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[回调方法介绍 onCreate()：Activity创建时调用，用于初始化工作，例如加载xml布局文件等 onStart()：Activity由不可见变为后台可见状态，不过还无法交互 onResume()：用户从后台或者跳转后的Activity回到原Activity时调用，让Activity回归前台 onPause()：启动新Activity时，原Activity会调用该方法并调用onStop方法不可在此回调中实现耗时方法,会影响新Acticity的启动 onStop()：Activity由可见变为完全不可见，若有对话框则依然可见，在onStop和onPause过程中的Activity优先级较低，容易被回收 onDestroy()：Activity即将被销毁，可在此做资源回收以及对象销毁的工作 onRestart()：Activity由不可见变为完全可见过程调用，当Activity从onStop过程中回到前台可见时调用，并随后调用onStart方法。 ​ onPostCreate()：在onCreate执行完毕之后的回调 onUserInteraction()：所有在Activity上执行的触摸事件都会优先调用该方法 onUserLeaveHint()：用户主动离开Activity会调用该方法，例如按Home键或者进入后台任务，系统事件导致的切换不会响应 onContentChanged()：当Activity调用setContentView方法结束后会调用该方法 onAttachedToWindow()：可以再方法中 进行Window窗口尺寸的修改 Activity几种状态下的生命周期变化 启动Activity:onCreate()-&gt;onStart()-&gt;onResume() Activity被覆盖或者锁屏时：onPause() Activity回到运行状态时:onResume() 当前Activity跳转到新的Activity或者Home键回到桌面时:onPause()-&gt;onStop() 后退回到上一Activity时：onRestart()-&gt;onStart()-&gt;onResume() 退出当前Activity：onPause()-&gt;onStop()-&gt;onDestroy() 下拉状态栏 对生命周期没有影响(捕捉下拉状态栏事件，使用onWindowFouceChanged()) 弹出Dialog：自己创造的Dialog不会有周期变化，其他创造的Dialog会执行onPause() 当发生Activity切换时，总是切换前的Activity先调用onPause方法，后执行其他方法。 新Activity主题为透明时，旧Activity不会走onStop()。 Activity被回收或者改变屏幕方向时信息的保存和恢复 onSaveInstanceState()保存信息 在被覆盖或者位于后台运行时，因为内存不足被回收时调用 屏幕发生旋转时会被调用 当前Activity发生跳转或者Home键响应导致应用位于后台 非主动销毁才会被调用 利用onSaveInstanceState()保存数据，执行于onPause()，onStop()之前 onRestoreInstaceState()恢复信息 在Activity被回收时，用户重新回到Activity 屏幕旋转Activity重建时 利用onRestoreInstanceState()恢复数据，执行于onStart() 之后 Activity任务栈 程序创建时就会创建一个Activity任务栈，存储当前程序的Activity，当前程序所有的Activity都是一个任务栈 任务栈是Activity的集合，只有位于栈顶的Activity可以和用户交互 任务栈可以移动到后台并保留了Activity的状态 退出应用程序时，要清理任务栈所有Activity，程序退出 Activity LaunchMode Android Study Plan III Activity启动过程 从Context的startActivity，调用ContextImpl的startActivity，内部实现由Instrumentation尝试启动Activity，这是一个跨进程的过程。继续调用AMS(ActivityManagerService)的startActivity方法，当校验完Activity的合法性后，利用ApplicationThread回调到我们自己的进程，这也是一个跨进程的过程，ApplicationThread就是一个Binder。回调逻辑在Binder线程池中完成，所以需要通过Handler将其切回UI线程，第一个消息时LAUNCH_ACTIVITY，对应着handleLaunchActivity，在这个方法里面完成Activity的创建和启动。接着在onResume中，Activity的内容渲染在Window上面，然后开始绘制流程。 Activity启动流程分析 Activty行为标志和属性 亲和性默认情况下，应用程序中的所有Activity，都有一个对于其他Activity的亲和性，这是一个对于同一个任务中的其他Activity的优先权，然后通过&lt;activity&gt;元素的taskAffinity属性可以分别为每一个activity设置亲和性。不同应用程序定义的activity可以共享一个亲和性，或者同一个应用程序定义的activity可以指定不同的亲和性。亲和性在两种情况下发挥作用： 启动一个包含FLAG_ACTIVITY_NEW_TASK标志的activity 新的Activity默认情况下，被加载进调用startActivity()方法的activity对象所在的任务中，被压入和调试者同一个栈中，但是如果传递了FLAG_ACTIVITY_NEW_TASK标志，系统会创建一个不同的任务栈容纳该Activity。若已经存在一个和该Activity亲和性相同的任务栈，该activity就会被加载进去，没有则重新创建任务栈。 activity的allowTaskReparenting属性设置为true 该activity可以从启动时所在的任务移动到另一个出现在前台的任务。举个栗子： 有一个activity负责展示数据，他作为一个数据展示应用程序的一部分，它和该应用中的其他activity有同样的亲和性，然后一个外部app调起了该activity，则该activity和外部app具有亲和性即在同一任务栈中。但是，当数据展示应用运行时，该activity会重新分配回到数据展示应用中。 清理栈用户离开一个任务很长时间，系统将清除除了根Activity之外的所有Activity，当用户重新回到应用中时，像是用户离开了它，只剩最初的Activity。考虑到过了一段时间用户可能会放弃之前做的所有事情，回到任务去做新的事情。有一些相关属性可以控制和修改机制： android:alwaysRetainTaskState 标记应用的task是否保持原来的状态，true总是保持,false则不能保证。若为true，则系统会保留所有的activity，例如在browser应用，可以替用户保留很多的tab。 android:clearTaskOnLaunch 标记是否从task清除除根activity之外的所有activity，true表示清除，false表示不清除。若为true，每次用户重启这个应用时，都只会看到根activity，即无论离开多久用户重新回归都只能看到根activity。特例：在我们应用中引用了其他应用的activity，且activity设置了allowTaskReparenting为true，则他们会被重新宿主到有共同affinity的task中。 android:finishOnTaskLaunch 作用与clearTaskOnLaunch类似，不过是作用于单个Activity，而非整个任务。可以设置任何Actiivty离开，即用户返回应用时，设置为true的Actiivty会消失。 特例：如果这个特性和allowTaskReparenting都为true，则该属性优先，Activity的affinity忽略。这个Activity不会重新宿主，但会被销毁。 其他方案 启动一个包含FLAG_ACTIVITY_CLEAR_TOP标志的Activity，则会清理所有栈中位于该实例之上的Activity。 ​ 查看当前任务栈方法 1adb shell dumpsys activity activities]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity,Window,View的关联与理解]]></title>
    <url>%2F2018%2F04%2F01%2FActivity-Window-View%E7%9A%84%E5%85%B3%E8%81%94%E4%B8%8E%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Activity,Window,View相关1. 什么是Activity,Window,View以及职能简介 Activity：不负责视图控制，只是控制生命周期和处理事件，真正控制视图的是Window，一个Activity包含一个Window，Window真正代表一个窗口。Activity是一个控制器，控制视图的添加与显示以及通过回调方法来进行Window与View的交互。 Window：Window是视图的承载器，内部持有一个DecorView，DecorView才是view的根布局，Window为抽象类，实际是Activity中的其子类PhoneWindow，其中有个内部类DecorView，通过创建DecorView来加载R.layout.*，Window通过WindowManager加载DecorView，并将DecorView和ViewRoot关联，进行视图控制与交互。 View：DecorView继承自FrameLayout,DecorView作为顶级View，一般其内部包含一个竖直方向的LinearLayout，里面包含ViewStub，标题栏（titleView），内容栏（contentView）。Activity通过setContentView()将布局文件加载进内容栏中。 ViewRoot：ViewRoot的实现类是ViewRootImpl，是WindowService和DecorView之间的纽带。ViewRoot不属于View节点，和View之间没有直接联系，不过实现了ViewParent接口。 2. Activity，Window，View的关系 基本关系是：Activity中展示元素通过Window实现，Window可以理解为一个容器，里面装载着一个个的View，来执行显示工作。 3. Activity如何和Window，View关联（附源码） Activity和Window关联 4. View和Window有什么联系]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan I]]></title>
    <url>%2F2018%2F03%2F24%2FAndroid-Study-Plan-I%2F</url>
    <content type="text"><![CDATA[Android 学习计划理解Java中的synchronized关键字。指标：理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。 有如下一个类A1234567class A &#123; public synchronized void a() &#123; &#125; public synchronized void b() &#123; &#125;&#125; 然后创建两个对象12A a1 = new A();A a2 = new A(); 然后在两个线程中并发访问如下代码：Thread1 Thread2a1.a(); a2.a(); 请问二者能否构成线程同步？ 如果A的定义是下面这种呢？1234567class A &#123; public static synchronized void a() &#123; &#125; public static synchronized void b() &#123; &#125;&#125; 答案Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。 Synchronized作用: 确保线程互斥的访问同步代码块 保证共享变量的修改能够及时可见 有效解决重排序问题 wait(),notify(),notifyAll(),sleep()作用 wait 调用线程 释放锁，然后进入休眠 sleep thread的一个操作方法，不释放锁直接进入休眠 notify 唤醒等待队列中的第一个相关进程 notifyAll 唤醒所有 Synchronized主修修饰对象为以下三种： 修饰普通方法 一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。 修饰静态方法 由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。 修饰代码块 其中普通代码块 如Synchronized（obj） 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。 简单来说 就是 Synchronized代码块更加灵活精确。 示例代码 12345678910111213141516171819202122public class SyncThread implements Runnable &#123; private static int count; public SyncThread() &#123; count = 0; &#125; @Override public void run() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; System.err.println(Thread.currentThread().getName() + " " + (count++)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static int getCount() &#123; return count; &#125;&#125; 修饰代码块1234567public static void main(String[] args) &#123; SyncThread syncThread = new SyncThread(); Thread thread1 = new Thread(syncThread, "sync1"); Thread thread2 = new Thread(syncThread, "sync2"); thread1.start(); thread2.start(); &#125; 访问的同一个对象时，同一时刻只能有一个线程执行，执行代码块是会锁定当前对象，所以需要执行完才能释放，下一个线程才能继续执行并锁定对象 运行结果 12345678910sync1 0sync1 1sync1 2sync1 3sync1 4sync2 5sync2 6sync2 7sync2 8sync2 9 修饰对象123456public static void main(String[] args) &#123; Thread thread1 = new Thread(new SyncThread(), "sync1"); Thread thread2 = new Thread(new SyncThread(), "sync2"); thread1.start(); thread2.start(); &#125; 这时创建了两个SyncThread对象，线程1执行对象1中的同步代码，线程2执行的是对象2的代码，这时两把锁分别锁定SyncThread1和SyncThread2对象，两把锁互不干扰也不互斥，所以同时执行。 运行结果 12345678910sync1 0sync2 1sync1 2sync2 3sync1 4sync2 5sync1 6sync2 7sync1 8sync2 9 问题1 ：不能同步 a1.a()锁是a1 a2.b()锁是a2 不是同一把锁 所以不同步问题2：能同步 锁都为A.class对象，是统一把锁]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础排序算法介绍]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基础排序算法介绍知识点: 排序算法稳定性的定义：简单的介绍就是排序前相等的数据先后顺序在排序后的先后顺序位置相同 基本交换算法 12345private static void swap(int[] array, int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp;&#125; 时间复杂度：执行算法所需要的计算工作量 $ O(1) $ 意味没有循环即只执行单条语句 $ O(n) $ 执行没有嵌套的循环 $ O(n^2) $ 双重嵌套循环 空间复杂度：算法在运行工程中临时占用存储空间的量度 算法 平均时间 最好 最差 空间复杂度 稳定性 冒泡排序 $ O(n^2) $ $ O(n) $ $ O(n^2) $ $ O(1) $ 稳定 直接插入排序 $ O(n^2) $ $ O(n) $ $ O(n^2) $ $ O(1) $ 稳定 折半插入排序 $ O(nlogn) $ $ O(nlogn) $ $ O(n^2) $ $ O(1) $ 稳定 希尔排序 $ O(nlogn) $ - $ O(n^2) $ $ O(n^1.3) $ $ O(n^2) $ $ O(1) $ 不稳定 选择排序 $ O(n^2) $ $ O(n^2) $ $ O(n^2) $ $ O(1) $ 不稳定 快速排序 $ O(nlogn) $ $ O(nlogn) $ $ O(n^2) $ $ O(nlogn) $ - $ O(n^2) $ 不稳定 归并排序 $ O(nlogn) $ $ O(nlogn) $ $ O(nlogn) $ $ O(n) $ 稳定 堆排序 $ O(nlogn) $ $ O(nlogn) $ $ O(nlogn) $ $ O(1) $ 不稳定 排序算法冒泡排序 在要排序的一组数中，对当前范围内还未排列好的数据由上而下进行比较，即每当相邻的数与要求的排序方式相反时将数据进行互换改进版的写法就是利用标记法减少循环次数 基本写法12345678910private static void bubbleSort(int[] array) &#123; int size = array.length; for (int i = 0; i &lt; size - 1; i++) &#123; for (int j = 1; j &lt; size - i; j++) &#123; if (array[j - 1] &gt; array[j]) &#123; swap(array, j, j - 1); &#125; &#125; &#125; &#125; 改进写法123456789101112131415private static void advancedBubbleSort(int[] array) &#123; int size = array.length; int flag = 0;//设置标记位 for (int i = 0; i &lt; size - 1; i++) &#123; flag = 0; for (int j = 1; j &lt; size - i; j++) &#123; if (array[j - 1] &gt; array[j]) &#123; flag = 1; swap(array, j, j - 1); &#125; &#125; if (flag == 0)//没有发生数据交换则意味着排序已经结束 break; &#125; &#125; 选择排序 再一次遍历过程中找到最小值放在排序数据中的首位，每次寻找剩余中最小的直到结束为止。 123456789101112private static void selectSort(int[] array) &#123; int size = array.length; for (int i = 0; i &lt; size; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; size; j++) &#123; if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; swap(array, i, minIndex); &#125; &#125; 直接插入排序 按照顺序选定元素从后往前找，插入一个顺序数列中即可 12345678910private static void InsertSort(int[] array) &#123; int size = array.length; for (int i = 0; i &lt; size; i++) &#123; int temp = array[i]; for (int j = i; j &gt; 0 &amp;&amp; array[j - 1] &gt; array[j]; j--) &#123;//从该元素所在位置 向前移动 直到该元素位于 递增顺序 array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; &#125; 折半插入排序 再往前寻找位置的过程中利用二分法寻找位置 123456789101112131415161718192021private static void insertBinarySort(int[] array) &#123; int size = array.length; for (int i = 1; i &lt; size; i++) &#123; if (array[i] &lt; array[i - 1]) &#123;//前比后大 int temp = array[i]; int low = 0, high = i - 1, mid; while (low &lt;= high) &#123;//直到相交或者相反 mid = (low + high) / 2;//折中取点 if (temp &lt; array[mid]) &#123;//小于中点则位于中点左侧 high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; for (int j = i; j &gt; low; j--) &#123; array[j] = array[j - 1]; &#125; array[low] = temp;//低点使用temp &#125; &#125; &#125; 希尔排序 先取d为间隔，将原始数组分为d个序列，将间隔的数组放在一个子序列利用插入排序法进行排序 然后缩小间隔d 重复上述操作，知道d为1时，则排序完成 12345678910111213private static void shellSort(int[] array) &#123; int size = array.length; for (int d = size / 2; d &gt; 0; d /= 2) &#123;//设置步长 for (int i = 0; i &lt; size; i += d) &#123; int temp = array[i]; int j = i; for (; j &gt;= d &amp;&amp; temp &lt; array[j - d]; j -= d) &#123; array[j] = array[j - d]; &#125; array[j] = temp; &#125; &#125; &#125; 基数排序 讲一组元素进行桶分配，按照每位数的大小进行排序 12345678910111213141516171819202122232425262728293031323334353637383940414243private static void radixSort(int[] array) &#123; int size = array.length; int max = array[0];//数组中的最大数 for (int i = 0; i &lt; size; i++) &#123; if (array[i] &gt; max) max = array[i]; &#125; int time = 0;//最大位数 while (max &gt; 0) &#123; max /= 10; time++; &#125; int k = 0;//索引 int m = 1;//位值 int n = 1;//第几位 int[][] temp = new int[10][size]; int[] order = new int[10]; while (m &lt;= time) &#123; for (int arr : array) &#123; int lsd = (arr / n) % 10; temp[lsd][order[lsd]] = arr; order[lsd]++; &#125; for (int i = 0; i &lt; 10; i++) &#123; if (order[i] != 0) &#123; for (int j = 0; j &lt; order[i]; j++) &#123; array[k] = temp[i][j]; k++; &#125; &#125; order[i] = 0; &#125; n *= 10; k = 0; m++; &#125;&#125; 快速排序 通过排序将待排序记录分成两部分，其中一部分记录的关键字均比另一部分小，然后分别对这两部分进行排序，直到整个序列有序。快速排序在元素很少时，效率很低 1234567891011121314151617181920private static void quickSort(int[] arr,int l,int r)&#123; if(l&gt;=r) return; int p=getMiddle(arr,l,r);//取出中点 quickSort(arr,l,p-1);//对左侧进行排序 quickSort(arr,p+1,r);//对右侧进行排序&#125; private static int getMiddle(int[] arr, int l, int r) &#123; int temp = arr[l];//定义左侧为基点 int middle = l; for (int i = middle + 1; i &lt;= r; i++) &#123; if (arr[i] &lt; temp) &#123; swap(arr, middle + 1, i); middle++; &#125; &#125; swap(arr, l, middle); return middle; &#125; 归并排序 把待排序序列分成若干个有序子序列，然后再把子序列合并成一个有序序列。 1234567891011121314151617181920212223242526272829303132333435private static void mergeSort(int[] arr, int l, int r) &#123; int mid = (l + r) / 2; if (l &lt; r) &#123; mergeSort(arr, l, mid); mergeSort(arr, mid + 1, r); merge(arr, l, mid, r); &#125;&#125;private static void merge(int[] arr, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; //左指针 int i = low; //右指针 int j = mid + 1; int index = 0; //把较小的数 移动到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (arr[i] &lt; arr[j]) &#123; temp[index++] = arr[i++]; &#125; else &#123; temp[index++] = arr[j++]; &#125; &#125; //把左边剩余的数移到新数组中 while (i &lt;= mid) &#123; temp[index++] = arr[i++]; &#125; //把右边剩余的数移到新数组中 while (j &lt;= high) &#123; temp[index++] = arr[j++]; &#125; //得到新的数据 覆盖原有部分 System.arraycopy(temp, 0, arr, low, temp.length);&#125; 堆排序 将数组构成大堆二叉树，即父节点比子节点大的二叉树，然后每次将根节点放在最后一位，循环遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 堆排序 * @param arr */private static void heapSort(int[] arr) &#123; //预先构建一次大堆二叉树 buildMaxHeap(arr); int length = arr.length; for (int i = length - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); maxHeap(arr, i, 0); &#125;&#125;/** * */private static void buildMaxHeap(int[] arr) &#123; int length = arr.length; for (int i = length / 2 - 1; i &gt;= 0; i--) &#123; maxHeap(arr, length, i); &#125;&#125;/** * 构建大堆二叉树节点 */private static void maxHeap(int[] arr, int length, int node) &#123; int left = 2 * node + 1; int right = 2 * node + 2; int maxIndex = node; if (left &lt; length &amp;&amp; arr[left] &gt; arr[maxIndex]) &#123; maxIndex = left; &#125; if (right &lt; length &amp;&amp; arr[right] &gt; arr[maxIndex]) &#123; maxIndex = right; &#125; //如果不是父节点最大，则找到最大的子节点进行调换 if (maxIndex != node) &#123; swap(arr, node, maxIndex); maxHeap(arr, length, maxIndex); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XI]]></title>
    <url>%2F2018%2F03%2F19%2FAndroid-Study-Plan-XI%2F</url>
    <content type="text"><![CDATA[Android学习计划话题：Okhttp和Retrofit 1、介绍这两个框架的作用和联系PS：这个问题几乎Android面试必问]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide源码解析要点]]></title>
    <url>%2F2018%2F03%2F18%2FGlide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[该源码解析是基于最新的Glide 4.6.0进行的]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan X]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-X%2F</url>
    <content type="text"><![CDATA[Android学习计划什么是Binder？简单描述下它的工作过程和使用场景]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan IX]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-IX%2F</url>
    <content type="text"><![CDATA[Android学习计划话题：Android中的ClassLoader1、Android中有哪几种ClassLoader？它们的作用和区别是什么？2、简述ClassLoader的双亲委托模型3、简述双亲委托模型在热修复领域的应用 答案1.Android中有哪几种ClassLoader？它们的作用和区别是什么？ 在Android程序中，.dex文件就是一群.class文件。 BootClassLoader BootClassLodaer是ClassLoader内部实现类，是只能包内可见，我们是无法调用的。在无父构造器传入的情况下，默认构建一个PathClassLoader且父构造器为BootClassLoader 12345private static ClassLoader createSystemClassLoader() &#123; String classPath = System.getProperty("java.class.path", "."); String librarySearchPath = System.getProperty("java.library.path", ""); return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance()); &#125; URLClassLoader 只能用于加载jar文件，但是在dalvik（Android5.0之前的虚拟机）无法直接识别jar，所以Android中无法使用这个加载器。 BaseDexClassLoader 用于加载各种dex中的类 123456public class BaseDexClassLoader extends ClassLoader &#123; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; throw new RuntimeException("Stub!"); &#125; ...&#125; 主要构造函数介绍： dexPath：指目标类所在的apk、dex或jar文件的路径，也可以是SD卡的路径，类加载器从该路径加载目标类。如果包含多个路径，路径之间必须用特定的分隔符去分隔，特定的分隔符从System.getProperty(&quot;path.separtor&quot;)获取（默认分割符为”:”）。最终将路径上的文件ODEX优化到optimizedDirectory，然后进行加载。 optimizedDirectory：解压出的dex文件路径，这个路径必须为内部路径，一般情况下的路径为/data/data/&lt;Package_Name&gt;/ librarySearchPath：存放目标类中使用的native文件库，也以”:”分割 parent：父加载器，在Android中以context.getClassLoader作为父加载器。 DexClassLoader 继承自BaseDexClassLoader，支持加载包含classes.dex的jar、apk，zip文件，可以是SD卡的路径。是实现热修复的关键。注意不要把优化后的文件放在外部存储，可能导致注入攻击。 PathClassLoader 用来加载Android系统类和应用程序的类，在dalvik上只能加载已安装apk的dex(/data/app目录)，在ART虚拟机上则没有这个限制。 1234567891011public class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); &#125; public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); &#125;&#125; 在PathDexClassLoader的构造方法中optimizedDirectory为null，因为默认参数为/data/dalvik-cache目录。 InMemoryDexClassLoader 用于加载内存中的dex文件(在API26中添加) 12345678910public final class InMemoryDexClassLoader extends BaseDexClassLoader &#123; public InMemoryDexClassLoader(ByteBuffer[] dexBuffers, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); &#125; public InMemoryDexClassLoader(ByteBuffer dexBuffer, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); &#125;&#125; DelegateClassLoader 是一个先查找在委托的类加载器(API27添加)，按照以下顺序实现加载： 首先判断该类是否被加载 搜索此类的类加载器是否加载过这个类 使用当前加载器去尝试加载类 最后委托给父加载器加载 2.简述ClassLoader的双亲委托模型JVM相关及其拓展(三) 3.简述双亲委托模型在热修复领域的应用一个ClassLoader文件可以有多少Dex文件，每个Dex文件是一个Element，多个Dex文件组成一个有序数组DexElements，当找类的时候会按照顺序遍历Dex文件，然后在当前遍历的Dex文件中找出类。由于双亲委托模型机制的存在，只要找到类就会停止检索并返回，找不到就会查询下一个Dex，所以只要我们先找到并加载修复Bug的文件，则有bug的Dex文件不会被加载。 注意点：假设有个A类，引用了B类。发布过程中发现B类有bug，若想要发个新的B类，需要阻止A加上这个类标志CLASS_ISPREVERIFIED。 4. 基本热修复代码实现]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan VIII]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-VIII%2F</url>
    <content type="text"><![CDATA[Android学习计划话题：Java基础知识学习1、Java中有哪几种引用？它们的含义和区别是什么？2、请用Java实现一个线程安全且高效的单例模式。 答案1. Java中有哪几种引用？它们的含义和区别是什么？ 强引用（StrongReference）：无论内存是否充足，都不会被回收强引用指的是在代码中普遍存在的类似Object object=new Object();这类的引用，只要有这类的存在，垃圾回收器永远不会回收该对象，这也是导致OOM异常出现的主要原因。若想中断强引用可以把对象置为null。 弱引用（WeakReference）：内存不足时，会被回收弱引用用来修饰非必需对象，弱引用所关联的对象生命周期只到下一次垃圾回收前，无论内存是否充足都会被回收关联对象。 123String s=new String("abc");WeakReference&lt;String&gt; weakReference=new WeakReference&lt;&gt;(s);//当内存回收时 调用weakRefrence=null 并且 System.gc(); 软引用（SoftReference）：无论内存是否充足，都会被回收软引用用来修饰一些有用但非必需的对象，软引用所关联的对象将会在系统即将发生OOM前，会把对象进行二次回收，若回收完内存还是不足则会发生OOM异常。可实现内存敏感的高速缓存 123String s=new String("abc");SoftReference&lt;String&gt; softReference=new SoftReference&lt;&gt;(s);//当内存不足时 会调用 softRefrence=null 并且 System.gc(); 虚引用（PhantomReference）：任何时候都会被回收虚引用不会决定对象的生命周期，虚引用关联的对象任何时候都可能被垃圾回收器回收。虚引用的作用是：跟踪对象被垃圾回收器回收的活动，虚引用本身加入引用队列中，记录引用对象是都被回收。 2. 请用Java实现一个线程安全且高效的单例模式。 单例：一个类有且仅有一个实例，并且自行实例化向整个系统提供。目的为 减少内存的占用 阻止对象实例化自己的单例对象副本，从而确保所有对象访问统一实例 控制了实例化过程所以可以灵活化控制实例过程。 线程安全：再多线程访问时采用加锁机制，当一个线程访问该数据时，其他线程不能访问该数据，直到读取完毕才可以访问。不会出现数据不一致和数据污染。 双重校验锁（DCL） 12345678910111213141516public class Singleton &#123; private static volatile Singleton mInstance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (mInstance == null) &#123; synchronized (Singleton.class) &#123; if (mInstance == null) &#123; mInstance = new Singleton(); &#125; &#125; &#125; return mInstance; &#125;&#125; 在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则mInstance = new Singleton();可能出现mInstance尚未被初始化的异常。mInstance = new Singleton();包括三步：为对象分配内存，执行构造方法，初始化实例对象，把mInstance的引用指向分配的内存空间。在JVM的执行过程中并不是原子性的。保护序列化与反序列化安全的写法：123456/***反序列化提供的一个特殊方法，可以控制对象的反序列化。*/private Object readResolve()&#123; return mInstance;//返回实例对象 &#125; 静态内部类： 为何可以保证线程安全？虚拟机可以保证一个类的类构造器 &lt;clinit&gt;()在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。同一个类加载器下，一个类型只会被初始化一次。 123456789101112public class Singleton &#123; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return SingletonHolder.sInstance; &#125; private static class SingletonHolder &#123; private static Singleton sInstance = new Singleton(); &#125;&#125; 枚举写法（在Android中不推荐使用，对内存的消耗较大）枚举法的好处：1.实例创建线程安全 2.防止被反射创建多个实例 3. 没有序列化的问题 1234567public enum Singleton&#123; INSTANCE; public void fun() &#123; //do sth &#125;&#125; 3. 拓展知识 Kotlin实现的单例模式：object Singleton{}，本质是饿汉加载，在类加载时就会创建单例。问题在于构造方法过多时，初始化会变慢以及资源的浪费。 Kotlin实现懒汉式加载： 12345class Singleton private constructor()&#123; companion object &#123; val instance: Singleton by lazy &#123; Singleton() &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan VII]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-VII%2F</url>
    <content type="text"><![CDATA[Android学习计划话题：关于序列化的知识1、Parcelable和Serializable有什么用，它们有什么差别？2、自定义一个类让其实现Parcelable，大致流程是什么? 答案：1. Parcelable和Serializable有什么用，它们有什么差别？ 什么是序列化？将对象转化为可以传输的二进制流的过程，就可以通过序列化，转化为可以在网络传输或者保存到本地的流，从而进行传输数据。反序列化即为从二进制流转化为对象的过程。也为了解决对象的持久化问题。当你在程序中声明一个类后，程序关闭则释放对象，持久化就是为了应用关闭后类的内容依然存在。 Parcelable和Serializable有什么用?两者都可以实现序列化，使对象变为二进制流在内存中传递。在开发中只要实现两者之一就可以进行数据的传递利用Intent和Binder。Serializable：Serializable是Java提供的一个序列化接口，需要序列化的对象只要实现了该接口，并选择性的声明serialVersionUID即可。序列化的机制依赖于该参数，不指定则会自动计算生成，当类发生变化时，该参数也会产生变化，将会导致反序列化失败的问题。如果显式的指定了该值，只要类的结构不发生大变化（更改类型，修改字段类型，添加或删除字段）都可以序列化成功。Parcelable：Parcelable是Android提供的一个序列化接口且仅能在Android中使用。使用相对复杂但是效率很高。序列化过程需要实现writeToParcel(Parcel dest, int flags),describeContents()方法，以及为了反序列化，还需要设置一个非空的CREATOR字段。 Parcelable和Serializable差别Parcelable不需要IO操作，Serializable需要大量的IO操作，会产生很多临时对象造成频繁的GC。Parcelable序列化的数据仅在内存中存在，如Activity间传递数据或者进程间通信使用Parcelable，在需要持久保存或者网络传输时使用SerializableAndroid版本不同可能Parcelable也会有变化，不建议进行数据持久化操作。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan VI]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-VI%2F</url>
    <content type="text"><![CDATA[Android学习计划话题：关于Gradle的知识1、如何理解Gradle？Grade在Android的构建过程中有什么作用？2、实践如下问题。 问题：我们都知道，Android中时常需要发布渠道包，需要将渠道信息附加到apk中，然后在程序启动的时候读取渠道信息。动态指定一个渠道号（比如1001），那么构建的apk中，请在它的AndroidManifest.xml文件里面的application节点下面添加如下meta-data，请写一段Gradle脚本来自动完成：123 &lt;application android:allowBackup="false" android:supportsRtl="true"&gt; &lt;meta-data android:name=“channel" android:value=“1001" /&gt;&lt;/application&gt; 要求：当通过如下命令来构建渠道包的时候，将渠道号自动添加到apk的manifest中。./gradlew clean assembleRelease -P channel=1001]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan V]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-V%2F</url>
    <content type="text"><![CDATA[Android学习计划话题：关于View的知识 1、View的getWidth()和getMeasuredWidth()有什么区别吗？2、如何在onCreate中拿到View的宽度和高度？ 答案1. View的getWidth()和getMeasuredWidth()有什么区别吗？ getWidth()通过setFrame方法来决定四个顶点位置，初始化mLeft,mTop,mRight,mBottom四个参数，这四个值固定则位置确定。必须在layout过程结束才有值。 12345678910111213141516171819 /** * Return the width of the your view. * * @return The width of your view, in pixels. * 利用屏幕上的右坐标减去左边的坐标 */ @ViewDebug.ExportedProperty(category = "layout") public final int getWidth() &#123; return mRight - mLeft; &#125; protected boolean setFrame(int left, int top, int right, int bottom) &#123; ... mLeft = left; mTop = top; mRight = right; mBottom = bottom;... &#125; getMeasuredWidth是在view的绘制流程中的measure结束后有值，获取的是view的测量宽高。mMeasuredWidth是在setMeasuredDimensionRaw方法中赋值的 123456789101112131415161718public static final int MEASURED\_SIZE\_MASK = 0x00ffffff; /** * Like &#123;@link #getMeasuredWidthAndState()&#125;, but only returns the * raw width component (that is the result is masked by * &#123;@link #MEASURED_SIZE_MASK&#125;). * * @return The raw measured width of this view. */ public final int getMeasuredWidth() &#123; return mMeasuredWidth &amp; MEASURED_SIZE_MASK;//与任何数字的运算得到的结果是mMeasuredWidth &#125; private void setMeasuredDimensionRaw(int measuredWidth, measuredHeight) &#123; mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; &#125; 一般情况下 getMeasuredWidth和getWidth的值是相同的，从源码中可以看出setMeasuredDimensionRaw会对mMeasuredWidth进行赋值，当调用了onMeasure，会调用到setMeasuredDimensionRaw则获取的结果将会不相同 1234567891011121314151617181920212223242526272829303132333435363738394041public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); &#125; ... if (forceLayout || needsLayout) &#123; // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123; throw new IllegalStateException("View with id " + getId() + ": " + getClass().getName() + "#onMeasure() did not set the" + " measured dimension by calling" + " setMeasuredDimension()"); &#125; mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; &#125; ... &#125; view的绘制流程measure layout draw measure为了计算出控件树中的各个控件要显示的内容以及大小，起点为ViewRootImpl 的 measureHierarchy ()。 SpecMode : EXACTLY(确切大小) AT_MOST(子view的大小不得超过SpecSize) UNSPECIFIED(对子view尺寸不做限制) 123456789101112131415161718/** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */ public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */ public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The child can be as large as it wants up * to the specified size. */ public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; layout 从根view开始，递归的完成控件树的布局工作，确定view的位置。先递归的对子view进行布局，在完成父布局的位置设置 draw 从根view开始进行绘制，利用Viwe.draw() 2.如何在onCreate中拿到View的宽度和高度？ 在 Activity#onWindowFocusChanged 回调中获取宽高。 view.post(runnable)，在 runnable 中获取宽高。 利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。 ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。 监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露 调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高。 补充知识点 matchParent无法measure(在view的measure过程中，需要知道parentSize即父容器的剩余空间，所以无法得出measure的大小) 深入理解View绘制流程]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan IV]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-IV%2F</url>
    <content type="text"><![CDATA[Android学习计划 话题：关于startActivityForResult1、startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode以及intent含义是什么？2、Activity A启动B的时候，在B中何时该执行setResult ？setResult可以位于Activity的finish方法之后吗？ 答案1. startActivityForResult 使用场景是什么？ requestCode、 resultCode 含义是什么？1.1 使用场景 用户开始新的活动，并且希望得到新活动的某些信息。比如选择照片、选择联系人、选择收货地址、进行某块数据编辑工作等。 1.2 requestCode 解决的是「区分多个异步任务」的问题。与其他异步 API 的设计类似，如果没有这个信息，那么 Activity 在收到响应时会进入混乱的状态。比如他不知道自己得到的是选择照片还是选择联系人的结果。 该信息会发送到 AMS 那边的 ActivityRecord.requestCode 变量进行记录，Client 端新 Activity 并不知道这个信息。 为什么 requestCode\&lt; 0 时收不到结果？ ActivityStarter 收到 startActivityLocked 时，写入ActivityRecord.resultTo 变量为空对应源码123456789101112ActivityRecord sourceRecord = null;ActivityRecord resultRecord = null;if (resultTo != null) &#123; sourceRecord = mSupervisor.isInAnyStackLocked(resultTo); if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, "Will send result to " + resultTo + " " + sourceRecord); if (sourceRecord != null) &#123; if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; resultRecord = sourceRecord; &#125; &#125;&#125; 在 ActivityStack 收到 finishActivityResultsLocked 时，读取 ActivityRecord.resultTo 变量为空，结果数据不会添加到源 ActivityRecord.results 变量 在 ActivityStack 收到 resumeTopActivityInnerLocked 时，读取 ActivityRecord.results 数组为空，不会分发结果数据，这样源 Activity 也就没有结果回调了 1.3 resultCode 异步调用结果码，告诉调用者成功/失败/其它信息 该信息由被调用 Activity / framework 写入，并经过 AMS 传递给源 Activity RESULT_CANCELED=0 RESULT_OK=-1 RESULT_FIRST_USER=11.4 intent 用于存储需要传递的数据 大小不得大于1M 2. A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？2.1 setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中Activity 构造器阶段大部分在显示调用finish()或者onBackPressed() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 public final void setResult(int resultCode, Intent data) &#123;//进行赋值 synchronized (this) &#123; mResultCode = resultCode; mResultData = data; &#125; &#125; // Home 键 + 不保留后台 Activity 可触发 onDestroyprotected void onDestroy() &#123; if (DEBUG_LIFECYCLE) Slog.v(TAG, "onDestroy " + this); mCalled = true; // dismiss any dialogs we are managing. if (mManagedDialogs != null) &#123; final int numDialogs = mManagedDialogs.size(); for (int i = 0; i &lt; numDialogs; i++) &#123; final ManagedDialog md = mManagedDialogs.valueAt(i); if (md.mDialog.isShowing()) &#123; md.mDialog.dismiss(); &#125; &#125; mManagedDialogs = null; &#125; // close any cursors we are managing. synchronized (mManagedCursors) &#123; int numCursors = mManagedCursors.size(); for (int i = 0; i &lt; numCursors; i++) &#123; ManagedCursor c = mManagedCursors.get(i); if (c != null) &#123; c.mCursor.close(); &#125; &#125; mManagedCursors.clear(); &#125; // Close any open search dialog if (mSearchManager != null) &#123; mSearchManager.stopSearch(); &#125; if (mActionBar != null) &#123; mActionBar.onDestroy(); &#125; getApplication().dispatchActivityDestroyed(this); &#125; private void finish(int finishTask) &#123; if (mParent == null) &#123; int resultCode; Intent resultData; synchronized (this) &#123; resultCode = mResultCode; resultData = mResultData; &#125; if (false) Log.v(TAG, "Finishing self: token=" + mToken); try &#123; if (resultData != null) &#123; resultData.prepareToLeaveProcess(this); &#125; if (ActivityManager.getService() .finishActivity(mToken, resultCode, resultData, finishTask)) &#123; mFinished = true; &#125; &#125; catch (RemoteException e) &#123; // Empty &#125; &#125; else &#123; mParent.finishFromChild(this); &#125; &#125; 2.2 否 如果位于 finish 之后执行，信息已经无法放到传递的数据中 从代码可以看出 setResult 和 finish 类似生产者/消费者模型，setResult 负责写入数据，finish 负责读取数据 2.3 线程安全问题 Activity.mResultCode 和 Activity.mResultData 变量由 Activity 对象的锁进行保护 支持后台线程和 UI 线程分别进行 setResult 和 finish 但是为什么需要加锁保护这两个信息？需要「解决什么问题」？ 2.4 API 设计/数据组装问题 底层 AMS 提供的接口的参数是 setResult 和 finish 的参数的组合形式，但是 Activity 为什么把一个接口拆分成两个接口给开发者使用？ 使用方便。很多情况下调用者只关心 finish ，不需要理解太多的信息 2.5 启动模式冲突 5.0以上 singleTask和singleInstance失效，重复启动时会重新创建实例 以下 则会直接收到RESULT_CANCELED 3. API 内部原理/数据处理流程 关键节点： Client 端通过 AMP 把数据发送给 Server 端 AMS Binder 实体 AMS 把数据包装成 ActivityResult 并保存在源 ActivityRecord 的 results 变量中 AMS 通过 ApplicationThreadProxy 向 Client 端发送 pause 信息让栈顶 Activity 进入 paused 状态，并等待 Client 端回复或超时 AMS 接收 Client 端已 paused 信息，恢复下一个获取焦点的 Activity ，读取之前保存在 ActivityRecord.results 变量的数据派发给 Client 端对应的 Activity Client 端数据经过 ApplicationThread 对象、ActivityThread 对象的分发最后到达 Activity 4. startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题4.1 基本原则 源 Activity 和目标 Activity 无法在跨 Task 情况下通过 onActivityResult 传递数据 4.2 Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调 源码链接 4.3 Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调源码链接 4.4 通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan III]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-III%2F</url>
    <content type="text"><![CDATA[Android学习计划话题：理解Activity的启动模式。1、Activity的启动模式有哪几种，分别用于什么场景？2、清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？ 答案1. Activity的启动模式有哪几种，分别用于什么场景 standard:标准模式多实例模式，每次启动一个Activity都会重新创建新的实例，若启动者是除Activity之外的context则需指定FLAG_ACTIVITY_NEW_TASK标记位，创建新栈，不然报出异常 android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. singleTop:栈顶复用模式 (FLAG_ACTIVITY_SINGLE_TOP)若Activity实例已经存在栈顶，则启动时不会创建新的实例而是回调onNewIntent()方法,若不在栈顶则会创建新的实例。onResume()会被调用 singleTask:栈内复用模式 (FLAG_ACTIVITY_NEW_TASK)栈内只要存在Activity实例，再次启动都不会重新创建实例，只会回调onNewIntent()方法,并从栈内弹出所有实例之上的所有。适合作为入口点，作为主页面，因为只会启动一次。 taskAffinity代指Activity希望进入的Task栈，默认是应用包名 singleInstance:单实例模式具有singleTask所有特性，不过单独存在一个任务栈中。启动时会新开一个任务栈，并直接创建实例，压入新开的任务栈中。 2. 清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？ onNewIntent singleTop模式下启动的Activity并在任务栈中存在 singleTask模式启动的Activity并在任务栈中存在 singleInstance模式启动的Activity并存在一个包含实例的栈 可以通过setIntent(intent)刷新intent数据 onConfigurationChanged 当系统配置信息发生变化时，系统调用该方法。需在AndroidManifests文件中处理了configChanges属性，才会被调用。默认会销毁当前Activity并重新创建一次来加载最新的配置信息。 若配置了configChanges 则不会重启Activity，若改变的配置不在你配置的选项中，则依然会重启，则不调用方法 configChanges常用取值 locale：选择一种新的语言 touchscreen：更换手机屏幕 keyboard：键盘类型发生改变 keyboardHidden：键盘是否显示 navigation：导航栏发生变化 screenLayout：手机屏幕布局发生变化 fontScale：手机字体大小发生改变 orientation：手机屏幕切换（运行在Api13以上，需要添加screenSize） screenSize：可用屏幕大小发生改变 layoutDirection：手机屏幕左右或上下互换]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan II]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-II%2F</url>
    <content type="text"><![CDATA[Android学习计划话题：清晰地理解Service。1、Service的start和bind状态有什么区别？2、同一个Service，先startService，然后再bindService，如何把它停止掉？3、你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？4、Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？ 答案 1.Service的start和bind状态有什么区别？start启动Service,service有独立的生命周期，不依赖启动组件；多次调用start方法，会重复调用onStartCommand方法；（判断service是否正在运行以避免多次调用）start启动的Service，需要stopService或stopSelf来停止（IntentService会自动调用）。 生命周期:onCreate()->onStartCommand()->onDestory() bind绑定的Service，依赖于启动组件，销毁后随之消失；多次bind，只会调用一次onBind方法 生命周期:onCreate()->onBind()->onUnBind()->onDestory() 2.同一个Service，先startService，然后再bindService，如何把它停止掉？调用stopService和unbindService方法，顺序无关，当最后一次调用时，会进入Service的onDestory方法 3.你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？4种返回值1234567891011121314151617//版本兼容，在Service被杀死后，并不保证onStartCommand会被再一次调用//Service被kill后，Service被重建，即会调用onCreate()public static final int START_STICKY_COMPATIBILITY = 0;/**在Service被杀死后，系统会尝试重启Service但不保存intent，会用一个null对象调用 onStartCommand方法（注意intent判空），除非有一些被发送的Intent对象在等待 Service被kill后，Service被重建、重启，即会调用onCreate()&gt;onStartCommand()，intent对象为null。启动服务，试用于媒体播放器之类，无限期等待*/public static final int START_STICKY = 1;/**常规操作，除非被杀死之前还有组件调用startService，否则不保留状态并重启Service 直到接受到新的Intent对象，这个服务才会被重新创建Service被kill后，Service没有重启*/public static final int START_NOT_STICKY = 2;/**Service被杀死后，系统将会组织一次重启Service，在杀死前的最后一次传递的intent会被重新执行，不会传递空的intent 任意等待中的Intent对象会依次被发送。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。 */public static final int START_REDELIVER_INTENT = 3; 4.Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？Service默认运行在主线程，所以生命周期的方法都会运行在主线程 5.Service种类 按运行地点分类：本地服务和远程服务本地服务：依附主进程，主进程被kill后就会自动销毁远程服务：运行在一个独立进程，需要利用AIDL通信需要占用一定资源而且是常驻形式 按运行类型分类：前台服务和后台服务前台服务：会在通知栏显示相关通知，当服务终止时通知栏消息即消失起到一定通知作用后台服务：不会显示在前台，用户无感知，服务终止也不会有任何提示 按使用方式分类：startService，bindService和混合使用startService：用于启动服务执行后台任务，不需要通信，停止需要stopServicebindService：启动的服务需要进行通信，unbindService停止混合使用：停止服务需同时调用stopService，unbindService 6.IntentService介绍继承Service的一个异步请求类，在IntentService有一个工作进程处理耗时操作，启动方式和普通Service一样。任务执行完毕后，IntentService会自动关闭。每次只会执行一个而不至于堵塞UI线程。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
