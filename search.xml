<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Activity的生命周期和启动模式]]></title>
    <url>%2F2019%2F01%2F04%2FActivity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[--- title: Activity的生命周期和启动模式 date: 2019-01-04 10:47:04 tags: Android top: 11 --- # Activity的生命周期和启动模式 {% fullimage /images/Activity生命周期和启动模式.jpeg,Activity生命周期和启动模式,Activity生命周期和启动模式 %} ## Activity的生命周期 {% fullimage /images/study_plan/activity_lifecycle.jpeg, Activity生命周期,Activity生命周期 %} ### 正常情况下的Activity生命周期 正常情况下，Activity会经历如下生命周期 #### onCreate(Bundle savedInstanceState) --创建 > **表示Activity正在被创建，是生命周期的第一个方法** > > 可以做一些初始化工作，调用`setContentView()`加载布局，初始化Activity需要的数据 > > *onCreate 入参的 savedInstanceState其实就是 由于Activity异常销毁存储下来的数据* #### onRestart() -- 重启 > **表示Activity正在重新启动，当当前Activity从不可见切换到可见时，就会触发** > > 随后就会调用到`onStart()`方法 #### onStart() -- 可见 > **表示Activity正在启动，这时Activity已经可见了，但没有出现在前台无法与用户交互** #### onResume() --可交互 > **表示Activity已经可见了，并且出现在前台且可以与用户交互。** #### onPause() -- 不可交互 > **表示Activity正在停止，此时可以做一些`存储数据、停止动画`等操作** > > *`onPause` 中不能执行过于耗时操作，会影响到下一个新Activity的显示。旧Activity必须执行完`onPause()`后，新Activity的`onResume()`才可以执行。* #### onStop() -- 不可见 > **表示Activity即将停止，此时Activity已经不可见，可以做一些稍微重量级的回收工作(`取消网络连接，注销广播监听器等`)，同样不能太耗时。** > > *当新Activity为透明主题即旧Activity依然可见，或者弹出一个框，都不会执行旧Activity的`onStop()`* #### onDestroy() -- 销毁 > **表示Activity即将被销毁，这时可以做一些回收工作以及资源的释放。** 拓展 *Activity在处于`onPause(),onStop(),onDestroy()`状态下，进程优先级较低，容易被回收，所以需要保存一些数据时，必须在onPause中存储，其他两个周期不一定能调用到。* ### Activity生命周期的阶段 可以分为以下3个阶段： - 完整生命周期 > 从`onCreate() 初始化`开始直到`onDestroy() 释放资源`结束 - 可见生命周期 > 从`onStart() 可见`到`onStop() 不可见`结束 - 前台生命周期 > 从`onResume() 可交互`到`onPause() 无法交互`结束 ### Activity生命周期的切换过程 - 启动Activity `onCreate() -> onStart() -> onResume()` - 打开新的Activity `旧Activity.onPause() -> Activity.onCreate() -> Activity.onStart() -> Activity.onResume()-> 旧Activity.onStop()` - 返回上一个Activity `新Activity.onPause() -> 旧Activity.onRestart() -> 旧Activity.onStart() -> 旧Activity.onResume() -> 新Activity.onStop() -> 新Activity.onDestroy()` - 弹出对话框 - 自身调用弹出 `不会有生命周期变化` - 外部调用弹出 `当前Activity.onPause()` - 关闭屏幕/按Home键 - `onPause() -> onStop()` - 新Activity显示，旧Activity依然可见 `新Activity.onPause() -> 新Activity.onStop() -> 旧Activity.onStop()` - 点亮屏幕/回到应用 - `onRestart() -> onStart() -> onResume()` - 新Activity显示，旧Activity依然可见 `新Activity.onRestart() -> 新Acticvity.onStart() -> 旧Activity.onRestart() ->旧Activity.onStart() -> 新Activity.onResume()` - 销毁Activity - `onPause() -> onStop() -> onDestroy()` - 新Activity显示，旧Activity依然可见，销毁新Acticvity `新Activity.onPause() -> 旧Activity.onResume() -> 旧Activity.onStop() -> 旧Activity.onDestroy()` - 弹出对话框样式的Activity `旧Activity.onPause() -> 新Activity.onCreate() -> 新Activity.onStart() -> 新Activity.onResume()` - 状态栏下拉 `不会有生命周期变化,如果需要监听可以 使用 onWindowFocusChanged()` - 横竖屏切换下的生命周期 这是一个 销毁重建的过程 `onPause() -> onStop() -> onDestroy() -> onCreate() -> onStart() -> onResume` ### 异常情况下的生命周期分析 > Activity除了上述正常情况下执行的生命周期调度，还会有一些异常情况会导致Activity被杀死。 #### 由于资源相关的系统配置发生改变导致Activity被杀死并重新构建 例如：当Activity发生横竖屏切换时，发了系统配置的改变，在默认情况下Activity就会被销毁并重建。 > 如何避免配置改变导致Activity重新创建？ > > 可以在`AndroidManifest.xml`中指定对应的系统属性，这样在触发对应改变时，不会再杀死并重建，会调用到`onConfigurationChanged()`，只需重写该方法即可。 > > 例如配置了`android:configChanges="orientation"`，横竖屏切换时就不会触发重建。 #### 由于系统资源不足，导致优先级低的Activity被杀死 这里需要先了解Activity的优先级情况。按照从高到低分为以下三种： 1. **前台Activity**：正在和用户交互的Activity 2. **可见但非前台Activity**：前台的Activity弹出一个Dialog，导致无法交互 3. **后台Activity**：已经被暂停的Activity，比如切到后台或者切换应用 **当系统内存不足时，系统就会按照上述描述的优先级去杀死目标Activity所在进程。** 如果一个进程中没有四大组件在执行，进程很快被系统杀死。 当上述两种情况发生时，Activity的生命周期会发生如下变化： - Activity被杀死：`onPause() -> onSaveInstanceState() -> onStop() -> onDestroy()` 系统异常终止时，调用`onSaveInstanceState()`保存数据。该方法调用在`onStop()`之前。 保存数据过程是利用一种`委托`的思想，上层委托下层。 - Activity重建：`onCreate() -> onStart() -> onRestoreInstanceState() -> onResume()` 重新创建时，调用`onRestoreInstanceState()`，调用在`onStart()`之后，该方法会把`onSaveInstanceState()`存储的Bundle对象拿出来解析。 *`onCreate和onRestoreInstanceState`都可以获取存储的对象，推荐使用`onRestoreInstanceState`不需要额外的去判断是否为空。* **系统只有在异常终止的情况下才会调用`onSaveInstanceState和onRestoreInstanceState`进行存储和恢复数据。** 拓展： 1. 还有一些会在Activity运行过程中的触发方法，这里简单的提及一下： - `onPostCreate()`：在`onCreate()`执行完毕后回调 - `onUserInteraction()`：所有Activity上的触摸事件 优先调用该方法 - `onUserLeaveHint()`：用户主动离开Activity调用该方法，例如点击Home - `onContentChanged()`：Activity 调用`setContentView()`完成后调用 ## Activity的启动模式 ### Activity的任务栈 > 当我们多次启动一个Activity的时候，系统会创建多个实例并放入任务栈中，当我们触发`finish`时，Activity会一一回退。**任务栈是一种先进后出的栈结构。** > > 任务栈又分为`前台任务栈`和`后台任务栈`。`后台任务栈`中的Activity位于暂停状态. - 程序在创建时就会创建一个Activity任务栈，存储当前程序的Activity - 任务栈是Activity的集合，只有位于栈顶的Activity可以和用户交互 - 任务栈可以移动到后台并保留了Activity的状态 - 退出应用程序时，任务栈会被清空，然后会被系统回收。 利用`adb shell dumpsys activity`查看当前任务栈 ### Activity的LaunchMode > LaunchMode为了减少Activity实例的创建优化 使用方法： - 在`AndroidManifest.xml`中给对应Activity配置属性 `android:launchMode="standard | singltTop | singleTask | singleInstance"` - `startActivity`时添加`intent.addFlags(FLAG)` #### standara 标准模式(默认这个) > 每次启动一个新的Activity都会创建一个新的Activity实例。 > > *若启动Activity的是除了Activity之外的context对象就需要指定`FLAG_ACTIVITY_NEW_TASK`标记位，创建一个新的任务栈。因为standard默认进入启动方的任务栈，由于他们是没有自身的任务栈，所以需要新建。* {% fullimage /images/study_plan/launchmode_standard.png, alt,Standard %} #### singleTop 栈顶复用模式 > 如果要启动的Activity位于栈顶，就不会重新创建，并且调用`onNewIntent(Intent intent)`取出当前请求的信息。 > > *还会调用`onPause()以及onResume()`。* {% fullimage /images/study_plan/launchmode_singletop.png, alt,SingleTop %} A位于栈顶，B位于栈底。如果A的启动模式为`singleTop`，再次启动A，栈内情况不会发生变化，依然为AB 如果启动B，则会创建新的实例，不论是否为`singleTop`。 #### singleTask 栈内复用模式 > 栈内只要存在Activity实例，再次启动都不会重新创建实例，只会回调`onNewIntent()`，并从栈内弹出该实例上的所有Activity。 > > 适合作为应用主入口，因为只会启动一次。 列举3个实例加深理解： - {% fullimage /images/study_plan/launchmode_singletask3.png, alt, SingleTask %} 目前S1中由ABC三个实例，这时D以`singleTask`模式请求启动且所需任务栈为`S2`，由于`S2`和`D`实例均不存在，所以系统会创建`S2`任务栈并把实例`D`入栈到`S2`。 - {% fullimage /images/study_plan/launchmode_singletask1.png, alt,SingleTask %} 目前S1中由ABC三个实例，这时D以`singleTask`模式请求启动且所需任务栈为`S1`，由于`S1`已经存在，所以直接入栈并置于栈顶。 - {% fullimage /images/study_plan/launchmode_singletask2.png, alt, SingleTask %} 目前S1中由ABCD四个实例，这时B以`singleTask`模式请求启动且所需任务栈为`S1`，此时B不会重新创建，将直接回调`onNewIntent()`并置于栈顶。*原先位于B实例上的CD都被清除，因为默认具有clear_top 效果，最终就变成了AB* #### singleInstance 单实例模式 > 加强的singleTask模式，除了singleTask拥有的特性外，还加强了一点。使用了这个模式启动的Activity只能单独的位于一个任务栈中。启动时会新开一个任务栈并直接创建实例压入栈中。 > > *即使设置了相同的任务栈名，也不能放在一个栈中。* #### TaskAffinity -- 栈亲和性 > taskAffinity：标识了一个Activity所需要任务栈的名字，默认情况下，所有Activity所需的任务栈名字为应用的包名。我们也可以为每个Activity指定任务栈，利用`android:taskAffinity`属性标记。 TaskAffininty一般是配合`singleTask启动模式`或者`allowTaskReparenting`属性。 - 配合`singleTask`使用 新Activity启动时默认被加载进启动该Activity的对象所在任务栈中。如果给启动的Activity设置`FLAG_ACTIVITY_NEW_TASK`标记或者设置`singleTask`启动模式，再配合`taskAffinity`设置任务栈名字，该实例就会被加载进相同名字的任务栈中，如果不存在相同就创建新的任务栈并压入实例。 - 配合`allowTaskReparenting`使用 > allowTaskReparenting 作用是 是否允许Activity更换从属任务。true表示可以更换，默认为false 简单描述： 有两个APP，A和B，此时应用A去启动应用B中的一个Activity，并且该Activity设置`allowTaskReparenting = true`，此时这个Activity的任务栈就会位于应用A中，当去启动B时，会优先展示已被启动的Activity，由于设置了`allowTaskReparenting`该Activity的任务栈又回到了B中。 ？？？ allowTaskReparenting = true 且两个Activity的TaskAffinity 相同会如何 ### Activity的行为标志和属性 #### Activity的Flag > 有些标记位可以设置启动模式，还有的可以影响Activity的运行状态。 ##### FLAG_ACTIVITY_NEW_TASK > 作用等同 `singleTask`启动模式 ##### FLAG_ACTIVITY_SINGLE_TOP > 作用等同`singleTop`启动模式 ##### FLAG_ACTIVITY_CLEAR_TOP > 当用这个标记启动对应Activity时，在同一个任务栈中的且位于它上面的Activity实例都会被消除。一般配合`singleTask`使用 ##### FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS > 对应的配置为在`AndroidManifest.xml`中使用`android:excludeFromRecents="true"` > > 具有这个标记的Activity不会出现在后台任务列表中 #### IntenFilter的匹配规则 > 启动Activity方法分为两种：`显式调用(可以清楚指出被启动组件的信息，例如类名)`，`隐式调用(没有明确的指出组件信息，通过IntentFilter找到符合要求的组件)`。 匹配规则： 1. 一个intent只有同时匹配某个Activity定义的``中定义的`action,category,data`才可以完全匹配，打开对应的Activity 2. 一个Activity可以定义多个，只要匹配任意一组就可以启动该Activity ##### action匹配规则 > 只要传递过来的Intent中定义的`action`可以匹配``定义的任一`action`，必须要完全相同且区分大小写。 ##### category匹配规则 > 传递过来的Intent中不包含`categroy`，那么就会启用默认的`categroy`，由于系统在启动Activity的时候默认会加上`android.intent.categroy.DEFAULT`属性 > > 如果包含`categroy`，那必须匹配``定义的任一`categroy` ##### data匹配规则 > 传递过来的Intent定义的`data`可以匹配``定义的任一`data` data主要分为两部分： - `mimeType`：媒体类型，例如`text/plain`这类，还包括图片，视频类型 - `URL`：地址 包含了`host(主机名)，scheme(模式)，port(端口号)，path(路径信息)`等 *隐式启动时，如果无法找到要启动的组件，就会抛出异常。我们就可以利用`PackageManager.resolveActivity()`或者`Intent.resolveActivity()`避免异常出现。* #### 清理任务栈 > 当用户离开一个任务时间很长时，系统将会清除除了根Activity之外的所有Activity，当用户重新回到应用时，只能看到根Activity。 系统提供了几种机制来调整这个规则： - `android:alwaysRetainTaskState` 标记应用的Task是否保持原来的状态，若为`true`，系统尝试保留所有Activity - `android:clearTaskOnLaunch` 标记是否从Task清除所有Activity除了根Activity，用户每次重新打开只会看到根Activity - `android:finishOnTaskLaunch` 只作用于单个Activity，若设置true，用户离开后回来就会消失 ### 拓展 1. 何时会调用`onNewIntent()`? - LaunchMode设置为`singleTop`，且要启动的Activity已经处于栈顶 - LaunchMode设置为`singleTask`或者`singleInstance`，且实例已存在 需要注意的是：*当调用到`onNewIntent(intent)`的时候，需要在内部调用`setNewIntent(intent)`赋值给当前Activity的Intent，否则后续的getIntent()得到的都是老Intent*]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView简析]]></title>
    <url>%2F2019%2F01%2F04%2FListView%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: ListView简析 date: 2019-01-04 10:12:32 tags: Android top: 10 ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 动画]]></title>
    <url>%2F2019%2F01%2F04%2FAndroid-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[--- title: Android - 动画 date: 2019-01-04 10:10:40 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[include、merge及ViewStub相关]]></title>
    <url>%2F2019%2F01%2F03%2Finclude%E3%80%81merge-ViewStub%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[--- title: include、merge及ViewStub相关 date: 2019-01-03 12:13:11 tags: - Android - 布局优化 top: 10 --- # 主要解析include、merge及ViewStub {% fullimage /images/布局优化之xml方面.png,布局优化之xml方面,布局优化之xml方面%} ## include > 主要为了解决重复定义相同布局的问题。把一套布局封装起来，需要使用时使用标签引入。提高代码复用性 > > 使用注意事项： > > 1. 如若我们在中设置了android:id属性，这个id会覆盖原先`中layout设置的布局id，所以在引用该id时需要注意 > 2. 如果需要在中需要使用andrdoid:**属性，必须要设置layout_width以及layout_height属性 源码分析： 从Activity创建开始，调用`setContentView()`传入对应xml文件，然后开始解析并绘制。 ```java // ../android/app/Activity.java public void setContentView(@LayoutRes int layoutResID){ //getWindow() 对应的就是PhoneWindow getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } // ../com/android/internal/policy/PhoneWindow.java @Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) { //初始化 DecorView installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { //渲染传进来的xml mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null && !isDestroyed()) { cb.onContentChanged(); } mContentParentExplicitlySet = true; } // ../android/view/LayoutInflater.java public View inflate(XmlPullParser parser, @Nullable ViewGroup root) { return inflate(parser, root, root != null); } public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); final XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); } } public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { ... final String name = parser.getName(); //如果是merge标签 if (TAG_MERGE.equals(name)) { if (root == null || !attachToRoot) { throw new InflateException(" can be used only with a valid " + "ViewGroup root and attachToRoot=true"); } rInflate(parser, root, inflaterContext, attrs, false); } else { ... rInflateChildren(parser, temp, attrs, true); } ... } } //解析所有子控件 final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException { rInflate(parser, parent, parent.getContext(), attrs, finishInflate); } void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException { final int depth = parser.getDepth(); int type; boolean pendingRequestFocus = false; while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) { if (type != XmlPullParser.START_TAG) { continue; } final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) { pendingRequestFocus = true; consumeChildElements(parser); } else if (TAG_TAG.equals(name)) { parseViewTag(parser, parent, attrs); //解析到标签 } else if (TAG_INCLUDE.equals(name)) { if (parser.getDepth() == 0) { throw new InflateException(" cannot be the root element"); } //解析include中包含的布局 parseInclude(parser, context, parent, attrs); } else if (TAG_MERGE.equals(name)) { throw new InflateException(" must be the root element"); } else { final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflateChildren(parser, view, attrs, true); viewGroup.addView(view, params); } } if (pendingRequestFocus) { parent.restoreDefaultFocus(); } //当系统解析完View之后调用 if (finishInflate) { parent.onFinishInflate(); } } private void parseInclude(XmlPullParser parser, Context context, View parent, AttributeSet attrs) throws XmlPullParserException, IOException { // include标签必须在ViewGroup中使用 if (parent instanceof ViewGroup) { ... //解析android:layout 属性 int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0); if (layout == 0) { final String value = attrs.getAttributeValue(null, ATTR_LAYOUT); if (value == null || value.length() 减少层级布局，可以将标签下的子View直接添加到标签的parent中，可以减少不必要的层级。添加的子View遵循父布局的布局方式。 > > ``标签一般和``标签搭配使用，``标签不支持设置`android:**`属性，因为它不是View，只是声明了一些View。 > > *使用`LayoutInflate.inflate(resId,viewroot,attachToRoot)`渲染时，第二个viewroot必须设置，且第三个参数必须为true。* > > **标签最好是替代FlameLayout或者与父布局方向一致的LinearLayout** 上述源码中，`inflate()`执行时判断`name`为`TAG_MERGE`时就会直接调用`rInflate()` ```java 在普通xml中引用merge布局都是 通过include引用的 private void parseInclude(XmlPullParser parser, Context context, View parent, AttributeSet attrs) throws XmlPullParserException, IOException { ... final View view = createViewFromTag(parent, name, attrs); // 获取merge标签的parent final ViewGroup viewGroup = (ViewGroup) parent; // 获取布局参数 final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); // 递归解析每个子元素 rInflate(parser, view, attrs, true); // 将子元素直接添加到merge标签的parent view中 viewGroup.addView(view, params); ... } ``` 从上述源码分析中可得 标签对应的View会直接添加至父容器中，减少一层布局。 拓展： 1. 如果Activity布局的根节点为`FlameLayout`，可以直接替换为``标签，执行`setContentView()`后可以减少一层布局 2. 自定义View如果继承`LinearLayout`，可以把自定义View的布局文件根节点设置为`` ## ViewStub > ViewStub继承了View，非常轻量级且宽高都为0，因为本身不参与任何的布局和绘制过程。主要用于 一些不常出现的界面可以按需加载，提高加载效率。 源码分析： ```java // ../android/view/ViewStub.java public final class ViewStub extends View { //初始化ViewStub public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewStub, defStyleAttr, defStyleRes); mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID); mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0); mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID); a.recycle(); //默认隐藏 setVisibility(GONE); //阻止View的绘制 setWillNotDraw(true); } ... //设置宽高为0 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(0, 0); } //空实现 不会绘制任何内容 @Override public void draw(Canvas canvas) { } @Override protected void dispatchDraw(Canvas canvas) { } public void setVisibility(int visibility) { if (mInflatedViewRef != null) { //如果已经渲染完成 与普通View逻辑相同 View view = mInflatedViewRef.get(); if (view != null) { view.setVisibility(visibility); } else { throw new IllegalStateException("setVisibility called on un-referenced view"); } } else { super.setVisibility(visibility); if (visibility == VISIBLE || visibility == INVISIBLE) { //需要渲染View inflate(); } } } //渲染代码 public View inflate() { final ViewParent viewParent = getParent(); if (viewParent != null && viewParent instanceof ViewGroup) { if (mLayoutResource != 0) { final ViewGroup parent = (ViewGroup) viewParent; //添加并渲染View final View view = inflateViewNoAdd(parent); //移除原来定义的ViewStub 替换渲染的View上去 replaceSelfWithView(view, parent); mInflatedViewRef = new WeakReference(view); if (mInflateListener != null) { //监听渲染完成 mInflateListener.onInflate(this, view); } return view; } else { throw new IllegalArgumentException("ViewStub must have a valid layoutResource"); } } else { throw new IllegalStateException("ViewStub must have a non-null ViewGroup viewParent"); } } private View inflateViewNoAdd(ViewGroup parent) { final LayoutInflater factory; if (mInflater != null) { factory = mInflater; } else { factory = LayoutInflater.from(mContext); } //渲染View final View view = factory.inflate(mLayoutResource, parent, false); if (mInflatedId != NO_ID) { //赋值设置的id到ViewStub渲染的View上 view.setId(mInflatedId); } return view; } private void replaceSelfWithView(View view, ViewGroup parent) { final int index = parent.indexOfChild(this); //移除本身存在的ViewStub parent.removeViewInLayout(this); final ViewGroup.LayoutParams layoutParams = getLayoutParams(); //以ViewStub自身设置的 LayoutParams为准 if (layoutParams != null) { parent.addView(view, index, layoutParams); } else { parent.addView(view, index); } } } ``` 根据上述源码发现，`inflate()`只可以调用一次，否则会因移除ViewStub出错。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>布局优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动过程]]></title>
    <url>%2F2019%2F01%2F02%2FActivity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[--- title: Activity启动过程 date: 2019-01-02 21:35:26 tags: Android top: 11 ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - 泛型]]></title>
    <url>%2F2019%2F01%2F02%2FJava-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[--- title: Java - 泛型 date: 2019-01-02 16:39:03 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[自定义ViewGroup实践]]></title>
    <url>%2F2019%2F01%2F02%2F%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[--- title: 自定义ViewGroup实践 date: 2019-01-02 14:21:44 tags: Android top: 10 --- # 自定义ViewGrouop - FlowLayout]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View实践]]></title>
    <url>%2F2019%2F01%2F02%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[--- title: 自定义View实践 date: 2019-01-02 14:16:26 tags: Android top: 10 --- # 自定义View -- ClockView]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2F2018%2F12%2F27%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[--- title: 位运算 date: 2018-12-27 15:04:55 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[View的事件体系]]></title>
    <url>%2F2018%2F12%2F25%2FView%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[--- title: View的事件体系 date: 2018-12-25 10:48:42 tags: Android top: 11 --- {% fullimage /images/View的事件体系.png,View的事件体系,View的事件体系%} # View的事件体系 > 在Android中任何一个与用户交互或者展示内容的控件都是由View拓展实现的。 ## View的基础知识 View是Android中所有控件的基类，也包括ViewGroup。ViewGroup可以理解为View的组合，内部可以包含很多View以及ViewGroup，通过这种关系就形成了一个View树。 {% fullimage /images/View-Tree.png,ViewTree,ViewTree%} 上层的控件主要负责测量与绘制下层的控件，并传递交互事件。 ### 1. View的位置参数 #### 1.Android坐标系 > 在Android中，将屏幕左上角的顶点作为坐标原点，向右为X轴增大方向，向下为Y轴增大方向 {% fullimage /images/Android-Position.png,Android坐标系,Android坐标系 %} #### 2.View坐标系 > View的位置由它的四个顶点决定，分别对应View的4个属性：`left(左上角横坐标)、top(左上角纵坐标)、right(右下角横坐标)，bottom(右下角纵坐标)`。 > > **这些坐标都是相对于View的父容器决定的。** {% fullimage /images/View-Position.png,View坐标系,View坐标系 %} ```java Left = getLeft(); Right = getRight(); Top = getTop(); Bottom = getBottom(); width = Right - Left; height = Bottom - Top; ``` 在Android3.0之后添加了几个新参数`x,y,translationX,translationY`。 ```java //X对应左上角横坐标 translationX指代x轴偏移量 x = left + translationX; //y对应左上角纵坐标 translationY指代y轴偏移量 y = top + translationY; ``` `left是View的初始坐标，不会改变的；x是View偏移后的坐标，偏移后就会发生变化` Android系统也提供了相应的方法可以直接获取对应参数。但是，不能在初始时就去获取，由于那时View还没有开始绘制，获取的都是0； 如何获取可以参考这个 {% post_link Android-Study-Plan-V %} ### 2.View触控 #### 1.MotionEvent `MotionEvent`：提供点击事件的事件行为以及事件发生的x,y坐标，典型事件由： - **ACTION_DOWN**：监听用户手指按下的操作，一次按下标志触摸事件的开始。 - **ACTION_MOVE**：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。 - **ACTION_UP**：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。 - **ACTION_CANCEL**：当用户保持按下操作，并把手指移动到了控件外部局域时且父View处理事件触发。 > 事件列：从手指接触屏幕到离开屏幕，产生的一系列事件。 > > 任何事件列都是**从ACTION_DOWN开始到ACTION_UP结束，中间会穿插着ACTION_MOVE事件** {% fullimage /images/View-Touch-Position.png,Android触摸点坐标系,Android触摸点坐标系 %} ```java getX 以及 getY 返回当前触摸点距离View左上角的x，y坐标 -- 相对坐标 getRawX 以及 getRawY 返回当前触摸点距离整个屏幕的x,y坐标 -- 绝对坐标 ``` #### 2.TouchSlop `TouchSlop`：系统所能识别的被人误是**滑动的最小距离**。当手指在屏幕上滑动时，如果滑动的距离小于这个值，就不会认为在进行滑动操作。 利用`ViewConfiguration.get(getContext()).getScaledTouchSlop()`获取该常亮 #### 3.VelocityTracker `VelocityTracker`：速度追踪，用于追踪在手指滑动过程中的速度，包括水平和垂直方向的速度 样例演示: ```java //创建速度追踪对象 VelocityTracker velocityTracker = VelocityTracker.obtain(); velocityTracker.addMovement(event); //计算速度 velocityTracker.computeCurrentVelocity(1000); //获取水平速度 float xVelocity = velocityTracker.getXVelocity(); //获取垂直速度 float yVelocity = velocityTracker.getYVelocity(); //重置并回收内存 velocityTracker.clear(); velocityTracker.recycle(); ``` #### 4.GestureDetector `GestureDetector`：手势检测，用于辅助检测用户的单击、滑动、长按，双击等行为。 样例演示： ```java GestureDetector mGestureDetector = new GestureDetector(this);//实例化一个GestureDetector对象 mGestureDetector.setIsLongpressEnabled(false);// 解决长按屏幕后无法拖动的现象 //接管目标View的onTouchEvent事件 public boolean onTouchEvent(MotionEvent event){ ... boolean consume = mGestureDetector.onTouchEvent(event); return consume } ``` ## View的滑动 > Android由于手机屏幕比较小，为了呈现更多的内容就需要滑动来展示。 ### 1.使用scrollTo()/scrollBy() > `scrollTo()`以及`scrollBy()`是由View本身提供的滑动方法。**只对View的内容进行滑动，而不能使View本身滑动。** ```java public void scrollTo(int x, int y) { if (mScrollX != x || mScrollY != y) { int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) { postInvalidateOnAnimation(); } } } public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y); } ``` `scrollTo(x,y)`表示移动到一个具体的坐标点 绝对滑动 `scrollBy(x,y)`表示移动的增量为x,y，即在原有位置上移动x,y的距离 相对滑动 `mScrollX和mScrollY分别表示View在X,Y方向的滚动距离。` `mScrollX`：View的左边缘减去View的内容的左边缘 **从右向左为正，反之为负** `mScrollY`：View的上边缘减去View的内容的上边缘 **从下向上为正，反之为负** ### 2.使用动画 > 通过动画给View增加平移效果。通过改变View自身的`translationX`和`translationY`属性达到滑动效果。 普通动画：新建`translate.xml`动画文件，定义好tranlate属性即可实现滑动动画。 普通动画并不能修改View的位置参数，只是执行了一个动画，实际位置还是初始地方。 属性动画：`ObjectAnimator.ofFloat(view,"translationX",0,300).setDuration(1000).start();`即可实现动画 属性动画真正对View的位置参数进行修改，所以对应时间都是跟随的。 ### 3.改变布局参数 > 改变View的`LayoutParams`使得View重新布局。 滑动时，可以对`LaqyoutParams`的`margin`相关参数进行加减就可以实现滑动。 ### 4.*弹性滑动 > 上述提到的方案除了动画，滑动都是很生硬的，就是闪烁过去的。所以需要实现弹性滑动(渐进式滑动)。 #### 1. *`Scroller` 使用实例： ```java Scroller scroller = new Scroller(mContext); //实例化一个Scroller对象 private void smoothScrollTo(int dstX, int dstY) { int scrollX = getScrollX();//View的左边缘到其内容左边缘的距离 int scrollY = getScrollY();//View的上边缘到其内容上边缘的距离 int deltaX = dstX - scrollX;//x方向滑动的位移量 int deltaY = dstY - scrollY;//y方向滑动的位移量 scroller.startScroll(scrollX, scrollY, deltaX, deltaY, 1000); //开始滑动 invalidate(); //刷新界面 } @Override//计算一段时间间隔内偏移的距离，并返回是否滚动结束的标记 public void computeScroll() { if (scroller.computeScrollOffset()) { scrollTo(scroller.getCurrX(), scroller.getCurY()); postInvalidate();//通过不断的重绘不断的调用computeScroll方法 } } ``` 工作原理： 构造`Scroller`对象时，内部没有做什么，只是保存了我们传递的参数 ```java public Scroller(Context context) { this(context, null); } public Scroller(Context context, Interpolator interpolator) { this(context, interpolator, context.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.HONEYCOMB); } public Scroller(Context context, Interpolator interpolator, boolean flywheel) { mFinished = true; if (interpolator == null) { mInterpolator = new ViscousFluidInterpolator(); } else { mInterpolator = interpolator; } mPpi = context.getResources().getDisplayMetrics().density * 160.0f; mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction()); mFlywheel = flywheel; mPhysicalCoeff = computeDeceleration(0.84f); // look and feel tuning } ``` 保存完参数后，就需要调用`Scroller`的`startScroll()`方法，传入对应参数进行滑动 ```java public void startScroll(int startX, int startY, int dx, int dy, int duration) { mMode = SCROLL_MODE; mFinished = false; //滑动持续时间 mDuration = duration; //滑动开始时间 mStartTime = AnimationUtils.currentAnimationTimeMillis(); //滑动起点 mStartX = startX; mStartY = startY; //滑动终点 mFinalX = startX + dx; mFinalY = startY + dy; //滑动距离 mDeltaX = dx; mDeltaY = dy; mDurationReciprocal = 1.0f / (float) mDuration; } ``` 调用`startScroll()`后，我们调用了`invalidate()`导致View进行了重绘，重绘过程中调用了`draw()`方法，`draw()`中调用了对应的`computeScroll()`方法。`computeScroll()`中又调用了`Scroller`的`computeScrollOffset()`方法，使`Scroller`对应的`mCurrX以及mCurrY`发生变化，配合View自身的`scrollTo()`产生滑动事件。后续继续调用了`postInvalidate()`使View重绘，按照上述流程继续执行，直到动画完成为止。 **关键方法为`startScroll()`及`computeScroll()`** {% fullimage /images/Scroller-Process.png,Scroller工作机制,Scroller工作机制 %} 总结一下原理：**Scroller并不能使View进行滑动，他需要配合View的computeScroll()方法才能完成滑动效果。在computeScroll()中不断让View进行重绘，每次重绘需要计算滑动持续的时间，根据这个时间计算出应该滑动到的位置，然后调用了View本身的scrollTo()配合位置进行滑动，多次的短距离滑动形成了弹性滑动的效果。** #### 2. 动画 [动画](#2-使用动画) #### 3. 延时策略 > 通过发生一系列延时消息而达到一种渐进式的效果，具体可以使用`Handler,View.postDelayed()或者Thread.sleep()`实现 *如果要求精确的话，不建议使用延时策略实现。* ## View的事件分发机制 > View的事件分发本质就是**[MotionEvent](#1-MotionEvent)事件的分发过程**。当一个MotionEvent产生后，系统需要把该事件传递给一个具体的View. ### 点击事件传递规则 点击事件的传递顺序为：**Activity(Window) --> ViewGroup --> View** 事件分发过程中有3个重要的方法: - `dispathTouchEvent(MotionEvent event)` 用来进行事件的分发。 - `onInterceptTouchEvent(MotionEvent event)` 用来进行事件的拦截，在`dispatchOnTouchEvent()`内部中调用，返回结果表明是否拦截事件，*View中是没有该方法的* - `onTouchEvent(MotionEvent event)` 用来处理点击事件，在`dispatchOnTouchEvent()`内部中调用，返回结果表明是否消耗当前事件 > 在Android系统中，可以处理事件传递的类有以下三种： > > - **Activity**：包含`dispatchTouchEvent`，`onTouchEvent`方法 > - **ViewGroup**：包含`dispatchTouchEvent`，`onInterceptTouchEvent`，`onTouchEvent` > - **View**：包含`dispatchTouchEvent`，`onTouchEvent`方法 可以用如下伪代码体现： ```java public boolean dispatchTouchEvent(MotionEvent event){ boolean consume = false; if(onInterceptTouchEvent(ev)){ //被拦截调用自身的onTouchEvent()处理点击事件 consume = onTouchEvent(event); }else{ //没有拦截继续放行，执行子View的dispatchTouchEvent() consume = child.dispatchTouchEvent(event); } return consume; } ``` {% fullimage /images/TouchEvent-Transmit.png,事件分发,事件分发%} - `super`：调用父类方法 - `true`：消费事件，即事件不会往下传递 - `false`：不消费事件，事件继续往下传递(`onInterceptTouchEvent()`)/交由父布局处理事件(`onTouchEvent`，`dispatchTouchEvent`) 简单的总结一下流程：**Activity.dispatchTouchEvent() -> ViewGroup.dispatchTouchEvent() -> ViewGroup.onInterceptTouchEvent() -> View.dispatchTouchEvent() -> View.onTouch() -> View.onTouchEvent() -> View.onClick()** ### 事件分发的源码解析 #### Activity的事件分发机制 当一个点击事件发生时，事件最先传递到的就是`Activity.dispatchTouchEvent(MotionEvent ev)`中进行事件分发。*具体工作是由Activity的Window来完成的。* ```java // ..android/app/Activity.java public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } //若dispatchTouchEvent返回true，事件到此结束，返回false，继续向下传递 if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } //当activity在栈顶时，点击，触摸或者点击通知栏都会触发 public void onUserInteraction() { } // ../com/android/internal/policy/PhoneWindow.java /** * getWindow().superDispatchTouchEvent(ev) * getWindow()指向的是Window对象的一个实例，在Android中Window的唯一实现就是PhoneWindow */ @Override public boolean superDispatchTouchEvent(MotionEvent event) { //mDecor 是DecorView的一个实例，DecoeView就是顶层View中的实例对象 return mDecor.superDispatchTouchEvent(event); } //../com/android/internal/policy/DecorView.java /** * mDecor.superDispatchTouchEvent(event) * mDecor 是DecorView的一个实例对象，DecorView是PhoneView的一个内部类，并且继承自FrameLayout */ public boolean superDispatchTouchEvent(MotionEvent event) { //调用父类的方法即FrameLayout.dispatchTouchEvent = ViewGroup.dispatchTouchEvent()，由父类去处理事件分发 return super.dispatchTouchEvent(event); } ``` `onUserInteraction()`用户点击屏幕时最先被触发。 {% fullimage /images/Activity-Dispatch.png,Activity事件分发,Activity事件分发%} 总结一下：按照上述流程图，当一个点击事件进来时，Activity上的事件流程如下： - 调用`Activity.dispatchTouchEvent()`，然后调用`onUserInteraction()` - 调用`getWindow()即PhoneWindow.superDispatchTouchEvent()` - 调用`mDecor即DecorView。superDispatchTouchEvent()` - 调用DecorView父类即**`ViewGroup.dispatchTouchEvent()`** 在这里实现了事件从Activity传递至ViewGroup #### ViewGroup事件分发机制 上述Activity事件分发，后面会走到`ViewGroup.dispatchTouchEvent()` ```java @Override public boolean dispatchTouchEvent(MotionEvent event){ ... //---- ViewGroup会在ACTION_DOWN时重置GroupFlags以免影响后续对ACTION_DOWN事件的处理---- if (actionMasked == MotionEvent.ACTION_DOWN) { cancelAndClearTouchTargets(ev); resetTouchState(); } //-------- //----判断当前事件是否需要拦截---- final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN //必须是ACTION_DOWN事件，若为其他UP或MOVE事件不触发拦截机制 || mFirstTouchTarget != null) { //mFirstTouchTarget 若当前事件被拦截，则该值为null 反之不会空 //FLAG_DISALLOW_INTERCEPT：禁止ViewGroup拦截除了DOWN以外的事件 //可由View调用requestDisallowInterceptTouchEvent设置标记 final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } //-------- ... //----ViewGroup不拦截分发事件，事件向下分发交由子View进行处理---- final View[] children = mChildren; //遍历当前ViewGroup下的所有子View 遍历为倒序，意味着从外到内遍历 for (int i = childrenCount - 1; i >= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } //如果View不可见或触摸点的坐标不在子View范围内，跳过本次循环 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); //事件传递下来后，调用dispatchTransformedTouchEvent，事件就会传递到View中 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j < childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //返回true的话 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } ... //如果 mfirstTouchTarget为空，ViewGroup默认拦截同一时间序列中的所有事件 if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. //child默认为空，直接调用父类的 dispatchTouchEvent() handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { ... } ... } //是否拦截事件分发 public boolean onInterceptTouchEvent(MotionEvent ev) { //触发条件需要有 鼠标输入触发 正常操作都是触摸方式 所以可以看做默认false if (ev.isFromSource(InputDevice.SOURCE_MOUSE) && ev.getAction() == MotionEvent.ACTION_DOWN && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) && isOnScrollbarThumb(ev.getX(), ev.getY())) { return true; } return false; } //事件向下分发 子View或者子ViewGroup private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { //如果没有子View，向上回溯调用父类的dispatchTouchEvent handled = super.dispatchTouchEvent(event); } else { //包含子View，调用子类的dispatchTouchEvent handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } ... } //mFirstTouchTarget其实是一种单链表结构 private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) { final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; } ``` {% fullimage /images/ViewGroup-Dispatch.png,ViewGroup事件分发,ViewGroup事件分发%} 根据上述流程图，总结一下： - 点击事件从上层传递到ViewGroup，先调用`ViewGroup.dispatchTouchEvent()` - 判断`ViewGroup.onInterceptTouchEvent()`是否拦截点击事件 - 默认不拦截，则将事件继续向子View传递，然后调用`View.dispatchTouchEvent()` - 被拦截返回`true`，调用`super.dispatchTouchEvent()`返给父布局处理，并且ViewGroup自身也处理事件，比如`onTouch(),onClick(),onTouchEvent()`等事件 #### View事件分发机制 上述ViewGroup事件分发后，就会调用到`View.dispatchTouchEvent()` ```java // ../android/view/View.java public boolean dispatchTouchEvent(MotionEvent event) { ... boolean result = false; if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null && li.mOnTouchListener != null //View设置了onTouch事件 && (mViewFlags & ENABLED_MASK) == ENABLED //View是可操作状态的 isEnable=true && li.mOnTouchListener.onTouch(this, event)//View的onTouch返回为true ){ result = true; } //如果result为true即上述条件通过 这个if条件就不会向下执行意味着onTouchEvent()不会被调用 if (!result && onTouchEvent(event)) { result = true; } } ... return result; } public boolean onTouchEvent(MotionEvent event) { final int action = event.getAction(); //只要设置了点击事件 clickable = true final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //当View点击事件被禁止时，直接消耗点击事件 if ((viewFlags & ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return clickable; } ... //监听点击事件，并且需要配置Click事件才可以触发 if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) { switch (action) { //当手指从屏幕离开时，触发对应的点击事件 case MotionEvent.ACTION_UP: //没有配置点击事件的话 直接返回 if (!clickable) { removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; } boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0; if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() && isFocusableInTouchMode() && !isFocused()) { focusTaken = requestFocus(); } ... if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } ... } break; ... } } } //实际点击事件的触发位置 public boolean performClick() { final boolean result; final ListenerInfo li = mListenerInfo; if (li != null && li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); //调用对应的点击事件 li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result; } ``` {% fullimage /images/View-Dispatch.png,View事件分发,View事件分发%} 根据上述流程图，总结一下： - 点击事件从ViewGroup传递到View，调用`View.dispatchTouchEvent()` - 判断当前View是否设置`OnTouchListener`，并且设置了`onTouch()`返回值，默认返回false - 返回`true`，代表事件被`onTouch()`消费，不会继续往下传递 - 返回`false`，事件继续向下传递，调用`View.onTouchEvent()`，后续若设置点击事件，则继续调用`performClick()`，最后执行`onClick()`事件 拓展： > 1. 如果有一个控件是`DISABLED`，注册的`onTouch()`事件不会被执行。若要监听点击事件，只能实现它的`onTouchEvent()` > 2. 点击事件优先级： `onTouch()` > `onTouchEvent()` > `performClick()` > `onClick()` #### 总结 1. 点击事件传递从`dispatchTouchEvent()`开始，在不修改默认返回值时，事件会按照嵌套层次由外向内传递，到达最内层View时，由最内层View`onTouchEvent()`处理 2. 事件在传递过程中，返回参数设为`true`，事件会被提前消费，不向下继续传递 3. View的点击事件触发顺序为 `onTouch()` > `onTouchEvent()` > `performClick()` > `onClick()` #### 拓展 1. *Touch事件的后续(例如`ACTION_MOVE`,`ACTION_UP`)层级传递* - 若`dispatchTouchEvent()`返回true，那么能收到`ACTION_DOWN`的函数也可以收到后续事件 - 若`onTouchEvent()`返回true，那么其他事件不再往下传递，而是直接传给自己的`onTouchEvent()`并结束本次事件传递 ## View的滑动冲突 ### 滑动冲突场景 #### 外部滑动和内部滑动方向不一致 *外层ViewGroup是可以横向滑动的，内层View是可以竖向滑动的。*例如：ViewPager嵌套ListView #### 外部滑动和内部滑动方向一致 *外层ViewGroup是可以竖向滑动的，内层View是也可以竖向滑动的。*例如：ScrollView嵌套ListView #### 两种情况的嵌套 ### 滑动冲突处理规则 #### 内外滑动方向不一致 处理规则 **根据滑动是水平滑动还是竖直滑动来判断由谁来拦截事件。**可以得到滑动过程中两个点的坐标，依据滑动路径与水平方向形成的夹角(`斜率`)判断，或者水平和竖直方向滑动的距离差进行判断。*在ViewPager中当斜率小于0.5时判断为水平滑动。* #### 内外滑动方向一致 处理规则 一般从业务上找突破点。根据业务需求，规定何时让外部View拦截事件何时由内部View拦截事件。 #### 嵌套滑动 处理规则 滑动规则更复杂，所以还是要从业务代码上下手。 ### 滑动冲突解决方案 #### 外部拦截法 > 点击事件都先经过**父容器的拦截处理**，如果父容器需要此事件就拦截，不需要就放行 需要重写父容器的`onInterceptTouchEvent()`，在方法内部做相应的拦截。 ```java public boolean onInterceptTouchEvent(MotionEvent ev){ boolean intercepted = false; int x = (int)ev.getX(); int y = (int)ev.getY(); switch(ev.getAction()){ //ACTION_DOWN必须返回false，否则后续事件无法向下传递 case MotionEvent.ACTION_DOWN: intercepted = false; break; case MotionEvent.ACTION_MOVE: if(父容器需要处理该事件){ intercepted = true; }else{ intercepted = false; } break; //ACTION_UP事件必须返回false，否则子容器无法相应 onClick事件 case MotionEvent.ACTION_UP: intercepted = false; break; default: break; } return intercepted; } ``` 是否拦截需要在`ACTION_MOVE`中进行判断，父容器需要拦截事件返回true，反之返回false。 #### 内部拦截法 > 父容器不拦截任何事件，所有事件交由子容器进行处理，如果子容器需要就消耗事件，不需要就返给父容器处理。 需要同时重写父容器的`onInterceptTouchEvent()`以及子容器的`dispatchTouchEvent()`。需要配合**`requestDisallowInterceptTouchEvent`** ```java //子View public boolean dispatchTouchEvent(MotionEvent ev){ int x= (int)ev.getX(); int y= (int)ev.getY(); switch(ev.getAction()){ //ACTION_DOWN必须返回false，否则后续事件无法向下传递 case MotionEvent.ACTION_DOWN: //使父布局跳过所有拦截事件 parent.requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y- mLastY ; if(父容器需要处理事件){ parent.requestDisallowInterceptTouchEvent(false); } break; //ACTION_UP事件必须返回false，否则子容器无法相应 onClick事件 case MotionEvent.ACTION_UP: intercepted = false; break; default: break; } mLastX = x; mLastY = y; return super.dispatchTouchEvent(ev); } //父容器 public boolean onInterceptTouchEvent(MotionEvent event){ int action = event.getAction(); if(action == MotionEvent.ACTION_DOWN){ return false; }else{ return true; } } ``` 两种方法相比较而言，`外部拦截法`相比`内部拦截法`实现起来更加简单，而且符合View的事件分发，推荐使用`外部拦截法`。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-简单实现Router功能]]></title>
    <url>%2F2018%2F12%2F24%2FAndroid-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0Router%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[--- title: Android-简单实现Router功能 date: 2018-12-24 17:31:04 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[BockingQueue阻塞队列]]></title>
    <url>%2F2018%2F12%2F24%2FBockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[--- title: BockingQueue阻塞队列 date: 2018-12-24 15:16:57 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android-线程相关]]></title>
    <url>%2F2018%2F12%2F21%2FAndroid-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[--- title: Android-线程相关 date: 2018-12-21 11:22:00 tags: Android top: 10 --- # Android中的线程 {% fullimage /images/Android-Thread-Type.png,Android线程,Android线程%} 在Android中进程一般指代App，线程又分为 - 主线程：进程所拥有的线程，默认情况下一个进程只有一个线程，这个线程就是主线程。Android中对应UI线程 - 子线程：工作线程，除主线程以外的线程都是工作线程。Android中的子线程的作用是处理耗时任务，比如网络请求，IO操作。 ## Thread {% post_link Java多线程基础%} ## AsyncTask > 轻量级的异步任务，可以在线程池中执行后台任务，]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-红黑树]]></title>
    <url>%2F2018%2F12%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[--- title: 数据结构-红黑树 date: 2018-12-20 16:08:30 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[RecycleView简析]]></title>
    <url>%2F2018%2F12%2F20%2FRecycleView%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: RecycleView简析 date: 2018-12-20 11:49:27 tags: Android top: 10 ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化]]></title>
    <url>%2F2018%2F12%2F20%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[--- title: Android性能优化 date: 2018-12-20 11:12:25 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReenTrantLock关键字分析]]></title>
    <url>%2F2018%2F12%2F19%2FReenTrantLock%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: ReenTrantLock关键字分析 date: 2018-12-19 15:06:32 tags: Java top: 10 --- # ReenTrantLock > 一个可重入的互斥锁，具备一样的线程重入特性 ## 特性 - 尝试获得锁 - 获取到锁的线程能够相应中断 ## Lock接口 > 在Java中锁是用来控制多个线程访问共享资源的方式。在Java SE5.0之后新增Lock接口。提供了与`synchronized`关键字类似的同步功能，只是在使用时需要显式的获取和释放锁，缺点就是无法像`synchronized`可以隐式的释放锁，但是可以自由操作获取锁和释放锁。 `void lock()`：执行时，如果锁处于空闲状态，当前线程将获得锁。如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获得锁。 `boolean tryLock()`：如果锁可用，则获取锁，并返回true，否则返回false。该方法只是试图获取锁，如果锁已被其他线程持有，当前线程不会被禁用，会继续向下执行代码。 `void unlock`：当前线程将释放持有锁，**锁只能由持有者释放，如果线程并不持有锁，执行该方法，可能导致异常的发生。** `Condition newCondition()`：条件对象，获取等待通知组件。该组件会与当前锁绑定，当前线程只有获取了锁，才能调用组件的`await()`方法，调用后，线程释放锁。 ## 使用方式 ```java public class ReenTrantLockTest implements Runnable { private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void test() { try { //获得同步锁 lock.lock(); System.err.println("获取锁" + System.currentTimeMillis()); condition.await(); System.err.println(); } catch ( InterruptedException e) { e.printStackTrace(); } finally { //释放同步锁 lock.unlock(); } } public static void main(String[] args) throws InterruptedException { ReenTrantLockTest test = new ReenTrantLockTest(); Thread t1 = new Thread(test); Thread t2 = new Thread(test); t1.start(); t2.start(); t1.join(); t2.join(); System.err.println("结束"); } @Override public void run() { test(); } } ``` 相比`synchronized`增加了一些高级功能： - **等待可中断**：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，去操作其他事情。 - **公平锁**：`多个线程在等待同一个锁时，必须按照申请锁的时间来依次获得锁。` `synchronized`是非公平锁，即`在锁被释放时，任何一个等待锁的线程都有机会获得锁。`这样就有可能会产生 **饥饿现象(有些线程可能永远无法获得锁)**。`ReenTrantLock`默认非公平锁，在构造时修改参数即可变为公平锁。 ```java public class LockFairTest implements Runnable { //true为公平锁 false为非公平锁 默认false private static Lock lock = new ReentrantLock(true); AtomicInteger iii = new AtomicInteger(0); @Override public void run() { while (iii.get() < 20) { lock.lock(); iii.getAndIncrement(); try { System.err.println(Thread.currentThread().getName() + "获得锁"); } finally { lock.unlock(); } } } public static void main(String[] args) { LockFairTest test = new LockFairTest(); Thread t1 = new Thread(test); Thread t2 = new Thread(test); Thread t3 = new Thread(test); Thread t4 = new Thread(test); t1.start(); t2.start(); t3.start(); t4.start(); } } 输出结果： 公平锁： Thread-0获得锁 Thread-1获得锁 Thread-2获得锁 Thread-3获得锁 非公平锁： Thread-2获得锁 Thread-2获得锁 Thread-2获得锁 Thread-2获得锁 ``` - **锁绑定多个条件**：一个`ReenTrantLock`对象可以通过多次调用`newCondition()`同时绑定多个`Condition`对象。在`synchronized`只能实现一个隐含的条件，要多关联只能额外添加锁。 ## 总结 - Lock类可以实现线程同步，获得锁需要执行`lock`，释放锁使用`unlock` - Lock分为公平锁(按照顺序)和不公平锁(不按顺序) - Lock还有读锁和写锁 ## 自定义重入锁 ```java public class CustomReetrantLock { boolean isLocked = false; Thread lockedBy = null; int lockedCount = 0; public synchronized void lock() throws InterruptedException { Thread callThread = Thread.currentThread(); while (isLocked && lockedBy != Thread.currentThread()) { wait(); } isLocked = true; lockedCount++; lockedBy = callThread; } public synchronized void unLock() { if (Thread.currentThread() == this.lockedBy) { lockedCount--; if (lockedCount == 0) { isLocked = false; notify(); } } } } ```]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(七) — 线程安全与锁优化]]></title>
    <url>%2F2018%2F12%2F19%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展(七) — 线程安全与锁优化 date: 2018-12-19 12:15:02 tags: JVM top: 11 --- # 线程安全与锁优化 > 首先需要并发的正确性，然后在此基础上实现高效。 ## 线程安全 > 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。 线程安全的代码必须具备一个特征：**代码本身封装了所有必要的正确保障性手段，令调用者无需关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。** 线程安全的“安全程度”由强至弱分为以下5类： - ### 不可变 > 只要一个不可变的对象被正确的构建出来，那其外部的可见状态永远不会改变 > > `不发生 this引用逃逸 情况下成立 -- 在构造函数返回之前，其他线程已经取得了该对象的引用。` 实现方案： - 如果共享数据是一个`基本数据类型`，只要在定义时用`final`修饰 - 如果共享数据是一个`对象`，最简单的就是 吧对象中带有状态的变量都声明为final 符合不可变要求的类型：`String、枚举类(Enum)、Long，Double以及BigInteger等大数据类型` - ### 绝对线程安全 > 完全满足线程安全的定义，即达到"不管运行环境如何，调用者都不需要任何额外的同步措施。" - ### 相对线程安全 > 保证对这个对象单独的操作是线程安全的，调用时不需做额外的保障措施，但是对于一些特定顺序的连续调用，就需要在调用端使用额外的同步手段保证调用的正确性。 大部分的线程安全类都属于这种类型，例如`Vector,HashTable,synchronizedCollection()` - ### 线程兼容 > 对象本身并非线程安全，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全的使用。 例如`ArrayList,HashMap` - ### 线程对立 > 无论调用端是否采取了同步措施，都无法在多线程环境中并发使用。**应当尽量避免** 例如`Thread中的suspend()和resume()`。 ## 线程安全的实现方法 > ①通过代码实现线程安全 ②通过虚拟机本身实现同步与锁 ### 互斥同步 (阻塞同步) > **同步**：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只能被一个线程使用。 > > **互斥**：实现同步的一种手段，`临界区、互斥量和信号量都是主要的互斥实现方法` **互斥是因，同步是果；互斥是方法，同步是目的** **互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），就会出现问题，无论共享数据是否真的会出现数据竞争，都要进行加锁。** 实现手段： - **synchronized** {% post_link synchorized关键字分析 %} - **ReentrantLock** {% post_link ReenTrantLock关键字分析 %} `synchronized`和`ReentrantLock`的异同： - 两者都是**可重入锁** > **可重入锁**：当一个线程得到一个对象锁后，再次请求该对象锁时是可以再次得到该对象锁的。**自己可以再次获得自己的内部锁。** - `synchronized`依赖于JVM而`ReentrantLock`依赖于API `synchronized`底层用**Mutex(互斥量)**实现，`ReentrantLock`继承自`Lock接口`,Lock接口又依赖于AQS实现 - `synchronized`的锁状态无法在代码中判断，`ReentrantLock`通过`isLocked()`判断 - `synchronized`非公平锁，另一个可以是公平也可以是非公平的 - `synchronized`不可被中断，另一个调用`lockInterrupbity()`即可中断 - `ReentrantLock`可以提高多个线程的读操作的效率 ### 非阻塞同步 > 基于冲突检测的乐观并发策略，即先进性操作，若无其他线程争用共享数据，操作成功；反之，产生了冲突再去采用其他的补偿措施（**最常见自旋——不停重试，直到成功为止**）。 为了保证**操作和冲突检测**具备原子性，需要用到硬件指令集，比如： - 测试并设置 - 获取并增加 - 交换 - ***比较并交换(CAS)*** - 加载链接/条件存储 {% post_link Atomic原子操作类分析%} ### 无同步方案 > 不用同步的方式保证线程安全，因为有些天生就是安全的。 有以下两类： - #### 可重入代码/纯代码(Reentrant Code/Pure Code) > 在代码执行的时候在任何时刻去中断，再去执行另外的代码，在控制权返回后，原来的程序不会出现任何的错误。 **可重入性是它的基本特征，满足可重入性的代码一定是线程安全的，反之，满足线程安全的代码不一定是可重入的。** 共同特征：不依赖存储在堆上的数据和公用的系统资源、用到的状态栏都由参数中传入、不调用非可重入的方法等 判定依据：**返回结果是可预测的，只要是输入了相同的数据就能返回相同的结果，就满足可重入性的要求。** - #### 线程本地存储(Thread Local Storage) > 把共享数据的可见范围限制在同一个进程之内，无须同步也可以保证线程之间不出现数据争用的情况。 使用`ThreadLocal`类可实现本地存储的功能。 ## 锁优化 > 锁优化是为了在线程之间更高效的共享数据，以及解决竞争性问题。 > > 锁的状态共分为4种：**无锁状态、偏向锁、轻量级锁和重量级锁**。锁随着竞争情况可以升级，**但升级后不能降级**。 > > `无锁状态->偏向锁->轻量级锁->重量级锁` ### 1. 自旋锁与适应性自旋 互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，影响系统的并发性能。同时，共享数据的锁定状态只会持续很短的一段时间，不值得去挂起和恢复线程。 **自旋锁**：若物理机器有一个以上的处理器，能使多个线程同时并行执行，让后面的请求锁线程(通过自旋——**CPU忙循环执行空指令**)等待，但不放弃处理器的执行时间，看看持有锁的线程是否很快释放锁。 `自旋等待不能代替阻塞，虽然避开了线程切换的开销，但要占用处理器时间，因此自旋等待必须有一定的上限，若超过了次数没有成功，就需要去挂起线程。` **自适应自旋锁**：自旋时间不固定，由该锁上次的自旋时间及锁的拥有者状态决定。 - 对于某个锁，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，JVM就会认为这次自旋也会再次成功获得锁，进而允许等待持续相对更长的时间 - 对于某个所，自选很少成功获得锁，以后再获取这个锁时可能忽略自旋过程，以避免浪费处理器资源。 ### 2. 锁消除 > JVM即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。 判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为他们是线程私有的，同步加锁操作自然就无须进行。 例如`StringBuffer`对象的连续`append()` ### 3. 锁粗化 > JVM探测到一串零碎的操作都对同一对象进行加锁，将会把加锁同步的范围扩展（**粗化**）到整个操作序列的外代码 ### 4. 轻量级锁 > 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。**轻量级锁并不是用来代替重量级锁的** 必须先了解 HotSpot虚拟机的对象(**对象头部分**)的内存布局：分为两部分 - ***Mark Word***：存储自身的运行时数据，如：`HashCode、GC分代年龄和锁信息`，这部分数据的长度在32和64位中的JVM中分别为32bit和64bit。**它是实现轻量级锁和偏向锁的关键。** - 存储指向方法区对象类型数据的指针，如果是数组对象的话，额外会存储数据的长度。 {% fullimage /images/MarkWord.png,Mark Word,Mark Word %} > 加锁过程 代码进入同步块时，如果同步对象未锁定(标记位为`01`)，虚拟机会在当前线程的栈帧中建立一个`锁记录(Lock Record)`的空间，用于存储对象目前的`Mark Word`拷贝（**Displaced Mark Word**）。 然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。 - 更新成功，那么当前线程拥有了该对象的锁，且对象Mark Word的锁标志位为`00` ，处于轻量级锁定状态。 - 更新失败，JVM首先会检查对象的Mark Word是否指向当前线程的栈帧 - 已指向表明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行 - 没指向表明该对象已被其他线程抢占。 **如果有两条以上的线程竞争同一个锁，轻量级锁就无法使用，需要膨胀为重量级锁，Mark Word的锁标志位变为`10`,存储的是指向重量级的指针，后面等待锁的也会进入阻塞状态。** > 解锁过程 若对象的Mark Word仍然指向线程的Lock Record，那就用CAS操作把对象当前的Mark Word和Displaced Mark Word替换回来 - 替换成功，就完成了整个同步过程 - 替换失败，说明有其他线程尝试获取锁，就要在释放锁的同时，唤醒被挂起的线程 > `栈帧`：用于支持虚拟西进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址信息。第一个方法从调用开始到执行完成，就是一个栈帧从入栈到出栈的过程。 ### 5. 偏向锁 > 消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。**提高一个对象在很长一段时间内都只被一个线程用做锁对象场景下的性能。** > > *偏向锁可以提高带有同步但无竞争的程序性能。* 这个锁会偏向于第一个获得它的线程，如果后续该锁没有被其他线程获取，则持有偏向锁的线程将永远不会进行同步。 > 加锁过程 JVM启用了`偏向锁`模式，当锁对象第一次被线程获取的时候，JVM会把锁标记位置为`01`,即偏向模式。使用CAS操作记录锁的线程ID到Mark Word中。 - CAS操作成功。持有偏向锁的线程在每次进入和退出同步块是，只要比较一下Mark Word存储的线程ID是否相同。 - 相同代表线程已经获得了锁，不需要再用CAS操作加锁和解锁 - 不同，就需要CAS操作竞争锁，竞争成功，替换Mark Word中的ThreadID为当前竞争线程的ID > 解锁过程 当有另一个线程去尝试获取偏向锁时，CAS替换ThreadID失败，就要撤销偏向锁。(撤销偏向锁，需要等待原持有偏向锁的线程到达全局安全点`所有线程都是暂停的，没有字节码正在执行`，暂停线程，并检查状态)。判断原持有偏向锁的线程是否处于活动状态 - 无活动则置为无锁状态(锁标志为`01`，是否偏向锁状态`0`) - 还处于活动状态，则升级为轻量锁(标志位为`00`) > 关闭偏向锁模式 使用JVM参数 `-XX:BlasedLockingStartupDelay=0`可以关闭延迟，因为偏向锁需要应用启动后过几秒激活 `-XX:UseBlasedLocking=false`关闭偏向锁 三种锁的升级 {% fullimage /images/lock-upgrade.png,锁的升级，锁的升级%} 三种锁的比较 | 锁 | 优点 | 缺点 | 适用场景 | | :------: | ------------------------------------------------------------ | --------------------------------------------- | :--------------------------------: | | 偏向锁 | 加锁和解锁不需要额外的消耗，与执行非同步方法相比仅存在纳秒级的差距 | 线程间存在锁竞争，需要带来额外锁撤销的消耗 | 只有一个线程访问同步块场景 | | 轻量级锁 | 竞争的线程不会阻塞，提高程序的相应速度 | 始终得不到锁竞争的线程，会使用自旋消耗CPU资源 | 追求相应时间，同步块执行速度非常快 | | 重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量，同步块执行时间较长 | > **重量级锁**：本质上是依赖操作系统的`Mutex Lock`互斥量来实现同步操作。由于线程间的切换需要从用户态转向核心态，转换成本较高，耗时相对较长。 *一个线程如何判断自己是否取得锁？* > 线程在获取锁之前会判断对象的`Mark Word`中是否存放自己的`threadId`，存放且相同则重入；不同，则使用CAS进行切换，锁升级为`轻量级锁`，释放偏向锁，清空`Mark Word`，线程开始竞争，竞争成功的就存入自己的`ThreadId`，失败的开始自旋。 ## 其他锁类型及其概念 ### 1.乐观锁 > 由于在进程挂起和恢复执行过程中需要很大的开销进行切换。所以有了乐观锁概念。 > > 每次去拿数据的时候都认为别人不会修改，但在更新的时候会去判断在此期间是否数据发生修改，没有被修改则进行数据更新。如果因为修改过产生冲突就失败就重试到成功为止(**自旋**)。 实例：例如`Atomic原子类` 使用场景：适合读取操作比较频繁的场景 ### 2.悲观锁 > 每次获取数据的时候，担心数据被修改，所以每次都要加锁，确保操作过程中数据不会发生改变，操作完成后再解锁让其他线程操作。 > > 在某个资源不可用的时候，就将CPU让出，把当前等待的线程切换为阻塞状态。等到资源可用，将阻塞线程唤醒，进入Runnable状态等待CPU调度。 实例：例如`synchronized` 使用场景：比较适合写入操作频繁的场景 ### 3.互斥锁 > 通过`排他性`，同时只允许一个访问者对其进行访问来保证资源的有效同步，但无法限制线程对该资源的访问顺序 ### 4.**死锁** > 两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用，他们都将无法推进下去。 死锁形成必须要求四个条件： - **互斥条件**：一个资源每次只能被一个线程使用 - **请求与保持条件**：一个线程引请求资源而阻塞时，对已获得的资源保持不放 - **不剥夺条件**：线程已获得的资源，在未使用完之前，不能强行剥夺 - **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系 常见死锁类型： - **静态的锁顺序死锁** `所有需要多个锁的线程，都要以相同的顺序获得锁` ```java class DeadLockTest{ private final Object lockA = new Object(); private final Object lockB = new Object(); public void a(){ synchronized(lockA){ synchronized(lockB){ System.out.println("func A") } } } public void b(){ synchronized(lockB){ synchronized(lockA){ System.out.println("func b") } } } } ``` - **动态的锁顺序死锁** `自定义锁的顺序，确保所有线程以相同的顺序获得锁` - **协作对象之间发生的死锁** `避免在持有锁的情况下调用外部的方法` 死锁预防： - 以确定的顺序获得锁 将所有的锁都按照特定顺序进行获取，防止死锁发生。 > **银行家算法**：允许进程动态的申请资源，但在系统进行资源分配之前，先计算此次资源分配的安全性，若分配不会导致进入不安全状态，则分配；否则等待。 - 超时放弃 > 例如`synchronized`只要线程没有获得锁，就会永远等待下去，`Lock`提供了`tryLock()`可以实现超时放弃]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础]]></title>
    <url>%2F2018%2F12%2F19%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[--- title: Java多线程基础 date: 2018-12-19 10:22:33 tags: Java top: 10 --- # Java多线程基础 ## 基础概念 ### 进程 > 操作系统结构的基础，是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单位。`进程就是程序的实体` ### 线程 > 线程是进程的一个实体，是CPU调度和分配的基本单位，线程是一个比进程更小的执行单位，一个进程在执行期间可以产生多个线程。`一个进程至少一个线程`。一般应用于高并发场景，可以提高CPU的利用率。 ### 多进程 > 每个进程都拥有自己独立的资源，多个进程可在单核处理器上并发执行，在多核处理器并行执行。 ### 多线程 > 一个进程可由多个线程组成，多个线程共享进程内资源，多个线程可在单核处理器上并发执行，在多核处理器并行执行。解决多任务同时执行的需求，合理使用CPU资源。**多线程具有不稳定性** ### 并发 > 在一段时间内多个任务同时执行，或者说在一段时间内可以执行多条指令，微观上看起来就是同时运行多个进程。**偏重于多个任务交替执行，有可能串行执行** ### 并行 > 在同一时刻内多个任务同时执行，多核处理器才可以做到。**偏重于同时执行。** ## 线程基础 ### 1. 进程与线程 两者的区别： - 多个进程间的内部数据和状态都是完全独立的，而多线程是共享一块内存空间和一组系统资源，有可能互相影响 - 线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以**线程的切换负担比进程的切换负担小** - 进程是重量级的任务，需要分配给他们独立的地址空间，进程间通信以及切换时很复杂的。 ### 2. 线程的实现 线程的实现一般有以下3中方法，前面两种比较常见： - #### 继承Thread类，重写`run()`方法 > `Thread`本质上是实现了`Runnable`接口的一个实例。**调用`start()`后并不是立即执行代码，而是是线程的状态变为`Runnable`可运行态，何时运行由操作系统决定。** 主要步骤： 1. 定义Thread类的子类，重写`run()`方法，`run()`方法内部代表了线程需要完成的任务，所以该方法又称`执行体` 2. 创建Thread类子类实例，即创建线程对象 3. 调用线程对象的`start()`启动线程 ```java public class ThreadTest extends Thread{ public void run(){ System.out.println("Hello Thread"); } public static void main(String[] args){ Thread thread = new ThreadTest(); thread.start(); } } ``` 拓展： 只调用`run()`和执行普通方法是一致的。 - #### 实现Runnable接口，并实现`run()`方法 主要步骤： 1. 自定义类实现`Runnable`，实现`run()`方法 2. 创建Thread类子类实例，即创建Thread对象 3. 调用实例的`start()` ```java public class RunnableTest implements Runnable{ public void run(){ System.out.println("Hello Runnable"); } public static void main(String[] args){ RunnableTest runnable = new RunnableTest(); Thread thread = new Thread(runnable); thread.start(); } } ``` - #### 实现Callable接口，重写`call()`方法需配合`Future`或者`FutureTask` 主要步骤： 1. 创建`Callable`接口实现类，并实现`call()`方法 2. 创建`Callable`实现类的实例，使用`FutureTask`包装`Callable`对象 3. 使用`FutureTask`对象作为Thread对象的target创建并启动新线程 4. 调用`FutureTask`对象的`get()`方法获得子线程执行结束后的返回值，**调用`get()`会阻塞线程** ```java public class TestCallable { public static class MyTestCallable implements Callable{ @Override public String call() throws Exception { return "Hello Callable"; } } public static void main(String[] args){ MyTestCallable myTestCallable = new MyTestCallable(); //利用futuretask FutureTask futureTask = new FutureTask(myTestCallable); Thread t =new Thread(futureTask); t.start(); try { System.err.println(futureTask.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } //利用ExecutorService产生一个线程 结合future ExecutorService executorService = Executors.newSingleThreadExecutor(); Future future = executorService.submit(myTestCallable); try { System.err.println(future.get()); executorService.shutdown(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } //利用ExecutorService产生一个线程 结合futureTask executorService.submit(futureTask); try { System.err.println(futureTask.get()); executorService.shutdown(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } } ``` `Runnable`与`Callable`不同点： - `Runnable`不返回执行结果，`Callable`可返回结果 - `Callable`可以抛出异常 - `Runnable`可直接由`Thread构造`或者`EXecutorService.submit()`执行 运行`Callable`可以得到一个Future对象，表示异步计算的结果。提供了检查计算是否完成的方法以等待计算的完成，并检查计算结果。 ```java public interface Future { //试图取消任务的执行。mayInterruptIfRunning确定是否应该以试图停止任务的方式中断执行任务流程。true 直接中断 false等待执行完成 boolean cancel(boolean mayInterruptIfRunning); //任务正常完成前将其取消，返回true boolean isCancelled(); //任务已完成或者因为正常终止、异常，取消而完成，返回true boolean isDone(); //等待计算结果的返回，如果被取消则抛出异常 V get() throws InterruptedException, ExecutionException; //设定执行时间，超过时间则抛出Timeout异常 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } ``` #### 三种方法的比较 | 方式 | 优点 | 缺点 | | ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | | 继承Thread类 | 编写简单，可以使用`this`直接访问当前线程 | 1.受限于Java类的单继承，无法继承其他类；2.多个线程之间无法共享方法或实例变量 | | 实现Runnable接口 | 多个线程可共享一个实现了`Runnable`接口的类，非常适合多个线程处理同一任务 | 1.`run()`没有返回值2.不能直接捕获运行过程中的异常，需要使用`setDefaultUncaughtExceptionHandler()`捕获子线程的异常 | | 实现Callable接口 | 多个线程可共享一个实现了`Callable`接口的类，非常适合多个线程处理同一任务；可以有返回值；可以抛出异常 | 编写略微复杂，要访问当前线程需要使用`Thread.currentThread()` | #### 线程创建的内存代价 > 每当有线程创建时，JVM就需要在内存中分配`虚拟机栈`和`本地方法栈`来记录调用方法的内容，分配`程序计数器`记录指令执行的位置，这样的`内存消耗`就是创建线程的内存代价。 ### 3. 线程的状态 Java线程在运行的生命周期中可能处于6种不同的状态： - #### New(创建) 线程被创建，还没有调用`start()`，还没有运行 - #### Runnable(可运行) 一旦调用`start()`，线程处于`Runnable`状态，一个可运行的线程可能处于正在运行或没有运行状态，这取决与操作系统给系统提供运行的时间 - #### Blocked(阻塞) 表示线程被锁阻塞而等待监事锁(`monitor`)，暂时不能活动 - #### Waiting(等待) 线程暂时不活动，并不运行任何代码，消耗最少资源并等待线程调度器重新激活它。 - #### Timed Waiting(超时等待) 在指定等待时间内等待另一个线程执行特定的方法的线程状态 - #### Terminated(终止) 表示当前线程已执行完毕。导致线程处于终止态有两种情况： - `run()`执行完毕正常退出 - 一个没有捕获的异常终止了`run()`，导致线程终止 {% fullimage /images/Thread-State.png,线程状态,线程状态%} ### 4. 线程的分类 - #### 普通线程(用户线程) 运行在前台，执行具体的任务，如程序的主线程，链接网络的子线程都是用户线程 - #### 守护线程 运行在后台，为其他线程提供服务，如果所有的前台线程都死亡，守护线程也随之死亡。当整个虚拟机只剩下后台线程，虚拟机也就退出了。 应用：JVM虚拟机启动后的后台检测线程，数据库连接池中的检测线程 最常见的守护线程：`虚拟机中的垃圾回收线程` ### 5. 线程中的常见方法 - #### `start()` `start()`方法执行后，表示该线程到达了`Runnable`状态，何时运行还要等待线程调度器调度 **线程死亡后，不可再次调用`start()`，只能对`New`状态的线程调用且只能调用一次`start()`** - #### `run()` 直接调用`run()`，只是调用线程中的代码，多个线程无法并发执行 - #### *`join()` 主要作用是**等待该线程终止**。`主线程需要等待子线程执行完成之后再结束，也就是在子线程调用了join()方法后面的代码只有子线程结束了才可以执行。` - #### *`sleep(long mills)` 主动放弃占用的处理器资源，进入`Blocked`。使当前执行的线程以指定的毫秒数休眠（`暂时停止执行`），具体取决于定时器和调度程序的精度和准确性。当超过了指定的睡眠时间后，线程进入`Runnable`，等待线程调度器调用。 - #### *`yield()` 主动放弃占用的处理器资源，进入`Runnable`状态，等待线程调度器调用。**放弃的时间不确定，可能一会就回重新获取CPU，线程调度器重新调用。** - #### *`interrupt()`和`isInterrupted()` `interrupted()`：请求线程终止，实际线程并不一定会终止，执行后可以将中断标识位设置为false。线程会时不时的检测中断标识位，以判断线程是否应该被中断。 `isInterrupted()`：检测当前线程是都已经是中断状态，检测中断标识位 - #### `setPriority()` 设置线程的优先级，**理论上说：线程优先级高的更容易被执行，但也要结合具体的系统。** 使用`getPriority()`可以查看当前线程的优先级。 - #### `isAlive()` 检查线程是否处于活动状态，如果线程处于`Runnable(就绪或运行),Blocked(阻塞)`返回`true`，若处于`New(新建),Terminated(终止)`返回`false` - #### *`wait()/wait(long mills)` 导致线程进入等待状态，并释放锁。`mills`为等待时间，超过这个时间没有对当前线程进行唤醒(调用`notify()/notifyAll()`)即会自动唤醒。未设置`mills`，则直到被唤醒为止。**只能在同步方法或者同步块内调用，例如`synchronized(lockobj) {...} `** - #### *`notify()` 让当前线程通知那些处于等待(`Waiting`)的线程，当前线程执行完毕后释放锁，随机选择一个在该对象上调用`wait()`的线程，解除其阻塞状态。**只能在同步方法或者同步块内调用，例如`synchronized(lockobj) {...} `** - #### *`notifyAll()` 让当前线程通知那些处于等待(`Waiting`)的线程，当前线程执行完毕后释放锁，唤醒所有在该对象上调用`wait()`的线程，解除其阻塞状态。**只能在同步方法或者同步块内调用，例如`synchronized(lockobj) {...} `** > `wait()`和`sleep()`的区别 > > - `sleep()`来自于Thread类方法，`wait()`来自Object类 > - `sleep()`不会释放锁，`wait()`释放锁，使得其他线程可以使用同步控制块或者方法 > > - `sleep()`让当前正在执行的线程休眠，等待一定的时间之后，会重新进入`Runnable`。`wait()`使实体所处线程暂停运行，直到被`notify()/notifyAll()`唤醒或者`wait()`的时间到达。 ### 6. 线程安全中断 ```java public class InterruptThreadTest extends Thread { //第一种 判定当前线程的中断标识位是否为true @Override public void run() { long l = 0; while (!Thread.currentThread().isInterrupted()) { l++; System.err.println("l = " + l); } System.err.println("线程已经停止"); } //第二种 自己设置中断标识位 on private static volatile boolean on = true; @Override public void run() { long l = 0; while(on){ l++; System.err.println("l = " + l); } System.err.println("线程已经停止"); } private static void cancel(){ on = false; } public static void main(String[] args) { try { InterruptThreadTest thread = new InterruptThreadTest(); thread.start(); TimeUnit.MILLISECONDS.sleep(10); //第一种 调用interrupt设置中断标识位为 true thread.interrupt(); //第二种 自己设置中断标识位 cancel(); } catch (InterruptedException e) { e.printStackTrace(); } } } ``` ### 7.线程优先级 > 线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使用哪个线程进入运行状态。*低优先级的线程并不意味着不会被运行，只是运行几率会变小。* > > 线程优先级具有**继承特性**，比如A线程启动B线程，则B线程与A线程优先级一致 > > 线程优先级具有**随机性**，线程优先级高的不一定每次都先执行完。 > > 优先级从`1-10`，10为最高级，1为最低级 ### 8. 线程调度策略 - #### 抢占式调度策略 如果一个优先级比其他任何处于可运行状态的线程都高的线程都进入就绪状态，那么运行时系统就会选择该线程运行。 - #### 时间片轮转调度策略 从所有处于就绪状态的线程中优先选择优先级最高的线程分配一定的CPU时间运行，该时间过后再去选择其他线程运行。`只有当线程运行结束或者放弃等原因进入阻塞状态，低优先级的线程才有机会执行。`若优先级相同，则调度程序以轮转的方式选择运行的线程。 ## 多线程 ### 1. 多线程的优缺点 优点： > 1. 资源利用率好 > 2. 提高程序的执行效率(多个线程同时执行) > 3. 程序响应更快 缺点： > 1. 设计更复杂 > > 多线程程序在访问共享数据时需要小心处理，否则会出现难以修复的bug。线程之间的交互往往非常复杂，不正确的线程同步产生的错误难以被发现并修复(由于线程调度的无序性，可能依赖于某种特殊的线程执行序列)。 > > 2. 上下文切换的开销 > > 线程是由CPU进行调度的，CPU的一个时间片内只执行一个线程上下文内的线程。**上下文切换**(`当CPU从执行一个线程切换到执行另一个线程时，需要先存储当前线程的本地数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后开始执行另一个线程。`)这个过程并不廉价，如果没有必要，要尽量减少`上下文切换`的发生。 > > 3. 更多的资源消耗 > > 除了CPU执行`上下文切换`的消耗外，线程的执行还有其他的资源消耗。例如**内存同步的开销(线程需要一些内存维持本地栈去存储线程专用数据)**、**创建线程和终止的开销**，**线程调度的开销**等。 拓展： - 引起**上下文切换**的原因 - 时间片用完，CPU正常调度下一个任务 - 被其他线程优先级更高的任务抢占 - 执行任务遇到阻塞，调度器挂起当前任务，切换执行另一个任务 - 用户主动挂起线程(`yield()`,`sleep()`) - 多任务抢占资源，没有抢到被挂起 - 硬件中断 - 线程切换的性能代价 > JVM需要先保存起被挂起线程的上下文环境：将线程执行位置保存在`程序计数器`中，调用方法的信息保存到`栈`中，待执行线程的`程序计数器`和`栈`中信息写入到处理器中。维护线程隔离数据区中的内容在**处理器中的导入导出**，就是线程切换的性能代价。 减少线程上下文切换的方法： - 使用基于CAS的非拥塞算法 - 无锁并发编程，尽量使用`ThreadLocal`或者不变量，而不是用锁 [安全共享策略](https://www.jianshu.com/p/bb36fee3e55c) - 使用`线程池+等待队列`的方式，控制线程数目 ### 2. 线程同步 > 如果两个线程竞争统一资源时，并且每一个线程都调用了修改该对象的方法，这种情况通常称为**竞态条件**。导致竞态条件发生的代码区称为**临界区**。 > > 若一个资源的创建、使用，销毁都在同一个线程内，且不会脱离该线程的控制，则无需同步。 - #### 同步方法 `synchronized`方法锁 - #### 同步代码块 `synvhronized`类锁 - #### wait()和notify() - #### volatile - #### 重入锁 `Lock` - #### 局部变量 `ThreadLocal` - #### 阻塞队列 `BlockingQueue` ### 3. 线程通信 > 线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。 - #### wait()/notify() 在`synchronized`修饰的同步方法或者同步代码块中使用Object类提供的`wait()、notify()，notifyAll()`这三个方法进行线程通信 - #### Condition 当程序使用`Lock`类同步，系统不存在隐式的同步监视器，只能用Condition控制线程通信 - #### BlockingQueue `BlockingQueue`提供了`put(E e)`和`take()`支持阻塞的方法。 体现在`生产者-消费者模式` 生产者-消费者模式的实现 1. wait()/notify()实现 2. Condition() 3. BlockingQueue ```java public class ProductCustomerBlockQueue { private int queueSize = 10; private ArrayBlockingQueue queue = new ArrayBlockingQueue(queueSize,true); public static void main(String[] args) { ProductCustomerBlockQueue blockQueue = new ProductCustomerBlockQueue(); Producter producter = blockQueue.new Producter(); Customer customer = blockQueue.new Customer(); producter.start(); customer.start(); } class Customer extends Thread { @Override public void run() { while (true) { try { queue.take(); System.err.println("消费哦"); } catch (InterruptedException e) { e.printStackTrace(); } } } } class Producter extends Thread { @Override public void run() { while (true) { try { queue.put(1); System.err.println("生产哦"); } catch (InterruptedException e) { e.printStackTrace(); } } } } } ``` ## 线程池 {% post_link Android-Study-Plan-XVII %}]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(六) -- Java与线程]]></title>
    <url>%2F2018%2F12%2F18%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展(六) -- Java与线程 date: 2018-12-18 16:34:07 tags: JVM top: 11 --- # Java与线程 ## 线程的实现 线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程间既可以共享进程资源，又可以独立调度(`线程是CPU调度的基本单位`)。 实现线程主要有三种方式： - ### 使用内核线程实现 > 直接由操作系统内核支持的线程。 > > 由内核来完成切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。 `多线程内核`：有能力处理多件事情，支持多线程的内核 `轻量级进程`：内核线程的一种高级接口。`只有先支持内核线程，才能有轻量级进程` - 优点：每个轻量级进程都是一个独立的调度单元，即使有一个在系统调用中堵塞了，也不影响整个进程继续工作。 - 缺点：各种线程操作都需要进行系统调用，代价相对高，需要在**用户态和内核态**中来回切换。另外轻量级进程的数量是有限的。 - 轻量级进程与内核线程是1:1的关系 - ### 使用用户线程实现 > 广义：一个线程只要不是内核线程，就可以认为是用户线程 > > 狭义：完全建立在用户空间的线程库上，而系统内核不能感知线程存在的实现 - 优点：线程的建立、同步、销毁和调度都在用户态中完成，不需要内核参与，所以操作时非常快速且低消耗，还支持更大的线程数量 - 缺点：没有系统内核的支持，所有线程操作都需要用户程序自己处理，实现较复杂 - 进程与用户线程之间是1:N的关系 - ### 使用用户线程加轻量级进程混合实现 > 既存在用户线程，也存在轻量级进程。 - 优点：用户线程还是在用户空间中，还可以支持大规模的用户线程并发；轻量级进程可以作为内核线程和用户线程之间的桥梁，用户线程的系统调用需要轻量级进程来完成，大大降低了系统被阻塞的危险。 - 采用多对多的线程模型。 Java线程的实现是不能确定的。**由于操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的。** ## 线程调度 > 系统为线程分配处理器使用权的过程。 主要调度方式有两种： - ### 协同式线程调度 > 线程的执行时间有 **线程本身** 控制，线程把自己的工作执行完后，要主动通知系统切换到另一个线程上。 - 优点：实现简单，切换操作可知，基本不存在线程同步问题 - 缺点：线程执行时间不可控 - ### 抢占式线程调度 > 每个线程由系统分配执行时间，线程的切换不由线程本身决定 - 线程执行时间是可控的，不存在因为一个线程而堵塞整个系统的问题 - 可以设置**线程优先级**，优先级越高的线程越容易被系统选择执行 `线程优先级并不是太靠谱，一方面线程调度还是取决于操作系统，优先级的实现不会太一致。另一方面优先级会被系统自行改变。` ## 线程状态转换 > 在任意时间点，一个线程有且只有一个状态 {% fullimage /images/Thread-State.png,线程状态转换,线程状态转换%} - ### 新建 > 线程创建后尚未启动的线程状态 - ### 运行 > 包括正在执行和等待着CPU为它分配执行时间 - ### 无限期等待 > 不会被分配CPU执行时间，要等待被其他线程显示的唤醒。以下方法会让线程陷入无限期的等待状态： > > 1. 没有设置Timeout参数的`Object,wait()` > 2. 没有设置Timeout参数的`Thread.join()` > 3. `LockSupport.park()` - ### 限期等待 > 不会被分配CPU执行时间，但在一定时间后会被系统唤醒。以下方法会让线程进入限期等待状态： > > 1. `Thread.sleep()` > 2. 设置Timeout参数的`Object,wait()` > 3. 设置Timeout参数的`Thread.join()` > 4. `LockSupport.parkNanos()` > 5. `LockSupport.parkUntil()` - ### 阻塞 > 线程被阻塞了 在程序等待进入同步区域的时候进入这种状态。 > > **阻塞状态**：等待着获取到一个**排他锁**，将在另一个线程放弃这个锁的时候发生 > > **等待状态**：在等待一段时间或者唤醒动作的发生 - ### 结束 > 线程已经结束执行]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized关键字分析]]></title>
    <url>%2F2018%2F12%2F18%2Fsynchorized%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: synchronized关键字分析 date: 2018-12-18 15:07:11 tags: Java top: 10 --- # synchronized >`synchronized`可作用于一段代码或方法，既可以保证可见性也可以保证原子性。 > >**可见性**：通过`synchronized`能保证同一个时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前将会对变量的修改刷新到主存中。 > >**原子性**：要么不执行，要么执行到底。 > >锁类型为：**可重入锁，非公平锁，独占锁，互斥锁** ## `synchronized`作用 - 确保线程互斥的访问代码块，同一时刻只有一个方法进入临界区 - 保证共享变量的修改能即时可见 - 有效解决重排序问题 ## `synchronized`使用 ### 修饰实例方法，锁的是当前对象实例(this) > 一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。 ```java public class SynchronizedMethodTest { public synchronized void method1(){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.err.println("method1 finish" + System.currentTimeMillis()); } public synchronized void method2(){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.err.println("method2 finish"+ System.currentTimeMillis()); } public static void main(String[] args){ final SynchronizedMethodTest test =new SynchronizedMethodTest(); new Thread(test::method1).start(); new Thread(test::method2).start(); } } 输出结果： method1 finish 1545188801152 method2 finish 1545188803157 ``` ### 修饰静态方法，锁的是当前Class对象(静态方法属于类，而不是对象) > 由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。 ```java public class SynchronizedStaticMethodTest { public synchronized static void method1() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.err.println("method1 finish" + System.currentTimeMillis()); } public synchronized static void method2() { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.err.println("method2 finish" + System.currentTimeMillis()); } public static void main(String[] args) { new Thread(SynchronizedStaticMethodTest::method1).start(); new Thread(SynchronizedStaticMethodTest::method2).start(); } } 输出结果 method1 finish 1545189344322 method2 finish 1545189346327 ``` ### 修饰代码块，锁的是括号里的对象 > 修饰代码块 其中普通代码块 如`synchronized（obj）` 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。 > Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。 > Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。 > > **就是 Synchronized代码块更加灵活精确。** ```java public class SynchronizedCodeBlockTest { public void method1() { synchronized (this) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.err.println("method1 finish" + System.currentTimeMillis()); } } public void method2() { synchronized (this) { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.err.println("method2 finish" + System.currentTimeMillis()); } } public static void main(String[] args) { final SynchronizedCodeBlockTest test =new SynchronizedCodeBlockTest(); new Thread(test::method1).start(); new Thread(test::method2).start(); } } 输出结果： method1 finish 1545189694303 method2 finish 1545189696308 ``` ## `synchronized`原理 JVM基于进入和退出`monitor`对象来实现**代码块同步**和**方法同步**。 - **代码块同步** 在编译后通过`monitorenter`插入到同步代码的开始处，将`monitorexit`插入到代码结束处和异常处，反编译字节码时就可以看到相关指令。**JVM要保证每个monitorenter必须有对应的monitorexit。** `monitorenter`：每个对象都有一个监视器锁(`monitor`)，当某个monitir被某个线程占用时就会处于锁定状态，线程执行`monitorenter`指令时会尝试获取`monitor`的所有权，尝试获取对象的锁。 - monitor进入数为0，则该进程进入monitor，然后将进入数置为1，该进程即为monitor的持有者 - 如果线程已占有monitor，只是重新进入，则monitor进入数+1 - 如果其他线程已占用monitor，则该线程处于堵塞状态，直至monitor进入数为0，在尝试重新获取monitor的所有权 `monitorexit`：执行`monitorexit`的线程必须是objectref所对应的monitor持有者。指令执行时，monitor进入数-1，如果-1后进入数为0，则线程退出monitor，不再是monitor持有者。其他被这个monitor阻塞的线程就可以尝试去获取monitor。 > 反编译命令 `javap -v **.class` ```java 3: monitorenter 4: ldc2_w #16 // long 2000l 7: invokestatic #4 // Method java/lang/Thread.sleep:(J)V ... 45: aload_1 46: monitorexit 47: goto 55 50: astore_3 51: aload_1 52: monitorexit ``` - **方法同步** `synchronized`在`method_info`会添加`ACC_synchronized`标记，线程执行会识别该标记，获取对应的锁。 ```java public synchronized void method2(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=4, locals=2, args_size=1 0: ldc2_w #16 // long 2000l 3: invokestatic #4 // Method java/lang/Thread.sleep:(J)V ``` 两者实现细节不同，**本质上都是对一个对象的监视器(monitor)获取，任意一个对象都拥有自己的监视器。**当这个对象由代码块同步或者方法同步调用时，**执行方法的线程必须先获取对象的监视器才能进入同步块或同步方法，没有获取到对象监视器的线程就会被堵塞在入口处，变为Blocked堵塞状态。当成功获取监视器线程释放了锁后，会唤醒堵塞的同步队列的线程，使其重新尝试获取监视器。** {% fullimage /images/synchronized-monitor.png,同步方法关系,同步方法关系%} 理解Java中的synchronized关键字。 指标：理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。 有如下一个类A ```java class A { public synchronized void a() { } public synchronized void b() { } } ``` 然后创建两个对象 ```java A a1 = new A(); A a2 = new A(); ``` 然后在两个线程中并发访问如下代码： Thread1 Thread2 a1.a(); a2.a(); 请问二者能否构成线程同步？ 如果A的定义是下面这种呢？ ```java class A { public static synchronized void a() { } public static synchronized void b() { } } ``` # 答案 Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。 > Synchronized作用: - 确保线程互斥的访问同步代码块 - 保证共享变量的修改能够及时可见 - 有效解决重排序问题 > wait(),notify(),notifyAll(),sleep()作用 - wait 调用线程 释放锁，然后进入休眠 - sleep thread的一个操作方法，不释放锁直接进入休眠 - notify 唤醒等待队列中的第一个相关进程 - notifyAll 唤醒所有 > Synchronized主修修饰对象为以下三种： 1. 修饰普通方法 一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。 2. 修饰静态方法 由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。 3. 修饰代码块 其中普通代码块 如Synchronized（obj） 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。 Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。 Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。 简单来说 就是 Synchronized代码块更加灵活精确。 > 示例代码 ```java public class SyncThread implements Runnable { private static int count; public SyncThread() { count = 0; } @Override public void run() { synchronized (this) { for (int i = 0; i < 5; i++) { try { System.err.println(Thread.currentThread().getName() + " " + (count++)); Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } } public static int getCount() { return count; } } ``` # 修饰代码块 ```java public static void main(String[] args) { SyncThread syncThread = new SyncThread(); Thread thread1 = new Thread(syncThread, "sync1"); Thread thread2 = new Thread(syncThread, "sync2"); thread1.start(); thread2.start(); } ``` 访问的同一个对象时，同一时刻只能有一个线程执行，执行代码块是会锁定当前对象，所以需要执行完才能释放，下一个线程才能继续执行并锁定对象 > 运行结果 ```log sync1 0 sync1 1 sync1 2 sync1 3 sync1 4 sync2 5 sync2 6 sync2 7 sync2 8 sync2 9 ``` # 修饰对象 ```java public static void main(String[] args) { Thread thread1 = new Thread(new SyncThread(), "sync1"); Thread thread2 = new Thread(new SyncThread(), "sync2"); thread1.start(); thread2.start(); } ``` 这时创建了两个SyncThread对象，线程1执行对象1中的同步代码，线程2执行的是对象2的代码，这时两把锁分别锁定SyncThread1和SyncThread2对象，两把锁互不干扰也不互斥，所以同时执行。 > 运行结果 ```log sync1 0 sync2 1 sync1 2 sync2 3 sync1 4 sync2 5 sync1 6 sync2 7 sync1 8 sync2 9 ``` 问题1 ：不能同步 - a1.a()锁是a1 a2.b()锁是a2 不是同一把锁 所以不同步 问题2：能同步 - 锁都为A.class对象，是统一把锁]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS操作&Atomic原子操作类分析]]></title>
    <url>%2F2018%2F12%2F18%2FAtomic%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: CAS操作&Atomic原子操作类分析 date: 2018-12-18 14:50:08 tags: - JVM - Java top: 10 typora-root-url: ../../themes/next-t/source/images --- # CAS操作 & Atomic原子操作类 ## CAS操作 > CAS是乐观锁技术，当多个线程尝试使用CAS更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程不会被挂起，而是告知竞争失败，并尝试再次发起请求。 CAS指令需要有三个操作数： - **内存位置(V)**：简单的理解为变量的内存地址 - **旧的预期值(A)** - **新值(B)** 执行CAS操作，当且仅当`V`符合旧预期`A`时，处理器就会更新`B`到`V`上。否则处理器不做任何操作。 ```java //伪代码实现 boolean compareAndSwap(V,A,B){ if(V!=A){ return false;//CAS操作失败 }else{ V=B;//替换内存中的值为新值 return true;//CAS操作成功 } } ``` ### CAS原理 > `compareAndSet()`内部是调用Java本地方法`compareAndSwapInt()`实现的，虚拟机内部对这些方法做了特殊处理，借助C来调用CPU的底层指令保证硬件层面实现原子操作。 > > Intel CPU 利用**cmpxchg**指令实现CAS ### CAS问题 - #### ABA问题 因为CAS需要在操作值的时候检查值是否发生变化，如果没有发生变化则更新，但如果一个值原来是A，变成了B，再变成了A，对于CAS检查而言就是没有发生过变化，实际已经发生变化。 解决思路就是利用版本号，在变量前添加版本号，并每次更新时加1，则A->B->A 会变为 1A->2B->3A。 可以利用`AtomicStampedReference`来解决，它内部的`compareAndSwap()`首先会去检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，全部相等才会替换值。 - #### 循环时间长开销大 CAS是非阻塞同步，不会将线程挂起，会进行自旋（`死循环`），时间过长会对性能造成很大的消耗。`Pause`指令 - #### 只能保证一个变量的原子操作 当对多个变量进行操作时，CAS无法保证原子性操作，这时可以用锁或者`AtomicReference`保证引用对象之间的原子性，就可以把多个变量放在一个对象里进行操作。 ## Atomic原子操作类 > 方便在多线程环境下，无锁的进行原子操作。**提供非阻塞的线程安全编程** ### 类摘要 | 类 | 描述 | | --------------------------- | ------------------------------------------------------- | | AtomicInteger | 更新int | | AtomicBoolean | 更新boolean | | AtomicLong | 更新long | | AtomicIntegerArray | 更新int数组 | | AtomicIntegerFieldUpdater | 基于反射，可以对指定类的指定``volatile int`字段进行更新 | | AtomicLongArray | 更新long数组 | | AtomicLongFieldUpdater | 基于反射，可以对指定类的指定`volatile long`字段进行更新 | | AtomicMarkableReference | 维护带有标记的对象引用，可以更新 | | AtomicReference | 更新对象引用 | | AtomicReferenceArray | 更新对象引用数组 | | AtomicReferenceFieldUpdater | 基于反射，可以对指定类的指定volatile 字段进行更新 | | AtomicStampedReference | 维护带有整数标志的对象引用，可以更新 | Java 8之后新增了4个新的原子操作类 | 类 | 描述 | | ----------------- | ---------- | | LongAdder | 更新long | | DoubleAdder | 更新double | | LongAccumulator | 更新long | | DoubleAccumulator | 更新double | 上述四个类引用`多段锁`的概念。**通过CAS保证原子性，通过自旋保证当次修改的最终修改成功，通过降低锁粒度（多段锁）增加并发性能。** 他们**属于原子累加器，适用于数据统计以及高并发环境，不适用于其他粒度的应用。** > `原子累加器`使用了**热点分离**思想 > > **热点分离**：①将竞争的数据进行分解成多个单元，在每个单元中分别进行数据处理 ②各单元处理完成后，通过`Hash算法`进行求和，从而得到最终结果 > > `热点分离`减小了锁的粒度，提供并发环境下的吞吐量，但需要额外空间存储数据，增大空间消耗。 ### 如何保证原子操作 内部都实现了一个`compareAndSet()`方法 ```java // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); } catch (Exception ex) { throw new Error(ex); } } //用volatile修饰 value 保证可见性 private volatile int value; public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset/*V 内存地址*/, expect/*A 旧的预期值*/, update/*B 修改值*/); } ``` `compareAndSwap()`涉及了两个重要对象，一个是`unsafe`另一个是`valueOffset`。 `unsafe`是JVM提供的一个后门，用来执行 **硬件级别的原子操作**。 `valueOffset`是通过`unsafe`获取到的，代表 **AtomicInteger对象value成员变量在内存中的偏移量**。可以简单的认为是*value变量的内存地址*。]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字分析]]></title>
    <url>%2F2018%2F12%2F17%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: volatile关键字分析 date: 2018-12-17 15:53:52 tags: Java top: 10 --- # volatile ***volatile的主要作用是保证可见性以及有序性，不一定保证原子性。*** > JVM提供的最轻量级的同步机制。 当一个变量被`volatile`关键字修饰后，就会具备两层语义： - **保证此变量对所有线程的可见性，这里指 当一条线程修改了这个变量的值，新值对于其他线程来说是立即可得知的。** - **禁止进行指令重排序** > volatile 保证可见性 在使用`volatile`关键字修饰一个变量后，该变量在一个线程中被修改后，会发生如下事情： 1. 修改后，修改的变量值会强制立即写入主内存中 2. 然后强制过期其他线程中工作内存中的缓存，使缓存无效 3. 由于缓存无效，其他线程需要读取该变量值时，会强制重新从主内存中读取 > 当访问共享变量时，多个线程也会在自己的工作内存中有一份共享变量的副本。当某个线程更改了自己工作内存中的数据时，由于某些原因（线程阻塞）没有及时的刷新数据至主内存，然后其他线程的工作内存中的数据还是老数据。就会导致`缓存一致性`问题。 > > **缓存一致性**：当其他线程读取该变量时，发现该缓存是无效的，就会从主内存中重新读取。 {% fullimage /images/volatile-process.png,volatile可见性,volatile可见性%} > volatile 保证有序性 `volatile`禁止指令重排序，可以在一定程度上保证有序性。 **指令重排序**：JVM为了优化指令，提高程序运行效率，在不影响**单线程**执行结果的前提下，尽可能的提高并行度。 volatile关键字通过提供“**内存屏障(重排序时不能把后面的指令重排序到内存屏障之前的位置)**”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。`加入volatile关键字的代码会多出一个lock前缀指令`。 内存屏障提供如下功能： - 重排序时不会把后面的指令重排序到内存屏障之前的位置—`有序性` - 本CPU的Cache立即写入内存，并且会引起别的CPU或者别的内核无效化其Cache，可以是对volatile变量的修改对其他CPU可见—`可见性` > volatile不保证原子性 `volatile`只能保证对单个volatile变量的读/写具有原子性，但是对于`volatile++`这样的复合操作没办法。 自增操作 `volatile++`实际执行了三步： 1. 读取变量的初始值 2. 在CPU中加1 3. 重新写入工作内存，在写入主内存 要想保证原子性，只能借助于`synchronized、Lock和java.util.concurrent.atomic包下的原子操作类`保证这些操作时原子性操作。 > volatile应用场景 `volatile`由于无法保证原子性，所以要使用必须具备以下两个条件： - 对变量的写操作不依赖于当前值 ```java volatile int a = 0 ; a = a * 2; ``` - 该变量没有包含在具有其他变量的不变式中 ***在多线程场景下，这两种情况即时使用`volatile`修饰，也有可能会有同步问题。*** > volatile 使用实例 1. 状态量标记 ```java volatile bool flag = true; public void write(){ flag = false; } public void modify(){ if(flag){ doSth(); } } ``` 2. 单例模式的实现(DCL) ```java class Singleton{ private Singleton(){ } private volatile static Singleton sInstance; public static Singleton getInstence(){ if(sInstance == null){ synchronized(Sineleton.class){ if(sInstance == null){ sInstance = new Singleton(); } } } return sInstance; } } ``` > `volatile` 和 `synchronized`区别 - `volatile`仅能使用在变量级别，`synchronized`适用于变量、方法和类 - `volatile`仅能实现变量修改可见性，不保证原子性；`synchronized`可以保证可见性及原子性 - `volatile`不会造成线程的阻塞；`synchronized`会造成阻塞(`阻塞同步`) - `volatile`由于禁止指令重排序，不会被编译器优化；`synchronized`会被优化]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DiskLruCache源码分析]]></title>
    <url>%2F2018%2F12%2F17%2FDiskLruCache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: DiskLruCache源码分析 date: 2018-12-17 14:54:18 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[实现自定义图片加载框架]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[--- title: 实现自定义图片加载框架 date: 2018-12-17 14:49:16 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[View的工作原理]]></title>
    <url>%2F2018%2F12%2F14%2FView%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[--- title: View的工作原理 date: 2018-12-14 16:47:21 tags: Android top: 11 --- # View的工作原理 {% fullimage /images/View工作原理.png,View工作原理,View工作原理%} ## ViewRoot以及DecorView的概念和何时关联 ### ViewRoot *ViewRoot对应于ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程均需通过ViewRoot完成。* ### DecorView **DecorView是整个Window界面的最顶层View。** *可以使用Android Studio自带的Layout Inspector查看页面层级* 一般情况下`DecorView`会包含一个竖直方向的LinearLayout，该LinearLayout分为上下两个部分，上面是标题栏(`titlebar`)，下面是内容栏(`继承自FrameLayout 且id为content`)。因此我们设置Activity的布局方法叫做`setContentView()`，因为他们都被加进了`id为content的FrameLayout`中。 我们可以利用`ViewGroup content = findViewById(R.android.id.content)`获取conetnt。使用`content.getChildAt(0)`获取设置的Activity布局。 ```java // ../android/app/Activity.java public T findViewById(@IdRes int id) { //从Window中去获取View return getWindow().findViewById(id); } // ../android/view/Window.java public T findViewById(@IdRes int id) { //从DecorView获取View return getDecorView().findViewById(id); } ``` 所有的View都会从DecorView中开始检索，所以**View层的事件都会先经过DecorView，再传递到我们定义的View上**。 ### 如何关联 当Activity创建时，最终是调用到`ActivityThread`的`handleLaunchActivity`来创建Activity。 ```java // ../android/app/ActivityThread.java private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { ... //创建一个Activity 会调用到onCreate()方法 从而完成DecroView的创建 Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason); ... } ... } ``` 上述方法后续调用到了`handleResumeActivity()`,在这个方法中调用到了`WindowManager.addView()`将View传递至WindowManager ```java // ../android/app/ActivityThread.java final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) { ActivityClientRecord r = mActivities.get(token); if (!checkAndUpdateLifecycleSeq(seq, r, "resumeActivity")) { return; } unscheduleGcIdler(); mSomeActivitiesChanged = true; // 在这里会调用到生命周期中的onResume方法 r = performResumeActivity(token, clearHide, reason); ... if(r!=null){ ... final Activity a = r.activity; ... //获得当前Activty的Window对象 r.window = r.activity.getWindow(); //获得当前Window的DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); //获得当前Activity的WindowManager对象 ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; //将DecorView添加到PhoneWindow中 wm.addView(decor, l); } else { a.onWindowAttributesChanged(l); } } // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. } else if (!willBeVisible) { if (localLOGV) Slog.v( TAG, "Launch " + r + " mStartedActivity set"); r.hideForNow = true; } } ... } ``` 后续调用到了`wm.addView()`。将对应的DecorView传递进去。 ```java // ../android/view/WindowManagerImpl.java public final class WindowManagerImpl implements WindowManager { private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Window mParentWindow; ... @Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); //调用到了WindowManagerGlobal中的addView mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); } ... } // ../android/view/WindowManagerGlobal.java public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) { ... //创建了ViewRootImpl实例 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try { //调用setView 将传进来的DecorView添加到PhoneWindow中。 root.setView(view, wparams, panelParentView); } catch (RuntimeException e) { // BadTokenException or InvalidDisplayException, clean up. if (index >= 0) { removeViewLocked(index, true); } throw e; } } } ``` 上述流程走完后，就把DecorView加载到了Window中。**这个流程中将ViewRootImpl对象与DecorView进行了关联**。 ## View绘制流程 上节中，调用了`ViewRootImpl.setView(decorView)`将DecorView与ViewRootImpl进行了关联。View的绘制流程就是从ViewRoot开始的。 ```java public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { synchronized(this){ //传进来的DecorView作为全局变量使用 mView = view; ... // Schedule the first layout -before- adding to the window // manager, to make sure we do the relayout before receiving // any other events from the system. //绘制整个布局 requestLayout(); ... } } //请求刷新整个布局 @Override public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { checkThread(); mLayoutRequested = true; scheduleTraversals(); } } void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; //添加同步屏障 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); } } final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); } } final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); void doTraversal() { if (mTraversalScheduled) { mTraversalScheduled = false; //移除同步屏障 mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) { Debug.startMethodTracing("ViewAncestor"); } //这里开始View的绘制流程 performTraversals(); if (mProfile) { Debug.stopMethodTracing(); mProfile = false; } } } ``` `ViewRootImpl.setView()`中最后调用到了`performTraversals()`在这个方法中开始View的绘制流程 ```java private void performTraversals() { ... boolean layoutRequested = mLayoutRequested && (!mStopped || mReportNextDraw); ... if (!mStopped || mReportNextDraw) { int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ... if(layoutRequested){ //开始Measure过程，定义View的宽高 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ... } } final boolean didLayout = layoutRequested && (!mStopped || mReportNextDraw); if(didLayout){ //开始Layout过程，决定View的位置 performLayout(lp, mWidth, mHeight); ... } if (!cancelDraw && !newSurface) { if (mPendingTransitions != null && mPendingTransitions.size() > 0) { for (int i = 0; i < mPendingTransitions.size(); ++i) { mPendingTransitions.get(i).startChangingAnimations(); } mPendingTransitions.clear(); } //开始Draw过程，决定了View的显示，这个过程结束才可以看到内容 performDraw(); } } ``` 通过以上流程分析：**View的绘制流程是从`ViewRootImpl`中开始的，先调用`performTraversals()`开始绘制，随后调用内部的`performMeasure()`开始Measure过程，调用`performLayout()`，开始Layout过程，最后调用`performDraw()`开始Draw，完成后就可以现在在屏幕上。** {% fullimage /images/View绘制流程.png,View绘制流程,View绘制流程 %} 如上图所示，`performTraversals()`依次调用`performMeasure()，performLayout(),performDraw()`完成View的绘制。 ## MeasureSpec ### 结构 > MeasureSpec代表一个32位int值，高2位代表SpecMode(测量模式)，低30位代表SpecSize(某种测量模式下的规格大小)。 作用：父控件提供给子View的一个参数，作为设定自身大小参考，实际大小还是有子View自身决定。 ```java public static class MeasureSpec { private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 < MODE_SHIFT; /** @hide */ @IntDef({UNSPECIFIED, EXACTLY, AT_MOST}) @Retention(RetentionPolicy.SOURCE) public @interface MeasureSpecMode {} public static final int UNSPECIFIED = 0 < MODE_SHIFT; public static final int EXACTLY = 1 < MODE_SHIFT; public static final int AT_MOST = 2 < MODE_SHIFT; public static int makeMeasureSpec(@IntRange(from = 0, to = (1 < MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) { if (sUseBrokenMakeMeasureSpec) { return size + mode; } else { return (size & ~MODE_MASK) | (mode & MODE_MASK); } public static int makeSafeMeasureSpec(int size, int mode) { if (sUseZeroUnspecifiedMeasureSpec && mode == UNSPECIFIED) { return 0; } return makeMeasureSpec(size, mode); } @MeasureSpecMode public static int getMode(int measureSpec) { //noinspection ResourceType return (measureSpec & MODE_MASK); } public static int getSize(int measureSpec) { return (measureSpec & ~MODE_MASK); } ``` `MeasureSpec`涉及到了很多的位运算，会新开一篇文章介绍。{% post_link 位运算 %} `SpecMode`分为三类： - UNSPECIFIED：未指定模式。父控件不对子控件家人和我束缚，子元素可以为任意大小，一般用于系统内部的测量。比如ScrollView - EXACTLY：精确模式。父控件为子View指定精确大小，希望子View完全按照自己给的尺寸处理大小。一般是设置了明确的值或是`MATCH_PARENT` - AT_MOST：最大模式。父控件为子View指定最大尺寸，希望子View不要超过这个尺寸。一般对应`WRAP_CONTENT` ### MeasureSpec与LayoutParams的对应关系 每一个View，都持有一个MeasureSpec，里面保存了View的尺寸。我们也可以使用`LayoutParams`指定View的尺寸。所以在View测量的时候，系统会将`LayoutParams`在父容器的约束下转换成`MeasureSpec`，然后根据转换后的值确定宽高。 **转换后的MeasureSpec是由LayoutParams和父容器的MeasureSpec一起决定的。** #### DecorView转换MeasureSpec > DecorView的转换由Window的尺寸和自身的LayoutParams决定。 ```java // ../android/view/ViewRootImpl.java private void performTraversals() { ... //DecorView Measure过程 int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); performMeasure(childWidthMeasureSpec,childHeightMeasureSpec) ... } //在方法中生成了DecoeView的MeasureSpec 根据Window的尺寸和自身的LayoutParams private static int getRootMeasureSpec(int windowSize/*Window尺寸*/, int rootDimension) { int measureSpec; switch (rootDimension) { case ViewGroup.LayoutParams.MATCH_PARENT: //MeasureSpec中的specSize就是窗口尺寸,specMode为EXACTLY 精确模式 measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: //MeasureSpec中的specSize为窗口尺寸,specMode为aT_MOST 最大模式，最大值为窗口尺寸 measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: //MeasureSpec中的specSize为固定尺寸,specMode为EXACTLY 精确模式 measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; } return measureSpec; } ``` #### 普通View转换MeasureSpec > 普通View的MeasureSpec由父容器的MeasureSpec和自身的LayoutParams决定。 | 下：childLayoutParams 右：parentSpecMode | EXACTLY | AT_MOST | UNSPECIFIED | | ---------------------------------------- | ------------------------------------------ | ------------------------------------------ | --------------------- | | 固定大小 | Exactly **先Measure子View，再Measure自己** ViewGroup中没有定义`onMeasure()`，定义了一个`measureChildren()`。 ```java // ../android/view/ViewGroup.java protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i < size; ++i) { final View child = children[i]; if ((child.mViewFlags & VISIBILITY_MASK) != GONE) { //遍历对每一个子元素进行测量过程 measureChild(child, widthMeasureSpec, heightMeasureSpec); } } } ``` 循环调用`measureChild()` ```java // ../android/view/ViewGroup.java protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { //获得子View的LayoutParams final LayoutParams lp = child.getLayoutParams(); // final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } //子View的MEasureSpec由父View的MEasureSpec以及自身的LayoutParams共同决定 public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); //padding代指父View已占用的空间，子View无法使用，所以子View的空间需要减去padding部分 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension >= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension >= 0) { // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension >= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } ``` 由于ViewGroup有不同布局的需要，很难统一，所以没有提供统一的`onMeasure()`方法，而是让子类自己去实现`onMeasure()`。 {% fullimage /images/ViewGroup-Measure.png,ViewGroup测量过程,ViewGroup测量过程%} 根据上述流程图，简单总结一下： - ViewGroup调用自身的`measureChildren()`，里面遍历自己的子View - 遍历后调用`measureChild()`，准备给每一个子View计算它的`MeasureSpec` - 调用`getChildMeasureSpec()`计算子View的`MeasureSpec`，需要结合父布局的`MeasureSpec`以及子View的`LayoutParams`共同得出结果 - 调用子View的`measure()`，完成子View的测量过程。 - #### 拓展 1. 在Activity启动时获取View的尺寸？ - 在 Activity#onWindowFocusChanged 回调中获取宽高。`当Activity得到焦点或失去焦点的时候，这个方法都会被频繁调用` - view.post(runnable)，在 runnable 中获取宽高。 `利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。` - ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。 `监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露` - 调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高`手动对view进行measure来得到View的尺寸。` ### layout >ViewGroup用来确定子元素的位置，当ViewGroup位置被确定后，在`onLayout()`中遍历所有子View，并调用其`layout()`。 > >**先layout自身后layout子元素。** #### View的layout过程 主要是由View的`layout()`方法实现 ```java // ../android/view/View.java public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 & PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } //左上角顶点距父容器左边的距离 int oldL = mLeft; //左上角顶点距父容器上边的距离 int oldT = mTop; //右下角顶点距父容器上边的距离 int oldB = mBottom; //右下角顶点距父容器上边的距离 int oldR = mRight; // boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); ... } ... } //由于子View下是没有子类了，所以该方法内不没有任何代码实现 一般自定义View是不需要重写该方法的 protected void onLayout(boolean changed, int left, int top, int right, int bottom) { } private boolean setOpticalFrame(int left, int top, int right, int bottom) { Insets parentInsets = mParent instanceof View ? ((View) mParent).getOpticalInsets() : Insets.NONE; Insets childInsets = getOpticalInsets(); //根据特效边框重新计算四个顶点的位置，然后调用setFrame重新计算 return setFrame( left + parentInsets.left - childInsets.left, top + parentInsets.top - childInsets.top, right + parentInsets.left + childInsets.right, bottom + parentInsets.top + childInsets.bottom); } protected boolean setFrame(int left, int top, int right, int bottom) { boolean changed = false; if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) { changed = true; // Remember our drawn bit int drawn = mPrivateFlags & PFLAG_DRAWN; int oldWidth = mRight - mLeft; int oldHeight = mBottom - mTop; int newWidth = right - left; int newHeight = bottom - top; boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight); // Invalidate our old position invalidate(sizeChanged); //重新计算View的四个顶点距父布局左上边框的距离 mLeft = left; mTop = top; mRight = right; mBottom = bottom; mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom); ... } } //判断当前View是否存在阴影或者外发光等边框效果 public static boolean isLayoutModeOptical(Object o) { return o instanceof ViewGroup && ((ViewGroup) o).isLayoutModeOptical(); } ``` {% fullimage /images/View-Layout.png,View的Layout过程,View的Layout过程%} 按照流程图总结一下： - View调用`layout()`开始布局过程(`确定最终宽高以及四个顶点的位置`) - 根据是否有边缘效果(`例如发光，阴影`) - 有边缘效果，调用`setOpticalFrame()`去除边缘的影响，最终还是调用`setFrame()`设立自己的四个顶点 - 无边缘效果，调用`setFrame()`设立自己的四个顶点 - 最后调用`onLayout()`最终确立宽高以及四点坐标。 #### ViewGroup的layout过程 当有子View存在的时候，需要遍历子View进行`layout`过程。即需要在`onLayout()`方法实现子View的`layout`。 ```java //源码与上述相同 由于ViewGroup中所有子View的layout都需要实现，所以需要实现 onLayout() 方法 protected void onLayout(boolean changed,int left,int top,int right,int bottom){ for (int i =0 ; i 两者的比较 | 类型 | 何时赋值 | 赋值方法 | 使用场景 | | :-------------------------------------------------------- | ------------------- | ----------------------------------------- | ------------------------------- | | View测量结束宽/高getMeasureWidth()/getMeasureHeight() | View的`measure`过程 | `setMeasureDimension()` | 在`onLayout()`获取View的宽/高 | | View最终宽/高getWidth()/getHeight() | View的`layout`过程 | `layout()`对top,left,right,bottom进行操作 | `onLayout()`结束后获取最终宽/高 | **一般情况下，二者返回的数据是相同的，除非人为对View的`layout()`进行重写。** ```java public void layout(int l,int t,int r,int b){ super.layout(j,t,r+100,b+100); } ``` 上述代码就会导致View最终结果与测量时不同。 ### draw > draw作用主要将View绘制在屏幕上面 > > **draw过程，先draw自身再draw子View** #### View的draw过程 View的draw过程，从`View.draw()`开始 ```java // ../android/view/View.java public void draw(Canvas canvas) { //标记当前View是否需要绘制背景 final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); int saveCount; //1. 绘制背景 if (!dirtyOpaque) { drawBackground(canvas); } final int viewFlags = mViewFlags; //是否有水平边缘 boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0; //是否有竖直边缘 boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0; if(!horizontalEdges && !verticalEdges){ // 3.绘制View本身 if (!dirtyOpaque) onDraw(canvas); // 4.绘制子View dispatchDraw(canvas); // 6.绘制装饰 例如滚动条 onDrawForeground(canvas); ... return; } //如果有竖直边缘或者水平边缘 例如divide // 2. 保存当前Canvas层 saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) { final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) { canvas.saveLayer(left, top, right, top + length, null, flags); } if (drawBottom) { canvas.saveLayer(left, bottom - length, right, bottom, null, flags); } if (drawLeft) { canvas.saveLayer(left, top, left + length, bottom, null, flags); } if (drawRight) { canvas.saveLayer(right - length, top, right, bottom, null, flags); } } else { scrollabilityCache.setFadeColor(solidColor); } ... // 3.绘制View本身 if (!dirtyOpaque) onDraw(canvas); // 4.绘制子View dispatchDraw(canvas); ... // 5.绘制边缘效果 例如阴影 canvas.restoreToCount(saveCount); ... // 6.绘制装饰 例如滚动条 onDrawForeground(canvas); ... } //绘制View本身的背景 private void drawBackground(Canvas canvas) { final Drawable background = mBackground; if (background == null) { return; } //设置View的背景边界 setBackgroundBounds(); ... final int scrollX = mScrollX; final int scrollY = mScrollY; if ((scrollX | scrollY) == 0) { background.draw(canvas); } else { //将画布偏移 然后在偏移后的画布上进行背景绘制 canvas.translate(scrollX, scrollY); background.draw(canvas); canvas.translate(-scrollX, -scrollY); } } //绘制View本身的内容 protected void onDraw(Canvas canvas) { // 默认空实现 需要子类复写该方法以实现内容的绘制 ，自定义View中必须执行该方法 } //绘制子View的内容 protected void dispatchDraw(Canvas canvas) { //由于View不存在子View，所以不需要实现 } //绘制装饰 例如滚动条 前景图片 public void onDrawForeground(Canvas canvas) { onDrawScrollIndicators(canvas); onDrawScrollBars(canvas); final Drawable foreground = mForegroundInfo != null ? mForegroundInfo.mDrawable : null; if (foreground != null) { if (mForegroundInfo.mBoundsChanged) { mForegroundInfo.mBoundsChanged = false; final Rect selfBounds = mForegroundInfo.mSelfBounds; final Rect overlayBounds = mForegroundInfo.mOverlayBounds; if (mForegroundInfo.mInsidePadding) { selfBounds.set(0, 0, getWidth(), getHeight()); } else { selfBounds.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom()); } final int ld = getLayoutDirection(); Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(), foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld); foreground.setBounds(overlayBounds); } foreground.draw(canvas); } } ``` {% fullimage /images/View-Draw.png,View的Draw流程,View的Draw流程%} 结合上述流程图分析Draw过程： - 先调用`View.draw()`方法开始Draw流程 - 如果需要`dirtyOpaque`，就绘制背景`drawBackground()` - 如果需要显示边缘效果，就进行保存画布`canvas.saveLayer()` - 如果需要`dirtyOpaque`，绘制自身的内容`onDraw()` -- **自定义View必须实现** - 调用`dispatchDraw()`绘制子View - 如果需要显示边缘效果，绘制后，还原画布`canvas.restore()` - 调用`drawForeground()`绘制装饰，例如滚动条或前景 #### ViewGroup的draw过程 ViewGroup的draw过程主要调整了上述源码中的`dispatchDraw()`，在其内部进行了子View的遍历以及绘制过程 ```java // ../android/view/ViewGroup.java protected void dispatchDraw(Canvas canvas) { boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode); final int childrenCount = mChildrenCount; final View[] children = mChildren; ... for (int i = 0; i < childrenCount; i++) { while (transientIndex >= 0 && mTransientIndices.get(transientIndex) == i) { final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) { more |= drawChild(canvas, transientChild, drawingTime); } transientIndex++; if (transientIndex >= transientCount) { transientIndex = -1; } } final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) { more |= drawChild(canvas, child, drawingTime); } } ... } //绘制子View protected boolean drawChild(Canvas canvas, View child, long drawingTime) { //调用子View的draw方法 return child.draw(canvas, this, drawingTime); } ``` {% fullimage /images/ViewGroup-Draw.png,ViewGroup的Draw流程,ViewGroup的Draw流程%} 结合上述流程图分析ViewGroup的Draw过程： - draw过程与上述`View的draw过程一致` - `dispatchDraw()`默认实现，内部包含了子View的遍历以及绘制 拓展： 1. `View.setWillNotDraw()`有什么意义? ```java public void setWillNotDraw(boolean willNotDraw) { //设置 不需绘制 标记位 setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK); } ``` 如果一个View不需要绘制任何内容，设置这个标记为`true`，系统就会进行相应优化。 ***View默认不开启`willNotDraw`标记位，ViewGroup默认开启。*** ## 自定义View > 自定义View需要了解View的层次、View的事件分发机制以及View的工作流程。 ### 分类 #### 1.继承View重写`onDraw()` > 主要用于实现一些不规则的效果，不方便通过布局的组合方法可以直接实现，往往需要静态或者动态的显示一些不规则图形(圆形啥的)。 > > 特殊形状的这种就需要重写`onDraw()`实现。**一般需要额外支持wrtap_content，并且也需要处理padding方法。** #### 2.继承ViewGroup派生特殊的Layout > 主要用于实现自定义的布局，除了常用的一些布局外。实现的是几种View的组合形式 > > **实现稍微复杂，需要合适的处理ViewGroup的`onMeasure()，onLayout()`以及子View的`onMeasure()，onLayout()`** #### 3.继承特定的View(例如TextView) > 这种比较常见，一般用于拓展已有View的功能。 > > **实现比较简单，无需自己处理wrap_content以及padding** #### 4.继承特定的ViewGroup(例如LinearLayout) > 比较常见，当某种效果看起来很像几种View组合在一起的时候 > > **实现比较简单，无需自己处理测量以及布局过程** ### 注意事项 #### 1.让View支持wrap_content > 直接继承View或ViewGroup的控件，不重写`onMeasure()`并对`AT_MOST`进行处理，就无法达到需要的显示效果。 #### 2.需要的话，让View支持padding > 直接继承View的控件，需要在`draw`过程处理padding属性，不然padding属性无法起作用。 > > 直接继承ViewGroup的控件，需要在`onMeasure()，onLayout()`处理自身的padding以及子View的margin #### 3.尽量不要在View中使用Handler > View内部提供了`post`方法，可以替代Handler使用 #### 4.View中如果有线程或动画，需要及时停止 > 1. 不处理有可能造成内存泄漏，View不可见时也需要停止线程和动画 > 2. 包含View的Activity启动时，View的`onAccachedToWindow()`会调用 > 3. 包含View的Activity退出或当前View被移除时，调用`View.onDetachedFromWindow()`时关闭线程和动画 #### 5.View若有滑动冲突情况，需要处理 ### 实例 {% post_link 自定义View实践%} {% post_link 自定义ViewGroup实践%} ## 拓展 ### Invalidate、postInvalidate、requestLayout源码及应用场景 #### invalidate > `invalidate()`必须在主线程调用，用于请求View的重绘，意味着只影响View的`draw`过程。 ```java // ../android/view/View.java public void invalidate() { invalidate(true); } public void invalidate(boolean invalidateCache) { invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true); } void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) { //View不可见或者在移动中 不进行重绘 if (skipInvalidate()) { return; } if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate && isOpaque() != mLastIsOpaque)) { //需要全部重绘 if (fullInvalidate) { mLastIsOpaque = isOpaque(); //修改绘制完成标记 mPrivateFlags &= ~PFLAG_DRAWN; } //修改正在绘制标记 mPrivateFlags |= PFLAG_DIRTY; //清除缓存 if (invalidateCache) { mPrivateFlags |= PFLAG_INVALIDATED; mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID; } // Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null && ai != null && l < r && t < b) { final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); //设置重绘区域 并把自身传递到父布局 p.invalidateChild(this, damage); } // Damage the entire projection receiver, if necessary. if (mBackground != null && mBackground.isProjected()) { final View receiver = getProjectionReceiver(); if (receiver != null) { receiver.damageInParent(); } } } } ``` 上述代码修改标记完成后，调用父类的`invalidateChild()`将需要重绘的区域(`脏区域`)传入。(`ViewGroup以及ViewRootImpl都继承自ViewParent类`) > 脏区域：*为了保证绘制的效率，控件树仅对需要绘制的区域进行重绘，需要重绘的区域成为`脏区域`*。 ```java //../android/view/VireGroup.java public final void invalidateChild(View child, final Rect dirty) { final AttachInfo attachInfo = mAttachInfo; //需要在开启硬件加速的情况下 会调用新的重绘方案 if (attachInfo != null && attachInfo.mHardwareAccelerated) { // HW accelerated fast path onDescendantInvalidated(child, child); return; } ViewParent parent = this; if (attachInfo != null) { ... //开始遍历循环 从当前View不断向上调用父布局的绘制方法 do { View view = null; // 当前父布局还为ViewGroup if (parent instanceof View) { view = (View) parent; }else { // 当前父布局到了ViewRootImpl } if (drawAnimation) { if (view != null) { view.mPrivateFlags |= PFLAG_DRAW_ANIMATION; } else if (parent instanceof ViewRootImpl) { ((ViewRootImpl) parent).mIsAnimating = true; } } // If the parent is dirty opaque or not dirty, mark it dirty with the opaque // flag coming from the child that initiated the invalidate // 父布局为实心 就需要设置 privateFlag标记 if (view != null) { if ((view.mViewFlags & FADING_EDGE_MASK) != 0 && view.getSolidColor() == 0) { opaqueFlag = PFLAG_DIRTY; } if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) { view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag; } } //递归调用父布局的重绘方法 parent = parent.invalidateChildInParent(location, dirty); if (view != null) { // Account for transform on current parent Matrix m = view.getMatrix(); if (!m.isIdentity()) { RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); m.mapRect(boundingRect); //将子View的脏区域 转换 父布局中的一块区域 dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom)); } } } while (parent != null); } } //将子视图坐标位置转化为当前视图的显示位置 public ViewParent invalidateChildInParent(final int[] location, final Rect dirty) { if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != 0) { // either DRAWN, or DRAWING_CACHE_VALID //ViewGroup中没有动画在执行 或者 已完成 if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) { dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY); if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) { dirty.union(0, 0, mRight - mLeft, mBottom - mTop); } final int left = mLeft; final int top = mTop; if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) { if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) { dirty.setEmpty(); } } location[CHILD_LEFT_INDEX] = left; location[CHILD_TOP_INDEX] = top; } else { if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) { dirty.set(0, 0, mRight - mLeft, mBottom - mTop); } else { // in case the dirty rect extends outside the bounds of this container dirty.union(0, 0, mRight - mLeft, mBottom - mTop); } location[CHILD_LEFT_INDEX] = mLeft; location[CHILD_TOP_INDEX] = mTop; mPrivateFlags &= ~PFLAG_DRAWN; } mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID; if (mLayerType != LAYER_TYPE_NONE) { mPrivateFlags |= PFLAG_INVALIDATED; } return mParent; } return null; } ``` 当`parent`不为View时，说明已经到达了最顶层即`ViewRootImpl` > 为什么最顶层会是`ViewRootImpl`? > > ```java > 在ViewRoot与DecorView关联时讲到最后 WindowManagerGlobal 调用了 ViewRootImpl.setView() 传递进去DecorView > public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { > //设置当前ViewRootImpl为DecorView的parent > view.assignParent(this); > } > //给当前View设置父布局 > void assignParent(ViewParent parent) { > if (mParent == null) { > mParent = parent; > } else if (parent == null) { > mParent = null; > } else { > throw new RuntimeException("view " + this + " being added, but" > + " it already has a parent"); > } > } > ``` > > 不断向上回溯的过程中，最终走到DecorView `getParent()`就为ViewRootImpl 走到最后调用到了ViewRootImpl的`invalidateChild`方法，内部实现为`invalidateChildInParent()` ```java // ../android/view/ViewRootImpl.java public void invalidateChild(View child, Rect dirty) { invalidateChildInParent(null, dirty); } public ViewParent invalidateChildInParent(int[] location, Rect dirty) { //判断当前线程是否与View线程相同 checkThread(); if (DEBUG_DRAW) Log.v(mTag, "Invalidate child: " + dirty); if (dirty == null) { //整个窗口重绘 invalidate(); return null; } else if (dirty.isEmpty() && !mIsAnimating) { //需要重绘区域为空 就不管了 return null; } //设置 重绘区域偏移 if (mCurScrollY != 0 || mTranslator != null) { mTempRect.set(dirty); dirty = mTempRect; if (mCurScrollY != 0) { dirty.offset(0, -mCurScrollY); } if (mTranslator != null) { mTranslator.translateRectInAppWindowToScreen(dirty); } if (mAttachInfo.mScalingRequired) { dirty.inset(-1, -1); } } invalidateRectOnScreen(dirty); return null; } //在屏幕上找到对应的重绘区域进行重绘 private void invalidateRectOnScreen(Rect dirty) { final Rect localDirty = mDirty; if (!localDirty.isEmpty() && !localDirty.contains(dirty)) { mAttachInfo.mSetIgnoreDirtyState = true; mAttachInfo.mIgnoreDirtyState = true; } // Add the new dirty rect to the current one localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom); // Intersect with the bounds of the window to skip // updates that lie outside of the visible region final float appScale = mAttachInfo.mApplicationScale; final boolean intersected = localDirty.intersect(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); if (!intersected) { localDirty.setEmpty(); } if (!mWillDrawSoon && (intersected || mIsAnimating)) { //真正执行绘制的地方 scheduleTraversals(); } } ``` 最终调用到了`scheduleTraversals()`，在上面讲到`View的绘制流程`时，有提到最初就是从`performTraversals()`开始，这里的`scheduleTraversals()`就是去触发一次`performTraversals()`开始一次绘制流程。 > 由于`scheduleTraversals`是在主线程执行的，所以调用`invalidate()`时由于请求还未处理该消息，当多次调用重绘请求时，重绘也不会发生多次，提升效率。 > > 调用到`performTraversals()`按道理会重新走一遍绘制流程即`measure->layout->draw`，由于重绘时，设置`layoutRequested为false`就不会重新触发`measure及layout`流程。 {% fullimage /images/View-Invalidate.png,View的重绘流程,View的重绘流程%} 根据上述流程图，简单总结： - View调用`invalidate()`时，会调用父布局的`invalidateChild()`并传入自身View以及需要重绘区域 - ViewGroup接收到传参时，会开启循环(`条件为直到没有父布局为止`)，调用自身的`invalidateChildInParent()-主要功能为将子布局区域转换成当前布局的区域`向父布局层层传递 - 当父布局不为ViewGroup时，意味着已经到了最顶层的DecorView(`因为它的parent为ViewRootImpl`)，所以最终会执行到`ViewRootImpl.invalidateChild()` - ViewRootImpl执行`invalidateChild()`最终调用到的就是`performTraversals()`进行View的绘制流程(`draw`)，由于设置了`mLayoutRequested`限制了`measure,layout`的执行，所以只会发生`draw` #### postInvalidate > `postInvalidate`就是可以在子线程重绘View。实际的实现还是调用`invalidate()` ```java // ../android/view/View.java public void postInvalidate() { postInvalidateDelayed(0); } public void postInvalidate(int left, int top, int right, int bottom) { postInvalidateDelayed(0, left, top, right, bottom); } public void postInvalidateDelayed(long delayMilliseconds, int left, int top, int right, int bottom) { // We try only with the AttachInfo because there's no point in invalidating // if we are not attached to our window final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) { final AttachInfo.InvalidateInfo info = AttachInfo.InvalidateInfo.obtain(); info.target = this; info.left = left; info.top = top; info.right = right; info.bottom = bottom; attachInfo.mViewRootImpl.dispatchInvalidateRectDelayed(info, delayMilliseconds); } } // ../android/view/ViewRootImpl.java public void dispatchInvalidateDelayed(View view, long delayMilliseconds) { Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view); mHandler.sendMessageDelayed(msg, delayMilliseconds); } final ViewRootHandler mHandler = new ViewRootHandler(); final class ViewRootHandler extends Handler { .. @Override public void handleMessage(Message msg) { switch (msg.what) { case MSG_INVALIDATE: //最终调用到了 invalidate ((View) msg.obj).invalidate(); break; ... } } ... } ``` #### requestLayout > 强制重新布局，重新走一遍View的绘制流程。 ```java // ../android/view/View.java public void requestLayout() { if (mMeasureCache != null) mMeasureCache.clear(); if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == null) { // Only trigger request-during-layout logic if this is the view requesting it, // not the views in its parent hierarchy ViewRootImpl viewRoot = getViewRootImpl(); if (viewRoot != null && viewRoot.isInLayout()) { if (!viewRoot.requestLayoutDuringLayout(this)) { return; } } mAttachInfo.mViewRequestingLayout = this; } //设置强制刷新标记 mPrivateFlags |= PFLAG_FORCE_LAYOUT; mPrivateFlags |= PFLAG_INVALIDATED; if (mParent != null && !mParent.isLayoutRequested()) { //向父布局继续请求刷新布局 mParent.requestLayout(); } if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == this) { mAttachInfo.mViewRequestingLayout = null; } } ``` 不断向父布局请求重新布局，逐层传递直到ViewRootImpl层。 ```java @Override public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { checkThread(); //设置标记 重新布局 mLayoutRequested = true; scheduleTraversals(); } } ``` 上文中提到`mLayoutRequested`就是防止`invalidate`重新走一遍绘制流程，这里设置为`true`，意味着需要走一遍`measure,layout`。 由于`measure`过程设置了`mPrivateTags PFLAG_LAYOUT_REQUIRED`所以会往下继续执行`layout`过程。 > `requestLayout`是否会触发`draw`过程？ > > 按照流程来说`layout`之后就是`draw`，所以可以从`layout`过程中查看相关代码 > > ```java > 在上文中说到 View的layout过程 会调用到 layout 后续是 setFrame 确定顶点，最后onLayout执行 > protected boolean setFrame(int left, int top, int right, int bottom) { > //意味着 如果布局的坐标发生了改变 就需要重新绘制 > if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) { > changed = true; > > // Remember our drawn bit > int drawn = mPrivateFlags & PFLAG_DRAWN; > > int oldWidth = mRight - mLeft; > int oldHeight = mBottom - mTop; > int newWidth = right - left; > int newHeight = bottom - top; > boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight); > > // Invalidate our old position > invalidate(sizeChanged); > ... > } > ... > } > ``` > > 综上所述，如果layout的布局有变化还是会触发`draw`过程的 ### include、merge、ViewStub作用以及实现 {% post_link include、merge-ViewStub相关%} ### View的层级计算 由于View是树形结构，代码的话可以利用`getParent()`实现 ，直到返回值为null，说明已经到了最高层。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java--反射]]></title>
    <url>%2F2018%2F12%2F14%2FJava-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[--- title: Java--反射 date: 2018-12-14 16:41:02 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[LruCache原理]]></title>
    <url>%2F2018%2F12%2F14%2FLRUCache%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[--- title: LruCache原理 date: 2018-12-14 16:40:15 tags: 源码分析 --- # LruCache > 一般来说，缓存的策略主要包含缓存的`添加、获取和删除`。但由于缓存的大小都是有上限的。缓存慢了之后，要想继续添加 ，就需要删除一些旧的缓存以提供空间。 > > 所以使用到了`LruCache`缓存算法，即**最近最少使用**算法，当缓存满时，会优先淘汰掉 最近最少使用的缓存对象。 **LruCache的核心原理就是利用了LinkedHashMap**。 > LruCache的使用 ```java int maxMemory = (int)(Runtime.getRuntime().totalMemory()/1024); //设置LruCache缓存的大小 int cacheSize = maxMemory/8; LruCache memoryCache = new LruCache(cacheSize){ @Override protected int sizeOf(@NonNull String key, @NonNull Bitmap value) { //重写sizeof方法，计算需要缓存的图片大小 return value.getRowBytes() * value.getHeight() / 1024; } }; ``` > LruCache的实现原理 `LruCache内部需要维护好一个缓存对象列表，其中对象的排列方式应该按照访问顺序排列的，即一直没访问的对象，要放在队尾，最近访问的对象就会放在对头，最晚被淘汰。` 查看源码中发现内部是利用了`LinkedHashMap`去缓存对象的。 ```java //LruCache构造方法 private final LinkedHashMap map; public LruCache(int maxSize) { if (maxSize]]></content>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--基本原则]]></title>
    <url>%2F2018%2F12%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[--- title: 设计模式--基本原则 date: 2018-12-14 10:01:55 tags: 设计模式 top: 10 --- # 设计模式六大基本原则 ## 单一职责原则（SRP） > 单一职责原则英文名称为`Single Responsibility Principle`,简称SRP。 优点： - 类的复杂性降低，实现什么职责都有清晰明确的定义 - 可读性提高，复杂性降低 - 可维护性高 对于开发过程来说，**接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化**。 ## 里氏替换原则（LSP） > 所有引用父类的地方都必须能透明的使用其子类的对象。简单的说就是 **父类能出现的地方子类就可以出现。** 里氏替换原则为良好的继承定义了一个规范，主要包含了4个含义： - **子类必须完全实现父类的方法**：`如果子类不能完整的实现父类的方法，或者父类方法在子类中已无法实现，建议断开父子继承关系，采用依赖、聚集，组合等方法代替继承。` - **子类可以有自己的个性**：`里氏替换原则可以正着用，但不能反过来用。子类出现的地方，父类未必可以使用。` - **覆盖或实现父类的方法时输入参数可以被放大**：`子类中的方法前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松。` - **覆写或实现父类的方法时输出结果可以被缩小** 在开发过程中尽量避免子类的”个性“，有了之后，与父类的关系就难调和。 ## 依赖倒置原则（DIP） > - 高层模块不应该依赖低层模块，两者都应该依赖其抽象 > - 抽象不应该依赖细节 > - 细节应该依赖于抽象 > > **面向接口编程** 本质就是通过抽象（接口或者抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的送耦合。 ## 接口隔离原则（ISP） > 接口分为两种：实例接口 和 类接口 > > 接口尽量细化，同时接口中的方法要尽量少。尽量使用多个专门的接口。 接口隔离原则是对接口进行规范约束，包含以下4层含义： - 接口要尽量小 **不能违反单一职责原则** - 接口要高内聚：`高内聚就是提高接口、类，模块的处理能力，减少对外的交互` - 定制服务：**只提供访问者需要的方法，减少可能引起的风险** - 接口设计是有限度的：`接口的设计粒度越小，系统越灵活，但是会增加结构复杂度以及开发难度` 在开发过程中可以按照如下规则设计： - 一个接口只服务于一个子模块或业务逻辑 - 通过业务逻辑压缩接口中的public方法 - 已经被污染的接口尽量去修改 - 根据每个项目或产品去制定拆分标准 ## 迪米特法则（LoD）--最少知识原则(LKP) > 一个对象应该对其他对象有最少的了解 迪米特法则对类的低耦合提出了明确的要求，包含以下4个含义： - 只和朋友交流：**在类的一个方法中尽量不引入一个类中不存在的对象** - 朋友间也是有距离的：**尽量不对外公布太多的public方法和非静态的public变量，尽量内敛** - 是自己的就是自己的：**如果一个方法放在本类中，既不增加类间关系，也不会对本类产生负面影响，就可以放置在本类中** - 谨慎使用Serializable：**在进行传输对象时需要进行序列化，当修改了属性时，会导致反序列化失败** 迪米特法则核心观念就是**类间解耦，弱耦合**。 ## 开闭原则（OCP）—最基础的原则 > 软件实体应该对扩展开放，对修改关闭。`一个软件实体应该通过扩展来实现变化，而不是去修改已有代码。` **开闭原则并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合** 开闭原则的重要性： - 减少测试工作量 - 提高复用性 - 提高可维护性 - 面向对象开发]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--单例模式]]></title>
    <url>%2F2018%2F12%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[--- title: 设计模式--单例模式 date: 2018-12-13 17:15:07 tags: 设计模式 top: 10 --- # 单例模式 > 一个类只能产生一个对象。确保某一个只有一个实例，而且自行实例化并向整个系统提供这个实例且构造函数私有化。 {% fullimage /images/Pattern-Singleton.png,单例模式,单例模式 %} ```java //单例模式通用代码 public class Singleton{ private static final Singleton singleton = new Singleton(); private Singleton(){ } public static Singleton getSingleton(){ return singleton; } public static void doSth(){ } } ``` ## 单例模式优点 1. 由于单例模式只存在一个实例，减少了内存开支 2. 减少了系统的开销 3. 避免对资源的多重占用 4. 在系统设置全局访问点，优化和共享资源访问 5. 允许可变数目的实例，基于单例模式可以进行拓展，可以获得指定个数的对象实例，既节省系统资源，又解决单例对象过多的性能损耗 ## 单例模式缺点 1. 单例模式一般没有接口，扩展很困难。 2. 单例模式对测试是不利的，因为单例模式没有完成时，是不能进行测试的。 3. 与单一职责原则有冲突 ## 单例模式使用场景 1. 要求生成唯一序列号的环境 2. 在整个项目中需要一个共享访问点或共享数据 3. 创建一个对象需要的消耗资源过多，如访问IO和数据库 4. 需要定义大量的静态常亮和静态方法 ## 单例模式的实现条件 1. `构造函数私有` 2. `有一个该类的静态私有对象` 3. `有一个静态的公用函数用于创建或获取本身静态私有对象` 4. **线程同步** ## 单例模式注意事项 1. 在高并发情况下，注意单例模式的线程同步问题 2. 考虑对象的复制情况 ## 单例模式实现实例 - 双重校验锁（DCL）--Java5之后可以安心使用该方法 ```java public class Singleton { private static volatile Singleton mInstance; private Singleton() { } public static Singleton getInstance() { if (mInstance == null) { synchronized (Singleton.class) { if (mInstance == null) { mInstance = new Singleton(); } } } return mInstance; } //反序列化提供的一个特殊方法，可以控制对象的反序列化 private Object readResolve(){ return mInstance;//返回实例对象 } } ``` > 在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则`mInstance = new Singleton(); `可能出现`mInstance `尚未被初始化的异常。 > > `mInstance = new Singleton(); `包括三步：`为对象分配内存`，`执行构造方法，初始化实例对象`，`把mInstance的引用指向分配的内存空间`。在JVM的执行过程中并不是原子性的。 - 静态内部类 ```java public class Singleton{ private static class SingletonHolder{ private static final Singleton INSTANCE = new Singleton(); } private Singleton(){ } public static Singleton getInstance(){ return SingletonHolder.INSTANCE; } } ``` > 为何可以保证线程安全？`虚拟机可以保证一个类的类构造器 `()`在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。**同一个类加载器下，一个类型只会被初始化一次。** - 枚举 ```java public enum Singleton { INSTANCE; } ``` > 防止反序列化重新创建新对象，在Android中不建议使用枚举，大概会增加4倍消耗。 ## 单例模式在Android中的体现 ```java //../android/view/inoputmethod/InputMethodManager.java public static InputMethodManager getInstance() { synchronized (InputMethodManager.class) { if (sInstance == null) { try { sInstance = new InputMethodManager(Looper.getMainLooper()); } catch (ServiceNotFoundException e) { throw new IllegalStateException(e); } } return sInstance; } } ```]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binder系列-ContentProvide]]></title>
    <url>%2F2018%2F12%2F13%2FBinder%E7%B3%BB%E5%88%97-ContentProvide%2F</url>
    <content type="text"><![CDATA[--- title: Binder系列-ContentProvide date: 2018-12-13 15:47:50 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[Binder系列-ServiceManager相关]]></title>
    <url>%2F2018%2F12%2F12%2FBinder%E7%B3%BB%E5%88%97-ServiceManager%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[--- title: Binder系列-ServiceManager相关 date: 2018-12-12 11:48:22 tags: Android top: 10 ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binder及AIDL]]></title>
    <url>%2F2018%2F12%2F11%2FBinder%E5%8F%8AAIDL%2F</url>
    <content type="text"><![CDATA[--- title: Binder及AIDL date: 2018-12-11 14:24:06 tags: Android top: 11 --- # 主要分析IPC机制，Binder框架以及AIDL原理 ## 1.IPC机制 > IPC是Inter-Process Communication的缩写。含义为进程间通信或者跨进程通信，指代两个进程间进行数据交换的过程、 还需要理解进程以及线程的区别和联系 > 进程：一般指一个执行单元，在设备上一般代指应用程序。 > > 线程：CPU调度的最小单元且线程是有限资源。 > > 一个进程可以包含多个线程，即一个应用内部可以执行多个任务。在Android中就会区分为`主线程(UI线程)`和`子线程`，一般会在子线程上做耗时操作，主线程不可。 由于IPC的使用场景是在多进程模式下。多进程的使用情况主要分为两种：`一个应用因为某些原因需要采用多进程模式来实现，比如获取更大内存空间`,`当前应用需要向其他应用来获取数据`。 ### 1. 多进程模式 1. 开启多进程模式 - 通过JNI在native层fork一个新的进程 - 在`AndroidManifest.xml`中给四大组件指定属性`android:process`。 2. 进程名的命名 ```xml ``` 上述代码为两种命名方案 - 省略包名以:开头：代指进程名为`com.wxy.test:remote`为**私有进程**，其他进程的组件不可以和他跑到同一个进程中 - 完整命名：如上述`com.wxy.test.remote`为**全局进程**，其他应用可以通过`ShareUID方式与他在同一进程中运行。` Android系统会为每一个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。 上述通过ShareUID将两个应用跑在同一个进程间是有要求的，**必须是两个应用具有相同的ShareUID且签名相同才可以**。达成上述要求时就可以 **共享两者间的data目录、组件信息以及内存数据**。 拓展知识：当两者签名不同时，会触发安装错误[INSTALL_FAILED_SHARED_USER_INCOMPATIBLE] 3. 查看进程信息 `adb shell ps|greb $packageName` 4. 运行机制 Android为每一个应用分配了一个独立的虚拟机，或者说为了每一个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上就会有不同的地址空间，就会导致不同的虚拟机访问同一个类的对象会产生多分副本。 **所有运行在不同进程的四大组件，只要他们通过内存共享数据，就会共享失败。** 5. 多进程造成的问题 - 静态成员变量和单例模式完全失效 - 线程同步机制失败 - SharedPreferences的可靠性下降 `不支持多进程读写` - Application会多次创建`分配了独立的虚拟机` 一个应用内的多进程：**相当于两个不同的应用采用了ShareUId模式**。虽说不能直接共享内存数据，但是可以通过跨进程通信来实现数据交互。 ### 2. 序列化 > 当我们需要跨进程通信时，传递的数据就需要进行序列化传递，然后接受方在反序列化得到传递数据 > 什么是序列化？ > > 将对象转化为可以传输的二进制流的过程，就可以通过序列化，转化为可以在网络传输或者保存到本地的流，从而进行传输数据。反序列化即为从二进制流转化为对象的过程。 > > > 也为了解决对象的持久化问题。当你在程序中声明一个类后，程序关闭则释放对象，持久化就是为了应用关闭后类的内容依然存在。 1. `Serializable` > 由Java提供的一个序列化接口，为对象提供标准的序列化以及反序列化操作。 使用方式相当简单 ```java public class User implements Serializable{ //该参数是用来辅助序列化以及反序列化的过程，原则上该值相同才可以进行序列化以及反序列化的操作. //不指定时 系统也会自动生成 但是容易因为变量的数量和类型发生改变而导致序列化失败。 private static final long serialVersionUID = 123123L; public String name; ... } ``` 优缺点：使用简单但是效率较低，在序列化(ObjectOutputStream)以及反序列化(ObjectInputStream)类调用中会有大量的I/O操作。 适用场景：将对象类序列化存储到设备或者需要网络传输。 2. `Parcelable` > Android提供的序列化接口，使用起来较为繁琐 ```java import android.os.Parcel; import android.os.Parcelable; public class User implements Parcelable { public String name; protected User(Parcel in) { name = in.readString(); } public static final Creator CREATOR = new Creator() { @Override public User createFromParcel(Parcel in) { return new User(in); } @Override public User[] newArray(int size) { return new User[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); } } ``` 序列化功能由`writeToParcel`实现，反序列化由`Parcel的read`实现。 优缺点：传递效率高效使用较为繁琐，主要序列化都在内存上进行。由于Parcelabel是Android提供的方法，可能会由于版本更新而会有些许改动。 适用场景：在内存的序列化中使用。 ### 3. IPC方式 > 本节主要讲述各种跨进程通信方式，目前有以下六种： > > {% fullimage /images/IPC-mode.png,IPC方式, IPC方式 %} > > 上述方式实际都是通过Binder来实现的 #### 1.Bundle > 支持在`Activity、Service和Receiver`之间通过Intent来传递Bundle数据(调用`intent.putExtra()`)，由于Bundle实现了Parcelable接口，所以可以方便的在不同进程间传递(`传输的数据必须可以被序列化，不然无法进行传递`)。可以看做为一个特殊的Map类型。 > > **最简单的进程间通信方式。** 拓展：当A进程计算后的结果无法通过Bundle传递至B进程时，可以将计算的过程用B进程的一个Service进行操作，然后在回调给B进程。 #### 2.文件共享 > **两个进程间通过读/写一个文件来进行数据传递**，适用于对数据同步要求不高的进程间通信，并且需要对**并发读/写**进行妥善处理 拓展：Android中的SharedPreferences也是文件共享方案的一种，但由于系统提供了一种缓存策略(内存中会有一份该文件的缓存)，导致它在多进程模式下，读/写并不可靠，甚至丢失数据。 #### 3.Messenger > 轻量级的IPC方案，可以在不同的进程间传递Message对象。调用`Messenger.send(Message message)`传递Message对象。 > > Messager的底层实现是`AIDL`。它对AIDL做了封装，由于它一次只可以处理一个请求**（串行请求）**，因此不需考虑线程同步的问题。不过不能直接调用服务端的方法，只能通过传递消息处理。 > > 由于主要传递的都是Message对象，导致无法实现远程调用。 Messenger的构造函数分以下两种： ```java public Messenger(IBinder target){ mTarget = IMessenger.Stub.asInterface(target); } public Messenger(Handler target){ mTarget = target.getImessenger(); } ``` > > 拓展：**Handler主要用于线程间通信，Messenger用于进程间通信** 实现一个Messenger需要以下两步： - **服务端进程**： ①创建一个Service来处理客户端的连接请求 ②创建一个Handler并由他构造一个Messenger对象 ③然后在Service的onBind方法中返回该Messenger对象中的Binder。 代码示例： ```java //MessengerServcice.java public class MessengerService extends Service { private static class MessengerHanler extends Handler { @Override public void handleMessage(Message msg) { //处理返回的Message消息 ... //获取Client返回的Messenger对象 Messenger client = msg.replyTo; if (client != null) { //拼接数据 发送消息 } } } //通过Handler构造一个Messenger对象 private final Messenger mMessenger = new Messenger(new MessengerHanler()); @Override public IBinder onBind(Intent intent) { //返回IBinder对象 将消息交由对应Handler处理 return mMessenger.getBinder(); } } ``` - **客户端进程**： ①绑定服务端Service --`bindService` ②绑定后使用Service返回的IBinder对象创建一个Messenger对象 ③通过Messenger对象向服务端发送Message **完成单向通信** ④创建一个Handler由此创建一个Messenger对象，然后将Messenger对象放入Message的**replyTo**字段传递给Server。 **完成双向通信** 代码示例： ```java public class MessengerActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger); Intent intent = new Intent(this, MessengerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); } private Messenger mService; private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { mService = new Messenger(service); Message msg = Message.obtain(null, 1); Bundle data = new Bundle(); data.putString("msg", "it is from client"); msg.setData(data); //若存在则形成了双向通信 msg.replyTo = mGetReplyMessenger; try { mService.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { } }; private Messenger mGetReplyMessenger = new Messenger(new MessengerHanler()); private static class MessengerHanler extends Handler { @Override public void handleMessage(Message msg) { //处理消息 } } @Override protected void onDestroy() { //取消绑定service unbindService(mConnection); super.onDestroy(); } } ``` Messenger的工作原理： {% fullimage /images/Messenger-principle.png,Messenger工作原理,Messenger工作原理 %} #### 4.AIDL [AIDL相关](#3-AIDL相关) #### 5.ContentProvider > ContentProvider是专门用于不同应用间进行数据共享的方式，底层同样是由Binder实现。**主要是提供了一个统一的接口为了存储和获取数据。** [ContentProvide](https://www.jianshu.com/p/9048b47bb267) #### 6.Socket > Socket也称为"套接字"，是网络通信中的概念，分为流式套接字(`基于TCP协议，采用流的方式提供可靠的字节流服务`)和用户数据报套接字（`基于UDP协议，采用数据报文提供数据打包发送的服务`）两种。**Socket不仅可以跨进程通信还可以跨设备通信。** `TCP协议是面向连接的协议，提供稳定的双向通信功能，因为连接的建立需要经过'三次握手'才能完成，由于本身提供了超时重传机制，因此具有很高的稳定性。` `UDP是无连接的，提供不稳定的单向通信功能，在性能上拥有良好的效率，但数据不一定能够有效传输。` 1. 实现方法： 服务端： - 创建一个Service，在线程中建立TCP服务，监听相应的端口等待客户端连接请求 - 与客户端连接时，会生成新的Socket对象，利用它可与客户端进行数据传输 - 断开连接时，关闭相应的socket并结束线程 客户端： - 开启一个线程，通过Socket发起连接请求 - 连接成功后，读取服务端消息 - 断开连接，关闭Socket 2. 注意事项： - 需要声明网络权限 以上6种IPC方式比较： | 名称 | 优点 | 缺点 | 适用场景 | | --------------- | ------------------------------------------------------------ | --------------------------------------------------- | ---------------------------------------------------------- | | Bundle | 简单易用 | 只能传输Bundle支持的数据类型 | 四大组件的进程间通信 | | 文件共享 | 简单易用 | 不适合高并发场景，且无法做到实时通信 | 无并发访问情形，数据简单且实时性不高 | | AIDL | 功能强大，支持一对多并发通信，支持实时通信 | 使用稍复杂，需要处理好线程同步 | 一对多通信且支持远程调用 | | Messenger | 功能强大，支持一对多串行通信，支持实时通信 | 不能很好处理高并发场景，数据只能通过Message进行传输 | 低并发的一对多即时通信，并且不需要返回结果，不需要远程调用 | | ContentProvider | 在数据访问方面功能强大，支持一对多数据共享，可通过Call方法扩展其他操作 | 受约束的AIDL实现，主要提供对数据的CRUD操作 | 一对多的进程间数据共享 | | Socket | 功能强大，可以通过网络传输字节流，支持一对多并发通信 | 实现细节稍微麻烦 | 网络数据交换 | ## 2.Binder机制 > 在Linux中，为了避免一个进程对其他进程的干扰，进程之间是相互独立的。 > > Android的进程间通信采用了Binder出于两个方面的考虑：性能和安全。 > > 性能：在移动设备上对性能的要求是比较严苛的，在Linux上通信方式例如管道，Socket都需要复制两次数据，Binder只需一次。 > > `对于消息队列、Socket和管道而言，数据先从发送方的缓存区拷贝到内核开辟的缓存区中，再从内核缓存区拷贝至接收方缓存区，需要两次拷贝过程；Binder是从发送方缓存区到内核的缓存区，而接受方的缓存区与内核缓存区映射在同一块物理地址上，节省了一次数据拷贝的过程。` > > 安全：传统的Linux通信是不包含通信双方的身份验证的，Binder自带身份验证，提高了安全性。 > > `Android提供了UID机制，可以有效的鉴别用户身份。` 概念： - 直观来说，Binder是Android中的一个类，实现了IBinder接口。 - IPC角度来说，Binder是Android中的一种跨进程通信方式。 - Android Framework角度来说，Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁。 - 应用层来说，Binder是客户端和服务端进行通信的媒介。 ### **1.Binder框架** Binder通信采用了**C/S架构**。在Android系统的Binder机制中，由一系列系统组件组成，分别是 - `Client` 客户端进程 - `Server` 服务端进程 - `Service Manager` 管理系统中的各种服务 提供注册、查询和返回代理服务对象的功能 - `Binder 驱动` 负责建立进程见得Binder连接，进程间的数据交互等底层操作 {% fullimage /images/IPC-Binder.jpg, Binder架构图, Binder架构图 %} Client,Server,Service Manager处于用户空间，Binder驱动位于内核空间。 下面介绍四个组成部分的作用： - **Service Manager：**服务的管理者，指代的是Native层的ServiceManager(C++)，是整个Binder通信机智的大管家，是Android进程间通信机制的守护进程。将Binder的名字转换为Client中对该Binder的引用，使得Client可以通过Binder名字来获取Service中的引用。{% post_link Binder系列-ServiceManager相关 %} - **Binder驱动：**主要是驱动设备的**初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)**。 和硬件设备没有任何关系。它工作于内核态，以misc设备注册在设备目录/dev下，用户可以通过/dev/binder访问它。负责进程之间binder通信的建立、传递、计数管理和数据的传递交互等底层支持。主要功能由`ioctl()/*主要负责在两个进程间收发IPC和IPC reply数据，常用命令为BINDER_WRITE_READ*/`实现。 - **Client&Service：**在Binder驱动和Service Manager提供的基础设施上进行C-S之间的通信。`Server进程启动时，将在本进程内运行的Service注册到Service Manager中，并且启动一个Binder线程池，用来接收Clien请求。然后Client进程向Service Manager查询所需要的Service，并获得一个Binder代理对象，通过该代理对象向Service发出请求。` 四大组件彼此之间不是直接交互的，都是通过Binder驱动进行交互，从而实现IPC通信方式。**系统需要启动了Service Manager之后，Client端和Server端需要现获取了Service Manager接口后，才可以开始通信服务。** ### 2.**Binder工作机制** {% fullimage /images/Binder-workflow.png, Binder工作机制, Binder工作机制 %} - 在Server端创建好一个Binder对象后，内部就会开启一个线程用于接收Binder驱动发送的消息，收到消息后就会执行`onTransact()`,然后按照参数执行不同的服务端代码。 - 在服务端成功Binder对象后，Binder驱动会创建一个`mRemote`对象，客户端可以借助它调用`transcat()`向服务端发送消息 - 客户端要访问Binder的远程服务，就要获取远程服务的Binder对象在Binder驱动中的`mRemote`引用，获取到引用后既可以调用相关方法。 [Binder相关](http://gityuan.com/2015/10/31/binder-prepare/) ### 3.Binder连接池 >首先回顾一下AIDL的使用方式：①创建一个Service和AIDL接口②创建一个类继承自AIDL接口中的Stub类并实现Stub中的抽象方法③在Service的onBind中返回这个类的对象④客户端绑定Service后就可以直接访问服务端的方法。 > >当业务需求越来越多时，上述的创建方式就会产生很多Service类，导致系统资源耗费颜值、应用过度重量级的问题。所以产生了`Binder连接池`的概念。 > 主要作用为 **将每个业务模块的Binder请求统一转发到远程Service上去执行，从而避免重复创建Service**。 工作原理： {% fullimage /images/BinderPool.png,BinderPool工作原理, BinderPool工作原理%} 每个业务模块创建自己的AIDL接口并实现，然后向服务端传递自己的**唯一标识(BinderCode)及对应的Binder对象**。服务端只要一个Service，然后实现`queryBinder()`接口，根据唯一标识返回对应的Binder对象。 实现方式： - 创建对应的AIDL文件并有具体实现 - 创建BinderPool.java以及IBinderPool.aidl文件 - 实现远程服务BinderPoolService，并在onBind()中返回实例化的BinderPool对象 - 实现BinderPool方法，并在`queryBinder()`中做好对应处理 - 客户端调用BinderPoolService ## 3.AIDL相关 > 在Messenger中讲到它是基于AIDL的，但是只能处理串行的消息，如果有大量的消息同时发送进来，也只能一个个处理，而且不支持跨进程调用服务端的方法，就需要用到AIDL来处理上述情况。 > > **AIDL默认是同步调用的，若需要异步调用--可以添加一个异步回调接口执行结果异步回调给调用方，需要使用RemoteCallbackList** > > **AIDL本质上就是系统为我们提供了一种快速实现Binder的工具，我们可以不依赖于AIDL，自己去完全实现一个Binder。** ### 1.AIDL支持的数据类型 - 基本数据类型：`byte、int、long、float、double、boolean，char` - String 和 CharSequence - ArrayList，HashMap(**包括key，每个元素必须可以被AIDL支持**) - 实现了Parcelabe接口的对象 **必须要显示Import进来** - 所有AIDL接口本身也会被调用**必须要显示Import进来** ### 2.定向tag > 除了基本数据类型，其他类型的参数必须加上方向 **in,out,inout**，用于表示在跨进程通信中的数据流向。 - `in`：表示数据只能由客户端流向服务端。服务端会收到这个对象的完整数据，**但在服务端对对象进行修改不会对客户端传递进来的对象造成影响。** - `out`：表示数据只能由服务端传递到客户端。服务端会接受到这个对象的空对象，**但在服务端接收到的空对象有任何修改之后客户端会同步发生变化。** - `inout`：表示数据可以在服务端和客户端之间双向流通。服务端会收到这个对象的完整数据，**且客户端会同步服务端对该对象的任何改动。** ### 3.关键类和方法 > 添加完AIDL文件之后，会自动生成对应的Java文件，这个是关键所在。 `DESCRIPTOR`：Binder的唯一标识，一般用当前Binder的类名表示。 ```java private static final java.lang.String DESCRIPTOR = "com.example.wxy.ipc.IBookManager"; ``` `asInterface(android.os.IBinder obj)`：用于将服务端的Binder对象转换成客户端需要的AIDL接口类型的对象，不过是要区分进程的。 ```java public static com.example.wxy.ipc.IBookManager asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); //位于同一进程则返回服务端Stub对象本身 if (((iin != null) && (iin instanceof com.example.wxy.ipc.IBookManager))) { return ((com.example.wxy.ipc.IBookManager) iin); } //否则返回封装后的Stub.proxy对象 return new com.example.wxy.ipc.IBookManager.Stub.Proxy(obj); } ``` `asBinder()`：返回当前Binder对象 `Proxy`：这个类运行在客户端，客户端调用这个类来调用服务端的代码(涉及到了**代理模式**) ```java private static class Proxy implements com.example.wxy.ipc.IBookManager { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } ... @Override public com.example.wxy.ipc.Book addBookInout(com.example.wxy.ipc.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.example.wxy.ipc.Book _result; try { _data.writeInterfaceToken(DESCRIPTOR); //在定向tag为out时 没有这个if //判断传入参数是否为空 ，为空则不写入，不为空则写入_data流 if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_addBookInout, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) { _result = com.example.wxy.ipc.Book.CREATOR.createFromParcel(_reply); } else { _result = null; } //在定向tag 为in时 没有这个if if ((0 != _reply.readInt())) { book.readFromParcel(_reply); } } finally { _reply.recycle(); _data.recycle(); } return _result; } } ``` 分析上述生成的代码： - `_data _reply`：`_data`存储传参的数据，`_reply`存储方法的返回值数据 - `transcat(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags)`：客户端和服务端通信的核心方法。调用后会挂起当前线程，等候服务端执行任务完成通知并接受返回的`_reply`数据。 - `code`：分配的方法ID是自动生成的 工作流程为： 1. 生成`_data` 和` _reply`数据，在`_data`中存入客户端数据 2. 调用`transcat()`传递数据至服务端，并调用服务端中`onTranscat()`的指定方法 3. 接收`_reply`数据，取出服务端返回的数据使用 `onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)`：运行在服务器端的Binder线程池中，客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法处理。参数介绍： - `code`：可以确定客户端所请求的方法是哪个 - `data`：取出目标方法所需参数 - `reply`：里面填写请求的返回值 - `flags`：设置进行IPC的模式，0双向流通 1单向流通 **AIDL生成的.java文件均设置0 ```java @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { ... case TRANSACTION_addBookInout: { data.enforceInterface(descriptor); com.example.wxy.ipc.Book _arg0; //定向tag为in时有这段if 从_data中读取book对象并赋值 if ((0 != data.readInt())) { _arg0 = com.example.wxy.ipc.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } com.example.wxy.ipc.Book _result = this.addBookInout(_arg0); reply.writeNoException(); if ((_result != null)) { reply.writeInt(1); _result.writeToParcel(reply,android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } //定向tag为out时有这段if 若服务端对传参进行过修改 都会同步到_reply中 if ((_arg0 != null)) { reply.writeInt(1); _arg0.writeToParcel(reply,android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } return true; } } ``` 分析上述生成的代码： 处理完由客户端调用的`transcat()`传递进来的`_data`，再将处理完的数据写入到`_reply`中。 工作流程为： 1. 获取由`transcat()`传入的数据，根据对应的`code`执行相应方法 2. 执行方法后，解析对应传递过来的数据`_data` 3. 将需要回传的数据写入`_reply`中，传回给客户端 整套AIDL实现的流程如下： {% fullimage /images/AIDL-IPC.png,AIDL实现IPC流程,AIDL实现IPC流程 %} 拓展： 1. 可能会产生ANR 由于客户端在调用远程服务方法时，客户端线程会被挂起，如果服务端的方法执行比较耗时，就会导致客户端ANR，或者在`onServiceConnected`和`onServiceDisconnected`中调用了服务端的耗时方法也会导致ANR。 当服务端调用客户端的listener方法时，该方法会运行在客户端的`binder线程池中`，若调用了耗时方法，也会导致ANR。 2. AIDL解注册失败 > 服务端无法找到注册时使用的listener而导致解注册失败。**因为Binder客户端会把传递过来的对象重新转化并生成一个新的对象，而且对象是不能跨进程传输的，对象跨进程传输的本质就是序列化和反序列化的过程。** 这时需要用到`RemoteCallBackList`，是系统专门提供用于删除跨进程的listener的接口，而且内部实现了线程同步的功能**(内部使用了`synchronized`)**。使用注意事项:**`beginBroadcast`和`finishBroadcast`必须要配对使用。** 3. 性能损耗较大 > 客户端频繁调用服务端方法，就需要实现一个**观察者模式**，当客户端的数据发生变化时再去通知服务端操作，减少频繁查询。 ### 4.权限验证 > 默认情况下，远程服务所有人都可以进行连接并调用，所以应该需要加入权限验证系统来保证安全。 - 在`onBind`中进行验证，不通过直接返回null，导致客户端无法绑定。 ```xml //在AndroidManifest.xml中定义该权限 //如果注册了该权限，则可以绑定成功 否则失败 ``` - 在配置Service时 设置`` ```xml ```]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android需要的必备知识]]></title>
    <url>%2F2018%2F12%2F09%2FAndroid%E9%9C%80%E8%A6%81%E7%9A%84%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[--- title: Android需要的必备知识 date: 2018-12-09 14:05:46 tags: Android top: 10 --- 第一关：Binder、AIDL、多进程（建议学习时间：2周） 知识点：Binder原理、AIDL的使用、多进程的定义和特性 学习资料： ① Android开发艺术探索第2章【推荐理由】地球人都知道学Android要看艺术探索。 ② [Android Bander设计与实现 - 设计篇 - universus的专栏 - CSDN博客](https://blog.csdn.net/universus/article/details/6211589) 【推荐理由】Binder底层史上最牛逼分析，没有之一。 ③ 艺术探索第2章的例子，请一定手动运行一遍并仔细理解，地址：[GitHub - singwhatiwanna/android-art-res: the sourc...](https://github.com/singwhatiwanna/android-art-res)。 第二关：View的绘制（建议学习时间：3天） 知识点：View的measure、layout和draw，View的工作原理 学习资料： ① Android开发艺术探索第4章【推荐理由】地球人都知道学Android要看艺术探索。 ② [图解View测量、布局及绘制原理 - 简书](https://www.jianshu.com/p/3d2c49315d68) 【推荐理由】配有流程图，比艺术探索好理解一些。 ③ [android ListView 工作原理 - Android - 掘金](https://juejin.im/entry/5819968bda2f60005dda6a2d)【推荐理由】帮大家了解ListView的工作过程，很有价值。 第三关：事件分发（建议学习时间：1周） 知识点：事件分发原理和规则 学习资料： ① Android开发艺术探索第3章【推荐理由】地球人都知道学Android要看艺术探索。 ② [Android事件分发机制，大表哥带你慢慢深入 - 简书](https://www.jianshu.com/p/fc0590afb1bf) 【推荐理由】通过实际的例子来讲事件分发，好理解。 ③ [Android ViewGroup事件分发机制 - Hongyang - CSDN博客](https://blog.csdn.net/lmj623565791/article/details/39102591) 【推荐理由】张鸿洋写的。 第四关：消息队列（建议学习时间：1天） 要求：Handler、Looper、Thread三者之间的关系；得知道子线程创建Handler为什么会报错，如何才能不报错 学习资料： ① Android开发艺术探索第10章【推荐理由】这块内容不难，艺术探索就够了。 ② [源码角度讲解子线程创建Handler报错的原因 - 曹银飞的专栏 - CSDN博客](https://blog.csdn.net/dfskhgalshgkajghljgh/article/details/52601802)【推荐理由】一个实际的例子帮助大家更好地理解。 第五关：Activity难点（建议学习时间：1天） ① setResult和finish的顺序关系 ② onSaveInstanceState()和onRestoreInstanceState() ③ onNewIntent()和onConfigurationChanged() 学习资料： ① [setResult()的调用时机 - 沙翁 - 博客园](https://www.cnblogs.com/shaweng/p/3875825.html)【推荐理由】清晰易懂，直接了当。 ② [onSaveInstanceState()和onRestoreInstanceState()使用详解...](https://www.jianshu.com/p/27181e2e32d2)【推荐理由】简单好懂。 ③ [关于onConfigurationChanged方法及常见问题解决 - 朱小姐。的博客 - CSDN...](https://blog.csdn.net/qq_27570955/article/details/55046934)【推荐理由】简单好懂，文章在郭霖公号投稿了。 ④ 艺术探索第1章【推荐理由】地球人都知道学Android要看艺术探索。 第六关：Service难点（建议学习时间：2天） ① 先start再bind，如何停止一个Service ② Service onStartCommand的返回值 ③ bindService后，ServiceConnection里面的回调方法运行在哪个线程？它们的调用时机分别是什么？ ④ Service的onCreate运行在哪个线程？ 学习资料： ① [Android中startService和bindService的区别 - 简书](https://www.jianshu.com/p/d870f99b675c)【推荐理由】详细全面地回答了上面的问题。 ② [Service: onStartCommand 诡异的返回值 - CodingMan - CSDN博...](https://blog.csdn.net/veryitman/article/details/7600008)【推荐理由】通过实例来演示onStartCommand那诡异的返回值。 ③ Service的onCreate、onStartCommand、onDestory等全部生命周期方法都运行在UI线程，ServiceConnection里面的回调方法也是运行在UI线程，大家一定要记住。【推荐理由】任玉刚说的，你们自己可以打log验证一下 第七关：ContentProvider难点(建议学习时间：3天) ① ContentProvider的生命周期 ② ContentProvider的onCreate和CRUD运行在哪个线程？它们是线程安全的吗？ ③ ContentProvider的内部存储只能是sqlite吗？ 学习资料： ① 艺术探索第9章中ContentProvider的启动、艺术探索第二章中ContentProvider的介绍【推荐理由】详细了解下，艺术探索的内容无需解释 ② [android ContentProvider onCreate()在 Application......](https://www.jianshu.com/p/0f1e36507b9d)【推荐理由】此文明确说明了ContentProvider的onCreate早于Application的onCreate而执行。 ③ [ContentProvider总结 - 简书](https://www.jianshu.com/p/cfa46bea6d7b)【推荐理由】此文明确说明了ContentProvider的onCreate和CRUD所在的线程 注意：ContentProvider的底层是Binder，当跨进程访问ContentProvider的时候，CRUD运行在Binder线程池中，不是线程安全的，而如果在同一个进程访问ContentProvider，根据Binder的原理，同进程的Binder调用就是直接的对象调用，这个时候CRUD运行在调用者的线程中。另外，ContentProvider的内部存储不一定是sqlite，它可以是任意数据。 第八关：AsyncTask原理(建议学习时间：3天) 要求：知道AsyncTask的工作原理，知道其串行和并行随版本的变迁 ① [Android源码分析—带你认识不一样的AsyncTask - 任玉刚 - CSDN博客](https://blog.csdn.net/singwhatiwanna/article/details/17596225) 【推荐理由】只看这一篇文章就够了 ② [https://android.googlesource.com/platform/frameworks/base/ /android-8.1.0_r46/core/java/android/os/AsyncTask.java](https://android.googlesource.com/platform/frameworks/base/+/android-8.1.0_r46/core/java/android/os/AsyncTask.java) 【推荐理由】阅读AsyncTask 8.1版本的源码，看看是否有更新]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal原理分析]]></title>
    <url>%2F2018%2F12%2F09%2FThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: ThreadLocal原理分析 date: 2018-12-09 14:04:59 tags: 源码分析 top: 10 --- # ThreadLocal详解 > 在前几节Handler详解中介绍 如何获取Looper对象时提及了是利用ThreadLocal来进行Looper的存储与获取。 ## 1.初步理解ThreadLocal ThreadLocal的定义为：**用于提供线程变量，在多线程环境中可以保证各个线程的变量独立于其他线程里的变量。**主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量不会互相干扰，适用于`高并发状态下实现无状态的调用即各个线程依赖不同的变量完成操作`。 > ThreadLocal保证的是多线程环境下的独立性，同步机制则保证多线程下数据的一致性。 ## 2.使用样例 ```java public class ThreadLocalTest { private static String label; private static ThreadLocal threadLocal = new ThreadLocal(); public static void main(String[] args) { label = "main"; threadLocal.set("main"); //new Thread Thread thread = new Thread() { @Override public void run() { super.run(); label = "new"; threadLocal.set("new"); } }; thread.start(); try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.err.println("label = " + label); System.err.println("threadLocal = " + threadLocal.get()); } } //console.log label = new threadLocal = main ``` 对于ThreadLocal中的变量，在一个线程中修改它的值，并不会影响到在其他线程中的值。**ThreadLocal中的值在每个线程中都是独立的。** ## 3.深入理解ThreadLocal ThreadLocal类中提供了以下几个方法来进行变量的操作： - `public T get()`获取ThreadLocal在当前线程中保存的变量副本 - `public void set(T value)`设置当前线程中的变量副本 - `public void remove()`移除当前线程中的变量副本 - `protected T initialValue()`设置ThreadLocal的初始值，该方法为延迟加载 接下来具体查看上述方法的内部实现。加深理解 ### `get()` ```java //返回当前线程中存储的变量副本 public T get() { //获取当前线程 Thread t = Thread.currentThread(); //获取到持有变量副本的map ThreadLocalMap map = getMap(t); //map存在则返回存储值 if (map != null) { //该map key为ThreadLocal 故获取value用的是this ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings("unchecked") T result = (T)e.value; return result; } } //不存在则返回默认值 return setInitialValue(); } ``` ### `set(T value)` ```java //设置当前线程的变量副本 public void set(T value){ Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //map不为null 则保存value if(map!=null){ map.set(this,value); } //否则创建一个ThreadLocalMap后保存value else{ createMap(t,value); } } ``` ### `remove()` ```java //移除保存的变量副本 public void remove(){ ThreadLocalMap map = getMap(Thread.currentThread); //map不为空 则移除当前ThreadLocal对应的变量副本 if(map!=null) map.remove(this); } ``` ### `initialValue()` ```java //子类可重写该方法 进行默认值的设置 protected T initialValue() { return null; } 对应有setInitialValue() private T setInitialValue(){ T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if(map!=null){ map.set(this,value); }else{ createMap(t,value); } return value; } ``` 在上述四个方法中都会涉及到一个类**`ThreadLocalMap`**，该类是ThreadLocal的核心机制实现。`在使用ThreadLocal的方法对存储变量进行操作时都需要获得当前线程对应的ThreadLocalMap来对变量进行操作`。**每个线程都会有专属的ThreadLocalMap，其中维护的value也是对应当前线程的。就保证了ThreadLocal中存储的变量都是相互独立的，不会受到多线程环境的影响。** **`ThreadLocalMap`** > 该类为ThreadLocal中的内部类，没有实现Map接口，内部自己实现了Map的功能。 1. 构造方法 ```java ThreadLocalMap(ThreadLocal firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); } ``` 2. 初始对象 ```java // 初始容量，必须是 2 的幂 private static final int INITIAL_CAPACITY = 16; // 存储数据的哈希表 private Entry[] table; // table 中已存储的条目数 private int size = 0; // 表示一个阈值，当 table 中存储的对象达到该值时就会扩容 private int threshold; // 设置 threshold 的值 private void setThreshold(int len) { threshold = len * 2 / 3; } ``` 由内部实现了一套Map机制 3. Entry > table中存储的都为Entry对象，用于保存K-V数据结构 ```java static class Entry extends WeakReference { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) { super(k); value = v; } } ``` Entry继承自`WeakRefrence`为弱引用类型并且限制了`K`只能为ThreadLocal对象，但是对应的`V`为强引用类型，则可能导致**内存泄漏**。 4. 保存key-value ```java //调用set方法将 key-value类型进行存储 private void set(ThreadLocal key, Object value) { // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; //计算要存储的索引位置 int i = key.threadLocalHashCode & (len-1); //判断要存储的索引位置是否已经存在Entry 存在则继续向下 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal k = e.get(); //key相同则更新 if (k == key) { e.value = value; return; } //key为空 代表该位置对应的Entry已失效，需要直接进行替换 if (k == null) { replaceStaleEntry(key, value, i); return; } } //若不存在 则将Entry保存到该位置 tab[i] = new Entry(key, value); int sz = ++size; //超过当前负载 则需进行扩容机制 重新调整table if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); } ``` 使用当前的ThreadLocal中对应的threadLocalHashCode来计算该键值对要存储的索引位置。该值是由ThreadLocal对象自动生成的，创建时就会进行赋值。 ```java private final int threadLocalHashCode = nextHashCode(); /** * The next hash code to be given out. Updated atomically. Starts at * zero. * 使用AtomicInteger用来保证多线程环境下不会受到影响 */ private static AtomicInteger nextHashCode = new AtomicInteger(); /** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */ private static final int HASH_INCREMENT = 0x61c88647; /** * Returns the next hash code. */ private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } ``` 当table中的条目超出阈值时就需要进行扩容 ```java //扩容是 新table的容量为原先的两倍 触发条件为table中的条目数超出了阈值的3/4 private void resize(){ Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for(int j = 0;j]]></content>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler机制源码解析(二)]]></title>
    <url>%2F2018%2F10%2F07%2FHandler%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[--- title: Handler机制源码解析(二) date: 2018-10-07 11:08:24 tags: 源码解析 top : 10 --- # 主要包括Handler其他使用知识点 ## 1. 子线程创建Handler对象 > 不可以直接在子线程创建Handler对象，因为Handler对象必须要绑定一个Looper，才可以使用。 > > 若在子线程需要使用Handler，则需要先创建一个Looper对象即执行`Looper.prepare()`然后再创建Handler对象时调用`Looper.myLooper()`获取Looper对象传入方法，最后调用`Looper.loop()`开始运行。 ```kotlin class MyActivity : Activity{ lateinit var mThread: MyThread lateinit var mHandler: MyHandler override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.act_main) //初始化子线程 mThread = Mythread() mThread.start() //需要发出的消息 val message = Message.obtain() message.obj = "test" //初始化Handler mHandler = MyHandler(this, mThread.childLooper) //发送消息 mHandler.sendMessage(message) } //子线程 class MyThread : Thread() { var childLooper: Looper? = null override fun run() { Looper.prepare() childLooper = Looper.myLooper() Looper.loop() } } //安全的Handler写法 class MyHandler(activity: MyActivity, looper: Looper?) : Handler(looper) { var mWeakRe: WeakReference = WeakReference(activity) override fun handleMessage(msg: Message?) { super.handleMessage(msg) val activity: MyActivity? = mWeakRe.get() if (activity!=null){ //添加handlerMessage需要处理的逻辑 } } } } ``` 以上代码执行完毕后就可以在子线程调用Handler对象。 **但是，在多次执行过程中，会有java.lang.NullPointerException: Attempt to read from field 'android.os.MessageQueue android.os.Looper.mQueue' on a null object reference空指针导致应用崩溃。**调试过程中发现是由于Looper对象为空导致的异常。由于**在子线程`run()`初始化了Looper对象，Handler对象的初始化依然继续执行，Looper对象此时尚未初始化好，导致空指针异常。** 由于这种情况的出现是随机的，不是百分百重现，为了保证应用的运行就需要引入`HandlerThread`这个类，可以帮我们解决这个问题。 ```kotlin //HandlerThread示例代码 class MyActivity : Activity{ lateinit var mHandler: MyHandler var mHandlerThread: HandlerThread?=null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.act_main) //初始化HandlerThread并指定线程名字为test mHandlerThread = HandlerThread("test",Process.THREAD_PRIORITY_BACKGROUND) mHandlerThread?.start() //需要发出的消息 val message = Message.obtain() message.obj = "test" //初始化Handler mHandler = MyHandler(this, mHandlerThread?.looper) //发送消息 mHandler.sendMessage(message) } //安全的Handler写法 class MyHandler(activity: MyActivity, looper: Looper?) : Handler(looper) { var mWeakRe: WeakReference = WeakReference(activity) override fun handleMessage(msg: Message?) { super.handleMessage(msg) val activity: MyActivity? = mWeakRe.get() if (activity!=null){ //添加handlerMessage需要处理的逻辑 } } } override fun onDestroy() { super.onDestroy() //结束时停止thread mHandlerThread?.quit() } } ``` 以上代码执行完毕后即在HandlerThread可以调用Handler对象。 我们需要从源码去分析为什么使用`HandlerThread`可以避免上述异常，是怎样一个机制实现的。 ```java // 源码位置:../core/java/android/os/HandlerThread.java public class HandlerThread extends Thread { ... //设置线程优先级 优先级主要分为UI线程和后台线程(Background) int mPriority; public HandlerThread(String name) { super(name); //默认标准App线程优先级 mPriority = Process.THREAD_PRIORITY_DEFAULT; } public HandlerThread(String name, int priority) { super(name); mPriority = priority; } //可以重写这个方法，在内部新建Handler对象 protected void onLooperPrepared() { } @Override public void run() { //获取到线程ID mTid = Process.myTid(); //创建对应的Looper，MessageQueue对象 Looper.prepare(); synchronized (this) { //对mLooper进行赋值 mLooper = Looper.myLooper(); //唤醒等待Looper赋值而阻塞的所有线程 notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } public Looper getLooper() { //判断当前线程是否存活 关闭则返回空 if (!isAlive()) { return null; } // If the thread has been started, wait until the looper has been created. synchronized (this) { //mLooper==null表明当前Looper对象尚未初始化 while (isAlive() && mLooper == null) { try { //调用线程等待 直至初始化完成 阻塞其他线程 wait(); } catch (InterruptedException e) { } } } //返回Looper对象 return mLooper; } //内嵌一个可以直接引用的Handler对象，外部可以直接使用 @NonNull public Handler getThreadHandler() { if (mHandler == null) { mHandler = new Handler(getLooper()); } return mHandler; } //HandlerThread退出 同步于Looper.quit() public boolean quit() { Looper looper = getLooper(); if (looper != null) { looper.quit(); return true; } return false; } //HandlerThread退出 同步于Looper.quitSafely() public boolean quitSafely() { Looper looper = getLooper(); if (looper != null) { looper.quitSafely(); return true; } return false; } } ``` 总结： - `HandlerThread`内嵌了Handler,Looper,MessageQueue对象 - `HandlerThread`内部使用`wait(),notifyAll()`等线程同步方式保证`mLooper`对象不会为空，`wait()`当Looper对象尚未初始化完成时阻塞其他线程，`notifyAll()`当mLooper对象不为空时，通知其他线程使用mLooper。 ## 2. IdleHandler > 当Looper里面的Message暂时处理完毕即**全部消息处理完毕或者阻塞等待新消息**时会调用`IdleHandler`这个类去处理一些空闲时间的消息。 > > 继承`IdleHandler`这个接口，需要设置`queueIdle()`的返回值。若返回`false`则调用一次后会移除，为`true`则继续持有，空闲时依然会调用。 > > 概括就是：**优先级别较低的`Message`，只有当`Looper`中没有消息要处理时，才会去处理`IdleHandler`。** ```kotlin //使用示例代码 val message = Message.obtain() message.obj = "1234" handler.sendMessage(message) val delayMessage=Message.obtain() delayMessage.obj="12344" handler.sendMessageDelayed(delayMessage,3000) //子线程添加IdleHandler 限制API23以上使用 mHandlerThread?.looper?.queue?.addIdleHandler(OnceIdleHandler()) mHandlerThread?.looper?.queue?.addIdleHandler(ForeverIdleHandler()) //主线程添加IdleHandler Looper.myQueue().addIdleHandler(OnceIdleHandler()) Looper.myQueue().addIdleHandler(ForeverIdleHandler()) //只使用一次的IdleHandler class OnceIdleHandler : MessageQueue.IdleHandler { override fun queueIdle(): Boolean { LogUtils.e("idle once") return false } } //一直持续存在的IdleHandler class ForeverIdleHandler : MessageQueue.IdleHandler { override fun queueIdle(): Boolean { LogUtils.e("idle forever") return true } } //需要移除IdleHandler 调用 Looper.myQueue().removeIdleHandler(OnceIdleHandler()) Looper.myQueue().removeIdleHandler(ForeverIdleHandler()) ``` 集成上述代码即可测试IdleHandler的使用，接下来要分析源码的实现以及使用场景。 ```java // 源码位置:../core/java/android/os/MessageQueue.java /** * IdleHandler定义 * Callback interface for discovering when a thread is going to block * waiting for more messages. */ public static interface IdleHandler { /** * Called when the message queue has run out of messages and will now * wait for more. Return true to keep your idle handler active, false * to have it removed. This may be called if there are still messages * pending in the queue, but they are all scheduled to be dispatched * after the current time. */ boolean queueIdle(); } //mIdleHandlers 是ArrayList型 故可以重复添加 private final ArrayList mIdleHandlers = new ArrayList(); //往MessageQueue中添加一个IdleHandler对象 public void addIdleHandler(@NonNull IdleHandler handler) { if (handler == null) { throw new NullPointerException("Can't add a null IdleHandler"); } synchronized (this) { //添加IdleHandler是线程安全的 mIdleHandlers.add(handler); } } //移除一个IdleHandler public void removeIdleHandler(@NonNull IdleHandler handler) { synchronized (this) { mIdleHandlers.remove(handler); } } //调用上述方法往mIdleHandlers添加或移除IdleHandler对象后 需要在next()方法中 去使用mIdleHandlers中的对象 Message next() { //无限循环 for(;;){ ... // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount **进程**：每个app运行时首先会创建一个进程，该进程是由zygote fork出来的，用于承载运行app上的Activity/Service等组件。进程对于上层应用来说是完全透明的，目的是为了`让App都运行在Android Runtimr`。大多数情况下一个App运行在一个线程中，除非配置了`Android:Process`属性，或者通过native fork 进程。 > > **线程**：线程比较常见，每次`new Thread().start()`都会创建一个新线程。并且与当前App所在进程之间资源共享。`在CPU看来进程或线程无非是一段可执行的代码，CPU采用CFS调度算法，保证每个task尽可能公平享有CPU时间片`。 > > 拓展知识：CFS调度算法是一种完全公平调度算法，基本设计思路是根据各个进程的权重来分配运行时间**。 当进入死循环时又该如何处理其他事务呢？**需要创建新的线程去处理**。 主线程进入Looper的死循环后，需要处理 activity的各个生命周期的回调函数执行(`在同一个线程下，代码是按顺序执行的，如果死循环堵塞了，后续该如何执行`)。 ```java //源码地址 android/app/ActivityThread.java public static void main(String[] args){ ... //Looper初始化 Looper.prepareMainLooper(); //new 一个ActivityThread并调用了attach方法 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); } ``` 源码中在初始化ActivityThread时也会初始化一个`H类型的成员，它继承了Handler`。 源码中调用`thread.attach(false)`时,**回去创建一个Binder进程（具体代指ApplicationThread,Binder的服务端，用于接收系统AMS发出来的事件），由Handler线程发送Message至主线程。** 所以在主线程开启Looper死循环之前，就已经启动了一个Binder线程并且准备了`H 这一个Handler类`，就可以用于处理一些死循环之外的事务。`仅需通过Binder线程向H发送消息即可`。 {% fullimage /images/activity_binder.png, App运行过程, App运行过程 %} **system_server进程即为系统进程**，里面运行了大量的系统服务，比如上图提供了`ApplicationThreadProxy以及ActivityManagerService`，这两者都基于IBinder接口，都是Binder线程。 **App进程即为我们常说的应用程序**，主线程主要负责Activity等组件的生命周期以及UI绘制。每个App进程中至少会包括两个binder线程:`ApplicationThread和ActivityManagerProxy`。 **Binder用于不同进程间的通信，由一个进程的Binder客户端向另一个进程的服务端发送事务。** **Handler则用于同一进程间不同线程的通信。** ### 3.主线程的消息模型 上图中绘制出主线程(ActivityThread)是如何循环的,简单的文字表达就是 > `ActivityManagerService(AMS)` ==直接调用==>`ApplicationThreadProxy(ATP)`==Binder==>`ApplicationThread`==Handler方式==>`ActivityThread` > > 主线程(ActivityThread)通过`ApplicationThread`和`ActivityManagerService`进行进程间通信，AMS以进程间通信的方式完成`ActivityThread`的请求后回调`ApplicationThread`中的Binder方法。然后由`ApplicationThread`向`ActivityThread`中的`H`发送消息，然后收到消息后 把处理逻辑发送至`ActivityThread`中去执行。]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-RemoteViews]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-RemoteViews%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-RemoteViews date: 2018-08-26 13:33:29 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-RecyclerView以及ConstrainLayout]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-RecyclerView%E4%BB%A5%E5%8F%8AConstrainLayout%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-RecyclerView以及ConstrainLayout date: 2018-08-26 13:33:14 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-动态权限]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-动态权限 date: 2018-08-26 13:32:25 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-设计模式基本原则]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-设计模式基本原则 date: 2018-08-26 13:31:38 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XX]]></title>
    <url>%2F2018%2F06%2F25%2FAndroid-Study-Plan-XX%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XX date: 2018-06-25 14:13:36 tags: Android --- # Android学习计划 ## 大尺寸图片加载问题：给定一个1000px*2000px的大图，如何进行正常加载且不会导致OOM。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XIX]]></title>
    <url>%2F2018%2F06%2F12%2FAndroid-Study-Plan-XIX%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XIX date: 2018-06-12 12:44:28 tags: Android --- # Android学习计划 ## AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树]]></title>
    <url>%2F2018%2F06%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[--- title: 数据结构-树 date: 2018-06-03 10:51:04 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础]]></title>
    <url>%2F2018%2F05%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[--- title: 计算机网络基础 date: 2018-05-31 12:52:59 tags: 计算机网络 ---]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XVIII -- 基础网络原理]]></title>
    <url>%2F2018%2F05%2F31%2FAndroid-Study-Plan-XVIII%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XVIII -- 基础网络原理 date: 2018-05-31 12:35:24 tags: Android --- # Android学习计划 ## 网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-线程池 ThreadPool 专题详解]]></title>
    <url>%2F2018%2F05%2F31%2FAndroid-Study-Plan-XVII%2F</url>
    <content type="text"><![CDATA[--- title: Android-线程池 ThreadPool 专题详解 date: 2018-05-31 12:35:18 tags: Android top: 10 --- ## 线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？ {% fullimage /images/ThreadPool-Structure.png,线程池脑图,线程池脑图 %} ### 基础概念 - **线程**：进程中负责执行的执行单元，一个进程中至少有一个线程,**操作系统能够进行调度的最小单位** - **进程**：一个执行中的程序的实例 - **多线程**：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU确定，因此多线程具有不确定性 - **线程池**： 基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象回归池中，避免反复创建线程对象所带来的性能开销，节省系统资源。 ### 1. 线程池的概念 在执行一个异步任务或并发任务时，往往会通过`new Thread()`方法去开启一个子线程去执行任务，等到子线程操作完成后在利用`Handler`切换至主线程。但是利用这种方法我们无法对自己创建的子线程进行有效的管理，然后由于过多的创建子进程，他们之间相互竞争会导致资源的过度占用。线程池的出现就是为了来对子进程进行管理。 ### 2. 线程池的实现原理 `Executors`提供了基础的四类线程池方法，最终都是通过`ThreadPoolExecutor`类完成。对于这个类的描述`他维护了一个线程池，对于提交Executor中的任务，不是创建新的线程而是使用池内的线程来执行任务。可以显著减少对于任务执行的开销。` 1. ThreadPoolExecutor构造函数介绍 ```java public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ``` 参数介绍： - **`corePoolSize 核心线程数`** 表示线程池中的基本线程数量即核心线程数量。一般情况下核心线程会一直存活在线程池中，即便他们处于闲置状态。只有在`ThreadPoolExecutor的allowCoreThreadTimeOut设置为true`的时候，会有一个超时策略（超过设置好的超时时间，闲置的核心线程会被终止）。**当创建的线程数小于corepoolSize时，不管有没有空闲线程都会创建新的线程**。 - **`maximumPoolSize 最大线程数`** 表示线程池中允许的最大创建线程数，当活动的线程数达到数值后，后续新任务会被阻塞。**使用有界队列时，未达到该值则会创建新的线程，使用无界队列时该值无效。** - **`keepAliveTime 非核心线程闲置时的超时时长`** 表示空闲非核心线程的最大存活时间，一旦超过即被销毁。**当`ThreadPoolExecutor的allowCoreThreadTimeOut设置为true`的时候，该参数也可作用于核心线程 - **`unit 存活时间的时间单位`** 用于指定keepAliveTime参数的时间单位，为一个枚举类型。包含下列参数：`NANOSECONDS（纳秒）`,`MICROSECONDS（微秒）`,`MILLSECONDS（毫秒）`,`SECONDS（）秒`,`MINUTES（分）`,`HOURS（时）`,`DAYS（天）` - **`workQueue 线程池中的任务队列`** 该队列是`java.util.BlockingQueue`的一个实例，是一种阻塞队列用来存放等待执行的任务。通过`execute()`方法将提交的Runnable对象存储进去。根据具体实现类的不同可以分为以下三种队列策略： - `容量为0即直接提交策略--SynchronousQueue`：等待队列容量为0 ，所有需要阻塞的任务必须等待池内的某个线程有空闲才可以继续执行，否则阻塞。`CachedThreadPool`使用该队列策略。 - `容量无限即无界队列策略--LinkedBlockingQueue`：等待队列的长度无穷大，在这种策略下不会出现多余corePoolSize的线程被创建，所以maximumPoolSize以及handler无效，因为不存在队列满的情况。不过也有缺点：**线程的执行速度会比提交速度慢，会导致无界队列快速增长，直到系统资源耗尽。**`fixedThreadPool`采用了这种队列策略。 - `容量有限即有界队列策略--指定了容量的任何BlockingQueue`：等待队列的长度为限制长度，指定了容量后可以**防止过多的资源被消耗**。 - **`threadFactory 线程工厂`**：是一个接口可以为线程池提供新线程的创建。由同一个threadFactory创建的线程同属于一个ThreadGroup，优先级都为Thread.NORM_PRIORITY，以及为非进程守护状态。默认都是采用`Executors.defaultThreadFactory()`返回值。 - **`handler 拒绝策略`**：当**使用有界队列时且队列任务被填满后并且线程数也达到了最大值，就会触发拒绝策略**。如果任务被拒绝执行，则会调用`RejectedExecutionHandler.rejectedExecution()`方法，默认调用`AbortPolicy`拒绝策略，也可以由用户自定义。JDK中定义了4种拒绝策略： - `AbortPolicy`**处理程序遭到拒绝则直接抛出`RejectedExecutionException`异常然后丢弃该任务。** 实现源码： ```java public static class AbortPolicy implements RejectedExecutionHandler { /** * Creates an {@code AbortPolicy}. */ public AbortPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString()); } } ``` 样例演示： ```java static class TestRunnable implements Runnable { private int id; TestRunnable(int id) { this.id = id; } @Override public void run() { System.err.println(Thread.currentThread().getName()+" 当前线程id="+ this.id); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } public static void abortPolicyDemo() { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue(1), new ThreadPoolExecutor.AbortPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.shutdown(); } 运行结果：添加进程时直接抛出异常但是没有影响后续的进行 pool-1-thread-1 当前线程id=1 Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@4b1210ee rejected from java.util.concurrent.ThreadPoolExecutor@4d7e1886[Running, pool size = 1, active threads = 1, queued tasks = 1, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112) at threadpool.ThreadPoolDemo.abortPolicyDemo(ThreadPoolDemo.java:140) at threadpool.ThreadPoolDemo.main(ThreadPoolDemo.java:13) pool-1-thread-1 当前线程id=2 ``` - `CallerRunsPolicy`**在调用`execute`方法的调用者所在线程来执行被拒绝的任务，提供简单的反馈控制机制，可以减缓新任务的提交速度。** 实现源码： ```java public static class CallerRunsPolicy implements RejectedExecutionHandler { /** * Creates a {@code CallerRunsPolicy}. */ public CallerRunsPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { r.run(); } } } ``` 样例演示： ```java public static void callerRunsPolicyDemo(){ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue(1), new ThreadPoolExecutor.CallerRunsPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.shutdown(); } 运行结果：task2执行在了主线程，由于被拒绝执行所以在调用者线程执行了任务 pool-1-thread-1 当前线程id=1 main 当前线程id=3 pool-1-thread-1 当前线程id=2 ``` - `DiscardPolicy`**被拒绝即无法执行的任务被直接删除** 实现源码： ```java public static class DiscardPolicy implements RejectedExecutionHandler { /** * Creates a {@code DiscardPolicy}. */ public DiscardPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { } } ``` 样例演示： ```java public static void discardPolicyDemo(){ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue(1), new ThreadPoolExecutor.DiscardPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.shutdown(); } 运行结果：由于被拒绝执行在该策略下被直接抛弃 pool-1-thread-1 当前线程id=1 pool-1-thread-1 当前线程id=2 ``` - `DiscardOldestPolicy`**判断线程池是否被关闭，没有则丢弃最老的一个请求，再尝试提交当前任务。** 实现源码： ```java public static class DiscardOldestPolicy implements RejectedExecutionHandler { /** * Creates a {@code DiscardOldestPolicy} for the given executor. */ public DiscardOldestPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { e.getQueue().poll(); e.execute(r); } } } ``` 样例演示： ```java public static void discardOldestPolicyDemo(){ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue(1), new ThreadPoolExecutor.DiscardOldestPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.submit(new TestRunnable(4)); threadPoolExecutor.shutdown(); } 运行结果：??? pool-1-thread-1 当前线程id=1 pool-1-thread-1 当前线程id=4 ``` - `CustomRejectPolicy 自定义拒绝策略`**可以用来记录运行日志或者记录无法处理的任务** 样例演示： ```java /** * 自定义拒绝策略，实现RejectedExecutionHandler接口即可 */ static class CustomRejectedPolicy implements RejectedExecutionHandler{ @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { if (!executor.isShutdown()){ System.err.println("自定义异常日志记录: "+ r.toString()); } } } public static void customPolicyDemo(){ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue(2), new CustomRejectedPolicy()); //使用execute是因为使用submit时会被封装成RunnableFuture对象 threadPoolExecutor.execute(new TestRunnable(1)); threadPoolExecutor.execute(new TestRunnable(2)); threadPoolExecutor.execute(new TestRunnable(3)); threadPoolExecutor.execute(new TestRunnable(4)); threadPoolExecutor.shutdown(); } 运行结果：由于4号被拒绝，记录日志 自定义异常日志记录: java.util.concurrent.FutureTask@4b1210ee pool-1-thread-1 当前线程id=1 pool-1-thread-1 当前线程id=2 pool-1-thread-1 当前线程id=3 ``` - 额外参数扩展 `allowCoreThreadTimeOut 允许核心线程过期 `默认值为false（线程池已不被使用，但是其中还有活着的线程，则该线程池无法被回收，会造成内存泄露）。所以用户可以显式调用`shutDown()`或者该值设置为true，则会被回收。 2. ThreadPoolExecutor的使用 向线程池提交一个任务的方式有两种： - `execute`：这种方法提交任务，是没有返回值的即无法判断在线程池中是否完成该任务 ```java threadPoolExecutor.execute(new TestRunnable(1)); ``` - `submit`：使用`submit`方法提交任务时，会返回一个future，可以通过这个future来判断任务是否执行成功也可以根据`future的get()`方法获取返回值。**若子线程任务没完成，`get()`方法会阻塞直到任务完成，若使用`get(long timeout,TimeUnit unit)`则会阻塞一段时间后返回，可能尚未完成任务。** ```java Future future = fixedThreadPool.submit(new Callable() { @Override public Integer call() throws Exception { System.err.println(Thread.currentThread().getName() + " , index = " + index); return 2; } }); try { System.err.println("Future return :" + future.get().toString()); } catch (Exception e) { e.printStackTrace(); } ``` 3. 线程池的关闭 线程池关闭方法有两种： - `shutdown()`：将线程池的状态置为SHUTDOWN状态，然后中断没有正在执行的线程。 ```java public void shutdown() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { checkShutdownAccess(); advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor } finally { mainLock.unlock(); } tryTerminate(); } ``` - `shutdownNow()`：将线程池的状态设为STOP状态，中断所有任务包括执行中的线程，并返回等待执行的任务列表。 ```java public List shutdownNow() { List tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { checkShutdownAccess(); advanceRunState(STOP); interruptWorkers(); tasks = drainQueue(); } finally { mainLock.unlock(); } tryTerminate(); return tasks; } ``` 中断线程需要采用`interrput`方法，**无法响应中断的任务可能永远无法终止。** 当需要立即中断所有线程并且不在乎任务是否执行完成时，可以使用`shutdownNow`方法。 4. 线程池的拓展 `ThreadPoolExecutor`默认提供三个空方法，可以通过重写这三个方法来监控线程池。 ```java //任务执行前 记录任务开始前时间 protected void beforeExecute(Thread t, Runnable r) { } //任务执行后 记录任务结束时间 protected void afterExecute(Runnable r, Throwable t) { } //线程池关闭 记录线程池关闭事件以及执行过的线程数量 protected void terminated() { } ``` 样例演示： ```java class CustomThreadPoolExecutor extends ThreadPoolExecutor{ public CustomThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); System.err.println("beforeExecute"+r.toString()); } @Override protected void afterExecute(Runnable r, Throwable t) { super.afterExecute(r, t); System.err.println("afterExecute"+r.toString()); } @Override protected void terminated() { super.terminated(); System.err.println("线程关闭"); } } ``` ### 3. 为什么要使用线程池 - **降低资源消耗。**通过重复利用已创建的线程降低线程创建和销毁造成的消耗 - **提高响应速度。**当任务到达时，任务可以不需要等到线程创建就可以立即执行 - **提高线程的可管理性。**线程是稀缺资源，大量创建会导致系统资源过度消耗且会降低系统的稳定性，线程池可以有效控制线程数，并进行统一的分配、调优和监控。 ### 4. 线程池的分类以及各自的特性 利用`Executors`类提供了四种不同的线程池，他们都是直接或者间接配置`ThreadPoolExecutor`来实现功能。下面分别介绍着四个线程池 `newFixedThreadPool` > 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就不会发生变化，如果某个线程因为异常而结束，则会补充一个新进程。 > > 由于只设置核心线程大小，所以可以**更快的响应外界请求** > > 线程池的大小设置，可以使用`Runtime.getRuntime().availableProcessors()` - 实现源码 ```java /** * 设置了核心线程，并且没有超时机制，使用LinkedBlockingQueue则任务队列大小是无上限的 */ public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } ``` - 样例演示 ```java public static void fixedThreadPoolDemo(){ ExecutorService fixedThreadPool= Executors.newFixedThreadPool(3); for (int i = 0; i 可根据需要创建新线程的线程池，但是在一起构造的线程可用时将重用他们。对于很多短期异步任务的程序而言，这类线程池可以提高性能。 > > 如果现有线程没有可用的，则会创建一个新的线程并添加到池中，终止并从缓存中移除那些超过60s没有使用的线程。**因此，长时间保持空闲的newCachedThreadPool线程池是不存在任何线程的，所以这时候几乎不占用系统资源。** - 实现源码 ```java /** * 核心线程数为0 线程最大为Int的最大值所以可以认定为线程池最大线程无限大，设置了超时时间为60s。任务队列采用了阻塞队列(必须池内有空闲线程才可以执行) */ public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue()); } ``` - 样例演示 ```java public static void cachedThreadPoolDemo(){ ExecutorService cachedThreadPool= Executors.newCachedThreadPool(); for (int i = 0; i 创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。 - 实现源码 ```java public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } /** * 核心线程数固定，非核心线程数为无限大，当非核心数处于闲置状态的时候会被立即回收 */ public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } ``` - 样例演示 ```java public static void scheduleThreadPoolDemo() { ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3); //延迟一定时间后执行Runnable任务 scheduledThreadPool.schedule(new Runnable() { @Override public void run() { System.err.println(Thread.currentThread().getName() + " delay 2s"); } }, 2, TimeUnit.SECONDS); //延迟一定时间后执行Callable任务 scheduledThreadPool.schedule(new Callable() { @Override public Object call() throws Exception { return null; } }, 2, TimeUnit.SECONDS); //延迟一定时间（initialDelay）后,以(period)时间间隔执行任务 scheduledThreadPool.scheduleAtFixedRate(new Runnable() { @Override public void run() { System.err.println(Thread.currentThread().getName() + " every 3s"); } }, 1, 1, TimeUnit.SECONDS); //延迟一定时间（initialDelay）后,以(delay即上一个任务执行结束到下一个任务开始的间隔)执行 scheduledThreadPool.scheduleWithFixedDelay(new Runnable() { @Override public void run() { System.err.println(Thread.currentThread().getName() + " delay 3s"); } }, 1, 1, TimeUnit.SECONDS); } 运行结果： pool-1-thread-1 every 3s pool-1-thread-2 delay 3s pool-1-thread-3 delay 3s 1 pool-1-thread-2 every 3s ``` - 适用场景 用于需要多个后台线程执行周期任务，同时需要限制线程数量 `newSingleThreadExecutor` > 创建一个单线程池，该线程池中只有一个线程在工作，其他任务都会依次在任务中排列中等候依次执行，任务是串行执行的。此线程池保证所有的任务的执行顺序按照任务提交顺序执行(FIFO-先进先出)。 - 实现源码 ```java /** * 只有一个核心线程，对任务队列没有大小限制，将所有外界任务统一到一个线程执行所有我们不需要处理线程同步的问题。 */ public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())); } ``` - 样例演示 ```java public static void singleThreadPoolDemo(){ ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor(); for (int i = 0; i < 6; i++) { final int index = i; singleThreadExecutor.execute(new Runnable() { @Override public void run() { System.err.println(Thread.currentThread().getName() + " , index = " + index); } }); try { Thread.sleep(1000); } catch (Exception e) { e.printStackTrace(); } } } 运行结果：所有的任务都是在pool-1-thread-1中依次运行 pool-1-thread-1 , index = 0 pool-1-thread-1 , index = 1 pool-1-thread-1 , index = 2 pool-1-thread-1 , index = 3 pool-1-thread-1 , index = 4 pool-1-thread-1 , index = 5 ``` - 适用场景 用于串行执行任务的场景，每个任务需要顺序执行 ### 5. 线程池的执行流程 {% fullimage /images/study_plan/threadpool_process.png, 线程池执行流程图,线程池执行流程图 %} 1. 判断corePoolSize(核心线程数)是否已到达，没到达则可以创建一个新线程执行任务 2. 判断工作队列是否已满，没满则添加入队列等待执行 3. 判断maximum(最大线程数)是否已到达，没到达则创建一个新线程执行任务。已满则执行拒绝策略。 ### 6. 线程池的使用注意 1. 线程池不要用`Executors`的方式去创建，应该利用`ThreadPoolExecutor`的方式，这样可以帮助更好理解实现方式以及避免资源消耗过度的问题。 **`fixThreadPool以及singleThreadPool`,由于设置的等待队列长度为Integer.MAX_VALUE，导致大量请求堆积，消耗大量资源。** **`cachedThreadPool以及scheduledThreadPool`,由于运行允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的请求，消耗大量资源。** 2. 针对具体情况去配置线程池参数，不同的任务类别应采用不同规模的线程池，任务类别分为3种： - **`CPU密集型任务(需要进行大量计算，处理)`**：线程池中线程个数尽量少，不应大于CPU核心数，避免出现每个线程都需要长时间使用但是线程过多去抢占资源。 - **`IO密集型任务(主要时间都在IO，CPU空闲时间比较多)`**：线程池可以配置尽量多的线程，由于CPU大部分时间空闲，可以提高CPU的利用率。 - **`混合型任务`**：如果可以拆分，则拆分成一个CPU密集型以及IO密集型任务，只要执行任务效率相差不大。若相差太大则没必要拆分。 ### 7.补充知识 1. `submit()`和`execute()`区别 `submit()`返回一个`future`，根据`future`可以判断任务是否完成--实现`Callable`接口 `execute()`无返回值。只是执行了任务，不知道结果如何 -- 实现`Runnable`接口 [参考链接](https://mp.weixin.qq.com/s?__biz=MzI3OTU0MzI4MQ==&mid=2247486818&idx=1&sn=5d5f87cceadb062c3502cd7a1e2d3e0a&chksm=eb4761fcdc30e8ea3de28eca8c16ce305336852534dbd23edb348b5c1e02334dee025ea8f7bf&mpshare=1&scene=23&srcid=12117GQN5ZAnFwJRhSpKAcO1%23rd)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler机制源码解析]]></title>
    <url>%2F2018%2F05%2F14%2FHandler%E6%9C%BA%E5%88%B6%E5%8D%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: Handler机制源码解析 date: 2018-05-14 23:13:32 tags: 源码解析 top : 10 --- # 主要的内容包括Handler的机制以及四个组成部分和源码的分析 > 下面的代码分析都是基于Android8.0 - Oreo的源代码 > ## 1. 消息机制简介 在应用启动时，会执行`main()`方法，`main()`会创建一个Looper对象，然后开启一个死循环，目的是**不断从消息队列`MessageQueue`里面取出`Message`对象并处理。** 在Android中使用消息机制，会优先想到的是Handler。Handler可以轻松的将一个任务切换到Handler所在的线程去执行。在多线程的应用场景中，**可以将工作线程中需要更新UI的操作信息传递到主线程去执行**，从而实现工作线程更新UI的操作，最终实现异步消息的处理。 {% fullimage /images/study_plan/handler_process.png, Handler执行流程图,Handler执行流程图 %} ## 2. Handler机制模型 消息机制主要包含**Handler、Message、MessageQueue，Looper**这四个类。 - **Handler**：消息辅助类。主要功能将`Message`对象发送到`MessageQueue`中，同时将自己的引用赋值给`Message#target`(Handler.sendMessage())。也可以实现`handleMessage()`方法处理回调。 - **Message**：消息实体。需要传递的消息也可以传递数据。 - **MessageQueue**：消息队列。**内部实现并不是队列，而是利用单链表去实现因为在插入和删除数据有优势。**用于存储Handler发给来的消息(`Message`)以及取出。`内部使用单链表实现` - **Looper**：与线程绑定，不止局限于主线程，绑定的线程来处理`Message`。不断循环执行`Looper.loop()`，从`MessageQueue`中读取`Message`，按分发机制将消息分发出去给目标处理(将`Message`发到`Handler.dispatchMessage`方法去处理)。 ## 3. Handler运行流程 {% fullimage /images/study_plan/handler_run_process.png, Handler运行流程图,Handler运行流程图 %} 工作流程：**异步通信准备==>消息入队==>消息循环==>消息处理** 1. **异步通信准备** > 假定在主线程创建Handler，则会直接在主线程中创建`Looper`,`MessageQueue`和`Handler`对象。**Looper和MessageQueue对象均属于其`创建线程`（由主线程创建则属于主线程）。**创建`Looper`时会自动创建`MessageQueue`对象，创建好`MessageQueue`对象后，`Looper`自动进入循环。`Handler`自动绑定`Looper`以及`MessageQueue`。 > > `Looper`对象的创建方法一般通过`Looper.prepareMainLooper()`和`Looper.prepare()`方法。 2. **消息入队** > 工作线程通过`Handler`发送`Message`到`MessageQueue`中。消息内容一般是UI操作，通过`Handler.sendMessage(Message message)`或`Handler.post(Runable r)`发送。加入`MessageQueue`一般通过`MessageQueue.enqueueMessage(Message msg,long when)`操作。 3. **消息循环** > 分为**消息出队**和**消息分发**两个步骤 > > - 消息出队：`Looper`从`MessageQueue`中循环取出`Message` > - 消息分发：`Looper`将取出的`Message`分发给创建消息的`Handler` > > **消息循环过程中，`MessageQueue`为空，则线程堵塞** 4. **消息处理** > `Handler`接受发过来的`Message`并处理。 ## 4. Handler使用过程的注意点 1. 在工作线程中创建自己的消息队列时必须要调用`Looper.prepare()`,并且**在一个线程中只可以调用一次**，然后需要调用`Looper.loop()`,开启消息循环。 > 在开发过程中基本不会调用上述方法，因为默认会调用主线程的Looper，然后一个线程中只能有一个Looper对象和一个MessageQueue。 2. **要注意Handler可能引起的内存泄漏**(在下面会介绍到为何会引发泄漏)。 错误的写法: ```java private final Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; ``` **非静态的内部类和匿名内部类都会隐式的持有其外部类的引用，而静态内部类不会持有外部类的引用。** 正确的写法： > 继承`Handler`时候要么放在单独的类文件中，要么直接使用静态内部类。 ```java //需要在静态内部类中调用外部类时，可以直接使用 `弱引用` 进行处理 private static final class MyHandler extends Handler{ private final WeakReference mWeakReference； public MyHandler(MyActivity activity){ mWeakReference = new WeakReference(activity); } @Override public void handlerMessage(Message msg){ super.handlerMessage(msg); MyActivity activity = mWeakReference.get(); } } //调用方法 private MyHandler mHandler = new MyHandler(this); ``` ## 5. Handler源码解析 1. **创建循环器对象（`Looper`）和创建消息队列对象(`MessageQueue`)** > 创建Looper对象主要有两个方法：`Looper.prepareMainLooper()`和`Looper.prepare()` > > 创建MessageQueue对象方法：**创建Looper对象时会自动创建MessageQueue** ```java // 源码位置:../core/java/android/os/Looper.java final MessageQueue mQueue; final Thread mThread; //Looper对象创建时会自动创建一个MessageQueue对象。 private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } //为当前线程(子线程)创建一个Looper对象 需要在子线程中主动调用该方法 public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { //判断sThreadLocal是否为null，不为空则直接跑出异常 可以保证一个线程只可以调用一次prepare方法 if (sThreadLocal.get() != null) { throw new RuntimeException("Only one Looper may be created per thread"); } sThreadLocal.set(new Looper(quitAllowed)); } //为主线程创建一个Looper对象 该方法会在主线程创建时自动调用 public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException("The main Looper has already been prepared."); } sMainLooper = myLooper(); } } ``` 总结： 1. 创建`Looper`对象时会自动创建`MessageQueue`对象 2. 主线程的Looper对象是自动生成的，而子线程需要调用`Looper.prepare()`创建`Looper`对象 > 创建主线程是调用了`ActivityThread`的`main()`方法。 > > 然后按照流程调用了`Looper.prepareMainLooper()`和`Looper.loop()`。所以主线程不需要调用代码生成Looper对象。 ```java //源码位置: ../core/java/android/app/ActivityThread.java public static void main(String[] args) { ... Looper.prepareMainLooper(); Looper.loop(); ... } ``` 3. Handler的主要作用是(`在主线程更新UI`)，所以**Handler主要是在主线程创建的**。 4. Looper与Thread是通过`ThreadLocal`关联的。由于`ThreadLocal`是与线程直接关联的，参考`prepare()`。 5. 子线程创建Handler对象:无法在子线程直接调用Handler无参构造方法**Handler创建时需要绑定Looper对象** 。需要使用`HandlerThread`。 2. **开启Looper即消息循环** > 创建了`Looper和MessageQueue`对象后，自动进入消息循环，使用`Looper.loop()`方法开始消息循环。 ```java //源码位置：../core/java/android/os/Looper.java public static void loop(){ //现获取Looper实例，保证调用loop时已有Looper，否则抛出异常 final Looper me = myLooper(); if (me == null) { throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); } //获取对应Looper实例创建的MessageQueue对象 final MessageQueue queue = me.mQueue; ... //开启消息循环-无限循环 for (;;) { //从MessageQueue取出Message对象 Message msg = queue.next(); // might block //取出消息为null，则退出循环 if (msg == null) { // No message indicates that the message queue is quitting. return; } //把Message分发给相应的target try { msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } //释放消息占据的资源 msg.recycleUnchecked(); } } ``` 3. **创建Handler对象** >创建Handler对象即可以进行消息的发送与处理 ```java //源码位置：.../core/java/android/os/Handler.java //Handler默认构造方法 public Handler() { this(null, false); } public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) && (klass.getModifiers() & Modifier.STATIC) == 0) { Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); } } //从当前线程的ThreadLocal获取Looper对象 mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); } //获取当前Looper的消息队列 mQueue = mLooper.mQueue; mCallback = callback; //设置消息是否为异步处理方式 mAsynchronous = async; } public Handler(Looper looper, Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } ``` `Handler的无参构造方法会默认关联当前线程的Looper对象和MessageQueue对象，设置callback回调方法为null，且消息处理方式为同步处理。` 4. **创建消息对象** >Handler发送Message并且进入MessageQueue循环，创建方式分为两种`new Message()`和`Message.obtain()`。通常使用`Message.obtain()`。这种方式**有效避免创建重复Message对象**。 ```java //创建消息对象 Message msg = Message.obtain(); msg.what = 1; msg.obj = "test"; //源码位置 .../core/java/android/os/Message.java /** Constructor (but the preferred way to get a Message is to call {@link #obtain() Message.obtain()}). */ //new Message 方法 public Message() { } private static final Object sPoolSync = new Object(); //维护一个Message池，用于复用Message对象 private static Message sPool; //obtain方法 直接从池内获取Message对象，避免new占用内存 public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; //直接从池中取出 return m; } } //无可复用对象，则重新new获取 return new Message(); } ``` 5. **发送消息(Message)** > Handler主要有以下几种发送消息的方式: > > - `sendMessage(Message msg)` > - `sendMessageDelayed(int what, long delayMillis)` > - `post(Runnable r)` > - `postDelayed(Runnable r, long delayMillis)` > - `sendMessageAtTime(Message msg, long uptimeMillis) ` > > 最终都是会调用到`sendMessageAtTime(Message msg, long uptimeMillis)`然后继续调用到`enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)`放入MessageQueue ```java //源码位置：.../core/java/android/os/Handler.java //post方法 public final boolean post(Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } public final boolean postAtTime(Runnable r, long uptimeMillis) { return sendMessageAtTime(getPostMessage(r), uptimeMillis); } public final boolean postAtTime(Runnable r, Object token, long uptimeMillis) { return sendMessageAtTime(getPostMessage(r, token), uptimeMillis); } public final boolean postDelayed(Runnable r, long delayMillis) { return sendMessageDelayed(getPostMessage(r), delayMillis); } //利用post()方式发送消息，需要转换为Message向下传递 private static Message getPostMessage(Runnable r, Object token) { Message m = Message.obtain(); m.obj = token; //将runnable赋值到callback上 以便后续判断是post还是sendMessage方式发送的消息 m.callback = r; return m; } //sendMessage方法 public final boolean sendMessage(Message msg) { return sendMessageDelayed(msg, 0); } public final boolean sendMessageDelayed(Message msg, long delayMillis) { if (delayMillis < 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } //所有的发送消息有关方法 都会调用到这个方法 public boolean sendMessageAtTime(Message msg, long uptimeMillis) { //获取MessageQueue对象 MessageQueue queue = mQueue; //获取对象为空 抛出异常 if (queue == null) { RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; } //对象不为空 调用enqueueMessage方法 return enqueueMessage(queue, msg, uptimeMillis); } //该方法为了 向MessageQueue插入Message private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { // 把当前的Handler设置为 消息标记位 即把消息派发给相对应的Handler实例 msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } //调用MessageQueue的enqueueMessage方法 return queue.enqueueMessage(msg, uptimeMillis); } ``` ```java //源码位置：..core/java/android/os/MessageQueue.java //内部是一个单链表有序序列，由 Message.when 作为排序依据，该值为一个相对时间。 boolean enqueueMessage(Message msg, long when) { ... synchronized (this) { //正在退出 回收Message if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; // p == null判断当前队列中是否有消息，插入消息作为队列头 // when == 0||when < p.when 队列当前处于等待状态 唤醒队列 if (p == null || when == 0 || when < p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. //当前队列有消息，按照消息创建时间插入到队列中 needWake = mBlocked && p.target == null && msg.isAsynchronous(); Message prev; //从对列头部开始遍历 for (;;) { prev = p; p = p.next; //循环到队列尾部或者出现一个when小于当前Message的when if (p == null || when < p.when) { break; } if (needWake && p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } ``` 总结： - 发送消息时`Message.when`表示期望该消息被分发的时间即`SystemClock.uptimeMillis() + delayMillis`。`SystemClock.uptimeMills`代表自系统开机到调用到该方法的时间差。 - `Message.when`利用时间差来表达期望事件分发的时间，所以使用的是一个相对时间。 6. **获取消息** > 发送了消息后，MessageQueue维护了消息队列，在Looper中通过`loop()`不断获取Message。通过`next()`获取Message. ```java //源码位置：..core/java/android/os/MessageQueue.java Message next(){ //该参数用于确定消息队列中是否有消息 下一个消息到来前需要等待的时长 int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } //该方法位于native层 若nextPollTimeoutMillis为-1 代表消息队列处于等待状态 阻塞操作 nativePollOnce(ptr, nextPollTimeoutMillis); ... synchronized (this) { ... Message msg = mMessages; if (msg != null) { if (now < msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; //标记消息使用状态 flag |= FLAG_IN_USE msg.markInUse(); //返回一条消息 return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } //消息正在退出 if (mQuitting) { dispose(); return null; } } } } ``` 7. **分发消息** > 分发消息到对应的Handler实例并根据传入的Message做对应的操作 ```java //源码位置：.../core/java/android/os/Handler.java public void dispatchMessage(Message msg) { //若callback不为空，则代表使用了post(Runnable r)方式发送了消息，执行handleCallback方法 if (msg.callback != null) { handleCallback(msg); } else { //代表使用了sendMessage()方式发送了消息，调用handleMessage方法 if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } //创建Handler实例时复写 自定义消息处理方法 public void handleMessage(Message msg) { } //直接回调runnable对象的run() private static void handleCallback(Message message) { message.callback.run(); } ``` 总结： - `msg.target.dispatchMessage(msg)`中`msg.target`指向的就是对应Handler实例， - 消息分发的优先级： 1. Message的回调方法`message.callback.run()` 2. Handler中Callback的回调方法`mCallback,handleMessage(msg)` 3. Handler的默认方法`handleMessage()` 8. **Message回收** > 上面讲到了新建Message推荐使用`obtain()`，因为可以有效的复用消息，其中里面复用的就是`sPool`变量，它是在Message回收的时候进行赋值的。 ```java //源码位置 .../core/java/android/os/Message.java /*package*/ boolean isInUse() { return ((flags & FLAG_IN_USE) == FLAG_IN_USE); } public void recycle() { //正在使用 无法回收 if (isInUse()) { if (gCheckRecycle) { throw new IllegalStateException("This message cannot be recycled because it " + "is still in use."); } return; } recycleUnchecked(); } void recycleUnchecked() { // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. //置为使用标记 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; //将Message放在了列表里，缓存的对象由obtain()拿出来复用 synchronized (sPoolSync) { if (sPoolSize < MAX_POOL_SIZE) { next = sPool; sPool = this; sPoolSize++; } } } ``` 9. **Looper退出** > `Looper.loop()`内部由一个无限循环组成，默认情况下不会退出循环。需要退出就需要调用`quit()`或者`quitSafely()`。 ```java //源码位置 .../core/java/android/os/Looper.java public void quit() { mQueue.quit(false); } public void quitSafely() { mQueue.quit(true); } //源码位置 .../core/java/android/os/MessageQueue.java void quit(boolean safe) { if (!mQuitAllowed) { throw new IllegalStateException("Main thread not allowed to quit."); } synchronized (this) { if (mQuitting) { return; } mQuitting = true; if (safe) { removeAllFutureMessagesLocked(); } else { removeAllMessagesLocked(); } // We can assume mPtr != 0 because mQuitting was previously false. //唤醒等待线程 nativeWake(mPtr); } } //直接移除MessageQueue中的所有消息 private void removeAllMessagesLocked() { Message p = mMessages; while (p != null) { Message n = p.next; //回收未被处理的消息 p.recycleUnchecked(); p = n; } //由于消息为null 则return 出无限循环 mMessages = null; } //直接移除未处理的消息 已经在执行的继续处理 private void removeAllFutureMessagesLocked() { final long now = SystemClock.uptimeMillis(); Message p = mMessages; if (p != null) { //还未处理的Message if (p.when > now) { removeAllMessagesLocked(); } else { Message n; for (;;) { n = p.next; if (n == null) { return; } if (n.when > now) { break; } p = n; } //不接收后续消息 p.next = null; do { p = n; n = p.next; p.recycleUnchecked(); } while (n != null); } } } ```]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的GC分析-Dalvik和ART虚拟机]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E4%B8%AD%E7%9A%84GC%E5%88%86%E6%9E%90-Dalvik%E5%92%8CART%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[--- title: Android中的GC分析-Dalvik和ART虚拟机 date: 2018-05-13 10:10:54 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XV -- 四大组件]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid-Study-Plan-XV%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XV -- 四大组件 date: 2018-05-13 09:50:49 tags: Android --- # Android学习计划 ## Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？ ### Android四大组件： 1. **`Activity`** > Activity的主要作用是展示一个界面并和用户直接交互。 activity的启动由Intent触发（**需要在AndroidManifest.xml中注册**）。Intent分为两种： - 显示Intent：直接跳转至指定的Activity类 ```java // 构造方法中直接传入Component Intent intent=new Intent(this,Activity.class); startActivity(intent); // 调用SetComponent方法 ComponentName componentName=new Component(this,Activity.class); Intent intent=new Intent(); intent.setComponentName(componentName); startActivity(intent); // 使用setClass方法 Intent intent=new Intent(); intent.setClassName(this,Activity.class); startActivity(intent); ``` - 隐式Intent：不明确指定启动哪个Activity，而是利用Activity配置的Action，Data，Category来让系统进行选择(`筛选是根据所有的来筛选`) ```java // setAction方法 Intent intent=new Intent(); intent.setAction("TestActivity"); startActivity(intent); //直接构造Action Intent intent=new Intent("TestActivity"); startActivity(intent); //在使用隐式调用时需要注意该Action是否存在,所以需要做try-catch防止异常发生 //利用这个方法可以判断是否有处理该Action的Activity存在 intent.resolveActivity(getPackageManager()) ``` 2. **`Service`** Service主要用于在后台执行一系列需要耗时的任务，需要单独的线程去完成，因为Service本身是运行在主线程的。Service不会与UI进行交互，其他的组件也可以启动Service，即便用户切换了应用，Service依然后台运行。（**需要在AndroidManifest.xml中注册**），Service有两种启动方式： - `startService`：启动一个Service，系统回调`onStartCommand()方法`，需要调用`stopService()`来停止Service - `bindService`：绑定一个Service，调用`unBindService()`来取消绑定，或者关闭绑定的组件也可以停止 3. **`BroadcastReceiver`** [完整介绍](https://www.jianshu.com/p/ca3d87a4cdf3) 广播主要用于在不同的组件甚至不用的应用间进行消息传递，不与用户产生交互，工作在系统内部。 广播的注册方式有两种： - 静态注册 （**需要在AndroidManifest.xml中注册**） ```xml ``` - 动态注册 ```java //最好在onResume中注册广播 @Override protected void onResume(){ super.onResume(); mBroadcastReceiver=new BroadcastReceiver(); IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction("com.test"); this.registerReceiver(mBroadcastReceiver,intentFilter); } //在onPause中取消注册 @Override protected void onPause(){ super.onPause(); this.unregisterReceiver(mBroadcastReceiver); } ``` 4. **`ContentProvider`** [相关链接](https://www.jianshu.com/p/ea8bc4aaf057) 主要用于给不同的应用提供共享数据,（**需要在AndroidManifest.xml中注册**） ```xml ``` ContentProvider默认执行在主线程，需要实现以下方法 - `onCreate()`：初始化Provider - `query()`：查询数据 **需异步操作** - `insert()`：插入数据 - `update()`：更新Provider的数据 - `delete()`：删除Provider的数据 - `getType()`：返回指定Uri中的数据MIME类型 相关的操作可能会被多个线程并发调用需要注意线程安全。 ### 开启多进程 Android的四大组件都可以开启多进程，只要在AndroidManifest.xml中配置`android:process="any"`，需要配置`android:exported`属性]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(五) -- Java内存模型]]></title>
    <url>%2F2018%2F05%2F09%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展(五) -- Java内存模型 date: 2018-05-09 19:11:37 tags: JVM top: 11 --- # Java内存模型 > 屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到的一致的内存访问效果。 主要目标： **定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。变量包括了实例字段、静态字段和构成对象的元素，但不包括局部变量和方法参数（他们为线程私有，不被共享）。** ## 主内存与工作内存 > Java内存模型规定了所有的变量都存储在`主内存(Main Memory)`中，每条线程还有自己的`工作内存(Work Memory)`。工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取，赋值等)必须在工作内存中进行，不能直接读取主内存的变量。**不同线程之间也无法直接访问对方工作内存中的变量，线程间传递变量均需通过主内存完成。** {% fullimage /images/JVM-JMM.png,线程-主内存-工作内存的交互关系,线程-主内存-工作内存的交互关系%} 主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。 ## 内存间交互操作 > 关于主内存与工作内存具体的交互协议，**即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，JMM中定义了8种操作来完成.** > > `每种操作都是原子、不可再分` > > | 类型 | 说明 | | ------------ | ------------------------------------------------------------ | | Lock(锁定) | 作用于主内存的变量，把一个变量表示为一条线程独占的状态 | | Unlock(解锁) | 作用于主内存的变量，把一个锁定状态的变量释放出来 | | Read(读取) | 作用于主内存的变量，一个变量值从主内存传输到线程的工作内存中 | | Load(载入) | 作用于工作内存的变量，从read操作中得到的值放入工作内存的变量副本中 | | Use(使用) | 作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行 | | Assign(赋值) | 作用于工作内存的变量，把接收到的值赋值给工作内存中的变量，遇到需要赋值的情况会执行 | | Store(存储) | 作用于工作内存的变量，把工作内存中的变量值传到主内存中 | | Write(写入) | 作用于主内存的变量，把store操作中得到的工作内存中的变量的值放入主内存的变量中 | > 如果要把一个变量从主内存复制到工作内存，就要顺序执行`read`和`load`操作，如果要从工作内存同步回主内存，就要顺序的执行`store`和`write`操作。 ## 原子性、可见性和有序性 > Java内存模型就是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。这也是并发编程的三大概念。 ### 原子性(Atomicity) > **对基本数据类型的读取和赋值都是原子操作**，所谓原子性操作就代指这些**操作是不可中断**的，要么做完，要么就不执行。 Java内存模型只保证了基本读取和赋值是原子操作。如果要实现更大范围操作的原子性，就需要通过`synchronized`和`lock`实现。 > Java中的原子操作包括： > > - 除long和double之外的基本数据类型赋值操作 *long和double占用的字节数是8即64bit，在32位操作系统上去读写数据需要两步完成，每一步取32位数据。需要添加volatile关键字保证* > - 所有引用reference的赋值操作 > - `java.concurrent.Atomic.*` 包下所有类的操作 ### 可见性(Visibility) > 当一个线程修改了共享变量的值，其他线程能够立即得知这个值的修改。 Java内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式实现可见性。 **当一个共享变量被volatile修饰时，他会保证修改的值会立即更新到主内存，当有其他线程需要读取时，会立即从主内存中读取新值。** 通过`synchronized`和`lock`也可保证可见性，**保证同一时刻只有一个线程获取锁然后执行代码，并且在释放锁之前会将变量的修改刷新到主内存中，保证可见性。** 拓展：`final`也可以实现可见性，final修饰字段一旦初始化完成，在其他线程中就可以看到fianl的值。 ### 有序性(Ordering) > 程序执行的顺序按照代码的先后顺序执行 Java内存模型允许编译器和处理器对指令进行重排序，但是规定了`as-if-serial`（不管怎么重排序，程序的执行结果不能改变）。 **指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。** `volatile`本身包含了禁止指令重排序的语义，而`synchronized`通过**一个变量在同一个时刻只允许一条线程对其lock操作**实现有序性。 ***要想并发程序正确的执行，必须要保证原子性、可见性和有序性，只要有一个没有被保证，就有可能导致程序运行不正确。*** ## 先行发生原则(happens-before) > JMM具备一些先天的`有序性`。**不需要通过任何手段就可以保证有序性，称之为`先行发生原则`。如果两个操作的执行次序无法从先行发生原则推导出来，他们之间就没有顺序性保障，就不能保证有序性。** 主要有以下规则： - **程序次序规则**：写在前面的代码先行发生于写在后面的(按照控制流顺序而不是代码顺序) - **管程锁定规则**：一个解锁操作先行于时间后面发生的同一个线程的加锁操作 - **volatile变量规则**：对一个volatile变量的写操作先行发生于读操作 - **线程启动规则**：Thread对象的`start()`优先于该线程的任意操作 - **传递性**：如果操作A早于B，B又早于C，则A早于C - **线程中断规则**：线程`interrupt()`调用早于该线程的中断检测。`Thread.interrupted()` - **线程终止规则**：线程中的所有操作都先行发生于对此线程的终止检测。`Thread.join()或者Thread.isAlive()` - **对象终结规则**：一个对象的初始化完成早于`finalize()`]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--HashMap实现原理及解析]]></title>
    <url>%2F2018%2F05%2F09%2FHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: 数据结构--HashMap实现原理及解析 date: 2018-05-09 13:03:31 tags: Java源码 top: 11 ---]]></content>
      <tags>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(四) -- 垃圾收集器与内存分配策略]]></title>
    <url>%2F2018%2F05%2F04%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展(四) -- 垃圾收集器与内存分配策略 date: 2018-05-04 13:25:05 tags: JVM top: 11 --- # 垃圾收集器与内存分配策略 ## 垃圾收集器 ### 1.概述 **垃圾收集(Garbage Collection,GC)：自动管理回收不再引用的内存数据**需要完成的三件事情： - 哪些内存需要回收 - 什么时候回收 - 如何回收 > Java语言会自动管理和回收不再引用的内存数据，由垃圾回收机制来完成。Java自身提供了内存管理机制，应用程序不需要去关注内存如何释放，内存用完后，GC会去自动进行处理，不需要人为干预出现错误。 在{% post_link JVM相关及其拓展 %}章节中介绍了JVM的内存区域。 **其中`程序计数器`、`虚拟机栈`，`本地方法栈`随线程而生，随线程而灭**。栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作，因此每一个栈帧分配多少内存基本是在类结构确定下来就已经是已知的。**因此这几个区域的内存分配和回收都具备确定性。所以不需要过多考虑回收的问题，在方法结束或者线程结束后，内存就随着回收了，也就实现了内存的自动清理。** **而`Java堆`和`方法区`则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序运行期间才知道会创建哪些对象，这部分的内存分配和回收是动态的。垃圾收集器关注的就是这部分的内存。** ### 2.判断对象是否可以回收 > 在堆里面存放着几乎所有的对象实例，垃圾收集器在回收前需要去判断对象是否还被引用来决定是否回收，即找到那些不再被任何途径使用的对象。 - **引用计数算法(Refrence Counting)** > 给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时候计数器为0的对象是不能再被引用的，可以被当做垃圾收集。 > > 优点：实现简单，判断效率高 > 缺点：无法检测出对象之间相互循环引用，开销大（会发生频繁且大量的引用变化，带来大量的额外运算）。 - **可达性分析算法(Reachability Analysis)** > 通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的节点为引用链，当一个对象到GC Roots没有任何引用链相连（从GC Roots到这个对象不可达）时，则证明此对象是不可用的。 {% fullimage /images/jvm/gc_reachability_analysis.png,可达性分析算法,可达性分析算法 %} 在Java语言中，可作为GC Roots的对象包括以下几种： - 虚拟机栈（栈帧中的本地变量表）中引用的对象 - 方法区中类静态属性引用的对象 - 方法区中常量引用的对象 - 本地方法栈中JNI引用的对象（Native对象） > 优点：更加精确严谨可以分析出循环引用的情况 > > 缺点：实现复杂，效率低，分析过程中需要GC停顿（因为应用关系不能发生改变，需要停止所有Java线程） ### 3.对象是生存还是死亡 > 真正宣告一个对象死亡，至少要经历两次标记过程 - **第一次标记**： 对象在进行可达性分析算法后没有发现与GC Roots相连接的引用链，将会被第一次标记并进行第一次筛选。筛选的条件是此对象是否有必要执行`finalize()`方法。 - 没必要执行 对象没有覆盖`finalize()`方法，或者`finalize()`方法已被虚拟机调用过。 - 有必要执行 对象会被放置在一个F-Queue的队列中，稍后会由一个JVM自动建立的、低优先级的Finalizer线程去执行。 - **第二次标记：** GC对F-Queue中的对象进行第二次小规模的标记，`finalize()`是对象摆除被回收的最后方法 - 若对象要避免自己被回收，需要重新与引用链上的任何一个对象建立关系即可，譬如把自己（this）赋值给某个变量或者对象的成员变量，那就会移除被回收的集合 - 如果没有摆除，则基本上会被回收。任何一个对象的`finalize()`方法只会被系统自动调用一次，再次调用`finalize()`方法则不会再次执行。 ```java public class FinalizeEscapeGC { public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() { System.err.println("It is live"); } @Override protected void finalize() throws Throwable { super.finalize(); System.err.println("finalize is executed"); FinalizeEscapeGC.SAVE_HOOK = this; } public static void main(String[] args) throws Throwable { SAVE_HOOK = new FinalizeEscapeGC(); SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.err.println("It is over"); } //将对象的引用链重新置为null，则拯救失败 SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.err.println("It is over"); } } } ``` - **`finalize()`** 运行代价高昂，不确定性大，无法保证各个对象的调用顺序。 ### 4.回收方法区 > 永久代的垃圾收集主要分为两部分：**废弃常量和无用的类** > > **废弃常量**：假如常量池中存在一个常量，但是没有任何对象引用该常量，在发生回收的时候，该常量就会被系统清理出常量池，常量池中的其他类（接口）、方法、字段的符号引用类似。 > > **无用的类**：需要同时满足以下条件 > > 1. 该类的所有实例已被回收，Java堆中不存在该类的任何实例 > 2. 加载该类的ClassLoader已被回收 > 3. 该类对应的Class对象没有在任何地方被引用，也无法在任何地方通过反射访问到该类的方法 ### 5.垃圾收集算法 1. **标记-清除算法(Mark-Sweep) 最基础的收集算法** > 算法分为`标记`和`清除`两个阶段，**首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象**。主要不足有两个：一个是效率问题（`标记和清除两个过程的效率都不高`）；另一个是空间问题（`标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作`）。 {% fullimage /images/jvm/gc_mark_sweep.png ,标记-清除算法,标记-清除算法%} 2. **复制算法(Copying)** > 将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象移到另一块上面，然后把已使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时就不需考虑内存碎片等情况。 > > 缺点：可用内存会减少一半；效率会随存活对象的升高而降低（当对象存活率较高的时候，需要更多的copy操作，导致效率降低） {% fullimage /images/jvm/gc_copying.png,整理算法,整理算法 %} 现在的商业虚拟机都采用这种收集算法来回收新生代。 提供了改良算法（基于**弱代理论①**）：不是按照1:1的比例去划分内存空间，而是分为较大的Eden空间和两块较小的Survivor空间，在回收时将Eden和Survivor存活的对象移至到另一块Survivor空间上。**HotSpot中Eden和Survivor的大小比例为8:1。**`在一般场景下足够使用，当Survivor空间不够使用时，需要依赖其他内存(代指老年代)进行分配担保②`。 > ①**弱代理论**：1. 大多数分配了内存的对象存活不会太久，在年轻代就会死掉；2. 很少有对象从年老代变成年轻代。 > > ②**分配担保**：如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。 3. **标记-整理算法(Mark-Compact)** > 标记过程与“标记-清除”算法一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理端边界以外的内存。 {% fullimage /images/jvm/gc_mark_compact.png,标记-整理算法,标记-整理算法%} > 优点：1. 效率不随对象存活率升高而降低。 2. 不像标记-清除算法会产生大量的内存碎片（因为会进行一次整理，将存活对象集中到一端）。 > > 缺点：除了需要进行标记，还需要整理过程，执行效率更低。 4. **分代收集算法(Generational Collection)** > 根据对象存活周期的不同将内存划分为几块，一般是把Java堆分成新生代和老年代~~和持久代(JDK8中移除)~~，这样就可以根据各个年代的特点采用最适当的收集算法。 > **新生代**中每次垃圾收集都会有大量的对象被回收，只有少量存活，就可以使用复制算法。 > > **老年代**中因为对象存活率较高，没有额外空间进行分配担保，所以必须使用“标记-清理”或者“标记-整理”算法。 - **新生代(Young Generation)**：所有新生对象都会放在新生代，新生代的目标是尽快收集生命周期短的对象，每次GC过后只有少量存活。新生代发生的GC叫做**`Minor GC（频率较高，新生代Eden区满才触发）`**。新生代细分为`Eden、From Survivor、To Survivor`三块空间（三块空间大小并非均分，默认比例为8:1:1）。 - **老年代(Tenured Generation)**：新生代发生几次GC后依然存活的对象会放到老年代中，所以老年代中的对象生命周期较长。内存也比新生代大很多（大概2:1）,当老年代内存满时会触发**`Full GC/Major GC(针对新生代和老年代触发，经常会伴随至少一次的Minor GC，收集频率较低且耗时长，一般慢10倍以上)`**。 - ~~**持久代(Permanent Generation)**~~：用于存放静态文件，如Java类，方法等，对GC没有影响。 - **拓展**：别处也有介绍 Full GC针对整个堆空间（包含新生代，老年代，永久代（如果包含））的回收。而Major GC是针对老年代的内存回收。 - **Minor GC**：新生代是堆的一部分，对象首先在新生代中分配。新生代填满时，垃圾收集器会暂停所有的应用程序，回收新生代空间。不再使用的对象会被回收，仍然使用的对象移动至其他地方。 - **Full GC:** 对象不断地移至老年代，最终老年代也被填满，JVM需要找到老年代不再使用的对象并进行回收。会导致长时间停顿。 {% fullimage /images/jvm/gc_java_heap_memory.png,Java堆内存,Java堆内存 %} ### 6.垃圾收集器 > 收集算法是内存回收的方法论，垃圾收集器就为内存回收的具体实现。 {% fullimage /images/jvm/gc_collectors.png,垃圾收集器,垃圾收集器 %} 根据上图分析新生代收集器主要是：**Serial收集器,ParNew收集器,Parallel Scavenge收集器和G1收集器**。老年代收集器为**CMS收集器，Serial Old收集器，Parallel收集器和G1收集器**。 在两个收集器之间存在连线，则意味着他们之间可以搭配使用。 - `Serial收集器` > 该收集器是最基本、发展历史最悠久的收集器。这个收集器是一个**单线程**收集器（`不仅是他只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是他在进行垃圾收集时必须停止其他的工作线程(Stop The World)，直到收集结束。进行Full GC时，还会对老年代空间对象进行压缩整理。`）。 是虚拟机运行在Client端的默认新生代收集器 有着优于其他收集器的地方： - **简单而高效** - **没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集效率** 关键控制参数： - -XX:SurvivorRatio：设置两个Survivor区和Eden区的比值(**8表示 1:1:8**) - -XX:PretenureSizeThreshold：设定对象超过多少岁时进入老年代 - -XX:HandlePromotionFailure：设置是否允许担保失败 - `ParNew收集器` > ParNew收集器其实是Serial收集器的多线程版本。除了使用多线程进行垃圾收集之外，其他科Serial收集器完全一样。 该收集器是运行在Server模式下的虚拟机中的首选的新生代收集器，其中有一个重要的原因就是：**除了Serial收集器外，目前只有它能和CMS收集器配合工作。**随着可以使用的CPU数量增加，GC时系统资源的有效利用还是有好处的。**默认开启的收集线程数与CPU的数量相同** > **并行（Parallel）**：指多条垃圾收集器线程并行工作，但此时用户线程仍处于等待状态 > > **并发（Concurrent）**：指用户线程与垃圾收集器同时执行，用户程序仍继续运行，而垃圾收集器执行于另一个CPU上。 关键控制参数： - -XX:UserParNewGC：是否开启ParNew收集器 - `Parallel Scavenge收集器` > Parallel Scavenge收集器是一个新生代收集器，使用了复制算法以及并行的多线程收集器。 该收集器的目标是：**达到一个可控制的吞吐量（ThroughPut）**①。 停顿时间越短越适合需要与用户交互的程序，良好的响应速度可以提升用户体验，高吞吐量就可以高效率的利用CPU时间，主要适合在后台运算而不需要太多交互的任务。 > `吞吐量`：CPU用于运行用户代码时间与CPU总消耗时间的比值。 关键控制参数： - -XX:UseAdaptiveSizePolicy：开关参数，当打开时就不需要去指定新生代大小以及Eden与Survivor比例，晋升老年代对象岁数大小等参数，触发**GC自适应调节策略**(`虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数已提供最适合的停顿时间或者最大的吞吐量`) - `Serial Old收集器` > 是Serial收集器的老年代版本，同样是一个单线程收集器。使用“标记-整理算法” 该收集器主要为了给Client模式下的虚拟机使用。如果在Server模式下，还有以下用途： - 在JDK1.5及之前的版本搭配Paraller Scavenge收集器 - 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用 - `Parallel Old收集器` > 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”。 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑`Parallel Scavenge + Parallel Old`组合。 - **`CMS收集器（Concurrent Mark Sweep）`** > 以获取最短回收停顿时间为目标的收集器。基于“**标记-清除算法**”实现。整体上来说内存回收过程是与用户线程一起并发执行的。 运作过程比较复杂，分为4个步骤： - **初始标记**：仅仅标记一下GC Roots能关联到的对象，速度很快 `触发Stop The World` - **并发标记**：进行GC Roots Tracing的过程 - **重新标记**：修正并发标记期间因用户程序继续运做而导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记长一些，但短于并发标记时间 `触发Stop The World` - **并发清除**：可以和用户线程一起工作 {% fullimage /images/jvm/gc_collectors_CMS.png,CMS,CMS %} CMS收集器有3个明显的缺点： 1. **对CPU资源非常敏感** **面向并发设计的程序都对CPU资源比较敏感**。在并发阶段，虽然不会导致用户线程停顿，但是会因为占了一部分CPU资源而导致线程变慢，吞吐量会降低。`CMS默认启动的回收线程数量为(CPU数量+3)/4` 2. **无法处理浮动垃圾（Floating Garabge）** 由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就有新的垃圾产生，即`浮动垃圾(这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉他们，只能留到下一次GC进行清理)`。 因此CMS收集器不能像其他收集器一样等到老年代几乎完全满了在进行收集，需要预留一部分空间提供并发收集时使用。 JDK1.5默认设置下，CMS收集器到老年代到了68%即会激活，到1.6时提高到了92%。 要是CMS运行期间预留的内存无法满足程序需要，就会出现一次`Concurrent Mode Failure`失败，虚拟机将会启动后备预案：**临时启用Serial Old收集器来重新进行老年代的垃圾收集，停顿时间就会变得很长了。** 3. **产生的空间碎片** 由于CMS是基于“标记-清除”算法实现的收集器。这种方式会产生大量的空间碎片，碎片过多时将会给对象分配来很大麻烦，往往会出现老年代还有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。 关键控制参数： - -XX:CMSInitiatingOccupancyFraction：设置CMS触发阈值即老年代对象占用空间 - **`G1收集器`** > 全称Garbage-First收集器，通过-XX:+UseG1GC参数来启用，在JDK9中，被提议为默认收集器。`在JDK10中，把单线程的Full GC改良为了多线程Full GC` G1收集器是一款面向服务端的垃圾收集器，设计目标是为了取代CMS收集器。具备如下特点： - **并行与并发**：使用多个CPU来缩短停顿时间，也会通过并发的方式让Java程序继续运行 - **分代收集**：分代概念在G1中得以保留，可以不需要其他的收集器配合管理整个堆，可以采用不同的方式去处理新创建的对象和旧对象。 - **空间整合**：整体基于“标记-整理”算法，局部（两个Region之间）采用“复制”算法实现 - **可预测的停顿**：除了追求低停顿外，还可建立可预测的时间停顿模型，用户可以指定期望停顿的时间 #### Region 在G1收集器之前其他收集器进行收集的范围都是整个新生代或者老年代，而G1可以通用。使用G1收集器，Java堆的内存布局就与其他收集器不同，将整个Java堆划分为多个大小相等的独立区域（Region），虽然保留了新生代老年代的概念，但他们都变成了一部分Region的集合。 #### 可停顿的时间模型 可以实现有计划的避免在整个Java堆中进行全区域的垃圾收集。跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region空间。可以保证G1收集器在有限时间内获得尽可能高的收集效率。 #### Remembered Set Region不可能是独立的，由于可能会被其他对象引用。在G1中，Region之间的对象引用以及其他收集器中的新生代老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。每一个Region都会对应一个Remembered Set，虚拟机发现在对Reference进行读写操作时，产生一个`Write Barrier`暂时中断写操作，检查对象引用是否位于不同的Region中，若是则通过`CardTable`记录相关引用信息到Remembered Set中。**在进行内存回收时，在GC Roots中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。** #### **stop-the-world** 概念：**除GC所需线程外，多有线程都要进如等待状态，直到GC任务完成。** 解决方法：使用多个CPU来缩短停顿时间。 #### G1运作步骤 - **初始标记**：标记一下GC Roots能直接关联的对象，需要停顿线程 - **并发标记**：从GC Roots开始进行可达性分析，找出存活的对象耗时较长 - **最终标记**：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，需要停顿线程，可并行执行 - **筛选回收**：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间来指定回收计划。 **如果应用追求吞吐量，那并不会带来特别的好处** - `ZGC收集器` > 在Java11 中引入的新型收集器 ### 7.内存分配与回收策略 **对象的内存分配，就是在堆上进行分配。** > 对象优先在Eden分配,就是在JVM的堆上进行内存分配 > 大对象直接进入老年代 大对象代指 **需要连续内存空间的Java对象** > 长期存活的对象将进入老年代 当Eden区满了，在创建对象会触发Minor GC(**执行Minor GC时，Eden空间存活的对象会被复制到To Survivor·空间，并且之前经过一次Minor GC在From Survivor存活并年轻的对象也会被复制到To Survivor空间。如果存活对象的分代年龄超过阈值，则会晋升到老年代。**) > 动态对象年龄判定 为了更好的适应不同程序的内存状况，并不需要永远要求对象年龄必须达到`maxTenuringThreshold`才可以晋升老年代，**若在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。** > 空间分配担保 **如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。**]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-链表]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[--- title: 数据结构-链表 date: 2018-04-25 13:25:55 tags: 数据结构 --- # 数据结构-链表 > 链表是一种基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)，简单来说链表并不像数组存储在一个连续的内存地址空间里，他们可以是不连续的因为他们每个节点保存着下一个节点的引用（地址），所以较之数组来说这是一个优势。 ## 1.单链表 > 单链表是链表的一种，由节点组成，每个节点包含到下一个节点的指针。 > 单链表特点： > > - 链表增删元素时间复杂度度为O(1)，查找一个元素复杂度为O(n) > - 单链表不需要预先分配空间，避免空间浪费 > - 单链表不能进行回溯操作，例如读取倒数几个节点的值 {% fullimage /images/structures/single_linkedlist.png,单链表,单链表 %} ```java /** * 表示一个节点 */ public class Node { //数据域 public int data; //下一节点 public Node next; public Node() { } public Node(int data) { this.data = data; } public Node(int data, Node next) { this.data = data; this.next = next; } } ``` ### 单链表的基本操作 - 链表添加元素 - 添加头部 - 添加尾部 - 链表删除元素 - 删除指定位置 - 删除倒数第K个节点 - 链表查询元素 - 指定索引 - 查询倒数第K个节点 - 其他操作 - 寻找链表中间元素 - 旋转单链表 - 翻转单链表 - 单链表排序 - 冒泡排序 - 插入排序 - 链表相加求和 - 删除重复元素 ## 2.双循环链表]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(三) -- 虚拟机类加载器]]></title>
    <url>%2F2018%2F04%2F16%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展(三) -- 虚拟机类加载器 date: 2018-04-16 13:29:36 tags: JVM top: 11 --- # 1.虚拟机类加载器 ## 定义： 在类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码块称为“类加载器”。 例如：编写的是.java文件，代码运行后变成.class文件，类加载器就是加载.class文件。 ## Java类加载器分类： ### 1.系统提供的类加载器 - **Bootstrap ClassLoader(启动类加载器)**：由C/C++实现的加载器，用于加载虚拟机运行时所需要的系统类，如`java.lang.*、java.uti.*`等系统类。它负责将存放在\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。 这个加载器由于是C实现的，所以无法被Java程序直接引用。并且不继承`java.lang.ClassLoader`。 - **Extension ClassLoader(扩展类加载器)**：这个加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载\lib\ext目录中的，或者被`javax.ext.dirs`系统变量所指定的路径中的所有类库。 - **Application ClassLoader(应用程序类加载器)**：这个加载器由sun.misc.Launcher$AppClassLoader实现。可以加载用户类路径上的指定类库，通过`ClassLoader.getSystemClassLoader()`方式获取，没有定义过自己的类加载器，则默认是这个。 - **Custom ClassLoader(自定义加载器)**：通过集成`java.lang.ClassLoader`来实现自己的加载器。 - {% fullimage /images/jvm/parent_loader.png, alt,双亲委派模型 %} ### 2.双亲委托模型 - 工作流程：如果一个类加载器收到了类加载的请求，不会自己去尝试加载这个类，而把这个请求委派给父类加载器去完成，每一层都是如此，依次向上递归，直到委托到最顶层的`Bootstrap ClassLoader`，若父加载器无法处理加载请求（它的搜索范围内没有找到所需的类时），则交由子加载器去加载。 > 简单流程介绍 > > 1. 自定义类加载器先从缓存中查看Class文件是否被加载，如果加载则返回Class，没有加载则委托给父类加载 > 2. 一直委托到`Bootstrap ClassLoader`,在`Bootstrap ClassLoader`没有找到Class文件，则在自己的规定路径\lib或者-Xbootclasspath选项指定路径的jar包进行查询，找到则返回Class，没有就交由子加载器去加载。 > 3. 最后交由我们自定义的类加载器去加载，还找不到则抛出`ClassNotFoundException`异常。 - 代码模型实现： ```java protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 检查请求的类是否已被加载过 Class c = findLoadedClass(name); //对应的类已被加载则不会往下进行 if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { //父加载器不为null，调用父加载器的load方法 c = parent.loadClass(name, false); } else { //父加载器为null，则调用系统的BootstrapClassLoader c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader //父类加载器无法加载则抛出ClassNotFoundException异常 } if (c == null) { // If still not found, then invoke findClass in order // to find the class. //父类加载器无法加载则调用本身的findClass()方法去加载 long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } ``` - 好处： - 避免重复加载，若该Class已加载则从缓存中直接读取 - 更加安全，例如`java.lang.Object`，无论哪一个类加载器去加载这个类，最终都会委派给Bootstrap ClassLoader去进行加载，所以我们自定义的Object类并不会被加载而导致系统中出现多个Object类。 ### 3.破坏双亲委托模型 双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载实现方式。 - 在JDK1.2发布之前，还没有双亲委托机制 - 由模型自身缺陷所导致的 - 用户对于程序动态性导致的，例如代码热替换，模块热部署 ### 4.自定义ClassLoader - 自定义需要加载的类 ```java public class Jobs { public void say() { System.err.println("自定义加载器加载"); } } ``` 自定义完成后需调用`javac Jobs.java`去生成对应的`Jobs.class`文件以用来加载。 - 实现自定义的ClassLoader ```java import java.io.*; public class DiskClassLoader extends ClassLoader { private String path; public DiskClassLoader(String path) { this.path = path; } @Override protected Class findClass(String name) throws ClassNotFoundException { Class clazz = null; byte[] classData = loadClassData(name); if (classData == null) { throw new ClassNotFoundException(); } else { //用来将获取的字节码数组转为class的实例 clazz = defineClass(name, classData, 0, classData.length); } return clazz; } /** * 获得class文件的字节码数组 * @param name * @return */ private byte[] loadClassData(String name) { String fileName = getFileName(name); File file = new File(path, fileName); System.err.println(fileName); InputStream inputStream = null; ByteArrayOutputStream byteArrayOutputStream = null; try { inputStream = new FileInputStream(file); byteArrayOutputStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int length = 0; while ((length = inputStream.read(buffer)) != -1) { byteArrayOutputStream.write(buffer, 0, length); } return byteArrayOutputStream.toByteArray(); } catch (IOException e) { e.printStackTrace(); } finally { //读取流后需要关闭，以免造成内存泄露 try { if (inputStream != null) { inputStream.close(); } } catch (IOException e) { e.printStackTrace(); } try { if (byteArrayOutputStream != null) { byteArrayOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } return null; } private String getFileName(String name) { int index = name.indexOf('.'); if (index == -1) { return name + ".class"; } else { return name.substring(index + 1) + ".class"; } } } ``` 自定义的ClassLoader需要读取对应Class的字节流数组，以便产生实例。注意不要忘记对流的关闭。 - 使用自定义的ClassLoader去加载类 ```java import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class CustomClassLoaderTest{ public static void main(String[] args) { DiskClassLoader diskClassLoader = new DiskClassLoader("需要加载的class的地址"); try { //对class文件进行加载 Class c = diskClassLoader.loadClass("Jobs"); if (c != null) { try { Object object = c.newInstance(); System.err.println(object.getClass().getClassLoader()); Method method = c.getDeclaredMethod("say", null); method.invoke(object, null); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } ``` 在对应的文件夹下是否已存在Jobs.java文件： - ```java //存在要加载的Java文件 sun.misc.Launcher$AppClassLoader@18b4aac2 自定义加载器加载 ``` - ```java //不存在对应的Java文件 DiskClassLoader@d716361 自定义加载器加载 ``` ​ 以上就为自定义ClassLoader的基本步骤，也是热修复框架中ClassLoader的雏形。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XIV]]></title>
    <url>%2F2018%2F04%2F16%2FAndroid-Study-Plan-XIV%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XIV date: 2018-04-16 13:07:50 tags: Android --- # Android学习计划 ##用过RxJava和RxAndroid吗？RxAndroid切换线程是怎么实现的？]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC,MVP,MVVM的理解]]></title>
    <url>%2F2018%2F04%2F15%2FMVC-MVP-MVVM%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[--- title: MVC,MVP,MVVM的理解 date: 2018-04-15 14:58:03 tags: 设计模式 --- # 1.MVC模式 MVC(Model-View-Controller，模型-视图-控制器)是20世纪80年代出现的一种设计模式。他用一种业务逻辑、数据、界面显示分离的方法组织代码。在Android中MVC的角色定义如下： - Model(模型层)：针对业务模型，建立的数据结构和相关的类，就可以理解为Model。与View无关，与业务相关。 - View(视图层)：一般采用XML文件或者Java代码进行界面的描述。 - Controller(控制器)：Android的控制层一般在Activity，Fragment中或者在由他们控制的其他业务类中。 {% fullimage /images/pattern/mvc_pattern.png, MVC,MVC %} 缺点： - 在Android开发中，Activity不是一个标准的Controller，首要职责为加载应用的布局和初始化界面，并接受用户的请求。随着界面以及代码逻辑的复杂，Activity会越来越庞大。 - view层和model层是相互感知的，意味之间存在很大的耦合。 # 2.MVP模式 MVP(Model-View-Presenter)是MVC的演化版本，对于Android来说，Model层和MVC模式是一种概念，activity或者fragment对应的就是View层，所有用户相关事件处理由Presenter处理。 - Model：主要提供数据的存取功能。 - View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件 - Presenter：作为View和Model沟通的桥梁，从Model层检索数据并返回给View层，使得View和Model层完全解耦。Presenter与View可以通过接口来实现通信，只要View层去实现定义好的接口。 {% fullimage /images/pattern/mvp_pattern.png, MVP,MVP %} 缺点： - View层和Presenter层会交互过于频繁，若Presenter过多的渲染了View，往往导致过于紧密，若View发生改动，Presenter也要发生变更。 # 3.MVVM模式 MVVM(Model-View-ViewModel)是2015由微软提出的一个UI架构概念。将Presenter改为ViewModel，同时实现View和ViewModel的双向绑定（View的变动，自动反映在ViewModel，反之亦然）。 - Model：主要提供数据的存储过程 - View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件 - ViewModel：功能和Presenter类似，与View和Model双向绑定 {% fullimage /images/pattern/mvvm_pattern.png, MVC,MVC %} 优点： - 低耦合。View可以独立于Model变化和修改，ViewModel可以绑定不同的View - 可重用性。把许多的试图逻辑处理放在一个ViewModel中，许多View可以使用该ViewModel - 独立开发。开发人员可以专注于逻辑和数据的处理 - 可测试性。可以直接针对ViewModel进行单独测试。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程保活介绍]]></title>
    <url>%2F2018%2F04%2F12%2F%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[--- title: 进程保活介绍 date: 2018-04-12 20:26:08 tags: Android top: 10 --- # 进程保活 {% fullimage /images/进程保活.png,进程保活,进程保活%} 进程保活的方式分为两个层面：`提高进程优先级，降低被杀死的概率`,`在进程被杀死后，进行拉活`。 ## 1. 进程的优先级 {% fullimage /images/study_plan/process_level.webp, alt,进程优先级 %} `优先级最低的进程首先被杀死、进程的等级会因为其他进程的依赖而提高一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低` 按重要性分类： - **前台进程**：进程持有一个正在与用户交互的Activity或者和交互Activity绑定的Service，前台运行的Service（执行`startForeground()`）,执行`onReceive()`的BroadcastReceiver - **可见进程**：进程持有一个被用户可见但没有显示在最前端的Activity(调用到了`onPause()`)或者和可见Activity绑定的Service - **服务进程**：进程持有一个`startService()`启动的Service进程，例如播放音乐，下载文件等Service - **后台进程**：进程持有一个用户不可见的Activity(调用到`onStop()`没有到`onDestroy()`)，进程被存放在一个LRU列表中，即很长时间没用的Activity会被优先杀死 - **空进程**：进程不包含任何活跃的应用组件，唯一的作用是`为了缓存需要，缩短下次启动的时间` ## 2. Android进程回收策略 对于进程的回收，依靠LowmemoryKiller完成，按照OOM_ADJ的阈值级别触发对应的内存回收。 {% fullimage /images/study_plan/oom_adj.webp, alt,流程图 %} 红色代表易被杀死的进程，绿色不易被杀死。LowmemoryKiller会优先杀死OOM_ADJ较大的进程，优先级相同则进一步受到进程所占内存和进程存活时间的影响。 ## 3. 提升进程优先级 - **利用Activity提升权限**：`监控手机锁屏解锁事件，在屏幕锁定时启动一个一像素的Activity，解锁时销毁。`**需把Activity设置成用户无感知** - **利用Notification提升权限**：`Service的优先级为4，使用setForeground可以设置前台Service，提升进程的优先级，降低被杀的概率。` - **注意点**：设置为前台Service时，在通知栏会显示一条通知。 - **应对措施**：可以去实现一个内部Service，在LiveService和其内部Service中同时发送相同ID的Notification，然后结束内部Service。内部Service被结束时，Notification也会消失，但是进程的优先级不会发生变化。 ## 4. 进程死后拉活的方案 - **利用系统广播拉活**：在发生特定事件是，系统会发送相应的广播，可以在AndroidManifest中静态注册对应的广播监听器，即可在对应事件发生时拉活应用。以下是常见的拉活广播事件： - 开机广播：RECEIVE_BOOT_COMPLETED - 网络变化：CHANGE_NETWORK_STATE,CHANGE_WIFI_STATE… - 文件挂载：MOUNT_UNMOUNT_FILESYSTEMS - 屏幕亮灭：SCREEN_ON,SCREEN_OFF - 锁屏解锁：RECEIVE_USER_PRESENT - 应用安装卸载：PACKAGE_ADDED,PACKAGE_REMOVED 缺点： - 广播接收器容易被系统的管理软件通过“自启管理”禁用场景，从而无法处理 - 系统广播事件不可控，只能保证有对应事件是拉活进程，但不能保证能否立即拉活。 - **利用第三方应用广播拉活**：该方案接受第三方应用的广播，反编译一些第三方应用，找到他们发送的广播，在自己应用内进行监听，当这些应用发送广播时，即可拉活自己的应用。 缺点： - 需要反编译较多应用来确保效果 - 第三方应用的广播可能会在日后更新中修改或删除 - **利用系统Service机制拉活**：把Service设置为`START_STICKY`，这个参数可以在Service被杀死后，利用系统机制尝试拉活。 缺点： - Service第一次被异常杀死后会在5秒内重启，第二层被杀死10秒内重启，第三次会在20秒内重启，一旦被杀死达到5次，则系统不会再重新拉活。 - 进程被Root权限的工具杀死活forcestop，无法重启。 - **利用Native进程拉活**：利用Linux中的fork机制创建Native进程，在Native进程中监控主进程的存活，当主进程挂掉后，在Native进程中立即对主进程拉活。（该进程的生命周期不受Android的管理）。 适用范围： - 在Android5.0以下版本手机效果很好，不受forcestop影响 - 在5.0以上的手机，Native进场也会被forcestop杀死，假如逻辑跑的比系统快，依然可以拉活。 - **利用JobScheduler机制拉活**：系统在Android5.0以上版本提供了JobScheduler接口，系统会定时调用该进程使应用处理一些操作。 适用范围：Android5.0以上系统手机，在部分小米手机可能无法拉活。 ```java @TargetApi(Build.VERSION_CODES.LOLLIPOP) public class KeepLiveService extends JobService { private final static String TAG="KeepLive"; private volatile static Service mKeepLiveService= null; @Override public boolean onStartJob(JobParameters jobParameters) { return false; } @Override public boolean onStopJob(JobParameters jobParameters) { return false; } } ``` ```java public void startJobscheduler(){ try { int jobId=1; JobInfo.Builder builder=new JobInfo.Builder(jobId, new ComponentName(MyApplication.getApplicationContext(), KeepLiveService.class)); builder.setPeriodic(10);//设置时间间隔 builder.setPersisted(true);//重启后需要继续执行 JobScheduler js = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); js.schedule(builder.build()); }catch (Throwable e){ e.printStackTrace(); } } ``` - **利用账号同步进制拉活**：Android系统的账号同步进制会定期同步执行，可以利用同步机制进行进程的拉活。 适用范围：适用于所有的Android版本，在Android N中进行了一些变动，该方案失效。 - **其他方案**： - 利用系统通知权限进行拉活 - 利用辅助功能拉活，将应用加入厂商白名单 - 利用推送进行拉活（如小米、华为推送）]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(二) -- 虚拟机类加载机制]]></title>
    <url>%2F2018%2F04%2F12%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展(二) -- 虚拟机类加载机制 date: 2018-04-12 12:40:07 tags: JVM top: 11 --- # 虚拟机类加载机制 ## 1.定义 `虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。` ## 2.类的生命周期 类从被加载到虚拟机内存中开始，到卸载除内存为止，生命周期包括：**加载(Loading)**、**验证(Verification)**、**准备(Preparation)**、**解析(Resolution)**、**初始化(Initialization)**、**使用(Using)**、**卸载(Unloading)**。其中`验证`、`准备`、`解析`统称为**连接(Linking)** {% fullimage /images/jvm/class_lifecycle.png, 类的生命周期,类的生命周期 %} 加载、验证、准备、初始化和卸载阶段执行顺序为确定的，类的加载过程必须按照这个顺序开始。解析阶段不一定：在某些情况下可以在初始化阶段之后开始，为了支持Java语言的运行时绑定。 初始化阶段，虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”： - 遇到`new ,getstatic,putstatic或invokestatic`指令时，类没有进行初始化，则需要先触发初始化。最常见的Java代码场景：使用new关键字实例化对象、读取或设置一个类的静态字段、调用一个类的静态方法。 - 使用`java.lang.reflect`进行反射调用的时候。 - 初始化一个类时，发现父类还没有初始化，先触发父类初始化方法。 - 虚拟机启动时，用户指定一个要执行的主类(包含`main()`方法的类)，先初始化该类。 - 使用动态语言支持时，若`java.lang.invoke,MethodHandle`实例最后解析结果为`REF_getStatic,REF_putStatic,REF_invokeStatic`的方法句柄，并且该类没有进行初始化。 ## 3.类加载的过程 - **加载** 虚拟机需要完成以下3件事情： 1. 通过一个类的全限定名来获取定义此类的二进制字节流 2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口 并没有指定一个二进制字节流要从一个Class文件中获取 - **验证**（若代码被反复验证和使用过，可以使用`-Xverify:none`来关闭大部分的类验证措施，缩短虚拟机加载时间） 验证是连接阶段的第一步，这一阶段的目的是为了**确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全**。 验证阶段大致需要完成以下4个阶段的检验动作： 1. **文件格式验证** 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 `主要目的是保证输入的字节流能正确的解析并存储于方法区之内，格式上符合描述一个Java类信息的要求。在这个阶段字节流进入内存中的方法区后续不再操作字节流。` 2. **元数据验证** 对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范 3. **字节码验证** 通过数据流和控制流分析，确定程序语义是合法且符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机的安全的事件。 4. **符号引用验证** 发生在虚拟机将符号引用转化为直接引用的时候，这个转化发生在解析阶段。对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验。`确保解析动作能正常执行` - **准备** **准备阶段是正式为变量分配内存并设置类初始变量初始值的阶段**，这些变量所使用的内存都将在方法区中进行分配。这个时候进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量。 初始值`通常情况`下是数据类型的零值，如 ```java public static int value = 123;//在准备阶段过程中初始值为0，而不是123。 ``` `特殊情况`：若类字段的属性表中有ConstantValue属性，那么准备阶段value就会初始化为ConstantValue指定的值，如 ```java public static final int value = 123;//在准备阶段过程中初始值为123。 ``` - **解析** **解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**。解析阶段中会涉及到`直接引用`(直接指向目标的指针、相对偏移量或者是一个能直接定位到目标的句柄)，`符号引用`(以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可)。 解析动作主要针对`类或接口（CONSTANT_Class_info）`、`字段（CONSTANT_Fieldref_info）`、`类方法（CONSTANT_Methodref_info）`、`接口方法（CONSTANT_InterfaceMethodref_info）`、`方法类型（CONSTANT_MethodType_info）`、`方法句柄（CONSTANT_MethodHandle_info）`、`调用点限定符（CONSTANT_InvokeDynamic_info）`。 - **初始化** 初始化是类加载过程的最后一步。**到这里才真正开始执行类中定义的Java程序代码**。 执行类构造器`()`方法的过程。 - `()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。 - `()`方法与类的构造函数不同，他不需要显示的调用父类构造器，因此虚拟中第一个被执行的`()`方法的类肯定是`java.long.object`。 - **初始化过程就是对变量进行赋值及执行静态代码块。** ## 4.类的卸载 类卸载的触发条件： - 该类所有的实例都已经被GC，也就是在JVM中不存在该类的任何实例 - 加载该类的ClassLoader也被GC - 该类的java.lang.Class对象没有在任何地方呗引用，如反射都无法访问该类 类卸载过程： 在方法区内的二进制数据会被卸载。 **若卸载后还需要使用，那么就需要去重新加载，然后在Java的虚拟机堆区上重新生成实例。**]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展（一）-- JVM内存区域]]></title>
    <url>%2F2018%2F04%2F10%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展（一）-- JVM内存区域 date: 2018-04-10 15:22:34 tags: JVM top: 11 --- # 1. JVM内存区域 {% fullimage /images/jvm/jvm_data.png, JVM运行时数据区,JVM运行时数据区 %} JVM在执行Java程序的过程中会把管理的内存分为若干个数据局域。 - **程序计数器(Program Counter Register)**：一块较小的内存空间，可看作为**当前线程所执行的字节码的行号指示器**。每条线程都需要一个独立的程序计数器，所以为线程私有区域。`没有规定任何OutOfMemoryError情况的区域`。`线程执行Java方法，则记录正在执行的虚拟机字节码指令地址，若为Native方法，则计数器值则为Undefined` - **Java虚拟机栈(VM Stack)**：虚拟机栈是线程私有的，生命周期与线程相同。描述的是**Java方法执行的内存模型**：每个方法在执行时都会创建一个栈帧用于存储局部变量表(存放编译器可知的各种基本数据类型`boolean,byte,char,int,long,float,double,short`,对象引用和returnAddress类型)，操作树栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。这个区域存在两种异常情况：`StackOverflowError：请求栈深度大于虚拟机所允许的深度`，`OutOfMemoryError：无法申请到足够的内存` - **本地方法栈(Native Method Stack)**：本地方法栈是线程私有的，虚拟机执行Native方法的服务，和虚拟机栈类似存在两个异常情况。 - **Java堆(Heap)**：JVM管理内存中最大的一块。是被所有线程共享的一块区域，在虚拟机启动时创建。唯一目的`存放对象实例`，几乎所有对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为”GC堆”。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，则抛出OutOfMemoryError异常。 - **方法区(Method Area)**：方法区与Java堆一样，是各个线程共享的内存区域。**用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。同Java堆一样会抛出OutOfMemoryError异常。 - **运行时常量池(Runtime Constant Pool)**：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一个是常量池（存放编译器生成的各种字面量和符号引用）。有一个重要特征是具有动态性，运行期也可以将新的常量放入池中。受到方法区内存的限制，也会抛出OutOfMemoryError异常。 - **直接内存(Direct Memory)**：不属于虚拟机运行时数据区的一部分。 > 拓展： > - 程序计数器，虚拟机栈，本地方法栈随着线程生命周期变化，生则生，死则死。 > - 程序计数器，虚拟机栈，本地方法栈不需要过多考虑内存回收问题，随着方法结束或者线程结束时，内存随着就会回收。 简述：JVM的内存区域主要有以下5类： 1. 程序计数器：线程私有，当前线程所执行的字节码的行号指示器 2. 虚拟机栈：线程私有，存放基本数据类型、对象引用和returnAddress类型，会发生内存溢出异常 3. 本地方法栈：线程私有，为JVM中用到的Native方法服务，会发生内存溢出异常 4. Java堆：线程共享，存放对象的实例，也是GC回收管理器的主要区域，会发生内存溢出异常 5. 方法区：线程共享，存储已被JVM加载的类信息、常亮、静态变量、即时编译后的代码等数据，会发生内存溢出异常 # 2.HotSpot虚拟机对象创建，布局以及访问 ## 对象的创建 在语言层面上，创建对象只需要一个`new`关键字。 在虚拟机中，分为以下几步： - **遇到一条new指令时，先去检查指令对应参数是否在常量池中可以定位到一个符号的引用，并且检查指令的参数是否已被加载、解析和初始化过。若无则需要执行相应的类加载过程。** - **类加载检查通过后，将为新生对象分配内存。**对象所需的内存大小在类加载完成后便可确定，这块内存由Java堆中划分出来。内存的分配方式由Java堆中内存是否规整决定（`已使用的内存和空闲内存是否相互交错`）。规整则使用 **指针碰撞**（`把指针向空闲空间挪动对象大小的距离`），不规整则使用**空闲列表**（`虚拟机内维护一个列表用来记录内存块中的可用区域，然后找到一块足够大的空间划分给对象实例`）。 - **处理并发安全问题。**除了如何分配内存，还需要考虑虚拟机中对象创建是非常频繁的行为，就会涉及到线程安全。解决这个问题有两种方案： - 对分配内存空间的行为进行同步处理 - 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为`本地线程分配缓存(TLAB)`。哪个线程需要分配内存就在哪个TLAB上分配，只有TLAB用完了，才同步申请另一块内存。 - **内存分配完成后，虚拟机将需要分配到的内存空间都初始化为零值（不包括对象头）。**这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 - **虚拟机对对象进行设置，将`类的元数据信息、对象的哈希码、对象的GC分代年龄信息`存入对象头中。** - **执行init方法初始化。**从虚拟机角度来说，对象已经产生完成，从Java方面来说才刚刚开始，要等到new指令执行并\方法执行后，把对象按照意愿初始化后，真正可用的对象生成完毕。 ## 对象的内存布局 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：`对象头(Header)`、`实例数据(Instance Data)`和`对齐填充(Padding)` ### 对象头 **存储自身的运行时数据** | 存储内容 | 标志位 | 状态 | |---|---|---| | 对象哈希码、对象分代年龄 | 01 | 未锁定 | | 指向锁记录的指针 | 00 | 轻量级锁定 | | 指向重量级锁的指针 | 10 | 膨胀 | | 空，不需要记录信息 | 11 | GC标记 | | 偏向线程ID，偏向时间戳，对象分代年龄 | 01 | 可偏向 | **类型指针** 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象为一个Java数组，则对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。 ### 实例数据 里面是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。在分配策略中，相同宽度的字段总是会被分配在一起。 ### 对齐填充 并非必然存在的，也没有特别的含义。仅仅起着占位符的作用。当实例数据部分没有对齐时，需要对齐填充来补全。 ## 对象的访问 Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式是`句柄访问`和`直接指针访问`。 - 使用句柄访问：Java堆中会划分出一块内存来作为句柄池，`refrence中存储的对象就是对象的句柄地址`，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 **句柄访问的最大好处是refrence中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，refrence本身不会有修改。** {% fullimage /images/jvm/get_object_by_handle.png, alt,流程图 %} - 使用直接指针访问：Java堆对象需要考虑如何放置访问类型数据的相关信息，而`refrence中存储的直接就是对象地址`。 **直接访问的最大好处是速度快，节省了一次指针定位的时间开销，在Java HotSpot虚拟机中很常用。** {% fullimage /images/jvm/get_object_direct.png, alt,流程图 %}]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--静态代理模式和动态代理模式原理及实现]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[--- title: 设计模式--静态代理模式和动态代理模式原理及实现 date: 2018-04-09 21:40:32 tags: 设计模式 top: 10 --- # 代理模式（委托模式） > **为其他对象提供一种代理以控制对这个对象的访问**。引入**代理对象**来间接访问**目标对象** {% fullimage /images/Pattern-Proxy.png,代理模式,代理模式 %} 代理模式优点： - 职责清晰：真实的角色就是实现实际的业务逻辑，不需关心其他非本职责的事务 - 高扩展性：代理类可以在不做任何修改的情况下继续使用 - 智能化：动态代理演示 代理模式缺点： 1. 在客户端和真实对象之间添加了代理，会造成请求的处理速度变慢 2. 实现代理模式比较复杂，需要额外的工作 代理模式的扩展： 1. 普通代理 > 客户端只能访问代理角色，而不能直接访问真实角色。 ```java public class Client { public static void main(String[] args){ //屏蔽了GamePlayer的真实角色访问 GamePlayerProxy gamePlayerProxy = new GamePlayerProxy("wxy"); gamePlayerProxy.login("wxy","124"); gamePlayerProxy.killBoss(); gamePlayerProxy.upgrade(); } } ``` Client只是调用了`GamePlayerProxy`代理角色，而不知道真实角色是谁。**非常适合扩展性要求较高的场景。** 2. 强制代理 > 通过真实角色来找到代理角色，否则不能访问。**由真实角色来管理代理角色。不允许直接访问真实角色** ```java public class Client { public static void main(String[] args){ //必须是真实角色的代理对象才可以使用 IGamePlayer gamePlayerProxy = new GamePlayer("wxy").getProxy(); //直接生成代理对象无效 //GamePlayerProxy gamePlayerProxy = new GamePlayerProxy(new GamePlayer("wzr5")); gamePlayerProxy.login("wxy","124"); gamePlayerProxy.killBoss(); gamePlayerProxy.upgrade(); } } ``` 3. 代理是有个性的 > 一个类可以实现多个接口，完成不同任务的整合。**代理类不仅可以实现主题接口，也可以实现其他接口完成不同的任务。** 4. **动态代理** > 不需要**显式实现与目标对象类相同的接口**，将这种实现推迟到程序运行时由JVM实现。 原理：通过Java反射机制的`method.invoke()`调用动态代理类对象方法，从而自动调用目标对象的方法。 优点：1. 只需要一个代理类就可以解决创建多个静态代理的问题，避免重复代码。2. 更加灵活 缺点：1. 效率低 `需要通过反射机制，间接调用目标对象方法` 2.应用场景局限`只能针对接口创建代理类，即只能动态代理实现了接口的类` 应用场景： - 需要代理对象数量较多的情况下使用 - `AOP`-面向切面编程 > 可以通过预编译的方式在运行期动态代理实现程序功能的统一维护，有效降低业务之间的耦合度，提供程序的可用性并提高了开发的效率。开发中主要用在日志收集，性能分析等。 使用方法： 1. 声明调用代理类 ```java public class GamePlayIH implements InvocationHandler { //被代理实例 T obj ; public GamePlayIH(T _obj) { this.obj = _obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = method.invoke(this.obj, args); return result; } } ``` 2. 声明目标对象类的抽象接口 ```java public interface IGamePlayer { void login(String user, String pwd); void killBoss(); void upgrade(); } ``` 3. 声明目标对象类 ``` public class GamePlayer implements IGamePlayer { private String name = ""; public GamePlayer(String _name) { this.name = _name; } @Override public void login(String user, String pwd) { System.err.println("登录名为：" + user + " 用户名为：" + this.name + "登录游戏"); } @Override public void killBoss() { System.err.println(this.name + "打Boss"); } @Override public void upgrade() { System.err.println(this.name + "升级了"); } } ``` 4. 通过动态代理对象，调用目标方法 ```java public class Client { public static void main(String[] args) { //创建目标对象 IGamePlayer player = new GamePlayer("wxy"); //创建调用处理对象 InvocationHandler handler = new GamePlayIH(player); //指定产生代理对象的类加载器 ClassLoader cl = player.getClass().getClassLoader(); //创建动态代理对象 IGamePlayer gamePlayerProxy = (IGamePlayer) Proxy.newProxyInstance(cl, new Class[]{IGamePlayer.class}, handler); //调用动态代理对象方法 gamePlayerProxy.login("wxy", "124"); gamePlayerProxy.killBoss(); gamePlayerProxy.upgrade(); } } ```]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android触摸事件分发]]></title>
    <url>%2F2018%2F04%2F09%2FAndroid%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[--- title: Android触摸事件分发 date: 2018-04-09 21:40:14 tags: Android --- # 1.触摸事件的类型 对应的类是`MotionEvent`，主要有以下三个类型： - **ACTION_DOWN**：监听用户手指按下的操作，一次按下标志触摸事件的开始。 - **ACTION_MOVE**：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。 - **ACTION_UP**：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。 - **ACTION_CANCEL**：当用户保持按下操作，并把手指移动到了控件外部局域时且父View处理事件触发。 # 2.事件传递的三个阶段 - **分发（Dispatch）**：事件的分发对应着`dispatchTouchEvent`方法，所有触摸事件由这个方法进行分发 ```java public boolean dispatchTouchEvent(MotionEvent ev) ``` 在这个方法中，根据当前视图的需求来进行事件的分发给子视图还是直接消费不往下传递，返回`true`表示事件被消费，不往下传递。返回值为`super.dispatchTouchEvent`表示继续往下传递。 - **拦截（Intercept）**:事件的拦截对应着`onInterceptTouchEvent`方法，这个事件只在ViewGroup及其子类中存在。 ```java public boolean onInterceptTouchEvent(MotionEvent ev) ``` 根据具体的逻辑，返回`true`表示拦截该事件，不继续把事件分发给子视图，交由自身的`onTouchEvent`进行处理，返回值为`false或super.onInterceptTouchEvent`表示继续往下传递。 - **消费（Consume）**：事件的消费对应着`onTouchEvent`方法 ```java public boolean onTouchEvent(MotionEvent ev) ``` 返回值为`true`时，表示当前视图可以处理事件，不会向上传递给父视图；返回值为`false`表示当前视图不处理这个事件，事件传递给父视图的`onTouchevent`进行处理。 > 在Android系统中，可以处理事件传递的类有以下三种： > > - **Activity**：包含`dispatchTouchEvent`，`onTouchEvent`方法 > - **ViewGroup**：包含`dispatchTouchEvent`，`onInterceptTouchEvent`，`onTouchEvent` > - **View**：包含`dispatchTouchEvent`，`onTouchEvent`方法 # 3.View的事件传递机制 View包括TextView，ImageView等子类，不包括ViewGroup。 ```java /** * Custom TextView with touchevent */ public class MyTextView extends AppCompatTextView { public static final String TAG="MyTextView"; ... @Override public boolean dispatchTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"dispatchTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL"); break; } return super.dispatchTouchEvent(event);② } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"onTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onTouchEvent_ACTION_CANCEL"); break; } return super.onTouchEvent(event);④ } } ``` ```java public class MainActivity extends AppCompatActivity { public static final String TAG="MainActivity"; MyTextView mtv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mtv= (MyTextView) findViewById(R.id.mtv); mtv.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Log.e(TAG,"MyTextView_onclick"); } }); mtv.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View view, MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"MyTextView_onTouch_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"MyTextView_onTouch_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"MyTextView_onTouch_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"MyTextView_onTouch_ACTION_CANCEL"); break; } return false;③ } }); } @Override public void onUserInteraction() { super.onUserInteraction(); Log.e(TAG,"onUserInteraction"); } @Override public boolean dispatchTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"dispatchTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL"); break; } return super.dispatchTouchEvent(event);① } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"onTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onTouchEvent_ACTION_CANCEL"); break; } return super.onTouchEvent(event); } } ``` - 常规输出：(返回的都为默认值) - 点击MyTextView区域 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MyTextView: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyTextView: dispatchTouchEvent_ACTION_UP E/MainActivity: MyTextView_onTouch_ACTION_UP E/MyTextView: onTouchEvent_ACTION_UP E/MainActivity: MyTextView_onclick ``` - 点击MyTextView外部区域 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MainActivity: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_MOVE E/MainActivity: onTouchEvent_ACTION_MOVE E/MainActivity: dispatchTouchEvent_ACTION_UP E/MainActivity: onTouchEvent_ACTION_UP ``` - ① **Activity的dispatchTouchEvent()**`return true;或return false;` ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_MOVE E/MainActivity: dispatchTouchEvent_ACTION_MOVE E/MainActivity: dispatchTouchEvent_ACTION_UP ``` > 不会再继续分发触摸事件，及后续控件的触摸事件都不会响应。 - ② **View的dispatchTouchEvent()**`return true;`不会调用MyTextView的`onClick`事件 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MyTextView: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyTextView: dispatchTouchEvent_ACTION_UP E/MainActivity: MyTextView_onTouch_ACTION_UP E/MyTextView: onTouchEvent_ACTION_UP ``` **View的dispatchTouchEvent()**`return false;`只响应MyTextView的`ACTION_DOWN`事件，后续的处理由MainActivity的`onTouchEvent`执行 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_MOVE E/MainActivity: onTouchEvent_ACTION_MOVE E/MainActivity: dispatchTouchEvent_ACTION_UP E/MainActivity: onTouchEvent_ACTION_UP ``` - ③**Activity中View的onTouch()**`return true;`不往下分发事件及不会调用到`onClick`事件 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyTextView: dispatchTouchEvent_ACTION_UP E/MainActivity: MyTextView_onTouch_ACTION_UP ``` - ④ **View的onTouchEvent()**`return true;`不触发`onClick`事件 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MyTextView: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyTextView: dispatchTouchEvent_ACTION_UP E/MainActivity: MyTextView_onTouch_ACTION_UP E/MyTextView: onTouchEvent_ACTION_UP ``` **View的onTouchEvent()**`return false;`只响应MyTextView的`ACTION_DOWN`事件，后续的处理由MainActivity的`onTouchEvent`执行 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MyTextView: onTouchEvent_ACTION_DOWN E/MainActivity: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MainActivity: onTouchEvent_ACTION_UP ``` {% fullimage /images/study_plan/Activity-View dispatch.png, View的事件传递,View的事件传递 %} > 总结： > > - 触摸事件传递从dispatchTouchEvent开始，在不修改默认返回的数值时，事件会按照嵌套层次由外向内传递，到达最内层的View时，就由它的onTouchEvent处理。 > > - 若事件在传递过程中，返回参数设为true，则导致事件提前被消费，内层View无法处理事件 > > - View的事件触发顺序为先执行onTouch方法，最后执行onClick方法。onTouch返回false，则会响应onClick，否则事件不会继续传递。 > > - View的点击事件流程： > > **Activity.dispatchTouchEvent() -> View.dispatchTouchEvent()->View.onTouch()->View.onTouchEvent()->View.onClick()** # 4.ViewGroup事件传递机制 ViewGroup作为View的容器存在，ViewGroup包括LinearLayout，RelativeLayout等。 ```java /** * Custom ViewGroup with touchEvent */ public class MyRelativeLayout extends RelativeLayout { public static final String TAG="MyRelativeLayout"; public MyRelativeLayout(Context context) { super(context); } public MyRelativeLayout(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean dispatchTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"dispatchTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL"); break; } return super.dispatchTouchEvent(event); } @Override public boolean onInterceptTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"onInterceptTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onInterceptTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onInterceptTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onInterceptTouchEvent_ACTION_CANCEL"); break; } return super.onInterceptTouchEvent(event);⑥ } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"onTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onTouchEvent_ACTION_CANCEL"); break; } return super.onTouchEvent(event); } } ``` - 常规模式（全为默认值） ```log E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWN E/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MyTextView: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyRelativeLayout: dispatchTouchEvent_ACTION_UP E/MyRelativeLayout: onInterceptTouchEvent_ACTION_UP E/MyTextView: dispatchTouchEvent_ACTION_UP E/MainActivity: MyTextView_onTouch_ACTION_UP E/MyTextView: onTouchEvent_ACTION_UP E/MainActivity: MyTextView_onclick ``` - ViewGroup.onInterceptTouchEvent()返回true ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWN E/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWN E/MainActivity: MyRelativeLayoutonTouch_ACTION_DOWN E/MyRelativeLayout: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyRelativeLayout: dispatchTouchEvent_ACTION_UP E/MainActivity: MyRelativeLayout_onTouch_ACTION_UP E/MyRelativeLayout: onTouchEvent_ACTION_UP ``` {% fullimage /images/study_plan/Activity-ViewGroup-View dispatch.png, View的事件传递,View的事件传递 %} > 总结: > > - 对于一个包裹在ViewGroup中的View，点击发生的触摸流程为： > > **Activity.dispatchTouchEvent()->ViewGroup.dispatchTouchEvent()->ViewGroup.onInterceptTouchEvent()->View.dispatchTouchEvent()->View.onTouch()->View.onTouchEvent()->View.onClick()** > > - dispatchTouchEvent事件分发逻辑如下： > > 如果 return true，事件会分发给当前 View 并由 dispatchTouchEvent 方法进行消费，同时事件会停止向下传递； > 如果 return false，事件分发分为两种情况： > 1.如果当前 View 获取的事件直接来自 Activity，则会将事件返回给 Activity 的 onTouchEvent 进行消费； > 2.如果当前 View 获取的事件来自外层父控件，则会将事件返回给父 View 的 onTouchEvent 进行消费。 > > - onInterceptTouchEvent 的事件拦截逻辑如下： > 如果 onInterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理； > 如果 onInterceptTouchEvent 返回 false或super.onInterceptTouchEvent(ev)，则表示将事件放行，当前 View 上的事件会被传递到子 View 上，再由子 View 的 dispatchTouchEvent 来开始这个事件的分发； > - onTouchEvent 的事件响应逻辑如下： > 如果事件传递到当前 View 的 onTouchEvent 方法，而该方法返回了 false，那么这个事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，如果传递到上面的 onTouchEvent 也返回 false，这个事件就会“消失”，而且接收不到下一次事件。 > 如果返回了 true 则会接收并消费该事件。 > 如果返回 super.onTouchEvent(ev) 默认处理事件的逻辑和返回 false 时相同。 # 5.源码分析 //TODO # 6.实例分析]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热修复基本原理]]></title>
    <url>%2F2018%2F04%2F07%2F%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[--- title: 热修复基本原理 date: 2018-04-07 13:11:03 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle操作小记]]></title>
    <url>%2F2018%2F04%2F03%2FGradle%E6%93%8D%E4%BD%9C%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[--- title: Gradle操作小记 date: 2018-04-03 16:24:22 tags: Gradle --- > 显示所有依赖关系解析树 ```gradle ./gradlew app:dependencies ``` > 生成项目 ```gradle ./gradlew clean assembleEnvTestReleaseChannels -PchannelList=default ``` > 清理项目 ```groovy ./gradlew clean ```]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常细节记录]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%97%A5%E5%B8%B8%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[--- title: 日常细节记录 date: 2018-04-03 13:04:15 tags: - Android - Java top: 11 --- 1. 强引用置为null时，不会立即回收对象，帮助回收器加快回收。但是会帮助GC 等到下次回收周期时即会回收 2. 死锁的四个必要条件：互斥，占有且等待，不可抢占，循环等待 3. CAS(原子操作)是乐观锁用到的主要机制，乐观锁是不用加锁去执行操作，如果产生冲突则失败重试，直到成功为止，也叫做“自旋”。与乐观锁相对应的是悲观锁，synchronized就是悲观锁，也叫“独占锁”需要加锁进行操作，并且加锁代码块中的只能有一个线程进行操作。 4. 点击App图标，系统最开始执行的是ActivityThread的main()方法 5. 应用的启动方式： - 冷启动：启动应用时，后台没有该应用的进程。系统创建一个新的进程来进行重新分配。 - 热启动：启动应用时，后台已有该应用的进程。 6. Application的生命周期：`onCreate()//应用开始时执行->onLowMemory()//内存低时执行->onTrimMemory()//关闭应用时执行 onTerminate()//在真机上不会调用` 7. 进程相关： `优先级最低的进程首先被杀死、进程的等级会因为其他进程的依赖而提高一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低` 按重要性分类： - 前台进程：进程持有一个正在与用户交互的Activity或者和交互Activity绑定的Service，前台运行的Service（执行`startForeground()`）,执行`onReceive()`的BroadcastReceiver - 可见进程：进程持有一个被用户可见但没有显示在最前端的Activity(调用到了`onPause()`)或者和可见Activity绑定的Service - 服务进程：进程持有一个`startService()`启动的Service进程，例如播放音乐，下载文件等Service - 后台进程：进程持有一个用户不可见的Activity(调用到`onStop()`没有到`onDestroy()`)，进程被存放在一个LRU列表中，即很长时间没用的Activity会被优先杀死 - 空进程：进程不包含任何活跃的应用组件，唯一的作用是`为了缓存需要，缩短下次启动的时间` 8. 统计应用启动时间：`adb shell am start -W [packageName]/[packageName.MainActivity]` 9. `volatile`作用是`可见性`(当一个线程修改了某一个全局变量的值，其他线程能否知道这个修改)，`有序性`（禁止指令重排优化,防止代码执行指令被重新排序）。`volatile`并不能保证线程安全即保证不了线程间操作的原子性。 10. SharedPreference中`apply`和`commit`方法的区别：`commit`同步保存更改，`apply`异步保存到磁盘，原子提交，性能较高，但不保存结果。SharedPreference不支持多线程操作，`MODE_MULTI_PROCESS`这个标记位并没有实际作用。可以利用`ContentProvider`去实现多进程，_方案后续会有介绍_。 11. MD5不是加密算法，是一种散列算法。加密算法一般是对称加密算法 12. 使用ADB启动Activity：`adb shell am start -n 包名/需启动Activity路径` 13. Fragment中`replace`与`add`区别： - `replcae`：把容器内所有内容进行替换，都需要重新走一遍fragment的生命周期 - `add`：添加不会清空容器内的内容。 14. 在三星手机上，进行原生分享文件时需要设置mimeType 15. `invalidate()`、`postInvalidate()`和`requestLayout()`的区别： - `invalidate()`：当子View调用invalidate方法时，会给View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递至ViewRootImpl中，最终触发performTraversals方法，进行View的重绘（即调用onDraw方法）。**该方法只能在UI线程中调用** - `postInvalidate()`：与invalidate作用一致，都是使View进行重绘，**该方法是在非UI线程中调用的**。内部主要实现是提供一个Handler实现，然后直接调用了invalidate方法，继续执行重绘流程。 - `requestLayout()`：调用了这个方法会重新执行View的绘制流程，即重新执行测量(`onMeasure`)，布局(`onLayout`)，绘制(`onDraw`)方法。**利用责任链模式-不断向上传递该事件，直到找到能处理该事件的上级**。 16. Bitmap所占用的内存 = 图片长度 x 图片宽度 x （屏幕分辨率÷图片资源目录分辨率）²×一个像素点占用的字节数 17. HashMap扩容机制 在1.8之前只要达到负载就进行扩容，1.8之后是防止Hash冲突才进行扩容，如果不冲突不会触发扩容。 18. dp,px,sp相关概念：]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XII]]></title>
    <url>%2F2018%2F04%2F01%2FAndroid-Study-Plan-XII%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XII date: 2018-04-01 17:58:32 tags: Android --- # Android学习计划 ## 从源码的角度描述下Activity的启动过程]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity,Window,View的关联与理解]]></title>
    <url>%2F2018%2F04%2F01%2FActivity-Window-View%E7%9A%84%E5%85%B3%E8%81%94%E4%B8%8E%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[--- title: 'Activity,Window,View的关联与理解' date: 2018-04-01 17:27:58 tags: Android --- # Activity,Window,View相关 ## 1. 什么是Activity,Window,View以及职能简介 - Activity：不负责视图控制，只是控制生命周期和处理事件，真正控制视图的是Window，一个Activity包含一个Window，Window真正代表一个窗口。`Activity是一个控制器，控制视图的添加与显示以及通过回调方法来进行Window与View的交互。` - Window：Window是视图的承载器，内部持有一个DecorView，DecorView才是view的根布局，Window为抽象类，实际是Activity中的其子类PhoneWindow，其中有个内部类DecorView，通过创建DecorView来加载`R.layout.*`，Window通过WindowManager加载DecorView，并将DecorView和ViewRoot关联，进行视图控制与交互。 - View：DecorView继承自FrameLayout,DecorView作为顶级View，一般其内部包含一个竖直方向的LinearLayout，里面包含ViewStub，标题栏（titleView），内容栏（contentView）。Activity通过`setContentView()`将布局文件加载进内容栏中。 - ViewRoot：ViewRoot的实现类是ViewRootImpl，是WindowService和DecorView之间的纽带。ViewRoot不属于View节点，和View之间没有直接联系，不过实现了ViewParent接口。 {% fullimage /images/study_plan/activity_window_view.png, alt,流程图 %} ## 2. Activity，Window，View的关系 > 基本关系是：Activity中展示元素通过Window实现，Window可以理解为一个容器，里面装载着一个个的View，来执行显示工作。 ## 3. Activity如何和Window，View关联（附源码） > Activity和Window关联 > ## 4. View和Window有什么联系]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础排序算法介绍]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[--- title: 基础排序算法介绍 date: 2018-03-20 20:40:23 tags: 算法 mathjax: true top: 10 --- # 基础排序算法介绍 ## 知识点: - 排序算法稳定性的定义：简单的介绍就是排序前相等的数据先后顺序在排序后的先后顺序位置相同 - 基本交换算法 ```java private static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } ``` - 时间复杂度：执行算法所需要的计算工作量 $ O(1) $ 意味没有循环即只执行单条语句 $ O(n) $ 执行没有嵌套的循环 $ O(n^2) $ 双重嵌套循环 - 空间复杂度：算法在运行工程中临时占用存储空间的量度 算法 | 平均时间 | 最好 | 最差 | 空间复杂度 | 稳定性 - | :-: | :-: | :-: | :-: | :-: | :-: | -: 冒泡排序| $ O(n^2) $ | $ O(n) $ | $ O(n^2) $ | $ O(1) $ | 稳定 直接插入排序| $ O(n^2) $ | $ O(n) $ | $ O(n^2) $ | $ O(1) $ | 稳定 折半插入排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(n^2) $ | $ O(1) $ | 稳定 希尔排序| $ O(nlogn) $ - $ O(n^2) $ | $ O(n^1.3) $ | $ O(n^2) $ | $ O(1) $ | 不稳定 选择排序| $ O(n^2) $ | $ O(n^2) $ | $ O(n^2) $ | $ O(1) $ | 不稳定 快速排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(n^2) $ | $ O(nlogn) $ - $ O(n^2) $ | 不稳定 归并排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(nlogn) $ | $ O(n) $ | 稳定 堆排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(nlogn) $ | $ O(1) $ | 不稳定 ## 排序算法 ### 冒泡排序 > 在要排序的一组数中，对当前范围内还未排列好的数据由上而下进行比较，即每当相邻的数与要求的排序方式相反时将数据进行互换 > 改进版的写法就是利用标记法减少循环次数 > 基本写法 ```java private static void bubbleSort(int[] array) { int size = array.length; for (int i = 0; i < size - 1; i++) { for (int j = 1; j < size - i; j++) { if (array[j - 1] > array[j]) { swap(array, j, j - 1); } } } } ``` > 改进写法 ```java private static void advancedBubbleSort(int[] array) { int size = array.length; int flag = 0;//设置标记位 for (int i = 0; i < size - 1; i++) { flag = 0; for (int j = 1; j < size - i; j++) { if (array[j - 1] > array[j]) { flag = 1; swap(array, j, j - 1); } } if (flag == 0)//没有发生数据交换则意味着排序已经结束 break; } } ``` ---- ### 选择排序 > 再一次遍历过程中找到最小值放在排序数据中的首位，每次寻找剩余中最小的直到结束为止。 ```java private static void selectSort(int[] array) { int size = array.length; for (int i = 0; i < size; i++) { int minIndex = i; for (int j = i + 1; j < size; j++) { if (array[j] < array[minIndex]) { minIndex = j; } } swap(array, i, minIndex); } } ``` ---- ### 直接插入排序 > 按照顺序选定元素从后往前找，插入一个顺序数列中即可 ```java private static void InsertSort(int[] array) { int size = array.length; for (int i = 0; i < size; i++) { int temp = array[i]; for (int j = i; j > 0 && array[j - 1] > array[j]; j--) {//从该元素所在位置 向前移动 直到该元素位于 递增顺序 array[j] = array[j - 1]; array[j - 1] = temp; } } } ``` ---- ### 折半插入排序 > 再往前寻找位置的过程中利用二分法寻找位置 ```java private static void insertBinarySort(int[] array) { int size = array.length; for (int i = 1; i < size; i++) { if (array[i] < array[i - 1]) {//前比后大 int temp = array[i]; int low = 0, high = i - 1, mid; while (low 先取`d`为间隔，将原始数组分为d个序列，将间隔的数组放在一个子序列利用插入排序法进行排序 然后缩小间隔`d` 重复上述操作，知道`d`为1时，则排序完成 ```java private static void shellSort(int[] array) { int size = array.length; for (int d = size / 2; d > 0; d /= 2) {//设置步长 for (int i = 0; i < size; i += d) { int temp = array[i]; int j = i; for (; j >= d && temp < array[j - d]; j -= d) { array[j] = array[j - d]; } array[j] = temp; } } } ``` ---- ### 基数排序 > 讲一组元素进行桶分配，按照每位数的大小进行排序 ```java private static void radixSort(int[] array) { int size = array.length; int max = array[0];//数组中的最大数 for (int i = 0; i < size; i++) { if (array[i] > max) max = array[i]; } int time = 0;//最大位数 while (max > 0) { max /= 10; time++; } int k = 0;//索引 int m = 1;//位值 int n = 1;//第几位 int[][] temp = new int[10][size]; int[] order = new int[10]; while (m]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XI]]></title>
    <url>%2F2018%2F03%2F19%2FAndroid-Study-Plan-XI%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XI date: 2018-03-19 19:47:12 tags: Android --- # Android学习计划 话题：Okhttp和Retrofit 1、介绍这两个框架的作用和联系 PS：这个问题几乎Android面试必问]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide源码解析要点]]></title>
    <url>%2F2018%2F03%2F18%2FGlide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[--- title: Glide源码解析要点 date: 2018-03-18 19:36:39 tags: 源码解析 --- > 该源码解析是基于最新的Glide 4.6.0进行的]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan IX - ClassLoaderß]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-IX%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan IX - ClassLoaderß date: 2018-03-18 17:48:29 tags: Android --- # Android学习计划 话题：Android中的ClassLoader 1、Android中有哪几种ClassLoader？它们的作用和区别是什么？ 2、简述ClassLoader的双亲委托模型 3、简述双亲委托模型在热修复领域的应用 # 答案 ## 1.Android中有哪几种ClassLoader？它们的作用和区别是什么？ > 在Android程序中，.dex文件就是一群.class文件。 {% fullimage /images/study_plan/android_classloader.png, alt,SingleTop %} - **BootClassLoader** > BootClassLodaer是ClassLoader内部实现类，是只能包内可见，我们是无法调用的。在无父构造器传入的情况下，默认构建一个PathClassLoader且父构造器为BootClassLoader > ```java private static ClassLoader createSystemClassLoader() { String classPath = System.getProperty("java.class.path", "."); String librarySearchPath = System.getProperty("java.library.path", ""); return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance()); } ``` - **URLClassLoader** > 只能用于加载jar文件，但是在dalvik（Android5.0之前的虚拟机）无法直接识别jar，所以Android中无法使用这个加载器。 - **BaseDexClassLoader** > 用于加载各种dex中的类 > ```java public class BaseDexClassLoader extends ClassLoader { public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) { throw new RuntimeException("Stub!"); } ... } ``` > > 主要构造函数介绍： > > - dexPath：指`目标类所在的apk、dex或jar文件的路径，也可以是SD卡的路径`，类加载器从该路径加载目标类。如果包含多个路径，路径之间必须用特定的分隔符去分隔，特定的分隔符从`System.getProperty("path.separtor")`获取（默认分割符为":"）。最终将路径上的文件ODEX优化到optimizedDirectory，然后进行加载。 > - optimizedDirectory：解压出的dex文件路径，这个路径必须为内部路径，一般情况下的路径为`/data/data//` > - librarySearchPath：存放目标类中使用的native文件库，也以":"分割 > - parent：父加载器，在Android中以`context.getClassLoader`作为父加载器。 - **DexClassLoader** > 继承自BaseDexClassLoader，支持加载包含classes.dex的jar、apk，zip文件，可以是SD卡的路径。是实现热修复的关键。**注意不要把优化后的文件放在外部存储，可能导致注入攻击。** - **PathClassLoader** > 用来加载Android系统类和应用程序的类，**在dalvik上只能加载已安装apk的dex(/data/app目录)，在ART虚拟机上则没有这个限制**。 ```java public class PathClassLoader extends BaseDexClassLoader { public PathClassLoader(String dexPath, ClassLoader parent) { super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); } public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) { super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); } } ``` > 在PathDexClassLoader的构造方法中optimizedDirectory为null，因为默认参数为`/data/dalvik-cache`目录。 - **InMemoryDexClassLoader** > 用于加载内存中的dex文件(在API26中添加) > ```java public final class InMemoryDexClassLoader extends BaseDexClassLoader { public InMemoryDexClassLoader(ByteBuffer[] dexBuffers, ClassLoader parent) { super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); } public InMemoryDexClassLoader(ByteBuffer dexBuffer, ClassLoader parent) { super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); } } ``` - **DelegateClassLoader** > 是一个先查找在委托的类加载器(API27添加)，按照以下顺序实现加载： > > 1. 首先判断该类是否被加载 > 2. 搜索此类的类加载器是否加载过这个类 > 3. 使用当前加载器去尝试加载类 > 4. 最后委托给父加载器加载 ## 2.简述ClassLoader的双亲委托模型 {% post_link JVM相关及其拓展-三 %} ## 3.简述双亲委托模型在热修复领域的应用 一个ClassLoader文件可以有多少Dex文件，每个Dex文件是一个Element，多个Dex文件组成一个有序数组DexElements，当找类的时候会按照顺序遍历Dex文件，然后在当前遍历的Dex文件中找出类。由于双亲委托模型机制的存在，只要找到类就会停止检索并返回，找不到就会查询下一个Dex，所以只要我们先找到并加载修复Bug的文件，则有bug的Dex文件不会被加载。 注意点：假设有个A类，引用了B类。发布过程中发现B类有bug，若想要发个新的B类，需要阻止A加上这个类标志CLASS_ISPREVERIFIED。 ## 4. 基本热修复代码实现]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan VIII - Java引用类型]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-VIII%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan VIII - Java引用类型 date: 2018-03-18 17:48:20 tags: Android --- # Android学习计划 话题：Java基础知识学习 1、Java中有哪几种引用？它们的含义和区别是什么？ 2、请用Java实现一个线程安全且高效的单例模式。 # 答案 ## 1. Java中有哪几种引用？它们的含义和区别是什么？ - 强引用（StrongReference）：`无论内存是否充足，都不会被回收`强引用指的是在代码中普遍存在的类似`Object object=new Object();`这类的引用，只要有这类的存在，垃圾回收器永远不会回收该对象，这也是导致OOM异常出现的主要原因。若想中断强引用可以把对象置为`null`。 - 弱引用（WeakReference）：`内存不足时，会被回收`弱引用用来修饰非必需对象，弱引用所关联的对象生命周期只到下一次垃圾回收前，无论内存是否充足都会被回收关联对象。 ```java String s=new String("abc"); WeakReference weakReference=new WeakReference(s); //当内存回收时 调用weakRefrence=null 并且 System.gc(); ``` - 软引用（SoftReference）：`无论内存是否充足，都会被回收`软引用用来修饰一些有用但非必需的对象，软引用所关联的对象将会在系统即将发生OOM前，会把对象进行二次回收，若回收完内存还是不足则会发生OOM异常。`可实现内存敏感的高速缓存` ```java String s=new String("abc"); SoftReference softReference=new SoftReference(s); //当内存不足时 会调用 softRefrence=null 并且 System.gc(); ``` - 虚引用（PhantomReference）：`任何时候都会被回收`虚引用不会决定对象的生命周期，虚引用关联的对象任何时候都可能被垃圾回收器回收。虚引用的作用是：跟踪对象被垃圾回收器回收的活动，虚引用本身加入引用队列中，记录引用对象是都被回收。 ## 2. 请用Java实现一个线程安全且高效的单例模式。 > 单例：一个类有且仅有一个实例，并且自行实例化向整个系统提供。目的为 > > - 减少内存的占用 > - 阻止对象实例化自己的单例对象副本，从而确保所有对象访问统一实例 > - 控制了实例化过程所以可以灵活化控制实例过程。 > > 线程安全：再多线程访问时采用加锁机制，当一个线程访问该数据时，其他线程不能访问该数据，直到读取完毕才可以访问。不会出现数据不一致和数据污染。 > 双重校验锁（DCL） ```java public class Singleton { private static volatile Singleton mInstance; private Singleton() { } public static Singleton getInstance() { if (mInstance == null) { synchronized (Singleton.class) { if (mInstance == null) { mInstance = new Singleton(); } } } return mInstance; } } ``` > 在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则`mInstance = new Singleton(); `可能出现`mInstance `尚未被初始化的异常。 > `mInstance = new Singleton(); `包括三步：`为对象分配内存`，`执行构造方法，初始化实例对象`，`把mInstance的引用指向分配的内存空间`。在JVM的执行过程中并不是原子性的。 > 保护序列化与反序列化安全的写法： ```java /** *反序列化提供的一个特殊方法，可以控制对象的反序列化。 */ private Object readResolve(){ return mInstance;//返回实例对象 } ``` > 静态内部类： > > `为何可以保证线程安全？`虚拟机可以保证一个类的类构造器 `()`在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。**同一个类加载器下，一个类型只会被初始化一次。** ```java public class Singleton { private Singleton() { } public static Singleton getInstance() { return SingletonHolder.sInstance; } private static class SingletonHolder { private static Singleton sInstance = new Singleton(); } } ``` > 枚举写法（在Android中不推荐使用，对内存的消耗较大） 枚举法的好处：1.实例创建线程安全 2.防止被反射创建多个实例 3. 没有序列化的问题 ```java public enum Singleton{ INSTANCE; public void fun() { //do sth } } ``` ## 3. 拓展知识 - Kotlin实现的单例模式：`object Singleton{}`，本质是饿汉加载，在类加载时就会创建单例。问题在于构造方法过多时，初始化会变慢以及资源的浪费。 - Kotlin实现懒汉式加载： ```kotlin class Singleton private constructor(){ companion object { val instance: Singleton by lazy { Singleton() } } } ```]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan VI]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-VI%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan VI date: 2018-03-18 17:48:09 tags: Android --- # Android学习计划 话题：关于Gradle的知识 1、如何理解Gradle？Grade在Android的构建过程中有什么作用？ 2、实践如下问题。 问题：我们都知道，Android中时常需要发布渠道包，需要将渠道信息附加到apk中，然后在程序启动的时候读取渠道信息。 动态指定一个渠道号（比如1001），那么构建的apk中，请在它的AndroidManifest.xml文件里面的application节点下面添加如下meta-data，请写一段Gradle脚本来自动完成： ```xml ``` 要求：当通过如下命令来构建渠道包的时候，将渠道号自动添加到apk的manifest中。 ./gradlew clean assembleRelease -P channel=1001]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan V]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-V%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan V date: 2018-03-18 17:48:03 tags: Android --- # Android学习计划 话题：关于View的知识 1、View的getWidth()和getMeasuredWidth()有什么区别吗？ 2、如何在onCreate中拿到View的宽度和高度？ # 答案 ## 1. View的getWidth()和getMeasuredWidth()有什么区别吗？ - `getWidth()`通过`setFrame`方法来决定四个顶点位置，初始化`mLeft,mTop,mRight,mBottom`四个参数，这四个值固定则位置确定。必须在layout过程结束才有值。 ```java /** * Return the width of the your view. * * @return The width of your view, in pixels. * 利用屏幕上的右坐标减去左边的坐标 */ @ViewDebug.ExportedProperty(category = "layout") public final int getWidth() { return mRight - mLeft; } protected boolean setFrame(int left, int top, int right, int bottom) { ... mLeft = left; mTop = top; mRight = right; mBottom = bottom; ... } ``` - `getMeasuredWidth`是在view的绘制流程中的`measure`结束后有值，获取的是view的测量宽高。`mMeasuredWidth `是在`setMeasuredDimensionRaw `方法中赋值的 ```java public static final int MEASURED\_SIZE\_MASK = 0x00ffffff; /** * Like {@link #getMeasuredWidthAndState()}, but only returns the * raw width component (that is the result is masked by * {@link #MEASURED_SIZE_MASK}). * * @return The raw measured width of this view. */ public final int getMeasuredWidth() { return mMeasuredWidth & MEASURED_SIZE_MASK;//与任何数字的运算得到的结果是mMeasuredWidth } private void setMeasuredDimensionRaw(int measuredWidth, measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; } ``` - 一般情况下 `getMeasuredWidth `和`getWidth`的值是相同的，从源码中可以看出`setMeasuredDimensionRaw `会对`mMeasuredWidth `进行赋值，当调用了`onMeasure`，会调用到`setMeasuredDimensionRaw `则获取的结果将会不相同 ```java public final void measure(int widthMeasureSpec, int heightMeasureSpec) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } ... if (forceLayout || needsLayout) { // first clears the measured dimension flag mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex < 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value >> 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException("View with id " + getId() + ": " + getClass().getName() + "#onMeasure() did not set the" + " measured dimension by calling" + " setMeasuredDimension()"); } mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } ... } ``` - view的绘制流程`measure` `layout` `draw` {% fullimage /images/study_plan/view_process.png, alt,流程图 %} - `measure`为了计算出控件树中的各个控件要显示的内容以及大小，起点为`ViewRootImpl 的 measureHierarchy ()`。 - SpecMode : `EXACTLY(确切大小)` `AT_MOST(子view的大小不得超过SpecSize)` `UNSPECIFIED(对子view尺寸不做限制)` ```java /** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */ public static final int UNSPECIFIED = 0 < MODE_SHIFT; /** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */ public static final int EXACTLY = 1 < MODE_SHIFT; /** * Measure specification mode: The child can be as large as it wants up * to the specified size. */ public static final int AT_MOST = 2 < MODE_SHIFT; ``` - `layout` 从根view开始，递归的完成控件树的布局工作，确定view的位置。先递归的对子view进行布局，在完成父布局的位置设置 - `draw` 从根view开始进行绘制，利用`Viwe.draw()` ## 2.如何在onCreate中拿到View的宽度和高度？ - 在 Activity#onWindowFocusChanged 回调中获取宽高。 - view.post(runnable)，在 runnable 中获取宽高。 `利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。` - ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。 `监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露` - 调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高。 ## 补充知识点 - matchParent无法measure(在view的measure过程中，需要知道parentSize即父容器的剩余空间，所以无法得出measure的大小) - [深入理解View绘制流程][1] [1]: https://www.cnblogs.com/jycboy/p/6219915.html#autoid-7-1-0]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan IV]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-IV%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan IV date: 2018-03-18 17:47:55 tags: Android --- # Android学习计划 话题：关于startActivityForResult 1、startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode以及intent含义是什么？ 2、Activity A启动B的时候，在B中何时该执行setResult ？setResult可以位于Activity的finish方法之后吗？ # 答案 ## 1. startActivityForResult 使用场景是什么？ requestCode、 resultCode 含义是什么？ ### 1.1 使用场景 - 用户开始新的活动，并且希望得到新活动的某些信息。比如选择照片、选择联系人、选择收货地址、进行某块数据编辑工作等。 ### 1.2 requestCode - 解决的是「区分多个异步任务」的问题。与其他异步 API 的设计类似，如果没有这个信息，那么 Activity 在收到响应时会进入混乱的状态。比如他不知道自己得到的是选择照片还是选择联系人的结果。 - 该信息会发送到 AMS 那边的 ActivityRecord.requestCode 变量进行记录，Client 端新 Activity 并不知道这个信息。 - 为什么 `requestCode`\< 0 时收不到结果？ - ActivityStarter 收到 startActivityLocked 时，写入ActivityRecord.resultTo 变量为空[对应源码][1] ``` java ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; if (resultTo != null) { sourceRecord = mSupervisor.isInAnyStackLocked(resultTo); if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, "Will send result to " + resultTo + " " + sourceRecord); if (sourceRecord != null) { if (requestCode >= 0 && !sourceRecord.finishing) { resultRecord = sourceRecord; } } } ``` - 在 ActivityStack 收到 finishActivityResultsLocked 时，读取 ActivityRecord.resultTo 变量为空，结果数据不会添加到源 ActivityRecord.results 变量 - 在 ActivityStack 收到 resumeTopActivityInnerLocked 时，读取 ActivityRecord.results 数组为空，不会分发结果数据，这样源 Activity 也就没有结果回调了 ### 1.3 resultCode - 异步调用结果码，告诉调用者成功/失败/其它信息 - 该信息由被调用 Activity / framework 写入，并经过 AMS 传递给源 Activity - `RESULT_CANCELED=0` `RESULT_OK=-1` `RESULT_FIRST_USER=1` ### 1.4 intent - 用于存储需要传递的数据 - 大小不得大于1M ## 2. A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？ ### 2.1 setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中 Activity 构造器阶段 大部分在显示调用finish()或者onBackPressed() ```java public final void setResult(int resultCode, Intent data) {//进行赋值 synchronized (this) { mResultCode = resultCode; mResultData = data; } } // Home 键 + 不保留后台 Activity 可触发 onDestroy protected void onDestroy() { if (DEBUG_LIFECYCLE) Slog.v(TAG, "onDestroy " + this); mCalled = true; // dismiss any dialogs we are managing. if (mManagedDialogs != null) { final int numDialogs = mManagedDialogs.size(); for (int i = 0; i < numDialogs; i++) { final ManagedDialog md = mManagedDialogs.valueAt(i); if (md.mDialog.isShowing()) { md.mDialog.dismiss(); } } mManagedDialogs = null; } // close any cursors we are managing. synchronized (mManagedCursors) { int numCursors = mManagedCursors.size(); for (int i = 0; i < numCursors; i++) { ManagedCursor c = mManagedCursors.get(i); if (c != null) { c.mCursor.close(); } } mManagedCursors.clear(); } // Close any open search dialog if (mSearchManager != null) { mSearchManager.stopSearch(); } if (mActionBar != null) { mActionBar.onDestroy(); } getApplication().dispatchActivityDestroyed(this); } private void finish(int finishTask) { if (mParent == null) { int resultCode; Intent resultData; synchronized (this) { resultCode = mResultCode; resultData = mResultData; } if (false) Log.v(TAG, "Finishing self: token=" + mToken); try { if (resultData != null) { resultData.prepareToLeaveProcess(this); } if (ActivityManager.getService() .finishActivity(mToken, resultCode, resultData, finishTask)) { mFinished = true; } } catch (RemoteException e) { // Empty } } else { mParent.finishFromChild(this); } } ``` ### 2.2 否 - 如果位于 finish 之后执行，信息已经无法放到传递的数据中 - 从代码可以看出 setResult 和 finish 类似生产者/消费者模型，setResult 负责写入数据，finish 负责读取数据 ### 2.3 线程安全问题 - Activity.mResultCode 和 Activity.mResultData 变量由 Activity 对象的锁进行保护 - 支持后台线程和 UI 线程分别进行 setResult 和 finish - 但是为什么需要加锁保护这两个信息？需要「解决什么问题」？ ### 2.4 API 设计/数据组装问题 - 底层 AMS 提供的接口的参数是 setResult 和 finish 的参数的组合形式，但是 Activity 为什么把一个接口拆分成两个接口给开发者使用？ - 使用方便。很多情况下调用者只关心 finish ，不需要理解太多的信息 ### 2.5 启动模式冲突 - 5.0以上 singleTask和singleInstance失效，重复启动时会重新创建实例 - 以下 则会直接收到`RESULT_CANCELED` ## 3. API 内部原理/数据处理流程 {% fullimage /images/study_plan/study_plan_4.png, alt,流程图 %} > 关键节点： - Client 端通过 AMP 把数据发送给 Server 端 AMS Binder 实体 - AMS 把数据包装成 ActivityResult 并保存在源 ActivityRecord 的 results 变量中 - AMS 通过 ApplicationThreadProxy 向 Client 端发送 pause 信息让栈顶 Activity 进入 paused 状态，并等待 Client 端回复或超时 - AMS 接收 Client 端已 paused 信息，恢复下一个获取焦点的 Activity ，读取之前保存在 ActivityRecord.results 变量的数据派发给 Client 端对应的 Activity - Client 端数据经过 ApplicationThread 对象、ActivityThread 对象的分发最后到达 Activity ## 4. startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题 ### 4.1 基本原则 > 源 Activity 和目标 Activity 无法在跨 Task 情况下通过 onActivityResult 传递数据 ### 4.2 Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调 [源码链接][2] ### 4.3 Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调 [源码链接][3] ### 4.4 通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task [1]: http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#266 [2]: http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#1196 [3]: http://androidxref.com/4.4.4_r1/xref/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java#1399]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan II - Service]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-II%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan II - Service date: 2018-03-18 17:38:40 tags: Android --- # Android学习计划 话题：清晰地理解Service。 1、Service的start和bind状态有什么区别？ 2、同一个Service，先startService，然后再bindService，如何把它停止掉？ 3、你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？ 4、Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？ # 答案 {% fullimage /images/study\_plan/service\_lifecycle.png, alt,Service生命周期 %} ## 1.Service的start和bind状态有什么区别？ start启动Service,service有独立的生命周期，不依赖启动组件； 多次调用start方法，会重复调用onStartCommand方法；（判断service是否正在运行以避免多次调用） start启动的Service，需要stopService或stopSelf来停止（IntentService会自动调用）。 > 生命周期:onCreate()-\>onStartCommand()-\>onDestory() bind绑定的Service，依赖于启动组件，销毁后随之消失； 多次bind，只会调用一次onBind方法 > 生命周期:onCreate()-\>onBind()-\>onUnBind()-\>onDestory() ## 2.同一个Service，先startService，然后再bindService，如何把它停止掉？ 调用stopService和unbindService方法，顺序无关，当最后一次调用时，会进入Service的onDestory方法 ## 3.你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？ 4种返回值 ```java //版本兼容，在Service被杀死后，并不保证onStartCommand会被再一次调用 //Service被kill后，Service被重建，即会调用onCreate() public static final int START_STICKY_COMPATIBILITY = 0; /**在Service被杀死后，系统会尝试重启Service但不保存intent，会用一个null对象调用 onStartCommand方法（注意intent判空），除非有一些被发送的Intent对象在等待 Service被kill后，Service被重建、重启，即会调用onCreate()>onStartCommand()，intent对象为null。 启动服务，试用于媒体播放器之类，无限期等待*/ public static final int START_STICKY = 1; /**常规操作，除非被杀死之前还有组件调用startService，否则不保留状态并重启Service 直到接受到新的Intent对象，这个服务才会被重新创建 Service被kill后，Service没有重启*/ public static final int START_NOT_STICKY = 2; /**Service被杀死后，系统将会组织一次重启Service，在杀死前的最后一次传递的intent会被重新执行，不会传递空的intent 任意等待中的Intent对象会依次被发送。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。 */ public static final int START_REDELIVER_INTENT = 3; ``` ## 4.Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？ Service默认运行在主线程，所以生命周期的方法都会运行在主线程 ## 5.Service种类 > 按运行地点分类：`本地服务`和`远程服务` > 本地服务：依附主进程，主进程被kill后就会自动销毁 > 远程服务：运行在一个独立进程，需要利用AIDL通信需要占用一定资源而且是常驻形式 > 按运行类型分类：`前台服务`和`后台服务` > 前台服务：会在通知栏显示相关通知，当服务终止时通知栏消息即消失起到一定通知作用 > 后台服务：不会显示在前台，用户无感知，服务终止也不会有任何提示 > 按使用方式分类：`startService`，`bindService`和`混合使用` > startService：用于启动服务执行后台任务，不需要通信，停止需要stopService > bindService：启动的服务需要进行通信，unbindService停止 > 混合使用：停止服务需同时调用stopService，unbindService ## 6.IntentService介绍 继承Service的一个异步请求类，在IntentService有一个工作进程处理耗时操作，启动方式和普通Service一样。任务执行完毕后，IntentService会自动关闭。每次只会执行一个而不至于堵塞UI线程。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
