<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[View的工作原理]]></title>
    <url>%2F2018%2F12%2F14%2FView%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[--- title: View的工作原理 date: 2018-12-14 16:47:21 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java--反射]]></title>
    <url>%2F2018%2F12%2F14%2FJava-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[--- title: Java--反射 date: 2018-12-14 16:41:02 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[LRUCache原理]]></title>
    <url>%2F2018%2F12%2F14%2FLRUCache%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[--- title: LRUCache原理 date: 2018-12-14 16:40:15 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式--基本原则]]></title>
    <url>%2F2018%2F12%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[--- title: 设计模式--基本原则 date: 2018-12-14 10:01:55 tags: 设计模式 top: 10 --- # 设计模式六大基本原则 ## 单一职责原则（SRP） > 单一职责原则英文名称为`Single Responsibility Principle`,简称SRP。 优点： - 类的复杂性降低，实现什么职责都有清晰明确的定义 - 可读性提高，复杂性降低 - 可维护性高 对于开发过程来说，**接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化**。 ## 里氏替换原则（LSP） > 所有引用父类的地方都必须能透明的使用其子类的对象。简单的说就是 **父类能出现的地方子类就可以出现。** 里氏替换原则为良好的继承定义了一个规范，主要包含了4个含义： - **子类必须完全实现父类的方法**：`如果子类不能完整的实现父类的方法，或者父类方法在子类中已无法实现，建议断开父子继承关系，采用依赖、聚集，组合等方法代替继承。` - **子类可以有自己的个性**：`里氏替换原则可以正着用，但不能反过来用。子类出现的地方，父类未必可以使用。` - **覆盖或实现父类的方法时输入参数可以被放大**：`子类中的方法前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松。` - **覆写或实现父类的方法时输出结果可以被缩小** 在开发过程中尽量避免子类的”个性“，有了之后，与父类的关系就难调和。 ## 依赖倒置原则（DIP） > - 高层模块不应该依赖低层模块，两者都应该依赖其抽象 > - 抽象不应该依赖细节 > - 细节应该依赖于抽象 > > **面向接口编程** 本质就是通过抽象（接口或者抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的送耦合。 ## 接口隔离原则（ISP） > 接口分为两种：实例接口 和 类接口 > > 接口尽量细化，同时接口中的方法要尽量少。尽量使用多个专门的接口。 接口隔离原则是对接口进行规范约束，包含以下4层含义： - 接口要尽量小 **不能违反单一职责原则** - 接口要高内聚：`高内聚就是提高接口、类，模块的处理能力，减少对外的交互` - 定制服务：**只提供访问者需要的方法，减少可能引起的风险** - 接口设计是有限度的：`接口的设计粒度越小，系统越灵活，但是会增加结构复杂度以及开发难度` 在开发过程中可以按照如下规则设计： - 一个接口只服务于一个子模块或业务逻辑 - 通过业务逻辑压缩接口中的public方法 - 已经被污染的接口尽量去修改 - 根据每个项目或产品去制定拆分标准 ## 迪米特法则（LoD）--最少知识原则(LKP) > 一个对象应该对其他对象有最少的了解 迪米特法则对类的低耦合提出了明确的要求，包含以下4个含义： - 只和朋友交流：**在类的一个方法中尽量不引入一个类中不存在的对象** - 朋友间也是有距离的：**尽量不对外公布太多的public方法和非静态的public变量，尽量内敛** - 是自己的就是自己的：**如果一个方法放在本类中，既不增加类间关系，也不会对本类产生负面影响，就可以放置在本类中** - 谨慎使用Serializable：**在进行传输对象时需要进行序列化，当修改了属性时，会导致反序列化失败** 迪米特法则核心观念就是**类间解耦，弱耦合**。 ## 开闭原则（OCP）—最基础的原则 > 软件实体应该对扩展开放，对修改关闭。`一个软件实体应该通过扩展来实现变化，而不是去修改已有代码。` **开闭原则并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合** 开闭原则的重要性： - 减少测试工作量 - 提高复用性 - 提高可维护性 - 面向对象开发]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--单例模式]]></title>
    <url>%2F2018%2F12%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[--- title: 设计模式--单例模式 date: 2018-12-13 17:15:07 tags: 设计模式 top: 10 --- # 单例模式 > 一个类只能产生一个对象。确保某一个只有一个实例，而且自行实例化并向整个系统提供这个实例且构造函数私有化。 {% fullimage /images/Pattern-Singleton.png,单例模式,单例模式 %} ```java //单例模式通用代码 public class Singleton{ private static final Singleton singleton = new Singleton(); private Singleton(){ } public static Singleton getSingleton(){ return singleton; } public static void doSth(){ } } ``` 单例模式优点： 1. 由于单例模式只存在一个实例，减少了内存开支 2. 减少了系统的开销 3. 避免对资源的多重占用 4. 在系统设置全局访问点，优化和共享资源访问 5. 允许可变数目的实例，基于单例模式可以进行拓展，可以获得指定个数的对象实例，既节省系统资源，又解决单例对象过多的性能损耗 单例模式缺点： 1. 单例模式一般没有接口，扩展很困难。 2. 单例模式对测试是不利的，因为单例模式没有完成时，是不能进行测试的。 3. 与单一职责原则有冲突 单例模式使用场景： 1. 要求生成唯一序列号的环境 2. 在整个项目中需要一个共享访问点或共享数据 3. 创建一个对象需要的消耗资源过多，如访问IO和数据库 4. 需要定义大量的静态常亮和静态方法 单例模式注意事项： 1. 在高并发情况下，注意单例模式的线程同步问题 2. 考虑对象的复制情况 单例模式实现实例： - 双重校验锁（DCL）--Java5之后可以安心使用该方法 ```java public class Singleton { private static volatile Singleton mInstance; private Singleton() { } public static Singleton getInstance() { if (mInstance == null) { synchronized (Singleton.class) { if (mInstance == null) { mInstance = new Singleton(); } } } return mInstance; } //反序列化提供的一个特殊方法，可以控制对象的反序列化 private Object readResolve(){ return mInstance;//返回实例对象 } } ``` > 在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则`mInstance = new Singleton(); `可能出现`mInstance `尚未被初始化的异常。 > > `mInstance = new Singleton(); `包括三步：`为对象分配内存`，`执行构造方法，初始化实例对象`，`把mInstance的引用指向分配的内存空间`。在JVM的执行过程中并不是原子性的。 - 静态内部类 ```java public class Singleton{ private static class SingletonHolder{ private static final Singleton INSTANCE = new Singleton(); } private Singleton(){ } public static Singleton getInstance(){ return SingletonHolder.INSTANCE; } } ``` > 为何可以保证线程安全？`虚拟机可以保证一个类的类构造器 `()`在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。**同一个类加载器下，一个类型只会被初始化一次。** - 枚举 ```java public enum Singleton { INSTANCE; } ``` > 防止反序列化重新创建新对象，在Android中不建议使用枚举，大概会增加4倍消耗。 单例模式在Android中的体现： ```java //../android/view/inoputmethod/InputMethodManager.java public static InputMethodManager getInstance() { synchronized (InputMethodManager.class) { if (sInstance == null) { try { sInstance = new InputMethodManager(Looper.getMainLooper()); } catch (ServiceNotFoundException e) { throw new IllegalStateException(e); } } return sInstance; } } ```]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binder系列-ContentProvide]]></title>
    <url>%2F2018%2F12%2F13%2FBinder%E7%B3%BB%E5%88%97-ContentProvide%2F</url>
    <content type="text"><![CDATA[--- title: Binder系列-ContentProvide date: 2018-12-13 15:47:50 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[Binder系列-ServiceManager相关]]></title>
    <url>%2F2018%2F12%2F12%2FBinder%E7%B3%BB%E5%88%97-ServiceManager%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[--- title: Binder系列-ServiceManager相关 date: 2018-12-12 11:48:22 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[Binder及AIDL]]></title>
    <url>%2F2018%2F12%2F11%2FBinder%E5%8F%8AAIDL%2F</url>
    <content type="text"><![CDATA[--- title: Binder及AIDL date: 2018-12-11 14:24:06 tags: Android top: 11 --- # 主要分析IPC机制，Binder框架以及AIDL原理 ## 1.IPC机制 > IPC是Inter-Process Communication的缩写。含义为进程间通信或者跨进程通信，指代两个进程间进行数据交换的过程、 还需要理解进程以及线程的区别和联系 > 进程：一般指一个执行单元，在设备上一般代指应用程序。 > > 线程：CPU调度的最小单元且线程是有限资源。 > > 一个进程可以包含多个线程，即一个应用内部可以执行多个任务。在Android中就会区分为`主线程(UI线程)`和`子线程`，一般会在子线程上做耗时操作，主线程不可。 由于IPC的使用场景是在多进程模式下。多进程的使用情况主要分为两种：`一个应用因为某些原因需要采用多进程模式来实现，比如获取更大内存空间`,`当前应用需要向其他应用来获取数据`。 ### 1. 多进程模式 1. 开启多进程模式 - 通过JNI在native层fork一个新的进程 - 在`AndroidManifest.xml`中给四大组件指定属性`android:process`。 2. 进程名的命名 ```xml ``` 上述代码为两种命名方案 - 省略包名以:开头：代指进程名为`com.wxy.test:remote`为**私有进程**，其他进程的组件不可以和他跑到同一个进程中 - 完整命名：如上述`com.wxy.test.remote`为**全局进程**，其他应用可以通过`ShareUID方式与他在同一进程中运行。` Android系统会为每一个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。 上述通过ShareUID将两个应用跑在同一个进程间是有要求的，**必须是两个应用具有相同的ShareUID且签名相同才可以**。达成上述要求时就可以 **共享两者间的data目录、组件信息以及内存数据**。 拓展知识：当两者签名不同时，会触发安装错误[INSTALL_FAILED_SHARED_USER_INCOMPATIBLE] 3. 查看进程信息 `adb shell ps|greb $packageName` 4. 运行机制 Android为每一个应用分配了一个独立的虚拟机，或者说为了每一个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上就会有不同的地址空间，就会导致不同的虚拟机访问同一个类的对象会产生多分副本。 **所有运行在不同进程的四大组件，只要他们通过内存共享数据，就会共享失败。** 5. 多进程造成的问题 - 静态成员变量和单例模式完全失效 - 线程同步机制失败 - SharedPreferences的可靠性下降 `不支持多进程读写` - Application会多次创建`分配了独立的虚拟机` 一个应用内的多进程：**相当于两个不同的应用采用了ShareUId模式**。虽说不能直接共享内存数据，但是可以通过跨进程通信来实现数据交互。 ### 2. 序列化 > 当我们需要跨进程通信时，传递的数据就需要进行序列化传递，然后接受方在反序列化得到传递数据 > 什么是序列化？ > > 将对象转化为可以传输的二进制流的过程，就可以通过序列化，转化为可以在网络传输或者保存到本地的流，从而进行传输数据。反序列化即为从二进制流转化为对象的过程。 > > > 也为了解决对象的持久化问题。当你在程序中声明一个类后，程序关闭则释放对象，持久化就是为了应用关闭后类的内容依然存在。 1. `Serializable` > 由Java提供的一个序列化接口，为对象提供标准的序列化以及反序列化操作。 使用方式相当简单 ```java public class User implements Serializable{ //该参数是用来辅助序列化以及反序列化的过程，原则上该值相同才可以进行序列化以及反序列化的操作. //不指定时 系统也会自动生成 但是容易因为变量的数量和类型发生改变而导致序列化失败。 private static final long serialVersionUID = 123123L; public String name; ... } ``` 优缺点：使用简单但是效率较低，在序列化(ObjectOutputStream)以及反序列化(ObjectInputStream)类调用中会有大量的I/O操作。 适用场景：将对象类序列化存储到设备或者需要网络传输。 2. `Parcelable` > Android提供的序列化接口，使用起来较为繁琐 ```java import android.os.Parcel; import android.os.Parcelable; public class User implements Parcelable { public String name; protected User(Parcel in) { name = in.readString(); } public static final Creator CREATOR = new Creator() { @Override public User createFromParcel(Parcel in) { return new User(in); } @Override public User[] newArray(int size) { return new User[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); } } ``` 序列化功能由`writeToParcel`实现，反序列化由`Parcel的read`实现。 优缺点：传递效率高效使用较为繁琐，主要序列化都在内存上进行。由于Parcelabel是Android提供的方法，可能会由于版本更新而会有些许改动。 适用场景：在内存的序列化中使用。 ### 3. IPC方式 > 本节主要讲述各种跨进程通信方式，目前有以下六种： > > {% fullimage /images/IPC-mode.png,IPC方式, IPC方式 %} > > 上述方式实际都是通过Binder来实现的 #### 1.Bundle > 支持在`Activity、Service和Receiver`之间通过Intent来传递Bundle数据(调用`intent.putExtra()`)，由于Bundle实现了Parcelable接口，所以可以方便的在不同进程间传递(`传输的数据必须可以被序列化，不然无法进行传递`)。可以看做为一个特殊的Map类型。 > > **最简单的进程间通信方式。** 拓展：当A进程计算后的结果无法通过Bundle传递至B进程时，可以将计算的过程用B进程的一个Service进行操作，然后在回调给B进程。 #### 2.文件共享 > **两个进程间通过读/写一个文件来进行数据传递**，适用于对数据同步要求不高的进程间通信，并且需要对**并发读/写**进行妥善处理 拓展：Android中的SharedPreferences也是文件共享方案的一种，但由于系统提供了一种缓存策略(内存中会有一份该文件的缓存)，导致它在多进程模式下，读/写并不可靠，甚至丢失数据。 #### 3.Messenger > 轻量级的IPC方案，可以在不同的进程间传递Message对象。调用`Messenger.send(Message message)`传递Message对象。 > > Messager的底层实现是`AIDL`。它对AIDL做了封装，由于它一次只可以处理一个请求**（串行请求）**，因此不需考虑线程同步的问题。不过不能直接调用服务端的方法，只能通过传递消息处理。 > > 由于主要传递的都是Message对象，导致无法实现远程调用。 Messenger的构造函数分以下两种： ```java public Messenger(IBinder target){ mTarget = IMessenger.Stub.asInterface(target); } public Messenger(Handler target){ mTarget = target.getImessenger(); } ``` > > 拓展：**Handler主要用于线程间通信，Messenger用于进程间通信** 实现一个Messenger需要以下两步： - **服务端进程**： ①创建一个Service来处理客户端的连接请求 ②创建一个Handler并由他构造一个Messenger对象 ③然后在Service的onBind方法中返回该Messenger对象中的Binder。 代码示例： ```java //MessengerServcice.java public class MessengerService extends Service { private static class MessengerHanler extends Handler { @Override public void handleMessage(Message msg) { //处理返回的Message消息 ... //获取Client返回的Messenger对象 Messenger client = msg.replyTo; if (client != null) { //拼接数据 发送消息 } } } //通过Handler构造一个Messenger对象 private final Messenger mMessenger = new Messenger(new MessengerHanler()); @Override public IBinder onBind(Intent intent) { //返回IBinder对象 将消息交由对应Handler处理 return mMessenger.getBinder(); } } ``` - **客户端进程**： ①绑定服务端Service --`bindService` ②绑定后使用Service返回的IBinder对象创建一个Messenger对象 ③通过Messenger对象向服务端发送Message **完成单向通信** ④创建一个Handler由此创建一个Messenger对象，然后将Messenger对象放入Message的**replyTo**字段传递给Server。 **完成双向通信** 代码示例： ```java public class MessengerActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger); Intent intent = new Intent(this, MessengerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); } private Messenger mService; private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { mService = new Messenger(service); Message msg = Message.obtain(null, 1); Bundle data = new Bundle(); data.putString("msg", "it is from client"); msg.setData(data); //若存在则形成了双向通信 msg.replyTo = mGetReplyMessenger; try { mService.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { } }; private Messenger mGetReplyMessenger = new Messenger(new MessengerHanler()); private static class MessengerHanler extends Handler { @Override public void handleMessage(Message msg) { //处理消息 } } @Override protected void onDestroy() { //取消绑定service unbindService(mConnection); super.onDestroy(); } } ``` Messenger的工作原理： {% fullimage /images/Messenger-principle.png,Messenger工作原理,Messenger工作原理 %} #### 4.AIDL [AIDL相关](#3-AIDL相关) ### 5.ContentProvider > ContentProvider是专门用于不同应用间进行数据共享的方式，底层同样是由Binder实现。**主要是提供了一个统一的接口为了存储和获取数据。** [ContentProvide](https://www.jianshu.com/p/9048b47bb267) ### 6.Socket > Socket也称为"套接字"，是网络通信中的概念，分为流式套接字(`基于TCP协议，采用流的方式提供可靠的字节流服务`)和用户数据报套接字（`基于UDP协议，采用数据报文提供数据打包发送的服务`）两种。**Socket不仅可以跨进程通信还可以跨设备通信。** `TCP协议是面向连接的协议，提供稳定的双向通信功能，因为连接的建立需要经过'三次握手'才能完成，由于本身提供了超时重传机制，因此具有很高的稳定性。` `UDP是无连接的，提供不稳定的单向通信功能，在性能上拥有良好的效率，但数据不一定能够有效传输。` 1. 实现方法： 服务端： - 创建一个Service，在线程中建立TCP服务，监听相应的端口等待客户端连接请求 - 与客户端连接时，会生成新的Socket对象，利用它可与客户端进行数据传输 - 断开连接时，关闭相应的socket并结束线程 客户端： - 开启一个线程，通过Socket发起连接请求 - 连接成功后，读取服务端消息 - 断开连接，关闭Socket 2. 注意事项： - 需要声明网络权限 以上6种IPC方式比较： | 名称 | 优点 | 缺点 | 适用场景 | | --------------- | ------------------------------------------------------------ | --------------------------------------------------- | ---------------------------------------------------------- | | Bundle | 简单易用 | 只能传输Bundle支持的数据类型 | 四大组件的进程间通信 | | 文件共享 | 简单易用 | 不适合高并发场景，且无法做到实时通信 | 无并发访问情形，数据简单且实时性不高 | | AIDL | 功能强大，支持一对多并发通信，支持实时通信 | 使用稍复杂，需要处理好线程同步 | 一对多通信且支持远程调用 | | Messenger | 功能强大，支持一对多串行通信，支持实时通信 | 不能很好处理高并发场景，数据只能通过Message进行传输 | 低并发的一对多即时通信，并且不需要返回结果，不需要远程调用 | | ContentProvider | 在数据访问方面功能强大，支持一对多数据共享，可通过Call方法扩展其他操作 | 受约束的AIDL实现，主要提供对数据的CRUD操作 | 一对多的进程间数据共享 | | Socket | 功能强大，可以通过网络传输字节流，支持一对多并发通信 | 实现细节稍微麻烦 | 网络数据交换 | ## 2.Binder机制 > 在Linux中，为了避免一个进程对其他进程的干扰，进程之间是相互独立的。 > > Android的进程间通信采用了Binder出于两个方面的考虑：性能和安全。 > > 性能：在移动设备上对性能的要求是比较严苛的，在Linux上通信方式例如管道，Socket都需要复制两次数据，Binder只需一次。 > > `对于消息队列、Socket和管道而言，数据先从发送方的缓存区拷贝到内核开辟的缓存区中，再从内核缓存区拷贝至接收方缓存区，需要两次拷贝过程；Binder是从发送方缓存区到内核的缓存区，而接受方的缓存区与内核缓存区映射在同一块物理地址上，节省了一次数据拷贝的过程。` > > 安全：传统的Linux通信是不包含通信双方的身份验证的，Binder自带身份验证，提高了安全性。 > > `Android提供了UID机制，可以有效的鉴别用户身份。` 概念： - 直观来说，Binder是Android中的一个类，实现了IBinder接口。 - IPC角度来说，Binder是Android中的一种跨进程通信方式。 - Android Framework角度来说，Binder是ServiceManager连接各种Manager和相应ManagerService的桥梁。 - 应用层来说，Binder是客户端和服务端进行通信的媒介。 ### **1.Binder框架** Binder通信采用了**C/S架构**。在Android系统的Binder机制中，由一系列系统组件组成，分别是 - `Client` 客户端进程 - `Server` 服务端进程 - `Service Manager` 管理系统中的各种服务 提供注册、查询和返回代理服务对象的功能 - `Binder 驱动` 负责建立进程见得Binder连接，进程间的数据交互等底层操作 {% fullimage /images/IPC-Binder.jpg, Binder架构图, Binder架构图 %} Client,Server,Service Manager处于用户空间，Binder驱动位于内核空间。 下面介绍四个组成部分的作用： - **Service Manager：**服务的管理者，指代的是Native层的ServiceManager(C++)，是整个Binder通信机智的大管家，是Android进程间通信机制的守护进程。将Binder的名字转换为Client中对该Binder的引用，使得Client可以通过Binder名字来获取Service中的引用。{% post_link Binder系列-ServiceManager相关 %} - **Binder驱动：**主要是驱动设备的**初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)**。 和硬件设备没有任何关系。它工作于内核态，以misc设备注册在设备目录/dev下，用户可以通过/dev/binder访问它。负责进程之间binder通信的建立、传递、计数管理和数据的传递交互等底层支持。主要功能由`ioctl()/*主要负责在两个进程间收发IPC和IPC reply数据，常用命令为BINDER_WRITE_READ*/`实现。 - **Client&Service：**在Binder驱动和Service Manager提供的基础设施上进行C-S之间的通信。`Server进程启动时，将在本进程内运行的Service注册到Service Manager中，并且启动一个Binder线程池，用来接收Clien请求。然后Client进程向Service Manager查询所需要的Service，并获得一个Binder代理对象，通过该代理对象向Service发出请求。` 四大组件彼此之间不是直接交互的，都是通过Binder驱动进行交互，从而实现IPC通信方式。**系统需要启动了Service Manager之后，Client端和Server端需要现获取了Service Manager接口后，才可以开始通信服务。** ### 2.**Binder工作机制** {% fullimage /images/Binder-workflow.png, Binder工作机制, Binder工作机制 %} - 在Server端创建好一个Binder对象后，内部就会开启一个线程用于接收Binder驱动发送的消息，收到消息后就会执行`onTransact()`,然后按照参数执行不同的服务端代码。 - 在服务端成功Binder对象后，Binder驱动会创建一个`mRemote`对象，客户端可以借助它调用`transcat()`向服务端发送消息 - 客户端要访问Binder的远程服务，就要获取远程服务的Binder对象在Binder驱动中的`mRemote`引用，获取到引用后既可以调用相关方法。 [Binder相关](http://gityuan.com/2015/10/31/binder-prepare/) ### 3.Binder连接池 >首先回顾一下AIDL的使用方式：①创建一个Service和AIDL接口②创建一个类继承自AIDL接口中的Stub类并实现Stub中的抽象方法③在Service的onBind中返回这个类的对象④客户端绑定Service后就可以直接访问服务端的方法。 > >当业务需求越来越多时，上述的创建方式就会产生很多Service类，导致系统资源耗费颜值、应用过度重量级的问题。所以产生了`Binder连接池`的概念。 > 主要作用为 **将每个业务模块的Binder请求统一转发到远程Service上去执行，从而避免重复创建Service**。 工作原理： {% fullimage /images/BinderPool.png,BinderPool工作原理, BinderPool工作原理%} 每个业务模块创建自己的AIDL接口并实现，然后向服务端传递自己的**唯一标识(BinderCode)及对应的Binder对象**。服务端只要一个Service，然后实现`queryBinder()`接口，根据唯一标识返回对应的Binder对象。 实现方式： - 创建对应的AIDL文件并有具体实现 - 创建BinderPool.java以及IBinderPool.aidl文件 - 实现远程服务BinderPoolService，并在onBind()中返回实例化的BinderPool对象 - 实现BinderPool方法，并在`queryBinder()`中做好对应处理 - 客户端调用BinderPoolService ## 3.AIDL相关 > 在Messenger中讲到它是基于AIDL的，但是只能处理串行的消息，如果有大量的消息同时发送进来，也只能一个个处理，而且不支持跨进程调用服务端的方法，就需要用到AIDL来处理上述情况。 > > **AIDL本质上就是系统为我们提供了一种快速实现Binder的工具，我们可以不依赖于AIDL，自己去完全实现一个Binder。** ### 1.AIDL支持的数据类型 - 基本数据类型：`byte、int、long、float、double、boolean，char` - String 和 CharSequence - ArrayList，HashMap(**包括key，每个元素必须可以被AIDL支持**) - 实现了Parcelabe接口的对象 **必须要显示Import进来** - 所有AIDL接口本身也会被调用**必须要显示Import进来** ### 2.定向tag > 除了基本数据类型，其他类型的参数必须加上方向 **in,out,inout**，用于表示在跨进程通信中的数据流向。 - `in`：表示数据只能由客户端流向服务端。服务端会收到这个对象的完整数据，**但在服务端对对象进行修改不会对客户端传递进来的对象造成影响。** - `out`：表示数据只能由服务端传递到客户端。服务端会接受到这个对象的空对象，**但在服务端接收到的空对象有任何修改之后客户端会同步发生变化。** - `inout`：表示数据可以在服务端和客户端之间双向流通。服务端会收到这个对象的完整数据，**且客户端会同步服务端对该对象的任何改动。** ### 3.关键类和方法 > 添加完AIDL文件之后，会自动生成对应的Java文件，这个是关键所在。 `DESCRIPTOR`：Binder的唯一标识，一般用当前Binder的类名表示。 ```java private static final java.lang.String DESCRIPTOR = "com.example.wxy.ipc.IBookManager"; ``` `asInterface(android.os.IBinder obj)`：用于将服务端的Binder对象转换成客户端需要的AIDL接口类型的对象，不过是要区分进程的。 ```java public static com.example.wxy.ipc.IBookManager asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); //位于同一进程则返回服务端Stub对象本身 if (((iin != null) && (iin instanceof com.example.wxy.ipc.IBookManager))) { return ((com.example.wxy.ipc.IBookManager) iin); } //否则返回封装后的Stub.proxy对象 return new com.example.wxy.ipc.IBookManager.Stub.Proxy(obj); } ``` `asBinder()`：返回当前Binder对象 `Proxy`：这个类运行在客户端，客户端调用这个类来调用服务端的代码(涉及到了**代理模式**) ```java private static class Proxy implements com.example.wxy.ipc.IBookManager { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } ... @Override public com.example.wxy.ipc.Book addBookInout(com.example.wxy.ipc.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.example.wxy.ipc.Book _result; try { _data.writeInterfaceToken(DESCRIPTOR); //在定向tag为out时 没有这个if //判断传入参数是否为空 ，为空则不写入，不为空则写入_data流 if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_addBookInout, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) { _result = com.example.wxy.ipc.Book.CREATOR.createFromParcel(_reply); } else { _result = null; } //在定向tag 为in时 没有这个if if ((0 != _reply.readInt())) { book.readFromParcel(_reply); } } finally { _reply.recycle(); _data.recycle(); } return _result; } } ``` 分析上述生成的代码： - `_data _reply`：`_data`存储传参的数据，`_reply`存储方法的返回值数据 - `transcat(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags)`：客户端和服务端通信的核心方法。调用后会挂起当前线程，等候服务端执行任务完成通知并接受返回的`_reply`数据。 - `code`：分配的方法ID是自动生成的 工作流程为： 1. 生成`_data` 和` _reply`数据，在`_data`中存入客户端数据 2. 调用`transcat()`传递数据至服务端，并调用服务端中`onTranscat()`的指定方法 3. 接收`_reply`数据，取出服务端返回的数据使用 `onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)`：运行在服务器端的Binder线程池中，客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法处理。参数介绍： - `code`：可以确定客户端所请求的方法是哪个 - `data`：取出目标方法所需参数 - `reply`：里面填写请求的返回值 - `flags`：设置进行IPC的模式，0双向流通 1单向流通 **AIDL生成的.java文件均设置0 ```java @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { ... case TRANSACTION_addBookInout: { data.enforceInterface(descriptor); com.example.wxy.ipc.Book _arg0; //定向tag为in时有这段if 从_data中读取book对象并赋值 if ((0 != data.readInt())) { _arg0 = com.example.wxy.ipc.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } com.example.wxy.ipc.Book _result = this.addBookInout(_arg0); reply.writeNoException(); if ((_result != null)) { reply.writeInt(1); _result.writeToParcel(reply,android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } //定向tag为out时有这段if 若服务端对传参进行过修改 都会同步到_reply中 if ((_arg0 != null)) { reply.writeInt(1); _arg0.writeToParcel(reply,android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } return true; } } ``` 分析上述生成的代码： 处理完由客户端调用的`transcat()`传递进来的`_data`，再将处理完的数据写入到`_reply`中。 工作流程为： 1. 获取由`transcat()`传入的数据，根据对应的`code`执行相应方法 2. 执行方法后，解析对应传递过来的数据`_data` 3. 将需要回传的数据写入`_reply`中，传回给客户端 整套AIDL实现的流程如下： {% fullimage /images/AIDL-IPC.png,AIDL实现IPC流程,AIDL实现IPC流程 %} 拓展： 1. 可能会产生ANR 由于客户端在调用远程服务方法时，客户端线程会被挂起，如果服务端的方法执行比较耗时，就会导致客户端ANR，或者在`onServiceConnected`和`onServiceDisconnected`中调用了服务端的耗时方法也会导致ANR。 当服务端调用客户端的listener方法时，该方法会运行在客户端的`binder线程池中`，若调用了耗时方法，也会导致ANR。 2. AIDL解注册失败 > 服务端无法找到注册时使用的listener而导致解注册失败。**因为Binder客户端会把传递过来的对象重新转化并生成一个新的对象，而且对象是不能跨进程传输的，对象跨进程传输的本质就是序列化和反序列化的过程。** 这时需要用到`RemoteCallBackList`，是系统专门提供用于删除跨进程的listener的接口，而且内部实现了线程同步的功能**(内部使用了`synchronized`)**。使用注意事项:**`beginBroadcast`和`finishBroadcast`必须要配对使用。** 3. 性能损耗较大 > 客户端频繁调用服务端方法，就需要实现一个**观察者模式**，当客户端的数据发生变化时再去通知服务端操作，减少频繁查询。 ### 4.权限验证 > 默认情况下，远程服务所有人都可以进行连接并调用，所以应该需要加入权限验证系统来保证安全。 - 在`onBind`中进行验证，不通过直接返回null，导致客户端无法绑定。 ```xml //在AndroidManifest.xml中定义该权限 //如果注册了该权限，则可以绑定成功 否则失败 ``` - 在配置Service时 设置`` ```xml ```]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android需要的必备知识]]></title>
    <url>%2F2018%2F12%2F09%2FAndroid%E9%9C%80%E8%A6%81%E7%9A%84%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[--- title: Android需要的必备知识 date: 2018-12-09 14:05:46 tags: Android top: 10 --- # 1.Binder原理、AIDL的使用、多进程的定义和特性 # 2.View的measure、layout和draw，View的工作原理 # 3.事件分发原理和规则 # 4.Handler、Looper、Thread三者之间的关系； # 5.Activity # 6.Service]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal原理分析]]></title>
    <url>%2F2018%2F12%2F09%2FThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: ThreadLocal原理分析 date: 2018-12-09 14:04:59 tags: 源码分析 top: 10 --- # ThreadLocal详解 > 在前几节Handler详解中介绍 如何获取Looper对象时提及了是利用ThreadLocal来进行Looper的存储与获取。 ## 1.初步理解ThreadLocal ThreadLocal的定义为：**用于提供线程变量，在多线程环境中可以保证各个线程的变量独立于其他线程里的变量。**主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量不会互相干扰，适用于`高并发状态下实现无状态的调用即各个线程依赖不同的变量完成操作`。 > ThreadLocal保证的是多线程环境下的独立性，同步机制则保证多线程下数据的一致性。 ## 2.使用样例 ```java public class ThreadLocalTest { private static String label; private static ThreadLocal threadLocal = new ThreadLocal(); public static void main(String[] args) { label = "main"; threadLocal.set("main"); //new Thread Thread thread = new Thread() { @Override public void run() { super.run(); label = "new"; threadLocal.set("new"); } }; thread.start(); try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.err.println("label = " + label); System.err.println("threadLocal = " + threadLocal.get()); } } //console.log label = new threadLocal = main ``` 对于ThreadLocal中的变量，在一个线程中修改它的值，并不会影响到在其他线程中的值。**ThreadLocal中的值在每个线程中都是独立的。** ## 3.深入理解ThreadLocal ThreadLocal类中提供了以下几个方法来进行变量的操作： - `public T get()`获取ThreadLocal在当前线程中保存的变量副本 - `public void set(T value)`设置当前线程中的变量副本 - `public void remove()`移除当前线程中的变量副本 - `protected T initialValue()`设置ThreadLocal的初始值，该方法为延迟加载 接下来具体查看上述方法的内部实现。加深理解 ### `get()` ```java //返回当前线程中存储的变量副本 public T get() { //获取当前线程 Thread t = Thread.currentThread(); //获取到持有变量副本的map ThreadLocalMap map = getMap(t); //map存在则返回存储值 if (map != null) { //该map key为ThreadLocal 故获取value用的是this ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings("unchecked") T result = (T)e.value; return result; } } //不存在则返回默认值 return setInitialValue(); } ``` ### `set(T value)` ```java //设置当前线程的变量副本 public void set(T value){ Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //map不为null 则保存value if(map!=null){ map.set(this,value); } //否则创建一个ThreadLocalMap后保存value else{ createMap(t,value); } } ``` ### `remove()` ```java //移除保存的变量副本 public void remove(){ ThreadLocalMap map = getMap(Thread.currentThread); //map不为空 则移除当前ThreadLocal对应的变量副本 if(map!=null) map.remove(this); } ``` ### `initialValue()` ```java //子类可重写该方法 进行默认值的设置 protected T initialValue() { return null; } 对应有setInitialValue() private T setInitialValue(){ T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if(map!=null){ map.set(this,value); }else{ createMap(t,value); } return value; } ``` 在上述四个方法中都会涉及到一个类**`ThreadLocalMap`**，该类是ThreadLocal的核心机制实现。`在使用ThreadLocal的方法对存储变量进行操作时都需要获得当前线程对应的ThreadLocalMap来对变量进行操作`。**每个线程都会有专属的ThreadLocalMap，其中维护的value也是对应当前线程的。就保证了ThreadLocal中存储的变量都是相互独立的，不会受到多线程环境的影响。** **`ThreadLocalMap`** > 该类为ThreadLocal中的内部类，没有实现Map接口，内部自己实现了Map的功能。 1. 构造方法 ```java ThreadLocalMap(ThreadLocal firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); } ``` 2. 初始对象 ```java // 初始容量，必须是 2 的幂 private static final int INITIAL_CAPACITY = 16; // 存储数据的哈希表 private Entry[] table; // table 中已存储的条目数 private int size = 0; // 表示一个阈值，当 table 中存储的对象达到该值时就会扩容 private int threshold; // 设置 threshold 的值 private void setThreshold(int len) { threshold = len * 2 / 3; } ``` 由内部实现了一套Map机制 3. Entry > table中存储的都为Entry对象，用于保存K-V数据结构 ```java static class Entry extends WeakReference { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) { super(k); value = v; } } ``` Entry继承自`WeakRefrence`为弱引用类型并且限制了`K`只能为ThreadLocal对象，但是对应的`V`为强引用类型，则可能导致**内存泄漏**。 4. 保存key-value ```java //调用set方法将 key-value类型进行存储 private void set(ThreadLocal key, Object value) { // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; //计算要存储的索引位置 int i = key.threadLocalHashCode & (len-1); //判断要存储的索引位置是否已经存在Entry 存在则继续向下 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal k = e.get(); //key相同则更新 if (k == key) { e.value = value; return; } //key为空 代表该位置对应的Entry已失效，需要直接进行替换 if (k == null) { replaceStaleEntry(key, value, i); return; } } //若不存在 则将Entry保存到该位置 tab[i] = new Entry(key, value); int sz = ++size; //超过当前负载 则需进行扩容机制 重新调整table if (!cleanSomeSlots(i, sz) && sz >= threshold) rehash(); } ``` 使用当前的ThreadLocal中对应的threadLocalHashCode来计算该键值对要存储的索引位置。该值是由ThreadLocal对象自动生成的，创建时就会进行赋值。 ```java private final int threadLocalHashCode = nextHashCode(); /** * The next hash code to be given out. Updated atomically. Starts at * zero. * 使用AtomicInteger用来保证多线程环境下不会受到影响 */ private static AtomicInteger nextHashCode = new AtomicInteger(); /** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */ private static final int HASH_INCREMENT = 0x61c88647; /** * Returns the next hash code. */ private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } ``` 当table中的条目超出阈值时就需要进行扩容 ```java //扩容是 新table的容量为原先的两倍 触发条件为table中的条目数超出了阈值的3/4 private void resize(){ Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for(int j = 0;j]]></content>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler机制源码解析(二)]]></title>
    <url>%2F2018%2F10%2F07%2FHandler%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[--- title: Handler机制源码解析(二) date: 2018-10-07 11:08:24 tags: 源码解析 top : 10 --- # 主要包括Handler其他使用知识点 ## 1. 子线程创建Handler对象 > 不可以直接在子线程创建Handler对象，因为Handler对象必须要绑定一个Looper，才可以使用。 > > 若在子线程需要使用Handler，则需要先创建一个Looper对象即执行`Looper.prepare()`然后再创建Handler对象时调用`Looper.myLooper()`获取Looper对象传入方法，最后调用`Looper.loop()`开始运行。 ```kotlin class MyActivity : Activity{ lateinit var mThread: MyThread lateinit var mHandler: MyHandler override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.act_main) //初始化子线程 mThread = Mythread() mThread.start() //需要发出的消息 val message = Message.obtain() message.obj = "test" //初始化Handler mHandler = MyHandler(this, mThread.childLooper) //发送消息 mHandler.sendMessage(message) } //子线程 class MyThread : Thread() { var childLooper: Looper? = null override fun run() { Looper.prepare() childLooper = Looper.myLooper() Looper.loop() } } //安全的Handler写法 class MyHandler(activity: MyActivity, looper: Looper?) : Handler(looper) { var mWeakRe: WeakReference = WeakReference(activity) override fun handleMessage(msg: Message?) { super.handleMessage(msg) val activity: MyActivity? = mWeakRe.get() if (activity!=null){ //添加handlerMessage需要处理的逻辑 } } } } ``` 以上代码执行完毕后就可以在子线程调用Handler对象。 **但是，在多次执行过程中，会有java.lang.NullPointerException: Attempt to read from field 'android.os.MessageQueue android.os.Looper.mQueue' on a null object reference空指针导致应用崩溃。**调试过程中发现是由于Looper对象为空导致的异常。由于**在子线程`run()`初始化了Looper对象，Handler对象的初始化依然继续执行，Looper对象此时尚未初始化好，导致空指针异常。** 由于这种情况的出现是随机的，不是百分百重现，为了保证应用的运行就需要引入`HandlerThread`这个类，可以帮我们解决这个问题。 ```kotlin //HandlerThread示例代码 class MyActivity : Activity{ lateinit var mHandler: MyHandler var mHandlerThread: HandlerThread?=null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.act_main) //初始化HandlerThread并指定线程名字为test mHandlerThread = HandlerThread("test",Process.THREAD_PRIORITY_BACKGROUND) mHandlerThread?.start() //需要发出的消息 val message = Message.obtain() message.obj = "test" //初始化Handler mHandler = MyHandler(this, mHandlerThread?.looper) //发送消息 mHandler.sendMessage(message) } //安全的Handler写法 class MyHandler(activity: MyActivity, looper: Looper?) : Handler(looper) { var mWeakRe: WeakReference = WeakReference(activity) override fun handleMessage(msg: Message?) { super.handleMessage(msg) val activity: MyActivity? = mWeakRe.get() if (activity!=null){ //添加handlerMessage需要处理的逻辑 } } } override fun onDestroy() { super.onDestroy() //结束时停止thread mHandlerThread?.quit() } } ``` 以上代码执行完毕后即在HandlerThread可以调用Handler对象。 我们需要从源码去分析为什么使用`HandlerThread`可以避免上述异常，是怎样一个机制实现的。 ```java // 源码位置:../core/java/android/os/HandlerThread.java public class HandlerThread extends Thread { ... //设置线程优先级 优先级主要分为UI线程和后台线程(Background) int mPriority; public HandlerThread(String name) { super(name); //默认标准App线程优先级 mPriority = Process.THREAD_PRIORITY_DEFAULT; } public HandlerThread(String name, int priority) { super(name); mPriority = priority; } //可以重写这个方法，在内部新建Handler对象 protected void onLooperPrepared() { } @Override public void run() { //获取到线程ID mTid = Process.myTid(); //创建对应的Looper，MessageQueue对象 Looper.prepare(); synchronized (this) { //对mLooper进行赋值 mLooper = Looper.myLooper(); //唤醒等待Looper赋值而阻塞的所有线程 notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } public Looper getLooper() { //判断当前线程是否存活 关闭则返回空 if (!isAlive()) { return null; } // If the thread has been started, wait until the looper has been created. synchronized (this) { //mLooper==null表明当前Looper对象尚未初始化 while (isAlive() && mLooper == null) { try { //调用线程等待 直至初始化完成 阻塞其他线程 wait(); } catch (InterruptedException e) { } } } //返回Looper对象 return mLooper; } //内嵌一个可以直接引用的Handler对象，外部可以直接使用 @NonNull public Handler getThreadHandler() { if (mHandler == null) { mHandler = new Handler(getLooper()); } return mHandler; } //HandlerThread退出 同步于Looper.quit() public boolean quit() { Looper looper = getLooper(); if (looper != null) { looper.quit(); return true; } return false; } //HandlerThread退出 同步于Looper.quitSafely() public boolean quitSafely() { Looper looper = getLooper(); if (looper != null) { looper.quitSafely(); return true; } return false; } } ``` 总结： - `HandlerThread`内嵌了Handler,Looper,MessageQueue对象 - `HandlerThread`内部使用`wait(),notifyAll()`等线程同步方式保证`mLooper`对象不会为空，`wait()`当Looper对象尚未初始化完成时阻塞其他线程，`notifyAll()`当mLooper对象不为空时，通知其他线程使用mLooper。 ## 2. IdleHandler > 当Looper里面的Message暂时处理完毕即**全部消息处理完毕或者阻塞等待新消息**时会调用`IdleHandler`这个类去处理一些空闲时间的消息。 > > 继承`IdleHandler`这个接口，需要设置`queueIdle()`的返回值。若返回`false`则调用一次后会移除，为`true`则继续持有，空闲时依然会调用。 > > 概括就是：**优先级别较低的`Message`，只有当`Looper`中没有消息要处理时，才会去处理`IdleHandler`。** ```kotlin //使用示例代码 val message = Message.obtain() message.obj = "1234" handler.sendMessage(message) val delayMessage=Message.obtain() delayMessage.obj="12344" handler.sendMessageDelayed(delayMessage,3000) //子线程添加IdleHandler 限制API23以上使用 mHandlerThread?.looper?.queue?.addIdleHandler(OnceIdleHandler()) mHandlerThread?.looper?.queue?.addIdleHandler(ForeverIdleHandler()) //主线程添加IdleHandler Looper.myQueue().addIdleHandler(OnceIdleHandler()) Looper.myQueue().addIdleHandler(ForeverIdleHandler()) //只使用一次的IdleHandler class OnceIdleHandler : MessageQueue.IdleHandler { override fun queueIdle(): Boolean { LogUtils.e("idle once") return false } } //一直持续存在的IdleHandler class ForeverIdleHandler : MessageQueue.IdleHandler { override fun queueIdle(): Boolean { LogUtils.e("idle forever") return true } } //需要移除IdleHandler 调用 Looper.myQueue().removeIdleHandler(OnceIdleHandler()) Looper.myQueue().removeIdleHandler(ForeverIdleHandler()) ``` 集成上述代码即可测试IdleHandler的使用，接下来要分析源码的实现以及使用场景。 ```java // 源码位置:../core/java/android/os/MessageQueue.java /** * IdleHandler定义 * Callback interface for discovering when a thread is going to block * waiting for more messages. */ public static interface IdleHandler { /** * Called when the message queue has run out of messages and will now * wait for more. Return true to keep your idle handler active, false * to have it removed. This may be called if there are still messages * pending in the queue, but they are all scheduled to be dispatched * after the current time. */ boolean queueIdle(); } //mIdleHandlers 是ArrayList型 故可以重复添加 private final ArrayList mIdleHandlers = new ArrayList(); //往MessageQueue中添加一个IdleHandler对象 public void addIdleHandler(@NonNull IdleHandler handler) { if (handler == null) { throw new NullPointerException("Can't add a null IdleHandler"); } synchronized (this) { //添加IdleHandler是线程安全的 mIdleHandlers.add(handler); } } //移除一个IdleHandler public void removeIdleHandler(@NonNull IdleHandler handler) { synchronized (this) { mIdleHandlers.remove(handler); } } //调用上述方法往mIdleHandlers添加或移除IdleHandler对象后 需要在next()方法中 去使用mIdleHandlers中的对象 Message next() { //无限循环 for(;;){ ... // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount < 0 && (mMessages == null || now < mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount **进程**：每个app运行时首先会创建一个进程，该进程是由zygote fork出来的，用于承载运行app上的Activity/Service等组件。进程对于上层应用来说是完全透明的，目的是为了`让App都运行在Android Runtimr`。大多数情况下一个App运行在一个线程中，除非配置了`Android:Process`属性，或者通过native fork 进程。 > > **线程**：线程比较常见，每次`new Thread().start()`都会创建一个新线程。并且与当前App所在进程之间资源共享。`在CPU看来进程或线程无非是一段可执行的代码，CPU采用CFS调度算法，保证每个task尽可能公平享有CPU时间片`。 > > 拓展知识：CFS调度算法是一种完全公平调度算法，基本设计思路是根据各个进程的权重来分配运行时间**。 当进入死循环时又该如何处理其他事务呢？**需要创建新的线程去处理**。 主线程进入Looper的死循环后，需要处理 activity的各个生命周期的回调函数执行(`在同一个线程下，代码是按顺序执行的，如果死循环堵塞了，后续该如何执行`)。 ```java //源码地址 android/app/ActivityThread.java public static void main(String[] args){ ... //Looper初始化 Looper.prepareMainLooper(); //new 一个ActivityThread并调用了attach方法 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); } ``` 源码中在初始化ActivityThread时也会初始化一个`H类型的成员，它继承了Handler`。 源码中调用`thread.attach(false)`时,**回去创建一个Binder进程（具体代指ApplicationThread,Binder的服务端，用于接收系统AMS发出来的事件），由Handler线程发送Message至主线程。** 所以在主线程开启Looper死循环之前，就已经启动了一个Binder线程并且准备了`H 这一个Handler类`，就可以用于处理一些死循环之外的事务。`仅需通过Binder线程向H发送消息即可`。 {% fullimage /images/activity_binder.png, App运行过程, App运行过程 %} **system_server进程即为系统进程**，里面运行了大量的系统服务，比如上图提供了`ApplicationThreadProxy以及ActivityManagerService`，这两者都基于IBinder接口，都是Binder线程。 **App进程即为我们常说的应用程序**，主线程主要负责Activity等组件的生命周期以及UI绘制。每个App进程中至少会包括两个binder线程:`ApplicationThread和ActivityManagerProxy`。 **Binder用于不同进程间的通信，由一个进程的Binder客户端向另一个进程的服务端发送事务。** **Handler则用于同一进程间不同线程的通信。** ### 3.主线程的消息模型 上图中绘制出主线程(ActivityThread)是如何循环的,简单的文字表达就是 > `ActivityManagerService(AMS)` ==直接调用==>`ApplicationThreadProxy(ATP)`==Binder==>`ApplicationThread`==Handler方式==>`ActivityThread` > > 主线程(ActivityThread)通过`ApplicationThread`和`ActivityManagerService`进行进程间通信，AMS以进程间通信的方式完成`ActivityThread`的请求后回调`ApplicationThread`中的Binder方法。然后由`ApplicationThread`向`ActivityThread`中的`H`发送消息，然后收到消息后 把处理逻辑发送至`ActivityThread`中去执行。]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-AsyncTask]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-AsyncTask%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-AsyncTask date: 2018-08-26 13:34:11 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-Handler工作原理]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-Handler%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-Handler工作原理 date: 2018-08-26 13:33:55 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-RemoteViews]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-RemoteViews%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-RemoteViews date: 2018-08-26 13:33:29 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-RecyclerView以及ConstrainLayout]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-RecyclerView%E4%BB%A5%E5%8F%8AConstrainLayout%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-RecyclerView以及ConstrainLayout date: 2018-08-26 13:33:14 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-ThreadLocal]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-ThreadLocal%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-ThreadLocal date: 2018-08-26 13:32:41 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-动态权限]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-动态权限 date: 2018-08-26 13:32:25 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-设计模式基本原则]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-Study-Plan-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-设计模式基本原则 date: 2018-08-26 13:31:38 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XX]]></title>
    <url>%2F2018%2F06%2F25%2FAndroid-Study-Plan-XX%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XX date: 2018-06-25 14:13:36 tags: Android --- # Android学习计划 ## 大尺寸图片加载问题：给定一个1000px*2000px的大图，如何进行正常加载且不会导致OOM。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XIX]]></title>
    <url>%2F2018%2F06%2F12%2FAndroid-Study-Plan-XIX%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XIX date: 2018-06-12 12:44:28 tags: Android --- # Android学习计划 ## AndroidStudio点击Build按钮后，AndroidStudio就会编译项目并安装到手机中，那么详细分析整个过程的细节。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树]]></title>
    <url>%2F2018%2F06%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[--- title: 数据结构-树 date: 2018-06-03 10:51:04 tags: ---]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础]]></title>
    <url>%2F2018%2F05%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[--- title: 计算机网络基础 date: 2018-05-31 12:52:59 tags: 计算机网络 ---]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XVIII -- 基础网络原理]]></title>
    <url>%2F2018%2F05%2F31%2FAndroid-Study-Plan-XVIII%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XVIII -- 基础网络原理 date: 2018-05-31 12:35:24 tags: Android --- # Android学习计划 ## 网络的5层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手以及四次挥手过程。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-线程池 ThreadPool 专题详解]]></title>
    <url>%2F2018%2F05%2F31%2FAndroid-Study-Plan-XVII%2F</url>
    <content type="text"><![CDATA[--- title: Android-线程池 ThreadPool 专题详解 date: 2018-05-31 12:35:18 tags: Android top: 10 --- ## 线程池的概念以及实现原理（设计原理）？为什么要使用线程池？Android中的线程池有哪些？它们的区别是什么？ ### 基础概念 - **线程**：进程中负责执行的执行单元，一个进程中至少有一个线程,**操作系统能够进行调度的最小单位** - **进程**：一个执行中的程序的实例 - **多线程**：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU确定，因此多线程具有不确定性 - **线程池**： 基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象回归池中，避免反复创建线程对象所带来的性能开销，节省系统资源。 ### 1. 线程池的概念 在执行一个异步任务或并发任务时，往往会通过`new Thread()`方法去开启一个子线程去执行任务，等到子线程操作完成后在利用`Handler`切换至主线程。但是利用这种方法我们无法对自己创建的子线程进行有效的管理，然后由于过多的创建子进程，他们之间相互竞争会导致资源的过度占用。线程池的出现就是为了来对子进程进行管理。 ### 2. 线程池的实现原理 `Executors`提供了基础的四类线程池方法，最终都是通过`ThreadPoolExecutor`类完成。对于这个类的描述`他维护了一个线程池，对于提交Executor中的任务，不是创建新的线程而是使用池内的线程来执行任务。可以显著减少对于任务执行的开销。` 1. ThreadPoolExecutor构造函数介绍 ```java public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ``` 参数介绍： - **`corePoolSize 核心线程数`** 表示线程池中的基本线程数量即核心线程数量。一般情况下核心线程会一直存活在线程池中，即便他们处于闲置状态。只有在`ThreadPoolExecutor的allowCoreThreadTimeOut设置为true`的时候，会有一个超时策略（超过设置好的超时时间，闲置的核心线程会被终止）。**当创建的线程数小于corepoolSize时，不管有没有空闲线程都会创建新的线程**。 - **`maximumPoolSize 最大线程数`** 表示线程池中允许的最大创建线程数，当活动的线程数达到数值后，后续新任务会被阻塞。**使用有界队列时，未达到该值则会创建新的线程，使用无界队列时该值无效。** - **`keepAliveTime 非核心线程闲置时的超时时长`** 表示空闲非核心线程的最大存活时间，一旦超过即被销毁。**当`ThreadPoolExecutor的allowCoreThreadTimeOut设置为true`的时候，该参数也可作用于核心线程 - **`unit 存活时间的时间单位`** 用于指定keepAliveTime参数的时间单位，为一个枚举类型。包含下列参数：`NANOSECONDS（纳秒）`,`MICROSECONDS（微秒）`,`MILLSECONDS（毫秒）`,`SECONDS（）秒`,`MINUTES（分）`,`HOURS（时）`,`DAYS（天）` - **`workQueue 线程池中的任务队列`** 该队列是`java.util.BlockingQueue`的一个实例，是一种阻塞队列用来存放等待执行的任务。通过`execute()`方法将提交的Runnable对象存储进去。根据具体实现类的不同可以分为以下三种队列策略： - `容量为0即直接提交策略--SynchronousQueue`：等待队列容量为0 ，所有需要阻塞的任务必须等待池内的某个线程有空闲才可以继续执行，否则阻塞。`CachedThreadPool`使用该队列策略。 - `容量无限即无界队列策略--LinkedBlockingQueue`：等待队列的长度无穷大，在这种策略下不会出现多余corePoolSize的线程被创建，所以maximumPoolSize以及handler无效，因为不存在队列满的情况。不过也有缺点：**线程的执行速度会比提交速度慢，会导致无界队列快速增长，直到系统资源耗尽。**`fixedThreadPool`采用了这种队列策略。 - `容量有限即有界队列策略--指定了容量的任何BlockingQueue`：等待队列的长度为限制长度，指定了容量后可以**防止过多的资源被消耗**。 - **`threadFactory 线程工厂`**：是一个接口可以为线程池提供新线程的创建。由同一个threadFactory创建的线程同属于一个ThreadGroup，优先级都为Thread.NORM_PRIORITY，以及为非进程守护状态。默认都是采用`Executors.defaultThreadFactory()`返回值。 - **`handler 拒绝策略`**：当**使用有界队列时且队列任务被填满后并且线程数也达到了最大值，就会触发拒绝策略**。如果任务被拒绝执行，则会调用`RejectedExecutionHandler.rejectedExecution()`方法，默认调用`AbortPolicy`拒绝策略，也可以由用户自定义。JDK中定义了4种拒绝策略： - `AbortPolicy`**处理程序遭到拒绝则直接抛出`RejectedExecutionException`异常然后丢弃该任务。** 实现源码： ```java public static class AbortPolicy implements RejectedExecutionHandler { /** * Creates an {@code AbortPolicy}. */ public AbortPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString()); } } ``` 样例演示： ```java static class TestRunnable implements Runnable { private int id; TestRunnable(int id) { this.id = id; } @Override public void run() { System.err.println(Thread.currentThread().getName()+" 当前线程id="+ this.id); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } public static void abortPolicyDemo() { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue(1), new ThreadPoolExecutor.AbortPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.shutdown(); } 运行结果：添加进程时直接抛出异常但是没有影响后续的进行 pool-1-thread-1 当前线程id=1 Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@4b1210ee rejected from java.util.concurrent.ThreadPoolExecutor@4d7e1886[Running, pool size = 1, active threads = 1, queued tasks = 1, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112) at threadpool.ThreadPoolDemo.abortPolicyDemo(ThreadPoolDemo.java:140) at threadpool.ThreadPoolDemo.main(ThreadPoolDemo.java:13) pool-1-thread-1 当前线程id=2 ``` - `CallerRunsPolicy`**在调用`execute`方法的调用者所在线程来执行被拒绝的任务，提供简单的反馈控制机制，可以减缓新任务的提交速度。** 实现源码： ```java public static class CallerRunsPolicy implements RejectedExecutionHandler { /** * Creates a {@code CallerRunsPolicy}. */ public CallerRunsPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { r.run(); } } } ``` 样例演示： ```java public static void callerRunsPolicyDemo(){ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue(1), new ThreadPoolExecutor.CallerRunsPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.shutdown(); } 运行结果：task2执行在了主线程，由于被拒绝执行所以在调用者线程执行了任务 pool-1-thread-1 当前线程id=1 main 当前线程id=3 pool-1-thread-1 当前线程id=2 ``` - `DiscardPolicy`**被拒绝即无法执行的任务被直接删除** 实现源码： ```java public static class DiscardPolicy implements RejectedExecutionHandler { /** * Creates a {@code DiscardPolicy}. */ public DiscardPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { } } ``` 样例演示： ```java public static void discardPolicyDemo(){ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue(1), new ThreadPoolExecutor.DiscardPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.shutdown(); } 运行结果：由于被拒绝执行在该策略下被直接抛弃 pool-1-thread-1 当前线程id=1 pool-1-thread-1 当前线程id=2 ``` - `DiscardOldestPolicy`**判断线程池是否被关闭，没有则丢弃最老的一个请求，再尝试提交当前任务。** 实现源码： ```java public static class DiscardOldestPolicy implements RejectedExecutionHandler { /** * Creates a {@code DiscardOldestPolicy} for the given executor. */ public DiscardOldestPolicy() { } public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { e.getQueue().poll(); e.execute(r); } } } ``` 样例演示： ```java public static void discardOldestPolicyDemo(){ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue(1), new ThreadPoolExecutor.DiscardOldestPolicy()); threadPoolExecutor.submit(new TestRunnable(1)); threadPoolExecutor.submit(new TestRunnable(2)); threadPoolExecutor.submit(new TestRunnable(3)); threadPoolExecutor.submit(new TestRunnable(4)); threadPoolExecutor.shutdown(); } 运行结果：??? pool-1-thread-1 当前线程id=1 pool-1-thread-1 当前线程id=4 ``` - `CustomRejectPolicy 自定义拒绝策略`**可以用来记录运行日志或者记录无法处理的任务** 样例演示： ```java /** * 自定义拒绝策略，实现RejectedExecutionHandler接口即可 */ static class CustomRejectedPolicy implements RejectedExecutionHandler{ @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { if (!executor.isShutdown()){ System.err.println("自定义异常日志记录: "+ r.toString()); } } } public static void customPolicyDemo(){ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 1, 1, 60, TimeUnit.SECONDS, new ArrayBlockingQueue(2), new CustomRejectedPolicy()); //使用execute是因为使用submit时会被封装成RunnableFuture对象 threadPoolExecutor.execute(new TestRunnable(1)); threadPoolExecutor.execute(new TestRunnable(2)); threadPoolExecutor.execute(new TestRunnable(3)); threadPoolExecutor.execute(new TestRunnable(4)); threadPoolExecutor.shutdown(); } 运行结果：由于4号被拒绝，记录日志 自定义异常日志记录: java.util.concurrent.FutureTask@4b1210ee pool-1-thread-1 当前线程id=1 pool-1-thread-1 当前线程id=2 pool-1-thread-1 当前线程id=3 ``` - 额外参数扩展 `allowCoreThreadTimeOut 允许核心线程过期 `默认值为false（线程池已不被使用，但是其中还有活着的线程，则该线程池无法被回收，会造成内存泄露）。所以用户可以显式调用`shutDown()`或者该值设置为true，则会被回收。 2. ThreadPoolExecutor的使用 向线程池提交一个任务的方式有两种： - `execute`：这种方法提交任务，是没有返回值的即无法判断在线程池中是否完成该任务 ```java threadPoolExecutor.execute(new TestRunnable(1)); ``` - `submit`：使用`submit`方法提交任务时，会返回一个future，可以通过这个future来判断任务是否执行成功也可以根据`future的get()`方法获取返回值。**若子线程任务没完成，`get()`方法会阻塞直到任务完成，若使用`get(long timeout,TimeUnit unit)`则会阻塞一段时间后返回，可能尚未完成任务。** ```java Future future = fixedThreadPool.submit(new Callable() { @Override public Integer call() throws Exception { System.err.println(Thread.currentThread().getName() + " , index = " + index); return 2; } }); try { System.err.println("Future return :" + future.get().toString()); } catch (Exception e) { e.printStackTrace(); } ``` 3. 线程池的关闭 线程池关闭方法有两种： - `shutdown()`：将线程池的状态置为SHUTDOWN状态，然后中断没有正在执行的线程。 ```java public void shutdown() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { checkShutdownAccess(); advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor } finally { mainLock.unlock(); } tryTerminate(); } ``` - `shutdownNow()`：将线程池的状态设为STOP状态，中断所有任务包括执行中的线程，并返回等待执行的任务列表。 ```java public List shutdownNow() { List tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { checkShutdownAccess(); advanceRunState(STOP); interruptWorkers(); tasks = drainQueue(); } finally { mainLock.unlock(); } tryTerminate(); return tasks; } ``` 中断线程需要采用`interrput`方法，**无法响应中断的任务可能永远无法终止。** 当需要立即中断所有线程并且不在乎任务是否执行完成时，可以使用`shutdownNow`方法。 4. 线程池的拓展 `ThreadPoolExecutor`默认提供三个空方法，可以通过重写这三个方法来监控线程池。 ```java //任务执行前 记录任务开始前时间 protected void beforeExecute(Thread t, Runnable r) { } //任务执行后 记录任务结束时间 protected void afterExecute(Runnable r, Throwable t) { } //线程池关闭 记录线程池关闭事件以及执行过的线程数量 protected void terminated() { } ``` 样例演示： ```java class CustomThreadPoolExecutor extends ThreadPoolExecutor{ public CustomThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); System.err.println("beforeExecute"+r.toString()); } @Override protected void afterExecute(Runnable r, Throwable t) { super.afterExecute(r, t); System.err.println("afterExecute"+r.toString()); } @Override protected void terminated() { super.terminated(); System.err.println("线程关闭"); } } ``` ### 3. 为什么要使用线程池 - **降低资源消耗。**通过重复利用已创建的线程降低线程创建和销毁造成的消耗 - **提高响应速度。**当任务到达时，任务可以不需要等到线程创建就可以立即执行 - **提高线程的可管理性。**线程是稀缺资源，大量创建会导致系统资源过度消耗且会降低系统的稳定性，线程池可以有效控制线程数，并进行统一的分配、调优和监控。 ### 4. 线程池的分类以及各自的特性 利用`Executors`类提供了四种不同的线程池，他们都是直接或者间接配置`ThreadPoolExecutor`来实现功能。下面分别介绍着四个线程池 `newFixedThreadPool` > 创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就不会发生变化，如果某个线程因为异常而结束，则会补充一个新进程。 > > 由于只设置核心线程大小，所以可以**更快的响应外界请求** > > 线程池的大小设置，可以使用`Runtime.getRuntime().availableProcessors()` - 实现源码 ```java /** * 设置了核心线程，并且没有超时机制，使用LinkedBlockingQueue则任务队列大小是无上限的 */ public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } ``` - 样例演示 ```java public static void fixedThreadPoolDemo(){ ExecutorService fixedThreadPool= Executors.newFixedThreadPool(3); for (int i = 0; i 可根据需要创建新线程的线程池，但是在一起构造的线程可用时将重用他们。对于很多短期异步任务的程序而言，这类线程池可以提高性能。 > > 如果现有线程没有可用的，则会创建一个新的线程并添加到池中，终止并从缓存中移除那些超过60s没有使用的线程。**因此，长时间保持空闲的newCachedThreadPool线程池是不存在任何线程的，所以这时候几乎不占用系统资源。** - 实现源码 ```java /** * 核心线程数为0 线程最大为Int的最大值所以可以认定为线程池最大线程无限大，设置了超时时间为60s。任务队列采用了阻塞队列(必须池内有空闲线程才可以执行) */ public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue()); } ``` - 样例演示 ```java public static void cachedThreadPoolDemo(){ ExecutorService cachedThreadPool= Executors.newCachedThreadPool(); for (int i = 0; i 创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。 - 实现源码 ```java public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } /** * 核心线程数固定，非核心线程数为无限大，当非核心数处于闲置状态的时候会被立即回收 */ public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } ``` - 样例演示 ```java public static void scheduleThreadPoolDemo() { ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3); //延迟一定时间后执行Runnable任务 scheduledThreadPool.schedule(new Runnable() { @Override public void run() { System.err.println(Thread.currentThread().getName() + " delay 2s"); } }, 2, TimeUnit.SECONDS); //延迟一定时间后执行Callable任务 scheduledThreadPool.schedule(new Callable() { @Override public Object call() throws Exception { return null; } }, 2, TimeUnit.SECONDS); //延迟一定时间（initialDelay）后,以(period)时间间隔执行任务 scheduledThreadPool.scheduleAtFixedRate(new Runnable() { @Override public void run() { System.err.println(Thread.currentThread().getName() + " every 3s"); } }, 1, 1, TimeUnit.SECONDS); //延迟一定时间（initialDelay）后,以(delay即上一个任务执行结束到下一个任务开始的间隔)执行 scheduledThreadPool.scheduleWithFixedDelay(new Runnable() { @Override public void run() { System.err.println(Thread.currentThread().getName() + " delay 3s"); } }, 1, 1, TimeUnit.SECONDS); } 运行结果： pool-1-thread-1 every 3s pool-1-thread-2 delay 3s pool-1-thread-3 delay 3s 1 pool-1-thread-2 every 3s ``` - 适用场景 用于需要多个后台线程执行周期任务，同时需要限制线程数量 `newSingleThreadExecutor` > 创建一个单线程池，该线程池中只有一个线程在工作，其他任务都会依次在任务中排列中等候依次执行，任务是串行执行的。此线程池保证所有的任务的执行顺序按照任务提交顺序执行(FIFO-先进先出)。 - 实现源码 ```java /** * 只有一个核心线程，对任务队列没有大小限制，将所有外界任务统一到一个线程执行所有我们不需要处理线程同步的问题。 */ public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())); } ``` - 样例演示 ```java public static void singleThreadPoolDemo(){ ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor(); for (int i = 0; i < 6; i++) { final int index = i; singleThreadExecutor.execute(new Runnable() { @Override public void run() { System.err.println(Thread.currentThread().getName() + " , index = " + index); } }); try { Thread.sleep(1000); } catch (Exception e) { e.printStackTrace(); } } } 运行结果：所有的任务都是在pool-1-thread-1中依次运行 pool-1-thread-1 , index = 0 pool-1-thread-1 , index = 1 pool-1-thread-1 , index = 2 pool-1-thread-1 , index = 3 pool-1-thread-1 , index = 4 pool-1-thread-1 , index = 5 ``` - 适用场景 用于串行执行任务的场景，每个任务需要顺序执行 ### 5. 线程池的执行流程 {% fullimage /images/study_plan/threadpool_process.png, 线程池执行流程图,线程池执行流程图 %} 1. 判断corePoolSize(核心线程数)是否已到达，没到达则可以创建一个新线程执行任务 2. 判断工作队列是否已满，没满则添加入队列等待执行 3. 判断maximum(最大线程数)是否已到达，没到达则创建一个新线程执行任务。已满则执行拒绝策略。 ### 6. 线程池的使用注意 1. 线程池不要用`Executors`的方式去创建，应该利用`ThreadPoolExecutor`的方式，这样可以帮助更好理解实现方式以及避免资源消耗过度的问题。 **`fixThreadPool以及singleThreadPool`,由于设置的等待队列长度为Integer.MAX_VALUE，导致大量请求堆积，消耗大量资源。** **`cachedThreadPool以及scheduledThreadPool`,由于运行允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的请求，消耗大量资源。** 2. 针对具体情况去配置线程池参数，不同的任务类别应采用不同规模的线程池，任务类别分为3种： - **`CPU密集型任务(需要进行大量计算，处理)`**：线程池中线程个数尽量少，不应大于CPU核心数，避免出现每个线程都需要长时间使用但是线程过多去抢占资源。 - **`IO密集型任务(主要时间都在IO，CPU空闲时间比较多)`**：线程池可以配置尽量多的线程，由于CPU大部分时间空闲，可以提高CPU的利用率。 - **`混合型任务`**：如果可以拆分，则拆分成一个CPU密集型以及IO密集型任务，只要执行任务效率相差不大。若相差太大则没必要拆分。 ## 7.补充知识 [参考链接](https://mp.weixin.qq.com/s?__biz=MzI3OTU0MzI4MQ==&mid=2247486818&idx=1&sn=5d5f87cceadb062c3502cd7a1e2d3e0a&chksm=eb4761fcdc30e8ea3de28eca8c16ce305336852534dbd23edb348b5c1e02334dee025ea8f7bf&mpshare=1&scene=23&srcid=12117GQN5ZAnFwJRhSpKAcO1%23rd)]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XVI -- AIDL]]></title>
    <url>%2F2018%2F05%2F31%2FAndroid-Study-Plan-XVI%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XVI -- AIDL date: 2018-05-31 12:35:10 tags: Android --- # Android学习计划 ## Android中AIDL的作用是什么？他所支持的参数类型是什么？默认情况下AIDL的调用过程是同步还是异步的？如何指定AIDL异步调用？]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler机制源码解析]]></title>
    <url>%2F2018%2F05%2F14%2FHandler%E6%9C%BA%E5%88%B6%E5%8D%B3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: Handler机制源码解析 date: 2018-05-14 23:13:32 tags: 源码解析 top : 10 --- # 主要的内容包括Handler的机制以及四个组成部分和源码的分析 [![](https://badge.juejin.im/entry/5bb7044ce51d450e7210d9f8/likes.svg?style=plastic)](https://juejin.im/post/5bb7007af265da0acf0af6c7) > 下面的代码分析都是基于Android8.0 - Oreo的源代码 > ## 1. 消息机制简介 在应用启动时，会执行`main()`方法，`main()`会创建一个Looper对象，然后开启一个死循环，目的是**不断从消息队列`MessageQueue`里面取出`Message`对象并处理。** 在Android中使用消息机制，会优先想到的是Handler。Handler可以轻松的将一个任务切换到Handler所在的线程去执行。在多线程的应用场景中，**可以将工作线程中需要更新UI的操作信息传递到主线程去执行**，从而实现工作线程更新UI的操作，最终实现异步消息的处理。 {% fullimage /images/study_plan/handler_process.png, Handler执行流程图,Handler执行流程图 %} ## 2. Handler机制模型 消息机制主要包含**Handler、Message、MessageQueue，Looper**这四个类。 - **Handler**：消息辅助类。主要功能将`Message`对象发送到`MessageQueue`中，同时将自己的引用赋值给`Message#target`(Handler.sendMessage())。也可以实现`handleMessage()`方法处理回调。 - **Message**：消息实体。需要传递的消息也可以传递数据。 - **MessageQueue**：消息队列。**内部实现并不是队列，而是利用单链表去实现因为在插入和删除数据有优势。**用于存储Handler发给来的消息(`Message`)以及取出。`内部使用单链表实现` - **Looper**：与线程绑定，不止局限于主线程，绑定的线程来处理`Message`。不断循环执行`Looper.loop()`，从`MessageQueue`中读取`Message`，按分发机制将消息分发出去给目标处理(将`Message`发到`Handler.dispatchMessage`方法去处理)。 ## 3. Handler运行流程 {% fullimage /images/study_plan/handler_run_process.png, Handler运行流程图,Handler运行流程图 %} 工作流程：**异步通信准备==>消息入队==>消息循环==>消息处理** 1. **异步通信准备** > 假定在主线程创建Handler，则会直接在主线程中创建`Looper`,`MessageQueue`和`Handler`对象。**Looper和MessageQueue对象均属于其`创建线程`（由主线程创建则属于主线程）。**创建`Looper`时会自动创建`MessageQueue`对象，创建好`MessageQueue`对象后，`Looper`自动进入循环。`Handler`自动绑定`Looper`以及`MessageQueue`。 > > `Looper`对象的创建方法一般通过`Looper.prepareMainLooper()`和`Looper.prepare()`方法。 2. **消息入队** > 工作线程通过`Handler`发送`Message`到`MessageQueue`中。消息内容一般是UI操作，通过`Handler.sendMessage(Message message)`或`Handler.post(Runable r)`发送。加入`MessageQueue`一般通过`MessageQueue.enqueueMessage(Message msg,long when)`操作。 3. **消息循环** > 分为**消息出队**和**消息分发**两个步骤 > > - 消息出队：`Looper`从`MessageQueue`中循环取出`Message` > - 消息分发：`Looper`将取出的`Message`分发给创建消息的`Handler` > > **消息循环过程中，`MessageQueue`为空，则线程堵塞** 4. **消息处理** > `Handler`接受发过来的`Message`并处理。 ## 4. Handler使用过程的注意点 1. 在工作线程中创建自己的消息队列时必须要调用`Looper.prepare()`,并且**在一个线程中只可以调用一次**，然后需要调用`Looper.loop()`,开启消息循环。 > 在开发过程中基本不会调用上述方法，因为默认会调用主线程的Looper，然后一个线程中只能有一个Looper对象和一个MessageQueue。 2. **要注意Handler可能引起的内存泄漏**(在下面会介绍到为何会引发泄漏)。 错误的写法: ```java private final Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; ``` **非静态的内部类和匿名内部类都会隐式的持有其外部类的引用，而静态内部类不会持有外部类的引用。** 正确的写法： > 继承`Handler`时候要么放在单独的类文件中，要么直接使用静态内部类。 ```java //需要在静态内部类中调用外部类时，可以直接使用 `弱引用` 进行处理 private static final class MyHandler extends Handler{ private final WeakReference mWeakReference； public MyHandler(MyActivity activity){ mWeakReference = new WeakReference(activity); } @Override public void handlerMessage(Message msg){ super.handlerMessage(msg); MyActivity activity = mWeakReference.get(); } } //调用方法 private MyHandler mHandler = new MyHandler(this); ``` ## 5. Handler源码解析 1. **创建循环器对象（`Looper`）和创建消息队列对象(`MessageQueue`)** > 创建Looper对象主要有两个方法：`Looper.prepareMainLooper()`和`Looper.prepare()` > > 创建MessageQueue对象方法：**创建Looper对象时会自动创建MessageQueue** ```java // 源码位置:../core/java/android/os/Looper.java final MessageQueue mQueue; final Thread mThread; //Looper对象创建时会自动创建一个MessageQueue对象。 private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } //为当前线程(子线程)创建一个Looper对象 需要在子线程中主动调用该方法 public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { //判断sThreadLocal是否为null，不为空则直接跑出异常 可以保证一个线程只可以调用一次prepare方法 if (sThreadLocal.get() != null) { throw new RuntimeException("Only one Looper may be created per thread"); } sThreadLocal.set(new Looper(quitAllowed)); } //为主线程创建一个Looper对象 该方法会在主线程创建时自动调用 public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException("The main Looper has already been prepared."); } sMainLooper = myLooper(); } } ``` 总结： 1. 创建`Looper`对象时会自动创建`MessageQueue`对象 2. 主线程的Looper对象是自动生成的，而子线程需要调用`Looper.prepare()`创建`Looper`对象 > 创建主线程是调用了`ActivityThread`的`main()`方法。 > > 然后按照流程调用了`Looper.prepareMainLooper()`和`Looper.loop()`。所以主线程不需要调用代码生成Looper对象。 ```java //源码位置: ../core/java/android/app/ActivityThread.java public static void main(String[] args) { ... Looper.prepareMainLooper(); Looper.loop(); ... } ``` 3. Handler的主要作用是(`在主线程更新UI`)，所以**Handler主要是在主线程创建的**。 4. Looper与Thread是通过`ThreadLocal`关联的。由于`ThreadLocal`是与线程直接关联的，参考`prepare()`。 5. 子线程创建Handler对象:无法在子线程直接调用Handler无参构造方法**Handler创建时需要绑定Looper对象** 。需要使用`HandlerThread`。 2. **开启Looper即消息循环** > 创建了`Looper和MessageQueue`对象后，自动进入消息循环，使用`Looper.loop()`方法开始消息循环。 ```java //源码位置：../core/java/android/os/Looper.java public static void loop(){ //现获取Looper实例，保证调用loop时已有Looper，否则抛出异常 final Looper me = myLooper(); if (me == null) { throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); } //获取对应Looper实例创建的MessageQueue对象 final MessageQueue queue = me.mQueue; ... //开启消息循环-无限循环 for (;;) { //从MessageQueue取出Message对象 Message msg = queue.next(); // might block //取出消息为null，则退出循环 if (msg == null) { // No message indicates that the message queue is quitting. return; } //把Message分发给相应的target try { msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } //释放消息占据的资源 msg.recycleUnchecked(); } } ``` 3. **创建Handler对象** >创建Handler对象即可以进行消息的发送与处理 ```java //源码位置：.../core/java/android/os/Handler.java //Handler默认构造方法 public Handler() { this(null, false); } public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) && (klass.getModifiers() & Modifier.STATIC) == 0) { Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); } } //从当前线程的ThreadLocal获取Looper对象 mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); } //获取当前Looper的消息队列 mQueue = mLooper.mQueue; mCallback = callback; //设置消息是否为异步处理方式 mAsynchronous = async; } public Handler(Looper looper, Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } ``` `Handler的无参构造方法会默认关联当前线程的Looper对象和MessageQueue对象，设置callback回调方法为null，且消息处理方式为同步处理。` 4. **创建消息对象** >Handler发送Message并且进入MessageQueue循环，创建方式分为两种`new Message()`和`Message.obtain()`。通常使用`Message.obtain()`。这种方式**有效避免创建重复Message对象**。 ```java //创建消息对象 Message msg = Message.obtain(); msg.what = 1; msg.obj = "test"; //源码位置 .../core/java/android/os/Message.java /** Constructor (but the preferred way to get a Message is to call {@link #obtain() Message.obtain()}). */ //new Message 方法 public Message() { } private static final Object sPoolSync = new Object(); //维护一个Message池，用于复用Message对象 private static Message sPool; //obtain方法 直接从池内获取Message对象，避免new占用内存 public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; //直接从池中取出 return m; } } //无可复用对象，则重新new获取 return new Message(); } ``` 5. **发送消息(Message)** > Handler主要有以下几种发送消息的方式: > > - `sendMessage(Message msg)` > - `sendMessageDelayed(int what, long delayMillis)` > - `post(Runnable r)` > - `postDelayed(Runnable r, long delayMillis)` > - `sendMessageAtTime(Message msg, long uptimeMillis) ` > > 最终都是会调用到`sendMessageAtTime(Message msg, long uptimeMillis)`然后继续调用到`enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)`放入MessageQueue ```java //源码位置：.../core/java/android/os/Handler.java //post方法 public final boolean post(Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } public final boolean postAtTime(Runnable r, long uptimeMillis) { return sendMessageAtTime(getPostMessage(r), uptimeMillis); } public final boolean postAtTime(Runnable r, Object token, long uptimeMillis) { return sendMessageAtTime(getPostMessage(r, token), uptimeMillis); } public final boolean postDelayed(Runnable r, long delayMillis) { return sendMessageDelayed(getPostMessage(r), delayMillis); } //利用post()方式发送消息，需要转换为Message向下传递 private static Message getPostMessage(Runnable r, Object token) { Message m = Message.obtain(); m.obj = token; //将runnable赋值到callback上 以便后续判断是post还是sendMessage方式发送的消息 m.callback = r; return m; } //sendMessage方法 public final boolean sendMessage(Message msg) { return sendMessageDelayed(msg, 0); } public final boolean sendMessageDelayed(Message msg, long delayMillis) { if (delayMillis < 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); } //所有的发送消息有关方法 都会调用到这个方法 public boolean sendMessageAtTime(Message msg, long uptimeMillis) { //获取MessageQueue对象 MessageQueue queue = mQueue; //获取对象为空 抛出异常 if (queue == null) { RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; } //对象不为空 调用enqueueMessage方法 return enqueueMessage(queue, msg, uptimeMillis); } //该方法为了 向MessageQueue插入Message private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { // 把当前的Handler设置为 消息标记位 即把消息派发给相对应的Handler实例 msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } //调用MessageQueue的enqueueMessage方法 return queue.enqueueMessage(msg, uptimeMillis); } ``` ```java //源码位置：..core/java/android/os/MessageQueue.java //内部是一个单链表有序序列，由 Message.when 作为排序依据，该值为一个相对时间。 boolean enqueueMessage(Message msg, long when) { ... synchronized (this) { //正在退出 回收Message if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; // p == null判断当前队列中是否有消息，插入消息作为队列头 // when == 0||when < p.when 队列当前处于等待状态 唤醒队列 if (p == null || when == 0 || when < p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. //当前队列有消息，按照消息创建时间插入到队列中 needWake = mBlocked && p.target == null && msg.isAsynchronous(); Message prev; //从对列头部开始遍历 for (;;) { prev = p; p = p.next; //循环到队列尾部或者出现一个when小于当前Message的when if (p == null || when < p.when) { break; } if (needWake && p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } ``` 总结： - 发送消息时`Message.when`表示期望该消息被分发的时间即`SystemClock.uptimeMillis() + delayMillis`。`SystemClock.uptimeMills`代表自系统开机到调用到该方法的时间差。 - `Message.when`利用时间差来表达期望事件分发的时间，所以使用的是一个相对时间。 6. **获取消息** > 发送了消息后，MessageQueue维护了消息队列，在Looper中通过`loop()`不断获取Message。通过`next()`获取Message. ```java //源码位置：..core/java/android/os/MessageQueue.java Message next(){ //该参数用于确定消息队列中是否有消息 下一个消息到来前需要等待的时长 int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } //该方法位于native层 若nextPollTimeoutMillis为-1 代表消息队列处于等待状态 阻塞操作 nativePollOnce(ptr, nextPollTimeoutMillis); ... synchronized (this) { ... Message msg = mMessages; if (msg != null) { if (now < msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; //标记消息使用状态 flag |= FLAG_IN_USE msg.markInUse(); //返回一条消息 return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } //消息正在退出 if (mQuitting) { dispose(); return null; } } } } ``` 7. **分发消息** > 分发消息到对应的Handler实例并根据传入的Message做对应的操作 ```java //源码位置：.../core/java/android/os/Handler.java public void dispatchMessage(Message msg) { //若callback不为空，则代表使用了post(Runnable r)方式发送了消息，执行handleCallback方法 if (msg.callback != null) { handleCallback(msg); } else { //代表使用了sendMessage()方式发送了消息，调用handleMessage方法 if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } //创建Handler实例时复写 自定义消息处理方法 public void handleMessage(Message msg) { } //直接回调runnable对象的run() private static void handleCallback(Message message) { message.callback.run(); } ``` 总结： - `msg.target.dispatchMessage(msg)`中`msg.target`指向的就是对应Handler实例， - 消息分发的优先级： 1. Message的回调方法`message.callback.run()` 2. Handler中Callback的回调方法`mCallback,handleMessage(msg)` 3. Handler的默认方法`handleMessage()` 8. **Message回收** > 上面讲到了新建Message推荐使用`obtain()`，因为可以有效的复用消息，其中里面复用的就是`sPool`变量，它是在Message回收的时候进行赋值的。 ```java //源码位置 .../core/java/android/os/Message.java /*package*/ boolean isInUse() { return ((flags & FLAG_IN_USE) == FLAG_IN_USE); } public void recycle() { //正在使用 无法回收 if (isInUse()) { if (gCheckRecycle) { throw new IllegalStateException("This message cannot be recycled because it " + "is still in use."); } return; } recycleUnchecked(); } void recycleUnchecked() { // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. //置为使用标记 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; //将Message放在了列表里，缓存的对象由obtain()拿出来复用 synchronized (sPoolSync) { if (sPoolSize < MAX_POOL_SIZE) { next = sPool; sPool = this; sPoolSize++; } } } ``` 9. **Looper退出** > `Looper.loop()`内部由一个无限循环组成，默认情况下不会退出循环。需要退出就需要调用`quit()`或者`quitSafely()`。 ```java //源码位置 .../core/java/android/os/Looper.java public void quit() { mQueue.quit(false); } public void quitSafely() { mQueue.quit(true); } //源码位置 .../core/java/android/os/MessageQueue.java void quit(boolean safe) { if (!mQuitAllowed) { throw new IllegalStateException("Main thread not allowed to quit."); } synchronized (this) { if (mQuitting) { return; } mQuitting = true; if (safe) { removeAllFutureMessagesLocked(); } else { removeAllMessagesLocked(); } // We can assume mPtr != 0 because mQuitting was previously false. //唤醒等待线程 nativeWake(mPtr); } } //直接移除MessageQueue中的所有消息 private void removeAllMessagesLocked() { Message p = mMessages; while (p != null) { Message n = p.next; //回收未被处理的消息 p.recycleUnchecked(); p = n; } //由于消息为null 则return 出无限循环 mMessages = null; } //直接移除未处理的消息 已经在执行的继续处理 private void removeAllFutureMessagesLocked() { final long now = SystemClock.uptimeMillis(); Message p = mMessages; if (p != null) { //还未处理的Message if (p.when > now) { removeAllMessagesLocked(); } else { Message n; for (;;) { n = p.next; if (n == null) { return; } if (n.when > now) { break; } p = n; } //不接收后续消息 p.next = null; do { p = n; n = p.next; p.recycleUnchecked(); } while (n != null); } } } ```]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的GC分析-Dalvik和ART虚拟机]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid%E4%B8%AD%E7%9A%84GC%E5%88%86%E6%9E%90-Dalvik%E5%92%8CART%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[--- title: Android中的GC分析-Dalvik和ART虚拟机 date: 2018-05-13 10:10:54 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XV -- 四大组件]]></title>
    <url>%2F2018%2F05%2F13%2FAndroid-Study-Plan-XV%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XV -- 四大组件 date: 2018-05-13 09:50:49 tags: Android --- # Android学习计划 ## Android中的四大组件每个组件的作用是什么？他们都可以开启多进程吗？ ### Android四大组件： 1. **`Activity`** > Activity的主要作用是展示一个界面并和用户直接交互。 activity的启动由Intent触发（**需要在AndroidManifest.xml中注册**）。Intent分为两种： - 显示Intent：直接跳转至指定的Activity类 ```java // 构造方法中直接传入Component Intent intent=new Intent(this,Activity.class); startActivity(intent); // 调用SetComponent方法 ComponentName componentName=new Component(this,Activity.class); Intent intent=new Intent(); intent.setComponentName(componentName); startActivity(intent); // 使用setClass方法 Intent intent=new Intent(); intent.setClassName(this,Activity.class); startActivity(intent); ``` - 隐式Intent：不明确指定启动哪个Activity，而是利用Activity配置的Action，Data，Category来让系统进行选择(`筛选是根据所有的来筛选`) ```java // setAction方法 Intent intent=new Intent(); intent.setAction("TestActivity"); startActivity(intent); //直接构造Action Intent intent=new Intent("TestActivity"); startActivity(intent); //在使用隐式调用时需要注意该Action是否存在,所以需要做try-catch防止异常发生 //利用这个方法可以判断是否有处理该Action的Activity存在 intent.resolveActivity(getPackageManager()) ``` 2. **`Service`** Service主要用于在后台执行一系列需要耗时的任务，需要单独的线程去完成，因为Service本身是运行在主线程的。Service不会与UI进行交互，其他的组件也可以启动Service，即便用户切换了应用，Service依然后台运行。（**需要在AndroidManifest.xml中注册**），Service有两种启动方式： - `startService`：启动一个Service，系统回调`onStartCommand()方法`，需要调用`stopService()`来停止Service - `bindService`：绑定一个Service，调用`unBindService()`来取消绑定，或者关闭绑定的组件也可以停止 3. **`BroadcastReceiver`** [完整介绍](https://www.jianshu.com/p/ca3d87a4cdf3) 广播主要用于在不同的组件甚至不用的应用间进行消息传递，不与用户产生交互，工作在系统内部。 广播的注册方式有两种： - 静态注册 （**需要在AndroidManifest.xml中注册**） ```xml ``` - 动态注册 ```java //最好在onResume中注册广播 @Override protected void onResume(){ super.onResume(); mBroadcastReceiver=new BroadcastReceiver(); IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction("com.test"); this.registerReceiver(mBroadcastReceiver,intentFilter); } //在onPause中取消注册 @Override protected void onPause(){ super.onPause(); this.unregisterReceiver(mBroadcastReceiver); } ``` 4. **`ContentProvider`** [相关链接](https://www.jianshu.com/p/ea8bc4aaf057) 主要用于给不同的应用提供共享数据,（**需要在AndroidManifest.xml中注册**） ```xml ``` ContentProvider默认执行在主线程，需要实现以下方法 - `onCreate()`：初始化Provider - `query()`：查询数据 **需异步操作** - `insert()`：插入数据 - `update()`：更新Provider的数据 - `delete()`：删除Provider的数据 - `getType()`：返回指定Uri中的数据MIME类型 相关的操作可能会被多个线程并发调用需要注意线程安全。 ### 开启多进程 Android的四大组件都可以开启多进程，只要在AndroidManifest.xml中配置`android:process="any"`，需要配置`android:exported`属性]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(五)]]></title>
    <url>%2F2018%2F05%2F09%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展(五) date: 2018-05-09 19:11:37 tags: JVM top: 11 ---]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--HashMap实现原理及解析]]></title>
    <url>%2F2018%2F05%2F09%2FHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[--- title: 数据结构--HashMap实现原理及解析 date: 2018-05-09 13:03:31 tags: Java源码 top: 1 ---]]></content>
      <tags>
        <tag>Java源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(四)]]></title>
    <url>%2F2018%2F05%2F04%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展(四) date: 2018-05-04 13:25:05 tags: JVM top: 11 --- # 垃圾收集器与内存分配策略 ## 垃圾收集器 ### 1.概述 **垃圾收集(Garbage Collection,GC)：自动管理回收不再引用的内存数据**需要完成的三件事情： - 哪些内存需要回收 - 什么时候回收 - 如何回收 > Java语言会自动管理和回收不再引用的内存数据，由垃圾回收机制来完成。Java自身提供了内存管理机制，应用程序不需要去关注内存如何释放，内存用完后，GC会去自动进行处理，不需要人为干预出现错误。 在{% post_link JVM相关及其拓展 %}章节中介绍了JVM的内存区域。 **其中`程序计数器`、`虚拟机栈`，`本地方法栈`随线程而生，随线程而灭**。栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作，因此每一个栈帧分配多少内存基本是在类结构确定下来就已经是已知的。**因此这几个区域的内存分配和回收都具备确定性。所以不需要过多考虑回收的问题，在方法结束或者线程结束后，内存就随着回收了，也就实现了内存的自动清理。** **而`Java堆`和`方法区`则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序运行期间才知道会创建哪些对象，这部分的内存分配和回收是动态的。垃圾收集器关注的就是这部分的内存。** ### 2.判断对象是否可以回收 > 在堆里面存放着几乎所有的对象实例，垃圾收集器在回收前需要去判断对象是否还被引用来决定是否回收，即找到那些不再被任何途径使用的对象。 - **引用计数算法(Refrence Counting)** > 给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时候计数器为0的对象是不能再被引用的，可以被当做垃圾收集。 > > 优点：实现简单，判断效率高 > 缺点：无法检测出对象之间相互循环引用，开销大（会发生频繁且大量的引用变化，带来大量的额外运算）。 - **可达性分析算法(Reachability Analysis)** > 通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的节点为引用链，当一个对象到GC Roots没有任何引用链相连（从GC Roots到这个对象不可达）时，则证明此对象是不可用的。 {% fullimage /images/jvm/gc_reachability_analysis.png,可达性分析算法,可达性分析算法 %} 在Java语言中，可作为GC Roots的对象包括以下几种： - 虚拟机栈（栈帧中的本地变量表）中引用的对象 - 方法区中类静态属性引用的对象 - 方法区中常量引用的对象 - 本地方法栈中JNI引用的对象（Native对象） > 优点：更加精确严谨可以分析出循环引用的情况 > > > 缺点：实现复杂，效率低，分析过程中需要GC停顿（因为应用关系不能发生改变，需要停止所有Java线程） ### 3.对象是生存还是死亡 > 真正宣告一个对象死亡，至少要经历两次标记过程 - **第一次标记**： 对象在进行可达性分析算法后没有发现与GC Roots相连接的引用链，将会被第一次标记并进行第一次筛选。筛选的条件是此对象是否有必要执行`finalize()`方法。 - 没必要执行 对象没有覆盖`finalize()`方法，或者`finalize()`方法已被虚拟机调用过。 - 有必要执行 对象会被放置在一个F-Queue的队列中，稍后会由一个JVM自动建立的、低优先级的Finalizer线程去执行。 - **第二次标记：** GC对F-Queue中的对象进行第二次小规模的标记，`finalize()`是对象摆除被回收的最后方法 - 若对象要避免自己被回收，需要重新与引用链上的任何一个对象建立关系即可，譬如把自己（this）赋值给某个变量或者对象的成员变量，那就会移除被回收的集合 - 如果没有摆除，则基本上会被回收。任何一个对象的`finalize()`方法只会被系统自动调用一次，再次调用`finalize()`方法则不会再次执行。 ```java public class FinalizeEscapeGC { public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() { System.err.println("It is live"); } @Override protected void finalize() throws Throwable { super.finalize(); System.err.println("finalize is executed"); FinalizeEscapeGC.SAVE_HOOK = this; } public static void main(String[] args) throws Throwable { SAVE_HOOK = new FinalizeEscapeGC(); SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.err.println("It is over"); } //将对象的引用链重新置为null，则拯救失败 SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.err.println("It is over"); } } } ``` - **`finalize()`** 运行代价高昂，不确定性大，无法保证各个对象的调用顺序。 ### 4.回收方法区 > 永久代的垃圾收集主要分为两部分：**废弃常量和无用的类** > > **废弃常量**：假如常量池中存在一个常量，但是没有任何对象引用该常量，在发生回收的时候，该常量就会被系统清理出常量池，常量池中的其他类（接口）、方法、字段的符号引用类似。 > > **无用的类**：需要同时满足以下条件 > > 1. 该类的所有实例已被回收，Java堆中不存在该类的任何实例 > 2. 加载该类的ClassLoader已被回收 > 3. 该类对应的Class对象没有在任何地方被引用，也无法在任何地方通过反射访问到该类的方法 ### 5.垃圾收集算法 1. **标记-清除算法(Mark-Sweep) 最基础的收集算法** > 算法分为`标记`和`清除`两个阶段，**首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象**。主要不足有两个：一个是效率问题（`标记和清除两个过程的效率都不高`）；另一个是空间问题（`标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作`）。 {% fullimage /images/jvm/gc_mark_sweep.png ,标记-清除算法,标记-清除算法%} 2. **复制算法(Copying)** > 将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象移到另一块上面，然后把已使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时就不需考虑内存碎片等情况。 > > 缺点：可用内存会减少一半；效率会随存活对象的升高而降低（当对象存活率较高的时候，需要更多的copy操作，导致效率降低） {% fullimage /images/jvm/gc_copying.png,整理算法,整理算法 %} 现在的商业虚拟机都采用这种收集算法来回收新生代。 提供了改良算法（基于**弱代理论①**）：不是按照1:1的比例去划分内存空间，而是分为较大的Eden空间和两块较小的Survivor空间，在回收时将Eden和Survivor存活的对象移至到另一块Survivor空间上。**HotSpot中Eden和Survivor的大小比例为8:1。**`在一般场景下足够使用，当Survivor空间不够使用时，需要依赖其他内存(代指老年代)进行分配担保②`。 > ①**弱代理论**：1. 大多数分配了内存的对象存活不会太久，在年轻代就会死掉；2. 很少有对象从年老代变成年轻代。 > > ②**分配担保**：如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。若老年代也满了就会触发一次full GC，也就是新生代和老年代都会进行回收。 3. **标记-整理算法(Mark-Compact)** > 标记过程与“标记-清除”算法一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理端边界以外的内存。 {% fullimage /images/jvm/gc_mark_compact.png,标记-整理算法,标记-整理算法%} > 优点：1. 效率不随对象存活率升高而降低。 2. 不像标记-清除算法会产生大量的内存碎片（因为会进行一次整理，将存活对象集中到一端）。 > > 缺点：除了需要进行标记，还需要整理过程，执行效率更低。 4. **分代收集算法(Generational Collection)** > 根据对象存活周期的不同将内存划分为几块，一般是把Java堆分成新生代和老年代~~和持久代(JDK8中移除)~~，这样就可以根据各个年代的特点采用最适当的收集算法。 > **新生代**中每次垃圾收集都会有大量的对象被回收，只有少量存活，就可以使用复制算法。 > > **老年代**中因为对象存活率较高，没有额外空间进行分配担保，所以必须使用“标记-清理”或者“标记-整理”算法。 - **新生代(Young Generation)**：所有新生对象都会放在新生代，新生代的目标是尽快收集生命周期短的对象，每次GC过后只有少量存活。新生代发生的GC叫做**`Minor GC（频率较高，新生代Eden区满才触发）`**。新生代细分为`Eden、From Survivor、To Survivor`三块空间（三块空间大小并非均分，默认比例为8:1:1）。 - **老年代(Tenured Generation)**：新生代发生几次GC后依然存活的对象会放到老年代中，所以老年代中的对象生命周期较长。内存也比新生代大很多（大概2:1）,当老年代内存满时会触发**`Full GC/Major GC(针对新生代和老年代触发，经常会伴随至少一次的Minor GC，收集频率较低且耗时长，一般慢10倍以上)`**。 - ~~**持久代(Permanent Generation)**~~：用于存放静态文件，如Java类，方法等，对GC没有影响。 - **拓展**：别处也有介绍 Full GC针对整个堆空间（包含新生代，老年代，永久代（如果包含））的回收。而Major GC是针对老年代的内存回收。 - **Minor GC**：新生代是堆的一部分，对象首先在新生代中分配。新生代填满时，垃圾收集器会暂停所有的应用程序，回收新生代空间。不再使用的对象会被回收，仍然使用的对象移动至其他地方。 - **Full GC:** 对象不断地移至老年代，最终老年代也被填满，JVM需要找到老年代不再使用的对象并进行回收。会导致长时间停顿。 {% fullimage /images/jvm/gc_java_heap_memory.png,Java堆内存,Java堆内存 %} ### 6.垃圾收集器 > 收集算法是内存回收的方法论，垃圾收集器就为内存回收的具体实现。 {% fullimage /images/jvm/gc_collectors.png,垃圾收集器,垃圾收集器 %} 在两个收集器之间存在连线，则意味着他们之间可以搭配使用。 - `Serial收集器` > 该收集器是最基本、发展历史最悠久的收集器。这个收集器是一个**单线程**收集器（`不仅是他只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是他在进行垃圾收集时必须停止其他的工作线程(Stop The World)，直到收集结束。进行Full GC时，还会对老年代空间对象进行压缩整理。`）。 是虚拟机运行在Client端的默认新生代收集器 有着优于其他收集器的地方： - **简单而高效** - **没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集效率** 关键控制参数： - -XX:SurvivorRatio：设置两个Survivor区和Eden区的比值(**8表示 1:1:8**) - -XX:PretenureSizeThreshold：设定对象超过多少岁时进入老年代 - -XX:HandlePromotionFailure：设置是否允许担保失败 - `ParNew收集器` > ParNew收集器其实是Serial收集器的多线程版本。除了使用多线程进行垃圾收集之外，其他科Serial收集器完全一样。 该收集器是运行在Server模式下的虚拟机中的首选的新生代收集器，其中有一个重要的原因就是：**除了Serial收集器外，目前只有它能和CMS收集器配合工作。**随着可以使用的CPU数量增加，GC时系统资源的有效利用还是有好处的。**默认开启的收集线程数与CPU的数量相同** > **并行（Parallel）**：指多条垃圾收集器线程并行工作，但此时用户线程仍处于等待状态 > > **并发（Concurrent）**：指用户线程与垃圾收集器同时执行，用户程序仍继续运行，而垃圾收集器执行于另一个CPU上。 关键控制参数： - -XX:UserParNewGC：是否开启ParNew收集器 - `Parallel Scavenge收集器` > Parallel Scavenge收集器是一个新生代收集器，使用了复制算法以及并行的多线程收集器。 该收集器的目标是：**达到一个可控制的吞吐量（ThroughPut）**①。 停顿时间越短越适合需要与用户交互的程序，良好的响应速度可以提升用户体验，高吞吐量就可以高效率的利用CPU时间，主要适合在后台运算而不需要太多交互的任务。 > `吞吐量`：CPU用于运行用户代码时间与CPU总消耗时间的比值。 关键控制参数： - -XX:UseAdaptiveSizePolicy：开关参数，当打开时就不需要去指定新生代大小以及Eden与Survivor比例，晋升老年代对象岁数大小等参数，触发**GC自适应调节策略**(`虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数已提供最适合的停顿时间或者最大的吞吐量`) - `Serial Old收集器` > 是Serial收集器的老年代版本，同样是一个单线程收集器。使用“标记-整理算法” 该收集器主要为了给Client模式下的虚拟机使用。如果在Server模式下，还有以下用途： - 在JDK1.5及之前的版本搭配Paraller Scavenge收集器 - 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用 - `Parallel Old收集器` > 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理算法”。 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑`Parallel Scavenge + Parallel Old`组合。 - **`CMS收集器（Concurrent Mark Sweep）`** > 以获取最短回收停顿时间为目标的收集器。基于“标记-清除算法”实现。整体上来说内存回收过程是与用户线程一起并发执行的。 运作过程比较复杂，分为4个步骤： - **初始标记**：仅仅标记一下GC Roots能关联到的对象，速度很快 `触发Stop The World` - **并发标记**：进行GC Roots Tracing的过程 - **重新标记**：修正并发标记期间因用户程序继续运做而导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记长一些，但短于并发标记时间 `触发Stop The World` - **并发清除**：可以和用户线程一起工作 {% fullimage /images/jvm/gc_collectors_CMS.png,CMS,CMS %} CMS收集器有3个明显的缺点： 1. **对CPU资源非常敏感** **面向并发设计的程序都对CPU资源比较敏感**。在并发阶段，虽然不会导致用户线程停顿，但是会因为占了一部分CPU资源而导致线程变慢，吞吐量会降低。`CMS默认启动的回收线程数量为(CPU数量+3)/4` 2. **无法处理浮动垃圾（Floating Garabge）** 由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就有新的垃圾产生，即`浮动垃圾(这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉他们，只能留到下一次GC进行清理)`。 因此CMS收集器不能像其他收集器一样等到老年代几乎完全满了在进行收集，需要预留一部分空间提供并发收集时使用。 JDK1.5默认设置下，CMS收集器到老年代到了68%即会激活，到1.6时提高到了92%。 要是CMS运行期间预留的内存无法满足程序需要，就会出现一次`Concurrent Mode Failure`失败，虚拟机将会启动后备预案：**临时启用Serial Old收集器来重新进行老年代的垃圾收集，停顿时间就会变得很长了。** 3. **产生的空间碎片** 由于CMS是基于“标记-清除”算法实现的收集器。这种方式会产生大量的空间碎片，碎片过多时将会给对象分配来很大麻烦，往往会出现老年代还有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。 关键控制参数： - -XX:CMSInitiatingOccupancyFraction：设置CMS触发阈值即老年代对象占用空间 - **`G1收集器`** > 全称Garbage-First收集器，通过-XX:+UseG1GC参数来启用，在JDK9中，被提议为默认收集器 G1收集器是一款面向服务端的垃圾收集器，设计目标是为了取代CMS收集器。具备如下特点： - **并行与并发**：使用多个CPU来缩短停顿时间，也会通过并发的方式让Java程序继续运行 - **分代收集**：分代概念在G1中得以保留，可以不需要其他的收集器配合管理整个堆，可以采用不同的方式去处理新创建的对象和旧对象。 - **空间整合**：整体基于“标记-整理”算法，局部（两个Region之间）采用“复制”算法实现 - **可预测的停顿**：除了追求低停顿外，还可建立可预测的时间停顿模型，用户可以指定期望停顿的时间 #### Region 在G1收集器之前其他收集器进行收集的范围都是整个新生代或者老年代，而G1可以通用。使用G1收集器，Java堆的内存布局就与其他收集器不同，将整个Java堆划分为多个大小相等的独立区域（Region），虽然保留了新生代老年代的概念，但他们都变成了一部分Region的集合。 #### 可停顿的时间模型 可以实现有计划的避免在整个Java堆中进行全区域的垃圾收集。跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region空间。可以保证G1收集器在有限时间内获得尽可能高的收集效率。 #### Remembered Set Region不可能是独立的，由于可能会被其他对象引用。在G1中，Region之间的对象引用以及其他收集器中的新生代老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。每一个Region都会对应一个Remembered Set，虚拟机发现在对Reference进行读写操作时，产生一个`Write Barrier`暂时中断写操作，检查对象引用是否位于不同的Region中，若是则通过`CardTable`记录相关引用信息到Remembered Set中。**在进行内存回收时，在GC Roots中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。** #### G1运作步骤 - **初始标记**：标记一下GC Roots能直接关联的对象，需要停顿线程 - **并发标记**：从GC Roots开始进行可达性分析，找出存活的对象耗时较长 - **最终标记**：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，需要停顿线程，可并行执行 - **筛选回收**：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间来指定回收计划。 **如果应用追求吞吐量，那并不会带来特别的好处** ### 7.拓展 1. 垃圾回收过程 1. 对象在Eden进行内存分配 2. 当Eden区满了，在创建对象会触发Minor GC(**执行Minor GC时，Eden空间存活的对象会被复制到To Survivor·空间，并且之前经过一次Minor GC在From Survivor存活并年轻的对象也会被复制到To Survivor空间。如果存活对象的分代年龄超过阈值，则会晋升到老年代。**)]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-链表]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[--- title: 数据结构-链表 date: 2018-04-25 13:25:55 tags: 数据结构 --- # 数据结构-链表 > 链表是一种基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)，简单来说链表并不像数组存储在一个连续的内存地址空间里，他们可以是不连续的因为他们每个节点保存着下一个节点的引用（地址），所以较之数组来说这是一个优势。 ## 1.单链表 > 单链表是链表的一种，由节点组成，每个节点包含到下一个节点的指针。 > 单链表特点： > > - 链表增删元素时间复杂度度为O(1)，查找一个元素复杂度为O(n) > - 单链表不需要预先分配空间，避免空间浪费 > - 单链表不能进行回溯操作，例如读取倒数几个节点的值 {% fullimage /images/structures/single_linkedlist.png,单链表,单链表 %} ```java /** * 表示一个节点 */ public class Node { //数据域 public int data; //下一节点 public Node next; public Node() { } public Node(int data) { this.data = data; } public Node(int data, Node next) { this.data = data; this.next = next; } } ``` ### 单链表的基本操作 - 链表添加元素 - 添加头部 - 添加尾部 - 链表删除元素 - 删除指定位置 - 删除倒数第K个节点 - 链表查询元素 - 指定索引 - 查询倒数第K个节点 - 其他操作 - 寻找链表中间元素 - 旋转单链表 - 翻转单链表 - 单链表排序 - 冒泡排序 - 插入排序 - 链表相加求和 - 删除重复元素 ​ ​]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(三)]]></title>
    <url>%2F2018%2F04%2F16%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展(三) date: 2018-04-16 13:29:36 tags: JVM top: 11 --- # 1.虚拟机类加载器 ## 定义： 在类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码块称为“类加载器”。 例如：编写的是.java文件，代码运行后变成.class文件，类加载器就是加载.class文件。 ## Java类加载器分类： ### 1.系统提供的类加载器 - **Bootstrap ClassLoader(启动类加载器)**：由C/C++实现的加载器，用于加载虚拟机运行时所需要的系统类，如`java.lang.*、java.uti.*`等系统类。它负责将存放在\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。 这个加载器由于是C实现的，所以无法被Java程序直接引用。并且不继承`java.lang.ClassLoader`。 - **Extension ClassLoader(扩展类加载器)**：这个加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载\lib\ext目录中的，或者被`javax.ext.dirs`系统变量所指定的路径中的所有类库。 - **Application ClassLoader(应用程序类加载器)**：这个加载器由sun.misc.Launcher$AppClassLoader实现。可以加载用户类路径上的指定类库，通过`ClassLoader.getSystemClassLoader()`方式获取，没有定义过自己的类加载器，则默认是这个。 - **Custom ClassLoader(自定义加载器)**：通过集成`java.lang.ClassLoader`来实现自己的加载器。 - {% fullimage /images/jvm/parent_loader.png, alt,双亲委派模型 %} ### 2.双亲委托模型 - 工作流程：如果一个类加载器收到了类加载的请求，不会自己去尝试加载这个类，而把这个请求委派给父类加载器去完成，每一层都是如此，依次向上递归，直到委托到最顶层的`Bootstrap ClassLoader`，若父加载器无法处理加载请求（它的搜索范围内没有找到所需的类时），则交由子加载器去加载。 > 简单流程介绍 > > 1. 自定义类加载器先从缓存中查看Class文件是否被加载，如果加载则返回Class，没有加载则委托给父类加载 > 2. 一直委托到`Bootstrap ClassLoader`,在`Bootstrap ClassLoader`没有找到Class文件，则在自己的规定路径\lib或者-Xbootclasspath选项指定路径的jar包进行查询，找到则返回Class，没有就交由子加载器去加载。 > 3. 最后交由我们自定义的类加载器去加载，还找不到则抛出`ClassNotFoundException`异常。 - 代码模型实现： ```java protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 检查请求的类是否已被加载过 Class c = findLoadedClass(name); //对应的类已被加载则不会往下进行 if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { //父加载器不为null，调用父加载器的load方法 c = parent.loadClass(name, false); } else { //父加载器为null，则调用系统的BootstrapClassLoader c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader //父类加载器无法加载则抛出ClassNotFoundException异常 } if (c == null) { // If still not found, then invoke findClass in order // to find the class. //父类加载器无法加载则调用本身的findClass()方法去加载 long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } ``` - 好处： - 避免重复加载，若该Class已加载则从缓存中直接读取 - 更加安全，例如`java.lang.Object`，无论哪一个类加载器去加载这个类，最终都会委派给Bootstrap ClassLoader去进行加载，所以我们自定义的Object类并不会被加载而导致系统中出现多个Object类。 ### 3.破坏双亲委托模型 双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载实现方式。 - 在JDK1.2发布之前，还没有双亲委托机制 - 由模型自身缺陷所导致的 - 用户对于程序动态性导致的，例如代码热替换，模块热部署 ### 4.自定义ClassLoader - 自定义需要加载的类 ```java public class Jobs { public void say() { System.err.println("自定义加载器加载"); } } ``` 自定义完成后需调用`javac Jobs.java`去生成对应的`Jobs.class`文件以用来加载。 - 实现自定义的ClassLoader ```java import java.io.*; public class DiskClassLoader extends ClassLoader { private String path; public DiskClassLoader(String path) { this.path = path; } @Override protected Class findClass(String name) throws ClassNotFoundException { Class clazz = null; byte[] classData = loadClassData(name); if (classData == null) { throw new ClassNotFoundException(); } else { //用来将获取的字节码数组转为class的实例 clazz = defineClass(name, classData, 0, classData.length); } return clazz; } /** * 获得class文件的字节码数组 * @param name * @return */ private byte[] loadClassData(String name) { String fileName = getFileName(name); File file = new File(path, fileName); System.err.println(fileName); InputStream inputStream = null; ByteArrayOutputStream byteArrayOutputStream = null; try { inputStream = new FileInputStream(file); byteArrayOutputStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int length = 0; while ((length = inputStream.read(buffer)) != -1) { byteArrayOutputStream.write(buffer, 0, length); } return byteArrayOutputStream.toByteArray(); } catch (IOException e) { e.printStackTrace(); } finally { //读取流后需要关闭，以免造成内存泄露 try { if (inputStream != null) { inputStream.close(); } } catch (IOException e) { e.printStackTrace(); } try { if (byteArrayOutputStream != null) { byteArrayOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } return null; } private String getFileName(String name) { int index = name.indexOf('.'); if (index == -1) { return name + ".class"; } else { return name.substring(index + 1) + ".class"; } } } ``` 自定义的ClassLoader需要读取对应Class的字节流数组，以便产生实例。注意不要忘记对流的关闭。 - 使用自定义的ClassLoader去加载类 ```java import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class CustomClassLoaderTest{ public static void main(String[] args) { DiskClassLoader diskClassLoader = new DiskClassLoader("需要加载的class的地址"); try { //对class文件进行加载 Class c = diskClassLoader.loadClass("Jobs"); if (c != null) { try { Object object = c.newInstance(); System.err.println(object.getClass().getClassLoader()); Method method = c.getDeclaredMethod("say", null); method.invoke(object, null); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } ``` 在对应的文件夹下是否已存在Jobs.java文件： - ```java //存在要加载的Java文件 sun.misc.Launcher$AppClassLoader@18b4aac2 自定义加载器加载 ``` - ```java //不存在对应的Java文件 DiskClassLoader@d716361 自定义加载器加载 ``` ​ 以上就为自定义ClassLoader的基本步骤，也是热修复框架中ClassLoader的雏形。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XIV]]></title>
    <url>%2F2018%2F04%2F16%2FAndroid-Study-Plan-XIV%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XIV date: 2018-04-16 13:07:50 tags: Android --- # Android学习计划 ##用过RxJava和RxAndroid吗？RxAndroid切换线程是怎么实现的？]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC,MVP,MVVM的理解]]></title>
    <url>%2F2018%2F04%2F15%2FMVC-MVP-MVVM%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[--- title: MVC,MVP,MVVM的理解 date: 2018-04-15 14:58:03 tags: 设计模式 --- # 1.MVC模式 MVC(Model-View-Controller，模型-视图-控制器)是20世纪80年代出现的一种设计模式。他用一种业务逻辑、数据、界面显示分离的方法组织代码。在Android中MVC的角色定义如下： - Model(模型层)：针对业务模型，建立的数据结构和相关的类，就可以理解为Model。与View无关，与业务相关。 - View(视图层)：一般采用XML文件或者Java代码进行界面的描述。 - Controller(控制器)：Android的控制层一般在Activity，Fragment中或者在由他们控制的其他业务类中。 {% fullimage /images/pattern/mvc_pattern.png, MVC,MVC %} 缺点： - 在Android开发中，Activity不是一个标准的Controller，首要职责为加载应用的布局和初始化界面，并接受用户的请求。随着界面以及代码逻辑的复杂，Activity会越来越庞大。 - view层和model层是相互感知的，意味之间存在很大的耦合。 # 2.MVP模式 MVP(Model-View-Presenter)是MVC的演化版本，对于Android来说，Model层和MVC模式是一种概念，activity或者fragment对应的就是View层，所有用户相关事件处理由Presenter处理。 - Model：主要提供数据的存取功能。 - View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件 - Presenter：作为View和Model沟通的桥梁，从Model层检索数据并返回给View层，使得View和Model层完全解耦。Presenter与View可以通过接口来实现通信，只要View层去实现定义好的接口。 {% fullimage /images/pattern/mvp_pattern.png, MVP,MVP %} 缺点： - View层和Presenter层会交互过于频繁，若Presenter过多的渲染了View，往往导致过于紧密，若View发生改动，Presenter也要发生变更。 # 3.MVVM模式 MVVM(Model-View-ViewModel)是2015由微软提出的一个UI架构概念。将Presenter改为ViewModel，同时实现View和ViewModel的双向绑定（View的变动，自动反映在ViewModel，反之亦然）。 - Model：主要提供数据的存储过程 - View：负责处理用户事件和视图部分的展示。在Android中可能是Activity、fragment或者View组件 - ViewModel：功能和Presenter类似，与View和Model双向绑定 {% fullimage /images/pattern/mvvm_pattern.png, MVC,MVC %} 优点： - 低耦合。View可以独立于Model变化和修改，ViewModel可以绑定不同的View - 可重用性。把许多的试图逻辑处理放在一个ViewModel中，许多View可以使用该ViewModel - 独立开发。开发人员可以专注于逻辑和数据的处理 - 可测试性。可以直接针对ViewModel进行单独测试。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程保活介绍]]></title>
    <url>%2F2018%2F04%2F12%2F%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[--- title: 进程保活介绍 date: 2018-04-12 20:26:08 tags: Android top: 10 --- # 进程保活 进程保活的方式分为两个层面：`提高进程优先级，降低被杀死的概率`,`在进程被杀死后，进行拉活`。 ## 1. 进程的优先级 {% fullimage /images/study_plan/process_level.webp, alt,进程优先级 %} {% post_link 日常细节记录 %} ## 2. Android进程回收策略 对于进程的回收，依靠LowmemoryKiller完成，按照OOM_ADJ的阈值级别触发对应的内存回收。 {% fullimage /images/study_plan/oom_adj.webp, alt,流程图 %} 红色代表易被杀死的进程，绿色不易被杀死。LowmemoryKiller会优先杀死OOM_ADJ较大的进程，优先级相同则进一步受到进程所占内存和进程存活时间的影响。 ## 3. 提升进程优先级 - **利用Activity提升权限**：`监控手机锁屏解锁事件，在屏幕锁定时启动一个一像素的Activity，解锁时销毁。`**需把Activity设置成用户无感知** - **利用Notification提升权限**：`Service的优先级为4，使用setForeground可以设置前台Service，提升进程的优先级，降低被杀的概率。` - **注意点**：设置为前台Service时，在通知栏会显示一条通知。 - **应对措施**：可以去实现一个内部Service，在LiveService和其内部Service中同时发送相同ID的Notification，然后结束内部Service。内部Service被结束时，Notification也会消失，但是进程的优先级不会发生变化。 ## 4. 进程死后拉活的方案 - **利用系统广播拉活**：在发生特定事件是，系统会发送相应的广播，可以在AndroidManifest中静态注册对应的广播监听器，即可在对应事件发生时拉活应用。以下是常见的拉活广播事件： - 开机广播：RECEIVE_BOOT_COMPLETED - 网络变化：CHANGE_NETWORK_STATE,CHANGE_WIFI_STATE… - 文件挂载：MOUNT_UNMOUNT_FILESYSTEMS - 屏幕亮灭：SCREEN_ON,SCREEN_OFF - 锁屏解锁：RECEIVE_USER_PRESENT - 应用安装卸载：PACKAGE_ADDED,PACKAGE_REMOVED 缺点： - 广播接收器容易被系统的管理软件通过“自启管理”禁用场景，从而无法处理 - 系统广播事件不可控，只能保证有对应事件是拉活进程，但不能保证能否立即拉活。 - **利用第三方应用广播拉活**：该方案接受第三方应用的广播，反编译一些第三方应用，找到他们发送的广播，在自己应用内进行监听，当这些应用发送广播时，即可拉活自己的应用。 缺点： - 需要反编译较多应用来确保效果 - 第三方应用的广播可能会在日后更新中修改或删除 - **利用系统Service机制拉活**：把Service设置为`START_STICKY`，这个参数可以在Service被杀死后，利用系统机制尝试拉活。 缺点： - Service第一次被异常杀死后会在5秒内重启，第二层被杀死10秒内重启，第三次会在20秒内重启，一旦被杀死达到5次，则系统不会再重新拉活。 - 进程被Root权限的工具杀死活forcestop，无法重启。 - **利用Native进程拉活**：利用Linux中的fork机制创建Native进程，在Native进程中监控主进程的存活，当主进程挂掉后，在Native进程中立即对主进程拉活。（该进程的生命周期不受Android的管理）。 适用范围： - 在Android5.0以下版本手机效果很好，不受forcestop影响 - 在5.0以上的手机，Native进场也会被forcestop杀死，假如逻辑跑的比系统快，依然可以拉活。 - **利用JobScheduler机制拉活**：系统在Android5.0以上版本提供了JobScheduler接口，系统会定时调用该进程使应用处理一些操作。 适用范围：Android5.0以上系统手机，在部分小米手机可能无法拉活。 ```java @TargetApi(Build.VERSION_CODES.LOLLIPOP) public class KeepLiveService extends JobService { private final static String TAG="KeepLive"; private volatile static Service mKeepLiveService= null; @Override public boolean onStartJob(JobParameters jobParameters) { return false; } @Override public boolean onStopJob(JobParameters jobParameters) { return false; } } ``` ```java public void startJobscheduler(){ try { int jobId=1; JobInfo.Builder builder=new JobInfo.Builder(jobId, new ComponentName(MyApplication.getApplicationContext(), KeepLiveService.class)); builder.setPeriodic(10);//设置时间间隔 builder.setPersisted(true);//重启后需要继续执行 JobScheduler js = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); js.schedule(builder.build()); }catch (Throwable e){ e.printStackTrace(); } } ``` - **利用账号同步进制拉活**：Android系统的账号同步进制会定期同步执行，可以利用同步机制进行进程的拉活。 适用范围：适用于所有的Android版本，在Android N中进行了一些变动，该方案失效。 - **其他方案**： - 利用系统通知权限进行拉活 - 利用辅助功能拉活，将应用加入厂商白名单 - 利用推送进行拉活（如小米、华为推送）]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展(二)]]></title>
    <url>%2F2018%2F04%2F12%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展(二) date: 2018-04-12 12:40:07 tags: JVM top: 11 --- # 虚拟机类加载机制 ## 1.定义 `虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。` ## 2.类的生命周期 类从被加载到虚拟机内存中开始，到卸载除内存为止，生命周期包括：**加载(Loading)**、**验证(Verification)**、**准备(Preparation)**、**解析(Resolution)**、**初始化(Initialization)**、**使用(Using)**、**卸载(Unloading)**。其中`验证`、`准备`、`解析`统称为**连接(Linking)** {% fullimage /images/jvm/class_lifecycle.png, 类的生命周期,类的生命周期 %} 加载、验证、准备、初始化和卸载阶段执行顺序为确定的，类的加载过程必须按照这个顺序开始。解析阶段不一定：在某些情况下可以在初始化阶段之后开始，为了支持Java语言的运行时绑定。 初始化阶段，虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”： - 遇到`new ,getstatic,putstatic或invokestatic`指令时，类没有进行初始化，则需要先触发初始化。最常见的Java代码场景：使用new关键字实例化对象、读取或设置一个类的静态字段、调用一个类的静态方法。 - 使用`java.lang.reflect`进行反射调用的时候。 - 初始化一个类时，发现父类还没有初始化，先触发父类初始化方法。 - 虚拟机启动时，用户指定一个要执行的主类(包含`main()`方法的类)，先初始化该类。 - 使用动态语言支持时，若`java.lang.invoke,MethodHandle`实例最后解析结果为`REF_getStatic,REF_putStatic,REF_invokeStatic`的方法句柄，并且该类没有进行初始化。 ## 3.类加载的过程 - **加载** 虚拟机需要完成以下3件事情： 1. 通过一个类的全限定名来获取定义此类的二进制字节流 2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口 - **验证**（若代码被反复验证和使用过，可以使用`-Xverify:none`来关闭大部分的类验证措施，缩短虚拟机加载时间） 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致需要完成以下4个阶段的检验动作： 1. 文件格式验证 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 `主要目的是保证输入的字节流能正确的解析并存储于方法区之内，格式上符合描述一个Java类信息的要求。在这个阶段字节流进入内存中的方法区后续不再操作字节流。` 2. 元数据验证 对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范 3. 字节码验证 通过数据流和控制流分析，确定程序语义是合法且符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机的安全的事件。 4. 符号引用验证 发生在虚拟机将符号引用转化为直接引用的时候，这个转化发生在解析阶段。对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验。`确保解析动作能正常执行` - **准备** 准备阶段是正式为变量分配内存并设置类初始变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个时候进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量。 初始值`通常情况`下是数据类型的零值，如 ```java public static int value = 123;//在准备阶段过程中初始值为0，而不是123。 ``` `特殊情况`：若类字段的属性表中有ConstantValue属性，那么准备阶段value就会初始化为ConstantValue指定的值，如 ```java public static final int value = 123;//在准备阶段过程中初始值为123。 ``` - **解析** 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析阶段中会涉及到`直接引用`(直接指向目标的指针、相对偏移量或者是一个能直接定位到目标的句柄)，`符号引用`(以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可)。 解析动作主要针对`类或接口（CONSTANT_Class_info）`、`字段（CONSTANT_Fieldref_info）`、`类方法（CONSTANT_Methodref_info）`、`接口方法（CONSTANT_InterfaceMethodref_info）`、`方法类型（CONSTANT_MethodType_info）`、`方法句柄（CONSTANT_MethodHandle_info）`、`调用点限定符（CONSTANT_InvokeDynamic_info）`。 - **初始化** 初始化是类加载过程的最后一步。到这里才真正开始执行类中定义的Java程序代码。 执行类构造器`()`方法的过程。 - `()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。 - `()`方法与类的构造函数不同，他不需要显示的调用父类构造器，因此虚拟中第一个被执行的`()`方法的类肯定是`java.long.object`。 - **初始化过程就是对变量进行赋值及执行静态代码块。**]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关及其拓展（一）]]></title>
    <url>%2F2018%2F04%2F10%2FJVM%E7%9B%B8%E5%85%B3%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[--- title: JVM相关及其拓展（一） date: 2018-04-10 15:22:34 tags: JVM top: 11 --- # 1. JVM内存区域 {% fullimage /images/jvm/jvm_data.png, JVM运行时数据区,JVM运行时数据区 %} JVM在执行Java程序的过程中会把管理的内存分为若干个数据局域。 - **程序计数器(Program Counter Register)**：一块较小的内存空间，可看作为当前线程所执行的字节码的行号指示器。每条线程都需要一个独立的程序计数器，所以为线程私有区域。`没有规定任何OutOfMemoryError情况的区域`。`线程执行Java方法，则记录正在执行的虚拟机字节码指令地址，若为Native方法，则计数器值则为Undefined` - **Java虚拟机栈(VM Stack)**：虚拟机栈是线程私有的，生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表(存放编译器可知的各种基本数据类型`boolean,byte,char,int,long,float,double,short`,对象引用和returnAddress类型)，操作树栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。这个区域存在两种异常情况：`StackOverflowError：请求栈深度大于虚拟机所允许的深度`，`OutOfMemoryError：无法申请到足够的内存` - **本地方法栈(Native Method Stack)**：虚拟机执行Native方法的服务，和虚拟机栈类似存在两个异常情况。 - **Java堆(Heap)**：JVM管理内存中最大的一块。是被所有线程共享的一块区域，在虚拟机启动时创建。唯一目的`存放对象实例`，几乎所有对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为”GC堆”。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，则抛出OutOfMemoryError异常。 - **方法区(Method Area)**：方法区与Java堆一样，是各个线程共享的内存区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。同Java堆一样会抛出OutOfMemoryError异常。 - **运行时常量池(Runtime Constant Pool)**：运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一个是常量池（存放编译器生成的各种字面量和符号引用）。有一个重要特征是具有动态性，运行期也可以将新的常量放入池中。受到方法区内存的限制，也会抛出OutOfMemoryError异常。 - **直接内存(Direct Memory)**：不属于虚拟机运行时数据区的一部分。 > 拓展： - 程序计数器，虚拟机栈，本地方法栈随着线程生命周期变化，生则生，死则死。 - 程序计数器，虚拟机栈，本地方法栈不需要过多考虑内存回收问题，随着方法结束或者线程结束时，内存随着就会回收。 # 2.HotSpot虚拟机对象创建，布局以及访问 ## 对象的创建 在语言层面上，创建对象只需要一个`new`关键字。 在虚拟机中，分为以下几步： - **遇到一条new指令时，先去检查指令对应参数是否在常量池中可以定位到一个符号的引用，并且检查指令的参数是否已被加载、解析和初始化过。若无则需要执行相应的类加载过程。** - **类加载检查通过后，将为新生对象分配内存。**对象所需的内存大小在类加载完成后便可确定，这块内存由Java堆中划分出来。内存的分配方式由Java堆中内存是否规整决定（`已使用的内存和空闲内存是否相互交错`）。规整则使用 **指针碰撞**（`把指针向空闲空间挪动对象大小的距离`），不规整则使用**空闲列表**（`虚拟机内维护一个列表用来记录内存块中的可用区域，然后找到一块足够大的空间划分给对象实例`）。 - **处理并发安全问题。**除了如何分配内存，还需要考虑虚拟机中对象创建是非常频繁的行为，就会涉及到线程安全。解决这个问题有两种方案： - 对分配内存空间的行为进行同步处理 - 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为`本地线程分配缓存(TLAB)`。哪个线程需要分配内存就在哪个TLAB上分配，只有TLAB用完了，才同步申请另一块内存。 - **内存分配完成后，虚拟机将需要分配到的内存空间都初始化为零值（不包括对象头）。**这一步操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 - **虚拟机对对象进行设置，将`类的元数据信息、对象的哈希码、对象的GC分代年龄信息`存入对象头中。** - **执行init方法初始化。**从虚拟机角度来说，对象已经产生完成，从Java方面来说才刚刚开始，要等到new指令执行并\方法执行后，把对象按照意愿初始化后，真正可用的对象生成完毕。 ## 对象的内存布局 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：`对象头(Header)`、`实例数据(Instance Data)`和`对齐填充(Padding)` ### 对象头 **存储自身的运行时数据** | 存储内容 | 标志位 | 状态 | |---|---|---| | 对象哈希码、对象分代年龄 | 01 | 未锁定 | | 指向锁记录的指针 | 00 | 轻量级锁定 | | 指向重量级锁的指针 | 10 | 膨胀 | | 空，不需要记录信息 | 11 | GC标记 | | 偏向线程ID，偏向时间戳，对象分代年龄 | 01 | 可偏向 | **类型指针** 对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象为一个Java数组，则对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。 ### 实例数据 里面是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。在分配策略中，相同宽度的字段总是会被分配在一起。 ### 对齐填充 并非必然存在的，也没有特别的含义。仅仅起着占位符的作用。当实例数据部分没有对齐时，需要对齐填充来补全。 ## 对象的访问 Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式是`句柄访问`和`直接指针访问`。 - 使用句柄访问：Java堆中会划分出一块内存来作为句柄池，`refrence中存储的对象就是对象的句柄地址`，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 **句柄访问的最大好处是refrence中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，refrence本身不会有修改。** {% fullimage /images/jvm/get_object_by_handle.png, alt,流程图 %} - 使用直接指针访问：Java堆对象需要考虑如何放置访问类型数据的相关信息，而`refrence中存储的直接就是对象地址`。 **直接访问的最大好处是速度快，节省了一次指针定位的时间开销，在Java HotSpot虚拟机中很常用。** {% fullimage /images/jvm/get_object_direct.png, alt,流程图 %}]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--静态代理模式和动态代理模式原理及实现]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[--- title: 设计模式--静态代理模式和动态代理模式原理及实现 date: 2018-04-09 21:40:32 tags: 设计模式 top: 10 --- # 代理模式（委托模式） > **为其他对象提供一种代理以控制对这个对象的访问**。引入**代理对象**来间接访问**目标对象** {% fullimage /images/Pattern-Proxy.png,代理模式,代理模式 %} 代理模式优点： - 职责清晰：真实的角色就是实现实际的业务逻辑，不需关心其他非本职责的事务 - 高扩展性：代理类可以在不做任何修改的情况下继续使用 - 智能化：动态代理演示 代理模式缺点： 1. 在客户端和真实对象之间添加了代理，会造成请求的处理速度变慢 2. 实现代理模式比较复杂，需要额外的工作 代理模式的扩展： 1. 普通代理 > 客户端只能访问代理角色，而不能直接访问真实角色。 ```java public class Client { public static void main(String[] args){ //屏蔽了GamePlayer的真实角色访问 GamePlayerProxy gamePlayerProxy = new GamePlayerProxy("wxy"); gamePlayerProxy.login("wxy","124"); gamePlayerProxy.killBoss(); gamePlayerProxy.upgrade(); } } ``` Client只是调用了`GamePlayerProxy`代理角色，而不知道真实角色是谁。**非常适合扩展性要求较高的场景。** 2. 强制代理 > 通过真实角色来找到代理角色，否则不能访问。**由真实角色来管理代理角色。不允许直接访问真实角色** ```java public class Client { public static void main(String[] args){ //必须是真实角色的代理对象才可以使用 IGamePlayer gamePlayerProxy = new GamePlayer("wxy").getProxy(); //直接生成代理对象无效 //GamePlayerProxy gamePlayerProxy = new GamePlayerProxy(new GamePlayer("wzr5")); gamePlayerProxy.login("wxy","124"); gamePlayerProxy.killBoss(); gamePlayerProxy.upgrade(); } } ``` 3. 代理是有个性的 > 一个类可以实现多个接口，完成不同任务的整合。**代理类不仅可以实现主题接口，也可以实现其他接口完成不同的任务。** 4. **动态代理** > 不需要**显式实现与目标对象类相同的接口**，将这种实现推迟到程序运行时由JVM实现。 原理：通过Java反射机制的`method.invoke()`调用动态代理类对象方法，从而自动调用目标对象的方法。 优点：1. 只需要一个代理类就可以解决创建多个静态代理的问题，避免重复代码。2. 更加灵活 缺点：1. 效率低 `需要通过反射机制，间接调用目标对象方法` 2.应用场景局限`只能针对接口创建代理类，即只能动态代理实现了接口的类` 应用场景： - 需要代理对象数量较多的情况下使用 - `AOP`-面向切面编程 > 可以通过预编译的方式在运行期动态代理实现程序功能的统一维护，有效降低业务之间的耦合度，提供程序的可用性并提高了开发的效率。开发中主要用在日志收集，性能分析等。 使用方法： 1. 声明调用代理类 ```java public class GamePlayIH implements InvocationHandler { //被代理实例 T obj ; public GamePlayIH(T _obj) { this.obj = _obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = method.invoke(this.obj, args); return result; } } ``` 2. 声明目标对象类的抽象接口 ```java public interface IGamePlayer { void login(String user, String pwd); void killBoss(); void upgrade(); } ``` 3. 声明目标对象类 ``` public class GamePlayer implements IGamePlayer { private String name = ""; public GamePlayer(String _name) { this.name = _name; } @Override public void login(String user, String pwd) { System.err.println("登录名为：" + user + " 用户名为：" + this.name + "登录游戏"); } @Override public void killBoss() { System.err.println(this.name + "打Boss"); } @Override public void upgrade() { System.err.println(this.name + "升级了"); } } ``` 4. 通过动态代理对象，调用目标方法 ```java public class Client { public static void main(String[] args) { //创建目标对象 IGamePlayer player = new GamePlayer("wxy"); //创建调用处理对象 InvocationHandler handler = new GamePlayIH(player); //指定产生代理对象的类加载器 ClassLoader cl = player.getClass().getClassLoader(); //创建动态代理对象 IGamePlayer gamePlayerProxy = (IGamePlayer) Proxy.newProxyInstance(cl, new Class[]{IGamePlayer.class}, handler); //调用动态代理对象方法 gamePlayerProxy.login("wxy", "124"); gamePlayerProxy.killBoss(); gamePlayerProxy.upgrade(); } } ```]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android触摸事件分发]]></title>
    <url>%2F2018%2F04%2F09%2FAndroid%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[--- title: Android触摸事件分发 date: 2018-04-09 21:40:14 tags: Android --- # 1.触摸事件的类型 对应的类是`MotionEvent`，主要有以下三个类型： - **ACTION_DOWN**：监听用户手指按下的操作，一次按下标志触摸事件的开始。 - **ACTION_MOVE**：用户按压屏幕后，在抬起之前，如果移动的距离超过一定数值，就判定为移动事件。 - **ACTION_UP**：监听用户手指离开屏幕的操作，一次抬起标志触摸事件的结束。 - **ACTION_CANCEL**：当用户保持按下操作，并把手指移动到了控件外部局域时且父View处理事件触发。 # 2.事件传递的三个阶段 - **分发（Dispatch）**：事件的分发对应着`dispatchTouchEvent`方法，所有触摸事件由这个方法进行分发 ```java public boolean dispatchTouchEvent(MotionEvent ev) ``` 在这个方法中，根据当前视图的需求来进行事件的分发给子视图还是直接消费不往下传递，返回`true`表示事件被消费，不往下传递。返回值为`super.dispatchTouchEvent`表示继续往下传递。 - **拦截（Intercept）**:事件的拦截对应着`onInterceptTouchEvent`方法，这个事件只在ViewGroup及其子类中存在。 ```java public boolean onInterceptTouchEvent(MotionEvent ev) ``` 根据具体的逻辑，返回`true`表示拦截该事件，不继续把事件分发给子视图，交由自身的`onTouchEvent`进行处理，返回值为`false或super.onInterceptTouchEvent`表示继续往下传递。 - **消费（Consume）**：事件的消费对应着`onTouchEvent`方法 ```java public boolean onTouchEvent(MotionEvent ev) ``` 返回值为`true`时，表示当前视图可以处理事件，不会向上传递给父视图；返回值为`false`表示当前视图不处理这个事件，事件传递给父视图的`onTouchevent`进行处理。 > 在Android系统中，可以处理事件传递的类有以下三种： > > - **Activity**：包含`dispatchTouchEvent`，`onTouchEvent`方法 > - **ViewGroup**：包含`dispatchTouchEvent`，`onInterceptTouchEvent`，`onTouchEvent` > - **View**：包含`dispatchTouchEvent`，`onTouchEvent`方法 # 3.View的事件传递机制 View包括TextView，ImageView等子类，不包括ViewGroup。 ```java /** * Custom TextView with touchevent */ public class MyTextView extends AppCompatTextView { public static final String TAG="MyTextView"; ... @Override public boolean dispatchTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"dispatchTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL"); break; } return super.dispatchTouchEvent(event);② } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"onTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onTouchEvent_ACTION_CANCEL"); break; } return super.onTouchEvent(event);④ } } ``` ```java public class MainActivity extends AppCompatActivity { public static final String TAG="MainActivity"; MyTextView mtv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mtv= (MyTextView) findViewById(R.id.mtv); mtv.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Log.e(TAG,"MyTextView_onclick"); } }); mtv.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View view, MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"MyTextView_onTouch_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"MyTextView_onTouch_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"MyTextView_onTouch_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"MyTextView_onTouch_ACTION_CANCEL"); break; } return false;③ } }); } @Override public void onUserInteraction() { super.onUserInteraction(); Log.e(TAG,"onUserInteraction"); } @Override public boolean dispatchTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"dispatchTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL"); break; } return super.dispatchTouchEvent(event);① } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"onTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onTouchEvent_ACTION_CANCEL"); break; } return super.onTouchEvent(event); } } ``` - 常规输出：(返回的都为默认值) - 点击MyTextView区域 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MyTextView: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyTextView: dispatchTouchEvent_ACTION_UP E/MainActivity: MyTextView_onTouch_ACTION_UP E/MyTextView: onTouchEvent_ACTION_UP E/MainActivity: MyTextView_onclick ``` - 点击MyTextView外部区域 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MainActivity: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_MOVE E/MainActivity: onTouchEvent_ACTION_MOVE E/MainActivity: dispatchTouchEvent_ACTION_UP E/MainActivity: onTouchEvent_ACTION_UP ``` - ① **Activity的dispatchTouchEvent()**`return true;或return false;` ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_MOVE E/MainActivity: dispatchTouchEvent_ACTION_MOVE E/MainActivity: dispatchTouchEvent_ACTION_UP ``` > 不会再继续分发触摸事件，及后续控件的触摸事件都不会响应。 - ② **View的dispatchTouchEvent()**`return true;`不会调用MyTextView的`onClick`事件 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MyTextView: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyTextView: dispatchTouchEvent_ACTION_UP E/MainActivity: MyTextView_onTouch_ACTION_UP E/MyTextView: onTouchEvent_ACTION_UP ``` **View的dispatchTouchEvent()**`return false;`只响应MyTextView的`ACTION_DOWN`事件，后续的处理由MainActivity的`onTouchEvent`执行 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_MOVE E/MainActivity: onTouchEvent_ACTION_MOVE E/MainActivity: dispatchTouchEvent_ACTION_UP E/MainActivity: onTouchEvent_ACTION_UP ``` - ③**Activity中View的onTouch()**`return true;`不往下分发事件及不会调用到`onClick`事件 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyTextView: dispatchTouchEvent_ACTION_UP E/MainActivity: MyTextView_onTouch_ACTION_UP ``` - ④ **View的onTouchEvent()**`return true;`不触发`onClick`事件 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MyTextView: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyTextView: dispatchTouchEvent_ACTION_UP E/MainActivity: MyTextView_onTouch_ACTION_UP E/MyTextView: onTouchEvent_ACTION_UP ``` **View的onTouchEvent()**`return false;`只响应MyTextView的`ACTION_DOWN`事件，后续的处理由MainActivity的`onTouchEvent`执行 ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MyTextView: onTouchEvent_ACTION_DOWN E/MainActivity: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MainActivity: onTouchEvent_ACTION_UP ``` {% fullimage /images/study_plan/Activity-View dispatch.png, View的事件传递,View的事件传递 %} > 总结： > > - 触摸事件传递从dispatchTouchEvent开始，在不修改默认返回的数值时，事件会按照嵌套层次由外向内传递，到达最内层的View时，就由它的onTouchEvent处理。 > > - 若事件在传递过程中，返回参数设为true，则导致事件提前被消费，内层View无法处理事件 > > - View的事件触发顺序为先执行onTouch方法，最后执行onClick方法。onTouch返回false，则会响应onClick，否则事件不会继续传递。 > > - View的点击事件流程： > > **Activity.dispatchTouchEvent() -> View.dispatchTouchEvent()->View.onTouch()->View.onTouchEvent()->View.onClick()** # 4.ViewGroup事件传递机制 ViewGroup作为View的容器存在，ViewGroup包括LinearLayout，RelativeLayout等。 ```java /** * Custom ViewGroup with touchEvent */ public class MyRelativeLayout extends RelativeLayout { public static final String TAG="MyRelativeLayout"; public MyRelativeLayout(Context context) { super(context); } public MyRelativeLayout(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean dispatchTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"dispatchTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"dispatchTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"dispatchTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"dispatchTouchEvent_ACTION_CANCEL"); break; } return super.dispatchTouchEvent(event); } @Override public boolean onInterceptTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"onInterceptTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onInterceptTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onInterceptTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onInterceptTouchEvent_ACTION_CANCEL"); break; } return super.onInterceptTouchEvent(event);⑥ } @Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: Log.e(TAG,"onTouchEvent_ACTION_DOWN"); break; case MotionEvent.ACTION_UP: Log.e(TAG,"onTouchEvent_ACTION_UP"); break; case MotionEvent.ACTION_MOVE: Log.e(TAG,"onTouchEvent_ACTION_MOVE"); break; case MotionEvent.ACTION_CANCEL: Log.e(TAG,"onTouchEvent_ACTION_CANCEL"); break; } return super.onTouchEvent(event); } } ``` - 常规模式（全为默认值） ```log E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWN E/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWN E/MyTextView: dispatchTouchEvent_ACTION_DOWN E/MainActivity: MyTextView_onTouch_ACTION_DOWN E/MyTextView: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyRelativeLayout: dispatchTouchEvent_ACTION_UP E/MyRelativeLayout: onInterceptTouchEvent_ACTION_UP E/MyTextView: dispatchTouchEvent_ACTION_UP E/MainActivity: MyTextView_onTouch_ACTION_UP E/MyTextView: onTouchEvent_ACTION_UP E/MainActivity: MyTextView_onclick ``` - ViewGroup.onInterceptTouchEvent()返回true ```java E/MainActivity: dispatchTouchEvent_ACTION_DOWN E/MyRelativeLayout: dispatchTouchEvent_ACTION_DOWN E/MyRelativeLayout: onInterceptTouchEvent_ACTION_DOWN E/MainActivity: MyRelativeLayoutonTouch_ACTION_DOWN E/MyRelativeLayout: onTouchEvent_ACTION_DOWN E/MainActivity: dispatchTouchEvent_ACTION_UP E/MyRelativeLayout: dispatchTouchEvent_ACTION_UP E/MainActivity: MyRelativeLayout_onTouch_ACTION_UP E/MyRelativeLayout: onTouchEvent_ACTION_UP ``` {% fullimage /images/study_plan/Activity-ViewGroup-View dispatch.png, View的事件传递,View的事件传递 %} > 总结: > > - 对于一个包裹在ViewGroup中的View，点击发生的触摸流程为： > > **Activity.dispatchTouchEvent()->ViewGroup.dispatchTouchEvent()->ViewGroup.onInterceptTouchEvent()->View.dispatchTouchEvent()->View.onTouch()->View.onTouchEvent()->View.onClick()** > > - dispatchTouchEvent事件分发逻辑如下： > > 如果 return true，事件会分发给当前 View 并由 dispatchTouchEvent 方法进行消费，同时事件会停止向下传递； > 如果 return false，事件分发分为两种情况： > 1.如果当前 View 获取的事件直接来自 Activity，则会将事件返回给 Activity 的 onTouchEvent 进行消费； > 2.如果当前 View 获取的事件来自外层父控件，则会将事件返回给父 View 的 onTouchEvent 进行消费。 > > - onInterceptTouchEvent 的事件拦截逻辑如下： > 如果 onInterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理； > 如果 onInterceptTouchEvent 返回 false或super.onInterceptTouchEvent(ev)，则表示将事件放行，当前 View 上的事件会被传递到子 View 上，再由子 View 的 dispatchTouchEvent 来开始这个事件的分发； > - onTouchEvent 的事件响应逻辑如下： > 如果事件传递到当前 View 的 onTouchEvent 方法，而该方法返回了 false，那么这个事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，如果传递到上面的 onTouchEvent 也返回 false，这个事件就会“消失”，而且接收不到下一次事件。 > 如果返回了 true 则会接收并消费该事件。 > 如果返回 super.onTouchEvent(ev) 默认处理事件的逻辑和返回 false 时相同。 # 5.源码分析 //TODO # 6.实例分析]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热修复基本原理]]></title>
    <url>%2F2018%2F04%2F07%2F%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[--- title: 热修复基本原理 date: 2018-04-07 13:11:03 tags: Android ---]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle操作小记]]></title>
    <url>%2F2018%2F04%2F03%2FGradle%E6%93%8D%E4%BD%9C%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[--- title: Gradle操作小记 date: 2018-04-03 16:24:22 tags: Gradle --- > 显示所有依赖关系解析树 ```gradle ./gradlew app:dependencies ``` > 生成项目 ```gradle ./gradlew clean assembleEnvTestReleaseChannels -PchannelList=default ``` > 清理项目 ```groovy ./gradlew clean ```]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XIII -- JVM垃圾回收]]></title>
    <url>%2F2018%2F04%2F03%2FAndroid-Study-Plan-XIII%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XIII -- JVM垃圾回收 date: 2018-04-03 15:43:20 tags: Android --- # Android学习计划 ## 简单描述下jvm的垃圾回收策略，比如引用计数、标记清除等策略 {% post_link JVM相关及其拓展-四 %}]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常细节记录]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%97%A5%E5%B8%B8%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[--- title: 日常细节记录 date: 2018-04-03 13:04:15 tags: - Android - Java top: 11 --- 1. 强引用置为null时，不会立即回收对象，帮助回收器加快回收。但是会帮助GC 等到下次回收周期时即会回收 2. 死锁的四个必要条件：互斥，占有且等待，不可抢占，循环等待 3. CAS(原子操作)是乐观锁用到的主要机制，乐观锁是不用加锁去执行操作，如果产生冲突则失败重试，直到成功为止，也叫做“自旋”。与乐观锁相对应的是悲观锁，synchronized就是悲观锁，也叫“独占锁”需要加锁进行操作，并且加锁代码块中的只能有一个线程进行操作。 4. 点击App图标，系统最开始执行的是ActivityThread的main()方法 5. 应用的启动方式： - 冷启动：启动应用时，后台没有该应用的进程。系统创建一个新的进程来进行重新分配。 - 热启动：启动应用时，后台已有该应用的进程。 6. Application的生命周期：`onCreate()//应用开始时执行->onLowMemory()//内存低时执行->onTrimMemory()//关闭应用时执行 onTerminate()//在真机上不会调用` 7. 进程相关： `优先级最低的进程首先被杀死、进程的等级会因为其他进程的依赖而提高一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低` 按重要性分类： - 前台进程：进程持有一个正在与用户交互的Activity或者和交互Activity绑定的Service，前台运行的Service（执行`startForeground()`）,执行`onReceive()`的BroadcastReceiver - 可见进程：进程持有一个被用户可见但没有显示在最前端的Activity(调用到了`onPause()`)或者和可见Activity绑定的Service - 服务进程：进程持有一个`startService()`启动的Service进程，例如播放音乐，下载文件等Service - 后台进程：进程持有一个用户不可见的Activity(调用到`onStop()`没有到`onDestroy()`)，进程被存放在一个LRU列表中，即很长时间没用的Activity会被优先杀死 - 空进程：进程不包含任何活跃的应用组件，唯一的作用是`为了缓存需要，缩短下次启动的时间` 8. 统计应用启动时间：`adb shell am start -W [packageName]/[packageName.MainActivity]` 9. `volatile`作用是`可见性`(当一个线程修改了某一个全局变量的值，其他线程能否知道这个修改)，`有序性`（禁止指令重排优化,防止代码执行指令被重新排序）。`volatile`并不能保证线程安全即保证不了线程间操作的原子性。 10. SharedPreference中`apply`和`commit`方法的区别：`commit`同步保存更改，`apply`异步保存到磁盘，原子提交，性能较高，但不保存结果。SharedPreference不支持多线程操作，`MODE_MULTI_PROCESS`这个标记位并没有实际作用。可以利用`ContentProvider`去实现多进程，_方案后续会有介绍_。 11. MD5不是加密算法，是一种散列算法。加密算法一般是对称加密算法 12. 使用ADB启动Activity：`adb shell am start -n 包名/需启动Activity路径` 13. Fragment中`replace`与`add`区别： - `replcae`：把容器内所有内容进行替换，都需要重新走一遍fragment的生命周期 - `add`：添加不会清空容器内的内容。 14. 在三星手机上，进行原生分享文件时需要设置mimeType 15. `invalidate()`、`postInvalidate()`和`requestLayout()`的区别： - `invalidate()`：当子View调用invalidate方法时，会给View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递至ViewRootImpl中，最终触发performTraversals方法，进行View的重绘（即调用onDraw方法）。**该方法只能在UI线程中调用** - `postInvalidate()`：与invalidate作用一致，都是使View进行重绘，**该方法是在非UI线程中调用的**。内部主要实现是提供一个Handler实现，然后直接调用了invalidate方法，继续执行重绘流程。 - `requestLayout()`：调用了这个方法会重新执行View的绘制流程，即重新执行测量(`onMeasure`)，布局(`onLayout`)，绘制(`onDraw`)方法。**利用责任链模式-不断向上传递该事件，直到找到能处理该事件的上级**。 16. Bitmap所占用的内存 = 图片长度 x 图片宽度 x （屏幕分辨率÷图片资源目录分辨率）²×一个像素点占用的字节数]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XII]]></title>
    <url>%2F2018%2F04%2F01%2FAndroid-Study-Plan-XII%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XII date: 2018-04-01 17:58:32 tags: Android --- # Android学习计划 ## 从源码的角度描述下Activity的启动过程]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity生命周期相关]]></title>
    <url>%2F2018%2F04%2F01%2FActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[--- title: Activity生命周期相关 date: 2018-04-01 17:57:25 tags: Android --- {% fullimage /images/study_plan/activity_lifecycle.jpeg, Activity生命周期,Activity生命周期 %} {% fullimage /images/study_plan/activity_lifecycle_2.jpg, Activity生命周期,Activity简便生命周期 %} - 回调方法介绍 - **onCreate()**：Activity创建时调用，用于初始化工作，例如加载xml布局文件等 - **onStart()**：Activity由不可见变为后台可见状态，不过还无法交互 - **onResume()**：用户从后台或者跳转后的Activity回到原Activity时调用，让Activity回归前台 - **onPause()**：启动新Activity时，原Activity会调用该方法并调用onStop方法`不可在此回调中实现耗时方法,会影响新Acticity的启动` - **onStop()**：Activity由可见变为完全不可见，若有对话框则依然可见，`在onStop和onPause过程中的Activity优先级较低，容易被回收` - **onDestroy()**：Activity即将被销毁，可在此做资源回收以及对象销毁的工作 - **onRestart()**：Activity由不可见变为完全可见过程调用，当Activity从onStop过程中回到前台可见时调用，并随后调用onStart方法。 ​ - **onPostCreate()**：在onCreate执行完毕之后的回调 - **onUserInteraction()**：所有在Activity上执行的触摸事件都会优先调用该方法 - **onUserLeaveHint()**：用户主动离开Activity会调用该方法，例如按Home键或者进入后台任务，系统事件导致的切换不会响应 - **onContentChanged()**：当Activity调用setContentView方法结束后会调用该方法 - **onAttachedToWindow()**：可以再方法中 进行Window窗口尺寸的修改 - Activity几种状态下的生命周期变化 - 启动Activity:`onCreate()->onStart()->onResume()` - Activity被覆盖或者锁屏时：`onPause()` - Activity回到运行状态时:`onResume()` - 当前Activity跳转到新的Activity或者Home键回到桌面时:`onPause()->onStop()` - 后退回到上一Activity时：`onRestart()->onStart()->onResume()` - 退出当前Activity：`onPause()->onStop()->onDestroy()` - 下拉状态栏 对生命周期没有影响(捕捉下拉状态栏事件，使用`onWindowFouceChanged()`) - 弹出Dialog：自己创造的Dialog不会有周期变化，其他创造的Dialog会执行`onPause()` - **当发生Activity切换时，总是切换前的Activity先调用onPause方法，后执行其他方法。** - 新Activity主题为透明时，旧Activity不会走`onStop()`。 - Activity被回收或者改变屏幕方向时信息的保存和恢复 - `onSaveInstanceState()`保存信息 - 在被覆盖或者位于后台运行时，因为内存不足被回收时调用 - 屏幕发生旋转时会被调用 - 当前Activity发生跳转或者Home键响应导致应用位于后台 - 非主动销毁才会被调用 - 利用`onSaveInstanceState()`保存数据，执行于`onPause()，onStop()`之前 - `onRestoreInstaceState()`恢复信息 - 在Activity被回收时，用户重新回到Activity - 屏幕旋转Activity重建时 - 利用`onRestoreInstanceState()`恢复数据，执行于`onStart()` 之后 - Activity任务栈 - 程序创建时就会创建一个Activity任务栈，存储当前程序的Activity，当前程序所有的Activity都是一个任务栈 - 任务栈是Activity的集合，只有位于栈顶的Activity可以和用户交互 - 任务栈可以移动到后台并保留了Activity的状态 - 退出应用程序时，要清理任务栈所有Activity，程序退出 - Activity LaunchMode - {% post_link Android-Study-Plan-III %} - Activity启动过程 - 从Context的startActivity，调用ContextImpl的startActivity，内部实现由Instrumentation尝试启动Activity，这是一个跨进程的过程。继续调用AMS(ActivityManagerService)的startActivity方法，当校验完Activity的合法性后，利用ApplicationThread回调到我们自己的进程，这也是一个跨进程的过程，ApplicationThread就是一个Binder。回调逻辑在Binder线程池中完成，所以需要通过Handler将其切回UI线程，第一个消息时LAUNCH_ACTIVITY，对应着handleLaunchActivity，在这个方法里面完成Activity的创建和启动。接着在onResume中，Activity的内容渲染在Window上面，然后开始绘制流程。 - [Activity启动流程分析](https://blog.csdn.net/qq_23547831/article/details/51224992) - Activty行为标志和属性 - **亲和性**`默认情况下，应用程序中的所有Activity，都有一个对于其他Activity的亲和性，这是一个对于同一个任务中的其他Activity的优先权，然后通过元素的taskAffinity属性可以分别为每一个activity设置亲和性。`不同应用程序定义的activity可以共享一个亲和性，或者同一个应用程序定义的activity可以指定不同的亲和性。亲和性在两种情况下发挥作用： - **启动一个包含`FLAG_ACTIVITY_NEW_TASK`标志的activity** 新的Activity默认情况下，被加载进调用`startActivity()`方法的activity对象所在的任务中，被压入和调试者同一个栈中，但是如果传递了`FLAG_ACTIVITY_NEW_TASK`标志，系统会创建一个不同的任务栈容纳该Activity。若已经存在一个和该Activity亲和性相同的任务栈，该activity就会被加载进去，没有则重新创建任务栈。 - **activity的`allowTaskReparenting属性设置为true`** 该activity可以从启动时所在的任务移动到另一个出现在前台的任务。举个栗子： - 有一个activity负责展示数据，他作为一个数据展示应用程序的一部分，它和该应用中的其他activity有同样的亲和性，然后一个外部app调起了该activity，则该activity和外部app具有亲和性即在同一任务栈中。但是，当数据展示应用运行时，该activity会重新分配回到数据展示应用中。 - **清理栈**`用户离开一个任务很长时间，系统将清除除了根Activity之外的所有Activity，当用户重新回到应用中时，像是用户离开了它，只剩最初的Activity。`考虑到过了一段时间用户可能会放弃之前做的所有事情，回到任务去做新的事情。有一些相关属性可以控制和修改机制： - **android:alwaysRetainTaskState** 标记应用的task是否保持原来的状态，`true`总是保持,`false`则不能保证。若为true，则系统会保留所有的activity，例如在browser应用，可以替用户保留很多的tab。 - **android:clearTaskOnLaunch** 标记是否从task清除除根activity之外的所有activity，`true`表示清除，`false`表示不清除。若为true，每次用户重启这个应用时，都只会看到根activity，即无论离开多久用户重新回归都只能看到根activity。特例：`在我们应用中引用了其他应用的activity，且activity设置了allowTaskReparenting为true，则他们会被重新宿主到有共同affinity的task中。` - **android:finishOnTaskLaunch** 作用与clearTaskOnLaunch类似，不过是作用于单个Activity，而非整个任务。可以设置任何Actiivty离开，即用户返回应用时，设置为true的Actiivty会消失。 特例：如果这个特性和`allowTaskReparenting`都为true，则该属性优先，Activity的affinity忽略。这个Activity不会重新宿主，但会被销毁。 - **其他方案** 启动一个包含`FLAG_ACTIVITY_CLEAR_TOP`标志的Activity，则会清理所有栈中位于该实例之上的Activity。 ​ - 查看当前任务栈方法 ```java adb shell dumpsys activity activities ```]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity,Window,View的关联与理解]]></title>
    <url>%2F2018%2F04%2F01%2FActivity-Window-View%E7%9A%84%E5%85%B3%E8%81%94%E4%B8%8E%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[--- title: 'Activity,Window,View的关联与理解' date: 2018-04-01 17:27:58 tags: Android --- # Activity,Window,View相关 ## 1. 什么是Activity,Window,View以及职能简介 - Activity：不负责视图控制，只是控制生命周期和处理事件，真正控制视图的是Window，一个Activity包含一个Window，Window真正代表一个窗口。`Activity是一个控制器，控制视图的添加与显示以及通过回调方法来进行Window与View的交互。` - Window：Window是视图的承载器，内部持有一个DecorView，DecorView才是view的根布局，Window为抽象类，实际是Activity中的其子类PhoneWindow，其中有个内部类DecorView，通过创建DecorView来加载`R.layout.*`，Window通过WindowManager加载DecorView，并将DecorView和ViewRoot关联，进行视图控制与交互。 - View：DecorView继承自FrameLayout,DecorView作为顶级View，一般其内部包含一个竖直方向的LinearLayout，里面包含ViewStub，标题栏（titleView），内容栏（contentView）。Activity通过`setContentView()`将布局文件加载进内容栏中。 - ViewRoot：ViewRoot的实现类是ViewRootImpl，是WindowService和DecorView之间的纽带。ViewRoot不属于View节点，和View之间没有直接联系，不过实现了ViewParent接口。 {% fullimage /images/study_plan/activity_window_view.png, alt,流程图 %} ## 2. Activity，Window，View的关系 > 基本关系是：Activity中展示元素通过Window实现，Window可以理解为一个容器，里面装载着一个个的View，来执行显示工作。 ## 3. Activity如何和Window，View关联（附源码） > Activity和Window关联 > ## 4. View和Window有什么联系]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan I - synchronized]]></title>
    <url>%2F2018%2F03%2F24%2FAndroid-Study-Plan-I%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan I - synchronized date: 2018-03-24 16:22:17 tags: Android --- # Android 学习计划 理解Java中的synchronized关键字。 指标：理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。 有如下一个类A ```java class A { public synchronized void a() { } public synchronized void b() { } } ``` 然后创建两个对象 ```java A a1 = new A(); A a2 = new A(); ``` 然后在两个线程中并发访问如下代码： Thread1 Thread2 a1.a(); a2.a(); 请问二者能否构成线程同步？ 如果A的定义是下面这种呢？ ```java class A { public static synchronized void a() { } public static synchronized void b() { } } ``` # 答案 Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。 > Synchronized作用: - 确保线程互斥的访问同步代码块 - 保证共享变量的修改能够及时可见 - 有效解决重排序问题 > wait(),notify(),notifyAll(),sleep()作用 - wait 调用线程 释放锁，然后进入休眠 - sleep thread的一个操作方法，不释放锁直接进入休眠 - notify 唤醒等待队列中的第一个相关进程 - notifyAll 唤醒所有 > Synchronized主修修饰对象为以下三种： 1. 修饰普通方法 一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象， 如果多个线程不同对象访问该方法，则无法保证同步。 2. 修饰静态方法 由于静态方法是类方法， 所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。 3. 修饰代码块 其中普通代码块 如Synchronized（obj） 这里的obj 可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。 Synchronized方法控制范围较大， 它会同步对象中所有Synchronized方法的代码。 Synchronized代码块控制范围较小， 它只会同步代码块中的代码， 而位于代码块之外的代码是可以被多个线程访问的。 简单来说 就是 Synchronized代码块更加灵活精确。 > 示例代码 ```java public class SyncThread implements Runnable { private static int count; public SyncThread() { count = 0; } @Override public void run() { synchronized (this) { for (int i = 0; i < 5; i++) { try { System.err.println(Thread.currentThread().getName() + " " + (count++)); Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } } public static int getCount() { return count; } } ``` # 修饰代码块 ```java public static void main(String[] args) { SyncThread syncThread = new SyncThread(); Thread thread1 = new Thread(syncThread, "sync1"); Thread thread2 = new Thread(syncThread, "sync2"); thread1.start(); thread2.start(); } ``` 访问的同一个对象时，同一时刻只能有一个线程执行，执行代码块是会锁定当前对象，所以需要执行完才能释放，下一个线程才能继续执行并锁定对象 > 运行结果 ```log sync1 0 sync1 1 sync1 2 sync1 3 sync1 4 sync2 5 sync2 6 sync2 7 sync2 8 sync2 9 ``` # 修饰对象 ```java public static void main(String[] args) { Thread thread1 = new Thread(new SyncThread(), "sync1"); Thread thread2 = new Thread(new SyncThread(), "sync2"); thread1.start(); thread2.start(); } ``` 这时创建了两个SyncThread对象，线程1执行对象1中的同步代码，线程2执行的是对象2的代码，这时两把锁分别锁定SyncThread1和SyncThread2对象，两把锁互不干扰也不互斥，所以同时执行。 > 运行结果 ```log sync1 0 sync2 1 sync1 2 sync2 3 sync1 4 sync2 5 sync1 6 sync2 7 sync1 8 sync2 9 ``` 问题1 ：不能同步 - a1.a()锁是a1 a2.b()锁是a2 不是同一把锁 所以不同步 问题2：能同步 - 锁都为A.class对象，是统一把锁]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础排序算法介绍]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[--- title: 基础排序算法介绍 date: 2018-03-20 20:40:23 tags: 算法 mathjax: true top: 10 --- # 基础排序算法介绍 ## 知识点: - 排序算法稳定性的定义：简单的介绍就是排序前相等的数据先后顺序在排序后的先后顺序位置相同 - 基本交换算法 ```java private static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } ``` - 时间复杂度：执行算法所需要的计算工作量 $ O(1) $ 意味没有循环即只执行单条语句 $ O(n) $ 执行没有嵌套的循环 $ O(n^2) $ 双重嵌套循环 - 空间复杂度：算法在运行工程中临时占用存储空间的量度 算法 | 平均时间 | 最好 | 最差 | 空间复杂度 | 稳定性 - | :-: | :-: | :-: | :-: | :-: | :-: | -: 冒泡排序| $ O(n^2) $ | $ O(n) $ | $ O(n^2) $ | $ O(1) $ | 稳定 直接插入排序| $ O(n^2) $ | $ O(n) $ | $ O(n^2) $ | $ O(1) $ | 稳定 折半插入排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(n^2) $ | $ O(1) $ | 稳定 希尔排序| $ O(nlogn) $ - $ O(n^2) $ | $ O(n^1.3) $ | $ O(n^2) $ | $ O(1) $ | 不稳定 选择排序| $ O(n^2) $ | $ O(n^2) $ | $ O(n^2) $ | $ O(1) $ | 不稳定 快速排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(n^2) $ | $ O(nlogn) $ - $ O(n^2) $ | 不稳定 归并排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(nlogn) $ | $ O(n) $ | 稳定 堆排序| $ O(nlogn) $ | $ O(nlogn) $ | $ O(nlogn) $ | $ O(1) $ | 不稳定 ## 排序算法 ### 冒泡排序 > 在要排序的一组数中，对当前范围内还未排列好的数据由上而下进行比较，即每当相邻的数与要求的排序方式相反时将数据进行互换 > 改进版的写法就是利用标记法减少循环次数 > 基本写法 ```java private static void bubbleSort(int[] array) { int size = array.length; for (int i = 0; i < size - 1; i++) { for (int j = 1; j < size - i; j++) { if (array[j - 1] > array[j]) { swap(array, j, j - 1); } } } } ``` > 改进写法 ```java private static void advancedBubbleSort(int[] array) { int size = array.length; int flag = 0;//设置标记位 for (int i = 0; i < size - 1; i++) { flag = 0; for (int j = 1; j < size - i; j++) { if (array[j - 1] > array[j]) { flag = 1; swap(array, j, j - 1); } } if (flag == 0)//没有发生数据交换则意味着排序已经结束 break; } } ``` ---- ### 选择排序 > 再一次遍历过程中找到最小值放在排序数据中的首位，每次寻找剩余中最小的直到结束为止。 ```java private static void selectSort(int[] array) { int size = array.length; for (int i = 0; i < size; i++) { int minIndex = i; for (int j = i + 1; j < size; j++) { if (array[j] < array[minIndex]) { minIndex = j; } } swap(array, i, minIndex); } } ``` ---- ### 直接插入排序 > 按照顺序选定元素从后往前找，插入一个顺序数列中即可 ```java private static void InsertSort(int[] array) { int size = array.length; for (int i = 0; i < size; i++) { int temp = array[i]; for (int j = i; j > 0 && array[j - 1] > array[j]; j--) {//从该元素所在位置 向前移动 直到该元素位于 递增顺序 array[j] = array[j - 1]; array[j - 1] = temp; } } } ``` ---- ### 折半插入排序 > 再往前寻找位置的过程中利用二分法寻找位置 ```java private static void insertBinarySort(int[] array) { int size = array.length; for (int i = 1; i < size; i++) { if (array[i] < array[i - 1]) {//前比后大 int temp = array[i]; int low = 0, high = i - 1, mid; while (low 先取`d`为间隔，将原始数组分为d个序列，将间隔的数组放在一个子序列利用插入排序法进行排序 然后缩小间隔`d` 重复上述操作，知道`d`为1时，则排序完成 ```java private static void shellSort(int[] array) { int size = array.length; for (int d = size / 2; d > 0; d /= 2) {//设置步长 for (int i = 0; i < size; i += d) { int temp = array[i]; int j = i; for (; j >= d && temp < array[j - d]; j -= d) { array[j] = array[j - d]; } array[j] = temp; } } } ``` ---- ### 基数排序 > 讲一组元素进行桶分配，按照每位数的大小进行排序 ```java private static void radixSort(int[] array) { int size = array.length; int max = array[0];//数组中的最大数 for (int i = 0; i < size; i++) { if (array[i] > max) max = array[i]; } int time = 0;//最大位数 while (max > 0) { max /= 10; time++; } int k = 0;//索引 int m = 1;//位值 int n = 1;//第几位 int[][] temp = new int[10][size]; int[] order = new int[10]; while (m]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Study-Plan-XI]]></title>
    <url>%2F2018%2F03%2F19%2FAndroid-Study-Plan-XI%2F</url>
    <content type="text"><![CDATA[--- title: Android-Study-Plan-XI date: 2018-03-19 19:47:12 tags: Android --- # Android学习计划 话题：Okhttp和Retrofit 1、介绍这两个框架的作用和联系 PS：这个问题几乎Android面试必问]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide源码解析要点]]></title>
    <url>%2F2018%2F03%2F18%2FGlide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[--- title: Glide源码解析要点 date: 2018-03-18 19:36:39 tags: 源码解析 --- > 该源码解析是基于最新的Glide 4.6.0进行的]]></content>
      <tags>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan IX - ClassLoaderß]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-IX%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan IX - ClassLoaderß date: 2018-03-18 17:48:29 tags: Android --- # Android学习计划 话题：Android中的ClassLoader 1、Android中有哪几种ClassLoader？它们的作用和区别是什么？ 2、简述ClassLoader的双亲委托模型 3、简述双亲委托模型在热修复领域的应用 # 答案 ## 1.Android中有哪几种ClassLoader？它们的作用和区别是什么？ > 在Android程序中，.dex文件就是一群.class文件。 {% fullimage /images/study_plan/android_classloader.png, alt,SingleTop %} - **BootClassLoader** > BootClassLodaer是ClassLoader内部实现类，是只能包内可见，我们是无法调用的。在无父构造器传入的情况下，默认构建一个PathClassLoader且父构造器为BootClassLoader > ```java private static ClassLoader createSystemClassLoader() { String classPath = System.getProperty("java.class.path", "."); String librarySearchPath = System.getProperty("java.library.path", ""); return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance()); } ``` - **URLClassLoader** > 只能用于加载jar文件，但是在dalvik（Android5.0之前的虚拟机）无法直接识别jar，所以Android中无法使用这个加载器。 - **BaseDexClassLoader** > 用于加载各种dex中的类 > ```java public class BaseDexClassLoader extends ClassLoader { public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) { throw new RuntimeException("Stub!"); } ... } ``` > > 主要构造函数介绍： > > - dexPath：指`目标类所在的apk、dex或jar文件的路径，也可以是SD卡的路径`，类加载器从该路径加载目标类。如果包含多个路径，路径之间必须用特定的分隔符去分隔，特定的分隔符从`System.getProperty("path.separtor")`获取（默认分割符为":"）。最终将路径上的文件ODEX优化到optimizedDirectory，然后进行加载。 > - optimizedDirectory：解压出的dex文件路径，这个路径必须为内部路径，一般情况下的路径为`/data/data//` > - librarySearchPath：存放目标类中使用的native文件库，也以":"分割 > - parent：父加载器，在Android中以`context.getClassLoader`作为父加载器。 - **DexClassLoader** > 继承自BaseDexClassLoader，支持加载包含classes.dex的jar、apk，zip文件，可以是SD卡的路径。是实现热修复的关键。**注意不要把优化后的文件放在外部存储，可能导致注入攻击。** - **PathClassLoader** > 用来加载Android系统类和应用程序的类，**在dalvik上只能加载已安装apk的dex(/data/app目录)，在ART虚拟机上则没有这个限制**。 ```java public class PathClassLoader extends BaseDexClassLoader { public PathClassLoader(String dexPath, ClassLoader parent) { super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); } public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) { super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); } } ``` > 在PathDexClassLoader的构造方法中optimizedDirectory为null，因为默认参数为`/data/dalvik-cache`目录。 - **InMemoryDexClassLoader** > 用于加载内存中的dex文件(在API26中添加) > ```java public final class InMemoryDexClassLoader extends BaseDexClassLoader { public InMemoryDexClassLoader(ByteBuffer[] dexBuffers, ClassLoader parent) { super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); } public InMemoryDexClassLoader(ByteBuffer dexBuffer, ClassLoader parent) { super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); } } ``` - **DelegateClassLoader** > 是一个先查找在委托的类加载器(API27添加)，按照以下顺序实现加载： > > 1. 首先判断该类是否被加载 > 2. 搜索此类的类加载器是否加载过这个类 > 3. 使用当前加载器去尝试加载类 > 4. 最后委托给父加载器加载 ## 2.简述ClassLoader的双亲委托模型 {% post_link JVM相关及其拓展-三 %} ## 3.简述双亲委托模型在热修复领域的应用 一个ClassLoader文件可以有多少Dex文件，每个Dex文件是一个Element，多个Dex文件组成一个有序数组DexElements，当找类的时候会按照顺序遍历Dex文件，然后在当前遍历的Dex文件中找出类。由于双亲委托模型机制的存在，只要找到类就会停止检索并返回，找不到就会查询下一个Dex，所以只要我们先找到并加载修复Bug的文件，则有bug的Dex文件不会被加载。 注意点：假设有个A类，引用了B类。发布过程中发现B类有bug，若想要发个新的B类，需要阻止A加上这个类标志CLASS_ISPREVERIFIED。 ## 4. 基本热修复代码实现]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan VIII - Java引用类型]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-VIII%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan VIII - Java引用类型 date: 2018-03-18 17:48:20 tags: Android --- # Android学习计划 话题：Java基础知识学习 1、Java中有哪几种引用？它们的含义和区别是什么？ 2、请用Java实现一个线程安全且高效的单例模式。 # 答案 ## 1. Java中有哪几种引用？它们的含义和区别是什么？ - 强引用（StrongReference）：`无论内存是否充足，都不会被回收`强引用指的是在代码中普遍存在的类似`Object object=new Object();`这类的引用，只要有这类的存在，垃圾回收器永远不会回收该对象，这也是导致OOM异常出现的主要原因。若想中断强引用可以把对象置为`null`。 - 弱引用（WeakReference）：`内存不足时，会被回收`弱引用用来修饰非必需对象，弱引用所关联的对象生命周期只到下一次垃圾回收前，无论内存是否充足都会被回收关联对象。 ```java String s=new String("abc"); WeakReference weakReference=new WeakReference(s); //当内存回收时 调用weakRefrence=null 并且 System.gc(); ``` - 软引用（SoftReference）：`无论内存是否充足，都会被回收`软引用用来修饰一些有用但非必需的对象，软引用所关联的对象将会在系统即将发生OOM前，会把对象进行二次回收，若回收完内存还是不足则会发生OOM异常。`可实现内存敏感的高速缓存` ```java String s=new String("abc"); SoftReference softReference=new SoftReference(s); //当内存不足时 会调用 softRefrence=null 并且 System.gc(); ``` - 虚引用（PhantomReference）：`任何时候都会被回收`虚引用不会决定对象的生命周期，虚引用关联的对象任何时候都可能被垃圾回收器回收。虚引用的作用是：跟踪对象被垃圾回收器回收的活动，虚引用本身加入引用队列中，记录引用对象是都被回收。 ## 2. 请用Java实现一个线程安全且高效的单例模式。 > 单例：一个类有且仅有一个实例，并且自行实例化向整个系统提供。目的为 > > - 减少内存的占用 > - 阻止对象实例化自己的单例对象副本，从而确保所有对象访问统一实例 > - 控制了实例化过程所以可以灵活化控制实例过程。 > > 线程安全：再多线程访问时采用加锁机制，当一个线程访问该数据时，其他线程不能访问该数据，直到读取完毕才可以访问。不会出现数据不一致和数据污染。 > 双重校验锁（DCL） ```java public class Singleton { private static volatile Singleton mInstance; private Singleton() { } public static Singleton getInstance() { if (mInstance == null) { synchronized (Singleton.class) { if (mInstance == null) { mInstance = new Singleton(); } } } return mInstance; } } ``` > 在JVM中，并不限制处理器的执行顺序，在不影响运行结果的情况下，顺序可能会被打乱。volatile 关键字的作用是防止执行命令不会被重新排序。如若没有volatile 修饰，则`mInstance = new Singleton(); `可能出现`mInstance `尚未被初始化的异常。 > `mInstance = new Singleton(); `包括三步：`为对象分配内存`，`执行构造方法，初始化实例对象`，`把mInstance的引用指向分配的内存空间`。在JVM的执行过程中并不是原子性的。 > 保护序列化与反序列化安全的写法： ```java /** *反序列化提供的一个特殊方法，可以控制对象的反序列化。 */ private Object readResolve(){ return mInstance;//返回实例对象 } ``` > 静态内部类： > > `为何可以保证线程安全？`虚拟机可以保证一个类的类构造器 `()`在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，只有一个线程可以去执行类构造方法，其他线程都会阻塞等待，直到构造方法执行完毕。**同一个类加载器下，一个类型只会被初始化一次。** ```java public class Singleton { private Singleton() { } public static Singleton getInstance() { return SingletonHolder.sInstance; } private static class SingletonHolder { private static Singleton sInstance = new Singleton(); } } ``` > 枚举写法（在Android中不推荐使用，对内存的消耗较大） 枚举法的好处：1.实例创建线程安全 2.防止被反射创建多个实例 3. 没有序列化的问题 ```java public enum Singleton{ INSTANCE; public void fun() { //do sth } } ``` ## 3. 拓展知识 - Kotlin实现的单例模式：`object Singleton{}`，本质是饿汉加载，在类加载时就会创建单例。问题在于构造方法过多时，初始化会变慢以及资源的浪费。 - Kotlin实现懒汉式加载： ```kotlin class Singleton private constructor(){ companion object { val instance: Singleton by lazy { Singleton() } } } ```]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan VII - 序列化]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-VII%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan VII - 序列化 date: 2018-03-18 17:48:14 tags: Android --- # Android学习计划 ## 话题：关于序列化的知识 1、Parcelable和Serializable有什么用，它们有什么差别？ 2、自定义一个类让其实现Parcelable，大致流程是什么? ## 答案： ### 1. Parcelable和Serializable有什么用，它们有什么差别？ > 什么是序列化？ > 将对象转化为可以传输的二进制流的过程，就可以通过序列化，转化为可以在网络传输或者保存到本地的流，从而进行传输数据。反序列化即为从二进制流转化为对象的过程。 > 也为了解决对象的持久化问题。当你在程序中声明一个类后，程序关闭则释放对象，持久化就是为了应用关闭后类的内容依然存在。 > #### Parcelable和Serializable有什么用? > 两者都可以实现序列化，使对象变为二进制流在内存中传递。在开发中只要实现两者之一就可以进行数据的传递利用Intent和Binder。 > Serializable：`Serializable `是Java提供的一个序列化接口，需要序列化的对象只要实现了该接口，并选择性的声明`serialVersionUID`即可。序列化的机制依赖于该参数，不指定则会自动计算生成，当类发生变化时，该参数也会产生变化，将会导致反序列化失败的问题。如果显式的指定了该值，只要类的结构不发生大变化（更改类型，修改字段类型，添加或删除字段）都可以序列化成功。 > Parcelable：`Parcelable `是Android提供的一个序列化接口且仅能在Android中使用。使用相对复杂但是效率很高。序列化过程需要实现`writeToParcel(Parcel dest, int flags)`,`describeContents()`方法，以及为了反序列化，还需要设置一个非空的`CREATOR`字段。 > #### Parcelable和Serializable差别 > Parcelable不需要IO操作，Serializable需要大量的IO操作，会产生很多临时对象造成频繁的GC。 > Parcelable序列化的数据仅在内存中存在，如Activity间传递数据或者进程间通信使用Parcelable，在需要持久保存或者网络传输时使用Serializable > Android版本不同可能Parcelable也会有变化，不建议进行数据持久化操作。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan VI]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-VI%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan VI date: 2018-03-18 17:48:09 tags: Android --- # Android学习计划 话题：关于Gradle的知识 1、如何理解Gradle？Grade在Android的构建过程中有什么作用？ 2、实践如下问题。 问题：我们都知道，Android中时常需要发布渠道包，需要将渠道信息附加到apk中，然后在程序启动的时候读取渠道信息。 动态指定一个渠道号（比如1001），那么构建的apk中，请在它的AndroidManifest.xml文件里面的application节点下面添加如下meta-data，请写一段Gradle脚本来自动完成： ```xml ``` 要求：当通过如下命令来构建渠道包的时候，将渠道号自动添加到apk的manifest中。 ./gradlew clean assembleRelease -P channel=1001]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan V]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-V%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan V date: 2018-03-18 17:48:03 tags: Android --- # Android学习计划 话题：关于View的知识 1、View的getWidth()和getMeasuredWidth()有什么区别吗？ 2、如何在onCreate中拿到View的宽度和高度？ # 答案 ## 1. View的getWidth()和getMeasuredWidth()有什么区别吗？ - `getWidth()`通过`setFrame`方法来决定四个顶点位置，初始化`mLeft,mTop,mRight,mBottom`四个参数，这四个值固定则位置确定。必须在layout过程结束才有值。 ```java /** * Return the width of the your view. * * @return The width of your view, in pixels. * 利用屏幕上的右坐标减去左边的坐标 */ @ViewDebug.ExportedProperty(category = "layout") public final int getWidth() { return mRight - mLeft; } protected boolean setFrame(int left, int top, int right, int bottom) { ... mLeft = left; mTop = top; mRight = right; mBottom = bottom; ... } ``` - `getMeasuredWidth`是在view的绘制流程中的`measure`结束后有值，获取的是view的测量宽高。`mMeasuredWidth `是在`setMeasuredDimensionRaw `方法中赋值的 ```java public static final int MEASURED\_SIZE\_MASK = 0x00ffffff; /** * Like {@link #getMeasuredWidthAndState()}, but only returns the * raw width component (that is the result is masked by * {@link #MEASURED_SIZE_MASK}). * * @return The raw measured width of this view. */ public final int getMeasuredWidth() { return mMeasuredWidth & MEASURED_SIZE_MASK;//与任何数字的运算得到的结果是mMeasuredWidth } private void setMeasuredDimensionRaw(int measuredWidth, measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; } ``` - 一般情况下 `getMeasuredWidth `和`getWidth`的值是相同的，从源码中可以看出`setMeasuredDimensionRaw `会对`mMeasuredWidth `进行赋值，当调用了`onMeasure`，会调用到`setMeasuredDimensionRaw `则获取的结果将会不相同 ```java public final void measure(int widthMeasureSpec, int heightMeasureSpec) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } ... if (forceLayout || needsLayout) { // first clears the measured dimension flag mPrivateFlags &= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex < 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value >> 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags & PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException("View with id " + getId() + ": " + getClass().getName() + "#onMeasure() did not set the" + " measured dimension by calling" + " setMeasuredDimension()"); } mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } ... } ``` - view的绘制流程`measure` `layout` `draw` {% fullimage /images/study_plan/view_process.png, alt,流程图 %} - `measure`为了计算出控件树中的各个控件要显示的内容以及大小，起点为`ViewRootImpl 的 measureHierarchy ()`。 - SpecMode : `EXACTLY(确切大小)` `AT_MOST(子view的大小不得超过SpecSize)` `UNSPECIFIED(对子view尺寸不做限制)` ```java /** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */ public static final int UNSPECIFIED = 0 < MODE_SHIFT; /** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */ public static final int EXACTLY = 1 < MODE_SHIFT; /** * Measure specification mode: The child can be as large as it wants up * to the specified size. */ public static final int AT_MOST = 2 < MODE_SHIFT; ``` - `layout` 从根view开始，递归的完成控件树的布局工作，确定view的位置。先递归的对子view进行布局，在完成父布局的位置设置 - `draw` 从根view开始进行绘制，利用`Viwe.draw()` ## 2.如何在onCreate中拿到View的宽度和高度？ - 在 Activity#onWindowFocusChanged 回调中获取宽高。 - view.post(runnable)，在 runnable 中获取宽高。 `利用Handler通信机制，发送一个Runnable在MessageQuene中，当layout处理结束时则会发送一个消息通知UI线程，可以获取到实际宽高。` - ViewTreeObserver 添加 OnGlobalLayoutListener，在 onGlobalLayout 回调中获取宽高。 `监听全局View的变化事件，使用后需要注意移除OnGlobalLayoutListener 监听，以免造成内存泄露` - 调用 view.measure()，再通过 getMeasuredWidth 和 getMeasuredHeight 获取宽高。 ## 补充知识点 - matchParent无法measure(在view的measure过程中，需要知道parentSize即父容器的剩余空间，所以无法得出measure的大小) - [深入理解View绘制流程][1] [1]: https://www.cnblogs.com/jycboy/p/6219915.html#autoid-7-1-0]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan IV]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-IV%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan IV date: 2018-03-18 17:47:55 tags: Android --- # Android学习计划 话题：关于startActivityForResult 1、startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode以及intent含义是什么？ 2、Activity A启动B的时候，在B中何时该执行setResult ？setResult可以位于Activity的finish方法之后吗？ # 答案 ## 1. startActivityForResult 使用场景是什么？ requestCode、 resultCode 含义是什么？ ### 1.1 使用场景 - 用户开始新的活动，并且希望得到新活动的某些信息。比如选择照片、选择联系人、选择收货地址、进行某块数据编辑工作等。 ### 1.2 requestCode - 解决的是「区分多个异步任务」的问题。与其他异步 API 的设计类似，如果没有这个信息，那么 Activity 在收到响应时会进入混乱的状态。比如他不知道自己得到的是选择照片还是选择联系人的结果。 - 该信息会发送到 AMS 那边的 ActivityRecord.requestCode 变量进行记录，Client 端新 Activity 并不知道这个信息。 - 为什么 `requestCode`\< 0 时收不到结果？ - ActivityStarter 收到 startActivityLocked 时，写入ActivityRecord.resultTo 变量为空[对应源码][1] ``` java ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; if (resultTo != null) { sourceRecord = mSupervisor.isInAnyStackLocked(resultTo); if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, "Will send result to " + resultTo + " " + sourceRecord); if (sourceRecord != null) { if (requestCode >= 0 && !sourceRecord.finishing) { resultRecord = sourceRecord; } } } ``` - 在 ActivityStack 收到 finishActivityResultsLocked 时，读取 ActivityRecord.resultTo 变量为空，结果数据不会添加到源 ActivityRecord.results 变量 - 在 ActivityStack 收到 resumeTopActivityInnerLocked 时，读取 ActivityRecord.results 数组为空，不会分发结果数据，这样源 Activity 也就没有结果回调了 ### 1.3 resultCode - 异步调用结果码，告诉调用者成功/失败/其它信息 - 该信息由被调用 Activity / framework 写入，并经过 AMS 传递给源 Activity - `RESULT_CANCELED=0` `RESULT_OK=-1` `RESULT_FIRST_USER=1` ### 1.4 intent - 用于存储需要传递的数据 - 大小不得大于1M ## 2. A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？ ### 2.1 setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中 Activity 构造器阶段 大部分在显示调用finish()或者onBackPressed() ```java public final void setResult(int resultCode, Intent data) {//进行赋值 synchronized (this) { mResultCode = resultCode; mResultData = data; } } // Home 键 + 不保留后台 Activity 可触发 onDestroy protected void onDestroy() { if (DEBUG_LIFECYCLE) Slog.v(TAG, "onDestroy " + this); mCalled = true; // dismiss any dialogs we are managing. if (mManagedDialogs != null) { final int numDialogs = mManagedDialogs.size(); for (int i = 0; i < numDialogs; i++) { final ManagedDialog md = mManagedDialogs.valueAt(i); if (md.mDialog.isShowing()) { md.mDialog.dismiss(); } } mManagedDialogs = null; } // close any cursors we are managing. synchronized (mManagedCursors) { int numCursors = mManagedCursors.size(); for (int i = 0; i < numCursors; i++) { ManagedCursor c = mManagedCursors.get(i); if (c != null) { c.mCursor.close(); } } mManagedCursors.clear(); } // Close any open search dialog if (mSearchManager != null) { mSearchManager.stopSearch(); } if (mActionBar != null) { mActionBar.onDestroy(); } getApplication().dispatchActivityDestroyed(this); } private void finish(int finishTask) { if (mParent == null) { int resultCode; Intent resultData; synchronized (this) { resultCode = mResultCode; resultData = mResultData; } if (false) Log.v(TAG, "Finishing self: token=" + mToken); try { if (resultData != null) { resultData.prepareToLeaveProcess(this); } if (ActivityManager.getService() .finishActivity(mToken, resultCode, resultData, finishTask)) { mFinished = true; } } catch (RemoteException e) { // Empty } } else { mParent.finishFromChild(this); } } ``` ### 2.2 否 - 如果位于 finish 之后执行，信息已经无法放到传递的数据中 - 从代码可以看出 setResult 和 finish 类似生产者/消费者模型，setResult 负责写入数据，finish 负责读取数据 ### 2.3 线程安全问题 - Activity.mResultCode 和 Activity.mResultData 变量由 Activity 对象的锁进行保护 - 支持后台线程和 UI 线程分别进行 setResult 和 finish - 但是为什么需要加锁保护这两个信息？需要「解决什么问题」？ ### 2.4 API 设计/数据组装问题 - 底层 AMS 提供的接口的参数是 setResult 和 finish 的参数的组合形式，但是 Activity 为什么把一个接口拆分成两个接口给开发者使用？ - 使用方便。很多情况下调用者只关心 finish ，不需要理解太多的信息 ### 2.5 启动模式冲突 - 5.0以上 singleTask和singleInstance失效，重复启动时会重新创建实例 - 以下 则会直接收到`RESULT_CANCELED` ## 3. API 内部原理/数据处理流程 {% fullimage /images/study_plan/study_plan_4.png, alt,流程图 %} > 关键节点： - Client 端通过 AMP 把数据发送给 Server 端 AMS Binder 实体 - AMS 把数据包装成 ActivityResult 并保存在源 ActivityRecord 的 results 变量中 - AMS 通过 ApplicationThreadProxy 向 Client 端发送 pause 信息让栈顶 Activity 进入 paused 状态，并等待 Client 端回复或超时 - AMS 接收 Client 端已 paused 信息，恢复下一个获取焦点的 Activity ，读取之前保存在 ActivityRecord.results 变量的数据派发给 Client 端对应的 Activity - Client 端数据经过 ApplicationThread 对象、ActivityThread 对象的分发最后到达 Activity ## 4. startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题 ### 4.1 基本原则 > 源 Activity 和目标 Activity 无法在跨 Task 情况下通过 onActivityResult 传递数据 ### 4.2 Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调 [源码链接][2] ### 4.3 Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调 [源码链接][3] ### 4.4 通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task [1]: http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#266 [2]: http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#1196 [3]: http://androidxref.com/4.4.4_r1/xref/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java#1399]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan III - Activty]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-III%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan III - Activty date: 2018-03-18 17:42:20 tags: Android --- # Android学习计划 话题：理解Activity的启动模式。 1、Activity的启动模式有哪几种，分别用于什么场景？ 2、清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？ # 答案 ## 1. Activity的启动模式有哪几种，分别用于什么场景 > standard:标准模式 > 多实例模式，每次启动一个Activity都会重新创建新的实例，若启动者是除Activity之外的context则需指定` FLAG_ACTIVITY_NEW_TASK`标记位，创建新栈，不然报出异常 `android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag.` {% fullimage /images/study_plan/launchmode_standard.png, alt,Standard %} > singleTop:栈顶复用模式 (`FLAG_ACTIVITY_SINGLE_TOP`) > 若Activity实例已经存在栈顶，则启动时不会创建新的实例而是回调`onNewIntent()`方法,若不在栈顶则会创建新的实例。`onResume()`会被调用 {% fullimage /images/study_plan/launchmode_singletop.png, alt,SingleTop %} > singleTask:栈内复用模式 (`FLAG_ACTIVITY_NEW_TASK`) > 栈内只要存在Activity实例，再次启动都不会重新创建实例，只会回调`onNewIntent()`方法,并从栈内弹出所有实例之上的所有。适合作为入口点，作为主页面，因为只会启动一次。 {% fullimage /images/study_plan/launchmode_singletask1.png, alt,SingleTask %} {% fullimage /images/study_plan/launchmode_singletask2.png, alt, SingleTask %} `taskAffinity`代指Activity希望进入的Task栈，默认是应用包名 {% fullimage /images/study_plan/launchmode_singletask3.png, alt, SingleTask %} > singleInstance:单实例模式 > 具有singleTask所有特性，不过单独存在一个任务栈中。启动时会新开一个任务栈，并直接创建实例，压入新开的任务栈中。 ## 2. 清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？ > onNewIntent - singleTop模式下启动的Activity并在任务栈中存在 - singleTask模式启动的Activity并在任务栈中存在 - singleInstance模式启动的Activity并存在一个包含实例的栈 - 可以通过`setIntent(intent)`刷新intent数据 > onConfigurationChanged - 当系统配置信息发生变化时，系统调用该方法。需在AndroidManifests文件中处理了configChanges属性，才会被调用。默认会销毁当前Activity并重新创建一次来加载最新的配置信息。 - 若配置了configChanges 则不会重启Activity，若改变的配置不在你配置的选项中，则依然会重启，则不调用方法 - configChanges常用取值 - locale：选择一种新的语言 - touchscreen：更换手机屏幕 - keyboard：键盘类型发生改变 - keyboardHidden：键盘是否显示 - navigation：导航栏发生变化 - screenLayout：手机屏幕布局发生变化 - fontScale：手机字体大小发生改变 - orientation：手机屏幕切换（运行在Api13以上，需要添加screenSize） - screenSize：可用屏幕大小发生改变 - layoutDirection：手机屏幕左右或上下互换]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Study Plan II - Service]]></title>
    <url>%2F2018%2F03%2F18%2FAndroid-Study-Plan-II%2F</url>
    <content type="text"><![CDATA[--- title: Android Study Plan II - Service date: 2018-03-18 17:38:40 tags: Android --- # Android学习计划 话题：清晰地理解Service。 1、Service的start和bind状态有什么区别？ 2、同一个Service，先startService，然后再bindService，如何把它停止掉？ 3、你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？ 4、Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？ # 答案 {% fullimage /images/study\_plan/service\_lifecycle.png, alt,Service生命周期 %} ## 1.Service的start和bind状态有什么区别？ start启动Service,service有独立的生命周期，不依赖启动组件； 多次调用start方法，会重复调用onStartCommand方法；（判断service是否正在运行以避免多次调用） start启动的Service，需要stopService或stopSelf来停止（IntentService会自动调用）。 > 生命周期:onCreate()-\>onStartCommand()-\>onDestory() bind绑定的Service，依赖于启动组件，销毁后随之消失； 多次bind，只会调用一次onBind方法 > 生命周期:onCreate()-\>onBind()-\>onUnBind()-\>onDestory() ## 2.同一个Service，先startService，然后再bindService，如何把它停止掉？ 调用stopService和unbindService方法，顺序无关，当最后一次调用时，会进入Service的onDestory方法 ## 3.你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？ 4种返回值 ```java //版本兼容，在Service被杀死后，并不保证onStartCommand会被再一次调用 //Service被kill后，Service被重建，即会调用onCreate() public static final int START_STICKY_COMPATIBILITY = 0; /**在Service被杀死后，系统会尝试重启Service但不保存intent，会用一个null对象调用 onStartCommand方法（注意intent判空），除非有一些被发送的Intent对象在等待 Service被kill后，Service被重建、重启，即会调用onCreate()>onStartCommand()，intent对象为null。 启动服务，试用于媒体播放器之类，无限期等待*/ public static final int START_STICKY = 1; /**常规操作，除非被杀死之前还有组件调用startService，否则不保留状态并重启Service 直到接受到新的Intent对象，这个服务才会被重新创建 Service被kill后，Service没有重启*/ public static final int START_NOT_STICKY = 2; /**Service被杀死后，系统将会组织一次重启Service，在杀死前的最后一次传递的intent会被重新执行，不会传递空的intent 任意等待中的Intent对象会依次被发送。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。 */ public static final int START_REDELIVER_INTENT = 3; ``` ## 4.Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？ Service默认运行在主线程，所以生命周期的方法都会运行在主线程 ## 5.Service种类 > 按运行地点分类：`本地服务`和`远程服务` > 本地服务：依附主进程，主进程被kill后就会自动销毁 > 远程服务：运行在一个独立进程，需要利用AIDL通信需要占用一定资源而且是常驻形式 > 按运行类型分类：`前台服务`和`后台服务` > 前台服务：会在通知栏显示相关通知，当服务终止时通知栏消息即消失起到一定通知作用 > 后台服务：不会显示在前台，用户无感知，服务终止也不会有任何提示 > 按使用方式分类：`startService`，`bindService`和`混合使用` > startService：用于启动服务执行后台任务，不需要通信，停止需要stopService > bindService：启动的服务需要进行通信，unbindService停止 > 混合使用：停止服务需同时调用stopService，unbindService ## 6.IntentService介绍 继承Service的一个异步请求类，在IntentService有一个工作进程处理耗时操作，启动方式和普通Service一样。任务执行完毕后，IntentService会自动关闭。每次只会执行一个而不至于堵塞UI线程。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
