

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Activity启动过程 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Activity启动过程">
              
                Activity启动过程
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-01-02 21:35" pubdate>
        2019年1月2日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      117
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Activity启动过程</h1>
            
            <div class="markdown-body">
              <!--ams是怎么找到启动的那个activity 从framework的角度讲activity的启动流程(冷启动) Application attach之前干了些什么？APP启动进程的时候，会处理些什么？ onResume的时候，已经是第一帧绘制了吗？如果不是，那什么时候是呢？-->
<blockquote>
<p>下列源码分析是基于 Android 8.0源码</p>
</blockquote>
<p>Activity的启动过程分为两种：</p>
<ul>
<li><strong>根Activity的启动过程</strong>  -  指代根Actiivty的启动过程也可以认为是应用程序的启动过程</li>
<li><strong>普通Activity的启动过程</strong>  -  除启动应用程序启动的第一个Activity之外Activity的启动过程</li>
</ul>
<h2 id="根Activity启动过程"><a href="#根Activity启动过程" class="headerlink" title="根Activity启动过程"></a>根Activity启动过程</h2><p><img src="/images/根Activity启动过程.png" srcset="/img/loading.gif" alt="根Activity启动过程-冷启动"></p>
<blockquote>
<p>点击桌面的应用程序图标就是启动根Activity的入口，当我们点击某个应用程序图标时，就会通过Launcher请求AMS来启动该应用程序。</p>
<p>其中涉及了三个进程间的通信：<code>Launcher组件</code>，<code>AMS</code>，<code>Activity组件</code>。</p>
</blockquote>
<h3 id="Launcher请求AMS过程"><a href="#Launcher请求AMS过程" class="headerlink" title="Launcher请求AMS过程"></a>Launcher请求AMS过程</h3><p>当我们在应用程序启动器Launcher上点击一个应用的图标时，Launcher组件就会调用<code>startActivitySafely()</code>启动该App的根Activity。</p>
<p>配置根Activity，需要在AndroidManifest.xml中配置 相关属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;activity<br>           android:name=".MainActivity"<br>           android:label="@string/app_name"<br>           android:theme="@style/AppTheme.NoActionBar"&gt;<br>           &lt;intent-filter&gt;<br>               &lt;action android:name="android.intent.action.MAIN" /&gt;<br>               &lt;category android:name="android.intent.category.LAUNCHER" /&gt;<br>           &lt;/intent-filter&gt;<br>       &lt;/activity&gt;<br></code></pre></td></tr></table></figure>
<p>Launcher组件中<code>startActivitySafely()</code>相关操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">// packages/apps/Launcher3/src/com/android/Launcher3/Launcher.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> startActivitySafely(View v,Intent intent,ItemInfo item)&#123;<br>  ...<br>  <br>  intent.addFlags(Intent.FFLAG_ACTIVITY_NEW_TASK);<br>  <span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">if</span>(Utilities.ATLEAST_MARSHMELLOW<br>      &amp;&amp;(item <span class="hljs-keyword">instanceof</span> ShortcutInfo)<br>      &amp;&amp;(item.itemType == Favorites.ITEM_TYPE_SHORTCUT<br>      ||item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT)<br>       &amp;&amp; !((ShortcutInfo)item).isPromise())&#123;<br>      startShortcutIntentSafely(intent,optsBundle,item);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(user ==<span class="hljs-keyword">null</span> || user.equals(Process.myUserHandle()))&#123;<br>      startActivity(intent,optsBundle);<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>      LauncherAppsCompat.getInstance(<span class="hljs-keyword">this</span>).startActivityForProfile(intent.getComponent(),<br>                                    user,intent.getSourceBounds(),optsBundle)；<br>    &#125;<br>    return <span class="hljs-keyword">true</span>;<br>  &#125;<span class="hljs-keyword">catch</span>(ActivityNotFoundException|SecurityException e)&#123;<br>    ...<br>  &#125;<br>  return <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>设置启动Acticvity为<code>FLAG_ACTIVITY_NEW_TASK</code>保证根Activity在一个新任务栈中启动。<code>Launcher.java</code>继承了<code>Activity</code>接下来就到了<code>Acticvity.startActivity()</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/Activity.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> startActivity(Intent intent, @Nullable Bundle options) &#123;<br>        <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;<br>            startActivityForResult(intent, -1, options);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            startActivityForResult(intent, -1);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>接下来会走到<code>startActivityFroResult()</code>，第二个参数设为<code>-1</code>表明<em>Launcher不需要知道返回结果</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/Activity.java<br> Activity mParent;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> startActivityForResult(@RequiresPermission Intent intent, <span class="hljs-keyword">int</span> requestCode,<br>            @Nullable Bundle options) &#123;<br>        <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;<br>            options = transferSpringboardActivityOptions(options);<br>            Instrumentation.ActivityResult ar =<br>                mInstrumentation.execStartActivity(<br>                    <span class="hljs-keyword">this</span>, <br>              mMainThread.getApplicationThread(), /*ApplicationThread*/<br>              mToken, <br>              <span class="hljs-keyword">this</span>,<br>                    intent, requestCode, options);<br>          ...<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          ...<br>        &#125;<br>   ...<br> &#125;<br></code></pre></td></tr></table></figure>
<p><code>mParent</code>代表当前Activity的父类，由于<code>根Activity</code>还未创建出来，所以<code>mParent==null</code>成立。后续向下走就会调用到<code>Instrumentation.execStartActivity()</code>去继续启动Activity组件。</p>
<blockquote>
<p>Instrumentation用于监控应用程序和系统间的交互。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/    .java<br><span class="hljs-keyword">public</span> ActivityResult execStartActivity(<br>            Context who, IBinder contextThread, IBinder token, Activity target,<br>            Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options) &#123;<br>        ...<br>        <span class="hljs-keyword">try</span> &#123;<br>            intent.migrateExtraStreamToClipData();<br>            intent.prepareToLeaveProcess(who);<br>            <span class="hljs-keyword">int</span> result = ActivityManager.getService()<br>                .startActivity(whoThread, who.getBasePackageName(), intent,<br>                        intent.resolveTypeIfNeeded(who.getContentResolver()),<br>                        token, target != <span class="hljs-keyword">null</span> ? target.mEmbeddedID : <span class="hljs-keyword">null</span>,<br>                        requestCode, 0, <span class="hljs-keyword">null</span>, options);<br>            //检查启动Activity是否存在<br>            checkStartActivityResult(result, intent);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            throw new RuntimeException("Failure from system", e);<br>        &#125;<br>        return <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<!--`contenxtThread`是一个`IBinder对象`，实际指向的是`ApplicationThread`，用于进程间通信的Binder对象，可以-->
<p><code>ActivityManager.getService()</code>用于获取<code>AMS</code>的代理对象。实质上是把启动过程转移到了<code>AMS</code>上去执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/ActivityManager.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityManager getService() &#123;<br>        return IActivityManagerSingleton.get();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =<br>            new Singleton&lt;IActivityManager&gt;() &#123;<br>                @Override<br>                <span class="hljs-keyword">protected</span> IActivityManager create() &#123;<br>                    <span class="hljs-keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);<br>                    <span class="hljs-keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);<br>                    return am;<br>                &#125;<br>            &#125;;<br><br>//../android/util/Singleton.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> class Singleton&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T mInstance;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T create();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T get() &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) &#123;<br>                mInstance = create();<br>            &#125;<br>            return mInstance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第一次调用到<code>getService()</code>时，就会调用到<code>IActivityManagerSingleton.get()</code>，由源码可知，该类是一个单例类。</p>
<p>在其中先去获取名为<code>activity</code>的一个代理对象(<code>IBinder</code>)，后续实现利用了<code>AIDL</code>，根据<code>asInterface()</code>可以获得<code>IActivityManager</code>对象，他是AMS在本地的代理对象。然后就可以直接调用到<code>AMS</code>的<code>startActivity()</code>。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Launcher请求AMS时序图.png" srcset="/img/loading.gif" class="full-image" alt="Launcher请求AMS时序图" title="Launcher请求AMS时序图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>总结：</p>
<ul>
<li>用户点击桌面图标触发<code>startActivitySafely()</code>开始调用打开根Activity流程。</li>
<li><code>Launcher组件</code>会调用到<code>Activity.startActivity()</code>后调用到<code>Activity.startActivityForResult()</code></li>
<li>由于从Launcher启动，根Activity尚未建立，就会走到<code>Instrumentation.execStartActivity()</code>中</li>
<li>在<code>Instrumentation.execStartActivity()</code>中，实际调用的是<code>ActivityManager.getService()</code>去继续启动Activity</li>
<li>跟踪到<code>ActivityManager.getService()</code>实际返回的是一个<code>AMS</code>的本地代理对象<code>IActivityManager</code>，由前面学到的Binder机制中，这个代理对象是可以直接调用到<code>AMS</code>中的方法，所以<code>execStartActivity()</code>最终指向的是<code>AMS.startActivity()</code></li>
</ul>
<h3 id="AMS到ApplicationThread的调用过程"><a href="#AMS到ApplicationThread的调用过程" class="headerlink" title="AMS到ApplicationThread的调用过程"></a>AMS到ApplicationThread的调用过程</h3><p>Launcher请求到AMS后，后续逻辑由AMS继续执行。继续执行的是<code>AMS.startActivity()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../core/java/com/android/server/am/ActivityManagerService.java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startActivity(IApplicationThread caller, String callingPackage,<br>            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,<br>            <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;<br>        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,<br>                resultWho, requestCode, startFlags, profilerInfo, bOptions,<br>                UserHandle.getCallingUserId()/*获取调用者的UserId*/);<br>    &#125;<br><br>    //检测调用是否合法<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startActivityAsUser(IApplicationThread caller, String callingPackage,<br>            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,<br>            <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="hljs-keyword">int</span> userId) &#123;<br>        //判断调用者进程是否被隔离<br>        enforceNotIsolatedCaller("startActivity");<br>        //检测调用者权限<br>        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),<br>                userId, <span class="hljs-keyword">false</span>, ALLOW_FULL_ONLY, "startActivity", <span class="hljs-keyword">null</span>);<br>        // TODO: Switch to user app stacks here.<br>        return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,<br>                resolvedType, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, resultTo, resultWho, requestCode, startFlags,<br>                profilerInfo, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, bOptions, <span class="hljs-keyword">false</span>, userId, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>,<br>                "startActivityAsUser");<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> enforceNotIsolatedCaller(String caller) &#123;<br>        <span class="hljs-keyword">if</span> (UserHandle.isIsolated(Binder.getCallingUid())) &#123;<br>            throw new SecurityException("Isolated process not allowed to call " + caller);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>进入到<code>AMS.startActivity()</code>中，会调用到<code>startActivityAsUser()</code>，在这个方法中需要去判断调用是否合法。需要先<code>检测调用者进程是否被隔离</code>以及<code>调用者权限是否正确</code>。</p>
<p>前面都通过的话，就会调用到<code>ActivityStarter.startActivityMayWait()</code>。没有通过校验的话就会抛出<code>SecurityException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../core/java/com/android/server/am/ActivityStarter.java<br> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startActivityMayWait(IApplicationThread caller, <span class="hljs-keyword">int</span> callingUid,<br>            String callingPackage, Intent intent, String resolvedType,<br>            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>            IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> startFlags,<br>            ProfilerInfo profilerInfo, WaitResult outResult,<br>            Configuration globalConfig, Bundle bOptions, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">int</span> userId,<br>            IActivityContainer iContainer, TaskRecord inTask/*Activity所在任务栈*/, String reason/*启动理由*/) &#123;<br>   ...<br>                 //指向 startActivityLocked 方法<br>                 <span class="hljs-keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,<br>                    aInfo, rInfo, voiceSession, voiceInteractor,<br>                    resultTo, resultWho, requestCode, callingPid,<br>                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,<br>                    options, ignoreTargetSecurity, componentSpecified, outRecord, container,<br>                    inTask, reason);<br>   ...<br>   <br> &#125;<br><br> <span class="hljs-keyword">int</span> startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,<br>            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,<br>            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>            IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> callingPid, <span class="hljs-keyword">int</span> callingUid,<br>            String callingPackage, <span class="hljs-keyword">int</span> realCallingPid, <span class="hljs-keyword">int</span> realCallingUid, <span class="hljs-keyword">int</span> startFlags,<br>            ActivityOptions options, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">boolean</span> componentSpecified,<br>            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,<br>            TaskRecord inTask, String reason) &#123;<br>        //判断启动理由不可为空<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(reason)) &#123;<br>            throw new IllegalArgumentException("Need to specify a reason.");<br>        &#125;<br>        mLastStartReason = reason;<br>        mLastStartActivityTimeMs = System.currentTimeMillis();<br>        mLastStartActivityRecord[0] = <span class="hljs-keyword">null</span>;<br>        //指向 startActivity 方法<br>        mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,<br>                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,<br>                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,<br>                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,<br>                container, inTask);<br><br>        <span class="hljs-keyword">if</span> (outActivity != <span class="hljs-keyword">null</span>) &#123;<br>            // mLastStartActivityRecord[0] is set in the call to startActivity above.<br>            outActivity[0] = mLastStartActivityRecord[0];<br>        &#125;<br>        return mLastStartActivityResult;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>ActivityStarter</code>是Android7.0新加入的类，他是加载Activity的控制类，会收集所有的逻辑来决定如何将<code>Intent和Flags</code>转换为Activity，并将Activity和Task以及Stark相关联。</p>
<p>调用<code>startActivityLocked()</code>之后继续走向<code>ActivityStarter.startActivity()</code>过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">/** DO NOT call <span class="hljs-keyword">this</span> method directly. Use &#123;@link #startActivityLocked&#125; instead. */<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,<br>        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,<br>        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>        IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> callingPid, <span class="hljs-keyword">int</span> callingUid,<br>        String callingPackage, <span class="hljs-keyword">int</span> realCallingPid, <span class="hljs-keyword">int</span> realCallingUid, <span class="hljs-keyword">int</span> startFlags,<br>        ActivityOptions options, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">boolean</span> componentSpecified,<br>        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,<br>        TaskRecord inTask) &#123;<br>    <span class="hljs-keyword">int</span> err = ActivityManager.START_SUCCESS;<br>    // Pull the optional Ephemeral Installer-only bundle out of the options early.<br>    <span class="hljs-keyword">final</span> Bundle verificationBundle<br>            = options != <span class="hljs-keyword">null</span> ? options.popAppVerificationBundle() : <span class="hljs-keyword">null</span>;<br>    ProcessRecord callerApp = <span class="hljs-keyword">null</span>;<br>    //这个caller是一直从Launcher启动时就传下来的<br>    <span class="hljs-keyword">if</span> (caller != <span class="hljs-keyword">null</span>) &#123;<br>        callerApp = mService.getRecordForAppLocked(caller);<br>        <span class="hljs-keyword">if</span> (callerApp != <span class="hljs-keyword">null</span>) &#123;<br>            callingPid = callerApp.pid;<br>            callingUid = callerApp.info.uid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Slog.w(TAG, "Unable to find app <span class="hljs-keyword">for</span> caller " + caller<br>                    + " (pid=" + callingPid + ") when starting: "<br>                    + intent.toString());<br>            err = ActivityManager.START_PERMISSION_DENIED;<br>        &#125;<br>     &#125;<br>...<br>    <br>    ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid,<br>            callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),<br>            resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="hljs-keyword">null</span>,<br>            mSupervisor, container, options, sourceRecord);<br>    <span class="hljs-keyword">if</span> (outActivity != <span class="hljs-keyword">null</span>) &#123;<br>        outActivity[0] = r;<br>    &#125;<br>...<br>    doPendingActivityLaunchesLocked(<span class="hljs-keyword">false</span>);<br>    return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, <span class="hljs-keyword">true</span>,<br>            options, inTask, outActivity);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第16行代码 <code>caller!=null</code> 这个<code>caller</code>对象是从Launcher启动时就一直传递下来的，指向的是<code>Launcher所在的应用程序进程的ApplicationThread对象</code>。</p>
<p>第17行代码 <code>mService.getRecordForAppLocked(caller)</code> 得到的就是一个<code>ProgreeRecord</code>对象(<code>用于描述一个应用程序进程</code>)。该对象指的就是 <em>Launcher组件所运行的应用程序进程</em>。</p>
<p>第30行代码 <code>new ActivityRecord()</code> <code>ActivityRecord用来记录一个Activity的所有信息。</code>在这里<code>ActivityRecord</code>指的就是将要启动的Activity即根Activity。</p>
<p>第39行代码 继续调用<code>startActivity()</code>并传递当前记录的Activity信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> startActivity(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,<br>        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>        <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,<br>        ActivityRecord[] outActivity) &#123;<br>    <span class="hljs-keyword">int</span> result = START_CANCELED;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mService.mWindowManager.deferSurfaceLayout();<br>        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,<br>                startFlags, doResume, options, inTask, outActivity);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!ActivityManager.isStartResultSuccessful(result)<br>                &amp;&amp; mStartActivity.getTask() != <span class="hljs-keyword">null</span>) &#123;<br>            mStartActivity.getTask().removeActivity(mStartActivity);<br>        &#125;<br>        mService.mWindowManager.continueSurfaceLayout();<br>    &#125;<br>    <br>   <br>    postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId,  mSourceRecord,<br>            mTargetStack);<br><br>    return result;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> startActivityUnchecked(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,<br>        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>        <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,<br>        ActivityRecord[] outActivity) &#123;<br>  ...<br>    <span class="hljs-keyword">if</span> (mStartActivity.resultTo == <span class="hljs-keyword">null</span> &amp;&amp; mInTask == <span class="hljs-keyword">null</span> &amp;&amp; !mAddingToTask<br>            &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123;<br>        //如果是使用 singleTask模式启动 会新建一个任务栈用来存储Activity<br>        newTask = <span class="hljs-keyword">true</span>;<br>        result = setTaskFromReuseOrCreateNewTask(<br>                taskToAffiliate, preferredLaunchStackId, topStack);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mSourceRecord != <span class="hljs-keyword">null</span>) &#123;<br>        result = setTaskFromSourceRecord();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mInTask != <span class="hljs-keyword">null</span>) &#123;<br>        result = setTaskFromInTask();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        // This not being started from an existing activity, and not part of a new task...<br>        // just put it in the top task, though these days <span class="hljs-keyword">this</span> <span class="hljs-keyword">case</span> should never happen.<br>        setTaskToCurrentTopOrCreateNewTask();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result != START_SUCCESS) &#123;<br>        return result;<br>    &#125;  <br>  <br>  ...<br>     <span class="hljs-keyword">if</span> (mDoResume) &#123;<br>        <span class="hljs-keyword">final</span> ActivityRecord topTaskActivity =<br>                mStartActivity.getTask().topRunningActivityLocked();<br>        <span class="hljs-keyword">if</span> (!mTargetStack.isFocusable()<br>                || (topTaskActivity != <span class="hljs-keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay<br>                &amp;&amp; mStartActivity != topTaskActivity)) &#123;<br>            mTargetStack.ensureActivitiesVisibleLocked(<span class="hljs-keyword">null</span>, 0, !PRESERVE_WINDOWS);<br>            mWindowManager.executeAppTransition();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;<br>                mTargetStack.moveToFront("startActivityUnchecked");<br>            &#125;<br>            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,<br>                    mOptions);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mTargetStack.addRecentActivityLocked(mStartActivity);<br>    &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第30行代码 由于我们从Launcher启动根Activity时，设置启动标志为<code>FLAG_ACTIVITY_NEW_TASK</code>，所以就会走到<code>setTaskFromReuseOrCreateNewTask()</code>，这个方法主要是<em>管理任务栈，如果没有就会创建一个新的任务栈。</em></p>
<p>第62代码 最终调用<code>ActivityStackSupervisor.resumeDocusedStackTopActivityLocked()</code>继续启动Activity的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../core/java/com/android/server/am/ActivityStackSupervisor.java<br>    <span class="hljs-keyword">boolean</span> resumeFocusedStackTopActivityLocked(<br>            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;<br>        //判断当前的任务栈是否相同<br>        <span class="hljs-keyword">if</span> (targetStack != <span class="hljs-keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;<br>            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);<br>        &#125;<br>        //获取要启动Activity的所在栈的栈顶Activity且不处于停止状态<br>        <span class="hljs-keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();<br>        //由于Activity尚未启动 满足要求<br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-keyword">null</span> || r.state != RESUMED) &#123;<br>            mFocusedStack.resumeTopActivityUncheckedLocked(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.state == RESUMED) &#123;<br>            // Kick off any lingering app transitions form the MoveTaskToFront operation.<br>            mFocusedStack.executeAppTransition(targetOptions);<br>        &#125;<br>        return <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>由于要启动的Activity尚未启动，所以会继续调用<code>ActivityStack.resumeTopActivityUncheckedLocked()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../core/java/com/android/server/am/ActivityStack.java<br>    <span class="hljs-keyword">boolean</span> resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;<br>        <span class="hljs-keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;<br>            // Don't even start recursing.<br>            return <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            // Protect against recursion.<br>            mStackSupervisor.inResumeTopActivity = <span class="hljs-keyword">true</span>;<br>            result = resumeTopActivityInnerLocked(prev, options);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mStackSupervisor.inResumeTopActivity = <span class="hljs-keyword">false</span>;<br>        &#125;<br>        mStackSupervisor.checkReadyForSleepLocked();<br><br>        return result;<br>    &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123;<br>     ...<br>       //需要启动Activity<br>       mStackSupervisor.startSpecificActivityLocked(next, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<br>     ...<br>     return <span class="hljs-keyword">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../core/java/com/android/server/am/ActivityStackSupervisor.java<br><br><br>    <span class="hljs-keyword">void</span> startSpecificActivityLocked(ActivityRecord r,<br>            <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig) &#123;<br>        // 获取即将启动Activity所在的应用程序进程<br>        ProcessRecord app = mService.getProcessRecordLocked(r.processName,<br>                r.info.applicationInfo.uid, <span class="hljs-keyword">true</span>);<br><br>        r.getStack().setLaunchTime(r);<br><br>        <span class="hljs-keyword">if</span> (app != <span class="hljs-keyword">null</span> &amp;&amp; app.thread != <span class="hljs-keyword">null</span>) &#123;<br>           //进程已经启动<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0<br>                        || !"android".equals(r.info.packageName)) &#123;<br>                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,<br>                            mService.mProcessStats);<br>                &#125;<br>                realStartActivityLocked(r, app, andResume, checkConfig);<br>                return;<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                Slog.w(TAG, "Exception when starting activity "<br>                        + r.intent.getComponent().flattenToShortString(), e);<br>            &#125;<br>        &#125;<br>        //启动应用进程<br>        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="hljs-keyword">true</span>, 0,<br>                "activity", r.intent.getComponent(), <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
{% fullimage /images/AMS-应用程序进程通信.png,AMS-应用程序进程通信,AMS-应用程序进程通信%}
<p>这一节主要是从<code>ActivityManagerService</code>经过层层调用到达<code>ApplicationThread</code>的Activity启动方法。</p>
{% fullimage /images/AMS-ApplicationThread调用过程.png,AMS-ApplicationThread调用过程,AMS-ApplicationThread调用过程%}
<p><code>ActivityStack</code>:Activity的任务栈，从中获取需要进行操作的<code>ActivityRecord</code>进行操作。<em>在启动过程中，它的作用是检测当前栈顶Activity是否为要启动的Activity,不是就启动新Activity，是的话就重启，在这之前需要标记一下前Activity处于Pause状态。</em></p>
<p><code>ActivityStackSupervisor</code>:管理整个手机任务栈，管理着所有的<code>ActivityStack</code>。<em>在启动过程，它负责检查是否已有对应的应用进程在运行，如果有就直接启动Actiivty，没有的话则需新建一个应用进程。</em></p>
<p>总结：</p>
<ul>
<li>调用<code>AMS.startActivity()</code>实质调用其内部的<code>startActivityAsUser()</code>并在方法内部进行验证，判定<em>调用者进程是否隔离以及调用者权限是否正确</em></li>
<li>通过验证后，就到了<code>ActivityStarter.startActivityMayWait()</code>,并设置启动理由为<code>startActivityAsUser</code></li>
<li>向下调用到了<code>startActivityLocked()</code>，方法内部会去判定<code>reason</code>是否为空</li>
<li>不为空则走到<code>startActivity()</code>，该方法中主要<em>caller(<code>指向Launcher组件所运行的进程的ApplicationThread对象</code>)</em>，<em>callerApp(<code>指向Launcher组件所允许的应用程序进程</code>)</em>，基于<code>callerApp</code>生成对应的<code>ActivityRecord(记录即将要启动的Activity)</code>并存入<code>Activityrecord[]</code>中备用。</li>
<li>对应参数传入<code>startActivity()</code>的重载函数中，向下继续调用<code>startActivityUnchecked()</code></li>
<li><code>startActivityUnchecked()</code>主要是 创建新的<code>TaskRecord(记录任务栈信息)</code></li>
<li>向下切换到<code>ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()</code>，这个方法主要实现的是<code>寻找需要回复的栈顶Activity</code></li>
<li>内部实现由<code>ActivityStack.resumeTopActivityUncheckedLocked()</code>实现，这里又继续调用到<code>resumeTopActivityInnerLocked()</code></li>
<li>后续又切换回到<code>ActivityStackSupervisor.startSpecificActivityLocked()</code>，在该方法中<code>获取即将启动的Activity所在应用程序进程</code>，已启动的话调用<code>realStartActivityLocked()</code>，未启动的话就调用<code>startProcessLocked()</code>去启动进程</li>
</ul>
<h3 id="AMS启动应用进程"><a href="#AMS启动应用进程" class="headerlink" title="AMS启动应用进程"></a>AMS启动应用进程</h3><p>由于启动是根Activity，这时应用进程尚未启动，需要通过<code>AMS.startProcessLocked()</code>创建一个应用程序进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../core/java/com/android/server/am/ActivityManagerService.java<br>    <span class="hljs-keyword">final</span> ProcessRecord startProcessLocked(String processName,<br>            ApplicationInfo info, <span class="hljs-keyword">boolean</span> knownToBeDead, <span class="hljs-keyword">int</span> intentFlags,<br>            String hostingType, ComponentName hostingName, <span class="hljs-keyword">boolean</span> allowWhileBooting,<br>            <span class="hljs-keyword">boolean</span> isolated, <span class="hljs-keyword">boolean</span> keepIfLarge) &#123;<br>        return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,<br>                hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge,<br>                <span class="hljs-keyword">null</span> /* ABI override */, <span class="hljs-keyword">null</span> /* entryPoint */, <span class="hljs-keyword">null</span> /* entryPointArgs */,<br>                <span class="hljs-keyword">null</span> /* crashHandler */);<br>    &#125;  <br><br>    <span class="hljs-keyword">final</span> ProcessRecord startProcessLocked(String processName, ApplicationInfo info,<br>            <span class="hljs-keyword">boolean</span> knownToBeDead, <span class="hljs-keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,<br>            <span class="hljs-keyword">boolean</span> allowWhileBooting, <span class="hljs-keyword">boolean</span> isolated, <span class="hljs-keyword">int</span> isolatedUid, <span class="hljs-keyword">boolean</span> keepIfLarge,<br>            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;<br>        <span class="hljs-keyword">long</span> startTime = SystemClock.elapsedRealtime();<br>        ProcessRecord app;<br>        ...<br>        startProcessLocked(<br>             app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);<br>    &#125;    <br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> startProcessLocked(ProcessRecord app, String hostingType,<br>            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;<br>      ...<br>        //<br>        <span class="hljs-keyword">boolean</span> isActivityProcess = (entryPoint == <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (entryPoint == <span class="hljs-keyword">null</span>) entryPoint = "android.app.ActivityThread";<br>          <br>        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " +<br>                    app.processName);<br>            checkTime(startTime, "startProcess: asking zygote to start proc");<br>            ProcessStartResult startResult;<br>            <span class="hljs-keyword">if</span> (hostingType.equals("webview_service")) &#123;<br>                startResult = startWebView(entryPoint,<br>                        app.processName, uid, uid, gids, debugFlags, mountExternal,<br>                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,<br>                        app.info.dataDir, <span class="hljs-keyword">null</span>, entryPointArgs);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                startResult = Process.start(entryPoint,<br>                        app.processName, uid, uid, gids, debugFlags, mountExternal,<br>                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,<br>                        app.info.dataDir, invokeWith, entryPointArgs);<br>            &#125;<br>      ...<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>调用到<code>Process</code>的静态成员函数<code>start()</code>启动一个新的应用进程，指定了该进程的入口函数为<code>ActivityThread.main()</code>；因此创建应用进程结束时，逻辑就转移到了<code>ActivityThread.main()</code>上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java">Process.start() =&gt; ZygoteProcess.start() == LocalSocket连接 =&gt; ZygoteServer.runSelectLoop() =&gt; ZygoteConnection.processOneCommand() =&gt; <br>// 源码路径：java/com/android/internal/os/ZygoteConnection.java<br>Runnable processOneCommand(ZygoteServer zygoteServer) &#123;<br>...<br>  //从Zygote孵化一个新进程并赋予 pid<br>          pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,<br>                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,<br>                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,<br>                parsedArgs.instructionSet, parsedArgs.appDataDir);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (pid == 0) &#123;<br>                // in child<br>                zygoteServer.setForkChild();<br><br>                zygoteServer.closeServerSocket();<br>                IoUtils.closeQuietly(serverPipeFd);<br>                serverPipeFd = <span class="hljs-keyword">null</span>;<br><br>                return handleChildProc(parsedArgs, descriptors, childPipeFd,<br>                        parsedArgs.startChildZygote);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                // In the parent. A pid &lt; 0 indicates a failure and will be handled in<br>                // handleParentProc.<br>                IoUtils.closeQuietly(childPipeFd);<br>                childPipeFd = <span class="hljs-keyword">null</span>;<br>                handleParentProc(pid, descriptors, serverPipeFd);<br>                return <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            IoUtils.closeQuietly(childPipeFd);<br>            IoUtils.closeQuietly(serverPipeFd);<br>        &#125;<br>&#125;<br>  <br>=&gt; ZygoteConnection.handleChildProc()<br>  <br><span class="hljs-keyword">private</span> Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors,<br>            FileDescriptor pipeFd, <span class="hljs-keyword">boolean</span> isZygote) &#123;<br>  ...<br>             <span class="hljs-keyword">if</span> (!isZygote) &#123;<br>                return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,<br>                        <span class="hljs-keyword">null</span> /* classLoader */);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                return ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,<br>                        parsedArgs.remainingArgs, <span class="hljs-keyword">null</span> /* classLoader */);<br>            &#125;<br>&#125;<br><br>=&gt; ZygoteInit.zygoteInit()<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Runnable zygoteInit(<span class="hljs-keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader) &#123;<br>        <span class="hljs-keyword">if</span> (RuntimeInit.DEBUG) &#123;<br>            Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from zygote");<br>        &#125;<br><br>        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ZygoteInit");<br>        RuntimeInit.redirectLogStreams();<br><br>        RuntimeInit.commonInit();<br>        ZygoteInit.nativeZygoteInit();<br>        <br>        return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);<br>    &#125;<br><br>=&gt; RuntimeInit.applicationInit()<br>  <br> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable applicationInit(<span class="hljs-keyword">int</span> targetSdkVersion, String[] argv,<br>            ClassLoader classLoader) &#123;<br> ...<br>           // Remaining arguments are passed to the start class's <span class="hljs-keyword">static</span> main<br>        return findStaticMain(args.startClass, args.startArgs, classLoader);<br>&#125;<br><br>=&gt; RuntimeInit.findStaticMain()//此时完成了对   android.app.ActivityThread.main()的反射调用<br><br>      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable findStaticMain(String className, String[] argv,<br>            ClassLoader classLoader) &#123;<br>        Class&lt;?&gt; cl;<br>        <span class="hljs-keyword">try</span> &#123;<br>            cl = Class.forName(className, <span class="hljs-keyword">true</span>, classLoader);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>            throw new RuntimeException(<br>                    "Missing class when invoking <span class="hljs-keyword">static</span> main " + className,<br>                    ex);<br>        &#125;<br><br>        Method m;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m = cl.getMethod("main", new Class[] &#123; String[].class &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;<br>            throw new RuntimeException(<br>                    "Missing <span class="hljs-keyword">static</span> main on " + className, ex);<br>        &#125; <span class="hljs-keyword">catch</span> (SecurityException ex) &#123;<br>            throw new RuntimeException(<br>                    "Problem getting <span class="hljs-keyword">static</span> main on " + className, ex);<br>        &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>拓展：为什么不用Binder而是采用Socket进行 ZygoteProcess与AMS间的通信。</p>
<ol>
<li>父进程binder线程有锁，然后子进程的主线程一直在等其子线程(从父进程拷贝过来的子进程)的资源，但是其实父进程的子进程并没有被拷贝过来，造成死锁，所以<strong>fork不允许存在多线程</strong>。而非常巧的是<strong>Binder通讯偏偏就是多线程，所以干脆父进程（Zgote）这个时候就不使用binder线程</strong></li>
<li><code>fork()</code>不支持多线程，可能导致binder调用的时候，多个service发起fork请求，导致部分service创建失败</li>
</ol>
<blockquote>
<p>Zygote进程孵化出新的应用进程后，通过反射执行<code>ActivityThread.main()</code>，在该方法中会事先准备好<code>Looper以及MessageQueue</code>，继续调用<code>attach()</code>用进程绑定到<code>AMS</code>，然后开始消息循环，不断读取队列消息，并分发消息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/ActivityThread.java<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        //准备主线程Looper 以便Handler调用<br>        Looper.prepareMainLooper();<br>        //创建主进程的 ActivityThread<br>        ActivityThread thread = new ActivityThread();<br>        //将该进程进行绑定<br>        thread.attach(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;<br>            //保存进程对应的主线程Handler<br>            sMainThreadHandler = thread.getHandler();<br>        &#125;<br><br>        // End of event ActivityThreadMain.<br>        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>        //主线程开始消息循环<br>        Looper.loop();<br>    <br>  &#125;<br>  <span class="hljs-keyword">final</span> ApplicationThread mAppThread = new ApplicationThread();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> attach(<span class="hljs-keyword">boolean</span> system) &#123;<br>      ...<br>        <span class="hljs-keyword">if</span> (!system) &#123;<br>          ...<br>            <span class="hljs-keyword">final</span> IActivityManager mgr = ActivityManager.getService();<br>            <span class="hljs-keyword">try</span> &#123;<br>                mgr.attachApplication(mAppThread);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>                throw ex.rethrowFromSystemServer();<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          ...<br>        &#125;<br>      ...<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>AMS</code>attach的是<code>ActivityThread</code>的代理对象<code>ApplicationThread</code>，然后<code>AMS</code>就可以通过代理对象对主线程进行操作。</p>
<p><strong>至此，应用进程创建完毕，并且已建立主线程完毕并开启了消息循环。</strong></p>
<h3 id="创建并绑定Application"><a href="#创建并绑定Application" class="headerlink" title="创建并绑定Application"></a>创建并绑定Application</h3><p>这时应用进程以及主线程已经创造完毕，接下来就是要创建<code>Application</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../core/java/com/android/server/am/ActivityManagerService.java<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> attachApplication(IApplicationThread thread) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            //获取当前进程的id<br>            <span class="hljs-keyword">int</span> callingPid = Binder.getCallingPid();<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> origId = Binder.clearCallingIdentity();<br>            attachApplicationLocked(thread, callingPid);<br>            Binder.restoreCallingIdentity(origId);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> attachApplicationLocked(IApplicationThread thread,<br>            <span class="hljs-keyword">int</span> pid) &#123;<br>        <br>        ProcessRecord app;<br>        <span class="hljs-keyword">long</span> startTime = SystemClock.uptimeMillis();<br>        <span class="hljs-keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123;<br>            <span class="hljs-keyword">synchronized</span> (mPidsSelfLocked) &#123;<br>                app = mPidsSelfLocked.get(pid);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            app = <span class="hljs-keyword">null</span>;<br>        &#125;<br>       // 如果获取进程信息为空 直接杀死进程并退出<br>       <span class="hljs-keyword">if</span> (app == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pid &gt; 0 &amp;&amp; pid != MY_PID) &#123;<br>                killProcessQuiet(pid);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    thread.scheduleExit();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    // Ignore exceptions.<br>                &#125;<br>            &#125;<br>            return <span class="hljs-keyword">false</span>;<br>        &#125;<br>        //创建死亡代理，被kill后可以通知AMS<br>        <span class="hljs-keyword">try</span> &#123;<br>            AppDeathRecipient adr = new AppDeathRecipient(<br>                    app, pid, thread);<br>            thread.asBinder().linkToDeath(adr, 0);<br>            app.deathRecipient = adr;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            app.resetPackageList(mProcessStats);<br>            startProcessLocked(app, "link fail", processName);<br>            return <span class="hljs-keyword">false</span>;<br>        &#125;<br>      <br>        <span class="hljs-keyword">try</span> &#123;<br>         ...<br>           <span class="hljs-keyword">if</span> (app.instr != <span class="hljs-keyword">null</span>) &#123;<br>                //绑定Application<br>                thread.bindApplication(processName, appInfo, providers,<br>                        app.instr.mClass,<br>                        profilerInfo, app.instr.mArguments,<br>                        app.instr.mWatcher,<br>                        app.instr.mUiAutomationConnection, testMode,<br>                        mBinderTransactionTrackingEnabled, enableTrackAllocation,<br>                        isRestrictedBackupMode || !normalMode, app.persistent,<br>                        new Configuration(getGlobalConfiguration()), app.compat,<br>                        getCommonServicesLocked(app.isolated),<br>                        mCoreSettingsObserver.getCoreSettingsLocked(),<br>                        buildSerial);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                thread.bindApplication(processName, appInfo, providers, <span class="hljs-keyword">null</span>, profilerInfo,<br>                        <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, testMode,<br>                        mBinderTransactionTrackingEnabled, enableTrackAllocation,<br>                        isRestrictedBackupMode || !normalMode, app.persistent,<br>                        new Configuration(getGlobalConfiguration()), app.compat,<br>                        getCommonServicesLocked(app.isolated),<br>                        mCoreSettingsObserver.getCoreSettingsLocked(),<br>                        buildSerial);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>          ...<br>          //启动失败 重启当前进程<br>          startProcessLocked(app, "bind fail", processName);<br>          return <span class="hljs-keyword">false</span>;<br>        &#125;<br>        //准备启动根Activity<br>         <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;<br>                    didSomething = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);<br>                badApp = <span class="hljs-keyword">true</span>;<br>         &#125;<br>      <br>       //绑定Service以及BroadCast的Application<br>       ...<br>       <span class="hljs-keyword">if</span> (badApp) &#123;<br>            //如果以上组件启动出错，则需要杀死进程并移除记录<br>            app.kill("error during init", <span class="hljs-keyword">true</span>);<br>            handleAppDiedLocked(app, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>            return <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        //如果以上没有启动任何组件，那么didSomething为<span class="hljs-keyword">false</span><br>        <span class="hljs-keyword">if</span> (!didSomething) &#123;<br>            //调整进程的oom_adj值， oom_adj相当于一种优先级<br>            //如果应用进程没有运行任何组件，那么当内存出现不足时，该进程是最先被系统“杀死”<br>            updateOomAdjLocked();<br>        &#125;<br>        return <span class="hljs-keyword">true</span>;<br><br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>AMS.attachApplicationLocked()</code>主要做了两步：</p>
<ul>
<li><p><code>thread.bindApplication()</code>：绑定Application到ActivityThread上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/ActivityThread.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> bindApplication(String processName, ApplicationInfo appInfo,<br>                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,<br>                ProfilerInfo profilerInfo, Bundle instrumentationArgs,<br>                IInstrumentationWatcher instrumentationWatcher,<br>                IUiAutomationConnection instrumentationUiConnection, <span class="hljs-keyword">int</span> debugMode,<br>                <span class="hljs-keyword">boolean</span> enableBinderTracking, <span class="hljs-keyword">boolean</span> trackAllocation,<br>                <span class="hljs-keyword">boolean</span> isRestrictedBackupMode, <span class="hljs-keyword">boolean</span> persistent, Configuration config,<br>                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,<br>                String buildSerial) &#123;<br><br>            <span class="hljs-keyword">if</span> (services != <span class="hljs-keyword">null</span>) &#123;<br>                // Setup the service cache in the ServiceManager<br>                ServiceManager.initServiceCache(services);<br>            &#125;<br><br>            setCoreSettings(coreSettings);<br><br>            AppBindData data = new AppBindData();<br>            //设置Data参数<br>            ...<br>            sendMessage(H.BIND_APPLICATION, data);<br>        &#125;<br><br><span class="hljs-keyword">private</span> class H extends Handler &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BIND_APPLICATION         = 110;<br>  ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> handleMessage(Message msg) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, "&gt;&gt;&gt; handling: " + codeToString(msg.what));<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                 <span class="hljs-keyword">case</span> BIND_APPLICATION:<br>                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication");<br>                    AppBindData data = (AppBindData)msg.obj;<br>                    handleBindApplication(data);<br>                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                    <span class="hljs-keyword">break</span>;<br>                ...<br>            &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>H</code>相当于<code>ApplcationThread</code>与<code>ActivityThread</code>的中间人，其中<code>AMS与ActivityThread通信靠 ApplicationThread，ActivityThread与ApplicationThread通信靠Handler</code>。</p>
<p>这里涉及的就是<strong><code>Android的主线程消息循环模型</code></strong>。</p>
</blockquote>
<p>在<code>ApplicationThread</code>发送<code>BIND_APPLICATION</code>标识的消息时，<code>H</code>接收到消息，调用<code>handleBindApplication()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java">Instrumentation mInstrumentation;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> handleBindApplication(AppBindData data) &#123;<br>  ...<br>  //获取LoaderApk对象<br>  data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);<br>  //创建进程对应的Android运行环境ContextImpl<br>  <span class="hljs-keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="hljs-keyword">this</span>, data.info);<br>  <br>  <span class="hljs-keyword">final</span> InstrumentationInfo ii;<br>   <span class="hljs-keyword">if</span> (ii != <span class="hljs-keyword">null</span>) &#123;<br>     ...<br>   &#125;<span class="hljs-keyword">else</span>&#123;<br>     //Activity中所有的生命周期方法都会被Instrumentation监控<br>     //只要是执行Activity生命周期的相关方法前后一定会调用Instrumentation相关方法<br>     mInstrumentation = new Instrumentation();<br>   &#125;<br>  <br>  <span class="hljs-keyword">try</span> &#123;<br>            //准备创建Application对象<br>            Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);<br>            mInitialApplication = app;<br>            ...<br>             //加载对应进程中的ContentProvider<br>            installContentProviders(app, data.providers);<br>            <span class="hljs-keyword">try</span> &#123;<br>                mInstrumentation.onCreate(data.instrumentationArgs);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                throw new RuntimeException(<br>                    "Exception thrown in onCreate() of "<br>                    + data.instrumentationName + ": " + e.toString(), e);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                //调用Application的onCreate方法<br>                mInstrumentation.callApplicationOnCreate(app);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>                    throw new RuntimeException(<br>                        "Unable to create application " + app.getClass().getName()<br>                        + ": " + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            StrictMode.setThreadPolicy(savedPolicy);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>handleBindApplicaiton()</code>主要是<strong>为了让一个Java的进程可以加入到Android中</strong>。</p>
<p>主要执行步骤有以下几步：</p>
<ol>
<li>设置进程的基本参数，例如进程名，时区等，配置资源以及兼容性设计。</li>
<li>创建进程对应的<code>ContextImpl、LoaderApk以及Application</code>对象，并初始化<code>ContentProvide以及Application</code>。</li>
<li>创建<code>Instrumentation</code>监听Activity的生命周期。(<strong>一个进程对应一个Instrumentation实例</strong>)</li>
</ol>
</li>
<li><p><code>mStackSuperVisor.attachApplicationLocked()</code>：启动根Activity</p>
<p>在该方法中<code>Application</code>已经绑定到进程上，接下来就是启动根Activity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../core/java/com/android/server/am/ActivityStackSupervisor.java<br><span class="hljs-keyword">boolean</span> attachApplicationLocked(ProcessRecord app) <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">final</span> String processName = app.processName;<br>        <span class="hljs-keyword">boolean</span> didSomething = <span class="hljs-keyword">false</span>;<br>        //ActivityStackSupervisor里面 维护者所有ActiivtyStack<br>        //通过循环 找到前台任务栈顶端的Activity<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123;<br>            ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123;<br>                <span class="hljs-keyword">final</span> ActivityStack stack = stacks.get(stackNdx);<br>                <span class="hljs-keyword">if</span> (!isFocusedStack(stack)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                ActivityRecord hr = stack.topRunningActivityLocked();<br>                <span class="hljs-keyword">if</span> (hr != <span class="hljs-keyword">null</span>) &#123;<br>                    //前台待启动的Activity与当前新建的进程一致时，启动这个Actiivty<br>                    <span class="hljs-keyword">if</span> (hr.app == <span class="hljs-keyword">null</span> &amp;&amp; app.uid == hr.info.applicationInfo.uid<br>                            &amp;&amp; processName.equals(hr.processName)) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">if</span> (realStartActivityLocked(hr, app, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>)) &#123;<br>                                didSomething = <span class="hljs-keyword">true</span>;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                            throw e;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!didSomething) &#123;<br>            ensureActivitiesVisibleLocked(<span class="hljs-keyword">null</span>, 0, !PRESERVE_WINDOWS);<br>        &#125;<br>        return didSomething;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>需要启动的Activity所在进程已经启动时，开始准备启动根Activity <code>realStartActivityLocked()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> realStartActivityLocked(ActivityRecord r, ProcessRecord app,<br>            <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig) <span class="hljs-keyword">throws</span> RemoteException &#123;    <br>  ...<br>app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,<br>                    System.identityHashCode(r), r.info,<br>                    // TODO: Have <span class="hljs-keyword">this</span> take the merged configuration instead of separate global and<br>                    // override configs.<br>                    mergedConfiguration.getGlobalConfiguration(),<br>                    mergedConfiguration.getOverrideConfiguration(), r.compat,<br>                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,<br>                    r.persistentState, results, newIntents, !andResume,<br>                    mService.isNextTransitionForward(), profilerInfo);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的<code>app.thread</code>的类型为<code>IApplicationThread</code>，它的实现是<code>ActivityThread</code>的内部类<code>ApplicationThread</code>。<code>app</code>指代的是要启动的Acttvity所在的应用进程。因此这段代码指的就是要在目标应用程序进程中启动Activity。</p>
</li>
</ul>
{% fullimage /images/AMS启动进程并绑定Application.png,AMS启动进程并绑定Application,AMS启动进程并绑定Application%}
<h3 id="ActivityThread启动Activity过程"><a href="#ActivityThread启动Activity过程" class="headerlink" title="ActivityThread启动Activity过程"></a>ActivityThread启动Activity过程</h3><p>这时Activity的启动过程从<code>AMS</code>切换到了<code>ApplicationThread</code>中，最后是调用到了<code>ApplicationThread.scheduleLaunchActivity()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/ActivityThread.java        <br>@Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> scheduleLaunchActivity(Intent intent, IBinder token, <span class="hljs-keyword">int</span> ident,<br>                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,<br>                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,<br>                <span class="hljs-keyword">int</span> procState, Bundle state, PersistableBundle persistentState,<br>                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,<br>                <span class="hljs-keyword">boolean</span> notResumed, <span class="hljs-keyword">boolean</span> isForward, ProfilerInfo profilerInfo) &#123;<br><br>            updateProcessState(procState, <span class="hljs-keyword">false</span>);<br><br>            ActivityClientRecord r = new ActivityClientRecord();<br><br>            r.token = token;<br>            r.ident = ident;<br>            r.intent = intent;<br>            r.referrer = referrer;<br>            r.voiceInteractor = voiceInteractor;<br>            r.activityInfo = info;<br>            r.compatInfo = compatInfo;<br>            r.state = state;<br>            r.persistentState = persistentState;<br><br>            r.pendingResults = pendingResults;<br>            r.pendingIntents = pendingNewIntents;<br><br>            r.startsNotResumed = notResumed;<br>            r.isForward = isForward;<br><br>            r.profilerInfo = profilerInfo;<br><br>            r.overrideConfig = overrideConfig;<br>            updatePendingConfiguration(curConfig);<br><br>            sendMessage(H.LAUNCH_ACTIVITY, r);<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>将需要启动Activity的参数封装成<code>ActivityClientRecord</code>，在调用<code>sendMessage()</code>设置类型为<code>LAUNCH_ACTIVITY</code>，并将<code>ActivityClientRecord</code>传递过去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> H mh = new H();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> sendMessage(<span class="hljs-keyword">int</span> what, Object obj, <span class="hljs-keyword">int</span> arg1, <span class="hljs-keyword">int</span> arg2, <span class="hljs-keyword">boolean</span> async) &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(<br>            TAG, "SCHEDULE " + what + " " + mH.codeToString(what)<br>            + ": " + arg1 + " / " + obj);<br>        Message msg = Message.obtain();<br>        msg.what = what;<br>        msg.obj = obj;<br>        msg.arg1 = arg1;<br>        msg.arg2 = arg2;<br>        <span class="hljs-keyword">if</span> (async) &#123;<br>            msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>        &#125;<br>        mH.sendMessage(msg);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里的<code>mh</code>指的就是<code>H</code>，这个<code>H</code>是<code>ActivityThread</code>的内部类并继承自<code>Handler</code>，是主线程的消息管理类。因为<code>ApplicationThread</code>是一个Binder，它的调用逻辑是在<code>Binder线程池</code>中。所以这里就要把执行逻辑切换到主线程中，就使用了<code>Handler</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> class H extends Handler &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LAUNCH_ACTIVITY         = 100;<br>  ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> handleMessage(Message msg) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, "&gt;&gt;&gt; handling: " + codeToString(msg.what));<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                <span class="hljs-keyword">case</span> LAUNCH_ACTIVITY: &#123;<br>                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");<br>                    //将传递过来的msg.obj转化为ActivityClientRecord<br>                    <span class="hljs-keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;<br>                    // 获得LoaderApk类型的对象并赋值到ActivityClientRecoed中<br>                    r.packageInfo = getPackageInfoNoCheck(<br>                            r.activityInfo.applicationInfo, r.compatInfo);<br>                    handleLaunchActivity(r, <span class="hljs-keyword">null</span>, "LAUNCH_ACTIVITY");<br>                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                &#125; <span class="hljs-keyword">break</span>;<br>                ...<br>            &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>每一个Android程序都是打包在一个Apk文件中的，一个Apk文件包含了一个Android程序中的所有资源。应用程序进程在启动一个Activity组件时，需要将它所属的Apk文件加载进来，以便访问内部资源。<code>ActivityThread</code>内部使用<code>LoaderApk</code>描述一个已加载的Apk文件。</p>
</blockquote>
<p>继续向下调用到<code>handleLauncheActivity()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;<br>...<br>  //Window开始初始化<br>  WindowManagerGlobal.initialize();<br>  //准备启动Activity<br>  Activity a = performLaunchActivity(r, customIntent);<br><br>  <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>) &#123;<br>           r.createdConfig = new Configuration(mConfiguration);<br>           reportSizeConfigurations(r);<br>           Bundle oldState = r.state;<br>           //将要启动的Activity状态设为 Resumed 标记待激活<br>           handleResumeActivity(r.token, <span class="hljs-keyword">false</span>, r.isForward,<br>                   !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);<br>           <span class="hljs-keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;<br>               performPauseActivityIfNeeded(r, reason);<br>               <span class="hljs-keyword">if</span> (r.isPreHoneycomb()) &#123;<br>                   r.state = oldState;<br>               &#125;<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           // If there was an error, <span class="hljs-keyword">for</span> any reason, tell the activity manager to stop us.<br>           <span class="hljs-keyword">try</span> &#123;<br>               //停止Activity启动<br>               ActivityManager.getService()<br>                   .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="hljs-keyword">null</span>,<br>                           Activity.DONT_FINISH_TASK_WITH_ACTIVITY);<br>           &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>               throw ex.rethrowFromSystemServer();<br>           &#125;<br>       &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先调用<code>performLaunchActivity()</code>开始准备启动Activity，内部会调用Activity的<code>Oncreate(),onStart(),onRestoreInstaceState()</code></p>
<p><code>performResumeActivity()</code>对应生命周期的<code>onResume()</code>，之后开始调用View的绘制，Activity的内容开始渲染到Window上面，直到我们看见绘制结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>performLaunchActivity()</code>主要完成了如下几件事：</p>
<ol>
<li><p>从<code>ActivityClientRecord</code>中获取待启动的Activity的组件信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ActivityInfo aInfo = r.activityInfo;<br>       <span class="hljs-keyword">if</span> (r.packageInfo == <span class="hljs-keyword">null</span>) &#123;<br>           //获取LoadedApk对象<br>           r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,<br>                   Context.CONTEXT_INCLUDE_CODE);<br>       &#125;<br>       //获取组件信息<br>       ComponentName component = r.intent.getComponent();<br>       <span class="hljs-keyword">if</span> (component == <span class="hljs-keyword">null</span>) &#123;<br>           component = r.intent.resolveActivity(<br>               mInitialApplication.getPackageManager());<br>           r.intent.setComponent(component);<br>       &#125;<br>   <br>       <span class="hljs-keyword">if</span> (r.activityInfo.targetActivity != <span class="hljs-keyword">null</span>) &#123;<br>           component = new ComponentName(r.activityInfo.packageName,<br>                   r.activityInfo.targetActivity);<br>       &#125;<br></code></pre></td></tr></table></figure>
<p><code>ComponentName</code>包含了<code>Activity组件的包名及类名。</code></p>
</li>
<li><p>通过<code>Instrumentation.newActivity()</code>使用类加载器创建Activity对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Activity activity = <span class="hljs-keyword">null</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           java.lang.ClassLoader cl = appContext.getClassLoader();<br>           //用类加载器创建该Activity的实例<br>           activity = mInstrumentation.newActivity(<br>                   cl, component.getClassName(), r.intent);<br>           StrictMode.incrementExpectedActivityCount(activity.getClass());<br>           r.intent.setExtrasClassLoader(cl);<br>           r.intent.prepareToEnterProcess();<br>           <span class="hljs-keyword">if</span> (r.state != <span class="hljs-keyword">null</span>) &#123;<br>               r.state.setClassLoader(cl);<br>           &#125;<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>         ...<br>       &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">// ../android/app/Instrumentation.java   <br><span class="hljs-keyword">public</span> Activity newActivity(ClassLoader cl, String className,<br>            Intent intent)<br>            <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException,<br>            ClassNotFoundException &#123;<br>        return (Activity)cl.loadClass(className).newInstance();<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>通过<code>LoadedApk.makeApplication()</code>创建Application对象（<em>实际是判空</em>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">Application app = r.packageInfo.makeApplication(<span class="hljs-keyword">false</span>, mInstrumentation);<br><br>// ../android/app/LoaderApk.java<br>    <span class="hljs-keyword">public</span> Application makeApplication(<span class="hljs-keyword">boolean</span> forceDefaultAppClass,<br>            Instrumentation instrumentation) &#123;<br>        <span class="hljs-keyword">if</span> (mApplication != <span class="hljs-keyword">null</span>) &#123;<br>            return mApplication;<br>        &#125;<br>      <br>      //新建Application<br>      <span class="hljs-keyword">try</span> &#123;<br>            java.lang.ClassLoader cl = getClassLoader();<br>            <span class="hljs-keyword">if</span> (!mPackageName.equals("android")) &#123;<br>                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,<br>                        "initializeJavaContextClassLoader");<br>                initializeJavaContextClassLoader();<br>                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>            &#125;<br>            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="hljs-keyword">this</span>);<br>            app = mActivityThread.mInstrumentation.newApplication(<br>                    cl, appClass, appContext);<br>            appContext.setOuterContext(app);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">if</span> (!mActivityThread.mInstrumentation.onException(app, e)) &#123;<br>                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                throw new RuntimeException(<br>                    "Unable to instantiate application " + appClass<br>                    + ": " + e.toString(), e);<br>            &#125;<br>        &#125;<br>        mActivityThread.mAllApplications.add(app);<br>        mApplication = app;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>由于在前面<code>创建并绑定Application</code>过程中的<code>bindApplication()</code>就已经创建好了<code>Application</code>，所以这一步只是起到了预防作用，并且不会重复创建。</p>
</li>
<li><p>创建<code>ContextImpl</code>对象，并通过<code>Activity.attach()</code>完成一些重要数据的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ContextImpl appContext = createBaseContextForActivity(r);<br>appContext.setOuterContext(activity);<br>                activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,<br>                        r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>                        r.embeddedID, r.lastNonConfigurationInstances, config,<br>                        r.referrer, r.voiceInteractor, window, r.configCallback);<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>ContextImpl</code>是一个很重要的数据结构，它是<code>Context</code>的具体实现，Context中大部分逻辑都是由<code>ContextImpl</code>完成的。<code>ContextImpl</code>是通过<code>Activity.attach()</code>与Activity进行关联的。除此之外，在<code>attach()</code>中，<strong>Activity还会完成Window的创建并建立关联</strong>，这样当Window接收到外部输入事件以后就可以将事件传递给Activity。</p>
</blockquote>
</li>
<li><p>调用<code>Activity.oncreate()</code>加载用户界面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">mInstrumentation.callActivityOnCreate(activity, r.state);<br><br>mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,<br>                                    r.persistentState);<br><br>mInstrumentation.callActivityOnPostCreate(activity, r.state,<br>                                r.persistentState);<br><br>// ../android/app/Instrumentation.java  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> callActivityOnCreate(Activity activity, Bundle icicle) &#123;<br>        prePerformCreate(activity);<br>        activity.performCreate(icicle);<br>        postPerformCreate(activity);<br>    &#125;<br><br>// ../android/app/Activity.java<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> performCreate(Bundle icicle) &#123;<br>        restoreHasCurrentPermissionRequest(icicle);<br>        onCreate(icicle);<br>        mActivityTransitionState.readState(icicle);<br>        performCreateCommon();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>最终调用到<code>Activity.performCreate()</code>后续调用到<code>Activity.onCreate()</code>这时根Activity就启动了，完成了整个启动流程。</p>
</li>
</ol>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ActivityThread启动Activity过程.png" srcset="/img/loading.gif" class="full-image" alt="ActivityThread启动Activity过程" title="ActivityThread启动Activity过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="根Activity启动过程中涉及的进程"><a href="#根Activity启动过程中涉及的进程" class="headerlink" title="根Activity启动过程中涉及的进程"></a>根Activity启动过程中涉及的进程</h3><p>根Activity启动过程中涉及四个进程：<strong>Zygote进程、Launcher进程、AMS所在进程（System Server进程），应用程序进程。</strong></p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/根启动Activity过程中的进程切换.png" srcset="/img/loading.gif" class="full-image" alt="根启动Activity过程中的进程切换" title="根启动Activity过程中的进程切换"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p>首先<code>Launcher进程</code>会向<code>AMS</code>发起<code>创建根Activity请求</code>，<code>AMS</code>会判断根Activity所需的应用程序进程是否存在并处于启动状态</p>
<ul>
<li><code>未启动</code>：请求<code>Zygote进程</code>创建应用程序进程</li>
<li><code>已启动</code>：<code>AMS</code>直接启动Activity</li>
</ul>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上述章节的描述，可以基本厘清<code>根Activity的启动过程</code></p>
<blockquote>
<p>当我们按下桌面上的应用程序快捷启动方式时，<code>Launcher</code>会调用<code>Activity.startActivity()</code>并设置启动FLAG为<code>FLAG_ACTIVITY_NEW_TASK</code>给根Activity设置任务栈，实质上是调用<code>Instrumentation.execStartActivity()</code>尝试启动Activity，这是一个跨进程的过程，利用<code>IActivityManager</code>与<code>AMS</code>进行通信。</p>
<p><code>AMS</code>就会记录下要启动的Activity信息，并且跨进程通知Launcher进入<code>pause</code>状态，<code>Launcher</code>进入<code>pause</code>状态后，跨进程通知<code>AMS</code>自己已被<code>pause</code>。<code>AMS</code>会回调用自身的<code>startActivty()</code>去继续启动根Activity，这一步需要校验(调用者是否有权限调用)，检验通过后，发现此时应用进程尚未启动，<code>AMS</code>就会启动新的进程，并且在新进程中创建<code>ActivityThread</code>对象并执行<code>main()</code>进程初始化。</p>
<p>应用进程启动完毕后，<code>AMS</code>通知主线程绑定<code>Application</code>并启动根Activity。这时<code>AMS</code>会通过<code>ApplicationThread</code>回调到我们的进程，这一步也是一个跨进程的过程，利用<code>ApplicationThread</code>这个Binder对象。由于回调逻辑是在<code>Binder线程池</code>中进行的，所以需要通过<code>Handler H</code>将其切回主线程，发出的消息是<code>LAUNCH_ACTIVITY</code>，对应调用<code>handleLaunchActivity</code>，在这个方法中完成了根Activity的创建以及启动。接着在<code>handleResumeActivity()</code>中开始Activity的内容绘制，直到绘制完成被我们看见。</p>
</blockquote>
<h2 id="普通Activity启动过程"><a href="#普通Activity启动过程" class="headerlink" title="普通Activity启动过程"></a>普通Activity启动过程</h2><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/普通Activity启动过程.png" srcset="/img/loading.gif" class="full-image" alt="普通Activity启动过程" title="普通Activity启动过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p>普通Activity启动过程相比于根Activity启动过程，只保留了两步：<code>AMS到Application的调用过程</code>,<code>ActivityThread启动Activity过程</code>。</p>
<p>涉及的进程也只剩：<code>AMS所在进程(System Server进程)，应用程序进程</code>。</p>
</blockquote>
<h3 id="相同进程的启动过程"><a href="#相同进程的启动过程" class="headerlink" title="相同进程的启动过程"></a>相同进程的启动过程</h3><blockquote>
<p>例如LoadingActivity -&gt; MainActivity</p>
</blockquote>
<ol>
<li>LoadingActivity组件会向<code>AMS</code>发送一个启动MainActivity的请求，其实就是内部通过<code>Instrumentation</code>尝试启动Activity(<code>execStartActivity</code>)，这是一个跨进程过程，会调用<code>AMS</code>的<code>startActivity()</code></li>
<li><code>AMS</code>会保存下来<code>MainActivity</code>的组件信息，然后向<code>LoadingActivity</code>发送一个进入中止状态的进程间通信请求。<em>这也就是为什么老Activity的<code>onPause()</code>会执行在新Activity的启动之前的原因。</em></li>
<li><code>LoadingActivity</code>进入中止状态后会通知到<code>AMS</code>继续向下执行<code>MainActivity</code>的启动，由于发现应用进程已经存在，所以<code>AMS</code>直接通过<code>ApplicationThread</code>回调到应用进程，这也是一个跨进程过程。</li>
<li>由于<code>ApplicationThread</code>是一个Binder对象，回调逻辑在<code>Binder线程池</code>中完成，需要通过<code>Handler H</code>切回到主线程，并发出<code>LAUNCH_ACTIVITY</code>消息，对应调用<code>handleLaunchActivity</code>。</li>
<li>继续向下完成<code>MainActivity</code>的创建和启动，然后在<code>handleResumeActivity()</code>中完成View的绘制，直到绘制完成展示在用户面前结束。</li>
</ol>
<h3 id="新进程的启动过程"><a href="#新进程的启动过程" class="headerlink" title="新进程的启动过程"></a>新进程的启动过程</h3><blockquote>
<p>例如LoadingActivity -&gt; MainActivity设置了<code>android:process=&quot;:remote&quot;</code></p>
<p>类似根Activity的启动过程，不过起始点是从<code>LoadingActivity</code>开始</p>
</blockquote>
<ol>
<li>LoadingActivity组件会向<code>AMS</code>发送一个启动MainActivity的请求，其实就是内部通过<code>Instrumentation</code>尝试启动Activity(<code>execStartActivity</code>)，这是一个跨进程过程，会调用<code>AMS</code>的<code>startActivity()</code></li>
<li><code>AMS</code>会保存下来<code>MainActivity</code>的组件信息，然后向<code>LoadingActivity</code>发送一个进入中止状态的进程间通信请求。<em>这也就是为什么老Activity的<code>onPause()</code>会执行在新Activity的启动之前的原因。</em></li>
<li><code>LoadingActivity</code>进入中止状态后会通知到<code>AMS</code>继续向下执行<code>MainActivity</code>的启动，此时发现用来运行的<code>:remote</code>进程不存在，就会调用<code>AMS</code>去启动新的应用进程，并且在新进程中创建<code>ActrivityThread(*主进程*)</code>并执行<code>main()</code>进行初始化。</li>
<li>应用进程启动完毕之后，向<code>AMS</code>发送一个启动完成的请求，<code>AMS</code>就会通知主线程<code>ActivityThread</code>去创建并绑定<code>Application</code>，绑定完成后，通知<code>AMS</code>绑定完成。<code>AMS</code>直接通过<code>ApplicationThread</code>回调到应用进程，这也是一个跨进程过程。</li>
<li>由于<code>ApplicationThread</code>是一个Binder对象，回调逻辑在<code>Binder线程池</code>中完成，需要通过<code>Handler H</code>切回到主线程，并发出<code>LAUNCH_ACTIVITY</code>消息，对应调用<code>handleLaunchActivity</code>。</li>
<li><!--App启动优化，如何检测启动耗时 -->
</li>
</ol>
<p>临时记录：</p>
<p>Andorid 9.0 源码添加了Sleeping状态，功能类似Stop</p>
<p>handleSleeping() 可能导致 onSaveInstanceState()存储异常</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/01/03/include、merge-ViewStub相关/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">include、merge及ViewStub相关</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/01/02/Java-泛型/">
                        <span class="hidden-mobile">Java - 泛型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
