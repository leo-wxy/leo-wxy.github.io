

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Activity启动过程 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/solarized-light.min.css">
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
                Activity启动过程
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-01-02 21:35" pubdate>
        2019年1月2日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      115
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Activity启动过程</h1>
            
            <div class="markdown-body" id="post-body">
              <!--ams是怎么找到启动的那个activity 从framework的角度讲activity的启动流程(冷启动) Application attach之前干了些什么？APP启动进程的时候，会处理些什么？ onResume的时候，已经是第一帧绘制了吗？如果不是，那什么时候是呢？-->
<blockquote>
<p>下列源码分析是基于 Android 8.0源码</p>
</blockquote>
<p>Activity的启动过程分为两种：</p>
<ul>
<li><strong>根Activity的启动过程</strong>  -  指代根Actiivty的启动过程也可以认为是应用程序的启动过程</li>
<li><strong>普通Activity的启动过程</strong>  -  除启动应用程序启动的第一个Activity之外Activity的启动过程</li>
</ul>
<h2 id="根Activity启动过程"><a href="#根Activity启动过程" class="headerlink" title="根Activity启动过程"></a>根Activity启动过程</h2><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/根Activity启动过程.png" srcset="/img/loading.gif" class="full-image" alt="根Activity启动过程-冷启动" title="根Activity启动过程-冷启动"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p>点击桌面的应用程序图标就是启动根Activity的入口，当我们点击某个应用程序图标时，就会通过Launcher请求AMS来启动该应用程序。</p>
<p>其中涉及了三个进程间的通信：<code>Launcher组件</code>，<code>AMS</code>，<code>Activity组件</code>。</p>
</blockquote>
<h3 id="Launcher请求AMS过程"><a href="#Launcher请求AMS过程" class="headerlink" title="Launcher请求AMS过程"></a>Launcher请求AMS过程</h3><p>当我们在应用程序启动器Launcher上点击一个应用的图标时，Launcher组件就会调用<code>startActivitySafely()</code>启动该App的根Activity。</p>
<p>配置根Activity，需要在AndroidManifest.xml中配置 相关属性</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>
           <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MainActivity"</span>
           <span class="hljs-attr">android:label</span>=<span class="hljs-string">"@string/app_name"</span>
           <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@style/AppTheme.NoActionBar"</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;</span>
           <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span></code></pre>
<p>Launcher组件中<code>startActivitySafely()</code>相关操作</p>
<pre><code class="hljs java"><span class="hljs-comment">// packages/apps/Launcher3/src/com/android/Launcher3/Launcher.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startActivitySafely</span><span class="hljs-params">(View v,Intent intent,ItemInfo item)</span></span>&#123;
  ...
  
  intent.addFlags(Intent.FFLAG_ACTIVITY_NEW_TASK);
  <span class="hljs-keyword">try</span>&#123;
    <span class="hljs-keyword">if</span>(Utilities.ATLEAST_MARSHMELLOW
      &amp;&amp;(item <span class="hljs-keyword">instanceof</span> ShortcutInfo)
      &amp;&amp;(item.itemType == Favorites.ITEM_TYPE_SHORTCUT
      ||item.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT)
       &amp;&amp; !((ShortcutInfo)item).isPromise())&#123;
      startShortcutIntentSafely(intent,optsBundle,item);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(user ==<span class="hljs-keyword">null</span> || user.equals(Process.myUserHandle()))&#123;
      startActivity(intent,optsBundle);
    &#125; <span class="hljs-keyword">else</span>&#123;
      LauncherAppsCompat.getInstance(<span class="hljs-keyword">this</span>).startActivityForProfile(intent.getComponent(),
                                    user,intent.getSourceBounds(),optsBundle)；
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  &#125;<span class="hljs-keyword">catch</span>(ActivityNotFoundException|SecurityException e)&#123;
    ...
  &#125;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;</code></pre>
<p>设置启动Acticvity为<code>FLAG_ACTIVITY_NEW_TASK</code>保证根Activity在一个新任务栈中启动。<code>Launcher.java</code>继承了<code>Activity</code>接下来就到了<code>Acticvity.startActivity()</code>中</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/Activity.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;
            startActivityForResult(intent, -<span class="hljs-number">1</span>, options);
        &#125; <span class="hljs-keyword">else</span> &#123;
            startActivityForResult(intent, -<span class="hljs-number">1</span>);
        &#125;
    &#125;</code></pre>
<p>接下来会走到<code>startActivityFroResult()</code>，第二个参数设为<code>-1</code>表明<em>Launcher不需要知道返回结果</em></p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/Activity.java</span>
 Activity mParent;

 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivityForResult</span><span class="hljs-params">(@RequiresPermission Intent intent, <span class="hljs-keyword">int</span> requestCode,
            @Nullable Bundle options)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;
            options = transferSpringboardActivityOptions(options);
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    <span class="hljs-keyword">this</span>, 
              mMainThread.getApplicationThread(), <span class="hljs-comment">/*ApplicationThread*/</span>
              mToken, 
              <span class="hljs-keyword">this</span>,
                    intent, requestCode, options);
          ...
        &#125;<span class="hljs-keyword">else</span>&#123;
          ...
        &#125;
   ...
 &#125;</code></pre>
<p><code>mParent</code>代表当前Activity的父类，由于<code>根Activity</code>还未创建出来，所以<code>mParent==null</code>成立。后续向下走就会调用到<code>Instrumentation.execStartActivity()</code>去继续启动Activity组件。</p>
<blockquote>
<p>Instrumentation用于监控应用程序和系统间的交互。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/    .java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title">execStartActivity</span><span class="hljs-params">(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options)</span> </span>&#123;
        ...
        <span class="hljs-keyword">try</span> &#123;
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
            <span class="hljs-keyword">int</span> result = ActivityManager.getService()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != <span class="hljs-keyword">null</span> ? target.mEmbeddedID : <span class="hljs-keyword">null</span>,
                        requestCode, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, options);
            <span class="hljs-comment">//检查启动Activity是否存在</span>
            checkStartActivityResult(result, intent);
        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Failure from system"</span>, e);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;</code></pre>
<!--`contenxtThread`是一个`IBinder对象`，实际指向的是`ApplicationThread`，用于进程间通信的Binder对象，可以-->
<p><code>ActivityManager.getService()</code>用于获取<code>AMS</code>的代理对象。实质上是把启动过程转移到了<code>AMS</code>上去执行</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityManager.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityManager <span class="hljs-title">getService</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> IActivityManagerSingleton.get();
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =
            <span class="hljs-keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;
                    <span class="hljs-keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    <span class="hljs-keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);
                    <span class="hljs-keyword">return</span> am;
                &#125;
            &#125;;

<span class="hljs-comment">//../android/util/Singleton.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> T mInstance;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
            <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) &#123;
                mInstance = create();
            &#125;
            <span class="hljs-keyword">return</span> mInstance;
        &#125;
    &#125;
&#125;</code></pre>
<p>第一次调用到<code>getService()</code>时，就会调用到<code>IActivityManagerSingleton.get()</code>，由源码可知，该类是一个单例类。</p>
<p>在其中先去获取名为<code>activity</code>的一个代理对象(<code>IBinder</code>)，后续实现利用了<code>AIDL</code>，根据<code>asInterface()</code>可以获得<code>IActivityManager</code>对象，他是AMS在本地的代理对象。然后就可以直接调用到<code>AMS</code>的<code>startActivity()</code>。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Launcher请求AMS时序图.png" srcset="/img/loading.gif" class="full-image" alt="Launcher请求AMS时序图" title="Launcher请求AMS时序图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>总结：</p>
<ul>
<li>用户点击桌面图标触发<code>startActivitySafely()</code>开始调用打开根Activity流程。</li>
<li><code>Launcher组件</code>会调用到<code>Activity.startActivity()</code>后调用到<code>Activity.startActivityForResult()</code></li>
<li>由于从Launcher启动，根Activity尚未建立，就会走到<code>Instrumentation.execStartActivity()</code>中</li>
<li>在<code>Instrumentation.execStartActivity()</code>中，实际调用的是<code>ActivityManager.getService()</code>去继续启动Activity</li>
<li>跟踪到<code>ActivityManager.getService()</code>实际返回的是一个<code>AMS</code>的本地代理对象<code>IActivityManager</code>，由前面学到的Binder机制中，这个代理对象是可以直接调用到<code>AMS</code>中的方法，所以<code>execStartActivity()</code>最终指向的是<code>AMS.startActivity()</code></li>
</ul>
<h3 id="AMS到ApplicationThread的调用过程"><a href="#AMS到ApplicationThread的调用过程" class="headerlink" title="AMS到ApplicationThread的调用过程"></a>AMS到ApplicationThread的调用过程</h3><p>Launcher请求到AMS后，后续逻辑由AMS继续执行。继续执行的是<code>AMS.startActivity()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityManagerService.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,
            <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;
        <span class="hljs-keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions,
                UserHandle.getCallingUserId()<span class="hljs-comment">/*获取调用者的UserId*/</span>);
    &#125;

    <span class="hljs-comment">//检测调用是否合法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityAsUser</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode,
            <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="hljs-keyword">int</span> userId)</span> </span>&#123;
        <span class="hljs-comment">//判断调用者进程是否被隔离</span>
        enforceNotIsolatedCaller(<span class="hljs-string">"startActivity"</span>);
        <span class="hljs-comment">//检测调用者权限</span>
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, <span class="hljs-keyword">false</span>, ALLOW_FULL_ONLY, <span class="hljs-string">"startActivity"</span>, <span class="hljs-keyword">null</span>);
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Switch to user app stacks here.</span>
        <span class="hljs-keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="hljs-number">1</span>, callingPackage, intent,
                resolvedType, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, resultTo, resultWho, requestCode, startFlags,
                profilerInfo, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, bOptions, <span class="hljs-keyword">false</span>, userId, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>,
                <span class="hljs-string">"startActivityAsUser"</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enforceNotIsolatedCaller</span><span class="hljs-params">(String caller)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (UserHandle.isIsolated(Binder.getCallingUid())) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<span class="hljs-string">"Isolated process not allowed to call "</span> + caller);
        &#125;
    &#125;</code></pre>
<p>进入到<code>AMS.startActivity()</code>中，会调用到<code>startActivityAsUser()</code>，在这个方法中需要去判断调用是否合法。需要先<code>检测调用者进程是否被隔离</code>以及<code>调用者权限是否正确</code>。</p>
<p>前面都通过的话，就会调用到<code>ActivityStarter.startActivityMayWait()</code>。没有通过校验的话就会抛出<code>SecurityException</code>异常。</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityStarter.java</span>
 <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityMayWait</span><span class="hljs-params">(IApplicationThread caller, <span class="hljs-keyword">int</span> callingUid,
            String callingPackage, Intent intent, String resolvedType,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> startFlags,
            ProfilerInfo profilerInfo, WaitResult outResult,
            Configuration globalConfig, Bundle bOptions, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">int</span> userId,
            IActivityContainer iContainer, TaskRecord inTask<span class="hljs-comment">/*Activity所在任务栈*/</span>, String reason<span class="hljs-comment">/*启动理由*/</span>)</span> </span>&#123;
   ...
                 <span class="hljs-comment">//指向 startActivityLocked 方法</span>
                 <span class="hljs-keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                    aInfo, rInfo, voiceSession, voiceInteractor,
                    resultTo, resultWho, requestCode, callingPid,
                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                    options, ignoreTargetSecurity, componentSpecified, outRecord, container,
                    inTask, reason);
   ...
   
 &#125;

 <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">startActivityLocked</span><span class="hljs-params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> callingPid, <span class="hljs-keyword">int</span> callingUid,
            String callingPackage, <span class="hljs-keyword">int</span> realCallingPid, <span class="hljs-keyword">int</span> realCallingUid, <span class="hljs-keyword">int</span> startFlags,
            ActivityOptions options, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">boolean</span> componentSpecified,
            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
            TaskRecord inTask, String reason)</span> </span>&#123;
        <span class="hljs-comment">//判断启动理由不可为空</span>
        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(reason)) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Need to specify a reason."</span>);
        &#125;
        mLastStartReason = reason;
        mLastStartActivityTimeMs = System.currentTimeMillis();
        mLastStartActivityRecord[<span class="hljs-number">0</span>] = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">//指向 startActivity 方法</span>
        mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,
                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,
                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,
                container, inTask);

        <span class="hljs-keyword">if</span> (outActivity != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// mLastStartActivityRecord[0] is set in the call to startActivity above.</span>
            outActivity[<span class="hljs-number">0</span>] = mLastStartActivityRecord[<span class="hljs-number">0</span>];
        &#125;
        <span class="hljs-keyword">return</span> mLastStartActivityResult;
    &#125;</code></pre>
<p><code>ActivityStarter</code>是Android7.0新加入的类，他是加载Activity的控制类，会收集所有的逻辑来决定如何将<code>Intent和Flags</code>转换为Activity，并将Activity和Task以及Stark相关联。</p>
<p>调用<code>startActivityLocked()</code>之后继续走向<code>ActivityStarter.startActivity()</code>过程</p>
<pre><code class="hljs java"><span class="hljs-comment">/** DO NOT call this method directly. Use &#123;<span class="hljs-doctag">@link</span> #startActivityLocked&#125; instead. */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
        IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> callingPid, <span class="hljs-keyword">int</span> callingUid,
        String callingPackage, <span class="hljs-keyword">int</span> realCallingPid, <span class="hljs-keyword">int</span> realCallingUid, <span class="hljs-keyword">int</span> startFlags,
        ActivityOptions options, <span class="hljs-keyword">boolean</span> ignoreTargetSecurity, <span class="hljs-keyword">boolean</span> componentSpecified,
        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
        TaskRecord inTask)</span> </span>&#123;
    <span class="hljs-keyword">int</span> err = ActivityManager.START_SUCCESS;
    <span class="hljs-comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span>
    <span class="hljs-keyword">final</span> Bundle verificationBundle
            = options != <span class="hljs-keyword">null</span> ? options.popAppVerificationBundle() : <span class="hljs-keyword">null</span>;
    ProcessRecord callerApp = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">//这个caller是一直从Launcher启动时就传下来的</span>
    <span class="hljs-keyword">if</span> (caller != <span class="hljs-keyword">null</span>) &#123;
        callerApp = mService.getRecordForAppLocked(caller);
        <span class="hljs-keyword">if</span> (callerApp != <span class="hljs-keyword">null</span>) &#123;
            callingPid = callerApp.pid;
            callingUid = callerApp.info.uid;
        &#125; <span class="hljs-keyword">else</span> &#123;
            Slog.w(TAG, <span class="hljs-string">"Unable to find app for caller "</span> + caller
                    + <span class="hljs-string">" (pid="</span> + callingPid + <span class="hljs-string">") when starting: "</span>
                    + intent.toString());
            err = ActivityManager.START_PERMISSION_DENIED;
        &#125;
     &#125;
...
    
    ActivityRecord r = <span class="hljs-keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,
            callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),
            resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="hljs-keyword">null</span>,
            mSupervisor, container, options, sourceRecord);
    <span class="hljs-keyword">if</span> (outActivity != <span class="hljs-keyword">null</span>) &#123;
        outActivity[<span class="hljs-number">0</span>] = r;
    &#125;
...
    doPendingActivityLaunchesLocked(<span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">return</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, <span class="hljs-keyword">true</span>,
            options, inTask, outActivity);
&#125;</code></pre>
<p>第16行代码 <code>caller!=null</code> 这个<code>caller</code>对象是从Launcher启动时就一直传递下来的，指向的是<code>Launcher所在的应用程序进程的ApplicationThread对象</code>。</p>
<p>第17行代码 <code>mService.getRecordForAppLocked(caller)</code> 得到的就是一个<code>ProgreeRecord</code>对象(<code>用于描述一个应用程序进程</code>)。该对象指的就是 <em>Launcher组件所运行的应用程序进程</em>。</p>
<p>第30行代码 <code>new ActivityRecord()</code> <code>ActivityRecord用来记录一个Activity的所有信息。</code>在这里<code>ActivityRecord</code>指的就是将要启动的Activity即根Activity。</p>
<p>第39行代码 继续调用<code>startActivity()</code>并传递当前记录的Activity信息。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,
        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
        <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,
        ActivityRecord[] outActivity)</span> </span>&#123;
    <span class="hljs-keyword">int</span> result = START_CANCELED;
    <span class="hljs-keyword">try</span> &#123;
        mService.mWindowManager.deferSurfaceLayout();
        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,
                startFlags, doResume, options, inTask, outActivity);
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-keyword">if</span> (!ActivityManager.isStartResultSuccessful(result)
                &amp;&amp; mStartActivity.getTask() != <span class="hljs-keyword">null</span>) &#123;
            mStartActivity.getTask().removeActivity(mStartActivity);
        &#125;
        mService.mWindowManager.continueSurfaceLayout();
    &#125;
    
   
    postStartActivityProcessing(r, result, mSupervisor.getLastStack().mStackId,  mSourceRecord,
            mTargetStack);

    <span class="hljs-keyword">return</span> result;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityUnchecked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,
        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
        <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,
        ActivityRecord[] outActivity)</span> </span>&#123;
  ...
    <span class="hljs-keyword">if</span> (mStartActivity.resultTo == <span class="hljs-keyword">null</span> &amp;&amp; mInTask == <span class="hljs-keyword">null</span> &amp;&amp; !mAddingToTask
            &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">//如果是使用 singleTask模式启动 会新建一个任务栈用来存储Activity</span>
        newTask = <span class="hljs-keyword">true</span>;
        result = setTaskFromReuseOrCreateNewTask(
                taskToAffiliate, preferredLaunchStackId, topStack);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mSourceRecord != <span class="hljs-keyword">null</span>) &#123;
        result = setTaskFromSourceRecord();
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mInTask != <span class="hljs-keyword">null</span>) &#123;
        result = setTaskFromInTask();
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// This not being started from an existing activity, and not part of a new task...</span>
        <span class="hljs-comment">// just put it in the top task, though these days this case should never happen.</span>
        setTaskToCurrentTopOrCreateNewTask();
    &#125;
    <span class="hljs-keyword">if</span> (result != START_SUCCESS) &#123;
        <span class="hljs-keyword">return</span> result;
    &#125;  
  
  ...
     <span class="hljs-keyword">if</span> (mDoResume) &#123;
        <span class="hljs-keyword">final</span> ActivityRecord topTaskActivity =
                mStartActivity.getTask().topRunningActivityLocked();
        <span class="hljs-keyword">if</span> (!mTargetStack.isFocusable()
                || (topTaskActivity != <span class="hljs-keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay
                &amp;&amp; mStartActivity != topTaskActivity)) &#123;
            mTargetStack.ensureActivitiesVisibleLocked(<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, !PRESERVE_WINDOWS);
            mWindowManager.executeAppTransition();
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;
                mTargetStack.moveToFront(<span class="hljs-string">"startActivityUnchecked"</span>);
            &#125;
            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                    mOptions);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        mTargetStack.addRecentActivityLocked(mStartActivity);
    &#125;
  ...
&#125;</code></pre>
<p>第30行代码 由于我们从Launcher启动根Activity时，设置启动标志为<code>FLAG_ACTIVITY_NEW_TASK</code>，所以就会走到<code>setTaskFromReuseOrCreateNewTask()</code>，这个方法主要是<em>管理任务栈，如果没有就会创建一个新的任务栈。</em></p>
<p>第62代码 最终调用<code>ActivityStackSupervisor.resumeDocusedStackTopActivityLocked()</code>继续启动Activity的流程。</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityStackSupervisor.java</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeFocusedStackTopActivityLocked</span><span class="hljs-params">(
            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;
        <span class="hljs-comment">//判断当前的任务栈是否相同</span>
        <span class="hljs-keyword">if</span> (targetStack != <span class="hljs-keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;
            <span class="hljs-keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
        &#125;
        <span class="hljs-comment">//获取要启动Activity的所在栈的栈顶Activity且不处于停止状态</span>
        <span class="hljs-keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();
        <span class="hljs-comment">//由于Activity尚未启动 满足要求</span>
        <span class="hljs-keyword">if</span> (r == <span class="hljs-keyword">null</span> || r.state != RESUMED) &#123;
            mFocusedStack.resumeTopActivityUncheckedLocked(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r.state == RESUMED) &#123;
            <span class="hljs-comment">// Kick off any lingering app transitions form the MoveTaskToFront operation.</span>
            mFocusedStack.executeAppTransition(targetOptions);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;</code></pre>
<p>由于要启动的Activity尚未启动，所以会继续调用<code>ActivityStack.resumeTopActivityUncheckedLocked()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityStack.java</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityUncheckedLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;
            <span class="hljs-comment">// Don't even start recursing.</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;

        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// Protect against recursion.</span>
            mStackSupervisor.inResumeTopActivity = <span class="hljs-keyword">true</span>;
            result = resumeTopActivityInnerLocked(prev, options);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            mStackSupervisor.inResumeTopActivity = <span class="hljs-keyword">false</span>;
        &#125;
        mStackSupervisor.checkReadyForSleepLocked();

        <span class="hljs-keyword">return</span> result;
    &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityInnerLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;
     ...
       <span class="hljs-comment">//需要启动Activity</span>
       mStackSupervisor.startSpecificActivityLocked(next, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);
     ...
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
   &#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityStackSupervisor.java</span>


    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startSpecificActivityLocked</span><span class="hljs-params">(ActivityRecord r,
            <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> </span>&#123;
        <span class="hljs-comment">// 获取即将启动Activity所在的应用程序进程</span>
        ProcessRecord app = mService.getProcessRecordLocked(r.processName,
                r.info.applicationInfo.uid, <span class="hljs-keyword">true</span>);

        r.getStack().setLaunchTime(r);

        <span class="hljs-keyword">if</span> (app != <span class="hljs-keyword">null</span> &amp;&amp; app.thread != <span class="hljs-keyword">null</span>) &#123;
           <span class="hljs-comment">//进程已经启动</span>
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="hljs-number">0</span>
                        || !<span class="hljs-string">"android"</span>.equals(r.info.packageName)) &#123;
                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                            mService.mProcessStats);
                &#125;
                realStartActivityLocked(r, app, andResume, checkConfig);
                <span class="hljs-keyword">return</span>;
            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
                Slog.w(TAG, <span class="hljs-string">"Exception when starting activity "</span>
                        + r.intent.getComponent().flattenToShortString(), e);
            &#125;
        &#125;
        <span class="hljs-comment">//启动应用进程</span>
        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="hljs-keyword">true</span>, <span class="hljs-number">0</span>,
                <span class="hljs-string">"activity"</span>, r.intent.getComponent(), <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
    &#125;</code></pre>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/AMS-应用程序进程通信.png" srcset="/img/loading.gif" class="full-image" alt="AMS-应用程序进程通信" title="AMS-应用程序进程通信"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>这一节主要是从<code>ActivityManagerService</code>经过层层调用到达<code>ApplicationThread</code>的Activity启动方法。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/AMS-ApplicationThread调用过程.png" srcset="/img/loading.gif" class="full-image" alt="AMS-ApplicationThread调用过程" title="AMS-ApplicationThread调用过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p><code>ActivityStack</code>:Activity的任务栈，从中获取需要进行操作的<code>ActivityRecord</code>进行操作。<em>在启动过程中，它的作用是检测当前栈顶Activity是否为要启动的Activity,不是就启动新Activity，是的话就重启，在这之前需要标记一下前Activity处于Pause状态。</em></p>
<p><code>ActivityStackSupervisor</code>:管理整个手机任务栈，管理着所有的<code>ActivityStack</code>。<em>在启动过程，它负责检查是否已有对应的应用进程在运行，如果有就直接启动Actiivty，没有的话则需新建一个应用进程。</em></p>
<p>总结：</p>
<ul>
<li>调用<code>AMS.startActivity()</code>实质调用其内部的<code>startActivityAsUser()</code>并在方法内部进行验证，判定<em>调用者进程是否隔离以及调用者权限是否正确</em></li>
<li>通过验证后，就到了<code>ActivityStarter.startActivityMayWait()</code>,并设置启动理由为<code>startActivityAsUser</code></li>
<li>向下调用到了<code>startActivityLocked()</code>，方法内部会去判定<code>reason</code>是否为空</li>
<li>不为空则走到<code>startActivity()</code>，该方法中主要<em>caller(<code>指向Launcher组件所运行的进程的ApplicationThread对象</code>)</em>，<em>callerApp(<code>指向Launcher组件所允许的应用程序进程</code>)</em>，基于<code>callerApp</code>生成对应的<code>ActivityRecord(记录即将要启动的Activity)</code>并存入<code>Activityrecord[]</code>中备用。</li>
<li>对应参数传入<code>startActivity()</code>的重载函数中，向下继续调用<code>startActivityUnchecked()</code></li>
<li><code>startActivityUnchecked()</code>主要是 创建新的<code>TaskRecord(记录任务栈信息)</code></li>
<li>向下切换到<code>ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()</code>，这个方法主要实现的是<code>寻找需要回复的栈顶Activity</code></li>
<li>内部实现由<code>ActivityStack.resumeTopActivityUncheckedLocked()</code>实现，这里又继续调用到<code>resumeTopActivityInnerLocked()</code></li>
<li>后续又切换回到<code>ActivityStackSupervisor.startSpecificActivityLocked()</code>，在该方法中<code>获取即将启动的Activity所在应用程序进程</code>，已启动的话调用<code>realStartActivityLocked()</code>，未启动的话就调用<code>startProcessLocked()</code>去启动进程</li>
</ul>
<h3 id="AMS启动应用进程"><a href="#AMS启动应用进程" class="headerlink" title="AMS启动应用进程"></a>AMS启动应用进程</h3><p>由于启动是根Activity，这时应用进程尚未启动，需要通过<code>AMS.startProcessLocked()</code>创建一个应用程序进程</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityManagerService.java</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(String processName,
            ApplicationInfo info, <span class="hljs-keyword">boolean</span> knownToBeDead, <span class="hljs-keyword">int</span> intentFlags,
            String hostingType, ComponentName hostingName, <span class="hljs-keyword">boolean</span> allowWhileBooting,
            <span class="hljs-keyword">boolean</span> isolated, <span class="hljs-keyword">boolean</span> keepIfLarge)</span> </span>&#123;
        <span class="hljs-keyword">return</span> startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,
                hostingName, allowWhileBooting, isolated, <span class="hljs-number">0</span> <span class="hljs-comment">/* isolatedUid */</span>, keepIfLarge,
                <span class="hljs-keyword">null</span> <span class="hljs-comment">/* ABI override */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* entryPoint */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* entryPointArgs */</span>,
                <span class="hljs-keyword">null</span> <span class="hljs-comment">/* crashHandler */</span>);
    &#125;  

    <span class="hljs-function"><span class="hljs-keyword">final</span> ProcessRecord <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(String processName, ApplicationInfo info,
            <span class="hljs-keyword">boolean</span> knownToBeDead, <span class="hljs-keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,
            <span class="hljs-keyword">boolean</span> allowWhileBooting, <span class="hljs-keyword">boolean</span> isolated, <span class="hljs-keyword">int</span> isolatedUid, <span class="hljs-keyword">boolean</span> keepIfLarge,
            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;
        <span class="hljs-keyword">long</span> startTime = SystemClock.elapsedRealtime();
        ProcessRecord app;
        ...
        startProcessLocked(
             app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
    &#125;    


    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startProcessLocked</span><span class="hljs-params">(ProcessRecord app, String hostingType,
            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;
      ...
        <span class="hljs-comment">//</span>
        <span class="hljs-keyword">boolean</span> isActivityProcess = (entryPoint == <span class="hljs-keyword">null</span>);
            <span class="hljs-keyword">if</span> (entryPoint == <span class="hljs-keyword">null</span>) entryPoint = <span class="hljs-string">"android.app.ActivityThread"</span>;
          
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"Start proc: "</span> +
                    app.processName);
            checkTime(startTime, <span class="hljs-string">"startProcess: asking zygote to start proc"</span>);
            ProcessStartResult startResult;
            <span class="hljs-keyword">if</span> (hostingType.equals(<span class="hljs-string">"webview_service"</span>)) &#123;
                startResult = startWebView(entryPoint,
                        app.processName, uid, uid, gids, debugFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, <span class="hljs-keyword">null</span>, entryPointArgs);
            &#125; <span class="hljs-keyword">else</span> &#123;
                startResult = Process.start(entryPoint,
                        app.processName, uid, uid, gids, debugFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, invokeWith, entryPointArgs);
            &#125;
      ...
    &#125;</code></pre>
<p>调用到<code>Process</code>的静态成员函数<code>start()</code>启动一个新的应用进程，指定了该进程的入口函数为<code>ActivityThread.main()</code>；因此创建应用进程结束时，逻辑就转移到了<code>ActivityThread.main()</code>上。</p>
<pre><code class="hljs java">Process.start() =&gt; ZygoteProcess.start() == LocalSocket连接 =&gt; ZygoteServer.runSelectLoop() =&gt; ZygoteConnection.processOneCommand() =&gt; 
<span class="hljs-comment">// 源码路径：java/com/android/internal/os/ZygoteConnection.java</span>
<span class="hljs-function">Runnable <span class="hljs-title">processOneCommand</span><span class="hljs-params">(ZygoteServer zygoteServer)</span> </span>&#123;
...
  <span class="hljs-comment">//从Zygote孵化一个新进程并赋予 pid</span>
          pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,
                parsedArgs.instructionSet, parsedArgs.appDataDir);

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// in child</span>
                zygoteServer.setForkChild();

                zygoteServer.closeServerSocket();
                IoUtils.closeQuietly(serverPipeFd);
                serverPipeFd = <span class="hljs-keyword">null</span>;

                <span class="hljs-keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,
                        parsedArgs.startChildZygote);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// In the parent. A pid &lt; 0 indicates a failure and will be handled in</span>
                <span class="hljs-comment">// handleParentProc.</span>
                IoUtils.closeQuietly(childPipeFd);
                childPipeFd = <span class="hljs-keyword">null</span>;
                handleParentProc(pid, descriptors, serverPipeFd);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
            &#125;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            IoUtils.closeQuietly(childPipeFd);
            IoUtils.closeQuietly(serverPipeFd);
        &#125;
&#125;
  
=&gt; ZygoteConnection.handleChildProc()
  
<span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">handleChildProc</span><span class="hljs-params">(Arguments parsedArgs, FileDescriptor[] descriptors,
            FileDescriptor pipeFd, <span class="hljs-keyword">boolean</span> isZygote)</span> </span>&#123;
  ...
             <span class="hljs-keyword">if</span> (!isZygote) &#123;
                <span class="hljs-keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,
                        <span class="hljs-keyword">null</span> <span class="hljs-comment">/* classLoader */</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,
                        parsedArgs.remainingArgs, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* classLoader */</span>);
            &#125;
&#125;

=&gt; ZygoteInit.zygoteInit()
  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Runnable <span class="hljs-title">zygoteInit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (RuntimeInit.DEBUG) &#123;
            Slog.d(RuntimeInit.TAG, <span class="hljs-string">"RuntimeInit: Starting application from zygote"</span>);
        &#125;

        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"ZygoteInit"</span>);
        RuntimeInit.redirectLogStreams();

        RuntimeInit.commonInit();
        ZygoteInit.nativeZygoteInit();
        
        <span class="hljs-keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
    &#125;

=&gt; RuntimeInit.applicationInit()
  
 <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">applicationInit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetSdkVersion, String[] argv,
            ClassLoader classLoader)</span> </span>&#123;
 ...
           <span class="hljs-comment">// Remaining arguments are passed to the start class's static main</span>
        <span class="hljs-keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);
&#125;

=&gt; RuntimeInit.findStaticMain()<span class="hljs-comment">//此时完成了对   android.app.ActivityThread.main()的反射调用</span>

      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">findStaticMain</span><span class="hljs-params">(String className, String[] argv,
            ClassLoader classLoader)</span> </span>&#123;
        Class&lt;?&gt; cl;
        <span class="hljs-keyword">try</span> &#123;
            cl = Class.forName(className, <span class="hljs-keyword">true</span>, classLoader);
        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(
                    <span class="hljs-string">"Missing class when invoking static main "</span> + className,
                    ex);
        &#125;

        Method m;
        <span class="hljs-keyword">try</span> &#123;
            m = cl.getMethod(<span class="hljs-string">"main"</span>, <span class="hljs-keyword">new</span> Class[] &#123; String[].class &#125;);
        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(
                    <span class="hljs-string">"Missing static main on "</span> + className, ex);
        &#125; <span class="hljs-keyword">catch</span> (SecurityException ex) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(
                    <span class="hljs-string">"Problem getting static main on "</span> + className, ex);
        &#125;
  ...
&#125;</code></pre>
<p>拓展：为什么不用Binder而是采用Socket进行 ZygoteProcess与AMS间的通信。</p>
<ol>
<li><code>Socket</code>的调用是root,group是system，相对是安全的</li>
<li><code>fork()</code>不支持多线程，可能导致binder调用的时候，多个service发起fork请求，导致部分service创建失败</li>
</ol>
<blockquote>
<p>Zygote进程孵化出新的应用进程后，通过反射执行<code>ActivityThread.main()</code>，在该方法中会事先准备好<code>Looper以及MessageQueue</code>，继续调用<code>attach()</code>用进程绑定到<code>AMS</code>，然后开始消息循环，不断读取队列消息，并分发消息。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//准备主线程Looper 以便Handler调用</span>
        Looper.prepareMainLooper();
        <span class="hljs-comment">//创建主进程的 ActivityThread</span>
        ActivityThread thread = <span class="hljs-keyword">new</span> ActivityThread();
        <span class="hljs-comment">//将该进程进行绑定</span>
        thread.attach(<span class="hljs-keyword">false</span>);

        <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">//保存进程对应的主线程Handler</span>
            sMainThreadHandler = thread.getHandler();
        &#125;

        <span class="hljs-comment">// End of event ActivityThreadMain.</span>
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        <span class="hljs-comment">//主线程开始消息循环</span>
        Looper.loop();
    
  &#125;
  <span class="hljs-keyword">final</span> ApplicationThread mAppThread = <span class="hljs-keyword">new</span> ApplicationThread();
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> system)</span> </span>&#123;
      ...
        <span class="hljs-keyword">if</span> (!system) &#123;
          ...
            <span class="hljs-keyword">final</span> IActivityManager mgr = ActivityManager.getService();
            <span class="hljs-keyword">try</span> &#123;
                mgr.attachApplication(mAppThread);
            &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;
                <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();
            &#125;
        &#125;<span class="hljs-keyword">else</span>&#123;
          ...
        &#125;
      ...
  &#125;</code></pre>
<p><code>AMS</code>attach的是<code>ActivityThread</code>的代理对象<code>ApplicationThread</code>，然后<code>AMS</code>就可以通过代理对象对主线程进行操作。</p>
<p><strong>至此，应用进程创建完毕，并且已建立主线程完毕并开启了消息循环。</strong></p>
<h3 id="创建并绑定Application"><a href="#创建并绑定Application" class="headerlink" title="创建并绑定Application"></a>创建并绑定Application</h3><p>这时应用进程以及主线程已经创造完毕，接下来就是要创建<code>Application</code></p>
<pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityManagerService.java</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attachApplication</span><span class="hljs-params">(IApplicationThread thread)</span> </span>&#123;
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
            <span class="hljs-comment">//获取当前进程的id</span>
            <span class="hljs-keyword">int</span> callingPid = Binder.getCallingPid();
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid);
            Binder.restoreCallingIdentity(origId);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">attachApplicationLocked</span><span class="hljs-params">(IApplicationThread thread,
            <span class="hljs-keyword">int</span> pid)</span> </span>&#123;
        
        ProcessRecord app;
        <span class="hljs-keyword">long</span> startTime = SystemClock.uptimeMillis();
        <span class="hljs-keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">synchronized</span> (mPidsSelfLocked) &#123;
                app = mPidsSelfLocked.get(pid);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            app = <span class="hljs-keyword">null</span>;
        &#125;
       <span class="hljs-comment">// 如果获取进程信息为空 直接杀死进程并退出</span>
       <span class="hljs-keyword">if</span> (app == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span> &amp;&amp; pid != MY_PID) &#123;
                killProcessQuiet(pid);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">try</span> &#123;
                    thread.scheduleExit();
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    <span class="hljs-comment">// Ignore exceptions.</span>
                &#125;
            &#125;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
        <span class="hljs-comment">//创建死亡代理，被kill后可以通知AMS</span>
        <span class="hljs-keyword">try</span> &#123;
            AppDeathRecipient adr = <span class="hljs-keyword">new</span> AppDeathRecipient(
                    app, pid, thread);
            thread.asBinder().linkToDeath(adr, <span class="hljs-number">0</span>);
            app.deathRecipient = adr;
        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
            app.resetPackageList(mProcessStats);
            startProcessLocked(app, <span class="hljs-string">"link fail"</span>, processName);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
      
        <span class="hljs-keyword">try</span> &#123;
         ...
           <span class="hljs-keyword">if</span> (app.instr != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">//绑定Application</span>
                thread.bindApplication(processName, appInfo, providers,
                        app.instr.mClass,
                        profilerInfo, app.instr.mArguments,
                        app.instr.mWatcher,
                        app.instr.mUiAutomationConnection, testMode,
                        mBinderTransactionTrackingEnabled, enableTrackAllocation,
                        isRestrictedBackupMode || !normalMode, app.persistent,
                        <span class="hljs-keyword">new</span> Configuration(getGlobalConfiguration()), app.compat,
                        getCommonServicesLocked(app.isolated),
                        mCoreSettingsObserver.getCoreSettingsLocked(),
                        buildSerial);
            &#125; <span class="hljs-keyword">else</span> &#123;
                thread.bindApplication(processName, appInfo, providers, <span class="hljs-keyword">null</span>, profilerInfo,
                        <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, testMode,
                        mBinderTransactionTrackingEnabled, enableTrackAllocation,
                        isRestrictedBackupMode || !normalMode, app.persistent,
                        <span class="hljs-keyword">new</span> Configuration(getGlobalConfiguration()), app.compat,
                        getCommonServicesLocked(app.isolated),
                        mCoreSettingsObserver.getCoreSettingsLocked(),
                        buildSerial);
            &#125;
        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
          ...
          <span class="hljs-comment">//启动失败 重启当前进程</span>
          startProcessLocked(app, <span class="hljs-string">"bind fail"</span>, processName);
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
        <span class="hljs-comment">//准备启动根Activity</span>
         <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;
                    didSomething = <span class="hljs-keyword">true</span>;
                &#125;
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                Slog.wtf(TAG, <span class="hljs-string">"Exception thrown launching activities in "</span> + app, e);
                badApp = <span class="hljs-keyword">true</span>;
         &#125;
      
       <span class="hljs-comment">//绑定Service以及BroadCast的Application</span>
       ...
       <span class="hljs-keyword">if</span> (badApp) &#123;
            <span class="hljs-comment">//如果以上组件启动出错，则需要杀死进程并移除记录</span>
            app.kill(<span class="hljs-string">"error during init"</span>, <span class="hljs-keyword">true</span>);
            handleAppDiedLocked(app, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;

        <span class="hljs-comment">//如果以上没有启动任何组件，那么didSomething为false</span>
        <span class="hljs-keyword">if</span> (!didSomething) &#123;
            <span class="hljs-comment">//调整进程的oom_adj值， oom_adj相当于一种优先级</span>
            <span class="hljs-comment">//如果应用进程没有运行任何组件，那么当内存出现不足时，该进程是最先被系统“杀死”</span>
            updateOomAdjLocked();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;

    &#125;</code></pre>
<p>在<code>AMS.attachApplicationLocked()</code>主要做了两步：</p>
<ul>
<li><p><code>thread.bindApplication()</code>：绑定Application到ActivityThread上</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindApplication</span><span class="hljs-params">(String processName, ApplicationInfo appInfo,
                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,
                ProfilerInfo profilerInfo, Bundle instrumentationArgs,
                IInstrumentationWatcher instrumentationWatcher,
                IUiAutomationConnection instrumentationUiConnection, <span class="hljs-keyword">int</span> debugMode,
                <span class="hljs-keyword">boolean</span> enableBinderTracking, <span class="hljs-keyword">boolean</span> trackAllocation,
                <span class="hljs-keyword">boolean</span> isRestrictedBackupMode, <span class="hljs-keyword">boolean</span> persistent, Configuration config,
                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,
                String buildSerial)</span> </span>&#123;

            <span class="hljs-keyword">if</span> (services != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">// Setup the service cache in the ServiceManager</span>
                ServiceManager.initServiceCache(services);
            &#125;

            setCoreSettings(coreSettings);

            AppBindData data = <span class="hljs-keyword">new</span> AppBindData();
            <span class="hljs-comment">//设置Data参数</span>
            ...
            sendMessage(H.BIND_APPLICATION, data);
        &#125;

<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BIND_APPLICATION         = <span class="hljs-number">110</span>;
  ...
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;
            <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));
            <span class="hljs-keyword">switch</span> (msg.what) &#123;
                 <span class="hljs-keyword">case</span> BIND_APPLICATION:
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"bindApplication"</span>);
                    AppBindData data = (AppBindData)msg.obj;
                    handleBindApplication(data);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                    <span class="hljs-keyword">break</span>;
                ...
            &#125;
    ...
&#125;</code></pre>
<blockquote>
<p><code>H</code>相当于<code>ApplcationThread</code>与<code>ActivityThread</code>的中间人，其中<code>AMS与ActivityThread通信靠 ApplicationThread，ActivityThread与ApplicationThread通信靠Handler</code>。</p>
<p>这里涉及的就是<strong><code>Android的主线程消息循环模型</code></strong>。</p>
</blockquote>
<p>在<code>ApplicationThread</code>发送<code>BIND_APPLICATION</code>标识的消息时，<code>H</code>接收到消息，调用<code>handleBindApplication()</code></p>
<pre><code class="hljs java">Instrumentation mInstrumentation;
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleBindApplication</span><span class="hljs-params">(AppBindData data)</span> </span>&#123;
  ...
  <span class="hljs-comment">//获取LoaderApk对象</span>
  data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
  <span class="hljs-comment">//创建进程对应的Android运行环境ContextImpl</span>
  <span class="hljs-keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="hljs-keyword">this</span>, data.info);
  
  <span class="hljs-keyword">final</span> InstrumentationInfo ii;
   <span class="hljs-keyword">if</span> (ii != <span class="hljs-keyword">null</span>) &#123;
     ...
   &#125;<span class="hljs-keyword">else</span>&#123;
     <span class="hljs-comment">//Activity中所有的生命周期方法都会被Instrumentation监控</span>
     <span class="hljs-comment">//只要是执行Activity生命周期的相关方法前后一定会调用Instrumentation相关方法</span>
     mInstrumentation = <span class="hljs-keyword">new</span> Instrumentation();
   &#125;
  
  <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//准备创建Application对象</span>
            Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);
            mInitialApplication = app;
            ...
             <span class="hljs-comment">//加载对应进程中的ContentProvider</span>
            installContentProviders(app, data.providers);
            <span class="hljs-keyword">try</span> &#123;
                mInstrumentation.onCreate(data.instrumentationArgs);
            &#125;
            <span class="hljs-keyword">catch</span> (Exception e) &#123;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(
                    <span class="hljs-string">"Exception thrown in onCreate() of "</span>
                    + data.instrumentationName + <span class="hljs-string">": "</span> + e.toString(), e);
            &#125;

            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">//调用Application的onCreate方法</span>
                mInstrumentation.callApplicationOnCreate(app);
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(
                        <span class="hljs-string">"Unable to create application "</span> + app.getClass().getName()
                        + <span class="hljs-string">": "</span> + e.toString(), e);
                &#125;
            &#125;
        &#125; <span class="hljs-keyword">finally</span> &#123;
            StrictMode.setThreadPolicy(savedPolicy);
        &#125;
&#125;</code></pre>
<p><code>handleBindApplicaiton()</code>主要是<strong>为了让一个Java的进程可以加入到Android中</strong>。</p>
<p>主要执行步骤有以下几步：</p>
<ol>
<li>设置进程的基本参数，例如进程名，时区等，配置资源以及兼容性设计。</li>
<li>创建进程对应的<code>ContextImpl、LoaderApk以及Application</code>对象，并初始化<code>ContentProvide以及Application</code>。</li>
<li>创建<code>Instrumentation</code>监听Activity的生命周期。(<strong>一个进程对应一个Instrumentation实例</strong>)</li>
</ol>
</li>
<li><p><code>mStackSuperVisor.attachApplicationLocked()</code>：启动根Activity</p>
<p>在该方法中<code>Application</code>已经绑定到进程上，接下来就是启动根Activity</p>
<pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/am/ActivityStackSupervisor.java</span>
<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">attachApplicationLocked</span><span class="hljs-params">(ProcessRecord app)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;
        <span class="hljs-keyword">final</span> String processName = app.processName;
        <span class="hljs-keyword">boolean</span> didSomething = <span class="hljs-keyword">false</span>;
        <span class="hljs-comment">//ActivityStackSupervisor里面 维护者所有ActiivtyStack</span>
        <span class="hljs-comment">//通过循环 找到前台任务栈顶端的Activity</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> displayNdx = mActivityDisplays.size() - <span class="hljs-number">1</span>; displayNdx &gt;= <span class="hljs-number">0</span>; --displayNdx) &#123;
            ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> stackNdx = stacks.size() - <span class="hljs-number">1</span>; stackNdx &gt;= <span class="hljs-number">0</span>; --stackNdx) &#123;
                <span class="hljs-keyword">final</span> ActivityStack stack = stacks.get(stackNdx);
                <span class="hljs-keyword">if</span> (!isFocusedStack(stack)) &#123;
                    <span class="hljs-keyword">continue</span>;
                &#125;
                ActivityRecord hr = stack.topRunningActivityLocked();
                <span class="hljs-keyword">if</span> (hr != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-comment">//前台待启动的Activity与当前新建的进程一致时，启动这个Actiivty</span>
                    <span class="hljs-keyword">if</span> (hr.app == <span class="hljs-keyword">null</span> &amp;&amp; app.uid == hr.info.applicationInfo.uid
                            &amp;&amp; processName.equals(hr.processName)) &#123;
                        <span class="hljs-keyword">try</span> &#123;
                            <span class="hljs-keyword">if</span> (realStartActivityLocked(hr, app, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>)) &#123;
                                didSomething = <span class="hljs-keyword">true</span>;
                            &#125;
                        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
                            <span class="hljs-keyword">throw</span> e;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (!didSomething) &#123;
            ensureActivitiesVisibleLocked(<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, !PRESERVE_WINDOWS);
        &#125;
        <span class="hljs-keyword">return</span> didSomething;
    &#125;</code></pre>
<p>需要启动的Activity所在进程已经启动时，开始准备启动根Activity <code>realStartActivityLocked()</code></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">realStartActivityLocked</span><span class="hljs-params">(ActivityRecord r, ProcessRecord app,
            <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;    
  ...
app.thread.scheduleLaunchActivity(<span class="hljs-keyword">new</span> Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info,
                    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Have this take the merged configuration instead of separate global and</span>
                    <span class="hljs-comment">// override configs.</span>
                    mergedConfiguration.getGlobalConfiguration(),
                    mergedConfiguration.getOverrideConfiguration(), r.compat,
                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,
                    r.persistentState, results, newIntents, !andResume,
                    mService.isNextTransitionForward(), profilerInfo);
  ...
&#125;</code></pre>
<p>这里的<code>app.thread</code>的类型为<code>IApplicationThread</code>，它的实现是<code>ActivityThread</code>的内部类<code>ApplicationThread</code>。<code>app</code>指代的是要启动的Acttvity所在的应用进程。因此这段代码指的就是要在目标应用程序进程中启动Activity。</p>
</li>
</ul>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/AMS启动进程并绑定Application.png" srcset="/img/loading.gif" class="full-image" alt="AMS启动进程并绑定Application" title="AMS启动进程并绑定Application"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="ActivityThread启动Activity过程"><a href="#ActivityThread启动Activity过程" class="headerlink" title="ActivityThread启动Activity过程"></a>ActivityThread启动Activity过程</h3><p>这时Activity的启动过程从<code>AMS</code>切换到了<code>ApplicationThread</code>中，最后是调用到了<code>ApplicationThread.scheduleLaunchActivity()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/ActivityThread.java        </span>
<span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleLaunchActivity</span><span class="hljs-params">(Intent intent, IBinder token, <span class="hljs-keyword">int</span> ident,
                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,
                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,
                <span class="hljs-keyword">int</span> procState, Bundle state, PersistableBundle persistentState,
                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,
                <span class="hljs-keyword">boolean</span> notResumed, <span class="hljs-keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;

            updateProcessState(procState, <span class="hljs-keyword">false</span>);

            ActivityClientRecord r = <span class="hljs-keyword">new</span> ActivityClientRecord();

            r.token = token;
            r.ident = ident;
            r.intent = intent;
            r.referrer = referrer;
            r.voiceInteractor = voiceInteractor;
            r.activityInfo = info;
            r.compatInfo = compatInfo;
            r.state = state;
            r.persistentState = persistentState;

            r.pendingResults = pendingResults;
            r.pendingIntents = pendingNewIntents;

            r.startsNotResumed = notResumed;
            r.isForward = isForward;

            r.profilerInfo = profilerInfo;

            r.overrideConfig = overrideConfig;
            updatePendingConfiguration(curConfig);

            sendMessage(H.LAUNCH_ACTIVITY, r);
        &#125;</code></pre>
<p>将需要启动Activity的参数封装成<code>ActivityClientRecord</code>，在调用<code>sendMessage()</code>设置类型为<code>LAUNCH_ACTIVITY</code>，并将<code>ActivityClientRecord</code>传递过去。</p>
<pre><code class="hljs java"><span class="hljs-keyword">final</span> H mh = <span class="hljs-keyword">new</span> H();
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what, Object obj, <span class="hljs-keyword">int</span> arg1, <span class="hljs-keyword">int</span> arg2, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(
            TAG, <span class="hljs-string">"SCHEDULE "</span> + what + <span class="hljs-string">" "</span> + mH.codeToString(what)
            + <span class="hljs-string">": "</span> + arg1 + <span class="hljs-string">" / "</span> + obj);
        Message msg = Message.obtain();
        msg.what = what;
        msg.obj = obj;
        msg.arg1 = arg1;
        msg.arg2 = arg2;
        <span class="hljs-keyword">if</span> (async) &#123;
            msg.setAsynchronous(<span class="hljs-keyword">true</span>);
        &#125;
        mH.sendMessage(msg);
    &#125;</code></pre>
<p>这里的<code>mh</code>指的就是<code>H</code>，这个<code>H</code>是<code>ActivityThread</code>的内部类并继承自<code>Handler</code>，是主线程的消息管理类。因为<code>ApplicationThread</code>是一个Binder，它的调用逻辑是在<code>Binder线程池</code>中。所以这里就要把执行逻辑切换到主线程中，就使用了<code>Handler</code>。</p>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LAUNCH_ACTIVITY         = <span class="hljs-number">100</span>;
  ...
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;
            <span class="hljs-keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="hljs-string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));
            <span class="hljs-keyword">switch</span> (msg.what) &#123;
                <span class="hljs-keyword">case</span> LAUNCH_ACTIVITY: &#123;
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">"activityStart"</span>);
                    <span class="hljs-comment">//将传递过来的msg.obj转化为ActivityClientRecord</span>
                    <span class="hljs-keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                    <span class="hljs-comment">// 获得LoaderApk类型的对象并赋值到ActivityClientRecoed中</span>
                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, <span class="hljs-keyword">null</span>, <span class="hljs-string">"LAUNCH_ACTIVITY"</span>);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                &#125; <span class="hljs-keyword">break</span>;
                ...
            &#125;
    ...
&#125;</code></pre>
<blockquote>
<p>每一个Android程序都是打包在一个Apk文件中的，一个Apk文件包含了一个Android程序中的所有资源。应用程序进程在启动一个Activity组件时，需要将它所属的Apk文件加载进来，以便访问内部资源。<code>ActivityThread</code>内部使用<code>LoaderApk</code>描述一个已加载的Apk文件。</p>
</blockquote>
<p>继续向下调用到<code>handleLauncheActivity()</code></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;
...
  <span class="hljs-comment">//Window开始初始化</span>
  WindowManagerGlobal.initialize();
  <span class="hljs-comment">//准备启动Activity</span>
  Activity a = performLaunchActivity(r, customIntent);

  <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>) &#123;
           r.createdConfig = <span class="hljs-keyword">new</span> Configuration(mConfiguration);
           reportSizeConfigurations(r);
           Bundle oldState = r.state;
           <span class="hljs-comment">//将要启动的Activity状态设为 Resumed 标记待激活</span>
           handleResumeActivity(r.token, <span class="hljs-keyword">false</span>, r.isForward,
                   !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);
           <span class="hljs-keyword">if</span> (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;
               performPauseActivityIfNeeded(r, reason);
               <span class="hljs-keyword">if</span> (r.isPreHoneycomb()) &#123;
                   r.state = oldState;
               &#125;
           &#125;
       &#125; <span class="hljs-keyword">else</span> &#123;
           <span class="hljs-comment">// If there was an error, for any reason, tell the activity manager to stop us.</span>
           <span class="hljs-keyword">try</span> &#123;
               <span class="hljs-comment">//停止Activity启动</span>
               ActivityManager.getService()
                   .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="hljs-keyword">null</span>,
                           Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
           &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;
               <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();
           &#125;
       &#125;   
&#125;</code></pre>
<p>首先调用<code>performLaunchActivity()</code>开始准备启动Activity，内部会调用Activity的<code>Oncreate(),onStart(),onRestoreInstaceState()</code></p>
<p><code>performResumeActivity()</code>对应生命周期的<code>onResume()</code>，之后开始调用View的绘制，Activity的内容开始渲染到Window上面，直到我们看见绘制结果。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;
  ...
&#125;</code></pre>
<p><code>performLaunchActivity()</code>主要完成了如下几件事：</p>
<ol>
<li><p>从<code>ActivityClientRecord</code>中获取待启动的Activity的组件信息</p>
<pre><code class="hljs java">ActivityInfo aInfo = r.activityInfo;
       <span class="hljs-keyword">if</span> (r.packageInfo == <span class="hljs-keyword">null</span>) &#123;
           <span class="hljs-comment">//获取LoadedApk对象</span>
           r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                   Context.CONTEXT_INCLUDE_CODE);
       &#125;
       <span class="hljs-comment">//获取组件信息</span>
       ComponentName component = r.intent.getComponent();
       <span class="hljs-keyword">if</span> (component == <span class="hljs-keyword">null</span>) &#123;
           component = r.intent.resolveActivity(
               mInitialApplication.getPackageManager());
           r.intent.setComponent(component);
       &#125;
   
       <span class="hljs-keyword">if</span> (r.activityInfo.targetActivity != <span class="hljs-keyword">null</span>) &#123;
           component = <span class="hljs-keyword">new</span> ComponentName(r.activityInfo.packageName,
                   r.activityInfo.targetActivity);
       &#125;</code></pre>
<p><code>ComponentName</code>包含了<code>Activity组件的包名及类名。</code></p>
</li>
<li><p>通过<code>Instrumentation.newActivity()</code>使用类加载器创建Activity对象</p>
<pre><code class="hljs java">Activity activity = <span class="hljs-keyword">null</span>;
       <span class="hljs-keyword">try</span> &#123;
           java.lang.ClassLoader cl = appContext.getClassLoader();
           <span class="hljs-comment">//用类加载器创建该Activity的实例</span>
           activity = mInstrumentation.newActivity(
                   cl, component.getClassName(), r.intent);
           StrictMode.incrementExpectedActivityCount(activity.getClass());
           r.intent.setExtrasClassLoader(cl);
           r.intent.prepareToEnterProcess();
           <span class="hljs-keyword">if</span> (r.state != <span class="hljs-keyword">null</span>) &#123;
               r.state.setClassLoader(cl);
           &#125;
       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
         ...
       &#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-comment">// ../android/app/Instrumentation.java   </span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Activity <span class="hljs-title">newActivity</span><span class="hljs-params">(ClassLoader cl, String className,
            Intent intent)</span>
            <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException,
            ClassNotFoundException </span>&#123;
        <span class="hljs-keyword">return</span> (Activity)cl.loadClass(className).newInstance();
    &#125;</code></pre>
</li>
<li><p>通过<code>LoadedApk.makeApplication()</code>创建Application对象（<em>实际是判空</em>）</p>
<pre><code class="hljs java">Application app = r.packageInfo.makeApplication(<span class="hljs-keyword">false</span>, mInstrumentation);

<span class="hljs-comment">// ../android/app/LoaderApk.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Application <span class="hljs-title">makeApplication</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceDefaultAppClass,
            Instrumentation instrumentation)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (mApplication != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> mApplication;
        &#125;
      
      <span class="hljs-comment">//新建Application</span>
      <span class="hljs-keyword">try</span> &#123;
            java.lang.ClassLoader cl = getClassLoader();
            <span class="hljs-keyword">if</span> (!mPackageName.equals(<span class="hljs-string">"android"</span>)) &#123;
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,
                        <span class="hljs-string">"initializeJavaContextClassLoader"</span>);
                initializeJavaContextClassLoader();
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            &#125;
            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="hljs-keyword">this</span>);
            app = mActivityThread.mInstrumentation.newApplication(
                    cl, appClass, appContext);
            appContext.setOuterContext(app);
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            <span class="hljs-keyword">if</span> (!mActivityThread.mInstrumentation.onException(app, e)) &#123;
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(
                    <span class="hljs-string">"Unable to instantiate application "</span> + appClass
                    + <span class="hljs-string">": "</span> + e.toString(), e);
            &#125;
        &#125;
        mActivityThread.mAllApplications.add(app);
        mApplication = app;
    &#125;</code></pre>
<p>由于在前面<code>创建并绑定Application</code>过程中的<code>bindApplication()</code>就已经创建好了<code>Application</code>，所以这一步只是起到了预防作用，并且不会重复创建。</p>
</li>
<li><p>创建<code>ContextImpl</code>对象，并通过<code>Activity.attach()</code>完成一些重要数据的初始化</p>
<pre><code class="hljs java">ContextImpl appContext = createBaseContextForActivity(r);
appContext.setOuterContext(activity);
                activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window, r.configCallback);</code></pre>
<blockquote>
<p><code>ContextImpl</code>是一个很重要的数据结构，它是<code>Context</code>的具体实现，Context中大部分逻辑都是由<code>ContextImpl</code>完成的。<code>ContextImpl</code>是通过<code>Activity.attach()</code>与Activity进行关联的。除此之外，在<code>attach()</code>中，<strong>Activity还会完成Window的创建并建立关联</strong>，这样当Window接收到外部输入事件以后就可以将事件传递给Activity。</p>
</blockquote>
</li>
<li><p>调用<code>Activity.oncreate()</code>加载用户界面</p>
<pre><code class="hljs java">mInstrumentation.callActivityOnCreate(activity, r.state);

mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
                                    r.persistentState);

mInstrumentation.callActivityOnPostCreate(activity, r.state,
                                r.persistentState);

<span class="hljs-comment">// ../android/app/Instrumentation.java  </span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callActivityOnCreate</span><span class="hljs-params">(Activity activity, Bundle icicle)</span> </span>&#123;
        prePerformCreate(activity);
        activity.performCreate(icicle);
        postPerformCreate(activity);
    &#125;

<span class="hljs-comment">// ../android/app/Activity.java</span>
<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performCreate</span><span class="hljs-params">(Bundle icicle)</span> </span>&#123;
        restoreHasCurrentPermissionRequest(icicle);
        onCreate(icicle);
        mActivityTransitionState.readState(icicle);
        performCreateCommon();
    &#125;</code></pre>
<p>最终调用到<code>Activity.performCreate()</code>后续调用到<code>Activity.onCreate()</code>这时根Activity就启动了，完成了整个启动流程。</p>
</li>
</ol>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/ActivityThread启动Activity过程.png" srcset="/img/loading.gif" class="full-image" alt="ActivityThread启动Activity过程" title="ActivityThread启动Activity过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="根Activity启动过程中涉及的进程"><a href="#根Activity启动过程中涉及的进程" class="headerlink" title="根Activity启动过程中涉及的进程"></a>根Activity启动过程中涉及的进程</h3><p>根Activity启动过程中涉及四个进程：<strong>Zygote进程、Launcher进程、AMS所在进程（System Server进程），应用程序进程。</strong></p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/根启动Activity过程中的进程切换.png" srcset="/img/loading.gif" class="full-image" alt="根启动Activity过程中的进程切换" title="根启动Activity过程中的进程切换"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p>首先<code>Launcher进程</code>会向<code>AMS</code>发起<code>创建根Activity请求</code>，<code>AMS</code>会判断根Activity所需的应用程序进程是否存在并处于启动状态</p>
<ul>
<li><code>未启动</code>：请求<code>Zygote进程</code>创建应用程序进程</li>
<li><code>已启动</code>：<code>AMS</code>直接启动Activity</li>
</ul>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上述章节的描述，可以基本厘清<code>根Activity的启动过程</code></p>
<blockquote>
<p>当我们按下桌面上的应用程序快捷启动方式时，<code>Launcher</code>会调用<code>Activity.startActivity()</code>并设置启动FLAG为<code>FLAG_ACTIVITY_NEW_TASK</code>给根Activity设置任务栈，实质上是调用<code>Instrumentation.execStartActivity()</code>尝试启动Activity，这是一个跨进程的过程，利用<code>IActivityManager</code>与<code>AMS</code>进行通信。</p>
<p><code>AMS</code>就会记录下要启动的Activity信息，并且跨进程通知Launcher进入<code>pause</code>状态，<code>Launcher</code>进入<code>pause</code>状态后，跨进程通知<code>AMS</code>自己已被<code>pause</code>。<code>AMS</code>会回调用自身的<code>startActivty()</code>去继续启动根Activity，这一步需要校验(调用者是否有权限调用)，检验通过后，发现此时应用进程尚未启动，<code>AMS</code>就会启动新的进程，并且在新进程中创建<code>ActivityThread</code>对象并执行<code>main()</code>进程初始化。</p>
<p>应用进程启动完毕后，<code>AMS</code>通知主线程绑定<code>Application</code>并启动根Activity。这时<code>AMS</code>会通过<code>ApplicationThread</code>回调到我们的进程，这一步也是一个跨进程的过程，利用<code>ApplicationThread</code>这个Binder对象。由于回调逻辑是在<code>Binder线程池</code>中进行的，所以需要通过<code>Handler H</code>将其切回主线程，发出的消息是<code>LAUNCH_ACTIVITY</code>，对应调用<code>handleLaunchActivity</code>，在这个方法中完成了根Activity的创建以及启动。接着在<code>handleResumeActivity()</code>中开始Activity的内容绘制，直到绘制完成被我们看见。</p>
</blockquote>
<h2 id="普通Activity启动过程"><a href="#普通Activity启动过程" class="headerlink" title="普通Activity启动过程"></a>普通Activity启动过程</h2><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/普通Activity启动过程.png" srcset="/img/loading.gif" class="full-image" alt="普通Activity启动过程" title="普通Activity启动过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p>普通Activity启动过程相比于根Activity启动过程，只保留了两步：<code>AMS到Application的调用过程</code>,<code>ActivityThread启动Activity过程</code>。</p>
<p>涉及的进程也只剩：<code>AMS所在进程(System Server进程)，应用程序进程</code>。</p>
</blockquote>
<h3 id="相同进程的启动过程"><a href="#相同进程的启动过程" class="headerlink" title="相同进程的启动过程"></a>相同进程的启动过程</h3><blockquote>
<p>例如LoadingActivity -&gt; MainActivity</p>
</blockquote>
<ol>
<li>LoadingActivity组件会向<code>AMS</code>发送一个启动MainActivity的请求，其实就是内部通过<code>Instrumentation</code>尝试启动Activity(<code>execStartActivity</code>)，这是一个跨进程过程，会调用<code>AMS</code>的<code>startActivity()</code></li>
<li><code>AMS</code>会保存下来<code>MainActivity</code>的组件信息，然后向<code>LoadingActivity</code>发送一个进入中止状态的进程间通信请求。<em>这也就是为什么老Activity的<code>onPause()</code>会执行在新Activity的启动之前的原因。</em></li>
<li><code>LoadingActivity</code>进入中止状态后会通知到<code>AMS</code>继续向下执行<code>MainActivity</code>的启动，由于发现应用进程已经存在，所以<code>AMS</code>直接通过<code>ApplicationThread</code>回调到应用进程，这也是一个跨进程过程。</li>
<li>由于<code>ApplicationThread</code>是一个Binder对象，回调逻辑在<code>Binder线程池</code>中完成，需要通过<code>Handler H</code>切回到主线程，并发出<code>LAUNCH_ACTIVITY</code>消息，对应调用<code>handleLaunchActivity</code>。</li>
<li>继续向下完成<code>MainActivity</code>的创建和启动，然后在<code>handleResumeActivity()</code>中完成View的绘制，直到绘制完成展示在用户面前结束。</li>
</ol>
<h3 id="新进程的启动过程"><a href="#新进程的启动过程" class="headerlink" title="新进程的启动过程"></a>新进程的启动过程</h3><blockquote>
<p>例如LoadingActivity -&gt; MainActivity设置了<code>android:process=&quot;:remote&quot;</code></p>
<p>类似根Activity的启动过程，不过起始点是从<code>LoadingActivity</code>开始</p>
</blockquote>
<ol>
<li>LoadingActivity组件会向<code>AMS</code>发送一个启动MainActivity的请求，其实就是内部通过<code>Instrumentation</code>尝试启动Activity(<code>execStartActivity</code>)，这是一个跨进程过程，会调用<code>AMS</code>的<code>startActivity()</code></li>
<li><code>AMS</code>会保存下来<code>MainActivity</code>的组件信息，然后向<code>LoadingActivity</code>发送一个进入中止状态的进程间通信请求。<em>这也就是为什么老Activity的<code>onPause()</code>会执行在新Activity的启动之前的原因。</em></li>
<li><code>LoadingActivity</code>进入中止状态后会通知到<code>AMS</code>继续向下执行<code>MainActivity</code>的启动，此时发现用来运行的<code>:remote</code>进程不存在，就会调用<code>AMS</code>去启动新的应用进程，并且在新进程中创建<code>ActrivityThread(*主进程*)</code>并执行<code>main()</code>进行初始化。</li>
<li>应用进程启动完毕之后，向<code>AMS</code>发送一个启动完成的请求，<code>AMS</code>就会通知主线程<code>ActivityThread</code>去创建并绑定<code>Application</code>，绑定完成后，通知<code>AMS</code>绑定完成。<code>AMS</code>直接通过<code>ApplicationThread</code>回调到应用进程，这也是一个跨进程过程。</li>
<li>由于<code>ApplicationThread</code>是一个Binder对象，回调逻辑在<code>Binder线程池</code>中完成，需要通过<code>Handler H</code>切回到主线程，并发出<code>LAUNCH_ACTIVITY</code>消息，对应调用<code>handleLaunchActivity</code>。</li>
<li><!--App启动优化，如何检测启动耗时 -->
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/01/03/include、merge-ViewStub相关/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">include、merge及ViewStub相关</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/01/02/Java-泛型/">
                        <span class="hidden-mobile">Java - 泛型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
