<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java - 泛型"><meta name="keywords" content="Java"><meta name="author" content="Leo-Wxy"><meta name="copyright" content="Leo-Wxy"><title>Java - 泛型 | Wxy的个人博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型基本概念"><span class="toc-number">1.</span> <span class="toc-text">泛型基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型的好处"><span class="toc-number">1.1.</span> <span class="toc-text">泛型的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型的类型通配符"><span class="toc-number">2.</span> <span class="toc-text">泛型的类型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无界通配符-非限定通配符-——"><span class="toc-number">2.1.</span> <span class="toc-text">无界通配符(非限定通配符)——?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带限通配符-限定通配符"><span class="toc-number">2.2.</span> <span class="toc-text">带限通配符(限定通配符)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#上限通配符——-extends-T"><span class="toc-number">2.2.1.</span> <span class="toc-text">上限通配符——? extends T</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下限通配符——-super-T"><span class="toc-number">2.2.2.</span> <span class="toc-text">下限通配符——? super T</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PECS原则"><span class="toc-number">2.3.</span> <span class="toc-text">PECS原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通配符的只读性"><span class="toc-number">2.4.</span> <span class="toc-text">通配符的只读性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型的类型擦除"><span class="toc-number">3.</span> <span class="toc-text">泛型的类型擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实例分析"><span class="toc-number">3.1.</span> <span class="toc-text">实例分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型擦除基本过程"><span class="toc-number">3.2.</span> <span class="toc-text">类型擦除基本过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型擦除基本原理"><span class="toc-number">3.3.</span> <span class="toc-text">类型擦除基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型擦除缺陷"><span class="toc-number">3.4.</span> <span class="toc-text">类型擦除缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无法创建泛型数组"><span class="toc-number">3.4.1.</span> <span class="toc-text">无法创建泛型数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型不能显式地运用在运行时类型的操作当中，例如instanceOf、new"><span class="toc-number">3.4.2.</span> <span class="toc-text">泛型不能显式地运用在运行时类型的操作当中，例如instanceOf、new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型的类型参数不能用在catch中"><span class="toc-number">3.4.3.</span> <span class="toc-text">泛型的类型参数不能用在catch中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型的基本使用"><span class="toc-number">4.</span> <span class="toc-text">泛型的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型类"><span class="toc-number">4.0.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型接口"><span class="toc-number">4.0.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型方法"><span class="toc-number">4.0.3.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型构造器"><span class="toc-number">4.0.4.</span> <span class="toc-text">泛型构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型注意事项"><span class="toc-number">4.1.</span> <span class="toc-text">泛型注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内容引用"><span class="toc-number">4.2.</span> <span class="toc-text">内容引用</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Leo-Wxy</div><div class="author-info__description text-center">如果我没有见过光明，那我本可以忍受黑暗</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">128</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Wxy的个人博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Java - 泛型</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-02</time></div><div class="article-container" id="post-content"><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/泛型.png" class="full-image" alt="泛型" title="泛型"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="泛型基本概念"><a href="#泛型基本概念" class="headerlink" title="泛型基本概念"></a>泛型基本概念</h2><blockquote>
<p>Java泛型是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数(<code>type parameter</code>)。声明的类型参数在使用时用具体的类型来替换。</p>
<p><strong>本质上是编译器为了提供更好的可读性而提供的一种方式，JVM中是不存在泛型的概念的。</strong></p>
</blockquote>
<p>泛型的出现在很大程度上是为了方便集合的使用，使其能够记住元素的数据类型。泛型是对Java语言类型系统的一种拓展，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符。</p>
<h3 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h3><ol>
<li><strong>类型安全</strong>。类型错误可以在编译期直接被捕获到，而不是在运行时抛出<code>ClassCastException(类型转换错误)</code>，有助于开发者方便找到错误，提高可靠性。</li>
<li><strong>减少代码中的强制类型转换</strong>。增强代码可读性</li>
</ol>
<h2 id="泛型的类型通配符"><a href="#泛型的类型通配符" class="headerlink" title="泛型的类型通配符"></a>泛型的类型通配符</h2><blockquote>
<p>匹配任意类型的类型实参。<strong>通配符往往用于方法的形参中，不允许在定义和调用中使用。</strong></p>
</blockquote>
<h3 id="无界通配符-非限定通配符-——"><a href="#无界通配符-非限定通配符-——" class="headerlink" title="无界通配符(非限定通配符)——?"></a>无界通配符(非限定通配符)——<code>?</code></h3><p>通配任意一种类型，可以用任意类型进行替代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;? extends Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        test(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以传入任意类型的List</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.err.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带限通配符-限定通配符"><a href="#带限通配符-限定通配符" class="headerlink" title="带限通配符(限定通配符)"></a>带限通配符(限定通配符)</h3><blockquote>
<p>限制泛型的类型参数的类型，使其满足条件，限制在一些类中。</p>
</blockquote>
<h4 id="上限通配符——-extends-T"><a href="#上限通配符——-extends-T" class="headerlink" title="上限通配符——? extends T"></a>上限通配符——<code>? extends T</code></h4><blockquote>
<p>确保泛型类型必须是T的子类来设定类型的上界。<strong>使用<code>extends</code>关键字制定这个类型必须是继承某个类或者实现某个接口，也可以是这个类或者接口本身。</strong></p>
<p>使用时</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; upList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        upTest(upList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设定集合中的所有元素必须是Number的子类，例如Integer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upTest</span><span class="params">(List&lt;? extends Number&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Number number : list) &#123;</span><br><span class="line">            System.err.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Java中父类型可以持有子类型。如果一个父类的容器可以持有子类的容器，那么就称之为<strong>协变</strong>。</p>
<p>可以利用<code>上限通配符</code>实现<code>协变</code>。</p>
</blockquote>
<h4 id="下限通配符——-super-T"><a href="#下限通配符——-super-T" class="headerlink" title="下限通配符——? super T"></a>下限通配符——<code>? super T</code></h4><blockquote>
<p>确保泛型类型必须是T的父类来设定类型的下界。<strong>使用<code>super</code>关键字指定这个类型必须是某个类的父类或者某个接口的父接口，也可以是这个类或者接口本身。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Number&gt; downList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        downTest(downList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设定集合中的所有元素必须是Integer的父类，例如Number</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downTest</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.err.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果一个类的父类型容器可以持有该类的子类型的容器，那么称之为<strong>逆变</strong>。</p>
<p>可以利用<code>下限通配符</code>实现<code>逆变</code>。</p>
</blockquote>
<h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><blockquote>
<p><strong>Producter Extends ，Consumer Super</strong>。</p>
</blockquote>
<p><code>Producter Extends</code>：如果你只需要一个只读List，那么使用<code>? extends T</code>。</p>
<blockquote>
<p>无法确定写入类型，所以禁止写入会编译错误。只能对外提供数据。</p>
</blockquote>
<p><code>Consumer Super</code>：如果你只需要一个只写List，那么使用<code>? super T</code></p>
<blockquote>
<p>写入类型都是其父类，是可以确定的。但是无论怎样取出的值都会是<code>Object</code>型，是无意义的。</p>
</blockquote>
<p><strong>如果需要同时读取以及写入，就不能使用通配符。</strong></p>
<h3 id="通配符的只读性"><a href="#通配符的只读性" class="headerlink" title="通配符的只读性"></a>通配符的只读性</h3><p>通配符代表了不确定的类型，无法了解到这个容器中放的是什么类型的数据，所有只有只读性，不能往里面去添加元素。</p>
<h2 id="泛型的类型擦除"><a href="#泛型的类型擦除" class="headerlink" title="泛型的类型擦除"></a>泛型的类型擦除</h2><blockquote>
<p>泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息。成功编译过后的Class文件是不会包含任何泛型信息的，泛型信息不会进入到运行时阶段。</p>
<p>例如<code>List&lt;String&gt;</code>在运行时用<code>List</code>表示，为了确保Java 5之前的版本可以进行兼容。</p>
</blockquote>
<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">typeErasure</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        System.err.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>反编译即观察得到的.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">typeErasure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class c1 = (<span class="keyword">new</span> ArrayList()).getClass();</span><br><span class="line">        Class c2 = (<span class="keyword">new</span> ArrayList()).getClass();</span><br><span class="line">        System.err.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">都被转成为ArrayList的类型，原先的泛型都被擦除。</span><br></pre></td></tr></table></figure>
<h3 id="类型擦除基本过程"><a href="#类型擦除基本过程" class="headerlink" title="类型擦除基本过程"></a>类型擦除基本过程</h3><ol>
<li><p>找到用来替换类型参数的具体类，一般都是<code>Object</code>。如果指定类类型参数的上界话，就会采用上界。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">未设置上界：List&lt;Integer&gt;  --&gt;  List&lt;Object&gt;</span><br><span class="line">设置上界：List&lt;T extends Number&gt; --&gt; List&lt;Number&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置边界：重用了 <code>extends</code>关键字。可以将类型参数的范围限制到一个子集中。</p>
<p>设置边界时有两个注意事项：</p>
<ul>
<li>类必须写在接口之前</li>
<li>只能设置一个类做边界，其他只能是接口</li>
</ul>
</blockquote>
</li>
<li><p>把代码中的类型参数都替换成具体的类，同时去掉出现的类型声明，即去掉<code>&lt;&gt;</code>内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; --&gt; List</span><br></pre></td></tr></table></figure>
</li>
<li><p>再生成一些桥接方法。这是由于擦除了类型之后的类可能缺少某些必须方法。</p>
</li>
</ol>
<h3 id="类型擦除基本原理"><a href="#类型擦除基本原理" class="headerlink" title="类型擦除基本原理"></a>类型擦除基本原理</h3><p>在编译过程中，类型变量的信息是可以拿到的。所以在<code>set()</code>中编译器可以做类型检查，非法类型无法通过编译。对于<code>get()</code>，由于擦除机制，得到的大部分都为<code>Object</code>，编译器会在<code>get()</code>之后做一个类型转换，转成对应的类型。</p>
<h3 id="类型擦除缺陷"><a href="#类型擦除缺陷" class="headerlink" title="类型擦除缺陷"></a>类型擦除缺陷</h3><h4 id="无法创建泛型数组"><a href="#无法创建泛型数组" class="headerlink" title="无法创建泛型数组"></a>无法创建泛型数组</h4><blockquote>
<p>Array无法提供编译期的类型安全保障，由于运行期就把泛型擦除了，编译器无法判断类型。</p>
</blockquote>
<p>一般是无法创建的，推荐使用<code>ArrayList</code>来实现数组。如果硬要创建，就需要用到反射去实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericArrayWithType</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericArrayWithType</span><span class="params">(Class&lt;T&gt; type, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用反射中的Array类型 newInstance创建实例对象</span></span><br><span class="line">        array = (T[]) Array.newInstance(type, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GenericArrayWithType&lt;Integer&gt; genericArrayWithType = <span class="keyword">new</span> GenericArrayWithType&lt;&gt;(Integer.class, <span class="number">10</span>);</span><br><span class="line">genericArrayWithType.put(<span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="泛型不能显式地运用在运行时类型的操作当中，例如instanceOf、new"><a href="#泛型不能显式地运用在运行时类型的操作当中，例如instanceOf、new" class="headerlink" title="泛型不能显式地运用在运行时类型的操作当中，例如instanceOf、new"></a>泛型不能显式地运用在运行时类型的操作当中，例如<code>instanceOf、new</code></h4><blockquote>
<p>由于系统中并不会真正生成泛型类，而且在运行时，所有参数的类型信息都已经被擦除。</p>
</blockquote>
<p>可以使用显式工厂模式，避免上述问题。</p>
<h4 id="泛型的类型参数不能用在catch中"><a href="#泛型的类型参数不能用在catch中" class="headerlink" title="泛型的类型参数不能用在catch中"></a>泛型的类型参数不能用在<code>catch</code>中</h4><blockquote>
<p>异常处理是由JVM在运行时刻进行的。由于类型擦除，JVM无法区分异常类型。对于JVM来说他们是没有区别的，也就无法正常执行对应的<code>catch</code>语句。</p>
</blockquote>
<h2 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h2><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><blockquote>
<p>基本格式 ： </p>
<p><strong>访问修饰符 class 类名&lt;限定类型变量名&gt;</strong></p>
<p>例如 ： <code>public class Box&lt;T&gt;</code></p>
</blockquote>
<p>首先定义一个简单的Box类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String object;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String object)</span></span>&#123;<span class="keyword">this</span>.object = object;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> object;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时的Box类内部只能接收<code>String</code>型参数，如果需要其他类型就需要重写另外一个，这时就可以用泛型类解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;<span class="keyword">this</span>.t=t;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> t;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时的Box类便可以支持其他类型参数，可以把<code>T</code>折换成任意类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><blockquote>
<p>基本格式 ： </p>
<p><strong>访问修饰符 interface 接口名&lt;限定类型变量名&gt;</strong></p>
<p>例如 ： <code>public interface Box&lt;T&gt;</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerBox</span> <span class="keyword">implements</span> <span class="title">Box</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringBox</span> <span class="keyword">implements</span> <span class="title">Box</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><blockquote>
<p>基本格式 ： </p>
<p><strong>访问修饰符 &lt;T,S&gt; 返回值类型 方法名 (形参列表)</strong></p>
<p>例如 ： <code>public &lt;T&gt; void showBox(T t)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    System.err.println(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持返回泛型类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    System.err.println(t);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型方法中定义的形参只能在该方法中使用，但是接口、类中定义的形参可以在这个接口、类中使用。</p>
<h4 id="泛型构造器"><a href="#泛型构造器" class="headerlink" title="泛型构造器"></a>泛型构造器</h4><blockquote>
<p>基本格式 ： </p>
<p><strong>访问修饰符 class 类名 {</strong></p>
<p>  <strong>访问修饰符 <t> 类名 (形参列表){}</t></strong> </p>
<p><strong>}</strong></p>
<p>例如 ： <code>public class Box{</code></p>
<p><code>public &lt;T&gt; Box (T t){}</code></p>
<p><code>}</code></p>
</blockquote>
<p>使用泛型构造器有两种方式：</p>
<ol>
<li><p>显式指定泛型参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> &lt;String&gt;Box(<span class="string">"a"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式推断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Box(<span class="string">"a"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="泛型注意事项"><a href="#泛型注意事项" class="headerlink" title="泛型注意事项"></a>泛型注意事项</h3><ul>
<li><p><strong>任何基本类型都不能作为类型参数</strong></p>
</li>
<li><p><strong>无法进行重载</strong></p>
<blockquote>
<p>由于擦除的原因，重载方法将产生相同的类型签名。避免这种问题的方法就是换个方法名</p>
</blockquote>
</li>
</ul>
<h3 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h3><p><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener">Java泛型详解</a></p>
<p><a href="https://www.jianshu.com/p/4caf2567f91d" target="_blank" rel="noopener">Java泛型进阶</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leo-Wxy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/01/02/Java-泛型/">http://yoursite.com/2019/01/02/Java-泛型/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Wxy的个人博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/01/02/Activity启动过程/"><i class="fa fa-chevron-left">  </i><span>Activity启动过程</span></a></div><div class="next-post pull-right"><a href="/2019/01/02/自定义ViewGroup实践/"><span>自定义ViewGroup实践</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Leo-Wxy</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>