<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ANR分析"><meta name="keywords" content="Android"><meta name="author" content="Leo-Wxy"><meta name="copyright" content="Leo-Wxy"><title>ANR分析 | Wxy的个人博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ANR概述"><span class="toc-number">1.</span> <span class="toc-text">ANR概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANR发生场景"><span class="toc-number">2.</span> <span class="toc-text">ANR发生场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANR机制"><span class="toc-number">3.</span> <span class="toc-text">ANR机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#输入事件超时监测"><span class="toc-number">3.1.</span> <span class="toc-text">输入事件超时监测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#输入系统简介"><span class="toc-number">3.1.1.</span> <span class="toc-text">输入系统简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#超时监测"><span class="toc-number">3.1.2.</span> <span class="toc-text">超时监测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service超时监测"><span class="toc-number">3.2.</span> <span class="toc-text">Service超时监测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ANR报告机制"><span class="toc-number">3.3.</span> <span class="toc-text">ANR报告机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANR分析"><span class="toc-number">4.</span> <span class="toc-text">ANR分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANR避免和检测"><span class="toc-number">5.</span> <span class="toc-text">ANR避免和检测</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">Leo-Wxy</div><div class="author-info__description text-center">如果我没有见过光明，那我本可以忍受黑暗</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">128</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Wxy的个人博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">ANR分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-28</time></div><div class="article-container" id="post-content"><!--简要解释一下 ANR？为什么会发生 ANR？如何避免发生 ANR？如何定位 ANR？ANR发生条件？如何分析ANR-->
<h2 id="ANR概述"><a href="#ANR概述" class="headerlink" title="ANR概述"></a>ANR概述</h2><blockquote>
<p>ANR：<code>Application Not Responding</code>应用程序未响应，Android会要求一些事件需要在规定时间内处理完成，如果超过预定事件内未能得到有效响应或者响应时间过长，就会造成ANR。</p>
</blockquote>
<p>ANR由<strong>消息处理机制</strong>保证，Android在系统层实现了发现ANR的机制，核心原理是<strong>消息调度和超时处理</strong>。</p>
<p>ANR本质是<strong>性能问题</strong>。实际上是对应用程序主线程的限制，要求主线程在限定时间内处理完一些最常见的操作(<em>启动服务，处理广播，处理输入</em>)，如果处理超时，则认为主线程已经失去了响应其他操作的能力。</p>
<h2 id="ANR发生场景"><a href="#ANR发生场景" class="headerlink" title="ANR发生场景"></a>ANR发生场景</h2><ul>
<li><strong>输入事件(按键和触摸事件)5s内未处理</strong>：Input event dispatching timed out</li>
<li><strong>BroadcastReceiver的<code>onReceive()</code>在规定时间内没处理完(<em>前台广播为10s，后台广播为60s</em>)</strong>：Timeout of broadcast BoradcastRecord</li>
<li><strong>Service在<em>前台20s后台200s</em>时间内为启动完成</strong>：Timeout executing service</li>
<li><strong>ContentProvider的<code>publish()</code>在10s内没有执行完成</strong>：Timeout publishing content providers</li>
</ul>
<h2 id="ANR机制"><a href="#ANR机制" class="headerlink" title="ANR机制"></a>ANR机制</h2><blockquote>
<p>ANR机制主要分为两部分：<strong>ANR监测机制</strong>，<strong>ANR报告机制</strong>。</p>
<ul>
<li>ANR监测机制：Android对于不同的ANR类型(<em>Broadcast,Service,InputEvent</em>)都有一套监测机制。</li>
<li>ANR报告机制：在监测到ANR后，需要显示ANR对话框，输出日志等</li>
</ul>
</blockquote>
<h3 id="输入事件超时监测"><a href="#输入事件超时监测" class="headerlink" title="输入事件超时监测"></a>输入事件超时监测</h3><h4 id="输入系统简介"><a href="#输入系统简介" class="headerlink" title="输入系统简介"></a>输入系统简介</h4><p>内核将原始事件写入到设备节点中，<code>InputReader</code>在期限错循环不断的从<code>EventHub</code>中抽取原始输入事件，进行加工处理后将加工所得的事件放入<code>InputDispatcher</code>的派发队列中。<code>InputDispatcher</code>在其线程循环中将派发队列中的事件取出，查找合适的窗口，将事件写入到窗口的事件接收管道中。</p>
<h4 id="超时监测"><a href="#超时监测" class="headerlink" title="超时监测"></a>超时监测</h4><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/输入事件超时监测.webp" class="full-image" alt="输入事件超时监测" title="输入事件超时监测"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p><code>InputDispaycher::dispatchOnceInnerLocked()</code>：根据事件类型选择不同事件的处理方法</p>
<p><code>InputDispaycher::findFocusedWindowTargetsLocked()</code>：内部调用<code>checkWindowReadyForMoreInputLocked()</code>检查窗口是否有新能力在接受新的输入事件。</p>
<p><code>InputDispatcher::handleTargetsNotReadyLocked()</code>：进行判断事件5s之内是否分发完毕</p>
<p>当应用主线程被卡住时，再点击其他组件也是无响应，因为事件派发是串行的，上一事件未处理完毕，下一事件不会向下执行。</p>
<p>在<code>Activity.onCreate()</code>执行耗时操作，不管用户如何操作都不会发生ANR，因为输入事件相关监听机制尚未建立起来。</p>
<p>输入事件由<code>InputDispatcher</code>调度，待处理的输入输出事件都会进入队列中等待，设计了一个等待超时的判断。</p>
<h3 id="Service超时监测"><a href="#Service超时监测" class="headerlink" title="Service超时监测"></a>Service超时监测</h3><p>本身有分析过<code>Service的启动流程</code>，在其中了解到<code>ActiveServices.realStartServiceLocked()</code>是真正的Service启动流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../core/java/com/android/server/am/ActiveServices.java  </span></span><br><span class="line"><span class="comment">// How long we wait for a service to finish executing.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_TIMEOUT = <span class="number">20</span>*<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// How long we wait for a service to finish executing.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正启动Service</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 主要是为了设置ANR超时，可以看出在正式启动Service之前开始ANR监测；</span></span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);</span><br><span class="line">       <span class="comment">// 启动过程调用scheduleCreateService方法,最终会调用Service.onCreate方法；</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">        <span class="comment">// 绑定过程中，这个方法中会调用app.thread.scheduleBindService方法</span></span><br><span class="line">        requestServiceBindingsLocked(r, execInFg);</span><br><span class="line">        <span class="comment">// 调动Service的其他方法，如onStartCommand，也是IPC通讯</span></span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置超时监测                                         </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleServiceTimeoutLocked</span><span class="params">(ProcessRecord proc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (proc.executingServices.size() == <span class="number">0</span> || proc.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">                ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">        msg.obj = proc;</span><br><span class="line">        <span class="comment">// 在serviceDoneExecutingLocked中会remove该SERVICE_TIMEOUT_MSG消息，</span></span><br><span class="line">        <span class="comment">// 当超时后仍没有remove SERVICE_TIMEOUT_MSG消息，则执行ActiveServices. serviceTimeout()方法；</span></span><br><span class="line">        mAm.mHandler.sendMessageDelayed(msg,</span><br><span class="line">                proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">        <span class="comment">// 前台进程中执行Service，SERVICE_TIMEOUT=20s；后台进程中执行Service，SERVICE_BACKGROUND_TIMEOUT=200s</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AMS中收到了  SERVICE_TIMEOUT_MSG Message就会触发该方法                                       </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceTimeout</span><span class="params">(ProcessRecord proc)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> maxTime =  now -</span><br><span class="line">              (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 寻找运行超时的Service</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=proc.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = proc.executingServices.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (sr.executingStart &lt; maxTime) &#123;</span><br><span class="line">            timeout = sr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 判断执行Service超时的进程是否在最近运行进程列表，如果不在，则忽略这个ANR</span></span><br><span class="line">    <span class="keyword">if</span> (timeout != <span class="keyword">null</span> &amp;&amp; mAm.mLruProcesses.contains(proc)) &#123;</span><br><span class="line">        anrMessage = <span class="string">"executing service "</span> + timeout.shortName;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (anrMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当存在timeout的service，则执行appNotResponding，报告ANR</span></span><br><span class="line">        mAm.appNotResponding(proc, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, anrMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service启动前会先启动超时监测，如果在指定时间内(<em>前台20s后台200s</em>)没有启动完毕，就会调用到<code>ActiveServices.serviceTimeout()</code>报告ANR；如果执行完毕，会调用到<code>ActiveServices.serviceDoneExecutingLocked()</code>在其中<code>removeMessages(SERVICE_TIMEOUT_MSG)</code>移除超时消息。</p>
<h3 id="ANR报告机制"><a href="#ANR报告机制" class="headerlink" title="ANR报告机制"></a>ANR报告机制</h3><p>无论哪种类型的ANR发生后，最终都会调用到<code>AppErrors.appNotResponding()</code>。这个方法主要的功能就是<strong>向用户或开发者报告ANR发生了。</strong>最终的表现就是弹出一个对话框，告诉用户当前程序无法响应；并且会输出ANR日志，以供开发者分析。</p>
<ul>
<li><strong>event log</strong>：通过检索”am_anr”关键字，可以找到发生ANR的应用</li>
<li><strong>main log</strong>：通过检索”ANR in”关键字，可以找到ANR的信息，日志的上下文会包含CPU的使用情况</li>
<li><strong>dropbox</strong>：通过检索”anr”类型，可以找到ANR的信息</li>
<li><strong>traces</strong>：发生ANR时，各进程的函数调用栈信息 (<em>可以通过<code>adb pull data.anr/traces.txt</code>导出trace文件</em>)</li>
</ul>
<p>ANR报告相关内容主要为以上四种，后续如果需要分析ANR问题，分析ANR往往是从<code>main log中的CPU使用情况和导出的traces.txt文件</code>进行分析。</p>
<h2 id="ANR分析"><a href="#ANR分析" class="headerlink" title="ANR分析"></a>ANR分析</h2><p>ANR问题的产生是由于主线程的任务无法在规定事件内无法完成。造成这种情况的原因大致会有以下几点：</p>
<ul>
<li>主线程在做一些耗时的工作</li>
<li>主线程被其他线程锁</li>
<li>cpu被其他线程占用，导致该进程没有被分配到足够的CPU资源</li>
</ul>
<p>分析思路主要是:</p>
<ol>
<li><code>从log中找到ANR发生的信息</code>：在log中搜索<code>am_anr或ANR in</code>找到ANR发生的log，包含了ANR发生的时间，进程，ANRtype。</li>
<li><code>继续分析CPU usage的信息</code>：表明了CPU在ANR前后的用量，从各种CPU usage信息中可以分析几点：<ul>
<li>如果其他进程占用CPU较多，而发生ANR的进程占用较低，可以认为是 因为CPU资源未分配足够，导致的ANR</li>
<li>如果ANR进程占用CPU较多，可以怀疑是内部一些不合理的代码导致CPU资源大量消耗，如出现了死循环或者后台有大量线程在执行任务，或者存在频繁的文件读写(<em>iowait</em>)</li>
<li>CPU总用量都不高，该进程和其他线程的占用过高，可能是由于主线程的操作耗时过长，或者主线程被锁导致。</li>
</ul>
</li>
<li><code>向下继续分析 trace文件</code>：trace文件记录了发生ANR前后该进程中各个线程的stack。对我们分析ANR问题最有价值的就是主线程的stack(<code>main</code>)。一般主线程trace中可能有如下几种情况：<ul>
<li>主线程是<code>running或native</code>而对应的栈对应了我们应用中的函数，则很有可能是执行该函数发生了超时</li>
<li>主线程是<code>block</code>，主线程被锁，可以考虑进行优化代码，解除掉锁的状态。如果是死锁问题，需要及时处理</li>
</ul>
</li>
</ol>
<h2 id="ANR避免和检测"><a href="#ANR避免和检测" class="headerlink" title="ANR避免和检测"></a>ANR避免和检测</h2><p>默认情况下，Android应用程序通常在单线程上运行——<strong>主线程</strong>。ANR的发生场景主要是在主线程中进行了耗时操作。</p>
<blockquote>
<p>哪些算作UI主线程？</p>
<ul>
<li>Activity的所有生命周期回调都是执行在主线程的</li>
<li>Service默认执行在主线程</li>
<li>BoradcastReceiver的<code>onReceive()</code>回调在主线程</li>
<li>没有使用子线程的Looper的Handler实现的<code>handleMessage()</code></li>
<li>AsyncTask除了<code>doInBackground()</code>执行在主线程</li>
<li>View的<code>post(runnable)</code>执行在主线程</li>
</ul>
</blockquote>
<p><strong>主要原则是不要在主线程中做耗时操作。</strong></p>
<p>检测可以利用BlockCanary – 基本原理是利用主线程的消息队列处理机制，通过对比消息分发开始和结束的时间点来判断是否超过设定的时间，超过则判断为线程卡顿。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leo-Wxy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/01/28/ANR分析/">http://yoursite.com/2019/01/28/ANR分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Wxy的个人博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/01/28/Bitmap分析/"><i class="fa fa-chevron-left">  </i><span>Bitmap分析</span></a></div><div class="next-post pull-right"><a href="/2019/01/18/CopyOnWriteArrayList实现原理及简析/"><span>数据结构--CopyOnWriteArrayList实现原理及简析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Leo-Wxy</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>