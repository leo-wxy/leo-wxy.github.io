<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>理解Window及WindowManager - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/dracula.min.css">


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">



<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                理解Window及WindowManager
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2019-01-10 11:48">
                    2019年1月10日 中午
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    2.7k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    40
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/WindowWindowManager.png" srcset="/img/loading.gif" class="full-image" alt="Window&WindowManager" title="Window&WindowManager"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p><code>Window</code>：他是一个抽象类，具体的实现类为<code>PhoneWindow</code>，它对View进行管理。每个Window都会对应一个<code>View</code>和一个<code>ViewRootImpl</code>，Window通过<code>ViewRootImpl</code>与View建立联系。</p>
<p><code>WindowManager</code>：是一个接口类，继承<code>ViewManager</code>，主要用于管理Window，具体实现类为<code>WindowManagerImpl</code>。实际使用中无法直接访问Window，需要通过<code>WindowManager</code>进行操作。</p>
<p><code>WindowManagerService</code>：<code>WindowManager</code>的具体工作都会通过<code>WindowManagerService</code>进行处理，他们之间通过<code>Binder</code>进行跨进程通信，<code>WindowManager</code>无法直接调用WMS中的API。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Window&WindowManager&WMS.png" srcset="/img/loading.gif" class="full-image" alt="Window&WindowManager&WMS" title="Window&WindowManager&WMS"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h2 id="2-Window的属性"><a href="#2-Window的属性" class="headerlink" title="2.Window的属性"></a>2.Window的属性</h2><h3 id="Window的类型-Type"><a href="#Window的类型-Type" class="headerlink" title="Window的类型(Type)"></a>Window的类型(<em>Type</em>)</h3><p>Window有三种类型：</p>
<ul>
<li><p><strong>Application Window(应用窗口)</strong>：对应一个Activity  <code>层级范围为1~99</code></p>
</li>
<li><p><strong>Sub Window(子窗口)</strong>：不能独立存在，需要附着在其他窗口上才行，例如<em>Dialog,PopupWindow</em>   <code>层级范围为1000~1999</code></p>
</li>
<li><strong>System Window(系统窗口)</strong>：需要声明权限才能创建的Window，例如<em>Toast</em>   <code>层级范围为2000~2999</code></li>
</ul>
<p>Window是分层的，层级大的Window会覆盖在层级小的Window上面，上面描述的层级范围对应的是<code>WindowManager.LayoutParams的type参数</code>。</p>
<p>通过<code>layoutParams.type = LayoutParams.TYPE_XXX</code>可以设置层级。<strong>同时需要声明<code>&lt;user-permission android:name=&quot;android:permission.SYSTEM_ALERT_WINDOW&quot;&gt;</code></strong>就可以设置系统窗口的type。</p>
<h3 id="Window的标志-Flag"><a href="#Window的标志-Flag" class="headerlink" title="Window的标志(Flag)"></a>Window的标志(<em>Flag</em>)</h3><p>Window的标志用于控制Window的显示，同时被定义在<code>WindowManager.LayoutParams</code>中，以下列举比较常用的：</p>
<table>
<thead>
<tr>
<th>FLAG</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLAG_NOT_FOCUSABLE</td>
<td>表示Window不需要获取焦点，也不需要接收各种输入事件，同时会设置<code>FLAG_NOT_TOUCH_MODAL</code>标记，最终事件会传递到下层具有焦点的Window</td>
</tr>
<tr>
<td>FLAG_NOT_TOUCH_MODAL</td>
<td>系统会将当前区域以外的触摸事件向下传递，Window以内的事件自己处理。<em>一般需要开启，否则其他Window无法接受时间。</em></td>
</tr>
<tr>
<td>FLAG_SHOW_WHEN_LOCKED</td>
<td>表示Window可显示在锁屏界面。(<em>例如XX助手</em>)</td>
</tr>
<tr>
<td>FLAG_KEEP_SCREEN_ON</td>
<td>只要窗口可见，屏幕就会一直亮着</td>
</tr>
<tr>
<td>FLAG_FULLSCREEN</td>
<td>隐藏所有的屏幕装饰窗口，进入全屏显示</td>
</tr>
</tbody>
</table>
<p>设置Windwo的Flag有三种方法：</p>
<ol>
<li><p>通过Window的<code>addFlags()</code></p>
<div class="hljs"><pre><code class="hljs java">Window mWindow = getWindow();
window.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);</code></pre></div>
</li>
<li><p>通过Window的<code>setFlags()</code></p>
<div class="hljs"><pre><code class="hljs java">Window mWindow = getWindow();
window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);</code></pre></div>
<blockquote>
<p><code>addFlags()</code>内部实现调用的还是<code>setFlags()</code>，两者区别不大。</p>
</blockquote>
</li>
<li><p>设置<code>LayoutParams.flags=XX</code>，并通过<code>addView()</code>添加进Window</p>
<div class="hljs"><pre><code class="hljs java">WindowManager.LayoutParams mLayoutParams = <span class="hljs-keyword">new</span> WindowManager.LayoutParams();
mLayoutParams.flags = WindowManager.LayoutParams.FLAG_FULLSCREEN;
WindowManager mWindowManager = (WindowManager)getSystemService(Context.WINDOW_SERVICE);
TextView tv = <span class="hljs-keyword">new</span> TextView(<span class="hljs-keyword">this</span>);
mWindowManager.addView(tv,mLayoutParams);</code></pre></div>
</li>
</ol>
<h3 id="Window的位置-Gravity"><a href="#Window的位置-Gravity" class="headerlink" title="Window的位置(Gravity)"></a>Window的位置(<em>Gravity</em>)</h3><p>默认位于屏幕中间</p>
<div class="hljs"><pre><code class="hljs java">mLayoutParams.gravity = Gravity.LEFT | Gravity.TOP;<span class="hljs-comment">//配置gravity 居于左上位置</span>
mLayoutParams.x = <span class="hljs-number">100</span>;<span class="hljs-comment">//相对于gravity 居左100</span>
mLayoutParams.y = <span class="hljs-number">300</span>;<span class="hljs-comment">//相对于gravity 居上300</span></code></pre></div>
<p>设置的<code>x、y</code>是相对于gravity的位置</p>
<h3 id="Window软键盘相关模式"><a href="#Window软键盘相关模式" class="headerlink" title="Window软键盘相关模式"></a>Window软键盘相关模式</h3><p>窗口之间的叠加是常见的场景，如果弹出窗口为软键盘的话，可能会有显示问题，默认弹出软键盘会覆盖用户的输入框。<code>WindowManager.LayoutParams</code>中定义了相关的软键盘弹出模式，下面列举常用的几个：</p>
<table>
<thead>
<tr>
<th>SoftInputMode</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOFT_INPUT_STATE_UNSPECIFIED</td>
<td>没有指定状态，系统会自动选择一个</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_UNCHANGED</td>
<td>不会改变软键盘状态</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_HIDDEN</td>
<td>用户进入窗口，软键盘默认隐藏</td>
</tr>
<tr>
<td>SOFT_INPUT_STATE_ALWAYS_HIDDEN</td>
<td>窗口获取焦点时，软键盘总是隐藏</td>
</tr>
<tr>
<td>SOFT_INPUT_ADJUST_RESIZE</td>
<td>软键盘弹出时，窗口会调整大小</td>
</tr>
<tr>
<td>SOFT_INPUT_ADJUST_PAN</td>
<td>软键盘弹出时，窗口不需要调整大小，确保输入焦点是可见</td>
</tr>
</tbody>
</table>
<div class="hljs"><pre><code class="hljs java">getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN)</code></pre></div>
<p>或者设置在<code>AndroidManifest.xml</code>中</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>
          <span class="hljs-attr">android:windowSoftInputMode</span>=<span class="hljs-string">"SOFT_INPUT_ADJUST_PAN"</span>
          /&gt;</span></code></pre></div>
<h2 id="3-Window的操作"><a href="#3-Window的操作" class="headerlink" title="3.Window的操作"></a>3.Window的操作</h2><p>对Window的访问必须通过<code>WindowManager</code>，主要有三大操作：<strong>添加、更新、删除</strong>。这三个方法主要定义在<code>ViewManger</code>中</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ViewManager</span>
</span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewLayout</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeView</span><span class="hljs-params">(View view)</span></span>;
&#125;</code></pre></div>
<p><code>WindowManager</code>也是一个接口继承自<code>ViewManager</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WindowManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewManager</span></span></code></pre></div>
<p><code>WindowManagerImpl</code>就是<code>WindowManager</code>的具体实现类</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowManagerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WindowManager</span> </span>&#123;
 ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewLayout</span><span class="hljs-params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;
        applyDefaultToken(params);
        mGlobal.updateViewLayout(view, params);
    &#125;
  
      <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeView</span><span class="hljs-params">(View view)</span> </span>&#123;
        mGlobal.removeView(view, <span class="hljs-keyword">false</span>);
    &#125;
  ...
&#125;</code></pre></div>
<p>最终<code>WindowManagerImpl</code>对View的操作交由<code>WindowManagerGlobal</code>去实现。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/WindowManager关系.png" srcset="/img/loading.gif" class="full-image" alt="WindowManager关系" title="WindowManager关系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p><code>WindowManagerGlobal</code>通过<code>ViewRootImpl</code>操作Window，<code>ViewRootImpl</code>通过<code>IWindowSession</code>这个Binder对象与<code>WindowManagerService</code>进程间通信去操作Window。</p>
<a href="/2019/01/30/WindowManagerService简析/" title="WindowManagerService简析">WindowManagerService简析</a>
<h3 id="Window添加"><a href="#Window添加" class="headerlink" title="Window添加"></a>Window添加</h3><blockquote>
<p>添加过程需要通过<code>WindowManager.addView()</code>来实现，它的真正实现需要通过<code>WindowManagerGlobal</code></p>
</blockquote>
<div class="hljs"><pre><code class="hljs java">    <span class="hljs-comment">//存储所有Window对应的View</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="hljs-keyword">new</span> ArrayList&lt;View&gt;();
    <span class="hljs-comment">//所有Window对应的ViewRootImpl</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="hljs-keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();
    <span class="hljs-comment">//所有Window对应的布局参数 LayoutParams</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =
            <span class="hljs-keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();
    <span class="hljs-comment">//存储那些正在被删除的对象</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="hljs-keyword">new</span> ArraySet&lt;View&gt;();    

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow)</span> </span>&#123;
        <span class="hljs-comment">//检测参数是否合法</span>
        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"view must not be null"</span>);
        &#125;
        <span class="hljs-keyword">if</span> (display == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"display must not be null"</span>);
        &#125;
        <span class="hljs-keyword">if</span> (!(params <span class="hljs-keyword">instanceof</span> WindowManager.LayoutParams)) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Params must be WindowManager.LayoutParams"</span>);
        &#125; 
      
        <span class="hljs-keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;
        <span class="hljs-comment">//如果是子Window还需要调整参数</span>
        <span class="hljs-keyword">if</span> (parentWindow != <span class="hljs-keyword">null</span>) &#123;
            parentWindow.adjustLayoutParamsForSubWindow(wparams);
        &#125; <span class="hljs-keyword">else</span> &#123;
            
            <span class="hljs-keyword">final</span> Context context = view.getContext();
            <span class="hljs-keyword">if</span> (context != <span class="hljs-keyword">null</span>
                    &amp;&amp; (context.getApplicationInfo().flags
                            &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="hljs-number">0</span>) &#123;
                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
            &#125;
        &#125;
      
      ...
        <span class="hljs-comment">//创建ViewRootImpl</span>
        root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);
        view.setLayoutParams(wparams);
        <span class="hljs-comment">//保存当前界面的参数</span>
        mViews.add(view);
        mRoots.add(root);
        mParams.add(wparams);
      ...
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//调用 ViewRootImpl.setView() 更新界面并完成Window的添加过程</span>
                root.setView(view, wparams, panelParentView);
            &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;
                <span class="hljs-comment">// BadTokenException or InvalidDisplayException, clean up.</span>
                <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;
                    removeViewLocked(index, <span class="hljs-keyword">true</span>);
                &#125;
                <span class="hljs-keyword">throw</span> e;
            &#125;
    &#125;</code></pre></div>
<p>在<code>WindowManagerGlobal.addView()</code>主要完成了以下三步：</p>
<ul>
<li>检查参数是否合法，如果是子Window，还需要调整参数</li>
<li>创建ViewRootImpl，然后保存当前界面参数</li>
<li>调用<code>ViewRootImpl.setView()</code>继续完成Window的添加过程</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewRootImpl.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setView</span><span class="hljs-params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;
  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
    ...
      <span class="hljs-comment">//刷新当前界面</span>
      requestLayout();
    ...
       <span class="hljs-keyword">try</span> &#123;
                    mOrigWindowType = mWindowAttributes.type;
                    mAttachInfo.mRecomputeGlobalAttributes = <span class="hljs-keyword">true</span>;
                    collectViewAttributes();
                    <span class="hljs-comment">//最终添加Window实现过程</span>
                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);
                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
                    mAdded = <span class="hljs-keyword">false</span>;
                    mView = <span class="hljs-keyword">null</span>;
                    mAttachInfo.mRootView = <span class="hljs-keyword">null</span>;
                    mInputChannel = <span class="hljs-keyword">null</span>;
                    mFallbackEventHandler.setView(<span class="hljs-keyword">null</span>);
                    unscheduleTraversals();
                    setAccessibilityFocus(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Adding window failed"</span>, e);
                &#125; <span class="hljs-keyword">finally</span> &#123;
                    <span class="hljs-keyword">if</span> (restore) &#123;
                        attrs.restore();
                    &#125;
                &#125;
  &#125;
&#125;</code></pre></div>
<p><code>mWindowSession</code>的类型是<code>IWindowSession</code>是一个Binder对象，用于进行进程间通信，它是<code>Session</code>代理对象。</p>
<p>添加完成后，需要通过返回值<code>res</code>来判断是否添加成功。若是<code>WindowManagerGlobal.ADD_PKAY</code>说明添加成功。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/wm/Session.java</span>
    <span class="hljs-keyword">final</span> WindowManagerService mService;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addToDisplay</span><span class="hljs-params">(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,
            <span class="hljs-keyword">int</span> viewVisibility, <span class="hljs-keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,
            Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;
        <span class="hljs-keyword">return</span> mService.addWindow(<span class="hljs-keyword">this</span>, window, seq, attrs, viewVisibility, displayId,
                outContentInsets, outStableInsets, outOutsets, outInputChannel);
    &#125;</code></pre></div>
<p><code>addToDisplay()</code>最终调用到<code>WindowManagerService.addWindow()</code>实现Window添加过程。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Window添加过程.png" srcset="/img/loading.gif" class="full-image" alt="Window添加过程" title="Window添加过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="Window更新"><a href="#Window更新" class="headerlink" title="Window更新"></a>Window更新</h3><blockquote>
<p>更新过程需要通过<code>WindowManager.updateViewLayout()</code>，它的真正实现需要通过<code>WindowManagerGlobal</code></p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/WindowManagerGlobal.java   </span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewLayout</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"view must not be null"</span>);
        &#125;
        <span class="hljs-keyword">if</span> (!(params <span class="hljs-keyword">instanceof</span> WindowManager.LayoutParams)) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Params must be WindowManager.LayoutParams"</span>);
        &#125;

        <span class="hljs-keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;
        <span class="hljs-comment">//更新View的LayoutParams</span>
        view.setLayoutParams(wparams);

        <span class="hljs-keyword">synchronized</span> (mLock) &#123;
            <span class="hljs-keyword">int</span> index = findViewLocked(view, <span class="hljs-keyword">true</span>);
            ViewRootImpl root = mRoots.get(index);
            mParams.remove(index);
            mParams.add(index, wparams);
            root.setLayoutParams(wparams, <span class="hljs-keyword">false</span>);
        &#125;
    &#125;</code></pre></div>
<p>更新View的LayoutParams之后，还需要更新<code>ViewRootImpl.setLayoutParams()</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/ViewRootImpl.java</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLayoutParams</span><span class="hljs-params">(WindowManager.LayoutParams attrs, <span class="hljs-keyword">boolean</span> newView)</span> </span>&#123;
  <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;
    ...
            <span class="hljs-keyword">if</span> (newView) &#123;
                mSoftInputMode = attrs.softInputMode;
                requestLayout();
            &#125;

            <span class="hljs-keyword">if</span> ((attrs.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)
                    == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) &#123;
                mWindowAttributes.softInputMode = (mWindowAttributes.softInputMode
                        &amp; ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)
                        | (oldSoftInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST);
            &#125;

            mWindowAttributesChanged = <span class="hljs-keyword">true</span>;
            <span class="hljs-comment">//开始View的测量，布局，绘制流程</span>
            scheduleTraversals();
  &#125;
&#125;</code></pre></div>
<p>在<code>scheduleTraversals()</code>调用到<code>performTraversals()</code>继续执行更新过程</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performTraversals</span><span class="hljs-params">()</span> </span>&#123;
  ...
    relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);
  ...
    <span class="hljs-keyword">if</span>(!mStopped)&#123;
      <span class="hljs-keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
      <span class="hljs-keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); 
      <span class="hljs-comment">//开始测量过程</span>
      performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    &#125;
    ...
    <span class="hljs-comment">//layoutRequested 是否需要重新执行布局过程</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);
    <span class="hljs-keyword">if</span>(didLayout)&#123;
      <span class="hljs-comment">//开始布局过程</span>
      performLayout(lp, mWidth, mHeight);
    &#125;
    ...
    <span class="hljs-keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;
            <span class="hljs-keyword">if</span> (mPendingTransitions != <span class="hljs-keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;
                    mPendingTransitions.get(i).startChangingAnimations();
                &#125;
                mPendingTransitions.clear();
            &#125;
            <span class="hljs-comment">//开始绘制过程</span>
            performDraw();
        &#125; 
  ...
  
&#125;</code></pre></div>
<p><code>performTraversals()</code>内部实现了Window更新以及View的整个工作过程(<em>测量-布局-绘制</em>)。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">relayoutWindow</span><span class="hljs-params">(WindowManager.LayoutParams params, <span class="hljs-keyword">int</span> viewVisibility,
        <span class="hljs-keyword">boolean</span> insetsPending)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;
  ...
     <span class="hljs-keyword">int</span> relayoutResult = mWindowSession.relayout(
            mWindow, mSeq, params,
            (<span class="hljs-keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="hljs-number">0.5f</span>),
            (<span class="hljs-keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="hljs-number">0.5f</span>),
            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="hljs-number">0</span>,
            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame,
            mPendingMergedConfiguration, mSurface);
  ...
&#125;</code></pre></div>
<p><code>mWindowSession</code>的类型是<code>IWindowSession</code>是一个Binder对象，用于进行进程间通信，它是<code>Session</code>代理对象。</p>
<p><code>mWindow</code>即<code>W extends IWindow.Stub</code>发送给WindowManagerService，用来接受WMS信息。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// ../core/java/com/android/server/wm/Session.java</span>
    <span class="hljs-keyword">final</span> WindowManagerService mService;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">relayout</span><span class="hljs-params">(IWindow window, <span class="hljs-keyword">int</span> seq, WindowManager.LayoutParams attrs,
            <span class="hljs-keyword">int</span> requestedWidth, <span class="hljs-keyword">int</span> requestedHeight, <span class="hljs-keyword">int</span> viewFlags,
            <span class="hljs-keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
            Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,
            MergedConfiguration mergedConfiguration, Surface outSurface)</span> </span>&#123;

        <span class="hljs-keyword">int</span> res = mService.relayoutWindow(<span class="hljs-keyword">this</span>, window, seq, attrs,
                requestedWidth, requestedHeight, viewFlags, flags,
                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,
                outStableInsets, outsets, outBackdropFrame, mergedConfiguration, outSurface);

        <span class="hljs-keyword">return</span> res;
    &#125;</code></pre></div>
<p><code>relayout()</code>最终调用到<code>WindowManagerService.relayoutWindow()</code>实现Window更新过程。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Window更新过程.png" srcset="/img/loading.gif" class="full-image" alt="Window更新过程" title="Window更新过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="Window删除"><a href="#Window删除" class="headerlink" title="Window删除"></a>Window删除</h3><blockquote>
<p>删除过程需要通过<code>WindowManager.removeView()</code>来实现，它的真正实现需要通过<code>WindowManagerGlobal</code></p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// ../android/view/WindowManagerGlobal.java   </span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeView</span><span class="hljs-params">(View view, <span class="hljs-keyword">boolean</span> immediate)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"view must not be null"</span>);
        &#125;

        <span class="hljs-keyword">synchronized</span> (mLock) &#123;
            <span class="hljs-comment">//找到需要删除的View索引</span>
            <span class="hljs-keyword">int</span> index = findViewLocked(view, <span class="hljs-keyword">true</span>);
            View curView = mRoots.get(index).getView();
            removeViewLocked(index, immediate);
            <span class="hljs-keyword">if</span> (curView == view) &#123;
                <span class="hljs-keyword">return</span>;
            &#125;

            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Calling with view "</span> + view
                    + <span class="hljs-string">" but the ViewAncestor is attached to "</span> + curView);
        &#125;
    &#125;</code></pre></div>
<p>实际调用<code>removeViewLocked()</code>执行删除Window操作，内部实现还是依赖了<code>ViewRootImpl</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeViewLocked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">boolean</span> immediate)</span> </span>&#123;
       <span class="hljs-comment">//从Window添加过程中保存的 ViewRootImpl数组中获取对应的ViewRootImpl对象</span>
       ViewRootImpl root = mRoots.get(index);
       View view = root.getView();

       <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;
           InputMethodManager imm = InputMethodManager.getInstance();
           <span class="hljs-keyword">if</span> (imm != <span class="hljs-keyword">null</span>) &#123;
               imm.windowDismissed(mViews.get(index).getWindowToken());
           &#125;
       &#125;
       <span class="hljs-comment">//在die 中执行删除Window操作</span>
       <span class="hljs-keyword">boolean</span> deferred = root.die(immediate);
       <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;
           view.assignParent(<span class="hljs-keyword">null</span>);
           <span class="hljs-keyword">if</span> (deferred) &#123;
               <span class="hljs-comment">//存储即将删除的View</span>
               mDyingViews.add(view);
           &#125;
       &#125;
   &#125;</code></pre></div>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">die</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> immediate<span class="hljs-comment">/*是否同步执行删除*/</span>)</span> </span>&#123;
    <span class="hljs-comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span>
    <span class="hljs-comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span>
    <span class="hljs-keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;
        <span class="hljs-comment">//删除对应Window</span>
        doDie();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;

    <span class="hljs-keyword">if</span> (!mIsDrawing) &#123;
        destroyHardwareRenderer();
    &#125; <span class="hljs-keyword">else</span> &#123;
        Log.e(mTag, <span class="hljs-string">"Attempting to destroy the window while drawing!\n"</span> +
                <span class="hljs-string">"  window="</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">", title="</span> + mWindowAttributes.getTitle());
    &#125;
    mHandler.sendEmptyMessage(MSG_DIE);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre></div>
<p><code>die()</code>中分为两种移除Window方式：<em>同步执行、异步执行(通过Handler)</em>。最终都会执行到<code>doDie()</code></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doDie</span><span class="hljs-params">()</span> </span>&#123;
    checkThread();
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
        <span class="hljs-keyword">if</span> (mRemoved) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        mRemoved = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (mAdded) &#123;
            <span class="hljs-comment">//已经添加成功的，需要进行删除</span>
            dispatchDetachedFromWindow();
        &#125;
        ...
        mAdded = <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-comment">//从保存的那些参数中 移除该View的所有引用</span>
    WindowManagerGlobal.getInstance().doRemoveView(<span class="hljs-keyword">this</span>);
&#125;</code></pre></div>
<p><code>doDie()</code>主要实现了两个功能：</p>
<ul>
<li><code>dispatchDetachedFromWindow()</code>：移除Window</li>
<li><code>doRemoveView()</code>：移除Window所对应的引用</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchDetachedFromWindow</span><span class="hljs-params">()</span> </span>&#123;
   <span class="hljs-comment">//触发View的 onDetachedFromWindow()</span>
       <span class="hljs-keyword">if</span> (mView != <span class="hljs-keyword">null</span> &amp;&amp; mView.mAttachInfo != <span class="hljs-keyword">null</span>) &#123;
           mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="hljs-keyword">false</span>);
           mView.dispatchDetachedFromWindow();
       &#125;
   ...
       <span class="hljs-keyword">try</span> &#123;
           <span class="hljs-comment">//依靠Session去移除Window</span>
           mWindowSession.remove(mWindow);
       &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
       &#125;
   ...
       unscheduleTraversals();
&#125;</code></pre></div>
<p><code>mWindowSession</code>的类型是<code>IWindowSession</code>是一个Binder对象，用于进行进程间通信，它是<code>Session</code>代理对象。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(IWindow window)</span> </span>&#123;
    mService.removeWindow(<span class="hljs-keyword">this</span>, window);
&#125;</code></pre></div>
<p><code>remove()</code>最终通过<code>WindowManagerService.removeView()</code>实现Window删除逻辑。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Window删除过程.png" srcset="/img/loading.gif" class="full-image" alt="Window删除过程" title="Window删除过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>上述Window的三大操作(<em>添加、更新和删除</em>)都会通过一个IPC过程调用<code>WindowManagerService</code>去实现具体逻辑。</p>
<p>三大操作过程也都需要通过<code>ViewRootImpl</code>来关联起Window和View，<code>ViewRootImpl</code>可以控制内部VIew的<em>测量、布局与绘制</em>。</p>
<p><strong>在上述三大操作中，虽然说是由<code>WindowManagerGlobal</code>去实现，但内部是依靠的<code>ViewRootImpl</code>，实际执行的是<code>WindowManagerService</code>。</strong><a href="/2019/01/30/WindowManagerService简析/" title="WindowManagerService简析">WindowManagerService简析</a></p>
</blockquote>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2019/01/10/Service工作过程/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Service工作过程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2019/01/06/Binder系列-Binder/">
                        <span class="hidden-mobile">Binder系列-Binder</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
