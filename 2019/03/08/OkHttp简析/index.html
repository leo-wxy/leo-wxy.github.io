

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
    <meta name="description" content="基于OkHttp 3.13版本进行分析   OkHttp定义OkHttp现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。 所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。 OkHttp支持SPDY协议，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp简析">
<meta property="og:url" content="http://example.com/2019/03/08/OkHttp%E7%AE%80%E6%9E%90/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="基于OkHttp 3.13版本进行分析   OkHttp定义OkHttp现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。 所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。 OkHttp支持SPDY协议，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/OkHttp%E7%AE%80%E6%9E%90mind.png">
<meta property="og:image" content="http://example.com/images/OkHttp-%E6%9E%84%E9%80%A0OkHttpClient%E5%AF%B9%E8%B1%A1.png">
<meta property="og:image" content="http://example.com/images/OkHttp-%E6%9E%84%E9%80%A0Request%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1.png">
<meta property="og:image" content="http://example.com/images/OkHttp-%E5%8F%91%E9%80%81Request%E8%AF%B7%E6%B1%82.png">
<meta property="og:image" content="http://example.com/images/OkHttp-%E5%A4%84%E7%90%86Request%E8%AF%B7%E6%B1%82.png">
<meta property="og:image" content="http://example.com/images/OkHttp-ApplicationInterceptor.png">
<meta property="og:image" content="http://example.com/images/OkHttp-RetryAndFollowUpInterceptor.png">
<meta property="og:image" content="http://example.com/images/OkHttp-BridgeInterceptor.png">
<meta property="og:image" content="http://example.com/images/OkHttp-CacheInterceptor.png">
<meta property="og:image" content="http://example.com/images/OkHttp-ConnectInterceptor.png">
<meta property="og:image" content="http://example.com/images/OkHttp-NetworkInterceptor.png">
<meta property="og:image" content="http://example.com/images/OkHttp-CallServerInterceptor.png">
<meta property="og:image" content="http://example.com/images/OkHttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/images/OkHttp-HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.png">
<meta property="og:image" content="http://example.com/images/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/images/%E5%AF%B9%E6%AF%94%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/images/OkHttp%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0.png">
<meta property="og:image" content="http://example.com/images/1345862-20200603214235374-1759578389.png">
<meta property="og:image" content="http://example.com/images/OkHttp-Cookie%E6%9C%BA%E5%88%B6.png">
<meta property="og:image" content="http://example.com/images/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84">
<meta property="og:image" content="http://example.com/images/OkHttp-LocalDNS.png">
<meta property="og:image" content="http://example.com/images/DNS%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">
<meta property="og:image" content="http://example.com/images/640-2236080.">
<meta property="og:image" content="http://example.com/images/OkHttp-HTTPDNS.png">
<meta property="og:image" content="http://example.com/images/HTTPDNS%E5%8E%9F%E7%90%86.jpeg">
<meta property="og:image" content="http://example.com/images/OkHttp-HTTP2.0.png">
<meta property="og:image" content="http://example.com/images/OkHttp%E8%A7%A3%E6%9E%90%E8%8A%82%E7%82%B9">
<meta property="article:published_time" content="2019-03-08T02:18:29.000Z">
<meta property="article:modified_time" content="2021-01-21T03:21:19.000Z">
<meta property="article:author" content="Leo-Wxy">
<meta property="article:tag" content="源码解析">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/images/OkHttp%E7%AE%80%E6%9E%90mind.png">
  
  
  
  <title>OkHttp简析 - Wxy的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":false};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">OkHttp简析</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-03-08 10:18" pubdate>
          2019年3月8日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          39 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">OkHttp简析</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>基于OkHttp 3.13版本进行分析</p>
</blockquote>
<p><img src="/images/OkHttp%E7%AE%80%E6%9E%90mind.png" srcset="/img/loading.gif" lazyload alt="OkHttp简析"></p>
<h2 id="OkHttp定义"><a href="#OkHttp定义" class="headerlink" title="OkHttp定义"></a>OkHttp定义</h2><p><code>OkHttp</code>现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。</p>
<p>所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。</p>
<p>OkHttp支持<code>SPDY协议</code>，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。</p>
<blockquote>
<p><code>SPDY协议</code>：Google提出的基于TCP的应用层协议，通过<code>压缩、多路复用、优先级</code>来缩短加载时间。</p>
</blockquote>
<h2 id="OkHttp使用示例"><a href="#OkHttp使用示例" class="headerlink" title="OkHttp使用示例"></a>OkHttp使用示例</h2><h3 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>     .url(url)<br>     .build();<br><br></code></pre></td></tr></table></figure>

<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RequestBody</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> RequestBody.create(JSON, json);<br><span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>    .url(url)<br>    .post(body)<br>    .build();<br></code></pre></td></tr></table></figure>

<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>();<br><span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.newCall(request).execute();<br><span class="hljs-keyword">return</span> response.body().string();<br></code></pre></td></tr></table></figure>

<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>();<br><br>client.newCall(request).enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(Call call, okhttp3.Response response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>



<h2 id="OkHttp源码分析"><a href="#OkHttp源码分析" class="headerlink" title="OkHttp源码分析"></a>OkHttp源码分析</h2><h3 id="构造OkHttpClient对象"><a href="#构造OkHttpClient对象" class="headerlink" title="构造OkHttpClient对象"></a>构造<code>OkHttpClient</code>对象</h3><p><img src="/images/OkHttp-%E6%9E%84%E9%80%A0OkHttpClient%E5%AF%B9%E8%B1%A1.png" srcset="/img/loading.gif" lazyload alt="构造OkHttpClient对象"></p>
<blockquote>
<p>需要先创建一个<code>OkHttpClient</code>用以执行后续请求。<strong>内部主要是相关参数配置。</strong></p>
<p>主要功能：通信的客户端，用以统一发起请求与解析返回值。</p>
</blockquote>
<figure class="highlight java"><figcaption><span>OkHttpClient.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">OkHttpClient</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Builder</span>());<br>&#125;<br><br>OkHttpClient(Builder builder) &#123;<br>  <span class="hljs-comment">//用于调用网络请求 本质为 线程池</span><br>  <span class="hljs-built_in">this</span>.dispatcher = builder.dispatcher;<br>  <span class="hljs-comment">//设置代理</span><br>  <span class="hljs-built_in">this</span>.proxy = builder.proxy;<br>  <span class="hljs-comment">//设置协议</span><br>  <span class="hljs-built_in">this</span>.protocols = builder.protocols;<br>  <span class="hljs-built_in">this</span>.connectionSpecs = builder.connectionSpecs;<br>  <span class="hljs-comment">//设置拦截器</span><br>  <span class="hljs-built_in">this</span>.interceptors = Util.immutableList(builder.interceptors);<br>  <span class="hljs-comment">//设置网络拦截器</span><br>  <span class="hljs-built_in">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);<br>  <span class="hljs-comment">//回调监听</span><br>  <span class="hljs-built_in">this</span>.eventListenerFactory = builder.eventListenerFactory;<br>  <span class="hljs-built_in">this</span>.proxySelector = builder.proxySelector;<br>  <span class="hljs-comment">//Cookie</span><br>  <span class="hljs-built_in">this</span>.cookieJar = builder.cookieJar;<br>  <span class="hljs-comment">//缓存</span><br>  <span class="hljs-built_in">this</span>.cache = builder.cache;<br>  <span class="hljs-built_in">this</span>.internalCache = builder.internalCache;<br>  <span class="hljs-built_in">this</span>.socketFactory = builder.socketFactory;<br><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isTLS</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;<br>    isTLS = isTLS || spec.isTls();<br>  &#125;<br><br>  <span class="hljs-comment">//用于Https请求</span><br>  <span class="hljs-keyword">if</span> (builder.sslSocketFactory != <span class="hljs-literal">null</span> || !isTLS) &#123;<br>    <span class="hljs-built_in">this</span>.sslSocketFactory = builder.sslSocketFactory;<br>    <span class="hljs-built_in">this</span>.certificateChainCleaner = builder.certificateChainCleaner;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">X509TrustManager</span> <span class="hljs-variable">trustManager</span> <span class="hljs-operator">=</span> Util.platformTrustManager();<br>    <span class="hljs-built_in">this</span>.sslSocketFactory = newSslSocketFactory(trustManager);<br>    <span class="hljs-built_in">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (sslSocketFactory != <span class="hljs-literal">null</span>) &#123;<br>    Platform.get().configureSslSocketFactory(sslSocketFactory);<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.hostnameVerifier = builder.hostnameVerifier;<br>  <span class="hljs-built_in">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(<br>      certificateChainCleaner);<br>  <span class="hljs-built_in">this</span>.proxyAuthenticator = builder.proxyAuthenticator;<br>  <span class="hljs-built_in">this</span>.authenticator = builder.authenticator;<br>  <span class="hljs-built_in">this</span>.connectionPool = builder.connectionPool;<br>  <span class="hljs-built_in">this</span>.dns = builder.dns;<br>  <span class="hljs-built_in">this</span>.followSslRedirects = builder.followSslRedirects;<br>  <span class="hljs-built_in">this</span>.followRedirects = builder.followRedirects;<br>  <span class="hljs-comment">//是否需要重试</span><br>  <span class="hljs-built_in">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;<br>  <span class="hljs-built_in">this</span>.callTimeout = builder.callTimeout;<br>  <span class="hljs-comment">//链接超时时长</span><br>  <span class="hljs-built_in">this</span>.connectTimeout = builder.connectTimeout;<br>  <span class="hljs-comment">//读取超时时间</span><br>  <span class="hljs-built_in">this</span>.readTimeout = builder.readTimeout;<br>  <span class="hljs-comment">//写入超时时间</span><br>  <span class="hljs-built_in">this</span>.writeTimeout = builder.writeTimeout;<br>  <span class="hljs-built_in">this</span>.pingInterval = builder.pingInterval;<br><br>  <span class="hljs-keyword">if</span> (interceptors.contains(<span class="hljs-literal">null</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Null interceptor: &quot;</span> + interceptors);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (networkInterceptors.contains(<span class="hljs-literal">null</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Null network interceptor: &quot;</span> + networkInterceptors);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>OkHttpClient</code>是应用<strong>建造者模式</strong>，通过<code>OkHttpClient.Builder</code>来构造一个<code>OkHttpClient</code>对象，支持数十种参数配置。</p>
<h3 id="构造Request请求对象"><a href="#构造Request请求对象" class="headerlink" title="构造Request请求对象"></a>构造<code>Request</code>请求对象</h3><p><img src="/images/OkHttp-%E6%9E%84%E9%80%A0Request%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1.png" srcset="/img/loading.gif" lazyload alt="OkHttp-构造Request请求对象"></p>
<blockquote>
<p>创建一个<code>Request</code>对象用以包括请求的所有信息，内部包含了<strong>请求地址，请求头，请求内容</strong>。</p>
<p>主要功能：封装请求的具体信息。</p>
</blockquote>
<figure class="highlight java"><figcaption><span>Request.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Request</span> &#123;<br>  Request(Builder builder) &#123;<br>    <span class="hljs-comment">//请求地址</span><br>    <span class="hljs-built_in">this</span>.url = builder.url;<br>    <span class="hljs-comment">//请求方法 例如：GET、POST、PUT、DELETE等</span><br>    <span class="hljs-built_in">this</span>.method = builder.method;<br>    <span class="hljs-comment">//请求头信息</span><br>    <span class="hljs-built_in">this</span>.headers = builder.headers.build();<br>    <span class="hljs-comment">//请求内容构造体</span><br>    <span class="hljs-built_in">this</span>.body = builder.body;<br>    <span class="hljs-comment">//请求的标签  用于后续对指定标签可进行特殊处理</span><br>    <span class="hljs-built_in">this</span>.tags = Util.immutableMap(builder.tags);<br>  &#125;<br>    <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-meta">@Nullable</span> HttpUrl url;<br>    String method;<br>    Headers.Builder headers;<br>    <span class="hljs-meta">@Nullable</span> RequestBody body;<br><br>    <span class="hljs-comment">/** A mutable map of tags, or an immutable empty map if we don&#x27;t have any. */</span><br>    Map&lt;Class&lt;?&gt;, Object&gt; tags = Collections.emptyMap();<br>    <br>    <span class="hljs-comment">//默认是GET方法，不带有请求体</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">this</span>.method = <span class="hljs-string">&quot;GET&quot;</span>;<br>      <span class="hljs-built_in">this</span>.headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Headers</span>.Builder();<br>    &#125;<br><br>    Builder(Request request) &#123;<br>      <span class="hljs-built_in">this</span>.url = request.url;<br>      <span class="hljs-built_in">this</span>.method = request.method;<br>      <span class="hljs-built_in">this</span>.body = request.body;<br>      <span class="hljs-built_in">this</span>.tags = request.tags.isEmpty()<br>          ? Collections.emptyMap()<br>          : <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(request.tags);<br>      <span class="hljs-built_in">this</span>.headers = request.headers.newBuilder();<br>    &#125;<br>     ... <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Request</code>使用的也是<strong>建造者模式</strong>，通过<code>Request.Builder</code>去构造对应<code>Request</code>。</p>
<h4 id="请求体RequestBody"><a href="#请求体RequestBody" class="headerlink" title="请求体RequestBody"></a>请求体<code>RequestBody</code></h4><blockquote>
<p>主要功能：用以提交<strong>流、表单等请求信息</strong>。</p>
</blockquote>
<h5 id="FormBody"><a href="#FormBody" class="headerlink" title="FormBody"></a>FormBody</h5><blockquote>
<p>支持提交键值对类型。例如<code>userId : 1 </code></p>
</blockquote>
<p>使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">FormBody.<span class="hljs-type">Builder</span> <span class="hljs-variable">formBodyBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormBody</span>.Builder();<br>Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;<br>    formBodyBuilder.add(entry.getKey(), entry.getValue().toString());<br>&#125;<br><span class="hljs-type">RequestBody</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> formBodyBuilder.build();<br></code></pre></td></tr></table></figure>



<h5 id="MultipartBody"><a href="#MultipartBody" class="headerlink" title="MultipartBody"></a>MultipartBody</h5><blockquote>
<p>除了支持键值对，还有提交文件功能。</p>
</blockquote>
<p>使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">MultipartBody.<span class="hljs-type">Builder</span> <span class="hljs-variable">multipartBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MultipartBody</span>.Builder().setType(MultipartBody.FORM);<br>       Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>       <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;<br>           multipartBuilder.addFormDataPart(entry.getKey(), entry.getValue().toString());<br>       &#125;<br>       <span class="hljs-comment">//可以针对文件新起一个 参数来进行传递</span><br>       <span class="hljs-keyword">for</span> (Map.Entry&lt;String, File&gt; entry : message.getFiles().entrySet()) &#123;<br>           <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> entry.getValue();<br>           <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>               <span class="hljs-keyword">continue</span>;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> f.getName();<br>           <span class="hljs-type">String</span> <span class="hljs-variable">ext</span> <span class="hljs-operator">=</span> name.substring(name.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>));<br>           <span class="hljs-type">String</span> <span class="hljs-variable">imageFormat</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jpg&quot;</span>;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;.png&quot;</span>.equalsIgnoreCase(ext)) &#123;<br>               imageFormat = <span class="hljs-string">&quot;png&quot;</span>;<br>           &#125;<br>           multipartBuilder.addFormDataPart(<br>                   entry.getKey(),<br>                   entry.getValue().getName(),<br>                   RequestBody.create(MediaType.parse(<span class="hljs-string">&quot;image/&quot;</span> + imageFormat), entry.getValue())<br>           );<br>       &#125;<br><br>       <span class="hljs-type">RequestBody</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> multipartBuilder.build();<br></code></pre></td></tr></table></figure>



<h3 id="发送Request请求"><a href="#发送Request请求" class="headerlink" title="发送Request请求"></a>发送<code>Request</code>请求</h3><p><img src="/images/OkHttp-%E5%8F%91%E9%80%81Request%E8%AF%B7%E6%B1%82.png" srcset="/img/loading.gif" lazyload alt="OkHttp-发送Request请求"></p>
<p>通过<code>OkHttpClient.newCall()</code>发送出<code>Request</code>请求</p>
<figure class="highlight java"><figcaption><span>OkHttpClient.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Call <span class="hljs-title function_">newCall</span><span class="hljs-params">(Request request)</span> &#123;<br>  <span class="hljs-keyword">return</span> RealCall.newRealCall(<span class="hljs-built_in">this</span>, request, <span class="hljs-literal">false</span> <span class="hljs-comment">/* for web socket */</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>返回了一个<code>Call</code>对象，实现类为<code>RealCall</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Call</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>  <span class="hljs-comment">//获取当前请求</span><br>  Request <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//执行当前请求 并返回结果</span><br>  Response <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>  <span class="hljs-comment">//异步请求</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Callback responseCallback)</span>;<br>  <span class="hljs-comment">//取消请求</span><br>  <span class="hljs-comment">/** Cancels the request, if possible. Requests that are already complete cannot be canceled. */</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//当前请求是否正在执行</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExecuted</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//请求是否已取消</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCanceled</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//超时返回</span><br>  Timeout <span class="hljs-title function_">timeout</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//克隆请求 用于重新调用</span><br>  Call <span class="hljs-title function_">clone</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Factory</span> &#123;<br>    Call <span class="hljs-title function_">newCall</span><span class="hljs-params">(Request request)</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span>RealCall.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Call</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">RealCall</span><span class="hljs-params">(OkHttpClient client, Request originalRequest, <span class="hljs-type">boolean</span> forWebSocket)</span> &#123;<br>    	<span class="hljs-comment">//前面先行创建的 OkHttpClient</span><br>    	<span class="hljs-built_in">this</span>.client = client;<br>        <span class="hljs-comment">//创建的请求对象</span><br>    	<span class="hljs-built_in">this</span>.originalRequest = originalRequest;<br>   		<span class="hljs-comment">//用于建立长连接</span><br>    	<span class="hljs-built_in">this</span>.forWebSocket = forWebSocket;<br>  	&#125;<br>    <br>    <span class="hljs-keyword">static</span> RealCall <span class="hljs-title function_">newRealCall</span><span class="hljs-params">(OkHttpClient client, Request originalRequest, <span class="hljs-type">boolean</span> forWebSocket)</span> &#123;<br>    	<span class="hljs-comment">// Safely publish the Call instance to the EventListener.</span><br>    	<span class="hljs-type">RealCall</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealCall</span>(client, originalRequest, forWebSocket);<br>        <span class="hljs-comment">//为这次请求设置了事件监听器，包括请求开始、结束、异常等监听</span><br>    	call.transmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transmitter</span>(client, call);<br>    	<span class="hljs-keyword">return</span> call;<br>  	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>newCall()</code>根据传递进来的<code>Request</code>创建一个<code>RealCall</code>实例去发送请求。</p>
<h4 id="同步请求——execute"><a href="#同步请求——execute" class="headerlink" title="同步请求——execute()"></a>同步请求——execute()</h4><blockquote>
<p>直接执行并返回请求结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Already Executed&quot;</span>);<br>      executed = <span class="hljs-literal">true</span>;<br>    &#125;<br>    transmitter.timeoutEnter();<br>    <span class="hljs-comment">//请求开始</span><br>    transmitter.callStart();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//加入 runningSuncCalls 队列中</span><br>      client.dispatcher().executed(<span class="hljs-built_in">this</span>);<br>      <span class="hljs-comment">//返回响应结果</span><br>      <span class="hljs-keyword">return</span> getResponseWithInterceptorChain();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">//从队列中移除 避免重复执行</span><br>      client.dispatcher().finished(<span class="hljs-built_in">this</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>执行<code>execute()</code>时，监听到请求事件开始，就会加入到<code>Dispatcher.runningSyncCalls</code>中，里面记录的是当前正在进行同步请求的call，然后当call完成时或因异常结束时，再从<code>Dispatcher.runningSyncCalls</code>移除。</p>
</blockquote>
<h4 id="异步请求——enqueue-Callback-callback"><a href="#异步请求——enqueue-Callback-callback" class="headerlink" title="异步请求——enqueue(Callback callback)"></a>异步请求——enqueue(Callback callback)</h4><blockquote>
<p>构造一个异步执行队列，然后把请求加入队列中处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Callback responseCallback)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Already Executed&quot;</span>);<br>      executed = <span class="hljs-literal">true</span>;<br>    &#125;<br>    transmitter.callStart();<br>    client.dispatcher().enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCall</span>(responseCallback));<br>  &#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncCall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NamedRunnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Callback responseCallback;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">callsPerHost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    AsyncCall(Callback responseCallback) &#123;<br>      <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;OkHttp %s&quot;</span>, redactedUrl());<br>      <span class="hljs-built_in">this</span>.responseCallback = responseCallback;<br>    &#125;<br><br>    AtomicInteger <span class="hljs-title function_">callsPerHost</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> callsPerHost;<br>    &#125;<br>    ...<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeOn</span><span class="hljs-params">(ExecutorService executorService)</span> &#123;<br>      <span class="hljs-keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        executorService.execute(<span class="hljs-built_in">this</span>);<br>        success = <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>        <span class="hljs-type">InterruptedIOException</span> <span class="hljs-variable">ioException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedIOException</span>(<span class="hljs-string">&quot;executor rejected&quot;</span>);<br>        ioException.initCause(e);<br>        transmitter.noMoreExchanges(ioException);<br>        responseCallback.onFailure(RealCall.<span class="hljs-built_in">this</span>, ioException);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>          client.dispatcher().finished(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// This call is no longer running!</span><br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">signalledCallback</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      transmitter.timeoutEnter();<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> getResponseWithInterceptorChain();<br>        signalledCallback = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//回调请求结果</span><br>        responseCallback.onResponse(RealCall.<span class="hljs-built_in">this</span>, response);<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">if</span> (signalledCallback) &#123;<br>          <span class="hljs-comment">// Do not signal the callback twice!</span><br>          Platform.get().log(INFO, <span class="hljs-string">&quot;Callback failure for &quot;</span> + toLoggableString(), e);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//回调失败并返回异常</span><br>          responseCallback.onFailure(RealCall.<span class="hljs-built_in">this</span>, e);<br>        &#125;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//从队列中移除</span><br>        client.dispatcher().finished(<span class="hljs-built_in">this</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>enqueue()</code>调用到<code>Dispatcher.enqueue()</code>传入的是一个<code>AsyncCall</code>对象，<code>AsyncCall</code>本质是一个<code>Runnable</code>对象，通过<code>Dispatcher</code>中的<code>ExecutorService</code>来执行<code>AsyncCall</code>。</p>
</blockquote>
<h3 id="执行Request请求"><a href="#执行Request请求" class="headerlink" title="执行Request请求"></a>执行<code>Request</code>请求</h3><blockquote>
<p>由<code>execute()</code>或<code>enqueue()</code>发送请求时，最后都是需要有<code>Dispatch</code>去执行请求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dispatcher</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxRequests</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxRequestsPerHost</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> ExecutorService executorService;<br>  <span class="hljs-comment">//正在准备执行的异步请求队列</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>  <span class="hljs-comment">//正在执行的异步请求队列</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>  <span class="hljs-comment">//正在执行的同步请求队列 </span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <br>  <span class="hljs-comment">//用以执行异步请求</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> ExecutorService <span class="hljs-title function_">executorService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (executorService == <span class="hljs-literal">null</span>) &#123;<br>      executorService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(), Util.threadFactory(<span class="hljs-string">&quot;OkHttp Dispatcher&quot;</span>, <span class="hljs-literal">false</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> executorService;<br>  &#125;<br>    <br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(AsyncCall call)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>      <span class="hljs-comment">//加入正在执行的异步队列中</span><br>      readyAsyncCalls.add(call);<br><br>      <span class="hljs-comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span><br>      <span class="hljs-comment">// the same host.</span><br>      <span class="hljs-keyword">if</span> (!call.get().forWebSocket) &#123;<br>        <span class="hljs-type">AsyncCall</span> <span class="hljs-variable">existingCall</span> <span class="hljs-operator">=</span> findExistingCallWithHost(call.host());<br>        <span class="hljs-keyword">if</span> (existingCall != <span class="hljs-literal">null</span>) call.reuseCallsPerHostFrom(existingCall);<br>      &#125;<br>    &#125;<br>    promoteAndExecute();<br>  &#125;<br>    <br>  <span class="hljs-comment">//加入正在执行的同步队列</span><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executed</span><span class="hljs-params">(RealCall call)</span> &#123;<br>    runningSyncCalls.add(call);<br>  &#125;<br>  <span class="hljs-comment">//从政在执行的异步队列中移除  </span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">finished</span><span class="hljs-params">(AsyncCall call)</span> &#123;<br>    call.callsPerHost().decrementAndGet();<br>    finished(runningAsyncCalls, call);<br>  &#125;<br>  <span class="hljs-comment">//执行完毕后  从正在执行的同步队列中移除</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">finished</span><span class="hljs-params">(RealCall call)</span> &#123;<br>    finished(runningSyncCalls, call);<br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">finished</span><span class="hljs-params">(Deque&lt;T&gt; calls, T call)</span> &#123;<br>    Runnable idleCallback;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!calls.remove(call)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(<span class="hljs-string">&quot;Call wasn&#x27;t in-flight!&quot;</span>);<br>      idleCallback = <span class="hljs-built_in">this</span>.idleCallback;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isRunning</span> <span class="hljs-operator">=</span> promoteAndExecute();<br>    <span class="hljs-keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="hljs-literal">null</span>) &#123;<br>      idleCallback.run();<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">promoteAndExecute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//判定当前线程是否持有锁</span><br>    <span class="hljs-keyword">assert</span> (!Thread.holdsLock(<span class="hljs-built_in">this</span>));<br><br>    List&lt;AsyncCall&gt; executableCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span> isRunning;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>      <br>      <span class="hljs-keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;<br>        <span class="hljs-type">AsyncCall</span> <span class="hljs-variable">asyncCall</span> <span class="hljs-operator">=</span> i.next();<br>        <span class="hljs-comment">//正在运行的异步请求不能超过 64个</span><br>        <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Max capacity.</span><br>        <span class="hljs-comment">//在同一个Host下的异步请求不能超过5个</span><br>        <span class="hljs-keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Host max capacity.</span><br><br>        i.remove();<br>        <span class="hljs-comment">//CAS</span><br>        asyncCall.callsPerHost().incrementAndGet();<br>        <span class="hljs-comment">//添加至异步执行队列</span><br>        executableCalls.add(asyncCall);<br>        <span class="hljs-comment">//添加至正在执行异步请求队列</span><br>        runningAsyncCalls.add(asyncCall);<br>      &#125;<br>      isRunning = runningCallsCount() &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;<br>      <span class="hljs-type">AsyncCall</span> <span class="hljs-variable">asyncCall</span> <span class="hljs-operator">=</span> executableCalls.get(i);<br>      <span class="hljs-comment">//执行异步请求</span><br>      asyncCall.executeOn(executorService());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> isRunning;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Dispatcher</code>是一个任务调度器，内部维护了三个双端队列：</p>
<ul>
<li><code>readyAsyncCalls</code>：准备执行的异步请求。<em>已经超过请求上限的异步请求就会放在该队列中。</em></li>
<li><code>runningAsyncCalls</code>：正在执行的异步请求。<em>不超过请求上限时，异步请求会加入到该队列中，超过时，依然放到<code>readyAsyncCalls</code>中。</em></li>
<li><code>runningSyncCalls</code>：正在执行的同步请求。<em>直接把同步请求添加到该队列中。</em></li>
</ul>
<p>通过<code>Dispatcher</code>中的<code>executorService</code>去执行对应请求。</p>
<h3 id="处理Request请求——通过拦截器"><a href="#处理Request请求——通过拦截器" class="headerlink" title="处理Request请求——通过拦截器"></a>处理<code>Request</code>请求——通过拦截器</h3><p><img src="/images/OkHttp-%E5%A4%84%E7%90%86Request%E8%AF%B7%E6%B1%82.png" srcset="/img/loading.gif" lazyload alt="OkHttp-处理Request请求"></p>
<blockquote>
<p>通过<code>Dispatcher</code>执行完请求后，返回回调结果前，需要通过<code>getResponseWithInterceptorChain()</code>通过层层责任链的执行来获得最终的请求结果。</p>
<p><strong>通过责任链模式将请求一层层的通过拦截器进行处理。</strong></p>
</blockquote>
<figure class="highlight java"><figcaption><span>RealCall.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">Response <span class="hljs-title function_">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// Build a full stack of interceptors.</span><br>    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//加入用户自定义的拦截器</span><br>    interceptors.addAll(client.interceptors());<br>    <span class="hljs-comment">//重试和重定向拦截器</span><br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RetryAndFollowUpInterceptor</span>(client));<br>    <span class="hljs-comment">//转化用户请求为网络请求</span><br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BridgeInterceptor</span>(client.cookieJar()));<br>    <span class="hljs-comment">//负责读取缓存以及更新缓存</span><br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheInterceptor</span>(client.internalCache()));<br>    <span class="hljs-comment">//与服务器建立连接</span><br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectInterceptor</span>(client));<br>    <span class="hljs-keyword">if</span> (!forWebSocket) &#123;<br>       <span class="hljs-comment">//用户自定义的网络拦截器</span><br>      interceptors.addAll(client.networkInterceptors());<br>    &#125;<br>    <span class="hljs-comment">//从服务器读取响应的数据</span><br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallServerInterceptor</span>(forWebSocket));<br><br>    Interceptor.<span class="hljs-type">Chain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(interceptors, transmitter, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>,<br>        originalRequest, <span class="hljs-built_in">this</span>, client.connectTimeoutMillis(),<br>        client.readTimeoutMillis(), client.writeTimeoutMillis());<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">calledNoMoreExchanges</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//链式调用拦截器，最终返回 Response</span><br>      <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(originalRequest);<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;<br>        closeQuietly(response);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> response;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      calledNoMoreExchanges = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">throw</span> transmitter.noMoreExchanges(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;<br>        transmitter.noMoreExchanges(<span class="hljs-literal">null</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>在获得响应结果之前，需要对用户设置的原始请求转换为实际的网络请求，然后通过一系列拦截器，直到最终得到结果，采用<strong>链式调用</strong>保证这些拦截器的执行顺序。</p>
<h4 id="OkHttp拦截器"><a href="#OkHttp拦截器" class="headerlink" title="OkHttp拦截器"></a>OkHttp拦截器</h4><blockquote>
<p>所有的拦截器都实现了<code>Interceptor</code>接口，支持用户去自定义拦截器，只要实现<code>Interceptor</code>接口即可。</p>
<p>拦截器可以 用来<em>监控、改写和重试HTTP访问</em>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>  <span class="hljs-comment">//主要实现该接口，控制返回结果</span><br>  Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException;<br><br>  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Chain</span> &#123;<br>    <br>    Request <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;<br><br>    Response <span class="hljs-title function_">proceed</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> IOException;<br><br>    <span class="hljs-comment">//返回Request执行后的返回结果</span><br>    <span class="hljs-meta">@Nullable</span> Connection <span class="hljs-title function_">connection</span><span class="hljs-params">()</span>;<br><br>    Call <span class="hljs-title function_">call</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">connectTimeoutMillis</span><span class="hljs-params">()</span>;<br><br>    Chain <span class="hljs-title function_">withConnectTimeout</span><span class="hljs-params">(<span class="hljs-type">int</span> timeout, TimeUnit unit)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">readTimeoutMillis</span><span class="hljs-params">()</span>;<br><br>    Chain <span class="hljs-title function_">withReadTimeout</span><span class="hljs-params">(<span class="hljs-type">int</span> timeout, TimeUnit unit)</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">writeTimeoutMillis</span><span class="hljs-params">()</span>;<br><br>    Chain <span class="hljs-title function_">withWriteTimeout</span><span class="hljs-params">(<span class="hljs-type">int</span> timeout, TimeUnit unit)</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="ApplicationInterceptor"><a href="#ApplicationInterceptor" class="headerlink" title="ApplicationInterceptor"></a><code>ApplicationInterceptor</code></h5><p><img src="/images/OkHttp-ApplicationInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-ApplicationInterceptor"></p>
<blockquote>
<p>该拦截器会被第一个执行，此处得到的<code>Request</code>为最原始状态。但是最终得到的<code>Response</code>是最终的结果。</p>
</blockquote>
<p>引用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>.Builder()<br>    .addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingInterceptor</span>())<br>    .build();<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>ApplicationInterceptor</code>适用于在请求前统一添加一些公共参数，例如<code>App的版本号，系统信息</code>等。</p>
<p>也可用于对返回的<code>Response</code>进行加工。</p>
</blockquote>
<p><code>ApplicationInterceptor</code>有以下特定：</p>
<ul>
<li>不需要关心后续拦截器进行的操作，因为是会被第一个执行的，只要关心返回结果即可。</li>
<li>只会被响应一次，即使强制缓存获取</li>
<li>可以对后续的拦截器调用进行拦截或者进行多次调用——<strong>通过<code>Chain.proceed()</code>进行控制</strong></li>
</ul>
<h5 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a><code>RetryAndFollowUpInterceptor</code></h5><p><img src="/images/OkHttp-RetryAndFollowUpInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-RetryAndFollowUpInterceptor"></p>
<blockquote>
<p>负责失败重试和重定向的拦截器。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RetryAndFollowUpInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//从自定义拦截器 那里传递下来的请求</span><br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> chain.request();<br>    <span class="hljs-type">RealInterceptorChain</span> <span class="hljs-variable">realChain</span> <span class="hljs-operator">=</span> (RealInterceptorChain) chain;<br>    <span class="hljs-comment">//获取事件监听器</span><br>    <span class="hljs-type">Transmitter</span> <span class="hljs-variable">transmitter</span> <span class="hljs-operator">=</span> realChain.transmitter();<br>    <span class="hljs-comment">//初始化 重定向次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">followUpCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">Response</span> <span class="hljs-variable">priorResponse</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//开启死循环 进行重试操作</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      transmitter.prepareToConnect(request);<br>      <span class="hljs-comment">//请求取消</span><br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>      &#125;<br><br>      Response response;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//向下调用 下一个拦截器——BridgeInterceptor</span><br>        response = realChain.proceed(request, transmitter, <span class="hljs-literal">null</span>);<br>        success = <span class="hljs-literal">true</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (RouteException e) &#123;<br>        <span class="hljs-comment">// 不需要重试 则抛出异常</span><br>        <span class="hljs-keyword">if</span> (!recover(e.getLastConnectException(), transmitter, <span class="hljs-literal">false</span>, request)) &#123;<br>          <span class="hljs-keyword">throw</span> e.getFirstConnectException();<br>        &#125;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-comment">// 无法与服务端建立连接</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">requestSendStarted</span> <span class="hljs-operator">=</span> !(e <span class="hljs-keyword">instanceof</span> ConnectionShutdownException);<br>        <span class="hljs-keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="hljs-keyword">throw</span> e;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// The network call threw an exception. Release any resources.</span><br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>          <span class="hljs-comment">//释放资源</span><br>          transmitter.exchangeDoneDueToException();<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// Attach the prior response if it exists. Such responses never have a body.</span><br>      <span class="hljs-keyword">if</span> (priorResponse != <span class="hljs-literal">null</span>) &#123;<br>        response = response.newBuilder()<br>            .priorResponse(priorResponse.newBuilder()<br>                    .body(<span class="hljs-literal">null</span>)<br>                    .build())<br>            .build();<br>      &#125;<br><br>      <span class="hljs-type">Exchange</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> Internal.instance.exchange(response);<br>      <span class="hljs-type">Route</span> <span class="hljs-variable">route</span> <span class="hljs-operator">=</span> exchange != <span class="hljs-literal">null</span> ? exchange.connection().route() : <span class="hljs-literal">null</span>;<br>      <span class="hljs-comment">//根据返回的 response的Code 判断是否需要进行重定向</span><br>      <span class="hljs-type">Request</span> <span class="hljs-variable">followUp</span> <span class="hljs-operator">=</span> followUpRequest(response, route);<br><br>      <span class="hljs-keyword">if</span> (followUp == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//释放资源</span><br>        <span class="hljs-keyword">if</span> (exchange != <span class="hljs-literal">null</span> &amp;&amp; exchange.isDuplex()) &#123;<br>          transmitter.timeoutEarlyExit();<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>      &#125;<br><br>      <span class="hljs-type">RequestBody</span> <span class="hljs-variable">followUpBody</span> <span class="hljs-operator">=</span> followUp.body();<br>      <span class="hljs-keyword">if</span> (followUpBody != <span class="hljs-literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;<br>        <span class="hljs-keyword">return</span> response;<br>      &#125;<br><br>      closeQuietly(response.body());<br>      <span class="hljs-keyword">if</span> (transmitter.hasExchange()) &#123;<br>        exchange.detachWithViolence();<br>      &#125;<br><br>      <span class="hljs-comment">//超出重定向次数</span><br>      <span class="hljs-keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtocolException</span>(<span class="hljs-string">&quot;Too many follow-up requests: &quot;</span> + followUpCount);<br>      &#125;<br>      <span class="hljs-comment">//获取重定向结果 赋予 request继续向下请求</span><br>      request = followUp;<br>      priorResponse = response;<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">recover</span><span class="hljs-params">(IOException e, Transmitter transmitter,</span><br><span class="hljs-params">      <span class="hljs-type">boolean</span> requestSendStarted, Request userRequest)</span> &#123;<br>    <span class="hljs-comment">// 未开启重试 retryOnConnectionFailure(false)</span><br>    <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 只允许发送一次 isOneShot()&#123;return true;&#125;</span><br>    <span class="hljs-keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 发生异常</span><br>    <span class="hljs-keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 设置不允许重试</span><br>    <span class="hljs-keyword">if</span> (!transmitter.canRetry()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>尝试执行下一个拦截器，即<code>BridgeInterceptor</code></li>
<li>抛出异常，需要根据以下情况去判断是否需要重试：<ul>
<li>客户端是否开启  <code>retryOnConnectionFailure</code></li>
<li><code>RequestBody.isOneShot()</code>返回值</li>
<li>判断异常类型，除了<code>ConnectionShutdownException</code>被中断情况外的<code>IOException</code>的子类，都不会进行重试</li>
</ul>
</li>
<li>根据Response返回的响应码<code>code</code>进行处理</li>
</ol>
</blockquote>
<figure class="highlight java"><figcaption><span>RetryAndFollowUpInterceptor.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Request <span class="hljs-title function_">followUpRequest</span><span class="hljs-params">(Response userResponse, <span class="hljs-meta">@Nullable</span> Route route)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (userResponse == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">responseCode</span> <span class="hljs-operator">=</span> userResponse.code();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> userResponse.request().method();<br>    <span class="hljs-keyword">switch</span> (responseCode) &#123;<br>      <span class="hljs-comment">// 407 需要进行代理认证</span><br>      <span class="hljs-keyword">case</span> HTTP_PROXY_AUTH:<br>        <span class="hljs-type">Proxy</span> <span class="hljs-variable">selectedProxy</span> <span class="hljs-operator">=</span> route != <span class="hljs-literal">null</span><br>            ? route.proxy()<br>            : client.proxy();<br>        <span class="hljs-keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtocolException</span>(<span class="hljs-string">&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);<br>      <span class="hljs-comment">// 401 未经认证</span><br>      <span class="hljs-keyword">case</span> HTTP_UNAUTHORIZED:<br>        <span class="hljs-keyword">return</span> client.authenticator().authenticate(route, userResponse);<br>      <span class="hljs-comment">// 301 永久重定向  302 临时重定向  只有GET、HEAD请求方法才有效</span><br>      <span class="hljs-keyword">case</span> HTTP_PERM_REDIRECT:<br>      <span class="hljs-keyword">case</span> HTTP_TEMP_REDIRECT:<br>        <span class="hljs-comment">// &quot;If the 307 or 308 status code is received in response to a request other than GET</span><br>        <span class="hljs-comment">// or HEAD, the user agent MUST NOT automatically redirect the request&quot;</span><br>        <span class="hljs-keyword">if</span> (!method.equals(<span class="hljs-string">&quot;GET&quot;</span>) &amp;&amp; !method.equals(<span class="hljs-string">&quot;HEAD&quot;</span>)) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// fall-through</span><br>      <br>      <span class="hljs-keyword">case</span> HTTP_MULT_CHOICE:<span class="hljs-comment">// 300  多个重定向地址</span><br>      <span class="hljs-keyword">case</span> HTTP_MOVED_PERM:<span class="hljs-comment">// 301 永久移除 指向了新的位置</span><br>      <span class="hljs-keyword">case</span> HTTP_MOVED_TEMP:<span class="hljs-comment">//302  临时移除</span><br>      <span class="hljs-keyword">case</span> HTTP_SEE_OTHER:<span class="hljs-comment">//303 查看其他位置</span><br>        <span class="hljs-comment">// 开发者是否允许重定向</span><br>        <span class="hljs-keyword">if</span> (!client.followRedirects()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//重定向后的实际地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">location</span> <span class="hljs-operator">=</span> userResponse.header(<span class="hljs-string">&quot;Location&quot;</span>);<br>        <span class="hljs-keyword">if</span> (location == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">HttpUrl</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> userResponse.request().url().resolve(location);<br><br>        <span class="hljs-comment">// Don&#x27;t follow redirects to unsupported protocols.</span><br>        <span class="hljs-keyword">if</span> (url == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// If configured, don&#x27;t follow redirects between SSL and non-SSL.</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">sameScheme</span> <span class="hljs-operator">=</span> url.scheme().equals(userResponse.request().url().scheme());<br>        <span class="hljs-keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// Most redirects don&#x27;t include a request body.</span><br>        Request.<span class="hljs-type">Builder</span> <span class="hljs-variable">requestBuilder</span> <span class="hljs-operator">=</span> userResponse.request().newBuilder();<br>        <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;<br>          <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">maintainBody</span> <span class="hljs-operator">=</span> HttpMethod.redirectsWithBody(method);<br>          <span class="hljs-keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;<br>            requestBuilder.method(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-literal">null</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">RequestBody</span> <span class="hljs-variable">requestBody</span> <span class="hljs-operator">=</span> maintainBody ? userResponse.request().body() : <span class="hljs-literal">null</span>;<br>            requestBuilder.method(method, requestBody);<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!maintainBody) &#123;<br>            requestBuilder.removeHeader(<span class="hljs-string">&quot;Transfer-Encoding&quot;</span>);<br>            requestBuilder.removeHeader(<span class="hljs-string">&quot;Content-Length&quot;</span>);<br>            requestBuilder.removeHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>);<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// When redirecting across hosts, drop all authentication headers. This</span><br>        <span class="hljs-comment">// is potentially annoying to the application layer since they have no</span><br>        <span class="hljs-comment">// way to retain them.</span><br>        <span class="hljs-keyword">if</span> (!sameConnection(userResponse.request().url(), url)) &#123;<br>          requestBuilder.removeHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> requestBuilder.url(url).build();<br>      <span class="hljs-comment">//408 超时</span><br>      <span class="hljs-keyword">case</span> HTTP_CLIENT_TIMEOUT:<br>        <span class="hljs-comment">// 408&#x27;s are rare in practice, but some servers like HAProxy use this response code. The</span><br>        <span class="hljs-comment">// spec says that we may repeat the request without modifications. Modern browsers also</span><br>        <span class="hljs-comment">// repeat the request (even non-idempotent ones.)</span><br>        <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure()) &#123;<br>          <span class="hljs-comment">// The application layer has directed us not to retry the request.</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">RequestBody</span> <span class="hljs-variable">requestBody</span> <span class="hljs-operator">=</span> userResponse.request().body();<br>        <span class="hljs-keyword">if</span> (requestBody != <span class="hljs-literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (userResponse.priorResponse() != <span class="hljs-literal">null</span><br>            &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;<br>          <span class="hljs-comment">// We attempted to retry and got another timeout. Give up.</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (retryAfter(userResponse, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> userResponse.request();<br>      <span class="hljs-comment">//503 服务端不可用</span><br>      <span class="hljs-keyword">case</span> HTTP_UNAVAILABLE:<br>        <span class="hljs-keyword">if</span> (userResponse.priorResponse() != <span class="hljs-literal">null</span><br>            &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;<br>          <span class="hljs-comment">// We attempted to retry and got another timeout. Give up.</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// specifically received an instruction to retry without delay</span><br>          <span class="hljs-keyword">return</span> userResponse.request();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>followUpRequest()</code>对<code>Response</code>返回的<code>code</code>进行对应操作，在触发到重定向相关的code<code>3XX</code>时，需要对应的转换<code>Request</code>使用获取到的重定向后地址进行请求。</p>
<blockquote>
<p>由源码可知，可以重试的最大次数为<strong>20</strong>次，可以通过<code>retryOnConnectionFailure(true)</code>设置支持重试。但是不支持自定义重试次数，若需要自定义重试次数，需要自定义拦截器去实现。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RetryInterceptor</span>(<span class="hljs-keyword">var</span> maxRetry: <span class="hljs-built_in">Int</span><span class="hljs-comment">/*最大重试次数*/</span>) : Interceptor &#123;<br>        <span class="hljs-comment">//当前重试次数</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> retryNum = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercept</span><span class="hljs-params">(chain: <span class="hljs-type">Interceptor</span>.<span class="hljs-type">Chain</span>)</span></span>: Response &#123;<br>            <span class="hljs-keyword">val</span> request = chain.request()<br>            <span class="hljs-keyword">var</span> response = chain.proceed(request)<br><br>            <span class="hljs-keyword">while</span> (!response.isSuccessful &amp;&amp; retryNum &lt; maxRetry) &#123;<br>                retryNum++<br>                response = chain.proceed(request)<br>            &#125;<br>            <span class="hljs-keyword">return</span> response<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h5 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a><code>BridgeInterceptor</code></h5><p><img src="/images/OkHttp-BridgeInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-BridgeInterceptor"></p>
<blockquote>
<p>用以将用户的请求转换为向服务器的请求，之后再把服务器返回的数据转换成用户直观的数据。<strong>主要是对Header进行处理</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BridgeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">userRequest</span> <span class="hljs-operator">=</span> chain.request();<br>    Request.<span class="hljs-type">Builder</span> <span class="hljs-variable">requestBuilder</span> <span class="hljs-operator">=</span> userRequest.newBuilder();<br>    <span class="hljs-comment">//重构用户请求 为 服务器请求格式</span><br>    <span class="hljs-type">RequestBody</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> userRequest.body();<br>    <span class="hljs-comment">//如果存在Body</span><br>    <span class="hljs-keyword">if</span> (body != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//对Header进行调整</span><br>      <span class="hljs-type">MediaType</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span> body.contentType();<br>      <span class="hljs-keyword">if</span> (contentType != <span class="hljs-literal">null</span>) &#123;<br>        requestBuilder.header(<span class="hljs-string">&quot;Content-Type&quot;</span>, contentType.toString());<br>      &#125;<br><br>      <span class="hljs-type">long</span> <span class="hljs-variable">contentLength</span> <span class="hljs-operator">=</span> body.contentLength();<br>      <span class="hljs-keyword">if</span> (contentLength != -<span class="hljs-number">1</span>) &#123;<br>        requestBuilder.header(<span class="hljs-string">&quot;Content-Length&quot;</span>, Long.toString(contentLength));<br>        requestBuilder.removeHeader(<span class="hljs-string">&quot;Transfer-Encoding&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        requestBuilder.header(<span class="hljs-string">&quot;Transfer-Encoding&quot;</span>, <span class="hljs-string">&quot;chunked&quot;</span>);<br>        requestBuilder.removeHeader(<span class="hljs-string">&quot;Content-Length&quot;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//设置Header中的 host</span><br>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">&quot;Host&quot;</span>) == <span class="hljs-literal">null</span>) &#123;<br>      requestBuilder.header(<span class="hljs-string">&quot;Host&quot;</span>, hostHeader(userRequest.url(), <span class="hljs-literal">false</span>));<br>    &#125;<br><br>    <span class="hljs-comment">//设置 connection : Keep-Alive 保持长连接模式</span><br>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">&quot;Connection&quot;</span>) == <span class="hljs-literal">null</span>) &#123;<br>      requestBuilder.header(<span class="hljs-string">&quot;Connection&quot;</span>, <span class="hljs-string">&quot;Keep-Alive&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// If we add an &quot;Accept-Encoding: gzip&quot; header field we&#x27;re responsible for also decompressing</span><br>    <span class="hljs-comment">// the transfer stream.</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">transparentGzip</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//默认使用Gzip压缩</span><br>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">&quot;Accept-Encoding&quot;</span>) == <span class="hljs-literal">null</span> &amp;&amp; userRequest.header(<span class="hljs-string">&quot;Range&quot;</span>) == <span class="hljs-literal">null</span>) &#123;<br>      transparentGzip = <span class="hljs-literal">true</span>;<br>      requestBuilder.header(<span class="hljs-string">&quot;Accept-Encoding&quot;</span>, <span class="hljs-string">&quot;gzip&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//设置 Cookie信息</span><br>    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());<br>    <span class="hljs-keyword">if</span> (!cookies.isEmpty()) &#123;<br>      requestBuilder.header(<span class="hljs-string">&quot;Cookie&quot;</span>, cookieHeader(cookies));<br>    &#125;<br>    <span class="hljs-comment">//设置UA</span><br>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">&quot;User-Agent&quot;</span>) == <span class="hljs-literal">null</span>) &#123;<br>      requestBuilder.header(<span class="hljs-string">&quot;User-Agent&quot;</span>, Version.userAgent());<br>    &#125;<br>    <span class="hljs-comment">//传递至下一个拦截器处理</span><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">networkResponse</span> <span class="hljs-operator">=</span> chain.proceed(requestBuilder.build());<br><br>    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());<br><br>    Response.<span class="hljs-type">Builder</span> <span class="hljs-variable">responseBuilder</span> <span class="hljs-operator">=</span> networkResponse.newBuilder()<br>        .request(userRequest);<br>    <span class="hljs-comment">//如果服务器支持Gzip压缩，需要进行解压操作</span><br>    <span class="hljs-keyword">if</span> (transparentGzip<br>        &amp;&amp; <span class="hljs-string">&quot;gzip&quot;</span>.equalsIgnoreCase(networkResponse.header(<span class="hljs-string">&quot;Content-Encoding&quot;</span>))<br>        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;<br>      <span class="hljs-type">GzipSource</span> <span class="hljs-variable">responseBody</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GzipSource</span>(networkResponse.body().source());<br>      <span class="hljs-type">Headers</span> <span class="hljs-variable">strippedHeaders</span> <span class="hljs-operator">=</span> networkResponse.headers().newBuilder()<br>          .removeAll(<span class="hljs-string">&quot;Content-Encoding&quot;</span>)<br>          .removeAll(<span class="hljs-string">&quot;Content-Length&quot;</span>)<br>          .build();<br>      responseBuilder.headers(strippedHeaders);<br>      <span class="hljs-type">String</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span> networkResponse.header(<span class="hljs-string">&quot;Content-Type&quot;</span>);<br>      responseBuilder.body(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RealResponseBody</span>(contentType, -<span class="hljs-number">1L</span>, Okio.buffer(responseBody)));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> responseBuilder.build();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>GZip</code>：是一种压缩技术，可以改进Web应用的性能，将请求体明显的减少其大小，如果服务器也支持该格式，就会返回对应格式的内容，客户端需要进行解压操作，可以明显的减少流量消耗。</p>
</blockquote>
<p><code>BridgeInterceptor</code>主要执行了以下3步：</p>
<ul>
<li><p>用户请求转换为网络请求</p>
<p>在原来<code>Request</code>上添加了很多<code>Header</code>，例如<code>Content-Type(定义网络文件的类型和网页的编码)、Content-Length(请求体内容长度)、Transfer-Encoding(请求体的大小)与Content-Length互斥、Accept-Encoding(编码格式)</code>。</p>
<p>未设置<code>Accept-Encoding</code>默认为<code>gzip</code>。</p>
</li>
<li><p>执行转换后的网络请求</p>
<p><code>chain.proceed(requestBuilder.build())</code></p>
</li>
<li><p>服务器返回的响应结果转换为用户响应结果</p>
<p>根据上一步获得<code>Response</code>后，需要再次转化为用户直观格式。主要在于服务端返回的信息里是否设置了<code>Accept-Encoding:gzip</code>，设置了则需要进行解压过程，获取最终结果。</p>
</li>
</ul>
<h5 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a><code>CacheInterceptor</code></h5><p><img src="/images/OkHttp-CacheInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-CacheInterceptor"></p>
<blockquote>
<p>主要用于<strong>读取缓存以及更新缓存的</strong>，<strong>为了节省流量和提高响应速度</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//根据请求的相关信息获取缓存</span><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">cacheCandidate</span> <span class="hljs-operator">=</span> cache != <span class="hljs-literal">null</span><br>        ? cache.get(chain.request())<br>        : <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-comment">//创建缓存策略</span><br>    <span class="hljs-type">CacheStrategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheStrategy</span>.Factory(now, chain.request(), cacheCandidate).get();①<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">networkRequest</span> <span class="hljs-operator">=</span> strategy.networkRequest;<br>    <span class="hljs-type">Response</span> <span class="hljs-variable">cacheResponse</span> <span class="hljs-operator">=</span> strategy.cacheResponse;<br><br>    <span class="hljs-keyword">if</span> (cache != <span class="hljs-literal">null</span>) &#123;<br>      cache.trackResponse(strategy);<br>    &#125;<br>    <span class="hljs-comment">//缓存无法使用，关闭获得的Response</span><br>    <span class="hljs-keyword">if</span> (cacheCandidate != <span class="hljs-literal">null</span> &amp;&amp; cacheResponse == <span class="hljs-literal">null</span>) &#123;<br>      closeQuietly(cacheCandidate.body()); <span class="hljs-comment">// The cache candidate wasn&#x27;t applicable. Close it.</span><br>    &#125;<br><br>    <span class="hljs-comment">// 根据策略，不使用网络且没有缓存的直接报错，返回504</span><br>    <span class="hljs-keyword">if</span> (networkRequest == <span class="hljs-literal">null</span> &amp;&amp; cacheResponse == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>.Builder()<br>          .request(chain.request())<br>          .protocol(Protocol.HTTP_1_1)<br>          .code(<span class="hljs-number">504</span>)<br>          .message(<span class="hljs-string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)<br>          .body(Util.EMPTY_RESPONSE)<br>          .sentRequestAtMillis(-<span class="hljs-number">1L</span>)<br>          .receivedResponseAtMillis(System.currentTimeMillis())<br>          .build();<br>    &#125;<br><br>    <span class="hljs-comment">// 直接返回缓存，不允许使用网络</span><br>    <span class="hljs-keyword">if</span> (networkRequest == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> cacheResponse.newBuilder()<br>          .cacheResponse(stripBody(cacheResponse))<br>          .build();<br>    &#125;<br><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">networkResponse</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//请求向下传递</span><br>      networkResponse = chain.proceed(networkRequest);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span><br>      <span class="hljs-keyword">if</span> (networkResponse == <span class="hljs-literal">null</span> &amp;&amp; cacheCandidate != <span class="hljs-literal">null</span>) &#123;<br>        closeQuietly(cacheCandidate.body());<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 接受到服务器返回数据，如果返回code为 304 直接使用缓存结果</span><br>    <span class="hljs-keyword">if</span> (cacheResponse != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;<br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> cacheResponse.newBuilder()<br>            .headers(combine(cacheResponse.headers(), networkResponse.headers()))<br>            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())<br>            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())<br>            .cacheResponse(stripBody(cacheResponse))<br>            .networkResponse(stripBody(networkResponse))<br>            .build();<br>        networkResponse.body().close();<br><br>        <span class="hljs-comment">// Update the cache after combining headers but before stripping the</span><br>        <span class="hljs-comment">// Content-Encoding header (as performed by initContentStream()).</span><br>        cache.trackConditionalCacheHit();<br>        <span class="hljs-comment">//更新当前存储的缓存信息</span><br>        cache.update(cacheResponse, response);<br>        <span class="hljs-keyword">return</span> response;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        closeQuietly(cacheResponse.body());<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//读取服务器返回结果</span><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> networkResponse.newBuilder()<br>        .cacheResponse(stripBody(cacheResponse))<br>        .networkResponse(stripBody(networkResponse))<br>        .build();<br>    <span class="hljs-comment">//对数据进行缓存</span><br>    <span class="hljs-keyword">if</span> (cache != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;<br>        <span class="hljs-comment">// Offer this request to the cache.</span><br>        <span class="hljs-type">CacheRequest</span> <span class="hljs-variable">cacheRequest</span> <span class="hljs-operator">=</span> cache.put(response);<br>        <span class="hljs-keyword">return</span> cacheWritingResponse(cacheRequest, response);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          cache.remove(networkRequest);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>          <span class="hljs-comment">// The cache cannot be written.</span><br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>CacheInterceptor</code>的执行流程如下所示：</p>
<ol>
<li>先行读取缓存数据</li>
<li>创建好对应的缓存策略：<code>强制缓存</code>、<code>对比缓存</code></li>
<li>根据缓存策略，不使用网络、也没有对应缓存，返回<code>504</code></li>
<li>根据缓存策略，不使用网络，存在缓存则直接返回</li>
<li>前面都没有返回结果，继续向下执行请求：<code>chain.proceed()</code></li>
<li>接受到对应网络结果，如果返回code为<code>304</code>，代表直接使用缓存并更新对应缓存信息</li>
<li>读取网络结果，对数据进行缓存</li>
<li>返回获取的网络结果</li>
</ol>
<p>具体的缓存策略请参考<a href="#OkHttp%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">缓存策略</a></p>
<h5 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a><code>ConnectInterceptor</code></h5><p><img src="/images/OkHttp-ConnectInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-ConnectInterceptor"></p>
<blockquote>
<p>真正与服务端建立连接，底层是通过<code>Socket</code>进行连接。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> OkHttpClient client;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">RealInterceptorChain</span> <span class="hljs-variable">realChain</span> <span class="hljs-operator">=</span> (RealInterceptorChain) chain;<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> realChain.request();<br>    <span class="hljs-type">Transmitter</span> <span class="hljs-variable">transmitter</span> <span class="hljs-operator">=</span> realChain.transmitter();<br><br>    <span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">doExtensiveHealthChecks</span> <span class="hljs-operator">=</span> !request.method().equals(<span class="hljs-string">&quot;GET&quot;</span>);<br>    <span class="hljs-comment">//建立连接</span><br>    <span class="hljs-type">Exchange</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> transmitter.newExchange(chain, doExtensiveHealthChecks);<br>    <span class="hljs-comment">//继续请求下一个拦截器</span><br>    <span class="hljs-keyword">return</span> realChain.proceed(request, transmitter, exchange);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ConnectInterceptor</code>主要功能是建立与服务器的连接关系，通过<code>Transmitter.newExchange()</code>建立连接，建立完成后继续向下执行请求。</p>
<p>具体的连接过程可以参考[连接机制](# OkHttp连接机制)</p>
<h5 id="NetworkInterceptor"><a href="#NetworkInterceptor" class="headerlink" title="NetworkInterceptor"></a><code>NetworkInterceptor</code></h5><p><img src="/images/OkHttp-NetworkInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-NetworkInterceptor"></p>
<blockquote>
<p>用户自定义的网络拦截器，处于第6个拦截器，前面经过了<code>RetryAndFolowUpInterceptor</code>的重定向过程以及<code>BridgeInterceptor</code>的请求头处理，在此处可以获取到更多的连接信息。</p>
</blockquote>
<p>引用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>.Builder()<br>    .addNetworkInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingInterceptor</span>())<br>    .build();<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>NetworkInterceptor</code>可以获取到最终请求的<code>Request</code>，以及获取到真正进行过网络请求的得到的<code>Response</code>，从而可以针对<code>Response</code>进行修改然后再回传到上层拦截器。</p>
</blockquote>
<p><code>NetworkInterceptor</code>主要有以下特点：</p>
<ul>
<li>可以操作经过<code>重定向、重试</code>得到的<code>Response</code></li>
<li>无法响应缓存数据的请求，因为<code>CacheInterceptor</code>执行在它之前</li>
<li>得到最终进行请求的<code>Request</code></li>
<li>可以获得连接信息</li>
</ul>
<h5 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a><code>CallServerInterceptor</code></h5><p><img src="/images/OkHttp-CallServerInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-CallServerInterceptor"></p>
<blockquote>
<p>数据的写入过程，也就是客户端和服务端进行交互的过程，客户端发送数据，服务端返回数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallServerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">RealInterceptorChain</span> <span class="hljs-variable">realChain</span> <span class="hljs-operator">=</span> (RealInterceptorChain) chain;<br>    <span class="hljs-type">Exchange</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> realChain.exchange();<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> realChain.request();<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">sentRequestMillis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-comment">//写入请求头</span><br>    exchange.writeRequestHeaders(request);<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">responseHeadersStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    Response.<span class="hljs-type">Builder</span> <span class="hljs-variable">responseBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//判断当前是否有 请求体body</span><br>    <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span><br>      <span class="hljs-comment">// Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return</span><br>      <span class="hljs-comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span><br>      <span class="hljs-comment">//如果是1XX的话 表示当前需要等服务端响应 </span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;100-continue&quot;</span>.equalsIgnoreCase(request.header(<span class="hljs-string">&quot;Expect&quot;</span>))) &#123;<br>        exchange.flushRequest();<br>        responseHeadersStarted = <span class="hljs-literal">true</span>;<br>        exchange.responseHeadersStart();<br>        responseBuilder = exchange.readResponseHeaders(<span class="hljs-literal">true</span>);<br>      &#125;<br><br>      <br>      <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//写入请求体</span><br>        <span class="hljs-keyword">if</span> (request.body().isDuplex()) &#123;<br>          <span class="hljs-comment">// Prepare a duplex body so that the application can send a request body later.</span><br>          exchange.flushRequest();<br>          <span class="hljs-type">BufferedSink</span> <span class="hljs-variable">bufferedRequestBody</span> <span class="hljs-operator">=</span> Okio.buffer(<br>              exchange.createRequestBody(request, <span class="hljs-literal">true</span>));<br>          request.body().writeTo(bufferedRequestBody);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br>          <span class="hljs-type">BufferedSink</span> <span class="hljs-variable">bufferedRequestBody</span> <span class="hljs-operator">=</span> Okio.buffer(<br>              exchange.createRequestBody(request, <span class="hljs-literal">false</span>));<br>          request.body().writeTo(bufferedRequestBody);<br>          bufferedRequestBody.close();<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        exchange.noRequestBody();<br>        <span class="hljs-keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;<br>          <span class="hljs-comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1 connection</span><br>          <span class="hljs-comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request body to</span><br>          <span class="hljs-comment">// leave the connection in a consistent state.</span><br>          exchange.noNewExchangesOnConnection();<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      exchange.noRequestBody();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (request.body() == <span class="hljs-literal">null</span> || !request.body().isDuplex()) &#123;<br>        <span class="hljs-comment">//结束请求</span><br>      exchange.finishRequest();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!responseHeadersStarted) &#123;<br>      exchange.responseHeadersStart();<br>    &#125;<br>    <span class="hljs-comment">//得到响应头</span><br>    <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-literal">null</span>) &#123;<br>      responseBuilder = exchange.readResponseHeaders(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> responseBuilder<br>        .request(request)<br>        .handshake(exchange.connection().handshake())<br>        .sentRequestAtMillis(sentRequestMillis)<br>        .receivedResponseAtMillis(System.currentTimeMillis())<br>        .build();<br>    <span class="hljs-comment">//读取响应体内容</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> response.code();<br>    <span class="hljs-keyword">if</span> (code == <span class="hljs-number">100</span>) &#123;<br>      <span class="hljs-comment">// server sent a 100-continue even though we did not request one.</span><br>      <span class="hljs-comment">// try again to read the actual response</span><br>      response = exchange.readResponseHeaders(<span class="hljs-literal">false</span>)<br>          .request(request)<br>          .handshake(exchange.connection().handshake())<br>          .sentRequestAtMillis(sentRequestMillis)<br>          .receivedResponseAtMillis(System.currentTimeMillis())<br>          .build();<br><br>      code = response.code();<br>    &#125;<br><br>    exchange.responseHeadersEnd(response);<br>    <span class="hljs-comment">//forWebSocket 表示为socket连接方式</span><br>    <span class="hljs-keyword">if</span> (forWebSocket &amp;&amp; code == <span class="hljs-number">101</span>) &#123;<br>      <span class="hljs-comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br>      response = response.newBuilder()<br>          .body(Util.EMPTY_RESPONSE)<br>          .build();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      response = response.newBuilder()<br>          .body(exchange.openResponseBody(response))<br>          .build();<br>    &#125;<br>    <span class="hljs-comment">// close表示关闭连接</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;close&quot;</span>.equalsIgnoreCase(response.request().header(<span class="hljs-string">&quot;Connection&quot;</span>))<br>        || <span class="hljs-string">&quot;close&quot;</span>.equalsIgnoreCase(response.header(<span class="hljs-string">&quot;Connection&quot;</span>))) &#123;<br>      exchange.noNewExchangesOnConnection();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((code == <span class="hljs-number">204</span> || code == <span class="hljs-number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtocolException</span>(<br>          <span class="hljs-string">&quot;HTTP &quot;</span> + code + <span class="hljs-string">&quot; had non-zero Content-Length: &quot;</span> + response.body().contentLength());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>CallServerInterceptor</code>主要执行了以下过程：</p>
<ul>
<li>写入请求头</li>
<li>写入请求体(如果存在)</li>
<li>获取状态行及响应头</li>
<li>获取响应体</li>
</ul>
<p><code>CallServerInterceptor</code>已经是最后一个拦截器了，接下来就是向上回溯并返回自己获得的<code>Response</code>。</p>
<blockquote>
<p>HTTP报文结构：</p>
<p><strong>请求报文</strong>：</p>
<p>请求行：声明请求方法、主机域名及协议版本</p>
<p>请求头：声明客户端的部分报文信息</p>
<p>请求体：存放客户端发送给服务器的数据</p>
<p><strong>响应报文</strong></p>
<p>状态行：声明HTTP协议版本、状态码及描述</p>
<p>响应头：声明服务端的部分报文信息</p>
<p>响应体：服务端返回客户端的数据</p>
</blockquote>
<h4 id="责任链模式串联"><a href="#责任链模式串联" class="headerlink" title="责任链模式串联"></a>责任链模式串联</h4><p>介绍完上述的拦截器后，接下来就是分析如何将这些拦截器进行串联调用。</p>
<figure class="highlight java"><figcaption><span>RealCall.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">Response <span class="hljs-title function_">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// Build a full stack of interceptors.</span><br>    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    ...<br>    <span class="hljs-comment">//构建责任链</span><br>    Interceptor.<span class="hljs-type">Chain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(interceptors, transmitter, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>,<br>        originalRequest, <span class="hljs-built_in">this</span>, client.connectTimeoutMillis(),<br>        client.readTimeoutMillis(), client.writeTimeoutMillis());<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">calledNoMoreExchanges</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//开始从头链式调用拦截器</span><br>      <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(originalRequest);<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;<br>        closeQuietly(response);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> response;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      calledNoMoreExchanges = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">throw</span> transmitter.noMoreExchanges(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;<br>        transmitter.noMoreExchanges(<span class="hljs-literal">null</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>实际执行链式调用的是<code>RealInterceptorChain</code>，由他负责责任链的执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealInterceptorChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span>.Chain &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">proceed</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> proceed(request, transmitter, exchange);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">proceed</span><span class="hljs-params">(Request request, Transmitter transmitter, <span class="hljs-meta">@Nullable</span> Exchange exchange)</span><br>      <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= interceptors.size()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br><br>    calls++;<br><br>    <span class="hljs-comment">// 存在已经在使用的流，直接进行复用</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.exchange != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-built_in">this</span>.exchange.connection().supportsUrl(request.url())) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;network interceptor &quot;</span> + interceptors.get(index - <span class="hljs-number">1</span>)<br>          + <span class="hljs-string">&quot; must retain the same host and port&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.exchange != <span class="hljs-literal">null</span> &amp;&amp; calls &gt; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;network interceptor &quot;</span> + interceptors.get(index - <span class="hljs-number">1</span>)<br>          + <span class="hljs-string">&quot; must call proceed() exactly once&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 调用该链中的下一个拦截器 实质为 用户自定义的拦截器，不存在则为 RetryAndFollowUpInterceptor</span><br>    <span class="hljs-type">RealInterceptorChain</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(interceptors, transmitter, exchange,<br>        index + <span class="hljs-number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);<br>    <span class="hljs-type">Interceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> interceptors.get(index);<br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> interceptor.intercept(next);<br><br>    <span class="hljs-comment">// Confirm that the next interceptor made its required call to chain.proceed().</span><br>    <span class="hljs-keyword">if</span> (exchange != <span class="hljs-literal">null</span> &amp;&amp; index + <span class="hljs-number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;network interceptor &quot;</span> + interceptor<br>          + <span class="hljs-string">&quot; must call proceed() exactly once&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Confirm that the intercepted response isn&#x27;t null.</span><br>    <span class="hljs-keyword">if</span> (response == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;interceptor &quot;</span> + interceptor + <span class="hljs-string">&quot; returned null&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (response.body() == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>          <span class="hljs-string">&quot;interceptor &quot;</span> + interceptor + <span class="hljs-string">&quot; returned a response with no body&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>RealIntercrptor</code>为链式调用的起点，调用<code>proceed()</code>之后，继续调用下一层的拦截器，直到得到最终的Response。</p>
<p>后续的拦截器也是按照这个规则向下执行，内部都会调用到<code>chain.proceed()</code>直到没有调用为止。</p>
<p><strong>Request是按照定义的<code>interceptor</code>顺序向下执行，然后Response是逆向向上处理的。</strong></p>
<h3 id="获取请求结果Response"><a href="#获取请求结果Response" class="headerlink" title="获取请求结果Response"></a>获取请求结果<code>Response</code></h3><blockquote>
<p><code>Response</code>：返回HTTP请求响应结果，包含了状态码，响应正文等</p>
</blockquote>
<p>在<code>CallServerInterceptor</code>得到最初格式的<code>Response</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得状态行及响应头  </span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> Response.Builder <span class="hljs-title function_">readResponseHeaders</span><span class="hljs-params">(<span class="hljs-type">boolean</span> expectContinue)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      Response.<span class="hljs-type">Builder</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> codec.readResponseHeaders(expectContinue);<br>      <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>        Internal.instance.initExchange(result, <span class="hljs-built_in">this</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      eventListener.responseFailed(call, e);<br>      trackFailure(e);<br>      <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">//获得响应正文</span><br><span class="hljs-keyword">public</span> ResponseBody <span class="hljs-title function_">openResponseBody</span><span class="hljs-params">(Response response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      eventListener.responseBodyStart(call);<br>      <span class="hljs-type">String</span> <span class="hljs-variable">contentType</span> <span class="hljs-operator">=</span> response.header(<span class="hljs-string">&quot;Content-Type&quot;</span>);<br>      <span class="hljs-type">long</span> <span class="hljs-variable">contentLength</span> <span class="hljs-operator">=</span> codec.reportedContentLength(response);<br>      <span class="hljs-type">Source</span> <span class="hljs-variable">rawSource</span> <span class="hljs-operator">=</span> codec.openResponseBodySource(response);<br>      <span class="hljs-type">ResponseBodySource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseBodySource</span>(rawSource, contentLength);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealResponseBody</span>(contentType, contentLength, Okio.buffer(source));<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      eventListener.responseFailed(call, e);<br>      trackFailure(e);<br>      <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/OkHttp%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="OkHttp执行流程"></p>
<h2 id="OkHttp缓存机制"><a href="#OkHttp缓存机制" class="headerlink" title="OkHttp缓存机制"></a>OkHttp缓存机制</h2><h3 id="Http缓存"><a href="#Http缓存" class="headerlink" title="Http缓存"></a>Http缓存</h3><p><img src="/images/OkHttp-HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.png" srcset="/img/loading.gif" lazyload alt="OkHttp-HTTP缓存机制"></p>
<blockquote>
<p>Http缓存是web性能优化的重要手段，缓存机制是依赖于<code>header</code>中的参数实现的，这些参数指定了缓存需要<em>从缓存中获取</em>还是<em>从服务端获取</em>。</p>
</blockquote>
<p>Http缓存有多种规则，根据是否需要重新向服务器发起请求来进行分类：</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><blockquote>
<p>当客户端第一次请求数据时，服务端在响应头会携带<strong>缓存规则信息</strong>，主要为两个字段：<strong>Expires</strong>、<strong>Cache-Control</strong></p>
<p>当再次请求数据时，如果符合缓存规则，则直接使用缓存数据，无需与服务端重新交互。</p>
</blockquote>
<p><img src="/images/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="强制缓存流程"></p>
<p>强制缓存在缓存未失效的情况下，可以直接使用缓存数据，接下来介绍<code>判断缓存数据是否失效</code>。<br>上文提到，强制缓存是根据两个Header字段进行判定的，这两个字段表示了<code>失效规则</code>。</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><del>Expires</del></h5><blockquote>
<p>服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。<br><em>这参数是HTTP1.0的东西了，现在主流的是HTTP1.1。</em><br>可能由于客户端时间没有与服务端时间同步而导致缓存命中的误差。</p>
</blockquote>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><blockquote>
<p>在HTTP1.1中替代<code>Expires</code>，功能与其一致。<br><code>Cache-Control</code>常见的取值有如下几种：</p>
</blockquote>
<ul>
<li><code>private</code>：客户端可以进行缓存</li>
<li><code>public</code>：客户端以及代理服务器都可以进行缓存</li>
<li><code>max-age= XX</code>：缓存数据在 XX秒后失效</li>
<li><code>no-cache</code>：需要使用到<code>对比缓存</code></li>
<li><code>no-store</code>：所有内容都不进行缓存</li>
<li><code>s-maxage = XX</code>：限定缓存可以在代理服务器中存放多久</li>
</ul>
<h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><blockquote>
<p>需要进行比较判断来确定是否使用缓存，当客户端第一次请求数据时，服务端会返回<strong>缓存标识</strong>以及数据给客户端，客户端对两者都要进行备份到缓存，当再次请求数据时，客户端会带上<strong>缓存标识</strong>发送给服务端，服务端对标识进行判断，返回code值。返回若为<strong>304</strong>，则继续使用缓存。</p>
</blockquote>
<p><img src="/images/%E5%AF%B9%E6%AF%94%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="对比缓存流程"></p>
<p>在<strong>缓存标识</strong>未失效时，可以继续使用缓存数据，每次都需要与服务端进行交互去验证<strong>缓存标识</strong>。<br>对比缓存也是依据两个Header字段进行判定的，这两个字段表示了<code>缓存标识</code>。</p>
<h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified&#x2F;If-Modified-Since"></a>Last-Modified&#x2F;If-Modified-Since</h5><p><code>Last-Modified</code>：服务端返回给客户端，表示资源的最后修改时间。<br><code>If-Modified-Since</code>：客户端发给服务端，表示服务端上次返回的资源最后修改时间。<br>服务端接收到<code>If-Modified-Since</code>后，与被请求资源的最后修改时间进行比对。</p>
<ul>
<li>若大于，返回最新资源并返回code为200，客户端需要重新进行缓存</li>
<li>否则，说明资源无修改并返回code为304，客户端继续使用缓存数据</li>
</ul>
<h5 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag&#x2F;If-None-Match"></a>ETag&#x2F;If-None-Match</h5><p><code>ETag</code>：服务端返回给客户端，表示当前资源在服务器的唯一标识。<br><code>If-None-Match</code>：客户端发送给服务端，表示服务端上次返回的资源唯一标识。<br>服务端接收到<code>If-None-Match</code>后，与被请求资源的唯一标识进行比对</p>
<ul>
<li>标识不同，表示资源被改动过，返回最新资源及设置code为200，客户端需要重新进行缓存</li>
<li>标识相同，表示资源未被改动，返回code为304，客户端继续使用缓存数据</li>
</ul>
<p>其中<code>ETag/If-None-Match</code>的优先级是高于<code>Last-Modified/If-Modified-Since</code>的</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<ul>
<li>强制缓存的优先级是高于对比缓存的</li>
<li>对于<code>强制缓存</code>，服务端会给予一个过期时间，在有效期内再次请求都只会使用缓存，不会请求服务端。</li>
<li>超过有效期就使用<code>对比缓存</code>策略，将服务端返回的<code>ETag/Last-Modified</code>发还给服务端进行验证，有效则继续使用缓存数据(<em>返回code为304</em>)，无效则重新获取并进行缓存(<em>返回code为200</em>)。</li>
</ul>
</blockquote>
<h3 id="缓存存储"><a href="#缓存存储" class="headerlink" title="缓存存储"></a>缓存存储</h3><p><img src="/images/OkHttp%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0.png" srcset="/img/loading.gif" lazyload alt="OkHttp缓存实现"></p>
<p>介绍完毕Http的缓存机制后，接下来就是看<code>OkHttp</code>中的源码实现</p>
<figure class="highlight java"><figcaption><span>CacheStrategy.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CacheStrategy(Request networkRequest, Response cacheResponse) &#123;<br>  <span class="hljs-built_in">this</span>.networkRequest = networkRequest;<br>  <span class="hljs-built_in">this</span>.cacheResponse = cacheResponse;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>缓存策略主要通过<code>CacheStrategy</code>类实现，关键参数为<code>networkRequest(网络请求)</code>、<code>cacheResponse(缓存的响应结果)</code>。<br><code>CacheStrategy</code>通过工厂模式进行构建的，最终通过调用<code>getCandidate()</code>来生成不同模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> CacheStrategy <span class="hljs-title function_">getCandidate</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 没缓存直接进行重新请求</span><br>      <span class="hljs-keyword">if</span> (cacheResponse == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheStrategy</span>(request, <span class="hljs-literal">null</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 如果是HTTPs且握手信息丢失进行重新请求</span><br>      <span class="hljs-keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheStrategy</span>(request, <span class="hljs-literal">null</span>);<br>      &#125;<br>      <span class="hljs-comment">//判断缓存已经失效 重新进行请求</span><br>      <span class="hljs-keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheStrategy</span>(request, <span class="hljs-literal">null</span>);<br>      &#125;<br>      <span class="hljs-comment">// </span><br>      <span class="hljs-type">CacheControl</span> <span class="hljs-variable">requestCaching</span> <span class="hljs-operator">=</span> request.cacheControl();<br>      <span class="hljs-keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheStrategy</span>(request, <span class="hljs-literal">null</span>);<br>      &#125;<br><br>      <span class="hljs-type">CacheControl</span> <span class="hljs-variable">responseCaching</span> <span class="hljs-operator">=</span> cacheResponse.cacheControl();<br>      <span class="hljs-comment">//</span><br>      <span class="hljs-type">long</span> <span class="hljs-variable">ageMillis</span> <span class="hljs-operator">=</span> cacheResponseAge();<br>      <span class="hljs-type">long</span> <span class="hljs-variable">freshMillis</span> <span class="hljs-operator">=</span> computeFreshnessLifetime();<br><br>      <span class="hljs-keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="hljs-number">1</span>) &#123;<br>        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));<br>      &#125;<br><br>      <span class="hljs-type">long</span> <span class="hljs-variable">minFreshMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="hljs-number">1</span>) &#123;<br>        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());<br>      &#125;<br><br>      <span class="hljs-type">long</span> <span class="hljs-variable">maxStaleMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="hljs-number">1</span>) &#123;<br>        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());<br>      &#125;<br>      <span class="hljs-comment">//处于强制缓存状态，直接返回缓存数据</span><br>      <span class="hljs-keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;<br>        Response.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> cacheResponse.newBuilder();<br>        <span class="hljs-keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;<br>          builder.addHeader(<span class="hljs-string">&quot;Warning&quot;</span>, <span class="hljs-string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">oneDayMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000L</span>;<br>        <span class="hljs-keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;<br>          builder.addHeader(<span class="hljs-string">&quot;Warning&quot;</span>, <span class="hljs-string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheStrategy</span>(<span class="hljs-literal">null</span>, builder.build());<br>      &#125;<br><br>      <span class="hljs-comment">// Find a condition to add to the request. If the condition is satisfied, the response body</span><br>      <span class="hljs-comment">// will not be transmitted.</span><br>      String conditionName;<br>      String conditionValue;<br>      <span class="hljs-keyword">if</span> (etag != <span class="hljs-literal">null</span>) &#123;<br>        conditionName = <span class="hljs-string">&quot;If-None-Match&quot;</span>;<br>        conditionValue = etag;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastModified != <span class="hljs-literal">null</span>) &#123;<br>        conditionName = <span class="hljs-string">&quot;If-Modified-Since&quot;</span>;<br>        conditionValue = lastModifiedString;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (servedDate != <span class="hljs-literal">null</span>) &#123;<br>        conditionName = <span class="hljs-string">&quot;If-Modified-Since&quot;</span>;<br>        conditionValue = servedDateString;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheStrategy</span>(request, <span class="hljs-literal">null</span>); <span class="hljs-comment">// No condition! Make a regular request.</span><br>      &#125;<br>      <span class="hljs-comment">//交由服务端去进行判断</span><br>      Headers.<span class="hljs-type">Builder</span> <span class="hljs-variable">conditionalRequestHeaders</span> <span class="hljs-operator">=</span> request.headers().newBuilder();<br>      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);<br><br>      <span class="hljs-type">Request</span> <span class="hljs-variable">conditionalRequest</span> <span class="hljs-operator">=</span> request.newBuilder()<br>          .headers(conditionalRequestHeaders.build())<br>          .build();<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheStrategy</span>(conditionalRequest, cacheResponse);<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p><code>CacheStrategy</code>根据之前的缓存结果以及要发送的<code>request的header</code>计算缓存策略</p>
<table>
<thead>
<tr>
<th>networkRequest</th>
<th>cacheResponse</th>
<th>CacheStrategy</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>null</td>
<td>不进行网络请求且缓存不存在或过期<br />返回504错误</td>
</tr>
<tr>
<td>null</td>
<td>not null</td>
<td>不进行网络请求但是存在缓存且有效<br />直接返回缓存数据</td>
</tr>
<tr>
<td>not null</td>
<td>null</td>
<td>进行网络请求且缓存不存在或过期<br />直接进行网络请求获取数据</td>
</tr>
<tr>
<td>not null</td>
<td>not null</td>
<td>进行网络请求，请求头包含<code>ETag/Last-Modified</code>且缓存存在<br />根据网络请求结果判断<br />返回304，使用缓存<br />返回200，使用请求数据且更新缓存</td>
</tr>
</tbody></table>
<h2 id="OkHttp连接机制"><a href="#OkHttp连接机制" class="headerlink" title="OkHttp连接机制"></a>OkHttp连接机制</h2><p>在<code>ConnectInterceptor</code>中进行了与服务端的连接，通过<code>Exchange</code>类进行连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Exchange <span class="hljs-title function_">newExchange</span><span class="hljs-params">(Interceptor.Chain chain, <span class="hljs-type">boolean</span> doExtensiveHealthChecks)</span> &#123;<br>  <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>    <span class="hljs-keyword">if</span> (noMoreExchanges) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;released&quot;</span>);<br>    <span class="hljs-keyword">if</span> (exchange != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;exchange != null&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">//建立连接</span><br>  <span class="hljs-type">ExchangeCodec</span> <span class="hljs-variable">codec</span> <span class="hljs-operator">=</span> exchangeFinder.find(client, chain, doExtensiveHealthChecks);<br>  <span class="hljs-type">Exchange</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchange</span>(<span class="hljs-built_in">this</span>, call, eventListener, exchangeFinder, codec);<br><br>  <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>    <span class="hljs-built_in">this</span>.exchange = result;<br>    <span class="hljs-built_in">this</span>.exchangeRequestDone = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>.exchangeResponseDone = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="通过Socket连接服务端"><a href="#通过Socket连接服务端" class="headerlink" title="通过Socket连接服务端"></a>通过Socket连接服务端</h3><p>通过<code>ExchangeCodec.find()</code>来设置连接或者复用</p>
<figure class="highlight java"><figcaption><span>ExchangeCodec.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ExchangeCodec <span class="hljs-title function_">find</span><span class="hljs-params">(</span><br><span class="hljs-params">      OkHttpClient client, Interceptor.Chain chain, <span class="hljs-type">boolean</span> doExtensiveHealthChecks)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">connectTimeout</span> <span class="hljs-operator">=</span> chain.connectTimeoutMillis();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">readTimeout</span> <span class="hljs-operator">=</span> chain.readTimeoutMillis();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">writeTimeout</span> <span class="hljs-operator">=</span> chain.writeTimeoutMillis();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pingIntervalMillis</span> <span class="hljs-operator">=</span> client.pingIntervalMillis();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">connectionRetryEnabled</span> <span class="hljs-operator">=</span> client.retryOnConnectionFailure();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">RealConnection</span> <span class="hljs-variable">resultConnection</span> <span class="hljs-operator">=</span> findHealthyConnection(connectTimeout, readTimeout,<br>          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);<br>      <span class="hljs-keyword">return</span> resultConnection.newCodec(client, chain);<br>    &#125; <span class="hljs-keyword">catch</span> (RouteException e) &#123;<br>      trackFailure();<br>      <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      trackFailure();<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RouteException</span>(e);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//返回一个健康的连接 </span><br>  <span class="hljs-keyword">private</span> RealConnection <span class="hljs-title function_">findHealthyConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> connectTimeout, <span class="hljs-type">int</span> readTimeout,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> writeTimeout, <span class="hljs-type">int</span> pingIntervalMillis, <span class="hljs-type">boolean</span> connectionRetryEnabled,</span><br><span class="hljs-params">      <span class="hljs-type">boolean</span> doExtensiveHealthChecks)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-type">RealConnection</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> findConnection(connectTimeout, readTimeout, writeTimeout,<br>          pingIntervalMillis, connectionRetryEnabled);<br><br>      <span class="hljs-comment">// If this is a brand new connection, we can skip the extensive health checks.</span><br>      <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>        <span class="hljs-keyword">if</span> (candidate.successCount == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> candidate;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span><br>      <span class="hljs-comment">// isn&#x27;t, take it out of the pool and start again.</span><br>      <span class="hljs-keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;<br>        candidate.noNewExchanges();<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> RealConnection <span class="hljs-title function_">findConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> connectTimeout, <span class="hljs-type">int</span> readTimeout, <span class="hljs-type">int</span> writeTimeout,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> pingIntervalMillis, <span class="hljs-type">boolean</span> connectionRetryEnabled)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">foundPooledConnection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">RealConnection</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Route</span> <span class="hljs-variable">selectedRoute</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    RealConnection releasedConnection;<br>    Socket toClose;<br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>      hasStreamFailure = <span class="hljs-literal">false</span>; <span class="hljs-comment">// This is a fresh attempt.</span><br>      <br>      <span class="hljs-type">Route</span> <span class="hljs-variable">previousRoute</span> <span class="hljs-operator">=</span> retryCurrentRoute()<br>          ? transmitter.connection.route()<br>          : <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span><br>      <span class="hljs-comment">// already-allocated connection may have been restricted from creating new exchanges.</span><br>      releasedConnection = transmitter.connection;<br>      toClose = transmitter.connection != <span class="hljs-literal">null</span> &amp;&amp; transmitter.connection.noNewExchanges<br>          ? transmitter.releaseConnectionNoEvents()<br>          : <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-keyword">if</span> (transmitter.connection != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// We had an already-allocated connection and it&#x27;s good.</span><br>        result = transmitter.connection;<br>        releasedConnection = <span class="hljs-literal">null</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Attempt to get a connection from the pool.</span><br>        <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>)) &#123;<br>          foundPooledConnection = <span class="hljs-literal">true</span>;<br>          result = transmitter.connection;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          selectedRoute = previousRoute;<br>        &#125;<br>      &#125;<br>    &#125;<br>    closeQuietly(toClose);<br><br>    <span class="hljs-keyword">if</span> (releasedConnection != <span class="hljs-literal">null</span>) &#123;<br>      eventListener.connectionReleased(call, releasedConnection);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;<br>      eventListener.connectionAcquired(call, result);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// If we found an already-allocated or pooled connection, we&#x27;re done.</span><br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// If we need a route selection, make one. This is a blocking operation.</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">newRouteSelection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-literal">null</span> &amp;&amp; (routeSelection == <span class="hljs-literal">null</span> || !routeSelection.hasNext())) &#123;<br>      newRouteSelection = <span class="hljs-literal">true</span>;<br>      routeSelection = routeSelector.next();<br>    &#125;<br><br>    List&lt;Route&gt; routes = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br><br>      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;<br>        <span class="hljs-comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span><br>        <span class="hljs-comment">// the pool. This could match due to connection coalescing.</span><br>        routes = routeSelection.getAll();<br>        <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(<br>            address, transmitter, routes, <span class="hljs-literal">false</span>)) &#123;<br>          foundPooledConnection = <span class="hljs-literal">true</span>;<br>          result = transmitter.connection;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//没有从连接池中获取到连接需要重新建立</span><br>      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;<br>        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-literal">null</span>) &#123;<br>          selectedRoute = routeSelection.next();<br>        &#125;<br><br>        <span class="hljs-comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span><br>        <span class="hljs-comment">// for an asynchronous cancel() to interrupt the handshake we&#x27;re about to do.</span><br>        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealConnection</span>(connectionPool, selectedRoute);<br>        connectingConnection = result;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If we found a pooled connection on the 2nd time around, we&#x27;re done.</span><br>    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;<br>      eventListener.connectionAcquired(call, result);<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// Do TCP + TLS handshakes. This is a blocking operation.</span><br>    <span class="hljs-comment">// 开始TCP三次握手以及TLS操作，为阻塞操作</span><br>    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,<br>        connectionRetryEnabled, call, eventListener);<br>    connectionPool.routeDatabase.connected(result.route());<br><br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      connectingConnection = <span class="hljs-literal">null</span>;<br>      <span class="hljs-comment">// Last attempt at connection coalescing, which only occurs if we attempted multiple</span><br>      <span class="hljs-comment">// concurrent connections to the same host.</span><br>      <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="hljs-literal">true</span>)) &#123;<br>        <span class="hljs-comment">// We lost the race! Close the connection we created and return the pooled connection.</span><br>        result.noNewExchanges = <span class="hljs-literal">true</span>;<br>        socket = result.socket();<br>        result = transmitter.connection;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//加入连接池 等待复用</span><br>        connectionPool.put(result);<br>        transmitter.acquireConnectionNoEvents(result);<br>      &#125;<br>    &#125;<br>    closeQuietly(socket);<br><br>    eventListener.connectionAcquired(call, result);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>最终通过<code>Socket.connect()</code>进行连接。</p>
<h3 id="连接池-ConnectionPool"><a href="#连接池-ConnectionPool" class="headerlink" title="连接池(ConnectionPool)"></a>连接池(ConnectionPool)</h3><p>![OkHttp-连接池 ConnectionPool](&#x2F;images&#x2F;OkHttp-连接池 ConnectionPool.png)</p>
<blockquote>
<p>频繁的进行Socket连接(三次握手)和Socket断开(四次挥手)非常消耗网络资源以及时间。在HTTP1.1之后提供了<code>keep-alive</code>这个header，可以实现长连接，有效的降低了延迟并提升了处理速度。<br>连接池就是为了<strong>复用已存在连接</strong>，可以有效降低创建连接的开销。</p>
</blockquote>
<h4 id="连接池构造方法以及成员变量"><a href="#连接池构造方法以及成员变量" class="headerlink" title="连接池构造方法以及成员变量"></a>连接池构造方法以及成员变量</h4><figure class="highlight java"><figcaption><span>ConnectionPool.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span> &#123;<br>  <span class="hljs-comment">//后台清理线程</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* corePoolSize */</span>,<br>      Integer.MAX_VALUE <span class="hljs-comment">/* maximumPoolSize */</span>, <span class="hljs-number">60L</span> <span class="hljs-comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">&quot;OkHttp ConnectionPool&quot;</span>, <span class="hljs-literal">true</span>)); <br>    <span class="hljs-comment">//最大的空闲连接数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxIdleConnections;<br>    <span class="hljs-comment">//连接最大持续时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> keepAliveDurationNs;<br>    <span class="hljs-comment">//存储连接的双向队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConnectionPool</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">this</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, TimeUnit.MINUTES);<br>    &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConnectionPool</span><span class="hljs-params">(<span class="hljs-type">int</span> maxIdleConnections, <span class="hljs-type">long</span> keepAliveDuration, TimeUnit timeUnit)</span> &#123;<br>    <span class="hljs-built_in">this</span>.maxIdleConnections = maxIdleConnections;<br>    <span class="hljs-built_in">this</span>.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);<br><br>    <span class="hljs-comment">// Put a floor on the keep alive duration, otherwise cleanup will spin loop.</span><br>    <span class="hljs-keyword">if</span> (keepAliveDuration &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;keepAliveDuration &lt;= 0: &quot;</span> + keepAliveDuration);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ConnectionPool</code>支持配置以下变量</p>
<ul>
<li><code>maxIdleConnections</code>：最大空闲连接数，默认<code>5</code></li>
<li><code>keepAliveDurationNs</code>：最大连接保持时间，默认<code>5min</code></li>
</ul>
<p><code>Connection</code>连接池中的<code>Connection</code>任一超出以上配置，就需要执行清理。</p>
<p>可以通过以下方法配置连接池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>.Builder()<br>        .connectionPool(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionPool</span>()); <span class="hljs-comment">//配置连接池</span><br></code></pre></td></tr></table></figure>

<h4 id="连接池加入连接"><a href="#连接池加入连接" class="headerlink" title="连接池加入连接"></a>连接池加入连接</h4><p><img src="/images/1345862-20200603214235374-1759578389.png" srcset="/img/loading.gif" lazyload alt="双端队列"></p>
<p>通过<code>connections</code>存储<code>Connection</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(RealConnection connection)</span> &#123;<br>  <span class="hljs-keyword">assert</span> (Thread.holdsLock(<span class="hljs-built_in">this</span>));<br>  <span class="hljs-keyword">if</span> (!cleanupRunning) &#123;<span class="hljs-comment">//当前清理线程没有运行</span><br>    cleanupRunning = <span class="hljs-literal">true</span>;<br>    executor.execute(cleanupRunnable);<span class="hljs-comment">//开启清理过程</span><br>  &#125;<br>  connections.add(connection);<span class="hljs-comment">//加入队列</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在外部执行<code>put()</code>时，连接加入连接池，并且开启清理线程去清理那些超出配置的连接。</p>
<p>外部执行<code>put()</code>路径如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConnectInterceptor 连接拦截器，其中执行连接过程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">RealInterceptorChain</span> <span class="hljs-variable">realChain</span> <span class="hljs-operator">=</span> (RealInterceptorChain) chain;<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> realChain.request();<br>    <span class="hljs-type">StreamAllocation</span> <span class="hljs-variable">streamAllocation</span> <span class="hljs-operator">=</span> realChain.streamAllocation();<br><br>    <span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">doExtensiveHealthChecks</span> <span class="hljs-operator">=</span> !request.method().equals(<span class="hljs-string">&quot;GET&quot;</span>);<br>    <span class="hljs-type">HttpCodec</span> <span class="hljs-variable">httpCodec</span> <span class="hljs-operator">=</span> streamAllocation.newStream(client, chain, doExtensiveHealthChecks);<span class="hljs-comment">//建立新连接</span><br>    <span class="hljs-type">RealConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> streamAllocation.connection();<br><br>    <span class="hljs-keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);<br>&#125;<br>  <br><span class="hljs-comment">// StreamAllocation </span><br>   <span class="hljs-keyword">public</span> HttpCodec <span class="hljs-title function_">newStream</span><span class="hljs-params">(</span><br><span class="hljs-params">      OkHttpClient client, Interceptor.Chain chain, <span class="hljs-type">boolean</span> doExtensiveHealthChecks)</span> &#123;<br>       ...<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">RealConnection</span> <span class="hljs-variable">resultConnection</span> <span class="hljs-operator">=</span> findHealthyConnection(connectTimeout, readTimeout,<br>          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);<span class="hljs-comment">//寻找可用的连接</span><br>      <span class="hljs-type">HttpCodec</span> <span class="hljs-variable">resultCodec</span> <span class="hljs-operator">=</span> resultConnection.newCodec(client, chain, <span class="hljs-built_in">this</span>);<br><br>      <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>        codec = resultCodec;<br>        <span class="hljs-keyword">return</span> resultCodec;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RouteException</span>(e);<br>    &#125;<br>  &#125; <br>  <br>  <span class="hljs-keyword">private</span> RealConnection <span class="hljs-title function_">findHealthyConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> connectTimeout, <span class="hljs-type">int</span> readTimeout,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> writeTimeout, <span class="hljs-type">int</span> pingIntervalMillis, <span class="hljs-type">boolean</span> connectionRetryEnabled,</span><br><span class="hljs-params">      <span class="hljs-type">boolean</span> doExtensiveHealthChecks)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-type">RealConnection</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> findConnection(connectTimeout, readTimeout, writeTimeout,<br>          pingIntervalMillis, connectionRetryEnabled);<br>      ...<br><br>      <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>  &#125;<br>  <br>   <span class="hljs-keyword">private</span> RealConnection <span class="hljs-title function_">findConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> connectTimeout, <span class="hljs-type">int</span> readTimeout, <span class="hljs-type">int</span> writeTimeout,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> pingIntervalMillis, <span class="hljs-type">boolean</span> connectionRetryEnabled)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    ...<br>     <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (released) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;released&quot;</span>);<br>      <span class="hljs-keyword">if</span> (codec != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;codec != null&quot;</span>);<br>      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br><br>      <span class="hljs-comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span><br>      <span class="hljs-comment">// already-allocated connection may have been restricted from creating new streams.</span><br>      releasedConnection = <span class="hljs-built_in">this</span>.connection;<br>      toClose = releaseIfNoNewStreams();<br>      ...<br>      <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Attempt to get a connection from the pool.</span><br>        Internal.instance.get(connectionPool, address, <span class="hljs-built_in">this</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">//根据address从连接池中获取对应连接</span><br>        <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>          foundPooledConnection = <span class="hljs-literal">true</span>;<br>          result = connection;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          selectedRoute = route;<br>        &#125;<br>      &#125;<br>    &#125;<br>     ...<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// If we found an already-allocated or pooled connection, we&#x27;re done.</span><br>      <span class="hljs-keyword">return</span> result;<br>    &#125;  <br>     <br>     ...<br>       <br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br><br>      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;<br>        <span class="hljs-comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span><br>        <span class="hljs-comment">// the pool. This could match due to connection coalescing.</span><br>        List&lt;Route&gt; routes = routeSelection.getAll();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = routes.size(); i &lt; size; i++) &#123;<br>          <span class="hljs-type">Route</span> <span class="hljs-variable">route</span> <span class="hljs-operator">=</span> routes.get(i);<br>          Internal.instance.get(connectionPool, address, <span class="hljs-built_in">this</span>, route);<br>          <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>            foundPooledConnection = <span class="hljs-literal">true</span>;<br>            result = connection;<br>            <span class="hljs-built_in">this</span>.route = route;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;<br>        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-literal">null</span>) &#123;<br>          selectedRoute = routeSelection.next();<br>        &#125;<br><br>        <span class="hljs-comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span><br>        <span class="hljs-comment">// for an asynchronous cancel() to interrupt the handshake we&#x27;re about to do.</span><br>        route = selectedRoute;<br>        refusedStreamCount = <span class="hljs-number">0</span>;<br>        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealConnection</span>(connectionPool, selectedRoute);<span class="hljs-comment">//连接池未找到对应连接，建立新连接</span><br>        acquire(result, <span class="hljs-literal">false</span>);<br>      &#125;<br>    &#125;<br>     <br>     ...<br>    <br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      reportedAcquired = <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-comment">// Pool the connection.</span><br>      Internal.instance.put(connectionPool, result);<span class="hljs-comment">//将新建的连接加入到连接池内</span><br><br>      <span class="hljs-comment">// If another multiplexed connection to the same address was created concurrently, then</span><br>      <span class="hljs-comment">// release this connection and acquire that one.</span><br>      <span class="hljs-keyword">if</span> (result.isMultiplexed()) &#123;<br>        socket = Internal.instance.deduplicate(connectionPool, address, <span class="hljs-built_in">this</span>);<br>        result = connection;<br>      &#125;<br>    &#125;<br>     <br>   &#125;<br>  <br>  <span class="hljs-comment">//OkHttpClient</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OkHttpClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Call.Factory, WebSocket.Factory &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>      Internal.instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Internal</span>() &#123;<br>       ...<br>        <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> RealConnection <span class="hljs-title function_">get</span><span class="hljs-params">(ConnectionPool pool, Address address,</span><br><span class="hljs-params">          StreamAllocation streamAllocation, Route route)</span> &#123;<br>           <span class="hljs-keyword">return</span> pool.get(address, streamAllocation, route);<span class="hljs-comment">//从连接池获取连接</span><br>        &#125; <br>         <br>        <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(ConnectionPool pool, RealConnection connection)</span> &#123;<br>          pool.put(connection);<span class="hljs-comment">//向连接池添加连接</span><br>        &#125;<br>       ...<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>通过<code>ConnectInterceptor.intercept()</code>去建立连接，向下调用到<code>StreamAllocation.newStream()</code></p>
<p>在<code>newStream()</code>中继续执行到<code>findConnection()</code>，其中主要执行了两步</p>
<ol>
<li>从<code>ConnectionPool</code>寻找是否存有当前<code>address</code>对应的连接，调用<code>ConnectionPool.get(XXX)</code>，存在就返回对应连接。</li>
<li>不存在对应连接，执行<code>new RealConnection()</code>新建连接，并调用<code>ConnectionPool.put()</code>存储新连接</li>
</ol>
<p>对应的<code>get()、put()</code>都是通过<code>Internal.instance</code>调用的，其中<code>Internal</code>是一个抽象类，具体实现类对应的就是<code>OkHttpClient</code>。</p>
<h4 id="连接池清理连接"><a href="#连接池清理连接" class="headerlink" title="连接池清理连接"></a>连接池清理连接</h4><p>在使用<code>连接池</code>时，初始化了一个<code>Executor</code>线程池，这个主要就是为了在清理无效连接时去开启清理线程用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Background threads are used to cleanup expired connections. There will be at most a single</span><br><span class="hljs-comment">   * thread running per connection pool. The thread pool executor permits the pool itself to be</span><br><span class="hljs-comment">   * garbage collected.</span><br><span class="hljs-comment">   * 清理过期的连接，且保证最多只能运行一个清理线程。</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span> <span class="hljs-comment">/* corePoolSize */</span>,<br>      Integer.MAX_VALUE <span class="hljs-comment">/* maximumPoolSize */</span>, <span class="hljs-number">60L</span> <span class="hljs-comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">&quot;OkHttp ConnectionPool&quot;</span>, <span class="hljs-literal">true</span>));<br><br><span class="hljs-comment">//清理过期连接任务</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">cleanupRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">waitNanos</span> <span class="hljs-operator">=</span> cleanup(System.nanoTime());<span class="hljs-comment">//返回下次需要清理连接的时间</span><br>        <span class="hljs-keyword">if</span> (waitNanos == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (waitNanos &gt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-type">long</span> <span class="hljs-variable">waitMillis</span> <span class="hljs-operator">=</span> waitNanos / <span class="hljs-number">1000000L</span>;<br>          waitNanos -= (waitMillis * <span class="hljs-number">1000000L</span>);<br>          <span class="hljs-keyword">synchronized</span> (ConnectionPool.<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              ConnectionPool.<span class="hljs-built_in">this</span>.wait(waitMillis, (<span class="hljs-type">int</span>) waitNanos);<span class="hljs-comment">//阻塞等待</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>

<h5 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup()"></a>cleanup()</h5><p>内部主要执行的是<code>标记空闲连接</code>、<code>清理空闲连接</code>，<code>返回下次清理时间</code>这几步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">(<span class="hljs-type">long</span> now)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">inUseConnectionCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">idleConnectionCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">RealConnection</span> <span class="hljs-variable">longestIdleConnection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">longestIdleDurationNs</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br><br>  <span class="hljs-comment">// Find either a connection to evict, or the time that the next eviction is due.</span><br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;<span class="hljs-comment">//遍历连接储存队列</span><br>      <span class="hljs-type">RealConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> i.next();<br><br>      <span class="hljs-comment">// If the connection is in use, keep searching.</span><br>      <span class="hljs-keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//标记正在使用的活跃连接</span><br>        inUseConnectionCount++;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      idleConnectionCount++;<span class="hljs-comment">//非活跃标记为空闲连接</span><br><br>      <span class="hljs-comment">// If the connection is ready to be evicted, we&#x27;re done.</span><br>      <span class="hljs-type">long</span> <span class="hljs-variable">idleDurationNs</span> <span class="hljs-operator">=</span> now - connection.idleAtNanos;<br>      <span class="hljs-keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;<br>        longestIdleDurationNs = idleDurationNs;<br>        longestIdleConnection = connection;<span class="hljs-comment">//得到最长空闲时间的连接</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (longestIdleDurationNs &gt;= <span class="hljs-built_in">this</span>.keepAliveDurationNs<br>        || idleConnectionCount &gt; <span class="hljs-built_in">this</span>.maxIdleConnections) &#123;<br>      <span class="hljs-comment">// We&#x27;ve found a connection to evict. Remove it from the list, then close it below (outside</span><br>      <span class="hljs-comment">// of the synchronized block).</span><br>      <span class="hljs-comment">// 空闲连接超过`maxIdleConnections`个或者空闲时间超过`keepAliveDurationNs`，需要清理该连接</span><br>      connections.remove(longestIdleConnection);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idleConnectionCount &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// A connection will be ready to evict soon.</span><br>      <span class="hljs-comment">// 返回最大空闲连接的到期时间，等待到达时间后进行清理</span><br>      <span class="hljs-keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inUseConnectionCount &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// All connections are in use. It&#x27;ll be at least the keep alive duration &#x27;til we run again.</span><br>      <span class="hljs-comment">// 所有都是活跃连接，返回最大空闲连接时间，等待到达时间后清理</span><br>      <span class="hljs-keyword">return</span> keepAliveDurationNs;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// No connections, idle or in use.</span><br>      <span class="hljs-comment">// 当前不存在连接，直接返回 -1，不进行清理任务</span><br>      cleanupRunning = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// 立即关闭过期连接</span><br>  closeQuietly(longestIdleConnection.socket());<br><br>  <span class="hljs-comment">// Cleanup again immediately.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>cleanup()</code>执行流程如下：</p>
<ul>
<li>遍历<code>ConnectionPool</code>的<code>connections</code>，通过<code>pruneAndGetAllocationCount()</code>判断<code>connection</code>是否空闲</li>
<li>遍历完毕后，找到最长时间的空闲连接(<code>longestIdleConnection</code>)</li>
<li>得到<code>longestIdleConnection</code>后，先是比较当前的<code>idleConnectionCount</code>是否大于<code>maxIdleConnections</code>或者<code>longestIdleDurarionNs</code>是否大于<code>keepAliveDurationNs</code>，两者满足其一，则清理掉<code>longestIdleConnection</code></li>
<li>不满足其上条件，继续判断<code>idleConnectionCount &gt; 0 </code>，表示当前存在空闲连接，就返回距离最大空闲连接时间差<code>keepAliveDurationNs - longestIdleDurationNs</code>，等待到时清理</li>
<li>不满足其上条件，继续判断<code>inUseConnectionCount &gt; 0</code>，表示当前都是活跃连接，返回<code>keepAliveDurationNs</code>，等待达到时间清理</li>
<li>以上条件都不满足，表示当前没有连接，直接返回<code>-1</code></li>
<li>存在<code>longestIdleConnection</code>，即调用<code>longestIdleConnection.socket().close()</code>关闭连接即可</li>
</ul>
<h5 id="pruneAndGetAllocationCount-Connection"><a href="#pruneAndGetAllocationCount-Connection" class="headerlink" title="pruneAndGetAllocationCount(Connection)"></a>pruneAndGetAllocationCount(Connection)</h5><p>判断当前连接是否正在活跃，采用了<strong>引用计数法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pruneAndGetAllocationCount</span><span class="hljs-params">(RealConnection connection, <span class="hljs-type">long</span> now)</span> &#123;<br>  <span class="hljs-comment">//连接弱引用列表</span><br>  List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; references.size(); ) &#123;<br>    <span class="hljs-comment">//获取引用连接</span><br>    Reference&lt;StreamAllocation&gt; reference = references.get(i);<br>    <span class="hljs-comment">//不为null ，表示当前连接尚未回收</span><br>    <span class="hljs-keyword">if</span> (reference.get() != <span class="hljs-literal">null</span>) &#123;<br>      i++;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// We&#x27;ve discovered a leaked allocation. This is an application bug.</span><br>    StreamAllocation.<span class="hljs-type">StreamAllocationReference</span> <span class="hljs-variable">streamAllocRef</span> <span class="hljs-operator">=</span><br>        (StreamAllocation.StreamAllocationReference) reference;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A connection to &quot;</span> + connection.route().address().url()<br>        + <span class="hljs-string">&quot; was leaked. Did you forget to close a response body?&quot;</span>;<br>    Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);<br><br>    <span class="hljs-comment">//移除引用</span><br>    references.remove(i);<br>    connection.noNewStreams = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span><br>    <span class="hljs-comment">//所有引用都被移除，表示当前连接处于空闲</span><br>    <span class="hljs-keyword">if</span> (references.isEmpty()) &#123;<br>      connection.idleAtNanos = now - keepAliveDurationNs;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> references.size();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>StreamAllocation</code>引用是在<code>StreamAllocation.acquire()</code>时加入的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(RealConnection connection, <span class="hljs-type">boolean</span> reportedAcquired)</span> &#123;<br>  <span class="hljs-keyword">assert</span> (Thread.holdsLock(connectionPool));<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.connection != <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br><br>  <span class="hljs-built_in">this</span>.connection = connection;<br>  <span class="hljs-built_in">this</span>.reportedAcquired = reportedAcquired;<br>  connection.allocations.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamAllocationReference</span>(<span class="hljs-built_in">this</span>, callStackTrace));<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>通过这种<code>引用计数法</code>来判断当前是否为空闲连接</p>
<h2 id="OkHttp-Cookie机制"><a href="#OkHttp-Cookie机制" class="headerlink" title="OkHttp-Cookie机制"></a>OkHttp-Cookie机制</h2><p><img src="/images/OkHttp-Cookie%E6%9C%BA%E5%88%B6.png" srcset="/img/loading.gif" lazyload alt="OkHttp-Cookie机制"></p>
<p>使用方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">OkHttpClient.Builder()<br>  .<span class="hljs-comment">//其他参数</span><br>  .cookieJar(<span class="hljs-keyword">object</span> : CookieJar &#123;<br>     <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveFromResponse</span><span class="hljs-params">(url:<span class="hljs-type">HttpUrl</span>,cookies:<span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">Cookie</span>&gt;)</span></span>&#123;<br>       <span class="hljs-comment">//从Response 获取Cookie信息 并存储到本地</span><br>     &#125;<br>    <br>     <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadForRequest</span><span class="hljs-params">(url:<span class="hljs-type">HttpUrl</span>)</span></span> : MutableList&lt;Cookie&gt; &#123;<br>       <span class="hljs-comment">//根据url获取存储本地的Cookie信息 放到 Request请求中</span><br>     &#125;<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p><code>Cookie</code>一般都会在请求中进行使用，多用于请求头的<code>Cookie</code>字段，大致可以猜测相关的处理位于<code>BridgeInterceptor</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BridgeInterceptor.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BridgeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span>&#123;<br>  <span class="hljs-comment">//这个也就是在 构建Client时放入的CookieJar对象</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CookieJar cookieJar;<br>  <br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  ...<br>    <span class="hljs-comment">//从配置的cookiejar中获取信息</span><br>     List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());<br>     <span class="hljs-keyword">if</span> (!cookies.isEmpty()) &#123;<br>       <span class="hljs-comment">//在请求头中添加 Cookie请求头，携带Cookie参数</span><br>       requestBuilder.header(<span class="hljs-string">&quot;Cookie&quot;</span>, cookieHeader(cookies));<br>     &#125;<br>  ...   <br>    <span class="hljs-comment">//请求最后得到的 response结果</span><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">networkResponse</span> <span class="hljs-operator">=</span> chain.proceed(requestBuilder.build());<br>    <span class="hljs-comment">//从rensponse中解析Cookie并缓存到 CookieJar中</span><br>    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());<br>      <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//HttpHeaders.java</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveHeaders</span><span class="hljs-params">(CookieJar cookieJar, HttpUrl url, Headers headers)</span> &#123;<br>    <span class="hljs-keyword">if</span> (cookieJar == CookieJar.NO_COOKIES) <span class="hljs-keyword">return</span>;<br><br>    List&lt;Cookie&gt; cookies = Cookie.parseAll(url, headers);<br>    <span class="hljs-keyword">if</span> (cookies.isEmpty()) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//获取到Cookie对象 缓存中 CookieJar中</span><br>    cookieJar.saveFromResponse(url, cookies);<br>  &#125;<br><br><span class="hljs-comment">//Cookie.java</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Cookie&gt; <span class="hljs-title function_">parseAll</span><span class="hljs-params">(HttpUrl url, Headers headers)</span> &#123;<br>    <span class="hljs-comment">//从响应头中读取到 Set-Cookie字段，并转换成 Cookie对象</span><br>    List&lt;String&gt; cookieStrings = headers.values(<span class="hljs-string">&quot;Set-Cookie&quot;</span>);<br>    List&lt;Cookie&gt; cookies = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = cookieStrings.size(); i &lt; size; i++) &#123;<br>      <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> Cookie.parse(url, cookieStrings.get(i));<br>      <span class="hljs-keyword">if</span> (cookie == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (cookies == <span class="hljs-literal">null</span>) cookies = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      cookies.add(cookie);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cookies != <span class="hljs-literal">null</span><br>        ? Collections.unmodifiableList(cookies)<br>        : Collections.&lt;Cookie&gt;emptyList();<br>  &#125;<br></code></pre></td></tr></table></figure>

<p><code>Cookie</code>原理简述：</p>
<blockquote>
<p>服务端返回的<code>Response</code>通过<code>Set-Cookie</code>响应头返回对应的<code>Cookie信息</code>，以便在下次进行请求时在<code>Request</code>的请求头中添加<code>Cookie</code>字段以携带Cookie信息。</p>
<p><code>OkHttp</code>通过<code>setCookieJar</code>对所有的<code>Cookie</code>文件进行管理。</p>
<ul>
<li><code>saveFromResponse()</code>：可以获取对应域名的Cookie信息</li>
<li><code>loadForRequest()</code>：可以在请求域名时添加Cookie信息</li>
</ul>
<p>可以通过一个全局的<code>CookieJar</code>类来实现应用内Cookie文件的管理。</p>
</blockquote>
<h2 id="OkHttp-DNS功能"><a href="#OkHttp-DNS功能" class="headerlink" title="OkHttp-DNS功能"></a>OkHttp-DNS功能</h2><h3 id="DNS介绍"><a href="#DNS介绍" class="headerlink" title="DNS介绍"></a>DNS介绍</h3><p><code>Domain Name System</code>：根据域名查出IP地址，是<code>HTTP协议</code>的前提，只有将域名正确的进行解析，得到IP地址后，才可以继续进行网络连接。</p>
<p>DNS服务器结构如下：</p>
<ul>
<li><code>根DNS服务器</code>：返回顶级DNS服务器的IP地址</li>
<li><code>顶级域DNS服务器</code>：返回权威DNS服务器的IP地址</li>
<li><code>权威DNS服务器</code>：返回对应主机的IP地址</li>
</ul>
<p><img src="/images/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="LocalDNS"><a href="#LocalDNS" class="headerlink" title="LocalDNS"></a>LocalDNS</h4><p><img src="/images/OkHttp-LocalDNS.png" srcset="/img/loading.gif" lazyload alt="OkHttp-LocalDNS"></p>
<p><strong>运营商提供的DNS服务器</strong>，请求时优先查询<code>LocalDNS 缓存</code>，存在直接使用。不存在就需要从<code>根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威域名服务器</code>往上查询可用的<code>IP地址</code>。</p>
<p><img src="/images/DNS%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ol>
<li><p>不稳定</p>
<blockquote>
<p>DNS劫持或者服务器故障，导致解析服务不可用</p>
</blockquote>
</li>
<li><p>不准确</p>
<blockquote>
<p><code>LocalDNS调度</code>不一定是<strong>就近原则</strong>。某些运营商会把解析请求转发到其他运营商的<code>LocalDNS</code>服务器。</p>
<p>就会导致解析出的IP不是就近服务器，致使访问变慢甚至无法访问。</p>
</blockquote>
</li>
<li><p>不及时</p>
<blockquote>
<p>运营商可能修改DNS的<code>TTL(Time-To-Live，DNS缓存时间)</code>，导致DNS解析结构发生修改，但是在当前请求条件下尚未生效。</p>
</blockquote>
</li>
</ol>
<p><img src="/images/640-2236080." srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="HttpDNS"><a href="#HttpDNS" class="headerlink" title="HttpDNS"></a>HttpDNS</h4><p><img src="/images/OkHttp-HTTPDNS.png" srcset="/img/loading.gif" lazyload alt="OkHttp-HTTPDNS"></p>
<p><code>HTTPDNS</code>利用<code>HTTP协议</code>与DNS服务交互，绕开了运营商<code>LocalDNS</code>服务，有效防止了域名劫持以及提高了域名解析成功率。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img src="/images/HTTPDNS%E5%8E%9F%E7%90%86.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol>
<li>客户端直接访问<code>HttpDNS</code>接口，获取域名在<code>HTTPDNS服务器</code>上的最优IP(从容灾方面考虑，还需要保留<code>LocalDNS</code>请求)</li>
<li>客户端获取到<code>IP</code>后，直接向该<code>IP</code>发起HTTP请求</li>
</ol>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ol>
<li>降低了<code>UnknownHostException</code>异常发生</li>
<li>调度精准，根据用户IP，精准获取域名对应IP</li>
<li>扩展性强，可以自定义域名对应IP规则</li>
</ol>
<h3 id="OkHttp-HttpDNS实现"><a href="#OkHttp-HttpDNS实现" class="headerlink" title="OkHttp-HttpDNS实现"></a>OkHttp-HttpDNS实现</h3><p>OkHttp提供了<code>Dns接口</code>，可以进行自定义拓展替代本身的<code>LocalDNS</code>解析方式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//自定义DNS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimizeLocalDNS</span> : <span class="hljs-type">Dns</span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lookup</span><span class="hljs-params">(hostname: <span class="hljs-type">String</span>)</span></span>: List&lt;InetAddress&gt; &#123;<br>        <span class="hljs-keyword">return</span> DNSLookUpUtil.loadLocalDNS(hostname)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//设置LocalDNS超时取消</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadLocalDNS</span><span class="hljs-params">(hostname: <span class="hljs-type">String</span>, timeout: <span class="hljs-type">Long</span> = <span class="hljs-number">10</span>L)</span></span>: List&lt;InetAddress&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">val</span> task = FutureTask&lt;List&lt;InetAddress&gt;&gt;(Callable&lt;List&lt;InetAddress&gt;&gt; &#123;<br>                    <span class="hljs-comment">//返回去重结果</span><br>                    InetAddress.getAllByName(hostname).toList().distinct()<br>                &#125;)<br>                Thread(task).start()<br>                <span class="hljs-keyword">return</span> task.<span class="hljs-keyword">get</span>(timeout, TimeUnit.SECONDS)<br>            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            &#125;<br>            <span class="hljs-keyword">return</span> listOf()<br>        &#125;<br><br><span class="hljs-comment">//设置自定义DNS</span><br>mOkHttpClient = httpBuilder<br>        .dns(OptimizeLocalDNS())<br>        .build();<br></code></pre></td></tr></table></figure>

<h3 id="OkHttp-DNS原理"><a href="#OkHttp-DNS原理" class="headerlink" title="OkHttp-DNS原理"></a>OkHttp-DNS原理</h3><p>配置的<code>dns()</code>初始使用位于<code>RetryAndFollowUpInterceptor.intercept()</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RetryAndFollowUpInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>  ...<br>   <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    ...<br>        <span class="hljs-type">StreamAllocation</span> <span class="hljs-variable">streamAllocation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamAllocation</span>(client.connectionPool(),<br>        createAddress(request.url()), call, eventListener, callStackTrace);<br>   &#125;<br>  <br>   <span class="hljs-keyword">private</span> Address <span class="hljs-title function_">createAddress</span><span class="hljs-params">(HttpUrl url)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(url.host(), url.port(), client.dns(), client.socketFactory(),<br>        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),<br>        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());<br>  &#125;<br> <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>构造出一个<code>Address</code>对象，里面包含了<code>主机名(host)、端口(port)、DNS配置(DNS)、SSL配置(sslSocketFactory,certificatePinner)、代理设置</code></p>
<p>得到<code>Address</code>，通过<code>StreamAllocation</code>构造了<code>RouteSelector</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">StreamAllocation</span><span class="hljs-params">(ConnectionPool connectionPool, Address address, Call call,</span><br><span class="hljs-params">    EventListener eventListener, Object callStackTrace)</span> &#123;<br>  <span class="hljs-built_in">this</span>.connectionPool = connectionPool;<br>  <span class="hljs-built_in">this</span>.address = address;<br>  <span class="hljs-built_in">this</span>.call = call;<br>  <span class="hljs-built_in">this</span>.eventListener = eventListener;<br>  <span class="hljs-built_in">this</span>.routeSelector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RouteSelector</span>(address, routeDatabase(), call, eventListener);<br>  <span class="hljs-built_in">this</span>.callStackTrace = callStackTrace;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>RouteSelector</code>主要为了<strong>Select Route(选择路由)，返回一个可用的<code>Route</code>对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetNextInetSocketAddress</span><span class="hljs-params">(Proxy proxy)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// Clear the addresses. Necessary if getAllByName() below throws!</span><br>    inetSocketAddresses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    String socketHost;<br>    <span class="hljs-type">int</span> socketPort;<br>    <span class="hljs-keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;<span class="hljs-comment">//存在代理</span><br>      socketHost = address.url().host();<br>      socketPort = address.url().port();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">proxyAddress</span> <span class="hljs-operator">=</span> proxy.address();<br>      <span class="hljs-keyword">if</span> (!(proxyAddress <span class="hljs-keyword">instanceof</span> InetSocketAddress)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>            <span class="hljs-string">&quot;Proxy.address() is not an &quot;</span> + <span class="hljs-string">&quot;InetSocketAddress: &quot;</span> + proxyAddress.getClass());<br>      &#125;<br>      <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">proxySocketAddress</span> <span class="hljs-operator">=</span> (InetSocketAddress) proxyAddress;<br>      socketHost = getHostString(proxySocketAddress);<br>      socketPort = proxySocketAddress.getPort();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (socketPort &lt; <span class="hljs-number">1</span> || socketPort &gt; <span class="hljs-number">65535</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SocketException</span>(<span class="hljs-string">&quot;No route to &quot;</span> + socketHost + <span class="hljs-string">&quot;:&quot;</span> + socketPort<br>          + <span class="hljs-string">&quot;; port is out of range&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;<span class="hljs-comment">//解析的直接为代理地址</span><br>      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//dns开始解析监听</span><br>      eventListener.dnsStart(call, socketHost);<br><br>      <span class="hljs-comment">// Try each address for best behavior in mixed IPv4/IPv6 environments.</span><br>      List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);<span class="hljs-comment">//通过配置的DNS去解析对应域名的IP列表</span><br>      <span class="hljs-keyword">if</span> (addresses.isEmpty()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnknownHostException</span>(address.dns() + <span class="hljs-string">&quot; returned no addresses for &quot;</span> + socketHost);<br>      &#125;<br>      <span class="hljs-comment">//dns解析结束监听</span><br>      eventListener.dnsEnd(call, socketHost, addresses);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;<br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">inetAddress</span> <span class="hljs-operator">=</span> addresses.get(i);<br>        inetSocketAddresses.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(inetAddress, socketPort));<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>



<p><code>resetNextInetSocketAddress()</code>返回<code>List&lt;InetSocketAddress&gt;</code>，区分了一下两种情况</p>
<ul>
<li>设置了<code>proxies</code>代理服务器，直接返回<code>InetSocketAddress(socketHost,socketPort)</code>代理服务器对应的地址和端口</li>
<li>未设置代理服务器，通过设置的<code>dns</code>去解析对应域名(<code>dns.lookup(host)</code>)得到<code>List&lt;InetAddress&gt;</code>对应的IP列表，在返回对应地址</li>
</ul>
<h2 id="OkHttp-HTTP2-0协议支持"><a href="#OkHttp-HTTP2-0协议支持" class="headerlink" title="OkHttp-HTTP2.0协议支持"></a>OkHttp-HTTP2.0协议支持</h2><p><img src="/images/OkHttp-HTTP2.0.png" srcset="/img/loading.gif" lazyload alt="OkHttp-HTTP2.0"></p>
<blockquote>
<p>基于<code>二进制分帧</code>、<code>首部压缩</code>和<code>服务端推送</code>进行分析</p>
</blockquote>
<p>&#x2F;&#x2F;TODO</p>
<h2 id="OkHttp拓展"><a href="#OkHttp拓展" class="headerlink" title="OkHttp拓展"></a>OkHttp拓展</h2><h3 id="请求时间获取"><a href="#请求时间获取" class="headerlink" title="请求时间获取"></a>请求时间获取</h3><p><img src="/images/OkHttp%E8%A7%A3%E6%9E%90%E8%8A%82%E7%82%B9" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><code>EventListener</code>是OkHttp提供的监听回调，可以通过实现这个抽象类监听到网络请求各阶段的时间点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventListener</span> &#123;<br>   <span class="hljs-comment">//请求相关回调</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callStart</span><span class="hljs-params">(Call call)</span> &#123;&#125; <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callEnd</span><span class="hljs-params">(Call call)</span> &#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callFailed</span><span class="hljs-params">(Call call, IOException ioe)</span> &#123;&#125;  <br>  <br>   <span class="hljs-comment">//dns解析回调</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dnsStart</span><span class="hljs-params">(Call call, String domainName)</span> &#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dnsEnd</span><span class="hljs-params">(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList)</span> &#123;&#125;<br>  <br>   <span class="hljs-comment">//请求连接相关回调</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectStart</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy)</span>&#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectEnd</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,<span class="hljs-meta">@Nullable</span> Protocol protocol)</span> &#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectFailed</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,</span><br><span class="hljs-params">      <span class="hljs-meta">@Nullable</span> Protocol protocol, IOException ioe)</span> &#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectionAcquired</span><span class="hljs-params">(Call call, Connection connection)</span>&#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connectionReleased</span><span class="hljs-params">(Call call, Connection connection)</span>&#123;&#125;<br>  <br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="DNS解析耗时"><a href="#DNS解析耗时" class="headerlink" title="DNS解析耗时"></a>DNS解析耗时</h4><p>只要监听<code>dnsStart()</code>和<code>dnsEnd()</code>之间的时间差即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> dnsStartTime;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">dnsDuration</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>;    <br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dnsStart</span><span class="hljs-params">(Call call, String domainName)</span> &#123;<br>    <span class="hljs-built_in">super</span>.dnsStart(call, domainName);<br>    recordEventLog(<span class="hljs-string">&quot;dnsStart&quot;</span>);<br>    dnsStartTime = System.nanoTime();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dnsEnd</span><span class="hljs-params">(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList)</span> &#123;<br>    <span class="hljs-built_in">super</span>.dnsEnd(call, domainName, inetAddressList);<br>    recordEventLog(<span class="hljs-string">&quot;dnsEnd&quot;</span>);<br>    dnsDuration = (System.nanoTime() - dnsStartTime) / <span class="hljs-number">1000000</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDnsDuration</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> dnsDuration;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>dnsDuration</code>即为DNS解析耗时</p>
<h4 id="请求连接耗时"><a href="#请求连接耗时" class="headerlink" title="请求连接耗时"></a>请求连接耗时</h4><p>初始连接耗时</p>
<blockquote>
<p>使用Socket建立TCP连接，初始连接表示的就是<code>Socket建立连接的过程</code></p>
</blockquote>
<p>只要监听<code>connectStart()</code>和<code>connectEnd()</code>之间的时间差。</p>
<p>复用连接耗时</p>
<blockquote>
<p>OkHttp设置<code>ConnectionPool</code>，可以复用已存在的连接</p>
</blockquote>
<p>需要监听<code>connectAcquired()</code>和<code>connectReleased()</code>之间的时间差</p>
<h3 id="IP直连问题"><a href="#IP直连问题" class="headerlink" title="IP直连问题"></a>IP直连问题</h3><p>&#x2F;&#x2F;TODO</p>
<h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a704ed05188255a8817f4c9">开源框架源码鉴赏：OkHttp</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenqf/p/6386163.html">彻底弄懂HTTP缓存机制及原理</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/iaPtSF-twWz-AN66UJUBDg">百度App网络深度优化系列《一》DNS优化</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903785232498696#heading-4">HTTP2.0相关</a></p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7541">HPACK算法</a></p>
<p><a target="_blank" rel="noopener" href="https://sq.163yun.com/blog/article/188769987293102080">HTTP&#x2F;2首部压缩的OkHttp3实现</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="print-no-link">#源码解析</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>OkHttp简析</div>
      <div>http://example.com/2019/03/08/OkHttp简析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Leo-Wxy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2019年3月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/03/12/WebView%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="WebView相关知识">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">WebView相关知识</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/03/08/Retrofit%E7%AE%80%E6%9E%90/" title="Retrofit简析">
                        <span class="hidden-mobile">Retrofit简析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
