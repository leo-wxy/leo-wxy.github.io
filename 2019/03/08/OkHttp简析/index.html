

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <title>OkHttp简析 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/atom-one-light.min.css">
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
                OkHttp简析
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-03-08 10:18" pubdate>
        2019年3月8日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      201
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">OkHttp简析</h1>
            
            <div class="markdown-body" id="post-body">
              <blockquote>
<p>基于OkHttp 3.13版本进行分析</p>
</blockquote>
<p><img src="/images/OkHttp简析mind.png" srcset="/img/loading.gif" alt="OkHttp简析"></p>
<h2 id="OkHttp定义"><a href="#OkHttp定义" class="headerlink" title="OkHttp定义"></a>OkHttp定义</h2><p><code>OkHttp</code>现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。</p>
<p>所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。</p>
<p>OkHttp支持<code>SPDY协议</code>，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。</p>
<blockquote>
<p><code>SPDY协议</code>：Google提出的基于TCP的应用层协议，通过<code>压缩、多路复用、优先级</code>来缩短加载时间。</p>
</blockquote>
<h2 id="OkHttp使用示例"><a href="#OkHttp使用示例" class="headerlink" title="OkHttp使用示例"></a>OkHttp使用示例</h2><h3 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><pre><code class="hljs java">Request request = <span class="hljs-keyword">new</span> Request.Builder()
     .url(url)
     .build();</code></pre>
<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><pre><code class="hljs java">RequestBody body = RequestBody.create(JSON, json);
Request request = <span class="hljs-keyword">new</span> Request.Builder()
    .url(url)
    .post(body)
    .build();</code></pre>
<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();
Response response = client.newCall(request).execute();
<span class="hljs-keyword">return</span> response.body().string();</code></pre>
<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();

client.newCall(request).enqueue(<span class="hljs-keyword">new</span> Callback() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> </span>&#123;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call call, okhttp3.Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    &#125;
&#125;);</code></pre>
<h2 id="OkHttp源码分析"><a href="#OkHttp源码分析" class="headerlink" title="OkHttp源码分析"></a>OkHttp源码分析</h2><h3 id="构造OkHttpClient对象"><a href="#构造OkHttpClient对象" class="headerlink" title="构造OkHttpClient对象"></a>构造<code>OkHttpClient</code>对象</h3><p><img src="/images/OkHttp-构造OkHttpClient对象.png" srcset="/img/loading.gif" alt="构造OkHttpClient对象"></p>
<blockquote>
<p>需要先创建一个<code>OkHttpClient</code>用以执行后续请求。<strong>内部主要是相关参数配置。</strong></p>
<p>主要功能：通信的客户端，用以统一发起请求与解析返回值。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OkHttpClient</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> Builder());
&#125;

OkHttpClient(Builder builder) &#123;
  <span class="hljs-comment">//用于调用网络请求 本质为 线程池</span>
  <span class="hljs-keyword">this</span>.dispatcher = builder.dispatcher;
  <span class="hljs-comment">//设置代理</span>
  <span class="hljs-keyword">this</span>.proxy = builder.proxy;
  <span class="hljs-comment">//设置协议</span>
  <span class="hljs-keyword">this</span>.protocols = builder.protocols;
  <span class="hljs-keyword">this</span>.connectionSpecs = builder.connectionSpecs;
  <span class="hljs-comment">//设置拦截器</span>
  <span class="hljs-keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);
  <span class="hljs-comment">//设置网络拦截器</span>
  <span class="hljs-keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);
  <span class="hljs-comment">//回调监听</span>
  <span class="hljs-keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;
  <span class="hljs-keyword">this</span>.proxySelector = builder.proxySelector;
  <span class="hljs-comment">//Cookie</span>
  <span class="hljs-keyword">this</span>.cookieJar = builder.cookieJar;
  <span class="hljs-comment">//缓存</span>
  <span class="hljs-keyword">this</span>.cache = builder.cache;
  <span class="hljs-keyword">this</span>.internalCache = builder.internalCache;
  <span class="hljs-keyword">this</span>.socketFactory = builder.socketFactory;

  <span class="hljs-keyword">boolean</span> isTLS = <span class="hljs-keyword">false</span>;
  <span class="hljs-keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;
    isTLS = isTLS || spec.isTls();
  &#125;

  <span class="hljs-comment">//用于Https请求</span>
  <span class="hljs-keyword">if</span> (builder.sslSocketFactory != <span class="hljs-keyword">null</span> || !isTLS) &#123;
    <span class="hljs-keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;
    <span class="hljs-keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;
  &#125; <span class="hljs-keyword">else</span> &#123;
    X509TrustManager trustManager = Util.platformTrustManager();
    <span class="hljs-keyword">this</span>.sslSocketFactory = newSslSocketFactory(trustManager);
    <span class="hljs-keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
  &#125;

  <span class="hljs-keyword">if</span> (sslSocketFactory != <span class="hljs-keyword">null</span>) &#123;
    Platform.get().configureSslSocketFactory(sslSocketFactory);
  &#125;

  <span class="hljs-keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;
  <span class="hljs-keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
      certificateChainCleaner);
  <span class="hljs-keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;
  <span class="hljs-keyword">this</span>.authenticator = builder.authenticator;
  <span class="hljs-keyword">this</span>.connectionPool = builder.connectionPool;
  <span class="hljs-keyword">this</span>.dns = builder.dns;
  <span class="hljs-keyword">this</span>.followSslRedirects = builder.followSslRedirects;
  <span class="hljs-keyword">this</span>.followRedirects = builder.followRedirects;
  <span class="hljs-comment">//是否需要重试</span>
  <span class="hljs-keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;
  <span class="hljs-keyword">this</span>.callTimeout = builder.callTimeout;
  <span class="hljs-comment">//链接超时时长</span>
  <span class="hljs-keyword">this</span>.connectTimeout = builder.connectTimeout;
  <span class="hljs-comment">//读取超时时间</span>
  <span class="hljs-keyword">this</span>.readTimeout = builder.readTimeout;
  <span class="hljs-comment">//写入超时时间</span>
  <span class="hljs-keyword">this</span>.writeTimeout = builder.writeTimeout;
  <span class="hljs-keyword">this</span>.pingInterval = builder.pingInterval;

  <span class="hljs-keyword">if</span> (interceptors.contains(<span class="hljs-keyword">null</span>)) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Null interceptor: "</span> + interceptors);
  &#125;
  <span class="hljs-keyword">if</span> (networkInterceptors.contains(<span class="hljs-keyword">null</span>)) &#123;
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Null network interceptor: "</span> + networkInterceptors);
  &#125;
&#125;</code></pre>
<p><code>OkHttpClient</code>是应用<strong>建造者模式</strong>，通过<code>OkHttpClient.Builder</code>来构造一个<code>OkHttpClient</code>对象，支持数十种参数配置。</p>
<h3 id="构造Request请求对象"><a href="#构造Request请求对象" class="headerlink" title="构造Request请求对象"></a>构造<code>Request</code>请求对象</h3><p><img src="/images/OkHttp-构造Request请求对象.png" srcset="/img/loading.gif" alt="OkHttp-构造Request请求对象"></p>
<blockquote>
<p>创建一个<code>Request</code>对象用以包括请求的所有信息，内部包含了<strong>请求地址，请求头，请求内容</strong>。</p>
<p>主要功能：封装请求的具体信息。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;
  Request(Builder builder) &#123;
    <span class="hljs-comment">//请求地址</span>
    <span class="hljs-keyword">this</span>.url = builder.url;
    <span class="hljs-comment">//请求方法 例如：GET、POST、PUT、DELETE等</span>
    <span class="hljs-keyword">this</span>.method = builder.method;
    <span class="hljs-comment">//请求头信息</span>
    <span class="hljs-keyword">this</span>.headers = builder.headers.build();
    <span class="hljs-comment">//请求内容构造体</span>
    <span class="hljs-keyword">this</span>.body = builder.body;
    <span class="hljs-comment">//请求的标签  用于后续对指定标签可进行特殊处理</span>
    <span class="hljs-keyword">this</span>.tags = Util.immutableMap(builder.tags);
  &#125;
    
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;
    <span class="hljs-meta">@Nullable</span> HttpUrl url;
    String method;
    Headers.Builder headers;
    <span class="hljs-meta">@Nullable</span> RequestBody body;

    <span class="hljs-comment">/** A mutable map of tags, or an immutable empty map if we don't have any. */</span>
    Map&lt;Class&lt;?&gt;, Object&gt; tags = Collections.emptyMap();
    
    <span class="hljs-comment">//默认是GET方法，不带有请求体</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">this</span>.method = <span class="hljs-string">"GET"</span>;
      <span class="hljs-keyword">this</span>.headers = <span class="hljs-keyword">new</span> Headers.Builder();
    &#125;

    Builder(Request request) &#123;
      <span class="hljs-keyword">this</span>.url = request.url;
      <span class="hljs-keyword">this</span>.method = request.method;
      <span class="hljs-keyword">this</span>.body = request.body;
      <span class="hljs-keyword">this</span>.tags = request.tags.isEmpty()
          ? Collections.emptyMap()
          : <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(request.tags);
      <span class="hljs-keyword">this</span>.headers = request.headers.newBuilder();
    &#125;
     ... 
  &#125;
&#125;</code></pre>
<p><code>Request</code>使用的也是<strong>建造者模式</strong>，通过<code>Request.Builder</code>去构造对应<code>Request</code>。</p>
<h4 id="请求体RequestBody"><a href="#请求体RequestBody" class="headerlink" title="请求体RequestBody"></a>请求体<code>RequestBody</code></h4><blockquote>
<p>主要功能：用以提交<strong>流、表单等请求信息</strong>。</p>
</blockquote>
<h5 id="FormBody"><a href="#FormBody" class="headerlink" title="FormBody"></a>FormBody</h5><blockquote>
<p>支持提交键值对类型。例如<code>userId : 1</code></p>
</blockquote>
<p>使用方法</p>
<pre><code class="hljs java">FormBody.Builder formBodyBuilder = <span class="hljs-keyword">new</span> FormBody.Builder();
Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();
<span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;
    formBodyBuilder.add(entry.getKey(), entry.getValue().toString());
&#125;
RequestBody body = formBodyBuilder.build();</code></pre>
<h5 id="MultipartBody"><a href="#MultipartBody" class="headerlink" title="MultipartBody"></a>MultipartBody</h5><blockquote>
<p>除了支持键值对，还有提交文件功能。</p>
</blockquote>
<p>使用方法</p>
<pre><code class="hljs java">MultipartBody.Builder multipartBuilder = <span class="hljs-keyword">new</span> MultipartBody.Builder().setType(MultipartBody.FORM);
       Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();
       <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;
           multipartBuilder.addFormDataPart(entry.getKey(), entry.getValue().toString());
       &#125;
       <span class="hljs-comment">//可以针对文件新起一个 参数来进行传递</span>
       <span class="hljs-keyword">for</span> (Map.Entry&lt;String, File&gt; entry : message.getFiles().entrySet()) &#123;
           File f = entry.getValue();
           <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)
               <span class="hljs-keyword">continue</span>;
           String name = f.getName();
           String ext = name.substring(name.lastIndexOf(<span class="hljs-string">'.'</span>));
           String imageFormat = <span class="hljs-string">"jpg"</span>;
           <span class="hljs-keyword">if</span> (<span class="hljs-string">".png"</span>.equalsIgnoreCase(ext)) &#123;
               imageFormat = <span class="hljs-string">"png"</span>;
           &#125;
           multipartBuilder.addFormDataPart(
                   entry.getKey(),
                   entry.getValue().getName(),
                   RequestBody.create(MediaType.parse(<span class="hljs-string">"image/"</span> + imageFormat), entry.getValue())
           );
       &#125;

       RequestBody body = multipartBuilder.build();</code></pre>
<h3 id="发送Request请求"><a href="#发送Request请求" class="headerlink" title="发送Request请求"></a>发送<code>Request</code>请求</h3><p><img src="/images/OkHttp-发送Request请求.png" srcset="/img/loading.gif" alt="OkHttp-发送Request请求"></p>
<p>通过<code>OkHttpClient.newCall()</code>发送出<code>Request</code>请求</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Call <span class="hljs-title">newCall</span><span class="hljs-params">(Request request)</span> </span>&#123;
  <span class="hljs-keyword">return</span> RealCall.newRealCall(<span class="hljs-keyword">this</span>, request, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* for web socket */</span>);
&#125;</code></pre>
<p>返回了一个<code>Call</code>对象，实现类为<code>RealCall</code></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Call</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cloneable</span> </span>&#123;
  <span class="hljs-comment">//获取当前请求</span>
  <span class="hljs-function">Request <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;
  <span class="hljs-comment">//执行当前请求 并返回结果</span>
  <span class="hljs-function">Response <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;
  <span class="hljs-comment">//异步请求</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Callback responseCallback)</span></span>;
  <span class="hljs-comment">//取消请求</span>
  <span class="hljs-comment">/** Cancels the request, if possible. Requests that are already complete cannot be canceled. */</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>;
  <span class="hljs-comment">//当前请求是否正在执行</span>
  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isExecuted</span><span class="hljs-params">()</span></span>;
  <span class="hljs-comment">//请求是否已取消</span>
  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCanceled</span><span class="hljs-params">()</span></span>;
  <span class="hljs-comment">//超时返回</span>
  <span class="hljs-function">Timeout <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>;
  <span class="hljs-comment">//克隆请求 用于重新调用</span>
  <span class="hljs-function">Call <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>;

  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;
    <span class="hljs-function">Call <span class="hljs-title">newCall</span><span class="hljs-params">(Request request)</span></span>;
  &#125;
&#125;</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Call</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RealCall</span><span class="hljs-params">(OkHttpClient client, Request originalRequest, <span class="hljs-keyword">boolean</span> forWebSocket)</span> </span>&#123;
    	<span class="hljs-comment">//前面先行创建的 OkHttpClient</span>
    	<span class="hljs-keyword">this</span>.client = client;
        <span class="hljs-comment">//创建的请求对象</span>
    	<span class="hljs-keyword">this</span>.originalRequest = originalRequest;
   		<span class="hljs-comment">//用于建立长连接</span>
    	<span class="hljs-keyword">this</span>.forWebSocket = forWebSocket;
  	&#125;
    
    <span class="hljs-function"><span class="hljs-keyword">static</span> RealCall <span class="hljs-title">newRealCall</span><span class="hljs-params">(OkHttpClient client, Request originalRequest, <span class="hljs-keyword">boolean</span> forWebSocket)</span> </span>&#123;
    	<span class="hljs-comment">// Safely publish the Call instance to the EventListener.</span>
    	RealCall call = <span class="hljs-keyword">new</span> RealCall(client, originalRequest, forWebSocket);
        <span class="hljs-comment">//为这次请求设置了事件监听器，包括请求开始、结束、异常等监听</span>
    	call.transmitter = <span class="hljs-keyword">new</span> Transmitter(client, call);
    	<span class="hljs-keyword">return</span> call;
  	&#125;
&#125;</code></pre>
<p>通过<code>newCall()</code>根据传递进来的<code>Request</code>创建一个<code>RealCall</code>实例去发送请求。</p>
<h4 id="同步请求——execute"><a href="#同步请求——execute" class="headerlink" title="同步请求——execute()"></a>同步请求——execute()</h4><blockquote>
<p>直接执行并返回请求结果</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already Executed"</span>);
      executed = <span class="hljs-keyword">true</span>;
    &#125;
    transmitter.timeoutEnter();
    <span class="hljs-comment">//请求开始</span>
    transmitter.callStart();
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-comment">//加入 runningSuncCalls 队列中</span>
      client.dispatcher().executed(<span class="hljs-keyword">this</span>);
      <span class="hljs-comment">//返回响应结果</span>
      <span class="hljs-keyword">return</span> getResponseWithInterceptorChain();
    &#125; <span class="hljs-keyword">finally</span> &#123;
      <span class="hljs-comment">//从队列中移除 避免重复执行</span>
      client.dispatcher().finished(<span class="hljs-keyword">this</span>);
    &#125;
  &#125;</code></pre>
<blockquote>
<p>执行<code>execute()</code>时，监听到请求事件开始，就会加入到<code>Dispatcher.runningSyncCalls</code>中，里面记录的是当前正在进行同步请求的call，然后当call完成时或因异常结束时，再从<code>Dispatcher.runningSyncCalls</code>移除。</p>
</blockquote>
<h4 id="异步请求——enqueue-Callback-callback"><a href="#异步请求——enqueue-Callback-callback" class="headerlink" title="异步请求——enqueue(Callback callback)"></a>异步请求——enqueue(Callback callback)</h4><blockquote>
<p>构造一个异步执行队列，然后把请求加入队列中处理</p>
</blockquote>
<pre><code class="hljs java">  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Callback responseCallback)</span> </span>&#123;
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already Executed"</span>);
      executed = <span class="hljs-keyword">true</span>;
    &#125;
    transmitter.callStart();
    client.dispatcher().enqueue(<span class="hljs-keyword">new</span> AsyncCall(responseCallback));
  &#125;

<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamedRunnable</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Callback responseCallback;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> AtomicInteger callsPerHost = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);

    AsyncCall(Callback responseCallback) &#123;
      <span class="hljs-keyword">super</span>(<span class="hljs-string">"OkHttp %s"</span>, redactedUrl());
      <span class="hljs-keyword">this</span>.responseCallback = responseCallback;
    &#125;

    <span class="hljs-function">AtomicInteger <span class="hljs-title">callsPerHost</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">return</span> callsPerHost;
    &#125;
    ...

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">executeOn</span><span class="hljs-params">(ExecutorService executorService)</span> </span>&#123;
      <span class="hljs-keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));
      <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;
      <span class="hljs-keyword">try</span> &#123;
        executorService.execute(<span class="hljs-keyword">this</span>);
        success = <span class="hljs-keyword">true</span>;
      &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;
        InterruptedIOException ioException = <span class="hljs-keyword">new</span> InterruptedIOException(<span class="hljs-string">"executor rejected"</span>);
        ioException.initCause(e);
        transmitter.noMoreExchanges(ioException);
        responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, ioException);
      &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-keyword">if</span> (!success) &#123;
          client.dispatcher().finished(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// This call is no longer running!</span>
        &#125;
      &#125;
    &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">boolean</span> signalledCallback = <span class="hljs-keyword">false</span>;
      transmitter.timeoutEnter();
      <span class="hljs-keyword">try</span> &#123;
        Response response = getResponseWithInterceptorChain();
        signalledCallback = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">//回调请求结果</span>
        responseCallback.onResponse(RealCall.<span class="hljs-keyword">this</span>, response);
      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
        <span class="hljs-keyword">if</span> (signalledCallback) &#123;
          <span class="hljs-comment">// Do not signal the callback twice!</span>
          Platform.get().log(INFO, <span class="hljs-string">"Callback failure for "</span> + toLoggableString(), e);
        &#125; <span class="hljs-keyword">else</span> &#123;
          <span class="hljs-comment">//回调失败并返回异常</span>
          responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, e);
        &#125;
      &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">//从队列中移除</span>
        client.dispatcher().finished(<span class="hljs-keyword">this</span>);
      &#125;
    &#125;
  &#125;</code></pre>
<blockquote>
<p><code>enqueue()</code>调用到<code>Dispatcher.enqueue()</code>传入的是一个<code>AsyncCall</code>对象，<code>AsyncCall</code>本质是一个<code>Runnable</code>对象，通过<code>Dispatcher</code>中的<code>ExecutorService</code>来执行<code>AsyncCall</code>。</p>
</blockquote>
<h3 id="执行Request请求"><a href="#执行Request请求" class="headerlink" title="执行Request请求"></a>执行<code>Request</code>请求</h3><blockquote>
<p>由<code>execute()</code>或<code>enqueue()</code>发送请求时，最后都是需要有<code>Dispatch</code>去执行请求。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dispatcher</span> </span>&#123;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxRequests = <span class="hljs-number">64</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxRequestsPerHost = <span class="hljs-number">5</span>;
    
  <span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> ExecutorService executorService;
  <span class="hljs-comment">//正在准备执行的异步请求队列</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
  <span class="hljs-comment">//正在执行的异步请求队列</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
  <span class="hljs-comment">//正在执行的同步请求队列 </span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
    
  <span class="hljs-comment">//用以执行异步请求</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> ExecutorService <span class="hljs-title">executorService</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (executorService == <span class="hljs-keyword">null</span>) &#123;
      executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60</span>, TimeUnit.SECONDS,
          <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp Dispatcher"</span>, <span class="hljs-keyword">false</span>));
    &#125;
    <span class="hljs-keyword">return</span> executorService;
  &#125;
    
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(AsyncCall call)</span> </span>&#123;
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
      <span class="hljs-comment">//加入正在执行的异步队列中</span>
      readyAsyncCalls.add(call);

      <span class="hljs-comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span>
      <span class="hljs-comment">// the same host.</span>
      <span class="hljs-keyword">if</span> (!call.get().forWebSocket) &#123;
        AsyncCall existingCall = findExistingCallWithHost(call.host());
        <span class="hljs-keyword">if</span> (existingCall != <span class="hljs-keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);
      &#125;
    &#125;
    promoteAndExecute();
  &#125;
    
  <span class="hljs-comment">//加入正在执行的同步队列</span>
  <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executed</span><span class="hljs-params">(RealCall call)</span> </span>&#123;
    runningSyncCalls.add(call);
  &#125;
  <span class="hljs-comment">//从政在执行的异步队列中移除  </span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(AsyncCall call)</span> </span>&#123;
    call.callsPerHost().decrementAndGet();
    finished(runningAsyncCalls, call);
  &#125;
  <span class="hljs-comment">//执行完毕后  从正在执行的同步队列中移除</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(RealCall call)</span> </span>&#123;
    finished(runningSyncCalls, call);
  &#125;
    
  <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;
    Runnable idleCallback;
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
      <span class="hljs-keyword">if</span> (!calls.remove(call)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">"Call wasn't in-flight!"</span>);
      idleCallback = <span class="hljs-keyword">this</span>.idleCallback;
    &#125;
    <span class="hljs-keyword">boolean</span> isRunning = promoteAndExecute();
    <span class="hljs-keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="hljs-keyword">null</span>) &#123;
      idleCallback.run();
    &#125;
  &#125;
    
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">promoteAndExecute</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-comment">//判定当前线程是否持有锁</span>
    <span class="hljs-keyword">assert</span> (!Thread.holdsLock(<span class="hljs-keyword">this</span>));

    List&lt;AsyncCall&gt; executableCalls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">boolean</span> isRunning;
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
      
      <span class="hljs-keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;
        AsyncCall asyncCall = i.next();
        <span class="hljs-comment">//正在运行的异步请求不能超过 64个</span>
        <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Max capacity.</span>
        <span class="hljs-comment">//在同一个Host下的异步请求不能超过5个</span>
        <span class="hljs-keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Host max capacity.</span>

        i.remove();
        <span class="hljs-comment">//CAS</span>
        asyncCall.callsPerHost().incrementAndGet();
        <span class="hljs-comment">//添加至异步执行队列</span>
        executableCalls.add(asyncCall);
        <span class="hljs-comment">//添加至正在执行异步请求队列</span>
        runningAsyncCalls.add(asyncCall);
      &#125;
      isRunning = runningCallsCount() &gt; <span class="hljs-number">0</span>;
    &#125;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;
      AsyncCall asyncCall = executableCalls.get(i);
      <span class="hljs-comment">//执行异步请求</span>
      asyncCall.executeOn(executorService());
    &#125;

    <span class="hljs-keyword">return</span> isRunning;
  &#125;
&#125;</code></pre>
<p><code>Dispatcher</code>是一个任务调度器，内部维护了三个双端队列：</p>
<ul>
<li><code>readyAsyncCalls</code>：准备执行的异步请求。<em>已经超过请求上限的异步请求就会放在该队列中。</em></li>
<li><code>runningAsyncCalls</code>：正在执行的异步请求。<em>不超过请求上限时，异步请求会加入到该队列中，超过时，依然放到<code>readyAsyncCalls</code>中。</em></li>
<li><code>runningSyncCalls</code>：正在执行的同步请求。<em>直接把同步请求添加到该队列中。</em></li>
</ul>
<p>通过<code>Dispatcher</code>中的<code>executorService</code>去执行对应请求。</p>
<h3 id="处理Request请求——通过拦截器"><a href="#处理Request请求——通过拦截器" class="headerlink" title="处理Request请求——通过拦截器"></a>处理<code>Request</code>请求——通过拦截器</h3><p><img src="/images/OkHttp-处理Request请求.png" srcset="/img/loading.gif" alt="OkHttp-处理Request请求"></p>
<blockquote>
<p>通过<code>Dispatcher</code>执行完请求后，返回回调结果前，需要通过<code>getResponseWithInterceptorChain()</code>通过层层责任链的执行来获得最终的请求结果。</p>
<p><strong>通过责任链模式将请求一层层的通过拦截器进行处理。</strong></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function">Response <span class="hljs-title">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-comment">// Build a full stack of interceptors.</span>
    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-comment">//加入用户自定义的拦截器</span>
    interceptors.addAll(client.interceptors());
    <span class="hljs-comment">//重试和重定向拦截器</span>
    interceptors.add(<span class="hljs-keyword">new</span> RetryAndFollowUpInterceptor(client));
    <span class="hljs-comment">//转化用户请求为网络请求</span>
    interceptors.add(<span class="hljs-keyword">new</span> BridgeInterceptor(client.cookieJar()));
    <span class="hljs-comment">//负责读取缓存以及更新缓存</span>
    interceptors.add(<span class="hljs-keyword">new</span> CacheInterceptor(client.internalCache()));
    <span class="hljs-comment">//与服务器建立连接</span>
    interceptors.add(<span class="hljs-keyword">new</span> ConnectInterceptor(client));
    <span class="hljs-keyword">if</span> (!forWebSocket) &#123;
       <span class="hljs-comment">//用户自定义的网络拦截器</span>
      interceptors.addAll(client.networkInterceptors());
    &#125;
    <span class="hljs-comment">//从服务器读取响应的数据</span>
    interceptors.add(<span class="hljs-keyword">new</span> CallServerInterceptor(forWebSocket));

    Interceptor.Chain chain = <span class="hljs-keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>,
        originalRequest, <span class="hljs-keyword">this</span>, client.connectTimeoutMillis(),
        client.readTimeoutMillis(), client.writeTimeoutMillis());

    <span class="hljs-keyword">boolean</span> calledNoMoreExchanges = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-comment">//链式调用拦截器，最终返回 Response</span>
      Response response = chain.proceed(originalRequest);
      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;
        closeQuietly(response);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);
      &#125;
      <span class="hljs-keyword">return</span> response;
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
      calledNoMoreExchanges = <span class="hljs-keyword">true</span>;
      <span class="hljs-keyword">throw</span> transmitter.noMoreExchanges(e);
    &#125; <span class="hljs-keyword">finally</span> &#123;
      <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;
        transmitter.noMoreExchanges(<span class="hljs-keyword">null</span>);
      &#125;
    &#125;
  &#125;</code></pre>
<p>在获得响应结果之前，需要对用户设置的原始请求转换为实际的网络请求，然后通过一系列拦截器，直到最终得到结果，采用<strong>链式调用</strong>保证这些拦截器的执行顺序。</p>
<h4 id="OkHttp拦截器"><a href="#OkHttp拦截器" class="headerlink" title="OkHttp拦截器"></a>OkHttp拦截器</h4><blockquote>
<p>所有的拦截器都实现了<code>Interceptor</code>接口，支持用户去自定义拦截器，只要实现<code>Interceptor</code>接口即可。</p>
<p>拦截器可以 用来<em>监控、改写和重试HTTP访问</em>。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interceptor</span> </span>&#123;
  <span class="hljs-comment">//主要实现该接口，控制返回结果</span>
  <span class="hljs-function">Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException</span>;

  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Chain</span> </span>&#123;
    
    <span class="hljs-function">Request <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function">Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> IOException</span>;

    <span class="hljs-comment">//返回Request执行后的返回结果</span>
    <span class="hljs-meta">@Nullable</span> <span class="hljs-function">Connection <span class="hljs-title">connection</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function">Call <span class="hljs-title">call</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connectTimeoutMillis</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function">Chain <span class="hljs-title">withConnectTimeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout, TimeUnit unit)</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">readTimeoutMillis</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function">Chain <span class="hljs-title">withReadTimeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout, TimeUnit unit)</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">writeTimeoutMillis</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function">Chain <span class="hljs-title">withWriteTimeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout, TimeUnit unit)</span></span>;
  &#125;
&#125;</code></pre>
<h5 id="ApplicationInterceptor"><a href="#ApplicationInterceptor" class="headerlink" title="ApplicationInterceptor"></a><code>ApplicationInterceptor</code></h5><p><img src="/images/OkHttp-ApplicationInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-ApplicationInterceptor"></p>
<blockquote>
<p>该拦截器会被第一个执行，此处得到的<code>Request</code>为最原始状态。但是最终得到的<code>Response</code>是最终的结果。</p>
</blockquote>
<p>引用代码</p>
<pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient.Builder()
    .addInterceptor(<span class="hljs-keyword">new</span> LoggingInterceptor())
    .build();</code></pre>
<blockquote>
<p><code>ApplicationInterceptor</code>适用于在请求前统一添加一些公共参数，例如<code>App的版本号，系统信息</code>等。</p>
<p>也可用于对返回的<code>Response</code>进行加工。</p>
</blockquote>
<p><code>ApplicationInterceptor</code>有以下特定：</p>
<ul>
<li>不需要关心后续拦截器进行的操作，因为是会被第一个执行的，只要关心返回结果即可。</li>
<li>只会被响应一次，即使强制缓存获取</li>
<li>可以对后续的拦截器调用进行拦截或者进行多次调用——<strong>通过<code>Chain.proceed()</code>进行控制</strong></li>
</ul>
<h5 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a><code>RetryAndFollowUpInterceptor</code></h5><p><img src="/images/OkHttp-RetryAndFollowUpInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-RetryAndFollowUpInterceptor"></p>
<blockquote>
<p>负责失败重试和重定向的拦截器。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetryAndFollowUpInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-comment">//从自定义拦截器 那里传递下来的请求</span>
    Request request = chain.request();
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    <span class="hljs-comment">//获取事件监听器</span>
    Transmitter transmitter = realChain.transmitter();
    <span class="hljs-comment">//初始化 重定向次数</span>
    <span class="hljs-keyword">int</span> followUpCount = <span class="hljs-number">0</span>;
    Response priorResponse = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">//开启死循环 进行重试操作</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
      transmitter.prepareToConnect(request);
      <span class="hljs-comment">//请求取消</span>
      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);
      &#125;

      Response response;
      <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;
      <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">//向下调用 下一个拦截器——BridgeInterceptor</span>
        response = realChain.proceed(request, transmitter, <span class="hljs-keyword">null</span>);
        success = <span class="hljs-keyword">true</span>;
      &#125; <span class="hljs-keyword">catch</span> (RouteException e) &#123;
        <span class="hljs-comment">// 不需要重试 则抛出异常</span>
        <span class="hljs-keyword">if</span> (!recover(e.getLastConnectException(), transmitter, <span class="hljs-keyword">false</span>, request)) &#123;
          <span class="hljs-keyword">throw</span> e.getFirstConnectException();
        &#125;
        <span class="hljs-keyword">continue</span>;
      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
        <span class="hljs-comment">// 无法与服务端建立连接</span>
        <span class="hljs-keyword">boolean</span> requestSendStarted = !(e <span class="hljs-keyword">instanceof</span> ConnectionShutdownException);
        <span class="hljs-keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="hljs-keyword">throw</span> e;
        <span class="hljs-keyword">continue</span>;
      &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">// The network call threw an exception. Release any resources.</span>
        <span class="hljs-keyword">if</span> (!success) &#123;
          <span class="hljs-comment">//释放资源</span>
          transmitter.exchangeDoneDueToException();
        &#125;
      &#125;

      <span class="hljs-comment">// Attach the prior response if it exists. Such responses never have a body.</span>
      <span class="hljs-keyword">if</span> (priorResponse != <span class="hljs-keyword">null</span>) &#123;
        response = response.newBuilder()
            .priorResponse(priorResponse.newBuilder()
                    .body(<span class="hljs-keyword">null</span>)
                    .build())
            .build();
      &#125;

      Exchange exchange = Internal.instance.exchange(response);
      Route route = exchange != <span class="hljs-keyword">null</span> ? exchange.connection().route() : <span class="hljs-keyword">null</span>;
      <span class="hljs-comment">//根据返回的 response的Code 判断是否需要进行重定向</span>
      Request followUp = followUpRequest(response, route);

      <span class="hljs-keyword">if</span> (followUp == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">//释放资源</span>
        <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span> &amp;&amp; exchange.isDuplex()) &#123;
          transmitter.timeoutEarlyExit();
        &#125;
        <span class="hljs-keyword">return</span> response;
      &#125;

      RequestBody followUpBody = followUp.body();
      <span class="hljs-keyword">if</span> (followUpBody != <span class="hljs-keyword">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;
        <span class="hljs-keyword">return</span> response;
      &#125;

      closeQuietly(response.body());
      <span class="hljs-keyword">if</span> (transmitter.hasExchange()) &#123;
        exchange.detachWithViolence();
      &#125;

      <span class="hljs-comment">//超出重定向次数</span>
      <span class="hljs-keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(<span class="hljs-string">"Too many follow-up requests: "</span> + followUpCount);
      &#125;
      <span class="hljs-comment">//获取重定向结果 赋予 request继续向下请求</span>
      request = followUp;
      priorResponse = response;
    &#125;
  &#125;
    
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">recover</span><span class="hljs-params">(IOException e, Transmitter transmitter,
      <span class="hljs-keyword">boolean</span> requestSendStarted, Request userRequest)</span> </span>&#123;
    <span class="hljs-comment">// 未开启重试 retryOnConnectionFailure(false)</span>
    <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 只允许发送一次 isOneShot()&#123;return true;&#125;</span>
    <span class="hljs-keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 发生异常</span>
    <span class="hljs-keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 设置不允许重试</span>
    <span class="hljs-keyword">if</span> (!transmitter.canRetry()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  &#125;
&#125;</code></pre>
<blockquote>
<ol>
<li>尝试执行下一个拦截器，即<code>BridgeInterceptor</code></li>
<li>抛出异常，需要根据以下情况去判断是否需要重试：<ul>
<li>客户端是否开启  <code>retryOnConnectionFailure</code></li>
<li><code>RequestBody.isOneShot()</code>返回值</li>
<li>判断异常类型，除了<code>ConnectionShutdownException</code>被中断情况外的<code>IOException</code>的子类，都不会进行重试</li>
</ul>
</li>
<li>根据Response返回的响应码<code>code</code>进行处理</li>
</ol>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">followUpRequest</span><span class="hljs-params">(Response userResponse, @Nullable Route route)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">if</span> (userResponse == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();
    <span class="hljs-keyword">int</span> responseCode = userResponse.code();

    <span class="hljs-keyword">final</span> String method = userResponse.request().method();
    <span class="hljs-keyword">switch</span> (responseCode) &#123;
      <span class="hljs-comment">// 407 需要进行代理认证</span>
      <span class="hljs-keyword">case</span> HTTP_PROXY_AUTH:
        Proxy selectedProxy = route != <span class="hljs-keyword">null</span>
            ? route.proxy()
            : client.proxy();
        <span class="hljs-keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(<span class="hljs-string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>);
        &#125;
        <span class="hljs-keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);
      <span class="hljs-comment">// 401 未经认证</span>
      <span class="hljs-keyword">case</span> HTTP_UNAUTHORIZED:
        <span class="hljs-keyword">return</span> client.authenticator().authenticate(route, userResponse);
      <span class="hljs-comment">// 307 永久重定向  308 临时重定向  只有GET、HEAD请求方法才有效</span>
      <span class="hljs-keyword">case</span> HTTP_PERM_REDIRECT:
      <span class="hljs-keyword">case</span> HTTP_TEMP_REDIRECT:
        <span class="hljs-comment">// "If the 307 or 308 status code is received in response to a request other than GET</span>
        <span class="hljs-comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span>
        <span class="hljs-keyword">if</span> (!method.equals(<span class="hljs-string">"GET"</span>) &amp;&amp; !method.equals(<span class="hljs-string">"HEAD"</span>)) &#123;
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        <span class="hljs-comment">// fall-through</span>
      
      <span class="hljs-keyword">case</span> HTTP_MULT_CHOICE:<span class="hljs-comment">// 300  多个重定向地址</span>
      <span class="hljs-keyword">case</span> HTTP_MOVED_PERM:<span class="hljs-comment">// 301 永久移除 指向了新的位置</span>
      <span class="hljs-keyword">case</span> HTTP_MOVED_TEMP:<span class="hljs-comment">//302  临时移除</span>
      <span class="hljs-keyword">case</span> HTTP_SEE_OTHER:<span class="hljs-comment">//303 查看其他位置</span>
        <span class="hljs-comment">// 开发者是否允许重定向</span>
        <span class="hljs-keyword">if</span> (!client.followRedirects()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">//重定向后的实际地址</span>
        String location = userResponse.header(<span class="hljs-string">"Location"</span>);
        <span class="hljs-keyword">if</span> (location == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        HttpUrl url = userResponse.request().url().resolve(location);

        <span class="hljs-comment">// Don't follow redirects to unsupported protocols.</span>
        <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// If configured, don't follow redirects between SSL and non-SSL.</span>
        <span class="hljs-keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());
        <span class="hljs-keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// Most redirects don't include a request body.</span>
        Request.Builder requestBuilder = userResponse.request().newBuilder();
        <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;
          <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);
          <span class="hljs-keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;
            requestBuilder.method(<span class="hljs-string">"GET"</span>, <span class="hljs-keyword">null</span>);
          &#125; <span class="hljs-keyword">else</span> &#123;
            RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="hljs-keyword">null</span>;
            requestBuilder.method(method, requestBody);
          &#125;
          <span class="hljs-keyword">if</span> (!maintainBody) &#123;
            requestBuilder.removeHeader(<span class="hljs-string">"Transfer-Encoding"</span>);
            requestBuilder.removeHeader(<span class="hljs-string">"Content-Length"</span>);
            requestBuilder.removeHeader(<span class="hljs-string">"Content-Type"</span>);
          &#125;
        &#125;

        <span class="hljs-comment">// When redirecting across hosts, drop all authentication headers. This</span>
        <span class="hljs-comment">// is potentially annoying to the application layer since they have no</span>
        <span class="hljs-comment">// way to retain them.</span>
        <span class="hljs-keyword">if</span> (!sameConnection(userResponse.request().url(), url)) &#123;
          requestBuilder.removeHeader(<span class="hljs-string">"Authorization"</span>);
        &#125;

        <span class="hljs-keyword">return</span> requestBuilder.url(url).build();
      <span class="hljs-comment">//408 超时</span>
      <span class="hljs-keyword">case</span> HTTP_CLIENT_TIMEOUT:
        <span class="hljs-comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span>
        <span class="hljs-comment">// spec says that we may repeat the request without modifications. Modern browsers also</span>
        <span class="hljs-comment">// repeat the request (even non-idempotent ones.)</span>
        <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure()) &#123;
          <span class="hljs-comment">// The application layer has directed us not to retry the request.</span>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;

        RequestBody requestBody = userResponse.request().body();
        <span class="hljs-keyword">if</span> (requestBody != <span class="hljs-keyword">null</span> &amp;&amp; requestBody.isOneShot()) &#123;
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-keyword">if</span> (userResponse.priorResponse() != <span class="hljs-keyword">null</span>
            &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;
          <span class="hljs-comment">// We attempted to retry and got another timeout. Give up.</span>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-keyword">if</span> (retryAfter(userResponse, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) &#123;
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-keyword">return</span> userResponse.request();
      <span class="hljs-comment">//503 服务端不可用</span>
      <span class="hljs-keyword">case</span> HTTP_UNAVAILABLE:
        <span class="hljs-keyword">if</span> (userResponse.priorResponse() != <span class="hljs-keyword">null</span>
            &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;
          <span class="hljs-comment">// We attempted to retry and got another timeout. Give up.</span>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="hljs-number">0</span>) &#123;
          <span class="hljs-comment">// specifically received an instruction to retry without delay</span>
          <span class="hljs-keyword">return</span> userResponse.request();
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
  &#125;</code></pre>
<p>通过<code>followUpRequest()</code>对<code>Response</code>返回的<code>code</code>进行对应操作，在触发到重定向相关的code<code>3XX</code>时，需要对应的转换<code>Request</code>使用获取到的重定向后地址进行请求。</p>
<blockquote>
<p>由源码可知，可以重试的最大次数为<strong>20</strong>次，可以通过<code>retryOnConnectionFailure(true)</code>设置支持重试。但是不支持自定义重试次数，若需要自定义重试次数，需要自定义拦截器去实现。</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetryInterceptor</span></span>(<span class="hljs-keyword">var</span> maxRetry: <span class="hljs-built_in">Int</span><span class="hljs-comment">/*最大重试次数*/</span>) : Interceptor &#123;
        <span class="hljs-comment">//当前重试次数</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> retryNum = <span class="hljs-number">0</span>

        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercept</span><span class="hljs-params">(chain: <span class="hljs-type">Interceptor</span>.<span class="hljs-type">Chain</span>)</span></span>: Response &#123;
            <span class="hljs-keyword">val</span> request = chain.request()
            <span class="hljs-keyword">var</span> response = chain.proceed(request)

            <span class="hljs-keyword">while</span> (!response.isSuccessful &amp;&amp; retryNum &lt; maxRetry) &#123;
                retryNum++
                response = chain.proceed(request)
            &#125;
            <span class="hljs-keyword">return</span> response
        &#125;
    &#125;</code></pre>
<h5 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a><code>BridgeInterceptor</code></h5><p><img src="/images/OkHttp-BridgeInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-BridgeInterceptor"></p>
<blockquote>
<p>用以将用户的请求转换为向服务器的请求，之后再把服务器返回的数据转换成用户直观的数据。<strong>主要是对Header进行处理</strong></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BridgeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    Request userRequest = chain.request();
    Request.Builder requestBuilder = userRequest.newBuilder();
    <span class="hljs-comment">//重构用户请求 为 服务器请求格式</span>
    RequestBody body = userRequest.body();
    <span class="hljs-comment">//如果存在Body</span>
    <span class="hljs-keyword">if</span> (body != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">//对Header进行调整</span>
      MediaType contentType = body.contentType();
      <span class="hljs-keyword">if</span> (contentType != <span class="hljs-keyword">null</span>) &#123;
        requestBuilder.header(<span class="hljs-string">"Content-Type"</span>, contentType.toString());
      &#125;

      <span class="hljs-keyword">long</span> contentLength = body.contentLength();
      <span class="hljs-keyword">if</span> (contentLength != -<span class="hljs-number">1</span>) &#123;
        requestBuilder.header(<span class="hljs-string">"Content-Length"</span>, Long.toString(contentLength));
        requestBuilder.removeHeader(<span class="hljs-string">"Transfer-Encoding"</span>);
      &#125; <span class="hljs-keyword">else</span> &#123;
        requestBuilder.header(<span class="hljs-string">"Transfer-Encoding"</span>, <span class="hljs-string">"chunked"</span>);
        requestBuilder.removeHeader(<span class="hljs-string">"Content-Length"</span>);
      &#125;
    &#125;
    <span class="hljs-comment">//设置Header中的 host</span>
    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Host"</span>) == <span class="hljs-keyword">null</span>) &#123;
      requestBuilder.header(<span class="hljs-string">"Host"</span>, hostHeader(userRequest.url(), <span class="hljs-keyword">false</span>));
    &#125;

    <span class="hljs-comment">//设置 connection : Keep-Alive 保持长连接模式</span>
    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Connection"</span>) == <span class="hljs-keyword">null</span>) &#123;
      requestBuilder.header(<span class="hljs-string">"Connection"</span>, <span class="hljs-string">"Keep-Alive"</span>);
    &#125;

    <span class="hljs-comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span>
    <span class="hljs-comment">// the transfer stream.</span>
    <span class="hljs-keyword">boolean</span> transparentGzip = <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">//默认使用Gzip压缩</span>
    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Accept-Encoding"</span>) == <span class="hljs-keyword">null</span> &amp;&amp; userRequest.header(<span class="hljs-string">"Range"</span>) == <span class="hljs-keyword">null</span>) &#123;
      transparentGzip = <span class="hljs-keyword">true</span>;
      requestBuilder.header(<span class="hljs-string">"Accept-Encoding"</span>, <span class="hljs-string">"gzip"</span>);
    &#125;
    <span class="hljs-comment">//设置 Cookie信息</span>
    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());
    <span class="hljs-keyword">if</span> (!cookies.isEmpty()) &#123;
      requestBuilder.header(<span class="hljs-string">"Cookie"</span>, cookieHeader(cookies));
    &#125;
    <span class="hljs-comment">//设置UA</span>
    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"User-Agent"</span>) == <span class="hljs-keyword">null</span>) &#123;
      requestBuilder.header(<span class="hljs-string">"User-Agent"</span>, Version.userAgent());
    &#125;
    <span class="hljs-comment">//传递至下一个拦截器处理</span>
    Response networkResponse = chain.proceed(requestBuilder.build());

    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());

    Response.Builder responseBuilder = networkResponse.newBuilder()
        .request(userRequest);
    <span class="hljs-comment">//如果服务器支持Gzip压缩，需要进行解压操作</span>
    <span class="hljs-keyword">if</span> (transparentGzip
        &amp;&amp; <span class="hljs-string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="hljs-string">"Content-Encoding"</span>))
        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;
      GzipSource responseBody = <span class="hljs-keyword">new</span> GzipSource(networkResponse.body().source());
      Headers strippedHeaders = networkResponse.headers().newBuilder()
          .removeAll(<span class="hljs-string">"Content-Encoding"</span>)
          .removeAll(<span class="hljs-string">"Content-Length"</span>)
          .build();
      responseBuilder.headers(strippedHeaders);
      String contentType = networkResponse.header(<span class="hljs-string">"Content-Type"</span>);
      responseBuilder.body(<span class="hljs-keyword">new</span> RealResponseBody(contentType, -<span class="hljs-number">1L</span>, Okio.buffer(responseBody)));
    &#125;

    <span class="hljs-keyword">return</span> responseBuilder.build();
  &#125;
&#125;</code></pre>
<blockquote>
<p><code>GZip</code>：是一种压缩技术，可以改进Web应用的性能，将请求体明显的减少其大小，如果服务器也支持该格式，就会返回对应格式的内容，客户端需要进行解压操作，可以明显的减少流量消耗。</p>
</blockquote>
<p><code>BridgeInterceptor</code>主要执行了以下3步：</p>
<ul>
<li><p>用户请求转换为网络请求</p>
<p>在原来<code>Request</code>上添加了很多<code>Header</code>，例如<code>Content-Type(定义网络文件的类型和网页的编码)、Content-Length(请求体内容长度)、Transfer-Encoding(请求体的大小)与Content-Length互斥、Accept-Encoding(编码格式)</code>。</p>
<p>未设置<code>Accept-Encoding</code>默认为<code>gzip</code>。</p>
</li>
<li><p>执行转换后的网络请求</p>
<p><code>chain.proceed(requestBuilder.build())</code></p>
</li>
<li><p>服务器返回的响应结果转换为用户响应结果</p>
<p>根据上一步获得<code>Response</code>后，需要再次转化为用户直观格式。主要在于服务端返回的信息里是否设置了<code>Accept-Encoding:gzip</code>，设置了则需要进行解压过程，获取最终结果。</p>
</li>
</ul>
<h5 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a><code>CacheInterceptor</code></h5><p><img src="/images/OkHttp-CacheInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-CacheInterceptor"></p>
<blockquote>
<p>主要用于<strong>读取缓存以及更新缓存的</strong>，<strong>为了节省流量和提高响应速度</strong>。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-comment">//根据请求的相关信息获取缓存</span>
    Response cacheCandidate = cache != <span class="hljs-keyword">null</span>
        ? cache.get(chain.request())
        : <span class="hljs-keyword">null</span>;

    <span class="hljs-keyword">long</span> now = System.currentTimeMillis();
    <span class="hljs-comment">//创建缓存策略</span>
    CacheStrategy strategy = <span class="hljs-keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();①
    Request networkRequest = strategy.networkRequest;
    Response cacheResponse = strategy.cacheResponse;

    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;
      cache.trackResponse(strategy);
    &#125;
    <span class="hljs-comment">//缓存无法使用，关闭获得的Response</span>
    <span class="hljs-keyword">if</span> (cacheCandidate != <span class="hljs-keyword">null</span> &amp;&amp; cacheResponse == <span class="hljs-keyword">null</span>) &#123;
      closeQuietly(cacheCandidate.body()); <span class="hljs-comment">// The cache candidate wasn't applicable. Close it.</span>
    &#125;

    <span class="hljs-comment">// 根据策略，不使用网络且没有缓存的直接报错，返回504</span>
    <span class="hljs-keyword">if</span> (networkRequest == <span class="hljs-keyword">null</span> &amp;&amp; cacheResponse == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response.Builder()
          .request(chain.request())
          .protocol(Protocol.HTTP_1_1)
          .code(<span class="hljs-number">504</span>)
          .message(<span class="hljs-string">"Unsatisfiable Request (only-if-cached)"</span>)
          .body(Util.EMPTY_RESPONSE)
          .sentRequestAtMillis(-<span class="hljs-number">1L</span>)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build();
    &#125;

    <span class="hljs-comment">// 直接返回缓存，不允许使用网络</span>
    <span class="hljs-keyword">if</span> (networkRequest == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">return</span> cacheResponse.newBuilder()
          .cacheResponse(stripBody(cacheResponse))
          .build();
    &#125;

    Response networkResponse = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-comment">//请求向下传递</span>
      networkResponse = chain.proceed(networkRequest);
    &#125; <span class="hljs-keyword">finally</span> &#123;
      <span class="hljs-comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span>
      <span class="hljs-keyword">if</span> (networkResponse == <span class="hljs-keyword">null</span> &amp;&amp; cacheCandidate != <span class="hljs-keyword">null</span>) &#123;
        closeQuietly(cacheCandidate.body());
      &#125;
    &#125;

    <span class="hljs-comment">// 接受到服务器返回数据，如果返回code为 304 直接使用缓存结果</span>
    <span class="hljs-keyword">if</span> (cacheResponse != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;
        Response response = cacheResponse.newBuilder()
            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
            .cacheResponse(stripBody(cacheResponse))
            .networkResponse(stripBody(networkResponse))
            .build();
        networkResponse.body().close();

        <span class="hljs-comment">// Update the cache after combining headers but before stripping the</span>
        <span class="hljs-comment">// Content-Encoding header (as performed by initContentStream()).</span>
        cache.trackConditionalCacheHit();
        <span class="hljs-comment">//更新当前存储的缓存信息</span>
        cache.update(cacheResponse, response);
        <span class="hljs-keyword">return</span> response;
      &#125; <span class="hljs-keyword">else</span> &#123;
        closeQuietly(cacheResponse.body());
      &#125;
    &#125;
    <span class="hljs-comment">//读取服务器返回结果</span>
    Response response = networkResponse.newBuilder()
        .cacheResponse(stripBody(cacheResponse))
        .networkResponse(stripBody(networkResponse))
        .build();
    <span class="hljs-comment">//对数据进行缓存</span>
    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;
        <span class="hljs-comment">// Offer this request to the cache.</span>
        CacheRequest cacheRequest = cache.put(response);
        <span class="hljs-keyword">return</span> cacheWritingResponse(cacheRequest, response);
      &#125;

      <span class="hljs-keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;
        <span class="hljs-keyword">try</span> &#123;
          cache.remove(networkRequest);
        &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;
          <span class="hljs-comment">// The cache cannot be written.</span>
        &#125;
      &#125;
    &#125;

    <span class="hljs-keyword">return</span> response;
  &#125;
&#125;</code></pre>
<p><code>CacheInterceptor</code>的执行流程如下所示：</p>
<ol>
<li>先行读取缓存数据</li>
<li>创建好对应的缓存策略：<code>强制缓存</code>、<code>对比缓存</code></li>
<li>根据缓存策略，不使用网络、也没有对应缓存，返回<code>504</code></li>
<li>根据缓存策略，不使用网络，存在缓存则直接返回</li>
<li>前面都没有返回结果，继续向下执行请求：<code>chain.proceed()</code></li>
<li>接受到对应网络结果，如果返回code为<code>304</code>，代表直接使用缓存并更新对应缓存信息</li>
<li>读取网络结果，对数据进行缓存</li>
<li>返回获取的网络结果</li>
</ol>
<p>具体的缓存策略请参考<a href="#OkHttp缓存机制">缓存策略</a></p>
<h5 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a><code>ConnectInterceptor</code></h5><p><img src="/images/OkHttp-ConnectInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-ConnectInterceptor"></p>
<blockquote>
<p>真正与服务端建立连接，底层是通过<code>Socket</code>进行连接。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> OkHttpClient client;

  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    Request request = realChain.request();
    Transmitter transmitter = realChain.transmitter();

    <span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span>
    <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="hljs-string">"GET"</span>);
    <span class="hljs-comment">//建立连接</span>
    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);
    <span class="hljs-comment">//继续请求下一个拦截器</span>
    <span class="hljs-keyword">return</span> realChain.proceed(request, transmitter, exchange);
  &#125;
&#125;</code></pre>
<p><code>ConnectInterceptor</code>主要功能是建立与服务器的连接关系，通过<code>Transmitter.newExchange()</code>建立连接，建立完成后继续向下执行请求。</p>
<p>具体的连接过程可以参考<a href="# OkHttp连接机制">连接机制</a></p>
<h5 id="NetworkInterceptor"><a href="#NetworkInterceptor" class="headerlink" title="NetworkInterceptor"></a><code>NetworkInterceptor</code></h5><p><img src="/images/OkHttp-NetworkInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-NetworkInterceptor"></p>
<blockquote>
<p>用户自定义的网络拦截器，处于第6个拦截器，前面经过了<code>RetryAndFolowUpInterceptor</code>的重定向过程以及<code>BridgeInterceptor</code>的请求头处理，在此处可以获取到更多的连接信息。</p>
</blockquote>
<p>引用代码</p>
<pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient.Builder()
    .addNetworkInterceptor(<span class="hljs-keyword">new</span> LoggingInterceptor())
    .build();</code></pre>
<blockquote>
<p><code>NetworkInterceptor</code>可以获取到最终请求的<code>Request</code>，以及获取到真正进行过网络请求的得到的<code>Response</code>，从而可以针对<code>Response</code>进行修改然后再回传到上层拦截器。</p>
</blockquote>
<p><code>NetworkInterceptor</code>主要有以下特点：</p>
<ul>
<li>可以操作经过<code>重定向、重试</code>得到的<code>Response</code></li>
<li>无法响应缓存数据的请求，因为<code>CacheInterceptor</code>执行在它之前</li>
<li>得到最终进行请求的<code>Request</code></li>
<li>可以获得连接信息</li>
</ul>
<h5 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a><code>CallServerInterceptor</code></h5><p><img src="/images/OkHttp-CallServerInterceptor.png" srcset="/img/loading.gif" alt="OkHttp-CallServerInterceptor"></p>
<blockquote>
<p>数据的写入过程，也就是客户端和服务端进行交互的过程，客户端发送数据，服务端返回数据。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallServerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;
<span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    Exchange exchange = realChain.exchange();
    Request request = realChain.request();

    <span class="hljs-keyword">long</span> sentRequestMillis = System.currentTimeMillis();
    <span class="hljs-comment">//写入请求头</span>
    exchange.writeRequestHeaders(request);

    <span class="hljs-keyword">boolean</span> responseHeadersStarted = <span class="hljs-keyword">false</span>;
    Response.Builder responseBuilder = <span class="hljs-keyword">null</span>;
    <span class="hljs-comment">//判断当前是否有 请求体body</span>
    <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span>
      <span class="hljs-comment">// Continue" response before transmitting the request body. If we don't get that, return</span>
      <span class="hljs-comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span>
      <span class="hljs-comment">//如果是1XX的话 表示当前需要等服务端响应 </span>
      <span class="hljs-keyword">if</span> (<span class="hljs-string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="hljs-string">"Expect"</span>))) &#123;
        exchange.flushRequest();
        responseHeadersStarted = <span class="hljs-keyword">true</span>;
        exchange.responseHeadersStart();
        responseBuilder = exchange.readResponseHeaders(<span class="hljs-keyword">true</span>);
      &#125;

      
      <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">//写入请求体</span>
        <span class="hljs-keyword">if</span> (request.body().isDuplex()) &#123;
          <span class="hljs-comment">// Prepare a duplex body so that the application can send a request body later.</span>
          exchange.flushRequest();
          BufferedSink bufferedRequestBody = Okio.buffer(
              exchange.createRequestBody(request, <span class="hljs-keyword">true</span>));
          request.body().writeTo(bufferedRequestBody);
        &#125; <span class="hljs-keyword">else</span> &#123;
          <span class="hljs-comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span>
          BufferedSink bufferedRequestBody = Okio.buffer(
              exchange.createRequestBody(request, <span class="hljs-keyword">false</span>));
          request.body().writeTo(bufferedRequestBody);
          bufferedRequestBody.close();
        &#125;
      &#125; <span class="hljs-keyword">else</span> &#123;
        exchange.noRequestBody();
        <span class="hljs-keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;
          <span class="hljs-comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span>
          <span class="hljs-comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span>
          <span class="hljs-comment">// leave the connection in a consistent state.</span>
          exchange.noNewExchangesOnConnection();
        &#125;
      &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
      exchange.noRequestBody();
    &#125;

    <span class="hljs-keyword">if</span> (request.body() == <span class="hljs-keyword">null</span> || !request.body().isDuplex()) &#123;
        <span class="hljs-comment">//结束请求</span>
      exchange.finishRequest();
    &#125;

    <span class="hljs-keyword">if</span> (!responseHeadersStarted) &#123;
      exchange.responseHeadersStart();
    &#125;
    <span class="hljs-comment">//得到响应头</span>
    <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-keyword">null</span>) &#123;
      responseBuilder = exchange.readResponseHeaders(<span class="hljs-keyword">false</span>);
    &#125;
    
    Response response = responseBuilder
        .request(request)
        .handshake(exchange.connection().handshake())
        .sentRequestAtMillis(sentRequestMillis)
        .receivedResponseAtMillis(System.currentTimeMillis())
        .build();
    <span class="hljs-comment">//读取响应体内容</span>
    <span class="hljs-keyword">int</span> code = response.code();
    <span class="hljs-keyword">if</span> (code == <span class="hljs-number">100</span>) &#123;
      <span class="hljs-comment">// server sent a 100-continue even though we did not request one.</span>
      <span class="hljs-comment">// try again to read the actual response</span>
      response = exchange.readResponseHeaders(<span class="hljs-keyword">false</span>)
          .request(request)
          .handshake(exchange.connection().handshake())
          .sentRequestAtMillis(sentRequestMillis)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build();

      code = response.code();
    &#125;

    exchange.responseHeadersEnd(response);
    <span class="hljs-comment">//forWebSocket 表示为socket连接方式</span>
    <span class="hljs-keyword">if</span> (forWebSocket &amp;&amp; code == <span class="hljs-number">101</span>) &#123;
      <span class="hljs-comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span>
      response = response.newBuilder()
          .body(Util.EMPTY_RESPONSE)
          .build();
    &#125; <span class="hljs-keyword">else</span> &#123;
      response = response.newBuilder()
          .body(exchange.openResponseBody(response))
          .build();
    &#125;
    <span class="hljs-comment">// close表示关闭连接</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="hljs-string">"Connection"</span>))
        || <span class="hljs-string">"close"</span>.equalsIgnoreCase(response.header(<span class="hljs-string">"Connection"</span>))) &#123;
      exchange.noNewExchangesOnConnection();
    &#125;

    <span class="hljs-keyword">if</span> ((code == <span class="hljs-number">204</span> || code == <span class="hljs-number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(
          <span class="hljs-string">"HTTP "</span> + code + <span class="hljs-string">" had non-zero Content-Length: "</span> + response.body().contentLength());
    &#125;

    <span class="hljs-keyword">return</span> response;
  &#125;
&#125;</code></pre>
<p><code>CallServerInterceptor</code>主要执行了以下过程：</p>
<ul>
<li>写入请求头</li>
<li>写入请求体(如果存在)</li>
<li>获取状态行及响应头</li>
<li>获取响应体</li>
</ul>
<p><code>CallServerInterceptor</code>已经是最后一个拦截器了，接下来就是向上回溯并返回自己获得的<code>Response</code>。</p>
<blockquote>
<p>HTTP报文结构：</p>
<p><strong>请求报文</strong>：</p>
<p>请求行：声明请求方法、主机域名及协议版本</p>
<p>请求头：声明客户端的部分报文信息</p>
<p>请求体：存放客户端发送给服务器的数据</p>
<p><strong>响应报文</strong></p>
<p>状态行：声明HTTP协议版本、状态码及描述</p>
<p>响应头：声明服务端的部分报文信息</p>
<p>响应体：服务端返回客户端的数据</p>
</blockquote>
<h4 id="责任链模式串联"><a href="#责任链模式串联" class="headerlink" title="责任链模式串联"></a>责任链模式串联</h4><p>介绍完上述的拦截器后，接下来就是分析如何将这些拦截器进行串联调用。</p>
<pre><code class="hljs java"><span class="hljs-function">Response <span class="hljs-title">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-comment">// Build a full stack of interceptors.</span>
    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    ...
    <span class="hljs-comment">//构建责任链</span>
    Interceptor.Chain chain = <span class="hljs-keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>,
        originalRequest, <span class="hljs-keyword">this</span>, client.connectTimeoutMillis(),
        client.readTimeoutMillis(), client.writeTimeoutMillis());

    <span class="hljs-keyword">boolean</span> calledNoMoreExchanges = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-comment">//开始从头链式调用拦截器</span>
      Response response = chain.proceed(originalRequest);
      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;
        closeQuietly(response);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);
      &#125;
      <span class="hljs-keyword">return</span> response;
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
      calledNoMoreExchanges = <span class="hljs-keyword">true</span>;
      <span class="hljs-keyword">throw</span> transmitter.noMoreExchanges(e);
    &#125; <span class="hljs-keyword">finally</span> &#123;
      <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;
        transmitter.noMoreExchanges(<span class="hljs-keyword">null</span>);
      &#125;
    &#125;
  &#125;</code></pre>
<p>实际执行链式调用的是<code>RealInterceptorChain</code>，由他负责责任链的执行</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealInterceptorChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span>.<span class="hljs-title">Chain</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">return</span> proceed(request, transmitter, exchange);
  &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span>
      <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">if</span> (index &gt;= interceptors.size()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();

    calls++;

    <span class="hljs-comment">// 存在已经在使用的流，直接进行复用</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.exchange != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"network interceptor "</span> + interceptors.get(index - <span class="hljs-number">1</span>)
          + <span class="hljs-string">" must retain the same host and port"</span>);
    &#125;

    <span class="hljs-comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.exchange != <span class="hljs-keyword">null</span> &amp;&amp; calls &gt; <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"network interceptor "</span> + interceptors.get(index - <span class="hljs-number">1</span>)
          + <span class="hljs-string">" must call proceed() exactly once"</span>);
    &#125;

    <span class="hljs-comment">// 调用该链中的下一个拦截器 实质为 用户自定义的拦截器，不存在则为 RetryAndFollowUpInterceptor</span>
    RealInterceptorChain next = <span class="hljs-keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,
        index + <span class="hljs-number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);
    Interceptor interceptor = interceptors.get(index);
    Response response = interceptor.intercept(next);

    <span class="hljs-comment">// Confirm that the next interceptor made its required call to chain.proceed().</span>
    <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span> &amp;&amp; index + <span class="hljs-number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="hljs-number">1</span>) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"network interceptor "</span> + interceptor
          + <span class="hljs-string">" must call proceed() exactly once"</span>);
    &#125;

    <span class="hljs-comment">// Confirm that the intercepted response isn't null.</span>
    <span class="hljs-keyword">if</span> (response == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"interceptor "</span> + interceptor + <span class="hljs-string">" returned null"</span>);
    &#125;

    <span class="hljs-keyword">if</span> (response.body() == <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(
          <span class="hljs-string">"interceptor "</span> + interceptor + <span class="hljs-string">" returned a response with no body"</span>);
    &#125;

    <span class="hljs-keyword">return</span> response;
  &#125;
&#125;</code></pre>
<p><code>RealIntercrptor</code>为链式调用的起点，调用<code>proceed()</code>之后，继续调用下一层的拦截器，直到得到最终的Response。</p>
<p>后续的拦截器也是按照这个规则向下执行，内部都会调用到<code>chain.proceed()</code>直到没有调用为止。</p>
<p><strong>Request是按照定义的<code>interceptor</code>顺序向下执行，然后Response是逆向向上处理的。</strong></p>
<h3 id="获取请求结果Response"><a href="#获取请求结果Response" class="headerlink" title="获取请求结果Response"></a>获取请求结果<code>Response</code></h3><blockquote>
<p><code>Response</code>：返回HTTP请求响应结果，包含了状态码，响应正文等</p>
</blockquote>
<p>在<code>CallServerInterceptor</code>得到最初格式的<code>Response</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//获得状态行及响应头  </span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> Response.<span class="hljs-function">Builder <span class="hljs-title">readResponseHeaders</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> expectContinue)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">try</span> &#123;
      Response.Builder result = codec.readResponseHeaders(expectContinue);
      <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
        Internal.instance.initExchange(result, <span class="hljs-keyword">this</span>);
      &#125;
      <span class="hljs-keyword">return</span> result;
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
      eventListener.responseFailed(call, e);
      trackFailure(e);
      <span class="hljs-keyword">throw</span> e;
    &#125;
  &#125;
<span class="hljs-comment">//获得响应正文</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseBody <span class="hljs-title">openResponseBody</span><span class="hljs-params">(Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">try</span> &#123;
      eventListener.responseBodyStart(call);
      String contentType = response.header(<span class="hljs-string">"Content-Type"</span>);
      <span class="hljs-keyword">long</span> contentLength = codec.reportedContentLength(response);
      Source rawSource = codec.openResponseBodySource(response);
      ResponseBodySource source = <span class="hljs-keyword">new</span> ResponseBodySource(rawSource, contentLength);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RealResponseBody(contentType, contentLength, Okio.buffer(source));
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
      eventListener.responseFailed(call, e);
      trackFailure(e);
      <span class="hljs-keyword">throw</span> e;
    &#125;
  &#125;</code></pre>
<p><img src="/images/OkHttp执行流程.png" srcset="/img/loading.gif" alt="OkHttp执行流程"></p>
<h2 id="OkHttp缓存机制"><a href="#OkHttp缓存机制" class="headerlink" title="OkHttp缓存机制"></a>OkHttp缓存机制</h2><h3 id="Http缓存"><a href="#Http缓存" class="headerlink" title="Http缓存"></a>Http缓存</h3><p><img src="/images/OkHttp-HTTP缓存机制.png" srcset="/img/loading.gif" alt="OkHttp-HTTP缓存机制"></p>
<blockquote>
<p>Http缓存是web性能优化的重要手段，缓存机制是依赖于<code>header</code>中的参数实现的，这些参数指定了缓存需要<em>从缓存中获取</em>还是<em>从服务端获取</em>。</p>
</blockquote>
<p>Http缓存有多种规则，根据是否需要重新向服务器发起请求来进行分类：</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><blockquote>
<p>当客户端第一次请求数据时，服务端在响应头会携带<strong>缓存规则信息</strong>，主要为两个字段：<strong>Expires</strong>、<strong>Cache-Control</strong></p>
<p>当再次请求数据时，如果符合缓存规则，则直接使用缓存数据，无需与服务端重新交互。</p>
</blockquote>
<p><img src="/images/强制缓存流程.png" srcset="/img/loading.gif" alt="强制缓存流程"></p>
<p>强制缓存在缓存未失效的情况下，可以直接使用缓存数据，接下来介绍<code>判断缓存数据是否失效</code>。<br>上文提到，强制缓存是根据两个Header字段进行判定的，这两个字段表示了<code>失效规则</code>。</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><del>Expires</del></h5><blockquote>
<p>服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。<br><em>这参数是HTTP1.0的东西了，现在主流的是HTTP1.1。</em><br>可能由于客户端时间没有与服务端时间同步而导致缓存命中的误差。</p>
</blockquote>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><blockquote>
<p>在HTTP1.1中替代<code>Expires</code>，功能与其一致。<br><code>Cache-Control</code>常见的取值有如下几种：</p>
<ul>
<li><code>private</code>：客户端可以进行缓存</li>
<li><code>public</code>：客户端以及代理服务器都可以进行缓存</li>
<li><code>max-age= XX</code>：缓存数据在 XX秒后失效</li>
<li><code>no-cache</code>：需要使用到<code>对比缓存</code></li>
<li><code>no-store</code>：所有内容都不进行缓存</li>
<li><code>s-maxage = XX</code>：限定缓存可以在代理服务器中存放多久</li>
</ul>
</blockquote>
<h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><blockquote>
<p>需要进行比较判断来确定是否使用缓存，当客户端第一次请求数据时，服务端会返回<strong>缓存标识</strong>以及数据给客户端，客户端对两者都要进行备份到缓存，当再次请求数据时，客户端会带上<strong>缓存标识</strong>发送给服务端，服务端对标识进行判断，返回code值。返回若为<strong>304</strong>，则继续使用缓存。</p>
</blockquote>
<p><img src="/images/对比缓存流程.png" srcset="/img/loading.gif" alt="对比缓存流程"></p>
<p>在<strong>缓存标识</strong>未失效时，可以继续使用缓存数据，每次都需要与服务端进行交互去验证<strong>缓存标识</strong>。<br>对比缓存也是依据两个Header字段进行判定的，这两个字段表示了<code>缓存标识</code>。</p>
<h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p><code>Last-Modified</code>：服务端返回给客户端，表示资源的最后修改时间。<br><code>If-Modified-Since</code>：客户端发给服务端，表示服务端上次返回的资源最后修改时间。<br>服务端接收到<code>If-Modified-Since</code>后，与被请求资源的最后修改时间进行比对。</p>
<ul>
<li>若大于，返回最新资源并返回code为200，客户端需要重新进行缓存</li>
<li>否则，说明资源无修改并返回code为304，客户端继续使用缓存数据</li>
</ul>
<h5 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h5><p><code>ETag</code>：服务端返回给客户端，表示当前资源在服务器的唯一标识。<br><code>If-None-Match</code>：客户端发送给服务端，表示服务端上次返回的资源唯一标识。<br>服务端接收到<code>If-None-Match</code>后，与被请求资源的唯一标识进行比对</p>
<ul>
<li>标识不同，表示资源被改动过，返回最新资源及设置code为200，客户端需要重新进行缓存</li>
<li>标识相同，表示资源未被改动，返回code为304，客户端继续使用缓存数据</li>
</ul>
<p>其中<code>ETag/If-None-Match</code>的优先级是高于<code>Last-Modified/If-Modified-Since</code>的</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<ul>
<li>强制缓存的优先级是高于对比缓存的</li>
<li>对于<code>强制缓存</code>，服务端会给予一个过期时间，在有效期内再次请求都只会使用缓存，不会请求服务端。</li>
<li>超过有效期就使用<code>对比缓存</code>策略，将服务端返回的<code>ETag/Last-Modified</code>发还给服务端进行验证，有效则继续使用缓存数据(<em>返回code为304</em>)，无效则重新获取并进行缓存(<em>返回code为200</em>)。</li>
</ul>
</blockquote>
<h3 id="缓存存储"><a href="#缓存存储" class="headerlink" title="缓存存储"></a>缓存存储</h3><p><img src="/images/OkHttp缓存实现.png" srcset="/img/loading.gif" alt="OkHttp缓存实现"></p>
<p>介绍完毕Http的缓存机制后，接下来就是看<code>OkHttp</code>中的源码实现<br><pre><code class="hljs java">CacheStrategy(Request networkRequest, Response cacheResponse) &#123;
  <span class="hljs-keyword">this</span>.networkRequest = networkRequest;
  <span class="hljs-keyword">this</span>.cacheResponse = cacheResponse;
&#125;</code></pre></p>
<p>缓存策略主要通过<code>CacheStrategy</code>类实现，关键参数为<code>networkRequest(网络请求)</code>、<code>cacheResponse(缓存的响应结果)</code>。<br><code>CacheStrategy</code>通过工厂模式进行构建的，最终通过调用<code>getCandidate()</code>来生成不同模式。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> CacheStrategy <span class="hljs-title">getCandidate</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-comment">// 没缓存直接进行重新请求</span>
      <span class="hljs-keyword">if</span> (cacheResponse == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);
      &#125;

      <span class="hljs-comment">// 如果是HTTPs且握手信息丢失进行重新请求</span>
      <span class="hljs-keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);
      &#125;
      <span class="hljs-comment">//判断缓存已经失效 重新进行请求</span>
      <span class="hljs-keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);
      &#125;
      <span class="hljs-comment">// </span>
      CacheControl requestCaching = request.cacheControl();
      <span class="hljs-keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);
      &#125;

      CacheControl responseCaching = cacheResponse.cacheControl();
      <span class="hljs-comment">//</span>
      <span class="hljs-keyword">long</span> ageMillis = cacheResponseAge();
      <span class="hljs-keyword">long</span> freshMillis = computeFreshnessLifetime();

      <span class="hljs-keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="hljs-number">1</span>) &#123;
        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
      &#125;

      <span class="hljs-keyword">long</span> minFreshMillis = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="hljs-number">1</span>) &#123;
        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
      &#125;

      <span class="hljs-keyword">long</span> maxStaleMillis = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="hljs-number">1</span>) &#123;
        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
      &#125;
      <span class="hljs-comment">//处于强制缓存状态，直接返回缓存数据</span>
      <span class="hljs-keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;
        Response.Builder builder = cacheResponse.newBuilder();
        <span class="hljs-keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;
          builder.addHeader(<span class="hljs-string">"Warning"</span>, <span class="hljs-string">"110 HttpURLConnection \"Response is stale\""</span>);
        &#125;
        <span class="hljs-keyword">long</span> oneDayMillis = <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000L</span>;
        <span class="hljs-keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;
          builder.addHeader(<span class="hljs-string">"Warning"</span>, <span class="hljs-string">"113 HttpURLConnection \"Heuristic expiration\""</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(<span class="hljs-keyword">null</span>, builder.build());
      &#125;

      <span class="hljs-comment">// Find a condition to add to the request. If the condition is satisfied, the response body</span>
      <span class="hljs-comment">// will not be transmitted.</span>
      String conditionName;
      String conditionValue;
      <span class="hljs-keyword">if</span> (etag != <span class="hljs-keyword">null</span>) &#123;
        conditionName = <span class="hljs-string">"If-None-Match"</span>;
        conditionValue = etag;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastModified != <span class="hljs-keyword">null</span>) &#123;
        conditionName = <span class="hljs-string">"If-Modified-Since"</span>;
        conditionValue = lastModifiedString;
      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (servedDate != <span class="hljs-keyword">null</span>) &#123;
        conditionName = <span class="hljs-string">"If-Modified-Since"</span>;
        conditionValue = servedDateString;
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// No condition! Make a regular request.</span>
      &#125;
      <span class="hljs-comment">//交由服务端去进行判断</span>
      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);

      Request conditionalRequest = request.newBuilder()
          .headers(conditionalRequestHeaders.build())
          .build();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);
    &#125;</code></pre>
<p><code>CacheStrategy</code>根据之前的缓存结果以及要发送的<code>request的header</code>计算缓存策略</p>
<table>
<thead>
<tr>
<th>networkRequest</th>
<th>cacheResponse</th>
<th>CacheStrategy</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td>null</td>
<td>不进行网络请求且缓存不存在或过期<br>返回504错误</td>
</tr>
<tr>
<td>null</td>
<td>not null</td>
<td>不进行网络请求但是存在缓存且有效<br>直接返回缓存数据</td>
</tr>
<tr>
<td>not null</td>
<td>null</td>
<td>进行网络请求且缓存不存在或过期<br>直接进行网络请求获取数据</td>
</tr>
<tr>
<td>not null</td>
<td>not null</td>
<td>进行网络请求，请求头包含<code>ETag/Last-Modified</code>且缓存存在<br>根据网络请求结果判断<br>返回304，使用缓存<br>返回200，使用请求数据且更新缓存</td>
</tr>
</tbody>
</table>
<h2 id="OkHttp连接机制"><a href="#OkHttp连接机制" class="headerlink" title="OkHttp连接机制"></a>OkHttp连接机制</h2><p>在<code>ConnectInterceptor</code>中进行了与服务端的连接，通过<code>Exchange</code>类进行连接。<br><pre><code class="hljs java"><span class="hljs-function">Exchange <span class="hljs-title">newExchange</span><span class="hljs-params">(Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;
  <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
    <span class="hljs-keyword">if</span> (noMoreExchanges) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"released"</span>);
    <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"exchange != null"</span>);
  &#125;
  <span class="hljs-comment">//建立连接</span>
  ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);
  Exchange result = <span class="hljs-keyword">new</span> Exchange(<span class="hljs-keyword">this</span>, call, eventListener, exchangeFinder, codec);

  <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
    <span class="hljs-keyword">this</span>.exchange = result;
    <span class="hljs-keyword">this</span>.exchangeRequestDone = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">this</span>.exchangeResponseDone = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">return</span> result;
  &#125;
&#125;</code></pre></p>
<h3 id="通过Socket连接服务端"><a href="#通过Socket连接服务端" class="headerlink" title="通过Socket连接服务端"></a>通过Socket连接服务端</h3><p>通过<code>ExchangeCodec.find()</code>来设置连接或者复用<br><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ExchangeCodec <span class="hljs-title">find</span><span class="hljs-params">(
      OkHttpClient client, Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;
    <span class="hljs-keyword">int</span> connectTimeout = chain.connectTimeoutMillis();
    <span class="hljs-keyword">int</span> readTimeout = chain.readTimeoutMillis();
    <span class="hljs-keyword">int</span> writeTimeout = chain.writeTimeoutMillis();
    <span class="hljs-keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();
    <span class="hljs-keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();

    <span class="hljs-keyword">try</span> &#123;
      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
      <span class="hljs-keyword">return</span> resultConnection.newCodec(client, chain);
    &#125; <span class="hljs-keyword">catch</span> (RouteException e) &#123;
      trackFailure();
      <span class="hljs-keyword">throw</span> e;
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
      trackFailure();
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RouteException(e);
    &#125;
  &#125;
  <span class="hljs-comment">//返回一个健康的连接 </span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findHealthyConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout,
      <span class="hljs-keyword">int</span> writeTimeout, <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled,
      <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
          pingIntervalMillis, connectionRetryEnabled);

      <span class="hljs-comment">// If this is a brand new connection, we can skip the extensive health checks.</span>
      <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
        <span class="hljs-keyword">if</span> (candidate.successCount == <span class="hljs-number">0</span>) &#123;
          <span class="hljs-keyword">return</span> candidate;
        &#125;
      &#125;

      <span class="hljs-comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span>
      <span class="hljs-comment">// isn't, take it out of the pool and start again.</span>
      <span class="hljs-keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;
        candidate.noNewExchanges();
        <span class="hljs-keyword">continue</span>;
      &#125;

      <span class="hljs-keyword">return</span> candidate;
    &#125;
  &#125;
  
  <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout, <span class="hljs-keyword">int</span> writeTimeout,
      <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">boolean</span> foundPooledConnection = <span class="hljs-keyword">false</span>;
    RealConnection result = <span class="hljs-keyword">null</span>;
    Route selectedRoute = <span class="hljs-keyword">null</span>;
    RealConnection releasedConnection;
    Socket toClose;
    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);
      hasStreamFailure = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// This is a fresh attempt.</span>
      
      Route previousRoute = retryCurrentRoute()
          ? transmitter.connection.route()
          : <span class="hljs-keyword">null</span>;

      <span class="hljs-comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span>
      <span class="hljs-comment">// already-allocated connection may have been restricted from creating new exchanges.</span>
      releasedConnection = transmitter.connection;
      toClose = transmitter.connection != <span class="hljs-keyword">null</span> &amp;&amp; transmitter.connection.noNewExchanges
          ? transmitter.releaseConnectionNoEvents()
          : <span class="hljs-keyword">null</span>;

      <span class="hljs-keyword">if</span> (transmitter.connection != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// We had an already-allocated connection and it's good.</span>
        result = transmitter.connection;
        releasedConnection = <span class="hljs-keyword">null</span>;
      &#125;

      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// Attempt to get a connection from the pool.</span>
        <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>)) &#123;
          foundPooledConnection = <span class="hljs-keyword">true</span>;
          result = transmitter.connection;
        &#125; <span class="hljs-keyword">else</span> &#123;
          selectedRoute = previousRoute;
        &#125;
      &#125;
    &#125;
    closeQuietly(toClose);

    <span class="hljs-keyword">if</span> (releasedConnection != <span class="hljs-keyword">null</span>) &#123;
      eventListener.connectionReleased(call, releasedConnection);
    &#125;
    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;
      eventListener.connectionAcquired(call, result);
    &#125;
    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// If we found an already-allocated or pooled connection, we're done.</span>
      <span class="hljs-keyword">return</span> result;
    &#125;

    <span class="hljs-comment">// If we need a route selection, make one. This is a blocking operation.</span>
    <span class="hljs-keyword">boolean</span> newRouteSelection = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span> &amp;&amp; (routeSelection == <span class="hljs-keyword">null</span> || !routeSelection.hasNext())) &#123;
      newRouteSelection = <span class="hljs-keyword">true</span>;
      routeSelection = routeSelector.next();
    &#125;

    List&lt;Route&gt; routes = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);

      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;
        <span class="hljs-comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span>
        <span class="hljs-comment">// the pool. This could match due to connection coalescing.</span>
        routes = routeSelection.getAll();
        <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(
            address, transmitter, routes, <span class="hljs-keyword">false</span>)) &#123;
          foundPooledConnection = <span class="hljs-keyword">true</span>;
          result = transmitter.connection;
        &#125;
      &#125;
      <span class="hljs-comment">//没有从连接池中获取到连接需要重新建立</span>
      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;
        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span>) &#123;
          selectedRoute = routeSelection.next();
        &#125;

        <span class="hljs-comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span>
        <span class="hljs-comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span>
        result = <span class="hljs-keyword">new</span> RealConnection(connectionPool, selectedRoute);
        connectingConnection = result;
      &#125;
    &#125;

    <span class="hljs-comment">// If we found a pooled connection on the 2nd time around, we're done.</span>
    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;
      eventListener.connectionAcquired(call, result);
      <span class="hljs-keyword">return</span> result;
    &#125;

    <span class="hljs-comment">// Do TCP + TLS handshakes. This is a blocking operation.</span>
    <span class="hljs-comment">// 开始TCP三次握手以及TLS操作，为阻塞操作</span>
    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
        connectionRetryEnabled, call, eventListener);
    connectionPool.routeDatabase.connected(result.route());

    Socket socket = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
      connectingConnection = <span class="hljs-keyword">null</span>;
      <span class="hljs-comment">// Last attempt at connection coalescing, which only occurs if we attempted multiple</span>
      <span class="hljs-comment">// concurrent connections to the same host.</span>
      <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="hljs-keyword">true</span>)) &#123;
        <span class="hljs-comment">// We lost the race! Close the connection we created and return the pooled connection.</span>
        result.noNewExchanges = <span class="hljs-keyword">true</span>;
        socket = result.socket();
        result = transmitter.connection;
      &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">//加入连接池 等待复用</span>
        connectionPool.put(result);
        transmitter.acquireConnectionNoEvents(result);
      &#125;
    &#125;
    closeQuietly(socket);

    eventListener.connectionAcquired(call, result);
    <span class="hljs-keyword">return</span> result;
  &#125;</code></pre></p>
<p>最终通过<code>Socket.connect()</code>进行连接。</p>
<h3 id="连接池-ConnectionPool"><a href="#连接池-ConnectionPool" class="headerlink" title="连接池(ConnectionPool)"></a>连接池(ConnectionPool)</h3><p><img src="/images/OkHttp-连接池 ConnectionPool.png" srcset="/img/loading.gif" alt="OkHttp-连接池 ConnectionPool"></p>
<blockquote>
<p>频繁的进行Socket连接(三次握手)和Socket断开(四次挥手)非常消耗网络资源以及时间。在HTTP1.1之后提供了<code>keep-alive</code>这个header，可以实现长连接，有效的降低了延迟并提升了处理速度。<br>连接池就是为了<strong>复用已存在连接</strong>，可以有效降低创建连接的开销。</p>
</blockquote>
<h4 id="连接池构造方法以及成员变量"><a href="#连接池构造方法以及成员变量" class="headerlink" title="连接池构造方法以及成员变量"></a>连接池构造方法以及成员变量</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123;
  <span class="hljs-comment">//后台清理线程</span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span> <span class="hljs-comment">/* corePoolSize */</span>,
      Integer.MAX_VALUE <span class="hljs-comment">/* maximumPoolSize */</span>, <span class="hljs-number">60L</span> <span class="hljs-comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,
      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp ConnectionPool"</span>, <span class="hljs-keyword">true</span>)); 
    <span class="hljs-comment">//最大的空闲连接数</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxIdleConnections;
    <span class="hljs-comment">//连接最大持续时间</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> keepAliveDurationNs;
    <span class="hljs-comment">//存储连接的双向队列</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">this</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, TimeUnit.MINUTES);
    &#125;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxIdleConnections, <span class="hljs-keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.maxIdleConnections = maxIdleConnections;
    <span class="hljs-keyword">this</span>.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);

    <span class="hljs-comment">// Put a floor on the keep alive duration, otherwise cleanup will spin loop.</span>
    <span class="hljs-keyword">if</span> (keepAliveDuration &lt;= <span class="hljs-number">0</span>) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"keepAliveDuration &lt;= 0: "</span> + keepAliveDuration);
    &#125;
  &#125;
&#125;</code></pre>
<p><code>ConnectionPool</code>支持配置以下变量</p>
<ul>
<li><code>maxIdleConnections</code>：最大空闲连接数，默认<code>5</code></li>
<li><code>keepAliveDurationNs</code>：最大连接保持时间，默认<code>5min</code></li>
</ul>
<p><code>Connection</code>连接池中的<code>Connection</code>任一超出以上配置，就需要执行清理。</p>
<p>可以通过以下方法配置连接池</p>
<pre><code class="hljs java">OkHttpClient.Builder builder = <span class="hljs-keyword">new</span> OkHttpClient.Builder()
        .connectionPool(<span class="hljs-keyword">new</span> ConnectionPool()); <span class="hljs-comment">//配置连接池</span></code></pre>
<h4 id="连接池加入连接"><a href="#连接池加入连接" class="headerlink" title="连接池加入连接"></a>连接池加入连接</h4><p><img src="/images/1345862-20200603214235374-1759578389.png" srcset="/img/loading.gif" alt="双端队列"></p>
<p>通过<code>connections</code>存储<code>Connection</code></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(RealConnection connection)</span> </span>&#123;
  <span class="hljs-keyword">assert</span> (Thread.holdsLock(<span class="hljs-keyword">this</span>));
  <span class="hljs-keyword">if</span> (!cleanupRunning) &#123;<span class="hljs-comment">//当前清理线程没有运行</span>
    cleanupRunning = <span class="hljs-keyword">true</span>;
    executor.execute(cleanupRunnable);<span class="hljs-comment">//开启清理过程</span>
  &#125;
  connections.add(connection);<span class="hljs-comment">//加入队列</span>
&#125;</code></pre>
<p>在外部执行<code>put()</code>时，连接加入连接池，并且开启清理线程去清理那些超出配置的连接。</p>
<p>外部执行<code>put()</code>路径如下</p>
<pre><code class="hljs java"><span class="hljs-comment">// ConnectInterceptor 连接拦截器，其中执行连接过程</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    Request request = realChain.request();
    StreamAllocation streamAllocation = realChain.streamAllocation();

    <span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span>
    <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="hljs-string">"GET"</span>);
    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);<span class="hljs-comment">//建立新连接</span>
    RealConnection connection = streamAllocation.connection();

    <span class="hljs-keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);
&#125;
  
<span class="hljs-comment">// StreamAllocation </span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> HttpCodec <span class="hljs-title">newStream</span><span class="hljs-params">(
      OkHttpClient client, Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;
       ...

    <span class="hljs-keyword">try</span> &#123;
      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);<span class="hljs-comment">//寻找可用的连接</span>
      HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="hljs-keyword">this</span>);

      <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
        codec = resultCodec;
        <span class="hljs-keyword">return</span> resultCodec;
      &#125;
    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RouteException(e);
    &#125;
  &#125; 
  
  <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findHealthyConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout,
      <span class="hljs-keyword">int</span> writeTimeout, <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled,
      <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
          pingIntervalMillis, connectionRetryEnabled);
      ...

      <span class="hljs-keyword">return</span> candidate;
    &#125;
  &#125;
  
   <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout, <span class="hljs-keyword">int</span> writeTimeout,
      <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    ...
     <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
      <span class="hljs-keyword">if</span> (released) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"released"</span>);
      <span class="hljs-keyword">if</span> (codec != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"codec != null"</span>);
      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);

      <span class="hljs-comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span>
      <span class="hljs-comment">// already-allocated connection may have been restricted from creating new streams.</span>
      releasedConnection = <span class="hljs-keyword">this</span>.connection;
      toClose = releaseIfNoNewStreams();
      ...
      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-comment">// Attempt to get a connection from the pool.</span>
        Internal.instance.get(connectionPool, address, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);<span class="hljs-comment">//根据address从连接池中获取对应连接</span>
        <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;
          foundPooledConnection = <span class="hljs-keyword">true</span>;
          result = connection;
        &#125; <span class="hljs-keyword">else</span> &#123;
          selectedRoute = route;
        &#125;
      &#125;
    &#125;
     ...
    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;
      <span class="hljs-comment">// If we found an already-allocated or pooled connection, we're done.</span>
      <span class="hljs-keyword">return</span> result;
    &#125;  
     
     ...
       
    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);

      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;
        <span class="hljs-comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span>
        <span class="hljs-comment">// the pool. This could match due to connection coalescing.</span>
        List&lt;Route&gt; routes = routeSelection.getAll();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = routes.size(); i &lt; size; i++) &#123;
          Route route = routes.get(i);
          Internal.instance.get(connectionPool, address, <span class="hljs-keyword">this</span>, route);
          <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;
            foundPooledConnection = <span class="hljs-keyword">true</span>;
            result = connection;
            <span class="hljs-keyword">this</span>.route = route;
            <span class="hljs-keyword">break</span>;
          &#125;
        &#125;
      &#125;

      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;
        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span>) &#123;
          selectedRoute = routeSelection.next();
        &#125;

        <span class="hljs-comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span>
        <span class="hljs-comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span>
        route = selectedRoute;
        refusedStreamCount = <span class="hljs-number">0</span>;
        result = <span class="hljs-keyword">new</span> RealConnection(connectionPool, selectedRoute);<span class="hljs-comment">//连接池未找到对应连接，建立新连接</span>
        acquire(result, <span class="hljs-keyword">false</span>);
      &#125;
    &#125;
     
     ...
    
    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;
      reportedAcquired = <span class="hljs-keyword">true</span>;

      <span class="hljs-comment">// Pool the connection.</span>
      Internal.instance.put(connectionPool, result);<span class="hljs-comment">//将新建的连接加入到连接池内</span>

      <span class="hljs-comment">// If another multiplexed connection to the same address was created concurrently, then</span>
      <span class="hljs-comment">// release this connection and acquire that one.</span>
      <span class="hljs-keyword">if</span> (result.isMultiplexed()) &#123;
        socket = Internal.instance.deduplicate(connectionPool, address, <span class="hljs-keyword">this</span>);
        result = connection;
      &#125;
    &#125;
     
   &#125;
  
  <span class="hljs-comment">//OkHttpClient</span>
  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Call</span>.<span class="hljs-title">Factory</span>, <span class="hljs-title">WebSocket</span>.<span class="hljs-title">Factory</span> </span>&#123;
    <span class="hljs-keyword">static</span> &#123;
      Internal.instance = <span class="hljs-keyword">new</span> Internal() &#123;
       ...
        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RealConnection <span class="hljs-title">get</span><span class="hljs-params">(ConnectionPool pool, Address address,
          StreamAllocation streamAllocation, Route route)</span> </span>&#123;
           <span class="hljs-keyword">return</span> pool.get(address, streamAllocation, route);<span class="hljs-comment">//从连接池获取连接</span>
        &#125; 
         
        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(ConnectionPool pool, RealConnection connection)</span> </span>&#123;
          pool.put(connection);<span class="hljs-comment">//向连接池添加连接</span>
        &#125;
       ...
      &#125;
  &#125;</code></pre>
<p>通过<code>ConnectInterceptor.intercept()</code>去建立连接，向下调用到<code>StreamAllocation.newStream()</code></p>
<p>在<code>newStream()</code>中继续执行到<code>findConnection()</code>，其中主要执行了两步</p>
<ol>
<li>从<code>ConnectionPool</code>寻找是否存有当前<code>address</code>对应的连接，调用<code>ConnectionPool.get(XXX)</code>，存在就返回对应连接。</li>
<li>不存在对应连接，执行<code>new RealConnection()</code>新建连接，并调用<code>ConnectionPool.put()</code>存储新连接</li>
</ol>
<p>对应的<code>get()、put()</code>都是通过<code>Internal.instance</code>调用的，其中<code>Internal</code>是一个抽象类，具体实现类对应的就是<code>OkHttpClient</code>。</p>
<h4 id="连接池清理连接"><a href="#连接池清理连接" class="headerlink" title="连接池清理连接"></a>连接池清理连接</h4><p>在使用<code>连接池</code>时，初始化了一个<code>Executor</code>线程池，这个主要就是为了在清理无效连接时去开启清理线程用的</p>
<pre><code class="hljs java">  <span class="hljs-comment">/**
   * Background threads are used to cleanup expired connections. There will be at most a single
   * thread running per connection pool. The thread pool executor permits the pool itself to be
   * garbage collected.
   * 清理过期的连接，且保证最多只能运行一个清理线程。
   */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span> <span class="hljs-comment">/* corePoolSize */</span>,
      Integer.MAX_VALUE <span class="hljs-comment">/* maximumPoolSize */</span>, <span class="hljs-number">60L</span> <span class="hljs-comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,
      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp ConnectionPool"</span>, <span class="hljs-keyword">true</span>));

<span class="hljs-comment">//清理过期连接任务</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable cleanupRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;
        <span class="hljs-keyword">long</span> waitNanos = cleanup(System.nanoTime());<span class="hljs-comment">//返回下次需要清理连接的时间</span>
        <span class="hljs-keyword">if</span> (waitNanos == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (waitNanos &gt; <span class="hljs-number">0</span>) &#123;
          <span class="hljs-keyword">long</span> waitMillis = waitNanos / <span class="hljs-number">1000000L</span>;
          waitNanos -= (waitMillis * <span class="hljs-number">1000000L</span>);
          <span class="hljs-keyword">synchronized</span> (ConnectionPool.<span class="hljs-keyword">this</span>) &#123;
            <span class="hljs-keyword">try</span> &#123;
              ConnectionPool.<span class="hljs-keyword">this</span>.wait(waitMillis, (<span class="hljs-keyword">int</span>) waitNanos);<span class="hljs-comment">//阻塞等待</span>
            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;
            &#125;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;;</code></pre>
<h5 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup()"></a>cleanup()</h5><p>内部主要执行的是<code>标记空闲连接</code>、<code>清理空闲连接</code>，<code>返回下次清理时间</code>这几步</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">cleanup</span><span class="hljs-params">(<span class="hljs-keyword">long</span> now)</span> </span>&#123;
  <span class="hljs-keyword">int</span> inUseConnectionCount = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> idleConnectionCount = <span class="hljs-number">0</span>;
  RealConnection longestIdleConnection = <span class="hljs-keyword">null</span>;
  <span class="hljs-keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;

  <span class="hljs-comment">// Find either a connection to evict, or the time that the next eviction is due.</span>
  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;
    <span class="hljs-keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;<span class="hljs-comment">//遍历连接储存队列</span>
      RealConnection connection = i.next();

      <span class="hljs-comment">// If the connection is in use, keep searching.</span>
      <span class="hljs-keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//标记正在使用的活跃连接</span>
        inUseConnectionCount++;
        <span class="hljs-keyword">continue</span>;
      &#125;

      idleConnectionCount++;<span class="hljs-comment">//非活跃标记为空闲连接</span>

      <span class="hljs-comment">// If the connection is ready to be evicted, we're done.</span>
      <span class="hljs-keyword">long</span> idleDurationNs = now - connection.idleAtNanos;
      <span class="hljs-keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;
        longestIdleDurationNs = idleDurationNs;
        longestIdleConnection = connection;<span class="hljs-comment">//得到最长空闲时间的连接</span>
      &#125;
    &#125;

    <span class="hljs-keyword">if</span> (longestIdleDurationNs &gt;= <span class="hljs-keyword">this</span>.keepAliveDurationNs
        || idleConnectionCount &gt; <span class="hljs-keyword">this</span>.maxIdleConnections) &#123;
      <span class="hljs-comment">// We've found a connection to evict. Remove it from the list, then close it below (outside</span>
      <span class="hljs-comment">// of the synchronized block).</span>
      <span class="hljs-comment">// 空闲连接超过`maxIdleConnections`个或者空闲时间超过`keepAliveDurationNs`，需要清理该连接</span>
      connections.remove(longestIdleConnection);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idleConnectionCount &gt; <span class="hljs-number">0</span>) &#123;
      <span class="hljs-comment">// A connection will be ready to evict soon.</span>
      <span class="hljs-comment">// 返回最大空闲连接的到期时间，等待到达时间后进行清理</span>
      <span class="hljs-keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inUseConnectionCount &gt; <span class="hljs-number">0</span>) &#123;
      <span class="hljs-comment">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span>
      <span class="hljs-comment">// 所有都是活跃连接，返回最大空闲连接时间，等待到达时间后清理</span>
      <span class="hljs-keyword">return</span> keepAliveDurationNs;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">// No connections, idle or in use.</span>
      <span class="hljs-comment">// 当前不存在连接，直接返回 -1，不进行清理任务</span>
      cleanupRunning = <span class="hljs-keyword">false</span>;
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    &#125;
  &#125;
<span class="hljs-comment">// 立即关闭过期连接</span>
  closeQuietly(longestIdleConnection.socket());

  <span class="hljs-comment">// Cleanup again immediately.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p><code>cleanup()</code>执行流程如下：</p>
<ul>
<li>遍历<code>ConnectionPool</code>的<code>connections</code>，通过<code>pruneAndGetAllocationCount()</code>判断<code>connection</code>是否空闲</li>
<li>遍历完毕后，找到最长时间的空闲连接(<code>longestIdleConnection</code>)</li>
<li>得到<code>longestIdleConnection</code>后，先是比较当前的<code>idleConnectionCount</code>是否大于<code>maxIdleConnections</code>或者<code>longestIdleDurarionNs</code>是否大于<code>keepAliveDurationNs</code>，两者满足其一，则清理掉<code>longestIdleConnection</code></li>
<li>不满足其上条件，继续判断<code>idleConnectionCount &gt; 0</code>，表示当前存在空闲连接，就返回距离最大空闲连接时间差<code>keepAliveDurationNs - longestIdleDurationNs</code>，等待到时清理</li>
<li>不满足其上条件，继续判断<code>inUseConnectionCount &gt; 0</code>，表示当前都是活跃连接，返回<code>keepAliveDurationNs</code>，等待达到时间清理</li>
<li>以上条件都不满足，表示当前没有连接，直接返回<code>-1</code></li>
<li>存在<code>longestIdleConnection</code>，即调用<code>longestIdleConnection.socket().close()</code>关闭连接即可</li>
</ul>
<h5 id="pruneAndGetAllocationCount-Connection"><a href="#pruneAndGetAllocationCount-Connection" class="headerlink" title="pruneAndGetAllocationCount(Connection)"></a>pruneAndGetAllocationCount(Connection)</h5><p>判断当前连接是否正在活跃，采用了<strong>引用计数法</strong></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pruneAndGetAllocationCount</span><span class="hljs-params">(RealConnection connection, <span class="hljs-keyword">long</span> now)</span> </span>&#123;
  <span class="hljs-comment">//连接弱引用列表</span>
  List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; references.size(); ) &#123;
    <span class="hljs-comment">//获取引用连接</span>
    Reference&lt;StreamAllocation&gt; reference = references.get(i);
    <span class="hljs-comment">//不为null ，表示当前连接尚未回收</span>
    <span class="hljs-keyword">if</span> (reference.get() != <span class="hljs-keyword">null</span>) &#123;
      i++;
      <span class="hljs-keyword">continue</span>;
    &#125;

    <span class="hljs-comment">// We've discovered a leaked allocation. This is an application bug.</span>
    StreamAllocation.StreamAllocationReference streamAllocRef =
        (StreamAllocation.StreamAllocationReference) reference;
    String message = <span class="hljs-string">"A connection to "</span> + connection.route().address().url()
        + <span class="hljs-string">" was leaked. Did you forget to close a response body?"</span>;
    Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);

    <span class="hljs-comment">//移除引用</span>
    references.remove(i);
    connection.noNewStreams = <span class="hljs-keyword">true</span>;

    <span class="hljs-comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span>
    <span class="hljs-comment">//所有引用都被移除，表示当前连接处于空闲</span>
    <span class="hljs-keyword">if</span> (references.isEmpty()) &#123;
      connection.idleAtNanos = now - keepAliveDurationNs;
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
  &#125;

  <span class="hljs-keyword">return</span> references.size();
&#125;</code></pre>
<p><code>StreamAllocation</code>引用是在<code>StreamAllocation.acquire()</code>时加入的</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(RealConnection connection, <span class="hljs-keyword">boolean</span> reportedAcquired)</span> </span>&#123;
  <span class="hljs-keyword">assert</span> (Thread.holdsLock(connectionPool));
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();

  <span class="hljs-keyword">this</span>.connection = connection;
  <span class="hljs-keyword">this</span>.reportedAcquired = reportedAcquired;
  connection.allocations.add(<span class="hljs-keyword">new</span> StreamAllocationReference(<span class="hljs-keyword">this</span>, callStackTrace));
&#125;</code></pre>
<p>通过这种<code>引用计数法</code>来判断当前是否为空闲连接</p>
<h2 id="OkHttp-DNS功能"><a href="#OkHttp-DNS功能" class="headerlink" title="OkHttp-DNS功能"></a>OkHttp-DNS功能</h2><h3 id="DNS介绍"><a href="#DNS介绍" class="headerlink" title="DNS介绍"></a>DNS介绍</h3><p><code>Domain Name System</code>：根据域名查出IP地址，是<code>HTTP协议</code>的前提，只有将域名正确的进行解析，得到IP地址后，才可以继续进行网络连接。</p>
<p>DNS服务器结构如下：</p>
<ul>
<li><code>根DNS服务器</code>：返回顶级DNS服务器的IP地址</li>
<li><code>顶级域DNS服务器</code>：返回权威DNS服务器的IP地址</li>
<li><code>权威DNS服务器</code>：返回对应主机的IP地址</li>
</ul>
<p><img src="/images/DNS服务器结构" srcset="/img/loading.gif" alt="img"></p>
<h4 id="LocalDNS"><a href="#LocalDNS" class="headerlink" title="LocalDNS"></a>LocalDNS</h4><p><img src="/images/OkHttp-LocalDNS.png" srcset="/img/loading.gif" alt="OkHttp-LocalDNS"></p>
<p><strong>运营商提供的DNS服务器</strong>，请求时优先查询<code>LocalDNS 缓存</code>，存在直接使用。不存在就需要从<code>根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威域名服务器</code>往上查询可用的<code>IP地址</code>。</p>
<p><img src="/images/DNS请求过程" srcset="/img/loading.gif" alt="img"></p>
<h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ol>
<li><p>不稳定</p>
<blockquote>
<p>DNS劫持或者服务器故障，导致解析服务不可用</p>
</blockquote>
</li>
<li><p>不准确</p>
<blockquote>
<p><code>LocalDNS调度</code>不一定是<strong>就近原则</strong>。某些运营商会把解析请求转发到其他运营商的<code>LocalDNS</code>服务器。</p>
<p>就会导致解析出的IP不是就近服务器，致使访问变慢甚至无法访问。</p>
</blockquote>
</li>
<li><p>不及时</p>
<blockquote>
<p>运营商可能修改DNS的<code>TTL(Time-To-Live，DNS缓存时间)</code>，导致DNS解析结构发生修改，但是在当前请求条件下尚未生效。</p>
</blockquote>
</li>
</ol>
<p><img src="/images/640-2236080." srcset="/img/loading.gif" alt="img"></p>
<h4 id="HttpDNS"><a href="#HttpDNS" class="headerlink" title="HttpDNS"></a>HttpDNS</h4><p><img src="/images/OkHttp-HTTPDNS.png" srcset="/img/loading.gif" alt="OkHttp-HTTPDNS"></p>
<p><code>HTTPDNS</code>利用<code>HTTP协议</code>与DNS服务交互，绕开了运营商<code>LocalDNS</code>服务，有效防止了域名劫持以及提高了域名解析成功率。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img src="/images/HTTPDNS原理.jpeg" srcset="/img/loading.gif" alt="img"></p>
<ol>
<li>客户端直接访问<code>HttpDNS</code>接口，获取域名在<code>HTTPDNS服务器</code>上的最优IP(从容灾方面考虑，还需要保留<code>LocalDNS</code>请求)</li>
<li>客户端获取到<code>IP</code>后，直接向该<code>IP</code>发起HTTP请求</li>
</ol>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ol>
<li>降低了<code>UnknownHostException</code>异常发生</li>
<li>调度精准，根据用户IP，精准获取域名对应IP</li>
<li>扩展性强，可以自定义域名对应IP规则</li>
</ol>
<h3 id="OkHttp-HttpDNS实现"><a href="#OkHttp-HttpDNS实现" class="headerlink" title="OkHttp-HttpDNS实现"></a>OkHttp-HttpDNS实现</h3><p>OkHttp提供了<code>Dns接口</code>，可以进行自定义拓展替代本身的<code>LocalDNS</code>解析方式</p>
<pre><code class="hljs kotlin"><span class="hljs-comment">//自定义DNS</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptimizeLocalDNS</span> : <span class="hljs-type">Dns&#123;</span></span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lookup</span><span class="hljs-params">(hostname: <span class="hljs-type">String</span>)</span></span>: List&lt;InetAddress&gt; &#123;
        <span class="hljs-keyword">return</span> DNSLookUpUtil.loadLocalDNS(hostname)
    &#125;
&#125;

<span class="hljs-comment">//设置LocalDNS超时取消</span>
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadLocalDNS</span><span class="hljs-params">(hostname: <span class="hljs-type">String</span>, timeout: <span class="hljs-type">Long</span> = <span class="hljs-number">10</span>L)</span></span>: List&lt;InetAddress&gt; &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">val</span> task = FutureTask&lt;List&lt;InetAddress&gt;&gt;(Callable&lt;List&lt;InetAddress&gt;&gt; &#123;
                    <span class="hljs-comment">//返回去重结果</span>
                    InetAddress.getAllByName(hostname).toList().distinct()
                &#125;)
                Thread(task).start()
                <span class="hljs-keyword">return</span> task.<span class="hljs-keyword">get</span>(timeout, TimeUnit.SECONDS)
            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;
            &#125;
            <span class="hljs-keyword">return</span> listOf()
        &#125;

<span class="hljs-comment">//设置自定义DNS</span>
mOkHttpClient = httpBuilder
        .dns(OptimizeLocalDNS())
        .build();</code></pre>
<h3 id="OkHttp-DNS原理"><a href="#OkHttp-DNS原理" class="headerlink" title="OkHttp-DNS原理"></a>OkHttp-DNS原理</h3><p>配置的<code>dns()</code>初始使用位于<code>RetryAndFollowUpInterceptor.intercept()</code>中</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetryAndFollowUpInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;
  ...
   <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    ...
        StreamAllocation streamAllocation = <span class="hljs-keyword">new</span> StreamAllocation(client.connectionPool(),
        createAddress(request.url()), call, eventListener, callStackTrace);
   &#125;
  
   <span class="hljs-function"><span class="hljs-keyword">private</span> Address <span class="hljs-title">createAddress</span><span class="hljs-params">(HttpUrl url)</span> </span>&#123;
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Address(url.host(), url.port(), client.dns(), client.socketFactory(),
        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
  &#125;
 
  ...
&#125;</code></pre>
<p>构造出一个<code>Address</code>对象，里面包含了<code>主机名(host)、端口(port)、DNS配置(DNS)、SSL配置(sslSocketFactory,certificatePinner)、代理设置</code></p>
<p>得到<code>Address</code>，通过<code>StreamAllocation</code>构造了<code>RouteSelector</code>对象</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StreamAllocation</span><span class="hljs-params">(ConnectionPool connectionPool, Address address, Call call,
    EventListener eventListener, Object callStackTrace)</span> </span>&#123;
  <span class="hljs-keyword">this</span>.connectionPool = connectionPool;
  <span class="hljs-keyword">this</span>.address = address;
  <span class="hljs-keyword">this</span>.call = call;
  <span class="hljs-keyword">this</span>.eventListener = eventListener;
  <span class="hljs-keyword">this</span>.routeSelector = <span class="hljs-keyword">new</span> RouteSelector(address, routeDatabase(), call, eventListener);
  <span class="hljs-keyword">this</span>.callStackTrace = callStackTrace;
&#125;</code></pre>
<p><code>RouteSelector</code>主要为了<strong>Select Route(选择路由)，返回一个可用的<code>Route</code>对象</strong>。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetNextInetSocketAddress</span><span class="hljs-params">(Proxy proxy)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-comment">// Clear the addresses. Necessary if getAllByName() below throws!</span>
    inetSocketAddresses = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

    String socketHost;
    <span class="hljs-keyword">int</span> socketPort;
    <span class="hljs-keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;<span class="hljs-comment">//存在代理</span>
      socketHost = address.url().host();
      socketPort = address.url().port();
    &#125; <span class="hljs-keyword">else</span> &#123;
      SocketAddress proxyAddress = proxy.address();
      <span class="hljs-keyword">if</span> (!(proxyAddress <span class="hljs-keyword">instanceof</span> InetSocketAddress)) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(
            <span class="hljs-string">"Proxy.address() is not an "</span> + <span class="hljs-string">"InetSocketAddress: "</span> + proxyAddress.getClass());
      &#125;
      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;
      socketHost = getHostString(proxySocketAddress);
      socketPort = proxySocketAddress.getPort();
    &#125;

    <span class="hljs-keyword">if</span> (socketPort &lt; <span class="hljs-number">1</span> || socketPort &gt; <span class="hljs-number">65535</span>) &#123;
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SocketException(<span class="hljs-string">"No route to "</span> + socketHost + <span class="hljs-string">":"</span> + socketPort
          + <span class="hljs-string">"; port is out of range"</span>);
    &#125;

    <span class="hljs-keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;<span class="hljs-comment">//解析的直接为代理地址</span>
      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">//dns开始解析监听</span>
      eventListener.dnsStart(call, socketHost);

      <span class="hljs-comment">// Try each address for best behavior in mixed IPv4/IPv6 environments.</span>
      List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);<span class="hljs-comment">//通过配置的DNS去解析对应域名的IP列表</span>
      <span class="hljs-keyword">if</span> (addresses.isEmpty()) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownHostException(address.dns() + <span class="hljs-string">" returned no addresses for "</span> + socketHost);
      &#125;
      <span class="hljs-comment">//dns解析结束监听</span>
      eventListener.dnsEnd(call, socketHost, addresses);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;
        InetAddress inetAddress = addresses.get(i);
        inetSocketAddresses.add(<span class="hljs-keyword">new</span> InetSocketAddress(inetAddress, socketPort));
      &#125;
    &#125;
  &#125;</code></pre>
<p><code>resetNextInetSocketAddress()</code>返回<code>List&lt;InetSocketAddress&gt;</code>，区分了一下两种情况</p>
<ul>
<li>设置了<code>proxies</code>代理服务器，直接返回<code>InetSocketAddress(socketHost,socketPort)</code>代理服务器对应的地址和端口</li>
<li>未设置代理服务器，通过设置的<code>dns</code>去解析对应域名(<code>dns.lookup(host)</code>)得到<code>List&lt;InetAddress&gt;</code>对应的IP列表，在返回对应地址</li>
</ul>
<h2 id="OkHttp-HTTP2-0协议支持"><a href="#OkHttp-HTTP2-0协议支持" class="headerlink" title="OkHttp-HTTP2.0协议支持"></a>OkHttp-HTTP2.0协议支持</h2><p><img src="/images/OkHttp-HTTP2.0.png" srcset="/img/loading.gif" alt="OkHttp-HTTP2.0"></p>
<blockquote>
<p>基于<code>二进制分帧</code>、<code>首部压缩</code>和<code>服务端推送</code>进行分析</p>
</blockquote>
<p>//TODO</p>
<h2 id="OkHttp拓展"><a href="#OkHttp拓展" class="headerlink" title="OkHttp拓展"></a>OkHttp拓展</h2><h3 id="请求时间获取"><a href="#请求时间获取" class="headerlink" title="请求时间获取"></a>请求时间获取</h3><p><code>EventListener</code>是OkHttp提供的监听回调，可以通过实现这个抽象类监听到网络请求各阶段的时间点</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventListener</span> </span>&#123;
   <span class="hljs-comment">//请求相关回调</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callStart</span><span class="hljs-params">(Call call)</span> </span>&#123;&#125; 
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callEnd</span><span class="hljs-params">(Call call)</span> </span>&#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callFailed</span><span class="hljs-params">(Call call, IOException ioe)</span> </span>&#123;&#125;  
  
   <span class="hljs-comment">//dns解析回调</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsStart</span><span class="hljs-params">(Call call, String domainName)</span> </span>&#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsEnd</span><span class="hljs-params">(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList)</span> </span>&#123;&#125;
  
   <span class="hljs-comment">//请求连接相关回调</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectStart</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy)</span></span>&#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectEnd</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,@Nullable Protocol protocol)</span> </span>&#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectFailed</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
      @Nullable Protocol protocol, IOException ioe)</span> </span>&#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectionAcquired</span><span class="hljs-params">(Call call, Connection connection)</span></span>&#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectionReleased</span><span class="hljs-params">(Call call, Connection connection)</span></span>&#123;&#125;
  
   ...
&#125;</code></pre>
<h4 id="DNS解析耗时"><a href="#DNS解析耗时" class="headerlink" title="DNS解析耗时"></a>DNS解析耗时</h4><p>只要监听<code>dnsStart()</code>和<code>dnsEnd()</code>之间的时间差即可</p>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> dnsStartTime;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> dnsDuration = -<span class="hljs-number">1L</span>;    

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsStart</span><span class="hljs-params">(Call call, String domainName)</span> </span>&#123;
    <span class="hljs-keyword">super</span>.dnsStart(call, domainName);
    recordEventLog(<span class="hljs-string">"dnsStart"</span>);
    dnsStartTime = System.nanoTime();
&#125;

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsEnd</span><span class="hljs-params">(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList)</span> </span>&#123;
    <span class="hljs-keyword">super</span>.dnsEnd(call, domainName, inetAddressList);
    recordEventLog(<span class="hljs-string">"dnsEnd"</span>);
    dnsDuration = (System.nanoTime() - dnsStartTime) / <span class="hljs-number">1000000</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDnsDuration</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> dnsDuration;
&#125;</code></pre>
<p><code>dnsDuration</code>即为DNS解析耗时</p>
<h4 id="请求连接耗时"><a href="#请求连接耗时" class="headerlink" title="请求连接耗时"></a>请求连接耗时</h4><p>初始连接耗时</p>
<blockquote>
<p>使用Socket建立TCP连接，初始连接表示的就是<code>Socket建立连接的过程</code></p>
</blockquote>
<p>只要监听<code>connectStart()</code>和<code>connectEnd()</code>之间的时间差。</p>
<p>复用连接耗时</p>
<blockquote>
<p>OkHttp设置<code>ConnectionPool</code>，可以复用已存在的连接</p>
</blockquote>
<p>需要监听<code>connectAcquired()</code>和<code>connectReleased()</code>之间的时间差</p>
<h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5a704ed05188255a8817f4c9" target="_blank" rel="noopener">开源框架源码鉴赏：OkHttp</a><br><a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">彻底弄懂HTTP缓存机制及原理</a></p>
<p><a href="https://mp.weixin.qq.com/s/iaPtSF-twWz-AN66UJUBDg" target="_blank" rel="noopener">百度App网络深度优化系列《一》DNS优化</a></p>
<p><a href="https://juejin.im/post/6844903785232498696#heading-4" target="_blank" rel="noopener">HTTP2.0相关</a></p>
<p><a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener">HPACK算法</a></p>
<p><a href="https://sq.163yun.com/blog/article/188769987293102080" target="_blank" rel="noopener">HTTP/2首部压缩的OkHttp3实现</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/源码解析/">源码解析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/03/12/WebView相关知识/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">WebView相关知识</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/03/08/Retrofit简析/">
                        <span class="hidden-mobile">Retrofit简析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
