

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <meta name="description" content="基于OkHttp 3.13版本进行分析   OkHttp定义OkHttp现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。 所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。 OkHttp支持SPDY协议，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。">
<meta name="keywords" content="源码解析">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp简析">
<meta property="og:url" content="https://leo-wxy.github.io/2019/03/08/OkHttp简析/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="基于OkHttp 3.13版本进行分析   OkHttp定义OkHttp现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。 所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。 OkHttp支持SPDY协议，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp简析mind.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-构造OkHttpClient对象.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-构造Request请求对象.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-发送Request请求.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-处理Request请求.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-ApplicationInterceptor.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-RetryAndFollowUpInterceptor.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-BridgeInterceptor.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-CacheInterceptor.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-ConnectInterceptor.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-NetworkInterceptor.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-CallServerInterceptor.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp执行流程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-HTTP缓存机制.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/强制缓存流程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/对比缓存流程.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp缓存实现.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-连接池%20ConnectionPool.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/1345862-20200603214235374-1759578389.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-Cookie机制.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/DNS服务器结构">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-LocalDNS.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/DNS请求过程">
<meta property="og:image" content="https://leo-wxy.github.io/images/640-2236080.">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-HTTPDNS.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/HTTPDNS原理.jpeg">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp-HTTP2.0.png">
<meta property="og:image" content="https://leo-wxy.github.io/images/OkHttp解析节点">
<meta property="og:updated_time" content="2021-01-21T03:21:19.000Z">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="OkHttp简析">
<meta name="twitter:description" content="基于OkHttp 3.13版本进行分析   OkHttp定义OkHttp现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。 所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。 OkHttp支持SPDY协议，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。">
<meta name="twitter:image" content="https://leo-wxy.github.io/images/OkHttp简析mind.png">
  
  <title>OkHttp简析 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.12","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="OkHttp简析">
              
                OkHttp简析
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-03-08 10:18" pubdate>
        2019年3月8日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      69k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      214 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">OkHttp简析</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>基于OkHttp 3.13版本进行分析</p>
</blockquote>
<p><img src="/images/OkHttp简析mind.png" srcset="/img/loading.gif" lazyload alt="OkHttp简析"></p>
<h2 id="OkHttp定义"><a href="#OkHttp定义" class="headerlink" title="OkHttp定义"></a>OkHttp定义</h2><p><code>OkHttp</code>现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。</p>
<p>所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。</p>
<p>OkHttp支持<code>SPDY协议</code>，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。</p>
<blockquote>
<p><code>SPDY协议</code>：Google提出的基于TCP的应用层协议，通过<code>压缩、多路复用、优先级</code>来缩短加载时间。</p>
</blockquote>
<h2 id="OkHttp使用示例"><a href="#OkHttp使用示例" class="headerlink" title="OkHttp使用示例"></a>OkHttp使用示例</h2><h3 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>     .url(url)<br>     .build();<br></code></pre></td></tr></table></figure>
<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">RequestBody body = RequestBody.create(JSON, json);<br>Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>    .url(url)<br>    .post(body)<br>    .build();<br></code></pre></td></tr></table></figure>
<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br>Response response = client.newCall(request).execute();<br><span class="hljs-keyword">return</span> response.body().string();<br></code></pre></td></tr></table></figure>
<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();<br><br>client.newCall(request).enqueue(<span class="hljs-keyword">new</span> Callback() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call call, IOException e)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call call, okhttp3.Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h2 id="OkHttp源码分析"><a href="#OkHttp源码分析" class="headerlink" title="OkHttp源码分析"></a>OkHttp源码分析</h2><h3 id="构造OkHttpClient对象"><a href="#构造OkHttpClient对象" class="headerlink" title="构造OkHttpClient对象"></a>构造<code>OkHttpClient</code>对象</h3><p><img src="/images/OkHttp-构造OkHttpClient对象.png" srcset="/img/loading.gif" lazyload alt="构造OkHttpClient对象"></p>
<blockquote>
<p>需要先创建一个<code>OkHttpClient</code>用以执行后续请求。<strong>内部主要是相关参数配置。</strong></p>
<p>主要功能：通信的客户端，用以统一发起请求与解析返回值。</p>
</blockquote>
<figure class="highlight java"><figcaption><span>OkHttpClient.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OkHttpClient</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> Builder());<br>&#125;<br><br>OkHttpClient(Builder builder) &#123;<br>  <span class="hljs-comment">//用于调用网络请求 本质为 线程池</span><br>  <span class="hljs-keyword">this</span>.dispatcher = builder.dispatcher;<br>  <span class="hljs-comment">//设置代理</span><br>  <span class="hljs-keyword">this</span>.proxy = builder.proxy;<br>  <span class="hljs-comment">//设置协议</span><br>  <span class="hljs-keyword">this</span>.protocols = builder.protocols;<br>  <span class="hljs-keyword">this</span>.connectionSpecs = builder.connectionSpecs;<br>  <span class="hljs-comment">//设置拦截器</span><br>  <span class="hljs-keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);<br>  <span class="hljs-comment">//设置网络拦截器</span><br>  <span class="hljs-keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);<br>  <span class="hljs-comment">//回调监听</span><br>  <span class="hljs-keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;<br>  <span class="hljs-keyword">this</span>.proxySelector = builder.proxySelector;<br>  <span class="hljs-comment">//Cookie</span><br>  <span class="hljs-keyword">this</span>.cookieJar = builder.cookieJar;<br>  <span class="hljs-comment">//缓存</span><br>  <span class="hljs-keyword">this</span>.cache = builder.cache;<br>  <span class="hljs-keyword">this</span>.internalCache = builder.internalCache;<br>  <span class="hljs-keyword">this</span>.socketFactory = builder.socketFactory;<br><br>  <span class="hljs-keyword">boolean</span> isTLS = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;<br>    isTLS = isTLS || spec.isTls();<br>  &#125;<br><br>  <span class="hljs-comment">//用于Https请求</span><br>  <span class="hljs-keyword">if</span> (builder.sslSocketFactory != <span class="hljs-keyword">null</span> || !isTLS) &#123;<br>    <span class="hljs-keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;<br>    <span class="hljs-keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    X509TrustManager trustManager = Util.platformTrustManager();<br>    <span class="hljs-keyword">this</span>.sslSocketFactory = newSslSocketFactory(trustManager);<br>    <span class="hljs-keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (sslSocketFactory != <span class="hljs-keyword">null</span>) &#123;<br>    Platform.get().configureSslSocketFactory(sslSocketFactory);<br>  &#125;<br><br>  <span class="hljs-keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;<br>  <span class="hljs-keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(<br>      certificateChainCleaner);<br>  <span class="hljs-keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;<br>  <span class="hljs-keyword">this</span>.authenticator = builder.authenticator;<br>  <span class="hljs-keyword">this</span>.connectionPool = builder.connectionPool;<br>  <span class="hljs-keyword">this</span>.dns = builder.dns;<br>  <span class="hljs-keyword">this</span>.followSslRedirects = builder.followSslRedirects;<br>  <span class="hljs-keyword">this</span>.followRedirects = builder.followRedirects;<br>  <span class="hljs-comment">//是否需要重试</span><br>  <span class="hljs-keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;<br>  <span class="hljs-keyword">this</span>.callTimeout = builder.callTimeout;<br>  <span class="hljs-comment">//链接超时时长</span><br>  <span class="hljs-keyword">this</span>.connectTimeout = builder.connectTimeout;<br>  <span class="hljs-comment">//读取超时时间</span><br>  <span class="hljs-keyword">this</span>.readTimeout = builder.readTimeout;<br>  <span class="hljs-comment">//写入超时时间</span><br>  <span class="hljs-keyword">this</span>.writeTimeout = builder.writeTimeout;<br>  <span class="hljs-keyword">this</span>.pingInterval = builder.pingInterval;<br><br>  <span class="hljs-keyword">if</span> (interceptors.contains(<span class="hljs-keyword">null</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Null interceptor: "</span> + interceptors);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (networkInterceptors.contains(<span class="hljs-keyword">null</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Null network interceptor: "</span> + networkInterceptors);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>OkHttpClient</code>是应用<strong>建造者模式</strong>，通过<code>OkHttpClient.Builder</code>来构造一个<code>OkHttpClient</code>对象，支持数十种参数配置。</p>
<h3 id="构造Request请求对象"><a href="#构造Request请求对象" class="headerlink" title="构造Request请求对象"></a>构造<code>Request</code>请求对象</h3><p><img src="/images/OkHttp-构造Request请求对象.png" srcset="/img/loading.gif" lazyload alt="OkHttp-构造Request请求对象"></p>
<blockquote>
<p>创建一个<code>Request</code>对象用以包括请求的所有信息，内部包含了<strong>请求地址，请求头，请求内容</strong>。</p>
<p>主要功能：封装请求的具体信息。</p>
</blockquote>
<figure class="highlight java"><figcaption><span>Request.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;<br>  Request(Builder builder) &#123;<br>    <span class="hljs-comment">//请求地址</span><br>    <span class="hljs-keyword">this</span>.url = builder.url;<br>    <span class="hljs-comment">//请求方法 例如：GET、POST、PUT、DELETE等</span><br>    <span class="hljs-keyword">this</span>.method = builder.method;<br>    <span class="hljs-comment">//请求头信息</span><br>    <span class="hljs-keyword">this</span>.headers = builder.headers.build();<br>    <span class="hljs-comment">//请求内容构造体</span><br>    <span class="hljs-keyword">this</span>.body = builder.body;<br>    <span class="hljs-comment">//请求的标签  用于后续对指定标签可进行特殊处理</span><br>    <span class="hljs-keyword">this</span>.tags = Util.immutableMap(builder.tags);<br>  &#125;<br>    <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>    <span class="hljs-meta">@Nullable</span> HttpUrl url;<br>    String method;<br>    Headers.Builder headers;<br>    <span class="hljs-meta">@Nullable</span> RequestBody body;<br><br>    <span class="hljs-comment">/** A mutable map of tags, or an immutable empty map if we don't have any. */</span><br>    Map&lt;Class&lt;?&gt;, Object&gt; tags = Collections.emptyMap();<br>    <br>    <span class="hljs-comment">//默认是GET方法，不带有请求体</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.method = <span class="hljs-string">"GET"</span>;<br>      <span class="hljs-keyword">this</span>.headers = <span class="hljs-keyword">new</span> Headers.Builder();<br>    &#125;<br><br>    Builder(Request request) &#123;<br>      <span class="hljs-keyword">this</span>.url = request.url;<br>      <span class="hljs-keyword">this</span>.method = request.method;<br>      <span class="hljs-keyword">this</span>.body = request.body;<br>      <span class="hljs-keyword">this</span>.tags = request.tags.isEmpty()<br>          ? Collections.emptyMap()<br>          : <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(request.tags);<br>      <span class="hljs-keyword">this</span>.headers = request.headers.newBuilder();<br>    &#125;<br>     ... <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Request</code>使用的也是<strong>建造者模式</strong>，通过<code>Request.Builder</code>去构造对应<code>Request</code>。</p>
<h4 id="请求体RequestBody"><a href="#请求体RequestBody" class="headerlink" title="请求体RequestBody"></a>请求体<code>RequestBody</code></h4><blockquote>
<p>主要功能：用以提交<strong>流、表单等请求信息</strong>。</p>
</blockquote>
<h5 id="FormBody"><a href="#FormBody" class="headerlink" title="FormBody"></a>FormBody</h5><blockquote>
<p>支持提交键值对类型。例如<code>userId : 1</code></p>
</blockquote>
<p>使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">FormBody.Builder formBodyBuilder = <span class="hljs-keyword">new</span> FormBody.Builder();<br>Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;<br>    formBodyBuilder.add(entry.getKey(), entry.getValue().toString());<br>&#125;<br>RequestBody body = formBodyBuilder.build();<br></code></pre></td></tr></table></figure>
<h5 id="MultipartBody"><a href="#MultipartBody" class="headerlink" title="MultipartBody"></a>MultipartBody</h5><blockquote>
<p>除了支持键值对，还有提交文件功能。</p>
</blockquote>
<p>使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">MultipartBody.Builder multipartBuilder = <span class="hljs-keyword">new</span> MultipartBody.Builder().setType(MultipartBody.FORM);<br>       Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>       <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;<br>           multipartBuilder.addFormDataPart(entry.getKey(), entry.getValue().toString());<br>       &#125;<br>       <span class="hljs-comment">//可以针对文件新起一个 参数来进行传递</span><br>       <span class="hljs-keyword">for</span> (Map.Entry&lt;String, File&gt; entry : message.getFiles().entrySet()) &#123;<br>           File f = entry.getValue();<br>           <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>               <span class="hljs-keyword">continue</span>;<br>           String name = f.getName();<br>           String ext = name.substring(name.lastIndexOf(<span class="hljs-string">'.'</span>));<br>           String imageFormat = <span class="hljs-string">"jpg"</span>;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-string">".png"</span>.equalsIgnoreCase(ext)) &#123;<br>               imageFormat = <span class="hljs-string">"png"</span>;<br>           &#125;<br>           multipartBuilder.addFormDataPart(<br>                   entry.getKey(),<br>                   entry.getValue().getName(),<br>                   RequestBody.create(MediaType.parse(<span class="hljs-string">"image/"</span> + imageFormat), entry.getValue())<br>           );<br>       &#125;<br><br>       RequestBody body = multipartBuilder.build();<br></code></pre></td></tr></table></figure>
<h3 id="发送Request请求"><a href="#发送Request请求" class="headerlink" title="发送Request请求"></a>发送<code>Request</code>请求</h3><p><img src="/images/OkHttp-发送Request请求.png" srcset="/img/loading.gif" lazyload alt="OkHttp-发送Request请求"></p>
<p>通过<code>OkHttpClient.newCall()</code>发送出<code>Request</code>请求</p>
<figure class="highlight java"><figcaption><span>OkHttpClient.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Call <span class="hljs-title">newCall</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> RealCall.newRealCall(<span class="hljs-keyword">this</span>, request, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* for web socket */</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>返回了一个<code>Call</code>对象，实现类为<code>RealCall</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Call</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>  <span class="hljs-comment">//获取当前请求</span><br>  <span class="hljs-function">Request <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//执行当前请求 并返回结果</span><br>  <span class="hljs-function">Response <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>  <span class="hljs-comment">//异步请求</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Callback responseCallback)</span></span>;<br>  <span class="hljs-comment">//取消请求</span><br>  <span class="hljs-comment">/** Cancels the request, if possible. Requests that are already complete cannot be canceled. */</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//当前请求是否正在执行</span><br>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isExecuted</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//请求是否已取消</span><br>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCanceled</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//超时返回</span><br>  <span class="hljs-function">Timeout <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//克隆请求 用于重新调用</span><br>  <span class="hljs-function">Call <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-function">Call <span class="hljs-title">newCall</span><span class="hljs-params">(Request request)</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>RealCall.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Call</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RealCall</span><span class="hljs-params">(OkHttpClient client, Request originalRequest, <span class="hljs-keyword">boolean</span> forWebSocket)</span> </span>&#123;<br>    	<span class="hljs-comment">//前面先行创建的 OkHttpClient</span><br>    	<span class="hljs-keyword">this</span>.client = client;<br>        <span class="hljs-comment">//创建的请求对象</span><br>    	<span class="hljs-keyword">this</span>.originalRequest = originalRequest;<br>   		<span class="hljs-comment">//用于建立长连接</span><br>    	<span class="hljs-keyword">this</span>.forWebSocket = forWebSocket;<br>  	&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> RealCall <span class="hljs-title">newRealCall</span><span class="hljs-params">(OkHttpClient client, Request originalRequest, <span class="hljs-keyword">boolean</span> forWebSocket)</span> </span>&#123;<br>    	<span class="hljs-comment">// Safely publish the Call instance to the EventListener.</span><br>    	RealCall call = <span class="hljs-keyword">new</span> RealCall(client, originalRequest, forWebSocket);<br>        <span class="hljs-comment">//为这次请求设置了事件监听器，包括请求开始、结束、异常等监听</span><br>    	call.transmitter = <span class="hljs-keyword">new</span> Transmitter(client, call);<br>    	<span class="hljs-keyword">return</span> call;<br>  	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>newCall()</code>根据传递进来的<code>Request</code>创建一个<code>RealCall</code>实例去发送请求。</p>
<h4 id="同步请求——execute"><a href="#同步请求——execute" class="headerlink" title="同步请求——execute()"></a>同步请求——execute()</h4><blockquote>
<p>直接执行并返回请求结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already Executed"</span>);<br>      executed = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    transmitter.timeoutEnter();<br>    <span class="hljs-comment">//请求开始</span><br>    transmitter.callStart();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//加入 runningSuncCalls 队列中</span><br>      client.dispatcher().executed(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-comment">//返回响应结果</span><br>      <span class="hljs-keyword">return</span> getResponseWithInterceptorChain();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">//从队列中移除 避免重复执行</span><br>      client.dispatcher().finished(<span class="hljs-keyword">this</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>执行<code>execute()</code>时，监听到请求事件开始，就会加入到<code>Dispatcher.runningSyncCalls</code>中，里面记录的是当前正在进行同步请求的call，然后当call完成时或因异常结束时，再从<code>Dispatcher.runningSyncCalls</code>移除。</p>
</blockquote>
<h4 id="异步请求——enqueue-Callback-callback"><a href="#异步请求——enqueue-Callback-callback" class="headerlink" title="异步请求——enqueue(Callback callback)"></a>异步请求——enqueue(Callback callback)</h4><blockquote>
<p>构造一个异步执行队列，然后把请求加入队列中处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Callback responseCallback)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already Executed"</span>);<br>      executed = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    transmitter.callStart();<br>    client.dispatcher().enqueue(<span class="hljs-keyword">new</span> AsyncCall(responseCallback));<br>  &#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamedRunnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Callback responseCallback;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> AtomicInteger callsPerHost = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    AsyncCall(Callback responseCallback) &#123;<br>      <span class="hljs-keyword">super</span>(<span class="hljs-string">"OkHttp %s"</span>, redactedUrl());<br>      <span class="hljs-keyword">this</span>.responseCallback = responseCallback;<br>    &#125;<br><br>    <span class="hljs-function">AtomicInteger <span class="hljs-title">callsPerHost</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> callsPerHost;<br>    &#125;<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">executeOn</span><span class="hljs-params">(ExecutorService executorService)</span> </span>&#123;<br>      <span class="hljs-keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));<br>      <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        executorService.execute(<span class="hljs-keyword">this</span>);<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>        InterruptedIOException ioException = <span class="hljs-keyword">new</span> InterruptedIOException(<span class="hljs-string">"executor rejected"</span>);<br>        ioException.initCause(e);<br>        transmitter.noMoreExchanges(ioException);<br>        responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, ioException);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>          client.dispatcher().finished(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// This call is no longer running!</span><br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">boolean</span> signalledCallback = <span class="hljs-keyword">false</span>;<br>      transmitter.timeoutEnter();<br>      <span class="hljs-keyword">try</span> &#123;<br>        Response response = getResponseWithInterceptorChain();<br>        signalledCallback = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">//回调请求结果</span><br>        responseCallback.onResponse(RealCall.<span class="hljs-keyword">this</span>, response);<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">if</span> (signalledCallback) &#123;<br>          <span class="hljs-comment">// Do not signal the callback twice!</span><br>          Platform.get().log(INFO, <span class="hljs-string">"Callback failure for "</span> + toLoggableString(), e);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//回调失败并返回异常</span><br>          responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, e);<br>        &#125;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//从队列中移除</span><br>        client.dispatcher().finished(<span class="hljs-keyword">this</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>enqueue()</code>调用到<code>Dispatcher.enqueue()</code>传入的是一个<code>AsyncCall</code>对象，<code>AsyncCall</code>本质是一个<code>Runnable</code>对象，通过<code>Dispatcher</code>中的<code>ExecutorService</code>来执行<code>AsyncCall</code>。</p>
</blockquote>
<h3 id="执行Request请求"><a href="#执行Request请求" class="headerlink" title="执行Request请求"></a>执行<code>Request</code>请求</h3><blockquote>
<p>由<code>execute()</code>或<code>enqueue()</code>发送请求时，最后都是需要有<code>Dispatch</code>去执行请求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dispatcher</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxRequests = <span class="hljs-number">64</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxRequestsPerHost = <span class="hljs-number">5</span>;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> ExecutorService executorService;<br>  <span class="hljs-comment">//正在准备执行的异步请求队列</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>  <span class="hljs-comment">//正在执行的异步请求队列</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>  <span class="hljs-comment">//正在执行的同步请求队列 </span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    <br>  <span class="hljs-comment">//用以执行异步请求</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> ExecutorService <span class="hljs-title">executorService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (executorService == <span class="hljs-keyword">null</span>) &#123;<br>      executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>          <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp Dispatcher"</span>, <span class="hljs-keyword">false</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> executorService;<br>  &#125;<br>    <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(AsyncCall call)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      <span class="hljs-comment">//加入正在执行的异步队列中</span><br>      readyAsyncCalls.add(call);<br><br>      <span class="hljs-comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span><br>      <span class="hljs-comment">// the same host.</span><br>      <span class="hljs-keyword">if</span> (!call.get().forWebSocket) &#123;<br>        AsyncCall existingCall = findExistingCallWithHost(call.host());<br>        <span class="hljs-keyword">if</span> (existingCall != <span class="hljs-keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);<br>      &#125;<br>    &#125;<br>    promoteAndExecute();<br>  &#125;<br>    <br>  <span class="hljs-comment">//加入正在执行的同步队列</span><br>  <span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executed</span><span class="hljs-params">(RealCall call)</span> </span>&#123;<br>    runningSyncCalls.add(call);<br>  &#125;<br>  <span class="hljs-comment">//从政在执行的异步队列中移除  </span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(AsyncCall call)</span> </span>&#123;<br>    call.callsPerHost().decrementAndGet();<br>    finished(runningAsyncCalls, call);<br>  &#125;<br>  <span class="hljs-comment">//执行完毕后  从正在执行的同步队列中移除</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(RealCall call)</span> </span>&#123;<br>    finished(runningSyncCalls, call);<br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finished</span><span class="hljs-params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;<br>    Runnable idleCallback;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!calls.remove(call)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">"Call wasn't in-flight!"</span>);<br>      idleCallback = <span class="hljs-keyword">this</span>.idleCallback;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> isRunning = promoteAndExecute();<br>    <span class="hljs-keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="hljs-keyword">null</span>) &#123;<br>      idleCallback.run();<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">promoteAndExecute</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//判定当前线程是否持有锁</span><br>    <span class="hljs-keyword">assert</span> (!Thread.holdsLock(<span class="hljs-keyword">this</span>));<br><br>    List&lt;AsyncCall&gt; executableCalls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">boolean</span> isRunning;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      <br>      <span class="hljs-keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;<br>        AsyncCall asyncCall = i.next();<br>        <span class="hljs-comment">//正在运行的异步请求不能超过 64个</span><br>        <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Max capacity.</span><br>        <span class="hljs-comment">//在同一个Host下的异步请求不能超过5个</span><br>        <span class="hljs-keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Host max capacity.</span><br><br>        i.remove();<br>        <span class="hljs-comment">//CAS</span><br>        asyncCall.callsPerHost().incrementAndGet();<br>        <span class="hljs-comment">//添加至异步执行队列</span><br>        executableCalls.add(asyncCall);<br>        <span class="hljs-comment">//添加至正在执行异步请求队列</span><br>        runningAsyncCalls.add(asyncCall);<br>      &#125;<br>      isRunning = runningCallsCount() &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;<br>      AsyncCall asyncCall = executableCalls.get(i);<br>      <span class="hljs-comment">//执行异步请求</span><br>      asyncCall.executeOn(executorService());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> isRunning;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Dispatcher</code>是一个任务调度器，内部维护了三个双端队列：</p>
<ul>
<li><code>readyAsyncCalls</code>：准备执行的异步请求。<em>已经超过请求上限的异步请求就会放在该队列中。</em></li>
<li><code>runningAsyncCalls</code>：正在执行的异步请求。<em>不超过请求上限时，异步请求会加入到该队列中，超过时，依然放到<code>readyAsyncCalls</code>中。</em></li>
<li><code>runningSyncCalls</code>：正在执行的同步请求。<em>直接把同步请求添加到该队列中。</em></li>
</ul>
<p>通过<code>Dispatcher</code>中的<code>executorService</code>去执行对应请求。</p>
<h3 id="处理Request请求——通过拦截器"><a href="#处理Request请求——通过拦截器" class="headerlink" title="处理Request请求——通过拦截器"></a>处理<code>Request</code>请求——通过拦截器</h3><p><img src="/images/OkHttp-处理Request请求.png" srcset="/img/loading.gif" lazyload alt="OkHttp-处理Request请求"></p>
<blockquote>
<p>通过<code>Dispatcher</code>执行完请求后，返回回调结果前，需要通过<code>getResponseWithInterceptorChain()</code>通过层层责任链的执行来获得最终的请求结果。</p>
<p><strong>通过责任链模式将请求一层层的通过拦截器进行处理。</strong></p>
</blockquote>
<figure class="highlight java"><figcaption><span>RealCall.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Response <span class="hljs-title">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// Build a full stack of interceptors.</span><br>    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//加入用户自定义的拦截器</span><br>    interceptors.addAll(client.interceptors());<br>    <span class="hljs-comment">//重试和重定向拦截器</span><br>    interceptors.add(<span class="hljs-keyword">new</span> RetryAndFollowUpInterceptor(client));<br>    <span class="hljs-comment">//转化用户请求为网络请求</span><br>    interceptors.add(<span class="hljs-keyword">new</span> BridgeInterceptor(client.cookieJar()));<br>    <span class="hljs-comment">//负责读取缓存以及更新缓存</span><br>    interceptors.add(<span class="hljs-keyword">new</span> CacheInterceptor(client.internalCache()));<br>    <span class="hljs-comment">//与服务器建立连接</span><br>    interceptors.add(<span class="hljs-keyword">new</span> ConnectInterceptor(client));<br>    <span class="hljs-keyword">if</span> (!forWebSocket) &#123;<br>       <span class="hljs-comment">//用户自定义的网络拦截器</span><br>      interceptors.addAll(client.networkInterceptors());<br>    &#125;<br>    <span class="hljs-comment">//从服务器读取响应的数据</span><br>    interceptors.add(<span class="hljs-keyword">new</span> CallServerInterceptor(forWebSocket));<br><br>    Interceptor.Chain chain = <span class="hljs-keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>,<br>        originalRequest, <span class="hljs-keyword">this</span>, client.connectTimeoutMillis(),<br>        client.readTimeoutMillis(), client.writeTimeoutMillis());<br><br>    <span class="hljs-keyword">boolean</span> calledNoMoreExchanges = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//链式调用拦截器，最终返回 Response</span><br>      Response response = chain.proceed(originalRequest);<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;<br>        closeQuietly(response);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> response;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      calledNoMoreExchanges = <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">throw</span> transmitter.noMoreExchanges(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;<br>        transmitter.noMoreExchanges(<span class="hljs-keyword">null</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>在获得响应结果之前，需要对用户设置的原始请求转换为实际的网络请求，然后通过一系列拦截器，直到最终得到结果，采用<strong>链式调用</strong>保证这些拦截器的执行顺序。</p>
<h4 id="OkHttp拦截器"><a href="#OkHttp拦截器" class="headerlink" title="OkHttp拦截器"></a>OkHttp拦截器</h4><blockquote>
<p>所有的拦截器都实现了<code>Interceptor</code>接口，支持用户去自定义拦截器，只要实现<code>Interceptor</code>接口即可。</p>
<p>拦截器可以 用来<em>监控、改写和重试HTTP访问</em>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>  <span class="hljs-comment">//主要实现该接口，控制返回结果</span><br>  <span class="hljs-function">Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Chain</span> </span>&#123;<br>    <br>    <span class="hljs-function">Request <span class="hljs-title">request</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">//返回Request执行后的返回结果</span><br>    <span class="hljs-meta">@Nullable</span> <span class="hljs-function">Connection <span class="hljs-title">connection</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Call <span class="hljs-title">call</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connectTimeoutMillis</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Chain <span class="hljs-title">withConnectTimeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout, TimeUnit unit)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">readTimeoutMillis</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Chain <span class="hljs-title">withReadTimeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout, TimeUnit unit)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">writeTimeoutMillis</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Chain <span class="hljs-title">withWriteTimeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout, TimeUnit unit)</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="ApplicationInterceptor"><a href="#ApplicationInterceptor" class="headerlink" title="ApplicationInterceptor"></a><code>ApplicationInterceptor</code></h5><p><img src="/images/OkHttp-ApplicationInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-ApplicationInterceptor"></p>
<blockquote>
<p>该拦截器会被第一个执行，此处得到的<code>Request</code>为最原始状态。但是最终得到的<code>Response</code>是最终的结果。</p>
</blockquote>
<p>引用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient.Builder()<br>    .addInterceptor(<span class="hljs-keyword">new</span> LoggingInterceptor())<br>    .build();<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>ApplicationInterceptor</code>适用于在请求前统一添加一些公共参数，例如<code>App的版本号，系统信息</code>等。</p>
<p>也可用于对返回的<code>Response</code>进行加工。</p>
</blockquote>
<p><code>ApplicationInterceptor</code>有以下特定：</p>
<ul>
<li>不需要关心后续拦截器进行的操作，因为是会被第一个执行的，只要关心返回结果即可。</li>
<li>只会被响应一次，即使强制缓存获取</li>
<li>可以对后续的拦截器调用进行拦截或者进行多次调用——<strong>通过<code>Chain.proceed()</code>进行控制</strong></li>
</ul>
<h5 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a><code>RetryAndFollowUpInterceptor</code></h5><p><img src="/images/OkHttp-RetryAndFollowUpInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-RetryAndFollowUpInterceptor"></p>
<blockquote>
<p>负责失败重试和重定向的拦截器。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetryAndFollowUpInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//从自定义拦截器 那里传递下来的请求</span><br>    Request request = chain.request();<br>    RealInterceptorChain realChain = (RealInterceptorChain) chain;<br>    <span class="hljs-comment">//获取事件监听器</span><br>    Transmitter transmitter = realChain.transmitter();<br>    <span class="hljs-comment">//初始化 重定向次数</span><br>    <span class="hljs-keyword">int</span> followUpCount = <span class="hljs-number">0</span>;<br>    Response priorResponse = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//开启死循环 进行重试操作</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      transmitter.prepareToConnect(request);<br>      <span class="hljs-comment">//请求取消</span><br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);<br>      &#125;<br><br>      Response response;<br>      <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//向下调用 下一个拦截器——BridgeInterceptor</span><br>        response = realChain.proceed(request, transmitter, <span class="hljs-keyword">null</span>);<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (RouteException e) &#123;<br>        <span class="hljs-comment">// 不需要重试 则抛出异常</span><br>        <span class="hljs-keyword">if</span> (!recover(e.getLastConnectException(), transmitter, <span class="hljs-keyword">false</span>, request)) &#123;<br>          <span class="hljs-keyword">throw</span> e.getFirstConnectException();<br>        &#125;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-comment">// 无法与服务端建立连接</span><br>        <span class="hljs-keyword">boolean</span> requestSendStarted = !(e <span class="hljs-keyword">instanceof</span> ConnectionShutdownException);<br>        <span class="hljs-keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="hljs-keyword">throw</span> e;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// The network call threw an exception. Release any resources.</span><br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>          <span class="hljs-comment">//释放资源</span><br>          transmitter.exchangeDoneDueToException();<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// Attach the prior response if it exists. Such responses never have a body.</span><br>      <span class="hljs-keyword">if</span> (priorResponse != <span class="hljs-keyword">null</span>) &#123;<br>        response = response.newBuilder()<br>            .priorResponse(priorResponse.newBuilder()<br>                    .body(<span class="hljs-keyword">null</span>)<br>                    .build())<br>            .build();<br>      &#125;<br><br>      Exchange exchange = Internal.instance.exchange(response);<br>      Route route = exchange != <span class="hljs-keyword">null</span> ? exchange.connection().route() : <span class="hljs-keyword">null</span>;<br>      <span class="hljs-comment">//根据返回的 response的Code 判断是否需要进行重定向</span><br>      Request followUp = followUpRequest(response, route);<br><br>      <span class="hljs-keyword">if</span> (followUp == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//释放资源</span><br>        <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span> &amp;&amp; exchange.isDuplex()) &#123;<br>          transmitter.timeoutEarlyExit();<br>        &#125;<br>        <span class="hljs-keyword">return</span> response;<br>      &#125;<br><br>      RequestBody followUpBody = followUp.body();<br>      <span class="hljs-keyword">if</span> (followUpBody != <span class="hljs-keyword">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;<br>        <span class="hljs-keyword">return</span> response;<br>      &#125;<br><br>      closeQuietly(response.body());<br>      <span class="hljs-keyword">if</span> (transmitter.hasExchange()) &#123;<br>        exchange.detachWithViolence();<br>      &#125;<br><br>      <span class="hljs-comment">//超出重定向次数</span><br>      <span class="hljs-keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(<span class="hljs-string">"Too many follow-up requests: "</span> + followUpCount);<br>      &#125;<br>      <span class="hljs-comment">//获取重定向结果 赋予 request继续向下请求</span><br>      request = followUp;<br>      priorResponse = response;<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">recover</span><span class="hljs-params">(IOException e, Transmitter transmitter,<br>      <span class="hljs-keyword">boolean</span> requestSendStarted, Request userRequest)</span> </span>&#123;<br>    <span class="hljs-comment">// 未开启重试 retryOnConnectionFailure(false)</span><br>    <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 只允许发送一次 isOneShot()&#123;return true;&#125;</span><br>    <span class="hljs-keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 发生异常</span><br>    <span class="hljs-keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 设置不允许重试</span><br>    <span class="hljs-keyword">if</span> (!transmitter.canRetry()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>尝试执行下一个拦截器，即<code>BridgeInterceptor</code></li>
<li>抛出异常，需要根据以下情况去判断是否需要重试：<ul>
<li>客户端是否开启  <code>retryOnConnectionFailure</code></li>
<li><code>RequestBody.isOneShot()</code>返回值</li>
<li>判断异常类型，除了<code>ConnectionShutdownException</code>被中断情况外的<code>IOException</code>的子类，都不会进行重试</li>
</ul>
</li>
<li>根据Response返回的响应码<code>code</code>进行处理</li>
</ol>
</blockquote>
<figure class="highlight java"><figcaption><span>RetryAndFollowUpInterceptor.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Request <span class="hljs-title">followUpRequest</span><span class="hljs-params">(Response userResponse, @Nullable Route route)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">if</span> (userResponse == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br>    <span class="hljs-keyword">int</span> responseCode = userResponse.code();<br><br>    <span class="hljs-keyword">final</span> String method = userResponse.request().method();<br>    <span class="hljs-keyword">switch</span> (responseCode) &#123;<br>      <span class="hljs-comment">// 407 需要进行代理认证</span><br>      <span class="hljs-keyword">case</span> HTTP_PROXY_AUTH:<br>        Proxy selectedProxy = route != <span class="hljs-keyword">null</span><br>            ? route.proxy()<br>            : client.proxy();<br>        <span class="hljs-keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(<span class="hljs-string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> client.proxyAuthenticator().authenticate(route, userResponse);<br>      <span class="hljs-comment">// 401 未经认证</span><br>      <span class="hljs-keyword">case</span> HTTP_UNAUTHORIZED:<br>        <span class="hljs-keyword">return</span> client.authenticator().authenticate(route, userResponse);<br>      <span class="hljs-comment">// 301 永久重定向  302 临时重定向  只有GET、HEAD请求方法才有效</span><br>      <span class="hljs-keyword">case</span> HTTP_PERM_REDIRECT:<br>      <span class="hljs-keyword">case</span> HTTP_TEMP_REDIRECT:<br>        <span class="hljs-comment">// "If the 307 or 308 status code is received in response to a request other than GET</span><br>        <span class="hljs-comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span><br>        <span class="hljs-keyword">if</span> (!method.equals(<span class="hljs-string">"GET"</span>) &amp;&amp; !method.equals(<span class="hljs-string">"HEAD"</span>)) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// fall-through</span><br>      <br>      <span class="hljs-keyword">case</span> HTTP_MULT_CHOICE:<span class="hljs-comment">// 300  多个重定向地址</span><br>      <span class="hljs-keyword">case</span> HTTP_MOVED_PERM:<span class="hljs-comment">// 301 永久移除 指向了新的位置</span><br>      <span class="hljs-keyword">case</span> HTTP_MOVED_TEMP:<span class="hljs-comment">//302  临时移除</span><br>      <span class="hljs-keyword">case</span> HTTP_SEE_OTHER:<span class="hljs-comment">//303 查看其他位置</span><br>        <span class="hljs-comment">// 开发者是否允许重定向</span><br>        <span class="hljs-keyword">if</span> (!client.followRedirects()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//重定向后的实际地址</span><br>        String location = userResponse.header(<span class="hljs-string">"Location"</span>);<br>        <span class="hljs-keyword">if</span> (location == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        HttpUrl url = userResponse.request().url().resolve(location);<br><br>        <span class="hljs-comment">// Don't follow redirects to unsupported protocols.</span><br>        <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// If configured, don't follow redirects between SSL and non-SSL.</span><br>        <span class="hljs-keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());<br>        <span class="hljs-keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">// Most redirects don't include a request body.</span><br>        Request.Builder requestBuilder = userResponse.request().newBuilder();<br>        <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;<br>          <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);<br>          <span class="hljs-keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;<br>            requestBuilder.method(<span class="hljs-string">"GET"</span>, <span class="hljs-keyword">null</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="hljs-keyword">null</span>;<br>            requestBuilder.method(method, requestBody);<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!maintainBody) &#123;<br>            requestBuilder.removeHeader(<span class="hljs-string">"Transfer-Encoding"</span>);<br>            requestBuilder.removeHeader(<span class="hljs-string">"Content-Length"</span>);<br>            requestBuilder.removeHeader(<span class="hljs-string">"Content-Type"</span>);<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// When redirecting across hosts, drop all authentication headers. This</span><br>        <span class="hljs-comment">// is potentially annoying to the application layer since they have no</span><br>        <span class="hljs-comment">// way to retain them.</span><br>        <span class="hljs-keyword">if</span> (!sameConnection(userResponse.request().url(), url)) &#123;<br>          requestBuilder.removeHeader(<span class="hljs-string">"Authorization"</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> requestBuilder.url(url).build();<br>      <span class="hljs-comment">//408 超时</span><br>      <span class="hljs-keyword">case</span> HTTP_CLIENT_TIMEOUT:<br>        <span class="hljs-comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span><br>        <span class="hljs-comment">// spec says that we may repeat the request without modifications. Modern browsers also</span><br>        <span class="hljs-comment">// repeat the request (even non-idempotent ones.)</span><br>        <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure()) &#123;<br>          <span class="hljs-comment">// The application layer has directed us not to retry the request.</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        RequestBody requestBody = userResponse.request().body();<br>        <span class="hljs-keyword">if</span> (requestBody != <span class="hljs-keyword">null</span> &amp;&amp; requestBody.isOneShot()) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (userResponse.priorResponse() != <span class="hljs-keyword">null</span><br>            &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;<br>          <span class="hljs-comment">// We attempted to retry and got another timeout. Give up.</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (retryAfter(userResponse, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> userResponse.request();<br>      <span class="hljs-comment">//503 服务端不可用</span><br>      <span class="hljs-keyword">case</span> HTTP_UNAVAILABLE:<br>        <span class="hljs-keyword">if</span> (userResponse.priorResponse() != <span class="hljs-keyword">null</span><br>            &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;<br>          <span class="hljs-comment">// We attempted to retry and got another timeout. Give up.</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// specifically received an instruction to retry without delay</span><br>          <span class="hljs-keyword">return</span> userResponse.request();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>followUpRequest()</code>对<code>Response</code>返回的<code>code</code>进行对应操作，在触发到重定向相关的code<code>3XX</code>时，需要对应的转换<code>Request</code>使用获取到的重定向后地址进行请求。</p>
<blockquote>
<p>由源码可知，可以重试的最大次数为<strong>20</strong>次，可以通过<code>retryOnConnectionFailure(true)</code>设置支持重试。但是不支持自定义重试次数，若需要自定义重试次数，需要自定义拦截器去实现。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetryInterceptor</span></span>(<span class="hljs-keyword">var</span> maxRetry: <span class="hljs-built_in">Int</span><span class="hljs-comment">/*最大重试次数*/</span>) : Interceptor &#123;<br>        <span class="hljs-comment">//当前重试次数</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> retryNum = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">intercept</span><span class="hljs-params">(chain: <span class="hljs-type">Interceptor</span>.<span class="hljs-type">Chain</span>)</span></span>: Response &#123;<br>            <span class="hljs-keyword">val</span> request = chain.request()<br>            <span class="hljs-keyword">var</span> response = chain.proceed(request)<br><br>            <span class="hljs-keyword">while</span> (!response.isSuccessful &amp;&amp; retryNum &lt; maxRetry) &#123;<br>                retryNum++<br>                response = chain.proceed(request)<br>            &#125;<br>            <span class="hljs-keyword">return</span> response<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a><code>BridgeInterceptor</code></h5><p><img src="/images/OkHttp-BridgeInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-BridgeInterceptor"></p>
<blockquote>
<p>用以将用户的请求转换为向服务器的请求，之后再把服务器返回的数据转换成用户直观的数据。<strong>主要是对Header进行处理</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BridgeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    Request userRequest = chain.request();<br>    Request.Builder requestBuilder = userRequest.newBuilder();<br>    <span class="hljs-comment">//重构用户请求 为 服务器请求格式</span><br>    RequestBody body = userRequest.body();<br>    <span class="hljs-comment">//如果存在Body</span><br>    <span class="hljs-keyword">if</span> (body != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">//对Header进行调整</span><br>      MediaType contentType = body.contentType();<br>      <span class="hljs-keyword">if</span> (contentType != <span class="hljs-keyword">null</span>) &#123;<br>        requestBuilder.header(<span class="hljs-string">"Content-Type"</span>, contentType.toString());<br>      &#125;<br><br>      <span class="hljs-keyword">long</span> contentLength = body.contentLength();<br>      <span class="hljs-keyword">if</span> (contentLength != -<span class="hljs-number">1</span>) &#123;<br>        requestBuilder.header(<span class="hljs-string">"Content-Length"</span>, Long.toString(contentLength));<br>        requestBuilder.removeHeader(<span class="hljs-string">"Transfer-Encoding"</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        requestBuilder.header(<span class="hljs-string">"Transfer-Encoding"</span>, <span class="hljs-string">"chunked"</span>);<br>        requestBuilder.removeHeader(<span class="hljs-string">"Content-Length"</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//设置Header中的 host</span><br>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Host"</span>) == <span class="hljs-keyword">null</span>) &#123;<br>      requestBuilder.header(<span class="hljs-string">"Host"</span>, hostHeader(userRequest.url(), <span class="hljs-keyword">false</span>));<br>    &#125;<br><br>    <span class="hljs-comment">//设置 connection : Keep-Alive 保持长连接模式</span><br>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Connection"</span>) == <span class="hljs-keyword">null</span>) &#123;<br>      requestBuilder.header(<span class="hljs-string">"Connection"</span>, <span class="hljs-string">"Keep-Alive"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span><br>    <span class="hljs-comment">// the transfer stream.</span><br>    <span class="hljs-keyword">boolean</span> transparentGzip = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//默认使用Gzip压缩</span><br>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"Accept-Encoding"</span>) == <span class="hljs-keyword">null</span> &amp;&amp; userRequest.header(<span class="hljs-string">"Range"</span>) == <span class="hljs-keyword">null</span>) &#123;<br>      transparentGzip = <span class="hljs-keyword">true</span>;<br>      requestBuilder.header(<span class="hljs-string">"Accept-Encoding"</span>, <span class="hljs-string">"gzip"</span>);<br>    &#125;<br>    <span class="hljs-comment">//设置 Cookie信息</span><br>    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());<br>    <span class="hljs-keyword">if</span> (!cookies.isEmpty()) &#123;<br>      requestBuilder.header(<span class="hljs-string">"Cookie"</span>, cookieHeader(cookies));<br>    &#125;<br>    <span class="hljs-comment">//设置UA</span><br>    <span class="hljs-keyword">if</span> (userRequest.header(<span class="hljs-string">"User-Agent"</span>) == <span class="hljs-keyword">null</span>) &#123;<br>      requestBuilder.header(<span class="hljs-string">"User-Agent"</span>, Version.userAgent());<br>    &#125;<br>    <span class="hljs-comment">//传递至下一个拦截器处理</span><br>    Response networkResponse = chain.proceed(requestBuilder.build());<br><br>    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());<br><br>    Response.Builder responseBuilder = networkResponse.newBuilder()<br>        .request(userRequest);<br>    <span class="hljs-comment">//如果服务器支持Gzip压缩，需要进行解压操作</span><br>    <span class="hljs-keyword">if</span> (transparentGzip<br>        &amp;&amp; <span class="hljs-string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="hljs-string">"Content-Encoding"</span>))<br>        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;<br>      GzipSource responseBody = <span class="hljs-keyword">new</span> GzipSource(networkResponse.body().source());<br>      Headers strippedHeaders = networkResponse.headers().newBuilder()<br>          .removeAll(<span class="hljs-string">"Content-Encoding"</span>)<br>          .removeAll(<span class="hljs-string">"Content-Length"</span>)<br>          .build();<br>      responseBuilder.headers(strippedHeaders);<br>      String contentType = networkResponse.header(<span class="hljs-string">"Content-Type"</span>);<br>      responseBuilder.body(<span class="hljs-keyword">new</span> RealResponseBody(contentType, -<span class="hljs-number">1L</span>, Okio.buffer(responseBody)));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> responseBuilder.build();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>GZip</code>：是一种压缩技术，可以改进Web应用的性能，将请求体明显的减少其大小，如果服务器也支持该格式，就会返回对应格式的内容，客户端需要进行解压操作，可以明显的减少流量消耗。</p>
</blockquote>
<p><code>BridgeInterceptor</code>主要执行了以下3步：</p>
<ul>
<li><p>用户请求转换为网络请求</p>
<p>在原来<code>Request</code>上添加了很多<code>Header</code>，例如<code>Content-Type(定义网络文件的类型和网页的编码)、Content-Length(请求体内容长度)、Transfer-Encoding(请求体的大小)与Content-Length互斥、Accept-Encoding(编码格式)</code>。</p>
<p>未设置<code>Accept-Encoding</code>默认为<code>gzip</code>。</p>
</li>
<li><p>执行转换后的网络请求</p>
<p><code>chain.proceed(requestBuilder.build())</code></p>
</li>
<li><p>服务器返回的响应结果转换为用户响应结果</p>
<p>根据上一步获得<code>Response</code>后，需要再次转化为用户直观格式。主要在于服务端返回的信息里是否设置了<code>Accept-Encoding:gzip</code>，设置了则需要进行解压过程，获取最终结果。</p>
</li>
</ul>
<h5 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a><code>CacheInterceptor</code></h5><p><img src="/images/OkHttp-CacheInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-CacheInterceptor"></p>
<blockquote>
<p>主要用于<strong>读取缓存以及更新缓存的</strong>，<strong>为了节省流量和提高响应速度</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//根据请求的相关信息获取缓存</span><br>    Response cacheCandidate = cache != <span class="hljs-keyword">null</span><br>        ? cache.get(chain.request())<br>        : <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br>    <span class="hljs-comment">//创建缓存策略</span><br>    CacheStrategy strategy = <span class="hljs-keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();①<br>    Request networkRequest = strategy.networkRequest;<br>    Response cacheResponse = strategy.cacheResponse;<br><br>    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;<br>      cache.trackResponse(strategy);<br>    &#125;<br>    <span class="hljs-comment">//缓存无法使用，关闭获得的Response</span><br>    <span class="hljs-keyword">if</span> (cacheCandidate != <span class="hljs-keyword">null</span> &amp;&amp; cacheResponse == <span class="hljs-keyword">null</span>) &#123;<br>      closeQuietly(cacheCandidate.body()); <span class="hljs-comment">// The cache candidate wasn't applicable. Close it.</span><br>    &#125;<br><br>    <span class="hljs-comment">// 根据策略，不使用网络且没有缓存的直接报错，返回504</span><br>    <span class="hljs-keyword">if</span> (networkRequest == <span class="hljs-keyword">null</span> &amp;&amp; cacheResponse == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response.Builder()<br>          .request(chain.request())<br>          .protocol(Protocol.HTTP_1_1)<br>          .code(<span class="hljs-number">504</span>)<br>          .message(<span class="hljs-string">"Unsatisfiable Request (only-if-cached)"</span>)<br>          .body(Util.EMPTY_RESPONSE)<br>          .sentRequestAtMillis(-<span class="hljs-number">1L</span>)<br>          .receivedResponseAtMillis(System.currentTimeMillis())<br>          .build();<br>    &#125;<br><br>    <span class="hljs-comment">// 直接返回缓存，不允许使用网络</span><br>    <span class="hljs-keyword">if</span> (networkRequest == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> cacheResponse.newBuilder()<br>          .cacheResponse(stripBody(cacheResponse))<br>          .build();<br>    &#125;<br><br>    Response networkResponse = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//请求向下传递</span><br>      networkResponse = chain.proceed(networkRequest);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span><br>      <span class="hljs-keyword">if</span> (networkResponse == <span class="hljs-keyword">null</span> &amp;&amp; cacheCandidate != <span class="hljs-keyword">null</span>) &#123;<br>        closeQuietly(cacheCandidate.body());<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 接受到服务器返回数据，如果返回code为 304 直接使用缓存结果</span><br>    <span class="hljs-keyword">if</span> (cacheResponse != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;<br>        Response response = cacheResponse.newBuilder()<br>            .headers(combine(cacheResponse.headers(), networkResponse.headers()))<br>            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())<br>            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())<br>            .cacheResponse(stripBody(cacheResponse))<br>            .networkResponse(stripBody(networkResponse))<br>            .build();<br>        networkResponse.body().close();<br><br>        <span class="hljs-comment">// Update the cache after combining headers but before stripping the</span><br>        <span class="hljs-comment">// Content-Encoding header (as performed by initContentStream()).</span><br>        cache.trackConditionalCacheHit();<br>        <span class="hljs-comment">//更新当前存储的缓存信息</span><br>        cache.update(cacheResponse, response);<br>        <span class="hljs-keyword">return</span> response;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        closeQuietly(cacheResponse.body());<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//读取服务器返回结果</span><br>    Response response = networkResponse.newBuilder()<br>        .cacheResponse(stripBody(cacheResponse))<br>        .networkResponse(stripBody(networkResponse))<br>        .build();<br>    <span class="hljs-comment">//对数据进行缓存</span><br>    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;<br>        <span class="hljs-comment">// Offer this request to the cache.</span><br>        CacheRequest cacheRequest = cache.put(response);<br>        <span class="hljs-keyword">return</span> cacheWritingResponse(cacheRequest, response);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          cache.remove(networkRequest);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>          <span class="hljs-comment">// The cache cannot be written.</span><br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>CacheInterceptor</code>的执行流程如下所示：</p>
<ol>
<li>先行读取缓存数据</li>
<li>创建好对应的缓存策略：<code>强制缓存</code>、<code>对比缓存</code></li>
<li>根据缓存策略，不使用网络、也没有对应缓存，返回<code>504</code></li>
<li>根据缓存策略，不使用网络，存在缓存则直接返回</li>
<li>前面都没有返回结果，继续向下执行请求：<code>chain.proceed()</code></li>
<li>接受到对应网络结果，如果返回code为<code>304</code>，代表直接使用缓存并更新对应缓存信息</li>
<li>读取网络结果，对数据进行缓存</li>
<li>返回获取的网络结果</li>
</ol>
<p>具体的缓存策略请参考<a href="#OkHttp缓存机制">缓存策略</a></p>
<h5 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a><code>ConnectInterceptor</code></h5><p><img src="/images/OkHttp-ConnectInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-ConnectInterceptor"></p>
<blockquote>
<p>真正与服务端建立连接，底层是通过<code>Socket</code>进行连接。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> OkHttpClient client;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    RealInterceptorChain realChain = (RealInterceptorChain) chain;<br>    Request request = realChain.request();<br>    Transmitter transmitter = realChain.transmitter();<br><br>    <span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br>    <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="hljs-string">"GET"</span>);<br>    <span class="hljs-comment">//建立连接</span><br>    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);<br>    <span class="hljs-comment">//继续请求下一个拦截器</span><br>    <span class="hljs-keyword">return</span> realChain.proceed(request, transmitter, exchange);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ConnectInterceptor</code>主要功能是建立与服务器的连接关系，通过<code>Transmitter.newExchange()</code>建立连接，建立完成后继续向下执行请求。</p>
<p>具体的连接过程可以参考<a href="# OkHttp连接机制">连接机制</a></p>
<h5 id="NetworkInterceptor"><a href="#NetworkInterceptor" class="headerlink" title="NetworkInterceptor"></a><code>NetworkInterceptor</code></h5><p><img src="/images/OkHttp-NetworkInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-NetworkInterceptor"></p>
<blockquote>
<p>用户自定义的网络拦截器，处于第6个拦截器，前面经过了<code>RetryAndFolowUpInterceptor</code>的重定向过程以及<code>BridgeInterceptor</code>的请求头处理，在此处可以获取到更多的连接信息。</p>
</blockquote>
<p>引用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient.Builder()<br>    .addNetworkInterceptor(<span class="hljs-keyword">new</span> LoggingInterceptor())<br>    .build();<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>NetworkInterceptor</code>可以获取到最终请求的<code>Request</code>，以及获取到真正进行过网络请求的得到的<code>Response</code>，从而可以针对<code>Response</code>进行修改然后再回传到上层拦截器。</p>
</blockquote>
<p><code>NetworkInterceptor</code>主要有以下特点：</p>
<ul>
<li>可以操作经过<code>重定向、重试</code>得到的<code>Response</code></li>
<li>无法响应缓存数据的请求，因为<code>CacheInterceptor</code>执行在它之前</li>
<li>得到最终进行请求的<code>Request</code></li>
<li>可以获得连接信息</li>
</ul>
<h5 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a><code>CallServerInterceptor</code></h5><p><img src="/images/OkHttp-CallServerInterceptor.png" srcset="/img/loading.gif" lazyload alt="OkHttp-CallServerInterceptor"></p>
<blockquote>
<p>数据的写入过程，也就是客户端和服务端进行交互的过程，客户端发送数据，服务端返回数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallServerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    RealInterceptorChain realChain = (RealInterceptorChain) chain;<br>    Exchange exchange = realChain.exchange();<br>    Request request = realChain.request();<br><br>    <span class="hljs-keyword">long</span> sentRequestMillis = System.currentTimeMillis();<br>    <span class="hljs-comment">//写入请求头</span><br>    exchange.writeRequestHeaders(request);<br><br>    <span class="hljs-keyword">boolean</span> responseHeadersStarted = <span class="hljs-keyword">false</span>;<br>    Response.Builder responseBuilder = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//判断当前是否有 请求体body</span><br>    <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span><br>      <span class="hljs-comment">// Continue" response before transmitting the request body. If we don't get that, return</span><br>      <span class="hljs-comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span><br>      <span class="hljs-comment">//如果是1XX的话 表示当前需要等服务端响应 </span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="hljs-string">"Expect"</span>))) &#123;<br>        exchange.flushRequest();<br>        responseHeadersStarted = <span class="hljs-keyword">true</span>;<br>        exchange.responseHeadersStart();<br>        responseBuilder = exchange.readResponseHeaders(<span class="hljs-keyword">true</span>);<br>      &#125;<br><br>      <br>      <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//写入请求体</span><br>        <span class="hljs-keyword">if</span> (request.body().isDuplex()) &#123;<br>          <span class="hljs-comment">// Prepare a duplex body so that the application can send a request body later.</span><br>          exchange.flushRequest();<br>          BufferedSink bufferedRequestBody = Okio.buffer(<br>              exchange.createRequestBody(request, <span class="hljs-keyword">true</span>));<br>          request.body().writeTo(bufferedRequestBody);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span><br>          BufferedSink bufferedRequestBody = Okio.buffer(<br>              exchange.createRequestBody(request, <span class="hljs-keyword">false</span>));<br>          request.body().writeTo(bufferedRequestBody);<br>          bufferedRequestBody.close();<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        exchange.noRequestBody();<br>        <span class="hljs-keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;<br>          <span class="hljs-comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span><br>          <span class="hljs-comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span><br>          <span class="hljs-comment">// leave the connection in a consistent state.</span><br>          exchange.noNewExchangesOnConnection();<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      exchange.noRequestBody();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (request.body() == <span class="hljs-keyword">null</span> || !request.body().isDuplex()) &#123;<br>        <span class="hljs-comment">//结束请求</span><br>      exchange.finishRequest();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!responseHeadersStarted) &#123;<br>      exchange.responseHeadersStart();<br>    &#125;<br>    <span class="hljs-comment">//得到响应头</span><br>    <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-keyword">null</span>) &#123;<br>      responseBuilder = exchange.readResponseHeaders(<span class="hljs-keyword">false</span>);<br>    &#125;<br>    <br>    Response response = responseBuilder<br>        .request(request)<br>        .handshake(exchange.connection().handshake())<br>        .sentRequestAtMillis(sentRequestMillis)<br>        .receivedResponseAtMillis(System.currentTimeMillis())<br>        .build();<br>    <span class="hljs-comment">//读取响应体内容</span><br>    <span class="hljs-keyword">int</span> code = response.code();<br>    <span class="hljs-keyword">if</span> (code == <span class="hljs-number">100</span>) &#123;<br>      <span class="hljs-comment">// server sent a 100-continue even though we did not request one.</span><br>      <span class="hljs-comment">// try again to read the actual response</span><br>      response = exchange.readResponseHeaders(<span class="hljs-keyword">false</span>)<br>          .request(request)<br>          .handshake(exchange.connection().handshake())<br>          .sentRequestAtMillis(sentRequestMillis)<br>          .receivedResponseAtMillis(System.currentTimeMillis())<br>          .build();<br><br>      code = response.code();<br>    &#125;<br><br>    exchange.responseHeadersEnd(response);<br>    <span class="hljs-comment">//forWebSocket 表示为socket连接方式</span><br>    <span class="hljs-keyword">if</span> (forWebSocket &amp;&amp; code == <span class="hljs-number">101</span>) &#123;<br>      <span class="hljs-comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br>      response = response.newBuilder()<br>          .body(Util.EMPTY_RESPONSE)<br>          .build();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      response = response.newBuilder()<br>          .body(exchange.openResponseBody(response))<br>          .build();<br>    &#125;<br>    <span class="hljs-comment">// close表示关闭连接</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="hljs-string">"Connection"</span>))<br>        || <span class="hljs-string">"close"</span>.equalsIgnoreCase(response.header(<span class="hljs-string">"Connection"</span>))) &#123;<br>      exchange.noNewExchangesOnConnection();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((code == <span class="hljs-number">204</span> || code == <span class="hljs-number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProtocolException(<br>          <span class="hljs-string">"HTTP "</span> + code + <span class="hljs-string">" had non-zero Content-Length: "</span> + response.body().contentLength());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>CallServerInterceptor</code>主要执行了以下过程：</p>
<ul>
<li>写入请求头</li>
<li>写入请求体(如果存在)</li>
<li>获取状态行及响应头</li>
<li>获取响应体</li>
</ul>
<p><code>CallServerInterceptor</code>已经是最后一个拦截器了，接下来就是向上回溯并返回自己获得的<code>Response</code>。</p>
<blockquote>
<p>HTTP报文结构：</p>
<p><strong>请求报文</strong>：</p>
<p>请求行：声明请求方法、主机域名及协议版本</p>
<p>请求头：声明客户端的部分报文信息</p>
<p>请求体：存放客户端发送给服务器的数据</p>
<p><strong>响应报文</strong></p>
<p>状态行：声明HTTP协议版本、状态码及描述</p>
<p>响应头：声明服务端的部分报文信息</p>
<p>响应体：服务端返回客户端的数据</p>
</blockquote>
<h4 id="责任链模式串联"><a href="#责任链模式串联" class="headerlink" title="责任链模式串联"></a>责任链模式串联</h4><p>介绍完上述的拦截器后，接下来就是分析如何将这些拦截器进行串联调用。</p>
<figure class="highlight java"><figcaption><span>RealCall.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Response <span class="hljs-title">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// Build a full stack of interceptors.</span><br>    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    ...<br>    <span class="hljs-comment">//构建责任链</span><br>    Interceptor.Chain chain = <span class="hljs-keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>,<br>        originalRequest, <span class="hljs-keyword">this</span>, client.connectTimeoutMillis(),<br>        client.readTimeoutMillis(), client.writeTimeoutMillis());<br><br>    <span class="hljs-keyword">boolean</span> calledNoMoreExchanges = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//开始从头链式调用拦截器</span><br>      Response response = chain.proceed(originalRequest);<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;<br>        closeQuietly(response);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> response;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      calledNoMoreExchanges = <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">throw</span> transmitter.noMoreExchanges(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;<br>        transmitter.noMoreExchanges(<span class="hljs-keyword">null</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>实际执行链式调用的是<code>RealInterceptorChain</code>，由他负责责任链的执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealInterceptorChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span>.<span class="hljs-title">Chain</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> proceed(request, transmitter, exchange);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">proceed</span><span class="hljs-params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span><br>      <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= interceptors.size()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();<br><br>    calls++;<br><br>    <span class="hljs-comment">// 存在已经在使用的流，直接进行复用</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.exchange != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"network interceptor "</span> + interceptors.get(index - <span class="hljs-number">1</span>)<br>          + <span class="hljs-string">" must retain the same host and port"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.exchange != <span class="hljs-keyword">null</span> &amp;&amp; calls &gt; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"network interceptor "</span> + interceptors.get(index - <span class="hljs-number">1</span>)<br>          + <span class="hljs-string">" must call proceed() exactly once"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 调用该链中的下一个拦截器 实质为 用户自定义的拦截器，不存在则为 RetryAndFollowUpInterceptor</span><br>    RealInterceptorChain next = <span class="hljs-keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,<br>        index + <span class="hljs-number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);<br>    Interceptor interceptor = interceptors.get(index);<br>    Response response = interceptor.intercept(next);<br><br>    <span class="hljs-comment">// Confirm that the next interceptor made its required call to chain.proceed().</span><br>    <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span> &amp;&amp; index + <span class="hljs-number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"network interceptor "</span> + interceptor<br>          + <span class="hljs-string">" must call proceed() exactly once"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Confirm that the intercepted response isn't null.</span><br>    <span class="hljs-keyword">if</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"interceptor "</span> + interceptor + <span class="hljs-string">" returned null"</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (response.body() == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br>          <span class="hljs-string">"interceptor "</span> + interceptor + <span class="hljs-string">" returned a response with no body"</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>RealIntercrptor</code>为链式调用的起点，调用<code>proceed()</code>之后，继续调用下一层的拦截器，直到得到最终的Response。</p>
<p>后续的拦截器也是按照这个规则向下执行，内部都会调用到<code>chain.proceed()</code>直到没有调用为止。</p>
<p><strong>Request是按照定义的<code>interceptor</code>顺序向下执行，然后Response是逆向向上处理的。</strong></p>
<h3 id="获取请求结果Response"><a href="#获取请求结果Response" class="headerlink" title="获取请求结果Response"></a>获取请求结果<code>Response</code></h3><blockquote>
<p><code>Response</code>：返回HTTP请求响应结果，包含了状态码，响应正文等</p>
</blockquote>
<p>在<code>CallServerInterceptor</code>得到最初格式的<code>Response</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得状态行及响应头  </span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> Response.<span class="hljs-function">Builder <span class="hljs-title">readResponseHeaders</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> expectContinue)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      Response.Builder result = codec.readResponseHeaders(expectContinue);<br>      <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>        Internal.instance.initExchange(result, <span class="hljs-keyword">this</span>);<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      eventListener.responseFailed(call, e);<br>      trackFailure(e);<br>      <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">//获得响应正文</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseBody <span class="hljs-title">openResponseBody</span><span class="hljs-params">(Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      eventListener.responseBodyStart(call);<br>      String contentType = response.header(<span class="hljs-string">"Content-Type"</span>);<br>      <span class="hljs-keyword">long</span> contentLength = codec.reportedContentLength(response);<br>      Source rawSource = codec.openResponseBodySource(response);<br>      ResponseBodySource source = <span class="hljs-keyword">new</span> ResponseBodySource(rawSource, contentLength);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RealResponseBody(contentType, contentLength, Okio.buffer(source));<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      eventListener.responseFailed(call, e);<br>      trackFailure(e);<br>      <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/OkHttp执行流程.png" srcset="/img/loading.gif" lazyload alt="OkHttp执行流程"></p>
<h2 id="OkHttp缓存机制"><a href="#OkHttp缓存机制" class="headerlink" title="OkHttp缓存机制"></a>OkHttp缓存机制</h2><h3 id="Http缓存"><a href="#Http缓存" class="headerlink" title="Http缓存"></a>Http缓存</h3><p><img src="/images/OkHttp-HTTP缓存机制.png" srcset="/img/loading.gif" lazyload alt="OkHttp-HTTP缓存机制"></p>
<blockquote>
<p>Http缓存是web性能优化的重要手段，缓存机制是依赖于<code>header</code>中的参数实现的，这些参数指定了缓存需要<em>从缓存中获取</em>还是<em>从服务端获取</em>。</p>
</blockquote>
<p>Http缓存有多种规则，根据是否需要重新向服务器发起请求来进行分类：</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><blockquote>
<p>当客户端第一次请求数据时，服务端在响应头会携带<strong>缓存规则信息</strong>，主要为两个字段：<strong>Expires</strong>、<strong>Cache-Control</strong></p>
<p>当再次请求数据时，如果符合缓存规则，则直接使用缓存数据，无需与服务端重新交互。</p>
</blockquote>
<p><img src="/images/强制缓存流程.png" srcset="/img/loading.gif" lazyload alt="强制缓存流程"></p>
<p>强制缓存在缓存未失效的情况下，可以直接使用缓存数据，接下来介绍<code>判断缓存数据是否失效</code>。<br>上文提到，强制缓存是根据两个Header字段进行判定的，这两个字段表示了<code>失效规则</code>。</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><del>Expires</del></h5><blockquote>
<p>服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。<br><em>这参数是HTTP1.0的东西了，现在主流的是HTTP1.1。</em><br>可能由于客户端时间没有与服务端时间同步而导致缓存命中的误差。</p>
</blockquote>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><blockquote>
<p>在HTTP1.1中替代<code>Expires</code>，功能与其一致。<br><code>Cache-Control</code>常见的取值有如下几种：</p>
<ul>
<li><code>private</code>：客户端可以进行缓存</li>
<li><code>public</code>：客户端以及代理服务器都可以进行缓存</li>
<li><code>max-age= XX</code>：缓存数据在 XX秒后失效</li>
<li><code>no-cache</code>：需要使用到<code>对比缓存</code></li>
<li><code>no-store</code>：所有内容都不进行缓存</li>
<li><code>s-maxage = XX</code>：限定缓存可以在代理服务器中存放多久</li>
</ul>
</blockquote>
<h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><blockquote>
<p>需要进行比较判断来确定是否使用缓存，当客户端第一次请求数据时，服务端会返回<strong>缓存标识</strong>以及数据给客户端，客户端对两者都要进行备份到缓存，当再次请求数据时，客户端会带上<strong>缓存标识</strong>发送给服务端，服务端对标识进行判断，返回code值。返回若为<strong>304</strong>，则继续使用缓存。</p>
</blockquote>
<p><img src="/images/对比缓存流程.png" srcset="/img/loading.gif" lazyload alt="对比缓存流程"></p>
<p>在<strong>缓存标识</strong>未失效时，可以继续使用缓存数据，每次都需要与服务端进行交互去验证<strong>缓存标识</strong>。<br>对比缓存也是依据两个Header字段进行判定的，这两个字段表示了<code>缓存标识</code>。</p>
<h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p><code>Last-Modified</code>：服务端返回给客户端，表示资源的最后修改时间。<br><code>If-Modified-Since</code>：客户端发给服务端，表示服务端上次返回的资源最后修改时间。<br>服务端接收到<code>If-Modified-Since</code>后，与被请求资源的最后修改时间进行比对。</p>
<ul>
<li>若大于，返回最新资源并返回code为200，客户端需要重新进行缓存</li>
<li>否则，说明资源无修改并返回code为304，客户端继续使用缓存数据</li>
</ul>
<h5 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h5><p><code>ETag</code>：服务端返回给客户端，表示当前资源在服务器的唯一标识。<br><code>If-None-Match</code>：客户端发送给服务端，表示服务端上次返回的资源唯一标识。<br>服务端接收到<code>If-None-Match</code>后，与被请求资源的唯一标识进行比对</p>
<ul>
<li>标识不同，表示资源被改动过，返回最新资源及设置code为200，客户端需要重新进行缓存</li>
<li>标识相同，表示资源未被改动，返回code为304，客户端继续使用缓存数据</li>
</ul>
<p>其中<code>ETag/If-None-Match</code>的优先级是高于<code>Last-Modified/If-Modified-Since</code>的</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<ul>
<li>强制缓存的优先级是高于对比缓存的</li>
<li>对于<code>强制缓存</code>，服务端会给予一个过期时间，在有效期内再次请求都只会使用缓存，不会请求服务端。</li>
<li>超过有效期就使用<code>对比缓存</code>策略，将服务端返回的<code>ETag/Last-Modified</code>发还给服务端进行验证，有效则继续使用缓存数据(<em>返回code为304</em>)，无效则重新获取并进行缓存(<em>返回code为200</em>)。</li>
</ul>
</blockquote>
<h3 id="缓存存储"><a href="#缓存存储" class="headerlink" title="缓存存储"></a>缓存存储</h3><p><img src="/images/OkHttp缓存实现.png" srcset="/img/loading.gif" lazyload alt="OkHttp缓存实现"></p>
<p>介绍完毕Http的缓存机制后，接下来就是看<code>OkHttp</code>中的源码实现<br><figure class="highlight java"><figcaption><span>CacheStrategy.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CacheStrategy(Request networkRequest, Response cacheResponse) &#123;<br>  <span class="hljs-keyword">this</span>.networkRequest = networkRequest;<br>  <span class="hljs-keyword">this</span>.cacheResponse = cacheResponse;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>缓存策略主要通过<code>CacheStrategy</code>类实现，关键参数为<code>networkRequest(网络请求)</code>、<code>cacheResponse(缓存的响应结果)</code>。<br><code>CacheStrategy</code>通过工厂模式进行构建的，最终通过调用<code>getCandidate()</code>来生成不同模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> CacheStrategy <span class="hljs-title">getCandidate</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">// 没缓存直接进行重新请求</span><br>      <span class="hljs-keyword">if</span> (cacheResponse == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);<br>      &#125;<br><br>      <span class="hljs-comment">// 如果是HTTPs且握手信息丢失进行重新请求</span><br>      <span class="hljs-keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);<br>      &#125;<br>      <span class="hljs-comment">//判断缓存已经失效 重新进行请求</span><br>      <span class="hljs-keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);<br>      &#125;<br>      <span class="hljs-comment">// </span><br>      CacheControl requestCaching = request.cacheControl();<br>      <span class="hljs-keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>);<br>      &#125;<br><br>      CacheControl responseCaching = cacheResponse.cacheControl();<br>      <span class="hljs-comment">//</span><br>      <span class="hljs-keyword">long</span> ageMillis = cacheResponseAge();<br>      <span class="hljs-keyword">long</span> freshMillis = computeFreshnessLifetime();<br><br>      <span class="hljs-keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="hljs-number">1</span>) &#123;<br>        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));<br>      &#125;<br><br>      <span class="hljs-keyword">long</span> minFreshMillis = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="hljs-number">1</span>) &#123;<br>        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());<br>      &#125;<br><br>      <span class="hljs-keyword">long</span> maxStaleMillis = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="hljs-number">1</span>) &#123;<br>        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());<br>      &#125;<br>      <span class="hljs-comment">//处于强制缓存状态，直接返回缓存数据</span><br>      <span class="hljs-keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;<br>        Response.Builder builder = cacheResponse.newBuilder();<br>        <span class="hljs-keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;<br>          builder.addHeader(<span class="hljs-string">"Warning"</span>, <span class="hljs-string">"110 HttpURLConnection \"Response is stale\""</span>);<br>        &#125;<br>        <span class="hljs-keyword">long</span> oneDayMillis = <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000L</span>;<br>        <span class="hljs-keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;<br>          builder.addHeader(<span class="hljs-string">"Warning"</span>, <span class="hljs-string">"113 HttpURLConnection \"Heuristic expiration\""</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(<span class="hljs-keyword">null</span>, builder.build());<br>      &#125;<br><br>      <span class="hljs-comment">// Find a condition to add to the request. If the condition is satisfied, the response body</span><br>      <span class="hljs-comment">// will not be transmitted.</span><br>      String conditionName;<br>      String conditionValue;<br>      <span class="hljs-keyword">if</span> (etag != <span class="hljs-keyword">null</span>) &#123;<br>        conditionName = <span class="hljs-string">"If-None-Match"</span>;<br>        conditionValue = etag;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastModified != <span class="hljs-keyword">null</span>) &#123;<br>        conditionName = <span class="hljs-string">"If-Modified-Since"</span>;<br>        conditionValue = lastModifiedString;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (servedDate != <span class="hljs-keyword">null</span>) &#123;<br>        conditionName = <span class="hljs-string">"If-Modified-Since"</span>;<br>        conditionValue = servedDateString;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(request, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// No condition! Make a regular request.</span><br>      &#125;<br>      <span class="hljs-comment">//交由服务端去进行判断</span><br>      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();<br>      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);<br><br>      Request conditionalRequest = request.newBuilder()<br>          .headers(conditionalRequestHeaders.build())<br>          .build();<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>CacheStrategy</code>根据之前的缓存结果以及要发送的<code>request的header</code>计算缓存策略</p>
<table>
<thead>
<tr>
<th>networkRequest</th>
<th>cacheResponse</th>
<th>CacheStrategy</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td>null</td>
<td>不进行网络请求且缓存不存在或过期<br>返回504错误</td>
</tr>
<tr>
<td>null</td>
<td>not null</td>
<td>不进行网络请求但是存在缓存且有效<br>直接返回缓存数据</td>
</tr>
<tr>
<td>not null</td>
<td>null</td>
<td>进行网络请求且缓存不存在或过期<br>直接进行网络请求获取数据</td>
</tr>
<tr>
<td>not null</td>
<td>not null</td>
<td>进行网络请求，请求头包含<code>ETag/Last-Modified</code>且缓存存在<br>根据网络请求结果判断<br>返回304，使用缓存<br>返回200，使用请求数据且更新缓存</td>
</tr>
</tbody>
</table>
<h2 id="OkHttp连接机制"><a href="#OkHttp连接机制" class="headerlink" title="OkHttp连接机制"></a>OkHttp连接机制</h2><p>在<code>ConnectInterceptor</code>中进行了与服务端的连接，通过<code>Exchange</code>类进行连接。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Exchange <span class="hljs-title">newExchange</span><span class="hljs-params">(Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>    <span class="hljs-keyword">if</span> (noMoreExchanges) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"released"</span>);<br>    <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"exchange != null"</span>);<br>  &#125;<br>  <span class="hljs-comment">//建立连接</span><br>  ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);<br>  Exchange result = <span class="hljs-keyword">new</span> Exchange(<span class="hljs-keyword">this</span>, call, eventListener, exchangeFinder, codec);<br><br>  <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>    <span class="hljs-keyword">this</span>.exchange = result;<br>    <span class="hljs-keyword">this</span>.exchangeRequestDone = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">this</span>.exchangeResponseDone = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="通过Socket连接服务端"><a href="#通过Socket连接服务端" class="headerlink" title="通过Socket连接服务端"></a>通过Socket连接服务端</h3><p>通过<code>ExchangeCodec.find()</code>来设置连接或者复用<br><figure class="highlight java"><figcaption><span>ExchangeCodec.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ExchangeCodec <span class="hljs-title">find</span><span class="hljs-params">(<br>      OkHttpClient client, Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> connectTimeout = chain.connectTimeoutMillis();<br>    <span class="hljs-keyword">int</span> readTimeout = chain.readTimeoutMillis();<br>    <span class="hljs-keyword">int</span> writeTimeout = chain.writeTimeoutMillis();<br>    <span class="hljs-keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();<br>    <span class="hljs-keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,<br>          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);<br>      <span class="hljs-keyword">return</span> resultConnection.newCodec(client, chain);<br>    &#125; <span class="hljs-keyword">catch</span> (RouteException e) &#123;<br>      trackFailure();<br>      <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      trackFailure();<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RouteException(e);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//返回一个健康的连接 </span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findHealthyConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout,<br>      <span class="hljs-keyword">int</span> writeTimeout, <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled,<br>      <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,<br>          pingIntervalMillis, connectionRetryEnabled);<br><br>      <span class="hljs-comment">// If this is a brand new connection, we can skip the extensive health checks.</span><br>      <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>        <span class="hljs-keyword">if</span> (candidate.successCount == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> candidate;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span><br>      <span class="hljs-comment">// isn't, take it out of the pool and start again.</span><br>      <span class="hljs-keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;<br>        candidate.noNewExchanges();<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout, <span class="hljs-keyword">int</span> writeTimeout,<br>      <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">boolean</span> foundPooledConnection = <span class="hljs-keyword">false</span>;<br>    RealConnection result = <span class="hljs-keyword">null</span>;<br>    Route selectedRoute = <span class="hljs-keyword">null</span>;<br>    RealConnection releasedConnection;<br>    Socket toClose;<br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);<br>      hasStreamFailure = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// This is a fresh attempt.</span><br>      <br>      Route previousRoute = retryCurrentRoute()<br>          ? transmitter.connection.route()<br>          : <span class="hljs-keyword">null</span>;<br><br>      <span class="hljs-comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span><br>      <span class="hljs-comment">// already-allocated connection may have been restricted from creating new exchanges.</span><br>      releasedConnection = transmitter.connection;<br>      toClose = transmitter.connection != <span class="hljs-keyword">null</span> &amp;&amp; transmitter.connection.noNewExchanges<br>          ? transmitter.releaseConnectionNoEvents()<br>          : <span class="hljs-keyword">null</span>;<br><br>      <span class="hljs-keyword">if</span> (transmitter.connection != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// We had an already-allocated connection and it's good.</span><br>        result = transmitter.connection;<br>        releasedConnection = <span class="hljs-keyword">null</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Attempt to get a connection from the pool.</span><br>        <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>)) &#123;<br>          foundPooledConnection = <span class="hljs-keyword">true</span>;<br>          result = transmitter.connection;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          selectedRoute = previousRoute;<br>        &#125;<br>      &#125;<br>    &#125;<br>    closeQuietly(toClose);<br><br>    <span class="hljs-keyword">if</span> (releasedConnection != <span class="hljs-keyword">null</span>) &#123;<br>      eventListener.connectionReleased(call, releasedConnection);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;<br>      eventListener.connectionAcquired(call, result);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// If we found an already-allocated or pooled connection, we're done.</span><br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// If we need a route selection, make one. This is a blocking operation.</span><br>    <span class="hljs-keyword">boolean</span> newRouteSelection = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span> &amp;&amp; (routeSelection == <span class="hljs-keyword">null</span> || !routeSelection.hasNext())) &#123;<br>      newRouteSelection = <span class="hljs-keyword">true</span>;<br>      routeSelection = routeSelector.next();<br>    &#125;<br><br>    List&lt;Route&gt; routes = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);<br><br>      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;<br>        <span class="hljs-comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span><br>        <span class="hljs-comment">// the pool. This could match due to connection coalescing.</span><br>        routes = routeSelection.getAll();<br>        <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(<br>            address, transmitter, routes, <span class="hljs-keyword">false</span>)) &#123;<br>          foundPooledConnection = <span class="hljs-keyword">true</span>;<br>          result = transmitter.connection;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//没有从连接池中获取到连接需要重新建立</span><br>      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;<br>        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span>) &#123;<br>          selectedRoute = routeSelection.next();<br>        &#125;<br><br>        <span class="hljs-comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span><br>        <span class="hljs-comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span><br>        result = <span class="hljs-keyword">new</span> RealConnection(connectionPool, selectedRoute);<br>        connectingConnection = result;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If we found a pooled connection on the 2nd time around, we're done.</span><br>    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;<br>      eventListener.connectionAcquired(call, result);<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// Do TCP + TLS handshakes. This is a blocking operation.</span><br>    <span class="hljs-comment">// 开始TCP三次握手以及TLS操作，为阻塞操作</span><br>    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,<br>        connectionRetryEnabled, call, eventListener);<br>    connectionPool.routeDatabase.connected(result.route());<br><br>    Socket socket = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      connectingConnection = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-comment">// Last attempt at connection coalescing, which only occurs if we attempted multiple</span><br>      <span class="hljs-comment">// concurrent connections to the same host.</span><br>      <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="hljs-keyword">true</span>)) &#123;<br>        <span class="hljs-comment">// We lost the race! Close the connection we created and return the pooled connection.</span><br>        result.noNewExchanges = <span class="hljs-keyword">true</span>;<br>        socket = result.socket();<br>        result = transmitter.connection;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//加入连接池 等待复用</span><br>        connectionPool.put(result);<br>        transmitter.acquireConnectionNoEvents(result);<br>      &#125;<br>    &#125;<br>    closeQuietly(socket);<br><br>    eventListener.connectionAcquired(call, result);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure></p>
<p>最终通过<code>Socket.connect()</code>进行连接。</p>
<h3 id="连接池-ConnectionPool"><a href="#连接池-ConnectionPool" class="headerlink" title="连接池(ConnectionPool)"></a>连接池(ConnectionPool)</h3><p><img src="/images/OkHttp-连接池 ConnectionPool.png" srcset="/img/loading.gif" lazyload alt="OkHttp-连接池 ConnectionPool"></p>
<blockquote>
<p>频繁的进行Socket连接(三次握手)和Socket断开(四次挥手)非常消耗网络资源以及时间。在HTTP1.1之后提供了<code>keep-alive</code>这个header，可以实现长连接，有效的降低了延迟并提升了处理速度。<br>连接池就是为了<strong>复用已存在连接</strong>，可以有效降低创建连接的开销。</p>
</blockquote>
<h4 id="连接池构造方法以及成员变量"><a href="#连接池构造方法以及成员变量" class="headerlink" title="连接池构造方法以及成员变量"></a>连接池构造方法以及成员变量</h4><figure class="highlight java"><figcaption><span>ConnectionPool.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123;<br>  <span class="hljs-comment">//后台清理线程</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span> <span class="hljs-comment">/* corePoolSize */</span>,<br>      Integer.MAX_VALUE <span class="hljs-comment">/* maximumPoolSize */</span>, <span class="hljs-number">60L</span> <span class="hljs-comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,<br>      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp ConnectionPool"</span>, <span class="hljs-keyword">true</span>)); <br>    <span class="hljs-comment">//最大的空闲连接数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxIdleConnections;<br>    <span class="hljs-comment">//连接最大持续时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> keepAliveDurationNs;<br>    <span class="hljs-comment">//存储连接的双向队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, TimeUnit.MINUTES);<br>    &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxIdleConnections, <span class="hljs-keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.maxIdleConnections = maxIdleConnections;<br>    <span class="hljs-keyword">this</span>.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);<br><br>    <span class="hljs-comment">// Put a floor on the keep alive duration, otherwise cleanup will spin loop.</span><br>    <span class="hljs-keyword">if</span> (keepAliveDuration &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"keepAliveDuration &lt;= 0: "</span> + keepAliveDuration);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ConnectionPool</code>支持配置以下变量</p>
<ul>
<li><code>maxIdleConnections</code>：最大空闲连接数，默认<code>5</code></li>
<li><code>keepAliveDurationNs</code>：最大连接保持时间，默认<code>5min</code></li>
</ul>
<p><code>Connection</code>连接池中的<code>Connection</code>任一超出以上配置，就需要执行清理。</p>
<p>可以通过以下方法配置连接池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient.Builder builder = <span class="hljs-keyword">new</span> OkHttpClient.Builder()<br>        .connectionPool(<span class="hljs-keyword">new</span> ConnectionPool()); <span class="hljs-comment">//配置连接池</span><br></code></pre></td></tr></table></figure>
<h4 id="连接池加入连接"><a href="#连接池加入连接" class="headerlink" title="连接池加入连接"></a>连接池加入连接</h4><p><img src="/images/1345862-20200603214235374-1759578389.png" srcset="/img/loading.gif" lazyload alt="双端队列"></p>
<p>通过<code>connections</code>存储<code>Connection</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(RealConnection connection)</span> </span>&#123;<br>  <span class="hljs-keyword">assert</span> (Thread.holdsLock(<span class="hljs-keyword">this</span>));<br>  <span class="hljs-keyword">if</span> (!cleanupRunning) &#123;<span class="hljs-comment">//当前清理线程没有运行</span><br>    cleanupRunning = <span class="hljs-keyword">true</span>;<br>    executor.execute(cleanupRunnable);<span class="hljs-comment">//开启清理过程</span><br>  &#125;<br>  connections.add(connection);<span class="hljs-comment">//加入队列</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在外部执行<code>put()</code>时，连接加入连接池，并且开启清理线程去清理那些超出配置的连接。</p>
<p>外部执行<code>put()</code>路径如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConnectInterceptor 连接拦截器，其中执行连接过程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    RealInterceptorChain realChain = (RealInterceptorChain) chain;<br>    Request request = realChain.request();<br>    StreamAllocation streamAllocation = realChain.streamAllocation();<br><br>    <span class="hljs-comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br>    <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="hljs-string">"GET"</span>);<br>    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);<span class="hljs-comment">//建立新连接</span><br>    RealConnection connection = streamAllocation.connection();<br><br>    <span class="hljs-keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);<br>&#125;<br>  <br><span class="hljs-comment">// StreamAllocation </span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> HttpCodec <span class="hljs-title">newStream</span><span class="hljs-params">(<br>      OkHttpClient client, Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;<br>       ...<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,<br>          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);<span class="hljs-comment">//寻找可用的连接</span><br>      HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="hljs-keyword">this</span>);<br><br>      <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>        codec = resultCodec;<br>        <span class="hljs-keyword">return</span> resultCodec;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RouteException(e);<br>    &#125;<br>  &#125; <br>  <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findHealthyConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout,<br>      <span class="hljs-keyword">int</span> writeTimeout, <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled,<br>      <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,<br>          pingIntervalMillis, connectionRetryEnabled);<br>      ...<br><br>      <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>  &#125;<br>  <br>   <span class="hljs-function"><span class="hljs-keyword">private</span> RealConnection <span class="hljs-title">findConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout, <span class="hljs-keyword">int</span> writeTimeout,<br>      <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    ...<br>     <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (released) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"released"</span>);<br>      <span class="hljs-keyword">if</span> (codec != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"codec != null"</span>);<br>      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);<br><br>      <span class="hljs-comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span><br>      <span class="hljs-comment">// already-allocated connection may have been restricted from creating new streams.</span><br>      releasedConnection = <span class="hljs-keyword">this</span>.connection;<br>      toClose = releaseIfNoNewStreams();<br>      ...<br>      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Attempt to get a connection from the pool.</span><br>        Internal.instance.get(connectionPool, address, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);<span class="hljs-comment">//根据address从连接池中获取对应连接</span><br>        <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;<br>          foundPooledConnection = <span class="hljs-keyword">true</span>;<br>          result = connection;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          selectedRoute = route;<br>        &#125;<br>      &#125;<br>    &#125;<br>     ...<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// If we found an already-allocated or pooled connection, we're done.</span><br>      <span class="hljs-keyword">return</span> result;<br>    &#125;  <br>     <br>     ...<br>       <br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (canceled) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>);<br><br>      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;<br>        <span class="hljs-comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span><br>        <span class="hljs-comment">// the pool. This could match due to connection coalescing.</span><br>        List&lt;Route&gt; routes = routeSelection.getAll();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = routes.size(); i &lt; size; i++) &#123;<br>          Route route = routes.get(i);<br>          Internal.instance.get(connectionPool, address, <span class="hljs-keyword">this</span>, route);<br>          <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;<br>            foundPooledConnection = <span class="hljs-keyword">true</span>;<br>            result = connection;<br>            <span class="hljs-keyword">this</span>.route = route;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;<br>        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span>) &#123;<br>          selectedRoute = routeSelection.next();<br>        &#125;<br><br>        <span class="hljs-comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span><br>        <span class="hljs-comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span><br>        route = selectedRoute;<br>        refusedStreamCount = <span class="hljs-number">0</span>;<br>        result = <span class="hljs-keyword">new</span> RealConnection(connectionPool, selectedRoute);<span class="hljs-comment">//连接池未找到对应连接，建立新连接</span><br>        acquire(result, <span class="hljs-keyword">false</span>);<br>      &#125;<br>    &#125;<br>     <br>     ...<br>    <br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      reportedAcquired = <span class="hljs-keyword">true</span>;<br><br>      <span class="hljs-comment">// Pool the connection.</span><br>      Internal.instance.put(connectionPool, result);<span class="hljs-comment">//将新建的连接加入到连接池内</span><br><br>      <span class="hljs-comment">// If another multiplexed connection to the same address was created concurrently, then</span><br>      <span class="hljs-comment">// release this connection and acquire that one.</span><br>      <span class="hljs-keyword">if</span> (result.isMultiplexed()) &#123;<br>        socket = Internal.instance.deduplicate(connectionPool, address, <span class="hljs-keyword">this</span>);<br>        result = connection;<br>      &#125;<br>    &#125;<br>     <br>   &#125;<br>  <br>  <span class="hljs-comment">//OkHttpClient</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Call</span>.<span class="hljs-title">Factory</span>, <span class="hljs-title">WebSocket</span>.<span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>      Internal.instance = <span class="hljs-keyword">new</span> Internal() &#123;<br>       ...<br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> RealConnection <span class="hljs-title">get</span><span class="hljs-params">(ConnectionPool pool, Address address,<br>          StreamAllocation streamAllocation, Route route)</span> </span>&#123;<br>           <span class="hljs-keyword">return</span> pool.get(address, streamAllocation, route);<span class="hljs-comment">//从连接池获取连接</span><br>        &#125; <br>         <br>        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(ConnectionPool pool, RealConnection connection)</span> </span>&#123;<br>          pool.put(connection);<span class="hljs-comment">//向连接池添加连接</span><br>        &#125;<br>       ...<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>ConnectInterceptor.intercept()</code>去建立连接，向下调用到<code>StreamAllocation.newStream()</code></p>
<p>在<code>newStream()</code>中继续执行到<code>findConnection()</code>，其中主要执行了两步</p>
<ol>
<li>从<code>ConnectionPool</code>寻找是否存有当前<code>address</code>对应的连接，调用<code>ConnectionPool.get(XXX)</code>，存在就返回对应连接。</li>
<li>不存在对应连接，执行<code>new RealConnection()</code>新建连接，并调用<code>ConnectionPool.put()</code>存储新连接</li>
</ol>
<p>对应的<code>get()、put()</code>都是通过<code>Internal.instance</code>调用的，其中<code>Internal</code>是一个抽象类，具体实现类对应的就是<code>OkHttpClient</code>。</p>
<h4 id="连接池清理连接"><a href="#连接池清理连接" class="headerlink" title="连接池清理连接"></a>连接池清理连接</h4><p>在使用<code>连接池</code>时，初始化了一个<code>Executor</code>线程池，这个主要就是为了在清理无效连接时去开启清理线程用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/**<br>   * Background threads are used to cleanup expired connections. There will be at most a single<br>   * thread running per connection pool. The thread pool executor permits the pool itself to be<br>   * garbage collected.<br>   * 清理过期的连接，且保证最多只能运行一个清理线程。<br>   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span> <span class="hljs-comment">/* corePoolSize */</span>,<br>      Integer.MAX_VALUE <span class="hljs-comment">/* maximumPoolSize */</span>, <span class="hljs-number">60L</span> <span class="hljs-comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,<br>      <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="hljs-string">"OkHttp ConnectionPool"</span>, <span class="hljs-keyword">true</span>));<br><br><span class="hljs-comment">//清理过期连接任务</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable cleanupRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">long</span> waitNanos = cleanup(System.nanoTime());<span class="hljs-comment">//返回下次需要清理连接的时间</span><br>        <span class="hljs-keyword">if</span> (waitNanos == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (waitNanos &gt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">long</span> waitMillis = waitNanos / <span class="hljs-number">1000000L</span>;<br>          waitNanos -= (waitMillis * <span class="hljs-number">1000000L</span>);<br>          <span class="hljs-keyword">synchronized</span> (ConnectionPool.<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              ConnectionPool.<span class="hljs-keyword">this</span>.wait(waitMillis, (<span class="hljs-keyword">int</span>) waitNanos);<span class="hljs-comment">//阻塞等待</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>
<h5 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup()"></a>cleanup()</h5><p>内部主要执行的是<code>标记空闲连接</code>、<code>清理空闲连接</code>，<code>返回下次清理时间</code>这几步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">cleanup</span><span class="hljs-params">(<span class="hljs-keyword">long</span> now)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> inUseConnectionCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> idleConnectionCount = <span class="hljs-number">0</span>;<br>  RealConnection longestIdleConnection = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;<br><br>  <span class="hljs-comment">// Find either a connection to evict, or the time that the next eviction is due.</span><br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;<span class="hljs-comment">//遍历连接储存队列</span><br>      RealConnection connection = i.next();<br><br>      <span class="hljs-comment">// If the connection is in use, keep searching.</span><br>      <span class="hljs-keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//标记正在使用的活跃连接</span><br>        inUseConnectionCount++;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      idleConnectionCount++;<span class="hljs-comment">//非活跃标记为空闲连接</span><br><br>      <span class="hljs-comment">// If the connection is ready to be evicted, we're done.</span><br>      <span class="hljs-keyword">long</span> idleDurationNs = now - connection.idleAtNanos;<br>      <span class="hljs-keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;<br>        longestIdleDurationNs = idleDurationNs;<br>        longestIdleConnection = connection;<span class="hljs-comment">//得到最长空闲时间的连接</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (longestIdleDurationNs &gt;= <span class="hljs-keyword">this</span>.keepAliveDurationNs<br>        || idleConnectionCount &gt; <span class="hljs-keyword">this</span>.maxIdleConnections) &#123;<br>      <span class="hljs-comment">// We've found a connection to evict. Remove it from the list, then close it below (outside</span><br>      <span class="hljs-comment">// of the synchronized block).</span><br>      <span class="hljs-comment">// 空闲连接超过`maxIdleConnections`个或者空闲时间超过`keepAliveDurationNs`，需要清理该连接</span><br>      connections.remove(longestIdleConnection);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idleConnectionCount &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// A connection will be ready to evict soon.</span><br>      <span class="hljs-comment">// 返回最大空闲连接的到期时间，等待到达时间后进行清理</span><br>      <span class="hljs-keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inUseConnectionCount &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span><br>      <span class="hljs-comment">// 所有都是活跃连接，返回最大空闲连接时间，等待到达时间后清理</span><br>      <span class="hljs-keyword">return</span> keepAliveDurationNs;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// No connections, idle or in use.</span><br>      <span class="hljs-comment">// 当前不存在连接，直接返回 -1，不进行清理任务</span><br>      cleanupRunning = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// 立即关闭过期连接</span><br>  closeQuietly(longestIdleConnection.socket());<br><br>  <span class="hljs-comment">// Cleanup again immediately.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>cleanup()</code>执行流程如下：</p>
<ul>
<li>遍历<code>ConnectionPool</code>的<code>connections</code>，通过<code>pruneAndGetAllocationCount()</code>判断<code>connection</code>是否空闲</li>
<li>遍历完毕后，找到最长时间的空闲连接(<code>longestIdleConnection</code>)</li>
<li>得到<code>longestIdleConnection</code>后，先是比较当前的<code>idleConnectionCount</code>是否大于<code>maxIdleConnections</code>或者<code>longestIdleDurarionNs</code>是否大于<code>keepAliveDurationNs</code>，两者满足其一，则清理掉<code>longestIdleConnection</code></li>
<li>不满足其上条件，继续判断<code>idleConnectionCount &gt; 0</code>，表示当前存在空闲连接，就返回距离最大空闲连接时间差<code>keepAliveDurationNs - longestIdleDurationNs</code>，等待到时清理</li>
<li>不满足其上条件，继续判断<code>inUseConnectionCount &gt; 0</code>，表示当前都是活跃连接，返回<code>keepAliveDurationNs</code>，等待达到时间清理</li>
<li>以上条件都不满足，表示当前没有连接，直接返回<code>-1</code></li>
<li>存在<code>longestIdleConnection</code>，即调用<code>longestIdleConnection.socket().close()</code>关闭连接即可</li>
</ul>
<h5 id="pruneAndGetAllocationCount-Connection"><a href="#pruneAndGetAllocationCount-Connection" class="headerlink" title="pruneAndGetAllocationCount(Connection)"></a>pruneAndGetAllocationCount(Connection)</h5><p>判断当前连接是否正在活跃，采用了<strong>引用计数法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pruneAndGetAllocationCount</span><span class="hljs-params">(RealConnection connection, <span class="hljs-keyword">long</span> now)</span> </span>&#123;<br>  <span class="hljs-comment">//连接弱引用列表</span><br>  List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; references.size(); ) &#123;<br>    <span class="hljs-comment">//获取引用连接</span><br>    Reference&lt;StreamAllocation&gt; reference = references.get(i);<br>    <span class="hljs-comment">//不为null ，表示当前连接尚未回收</span><br>    <span class="hljs-keyword">if</span> (reference.get() != <span class="hljs-keyword">null</span>) &#123;<br>      i++;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// We've discovered a leaked allocation. This is an application bug.</span><br>    StreamAllocation.StreamAllocationReference streamAllocRef =<br>        (StreamAllocation.StreamAllocationReference) reference;<br>    String message = <span class="hljs-string">"A connection to "</span> + connection.route().address().url()<br>        + <span class="hljs-string">" was leaked. Did you forget to close a response body?"</span>;<br>    Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);<br><br>    <span class="hljs-comment">//移除引用</span><br>    references.remove(i);<br>    connection.noNewStreams = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span><br>    <span class="hljs-comment">//所有引用都被移除，表示当前连接处于空闲</span><br>    <span class="hljs-keyword">if</span> (references.isEmpty()) &#123;<br>      connection.idleAtNanos = now - keepAliveDurationNs;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> references.size();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>StreamAllocation</code>引用是在<code>StreamAllocation.acquire()</code>时加入的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(RealConnection connection, <span class="hljs-keyword">boolean</span> reportedAcquired)</span> </span>&#123;<br>  <span class="hljs-keyword">assert</span> (Thread.holdsLock(connectionPool));<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();<br><br>  <span class="hljs-keyword">this</span>.connection = connection;<br>  <span class="hljs-keyword">this</span>.reportedAcquired = reportedAcquired;<br>  connection.allocations.add(<span class="hljs-keyword">new</span> StreamAllocationReference(<span class="hljs-keyword">this</span>, callStackTrace));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过这种<code>引用计数法</code>来判断当前是否为空闲连接</p>
<h2 id="OkHttp-Cookie机制"><a href="#OkHttp-Cookie机制" class="headerlink" title="OkHttp-Cookie机制"></a>OkHttp-Cookie机制</h2><p><img src="/images/OkHttp-Cookie机制.png" srcset="/img/loading.gif" lazyload alt="OkHttp-Cookie机制"></p>
<p>使用方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">OkHttpClient.Builder()<br>  .<span class="hljs-comment">//其他参数</span><br>  .cookieJar(<span class="hljs-keyword">object</span> : CookieJar &#123;<br>     <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveFromResponse</span><span class="hljs-params">(url:<span class="hljs-type">HttpUrl</span>,cookies:<span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">Cookie</span>&gt;)</span></span>&#123;<br>       <span class="hljs-comment">//从Response 获取Cookie信息 并存储到本地</span><br>     &#125;<br>    <br>     <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadForRequest</span><span class="hljs-params">(url:<span class="hljs-type">HttpUrl</span>)</span></span> : MutableList&lt;Cookie&gt; &#123;<br>       <span class="hljs-comment">//根据url获取存储本地的Cookie信息 放到 Request请求中</span><br>     &#125;<br>  &#125;)<br></code></pre></td></tr></table></figure>
<p><code>Cookie</code>一般都会在请求中进行使用，多用于请求头的<code>Cookie</code>字段，大致可以猜测相关的处理位于<code>BridgeInterceptor</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BridgeInterceptor.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BridgeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span></span>&#123;<br>  <span class="hljs-comment">//这个也就是在 构建Client时放入的CookieJar对象</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CookieJar cookieJar;<br>  <br>    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  ...<br>    <span class="hljs-comment">//从配置的cookiejar中获取信息</span><br>     List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());<br>     <span class="hljs-keyword">if</span> (!cookies.isEmpty()) &#123;<br>       <span class="hljs-comment">//在请求头中添加 Cookie请求头，携带Cookie参数</span><br>       requestBuilder.header(<span class="hljs-string">"Cookie"</span>, cookieHeader(cookies));<br>     &#125;<br>  ...   <br>    <span class="hljs-comment">//请求最后得到的 response结果</span><br>    Response networkResponse = chain.proceed(requestBuilder.build());<br>    <span class="hljs-comment">//从rensponse中解析Cookie并缓存到 CookieJar中</span><br>    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());<br>      <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//HttpHeaders.java</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveHeaders</span><span class="hljs-params">(CookieJar cookieJar, HttpUrl url, Headers headers)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cookieJar == CookieJar.NO_COOKIES) <span class="hljs-keyword">return</span>;<br><br>    List&lt;Cookie&gt; cookies = Cookie.parseAll(url, headers);<br>    <span class="hljs-keyword">if</span> (cookies.isEmpty()) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//获取到Cookie对象 缓存中 CookieJar中</span><br>    cookieJar.saveFromResponse(url, cookies);<br>  &#125;<br><br><span class="hljs-comment">//Cookie.java</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Cookie&gt; <span class="hljs-title">parseAll</span><span class="hljs-params">(HttpUrl url, Headers headers)</span> </span>&#123;<br>    <span class="hljs-comment">//从响应头中读取到 Set-Cookie字段，并转换成 Cookie对象</span><br>    List&lt;String&gt; cookieStrings = headers.values(<span class="hljs-string">"Set-Cookie"</span>);<br>    List&lt;Cookie&gt; cookies = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = cookieStrings.size(); i &lt; size; i++) &#123;<br>      Cookie cookie = Cookie.parse(url, cookieStrings.get(i));<br>      <span class="hljs-keyword">if</span> (cookie == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (cookies == <span class="hljs-keyword">null</span>) cookies = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      cookies.add(cookie);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cookies != <span class="hljs-keyword">null</span><br>        ? Collections.unmodifiableList(cookies)<br>        : Collections.&lt;Cookie&gt;emptyList();<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>Cookie</code>原理简述：</p>
<blockquote>
<p>服务端返回的<code>Response</code>通过<code>Set-Cookie</code>响应头返回对应的<code>Cookie信息</code>，以便在下次进行请求时在<code>Request</code>的请求头中添加<code>Cookie</code>字段以携带Cookie信息。</p>
<p><code>OkHttp</code>通过<code>setCookieJar</code>对所有的<code>Cookie</code>文件进行管理。</p>
<ul>
<li><code>saveFromResponse()</code>：可以获取对应域名的Cookie信息</li>
<li><code>loadForRequest()</code>：可以在请求域名时添加Cookie信息</li>
</ul>
<p>可以通过一个全局的<code>CookieJar</code>类来实现应用内Cookie文件的管理。</p>
</blockquote>
<h2 id="OkHttp-DNS功能"><a href="#OkHttp-DNS功能" class="headerlink" title="OkHttp-DNS功能"></a>OkHttp-DNS功能</h2><h3 id="DNS介绍"><a href="#DNS介绍" class="headerlink" title="DNS介绍"></a>DNS介绍</h3><p><code>Domain Name System</code>：根据域名查出IP地址，是<code>HTTP协议</code>的前提，只有将域名正确的进行解析，得到IP地址后，才可以继续进行网络连接。</p>
<p>DNS服务器结构如下：</p>
<ul>
<li><code>根DNS服务器</code>：返回顶级DNS服务器的IP地址</li>
<li><code>顶级域DNS服务器</code>：返回权威DNS服务器的IP地址</li>
<li><code>权威DNS服务器</code>：返回对应主机的IP地址</li>
</ul>
<p><img src="/images/DNS服务器结构" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="LocalDNS"><a href="#LocalDNS" class="headerlink" title="LocalDNS"></a>LocalDNS</h4><p><img src="/images/OkHttp-LocalDNS.png" srcset="/img/loading.gif" lazyload alt="OkHttp-LocalDNS"></p>
<p><strong>运营商提供的DNS服务器</strong>，请求时优先查询<code>LocalDNS 缓存</code>，存在直接使用。不存在就需要从<code>根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威域名服务器</code>往上查询可用的<code>IP地址</code>。</p>
<p><img src="/images/DNS请求过程" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ol>
<li><p>不稳定</p>
<blockquote>
<p>DNS劫持或者服务器故障，导致解析服务不可用</p>
</blockquote>
</li>
<li><p>不准确</p>
<blockquote>
<p><code>LocalDNS调度</code>不一定是<strong>就近原则</strong>。某些运营商会把解析请求转发到其他运营商的<code>LocalDNS</code>服务器。</p>
<p>就会导致解析出的IP不是就近服务器，致使访问变慢甚至无法访问。</p>
</blockquote>
</li>
<li><p>不及时</p>
<blockquote>
<p>运营商可能修改DNS的<code>TTL(Time-To-Live，DNS缓存时间)</code>，导致DNS解析结构发生修改，但是在当前请求条件下尚未生效。</p>
</blockquote>
</li>
</ol>
<p><img src="/images/640-2236080." srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="HttpDNS"><a href="#HttpDNS" class="headerlink" title="HttpDNS"></a>HttpDNS</h4><p><img src="/images/OkHttp-HTTPDNS.png" srcset="/img/loading.gif" lazyload alt="OkHttp-HTTPDNS"></p>
<p><code>HTTPDNS</code>利用<code>HTTP协议</code>与DNS服务交互，绕开了运营商<code>LocalDNS</code>服务，有效防止了域名劫持以及提高了域名解析成功率。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img src="/images/HTTPDNS原理.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol>
<li>客户端直接访问<code>HttpDNS</code>接口，获取域名在<code>HTTPDNS服务器</code>上的最优IP(从容灾方面考虑，还需要保留<code>LocalDNS</code>请求)</li>
<li>客户端获取到<code>IP</code>后，直接向该<code>IP</code>发起HTTP请求</li>
</ol>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ol>
<li>降低了<code>UnknownHostException</code>异常发生</li>
<li>调度精准，根据用户IP，精准获取域名对应IP</li>
<li>扩展性强，可以自定义域名对应IP规则</li>
</ol>
<h3 id="OkHttp-HttpDNS实现"><a href="#OkHttp-HttpDNS实现" class="headerlink" title="OkHttp-HttpDNS实现"></a>OkHttp-HttpDNS实现</h3><p>OkHttp提供了<code>Dns接口</code>，可以进行自定义拓展替代本身的<code>LocalDNS</code>解析方式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//自定义DNS</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptimizeLocalDNS</span> : <span class="hljs-type">Dns&#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lookup</span><span class="hljs-params">(hostname: <span class="hljs-type">String</span>)</span></span>: List&lt;InetAddress&gt; &#123;<br>        <span class="hljs-keyword">return</span> DNSLookUpUtil.loadLocalDNS(hostname)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//设置LocalDNS超时取消</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadLocalDNS</span><span class="hljs-params">(hostname: <span class="hljs-type">String</span>, timeout: <span class="hljs-type">Long</span> = <span class="hljs-number">10</span>L)</span></span>: List&lt;InetAddress&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">val</span> task = FutureTask&lt;List&lt;InetAddress&gt;&gt;(Callable&lt;List&lt;InetAddress&gt;&gt; &#123;<br>                    <span class="hljs-comment">//返回去重结果</span><br>                    InetAddress.getAllByName(hostname).toList().distinct()<br>                &#125;)<br>                Thread(task).start()<br>                <span class="hljs-keyword">return</span> task.<span class="hljs-keyword">get</span>(timeout, TimeUnit.SECONDS)<br>            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            &#125;<br>            <span class="hljs-keyword">return</span> listOf()<br>        &#125;<br><br><span class="hljs-comment">//设置自定义DNS</span><br>mOkHttpClient = httpBuilder<br>        .dns(OptimizeLocalDNS())<br>        .build();<br></code></pre></td></tr></table></figure>
<h3 id="OkHttp-DNS原理"><a href="#OkHttp-DNS原理" class="headerlink" title="OkHttp-DNS原理"></a>OkHttp-DNS原理</h3><p>配置的<code>dns()</code>初始使用位于<code>RetryAndFollowUpInterceptor.intercept()</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetryAndFollowUpInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>  ...<br>   <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    ...<br>        StreamAllocation streamAllocation = <span class="hljs-keyword">new</span> StreamAllocation(client.connectionPool(),<br>        createAddress(request.url()), call, eventListener, callStackTrace);<br>   &#125;<br>  <br>   <span class="hljs-function"><span class="hljs-keyword">private</span> Address <span class="hljs-title">createAddress</span><span class="hljs-params">(HttpUrl url)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Address(url.host(), url.port(), client.dns(), client.socketFactory(),<br>        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),<br>        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());<br>  &#125;<br> <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>构造出一个<code>Address</code>对象，里面包含了<code>主机名(host)、端口(port)、DNS配置(DNS)、SSL配置(sslSocketFactory,certificatePinner)、代理设置</code></p>
<p>得到<code>Address</code>，通过<code>StreamAllocation</code>构造了<code>RouteSelector</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StreamAllocation</span><span class="hljs-params">(ConnectionPool connectionPool, Address address, Call call,<br>    EventListener eventListener, Object callStackTrace)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>.connectionPool = connectionPool;<br>  <span class="hljs-keyword">this</span>.address = address;<br>  <span class="hljs-keyword">this</span>.call = call;<br>  <span class="hljs-keyword">this</span>.eventListener = eventListener;<br>  <span class="hljs-keyword">this</span>.routeSelector = <span class="hljs-keyword">new</span> RouteSelector(address, routeDatabase(), call, eventListener);<br>  <span class="hljs-keyword">this</span>.callStackTrace = callStackTrace;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>RouteSelector</code>主要为了<strong>Select Route(选择路由)，返回一个可用的<code>Route</code>对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetNextInetSocketAddress</span><span class="hljs-params">(Proxy proxy)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// Clear the addresses. Necessary if getAllByName() below throws!</span><br>    inetSocketAddresses = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    String socketHost;<br>    <span class="hljs-keyword">int</span> socketPort;<br>    <span class="hljs-keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;<span class="hljs-comment">//存在代理</span><br>      socketHost = address.url().host();<br>      socketPort = address.url().port();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      SocketAddress proxyAddress = proxy.address();<br>      <span class="hljs-keyword">if</span> (!(proxyAddress <span class="hljs-keyword">instanceof</span> InetSocketAddress)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>            <span class="hljs-string">"Proxy.address() is not an "</span> + <span class="hljs-string">"InetSocketAddress: "</span> + proxyAddress.getClass());<br>      &#125;<br>      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;<br>      socketHost = getHostString(proxySocketAddress);<br>      socketPort = proxySocketAddress.getPort();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (socketPort &lt; <span class="hljs-number">1</span> || socketPort &gt; <span class="hljs-number">65535</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SocketException(<span class="hljs-string">"No route to "</span> + socketHost + <span class="hljs-string">":"</span> + socketPort<br>          + <span class="hljs-string">"; port is out of range"</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;<span class="hljs-comment">//解析的直接为代理地址</span><br>      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//dns开始解析监听</span><br>      eventListener.dnsStart(call, socketHost);<br><br>      <span class="hljs-comment">// Try each address for best behavior in mixed IPv4/IPv6 environments.</span><br>      List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);<span class="hljs-comment">//通过配置的DNS去解析对应域名的IP列表</span><br>      <span class="hljs-keyword">if</span> (addresses.isEmpty()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownHostException(address.dns() + <span class="hljs-string">" returned no addresses for "</span> + socketHost);<br>      &#125;<br>      <span class="hljs-comment">//dns解析结束监听</span><br>      eventListener.dnsEnd(call, socketHost, addresses);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;<br>        InetAddress inetAddress = addresses.get(i);<br>        inetSocketAddresses.add(<span class="hljs-keyword">new</span> InetSocketAddress(inetAddress, socketPort));<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>resetNextInetSocketAddress()</code>返回<code>List&lt;InetSocketAddress&gt;</code>，区分了一下两种情况</p>
<ul>
<li>设置了<code>proxies</code>代理服务器，直接返回<code>InetSocketAddress(socketHost,socketPort)</code>代理服务器对应的地址和端口</li>
<li>未设置代理服务器，通过设置的<code>dns</code>去解析对应域名(<code>dns.lookup(host)</code>)得到<code>List&lt;InetAddress&gt;</code>对应的IP列表，在返回对应地址</li>
</ul>
<h2 id="OkHttp-HTTP2-0协议支持"><a href="#OkHttp-HTTP2-0协议支持" class="headerlink" title="OkHttp-HTTP2.0协议支持"></a>OkHttp-HTTP2.0协议支持</h2><p><img src="/images/OkHttp-HTTP2.0.png" srcset="/img/loading.gif" lazyload alt="OkHttp-HTTP2.0"></p>
<blockquote>
<p>基于<code>二进制分帧</code>、<code>首部压缩</code>和<code>服务端推送</code>进行分析</p>
</blockquote>
<p>//TODO</p>
<h2 id="OkHttp拓展"><a href="#OkHttp拓展" class="headerlink" title="OkHttp拓展"></a>OkHttp拓展</h2><h3 id="请求时间获取"><a href="#请求时间获取" class="headerlink" title="请求时间获取"></a>请求时间获取</h3><p><img src="/images/OkHttp解析节点" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><code>EventListener</code>是OkHttp提供的监听回调，可以通过实现这个抽象类监听到网络请求各阶段的时间点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventListener</span> </span>&#123;<br>   <span class="hljs-comment">//请求相关回调</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callStart</span><span class="hljs-params">(Call call)</span> </span>&#123;&#125; <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callEnd</span><span class="hljs-params">(Call call)</span> </span>&#123;&#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callFailed</span><span class="hljs-params">(Call call, IOException ioe)</span> </span>&#123;&#125;  <br>  <br>   <span class="hljs-comment">//dns解析回调</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsStart</span><span class="hljs-params">(Call call, String domainName)</span> </span>&#123;&#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsEnd</span><span class="hljs-params">(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList)</span> </span>&#123;&#125;<br>  <br>   <span class="hljs-comment">//请求连接相关回调</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectStart</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy)</span></span>&#123;&#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectEnd</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,@Nullable Protocol protocol)</span> </span>&#123;&#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectFailed</span><span class="hljs-params">(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,<br>      @Nullable Protocol protocol, IOException ioe)</span> </span>&#123;&#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectionAcquired</span><span class="hljs-params">(Call call, Connection connection)</span></span>&#123;&#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectionReleased</span><span class="hljs-params">(Call call, Connection connection)</span></span>&#123;&#125;<br>  <br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="DNS解析耗时"><a href="#DNS解析耗时" class="headerlink" title="DNS解析耗时"></a>DNS解析耗时</h4><p>只要监听<code>dnsStart()</code>和<code>dnsEnd()</code>之间的时间差即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> dnsStartTime;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> dnsDuration = -<span class="hljs-number">1L</span>;    <br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsStart</span><span class="hljs-params">(Call call, String domainName)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.dnsStart(call, domainName);<br>    recordEventLog(<span class="hljs-string">"dnsStart"</span>);<br>    dnsStartTime = System.nanoTime();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dnsEnd</span><span class="hljs-params">(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.dnsEnd(call, domainName, inetAddressList);<br>    recordEventLog(<span class="hljs-string">"dnsEnd"</span>);<br>    dnsDuration = (System.nanoTime() - dnsStartTime) / <span class="hljs-number">1000000</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDnsDuration</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dnsDuration;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>dnsDuration</code>即为DNS解析耗时</p>
<h4 id="请求连接耗时"><a href="#请求连接耗时" class="headerlink" title="请求连接耗时"></a>请求连接耗时</h4><p>初始连接耗时</p>
<blockquote>
<p>使用Socket建立TCP连接，初始连接表示的就是<code>Socket建立连接的过程</code></p>
</blockquote>
<p>只要监听<code>connectStart()</code>和<code>connectEnd()</code>之间的时间差。</p>
<p>复用连接耗时</p>
<blockquote>
<p>OkHttp设置<code>ConnectionPool</code>，可以复用已存在的连接</p>
</blockquote>
<p>需要监听<code>connectAcquired()</code>和<code>connectReleased()</code>之间的时间差</p>
<h3 id="IP直连问题"><a href="#IP直连问题" class="headerlink" title="IP直连问题"></a>IP直连问题</h3><p>//TODO</p>
<h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5a704ed05188255a8817f4c9" target="_blank" rel="noopener">开源框架源码鉴赏：OkHttp</a><br><a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">彻底弄懂HTTP缓存机制及原理</a></p>
<p><a href="https://mp.weixin.qq.com/s/iaPtSF-twWz-AN66UJUBDg" target="_blank" rel="noopener">百度App网络深度优化系列《一》DNS优化</a></p>
<p><a href="https://juejin.im/post/6844903785232498696#heading-4" target="_blank" rel="noopener">HTTP2.0相关</a></p>
<p><a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener">HPACK算法</a></p>
<p><a href="https://sq.163yun.com/blog/article/188769987293102080" target="_blank" rel="noopener">HTTP/2首部压缩的OkHttp3实现</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/源码解析/">源码解析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/03/12/WebView相关知识/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">WebView相关知识</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/03/08/Retrofit简析/">
                        <span class="hidden-mobile">Retrofit简析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>
  




















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
