

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
  <title>OkHttp简析 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.10","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="OkHttp简析">
              
                OkHttp简析
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-03-08 10:18" pubdate>
        2019年3月8日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      208
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">OkHttp简析</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>基于OkHttp 3.13版本进行分析</p>
</blockquote>
<p><img src="/images/OkHttp简析mind.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp简析"></p>
<h2 id="OkHttp定义"><a href="#OkHttp定义" class="headerlink" title="OkHttp定义"></a>OkHttp定义</h2><p><code>OkHttp</code>现如今已成为主流的网络请求框架，连Android源码中都引入其作为基础网络库，可知它的重要性。</p>
<p>所以只会简单的使用是远远不够的，更要深入了解其原理，知道它的设计概念，这才是最重要的。</p>
<p>OkHttp支持<code>SPDY协议</code>，可以合并多个到同一个主机的请求，分享同一个Socket。如果SPDY不可用，会使用连接池的技术减少请求的延迟。</p>
<blockquote>
<p><code>SPDY协议</code>：Google提出的基于TCP的应用层协议，通过<code>压缩、多路复用、优先级</code>来缩短加载时间。</p>
</blockquote>
<h2 id="OkHttp使用示例"><a href="#OkHttp使用示例" class="headerlink" title="OkHttp使用示例"></a>OkHttp使用示例</h2><h3 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Request request = new Request.Builder()<br>     .url(url)<br>     .build();<br></code></pre></td></tr></table></figure>
<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">RequestBody body = RequestBody.create(JSON, json);<br>Request request = new Request.Builder()<br>    .url(url)<br>    .post(body)<br>    .build();<br></code></pre></td></tr></table></figure>
<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client = new OkHttpClient();<br>Response response = client.newCall(request).execute();<br>return response.body().string();<br></code></pre></td></tr></table></figure>
<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client = new OkHttpClient();<br><br>client.newCall(request).enqueue(new Callback() &#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onFailure(Call call, IOException e) &#123;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onResponse(Call call, okhttp3.Response response) <span class="hljs-keyword">throws</span> IOException &#123;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h2 id="OkHttp源码分析"><a href="#OkHttp源码分析" class="headerlink" title="OkHttp源码分析"></a>OkHttp源码分析</h2><h3 id="构造OkHttpClient对象"><a href="#构造OkHttpClient对象" class="headerlink" title="构造OkHttpClient对象"></a>构造<code>OkHttpClient</code>对象</h3><p><img src="/images/OkHttp-构造OkHttpClient对象.png" srcset="/img/loading.gif" lazyload="" alt="构造OkHttpClient对象"></p>
<blockquote>
<p>需要先创建一个<code>OkHttpClient</code>用以执行后续请求。<strong>内部主要是相关参数配置。</strong></p>
<p>主要功能：通信的客户端，用以统一发起请求与解析返回值。</p>
</blockquote>
<figure class="highlight java"><figcaption><span>OkHttpClient.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> OkHttpClient() &#123;<br>  <span class="hljs-keyword">this</span>(new Builder());<br>&#125;<br><br>OkHttpClient(Builder builder) &#123;<br>  //用于调用网络请求 本质为 线程池<br>  <span class="hljs-keyword">this</span>.dispatcher = builder.dispatcher;<br>  //设置代理<br>  <span class="hljs-keyword">this</span>.proxy = builder.proxy;<br>  //设置协议<br>  <span class="hljs-keyword">this</span>.protocols = builder.protocols;<br>  <span class="hljs-keyword">this</span>.connectionSpecs = builder.connectionSpecs;<br>  //设置拦截器<br>  <span class="hljs-keyword">this</span>.interceptors = Util.immutableList(builder.interceptors);<br>  //设置网络拦截器<br>  <span class="hljs-keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors);<br>  //回调监听<br>  <span class="hljs-keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;<br>  <span class="hljs-keyword">this</span>.proxySelector = builder.proxySelector;<br>  //Cookie<br>  <span class="hljs-keyword">this</span>.cookieJar = builder.cookieJar;<br>  //缓存<br>  <span class="hljs-keyword">this</span>.cache = builder.cache;<br>  <span class="hljs-keyword">this</span>.internalCache = builder.internalCache;<br>  <span class="hljs-keyword">this</span>.socketFactory = builder.socketFactory;<br><br>  <span class="hljs-keyword">boolean</span> isTLS = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;<br>    isTLS = isTLS || spec.isTls();<br>  &#125;<br><br>  //用于Https请求<br>  <span class="hljs-keyword">if</span> (builder.sslSocketFactory != <span class="hljs-keyword">null</span> || !isTLS) &#123;<br>    <span class="hljs-keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;<br>    <span class="hljs-keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    X509TrustManager trustManager = Util.platformTrustManager();<br>    <span class="hljs-keyword">this</span>.sslSocketFactory = newSslSocketFactory(trustManager);<br>    <span class="hljs-keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (sslSocketFactory != <span class="hljs-keyword">null</span>) &#123;<br>    Platform.get().configureSslSocketFactory(sslSocketFactory);<br>  &#125;<br><br>  <span class="hljs-keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;<br>  <span class="hljs-keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(<br>      certificateChainCleaner);<br>  <span class="hljs-keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;<br>  <span class="hljs-keyword">this</span>.authenticator = builder.authenticator;<br>  <span class="hljs-keyword">this</span>.connectionPool = builder.connectionPool;<br>  <span class="hljs-keyword">this</span>.dns = builder.dns;<br>  <span class="hljs-keyword">this</span>.followSslRedirects = builder.followSslRedirects;<br>  <span class="hljs-keyword">this</span>.followRedirects = builder.followRedirects;<br>  //是否需要重试<br>  <span class="hljs-keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;<br>  <span class="hljs-keyword">this</span>.callTimeout = builder.callTimeout;<br>  //链接超时时长<br>  <span class="hljs-keyword">this</span>.connectTimeout = builder.connectTimeout;<br>  //读取超时时间<br>  <span class="hljs-keyword">this</span>.readTimeout = builder.readTimeout;<br>  //写入超时时间<br>  <span class="hljs-keyword">this</span>.writeTimeout = builder.writeTimeout;<br>  <span class="hljs-keyword">this</span>.pingInterval = builder.pingInterval;<br><br>  <span class="hljs-keyword">if</span> (interceptors.contains(<span class="hljs-keyword">null</span>)) &#123;<br>    throw new IllegalStateException("Null interceptor: " + interceptors);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (networkInterceptors.contains(<span class="hljs-keyword">null</span>)) &#123;<br>    throw new IllegalStateException("Null network interceptor: " + networkInterceptors);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>OkHttpClient</code>是应用<strong>建造者模式</strong>，通过<code>OkHttpClient.Builder</code>来构造一个<code>OkHttpClient</code>对象，支持数十种参数配置。</p>
<h3 id="构造Request请求对象"><a href="#构造Request请求对象" class="headerlink" title="构造Request请求对象"></a>构造<code>Request</code>请求对象</h3><p><img src="/images/OkHttp-构造Request请求对象.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-构造Request请求对象"></p>
<blockquote>
<p>创建一个<code>Request</code>对象用以包括请求的所有信息，内部包含了<strong>请求地址，请求头，请求内容</strong>。</p>
<p>主要功能：封装请求的具体信息。</p>
</blockquote>
<figure class="highlight java"><figcaption><span>Request.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class Request &#123;<br>  Request(Builder builder) &#123;<br>    //请求地址<br>    <span class="hljs-keyword">this</span>.url = builder.url;<br>    //请求方法 例如：GET、POST、PUT、DELETE等<br>    <span class="hljs-keyword">this</span>.method = builder.method;<br>    //请求头信息<br>    <span class="hljs-keyword">this</span>.headers = builder.headers.build();<br>    //请求内容构造体<br>    <span class="hljs-keyword">this</span>.body = builder.body;<br>    //请求的标签  用于后续对指定标签可进行特殊处理<br>    <span class="hljs-keyword">this</span>.tags = Util.immutableMap(builder.tags);<br>  &#125;<br>    <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> class Builder &#123;<br>    @Nullable HttpUrl url;<br>    String method;<br>    Headers.Builder headers;<br>    @Nullable RequestBody body;<br><br>    /** A mutable map of tags, or an immutable empty map <span class="hljs-keyword">if</span> we don't have any. */<br>    Map&lt;Class&lt;?&gt;, Object&gt; tags = Collections.emptyMap();<br>    <br>    //默认是GET方法，不带有请求体<br>    <span class="hljs-keyword">public</span> Builder() &#123;<br>      <span class="hljs-keyword">this</span>.method = "GET";<br>      <span class="hljs-keyword">this</span>.headers = new Headers.Builder();<br>    &#125;<br><br>    Builder(Request request) &#123;<br>      <span class="hljs-keyword">this</span>.url = request.url;<br>      <span class="hljs-keyword">this</span>.method = request.method;<br>      <span class="hljs-keyword">this</span>.body = request.body;<br>      <span class="hljs-keyword">this</span>.tags = request.tags.isEmpty()<br>          ? Collections.emptyMap()<br>          : new LinkedHashMap&lt;&gt;(request.tags);<br>      <span class="hljs-keyword">this</span>.headers = request.headers.newBuilder();<br>    &#125;<br>     ... <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Request</code>使用的也是<strong>建造者模式</strong>，通过<code>Request.Builder</code>去构造对应<code>Request</code>。</p>
<h4 id="请求体RequestBody"><a href="#请求体RequestBody" class="headerlink" title="请求体RequestBody"></a>请求体<code>RequestBody</code></h4><blockquote>
<p>主要功能：用以提交<strong>流、表单等请求信息</strong>。</p>
</blockquote>
<h5 id="FormBody"><a href="#FormBody" class="headerlink" title="FormBody"></a>FormBody</h5><blockquote>
<p>支持提交键值对类型。例如<code>userId : 1</code></p>
</blockquote>
<p>使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">FormBody.Builder formBodyBuilder = new FormBody.Builder();<br>Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;&gt;();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;<br>    formBodyBuilder.add(entry.getKey(), entry.getValue().toString());<br>&#125;<br>RequestBody body = formBodyBuilder.build();<br></code></pre></td></tr></table></figure>
<h5 id="MultipartBody"><a href="#MultipartBody" class="headerlink" title="MultipartBody"></a>MultipartBody</h5><blockquote>
<p>除了支持键值对，还有提交文件功能。</p>
</blockquote>
<p>使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);<br>       Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;&gt;();<br>       <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;<br>           multipartBuilder.addFormDataPart(entry.getKey(), entry.getValue().toString());<br>       &#125;<br>       //可以针对文件新起一个 参数来进行传递<br>       <span class="hljs-keyword">for</span> (Map.Entry&lt;String, File&gt; entry : message.getFiles().entrySet()) &#123;<br>           File f = entry.getValue();<br>           <span class="hljs-keyword">if</span> (f == <span class="hljs-keyword">null</span>)<br>               <span class="hljs-keyword">continue</span>;<br>           String name = f.getName();<br>           String ext = name.substring(name.lastIndexOf('.'));<br>           String imageFormat = "jpg";<br>           <span class="hljs-keyword">if</span> (".png".equalsIgnoreCase(ext)) &#123;<br>               imageFormat = "png";<br>           &#125;<br>           multipartBuilder.addFormDataPart(<br>                   entry.getKey(),<br>                   entry.getValue().getName(),<br>                   RequestBody.create(MediaType.parse("image/" + imageFormat), entry.getValue())<br>           );<br>       &#125;<br><br>       RequestBody body = multipartBuilder.build();<br></code></pre></td></tr></table></figure>
<h3 id="发送Request请求"><a href="#发送Request请求" class="headerlink" title="发送Request请求"></a>发送<code>Request</code>请求</h3><p><img src="/images/OkHttp-发送Request请求.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-发送Request请求"></p>
<p>通过<code>OkHttpClient.newCall()</code>发送出<code>Request</code>请求</p>
<figure class="highlight java"><figcaption><span>OkHttpClient.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">@Override <span class="hljs-keyword">public</span> Call newCall(Request request) &#123;<br>  return RealCall.newRealCall(<span class="hljs-keyword">this</span>, request, <span class="hljs-keyword">false</span> /* <span class="hljs-keyword">for</span> web socket */);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>返回了一个<code>Call</code>对象，实现类为<code>RealCall</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> interface Call extends Cloneable &#123;<br>  //获取当前请求<br>  Request request();<br>  //执行当前请求 并返回结果<br>  Response execute() <span class="hljs-keyword">throws</span> IOException;<br>  //异步请求<br>  <span class="hljs-keyword">void</span> enqueue(Callback responseCallback);<br>  //取消请求<br>  /** Cancels the request, <span class="hljs-keyword">if</span> possible. Requests that are already complete cannot be canceled. */<br>  <span class="hljs-keyword">void</span> cancel();<br>  //当前请求是否正在执行<br>  <span class="hljs-keyword">boolean</span> isExecuted();<br>  //请求是否已取消<br>  <span class="hljs-keyword">boolean</span> isCanceled();<br>  //超时返回<br>  Timeout timeout();<br>  //克隆请求 用于重新调用<br>  Call clone();<br><br>  interface Factory &#123;<br>    Call newCall(Request request);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>RealCall.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> class RealCall implements Call &#123;<br>    <span class="hljs-keyword">private</span> RealCall(OkHttpClient client, Request originalRequest, <span class="hljs-keyword">boolean</span> forWebSocket) &#123;<br>    	//前面先行创建的 OkHttpClient<br>    	<span class="hljs-keyword">this</span>.client = client;<br>        //创建的请求对象<br>    	<span class="hljs-keyword">this</span>.originalRequest = originalRequest;<br>   		//用于建立长连接<br>    	<span class="hljs-keyword">this</span>.forWebSocket = forWebSocket;<br>  	&#125;<br>    <br>    <span class="hljs-keyword">static</span> RealCall newRealCall(OkHttpClient client, Request originalRequest, <span class="hljs-keyword">boolean</span> forWebSocket) &#123;<br>    	// Safely publish the Call instance to the EventListener.<br>    	RealCall call = new RealCall(client, originalRequest, forWebSocket);<br>        //为这次请求设置了事件监听器，包括请求开始、结束、异常等监听<br>    	call.transmitter = new Transmitter(client, call);<br>    	return call;<br>  	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>newCall()</code>根据传递进来的<code>Request</code>创建一个<code>RealCall</code>实例去发送请求。</p>
<h4 id="同步请求——execute"><a href="#同步请求——execute" class="headerlink" title="同步请求——execute()"></a>同步请求——execute()</h4><blockquote>
<p>直接执行并返回请求结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">@Override <span class="hljs-keyword">public</span> Response execute() <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (executed) throw new IllegalStateException("Already Executed");<br>      executed = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    transmitter.timeoutEnter();<br>    //请求开始<br>    transmitter.callStart();<br>    <span class="hljs-keyword">try</span> &#123;<br>      //加入 runningSuncCalls 队列中<br>      client.dispatcher().executed(<span class="hljs-keyword">this</span>);<br>      //返回响应结果<br>      return getResponseWithInterceptorChain();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      //从队列中移除 避免重复执行<br>      client.dispatcher().finished(<span class="hljs-keyword">this</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>执行<code>execute()</code>时，监听到请求事件开始，就会加入到<code>Dispatcher.runningSyncCalls</code>中，里面记录的是当前正在进行同步请求的call，然后当call完成时或因异常结束时，再从<code>Dispatcher.runningSyncCalls</code>移除。</p>
</blockquote>
<h4 id="异步请求——enqueue-Callback-callback"><a href="#异步请求——enqueue-Callback-callback" class="headerlink" title="异步请求——enqueue(Callback callback)"></a>异步请求——enqueue(Callback callback)</h4><blockquote>
<p>构造一个异步执行队列，然后把请求加入队列中处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java">  @Override <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> enqueue(Callback responseCallback) &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (executed) throw new IllegalStateException("Already Executed");<br>      executed = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    transmitter.callStart();<br>    client.dispatcher().enqueue(new AsyncCall(responseCallback));<br>  &#125;<br><br><span class="hljs-keyword">final</span> class AsyncCall extends NamedRunnable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Callback responseCallback;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> AtomicInteger callsPerHost = new AtomicInteger(0);<br><br>    AsyncCall(Callback responseCallback) &#123;<br>      <span class="hljs-keyword">super</span>("OkHttp %s", redactedUrl());<br>      <span class="hljs-keyword">this</span>.responseCallback = responseCallback;<br>    &#125;<br><br>    AtomicInteger callsPerHost() &#123;<br>      return callsPerHost;<br>    &#125;<br>    ...<br><br>    <span class="hljs-keyword">void</span> executeOn(ExecutorService executorService) &#123;<br>      <span class="hljs-keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));<br>      <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        executorService.execute(<span class="hljs-keyword">this</span>);<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>        InterruptedIOException ioException = new InterruptedIOException("executor rejected");<br>        ioException.initCause(e);<br>        transmitter.noMoreExchanges(ioException);<br>        responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, ioException);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>          client.dispatcher().finished(<span class="hljs-keyword">this</span>); // This call is no longer running!<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    @Override <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> execute() &#123;<br>      <span class="hljs-keyword">boolean</span> signalledCallback = <span class="hljs-keyword">false</span>;<br>      transmitter.timeoutEnter();<br>      <span class="hljs-keyword">try</span> &#123;<br>        Response response = getResponseWithInterceptorChain();<br>        signalledCallback = <span class="hljs-keyword">true</span>;<br>        //回调请求结果<br>        responseCallback.onResponse(RealCall.<span class="hljs-keyword">this</span>, response);<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">if</span> (signalledCallback) &#123;<br>          // Do not signal the callback twice!<br>          Platform.get().log(INFO, "Callback failure <span class="hljs-keyword">for</span> " + toLoggableString(), e);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          //回调失败并返回异常<br>          responseCallback.onFailure(RealCall.<span class="hljs-keyword">this</span>, e);<br>        &#125;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        //从队列中移除<br>        client.dispatcher().finished(<span class="hljs-keyword">this</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>enqueue()</code>调用到<code>Dispatcher.enqueue()</code>传入的是一个<code>AsyncCall</code>对象，<code>AsyncCall</code>本质是一个<code>Runnable</code>对象，通过<code>Dispatcher</code>中的<code>ExecutorService</code>来执行<code>AsyncCall</code>。</p>
</blockquote>
<h3 id="执行Request请求"><a href="#执行Request请求" class="headerlink" title="执行Request请求"></a>执行<code>Request</code>请求</h3><blockquote>
<p>由<code>execute()</code>或<code>enqueue()</code>发送请求时，最后都是需要有<code>Dispatch</code>去执行请求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class Dispatcher &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxRequests = 64;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxRequestsPerHost = 5;<br>    <br>  <span class="hljs-keyword">private</span> @Nullable ExecutorService executorService;<br>  //正在准备执行的异步请求队列<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();<br>  //正在执行的异步请求队列<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();<br>  //正在执行的同步请求队列 <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();<br>    <br>  //用以执行异步请求<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> ExecutorService executorService() &#123;<br>    <span class="hljs-keyword">if</span> (executorService == <span class="hljs-keyword">null</span>) &#123;<br>      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,<br>          new SynchronousQueue&lt;&gt;(), Util.threadFactory("OkHttp Dispatcher", <span class="hljs-keyword">false</span>));<br>    &#125;<br>    return executorService;<br>  &#125;<br>    <br>  <span class="hljs-keyword">void</span> enqueue(AsyncCall call) &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      //加入正在执行的异步队列中<br>      readyAsyncCalls.add(call);<br><br>      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to<br>      // the same host.<br>      <span class="hljs-keyword">if</span> (!call.get().forWebSocket) &#123;<br>        AsyncCall existingCall = findExistingCallWithHost(call.host());<br>        <span class="hljs-keyword">if</span> (existingCall != <span class="hljs-keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);<br>      &#125;<br>    &#125;<br>    promoteAndExecute();<br>  &#125;<br>    <br>  //加入正在执行的同步队列<br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> executed(RealCall call) &#123;<br>    runningSyncCalls.add(call);<br>  &#125;<br>  //从政在执行的异步队列中移除  <br>  <span class="hljs-keyword">void</span> finished(AsyncCall call) &#123;<br>    call.callsPerHost().decrementAndGet();<br>    finished(runningAsyncCalls, call);<br>  &#125;<br>  //执行完毕后  从正在执行的同步队列中移除<br>  <span class="hljs-keyword">void</span> finished(RealCall call) &#123;<br>    finished(runningSyncCalls, call);<br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-keyword">void</span> finished(Deque&lt;T&gt; calls, T call) &#123;<br>    Runnable idleCallback;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");<br>      idleCallback = <span class="hljs-keyword">this</span>.idleCallback;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> isRunning = promoteAndExecute();<br>    <span class="hljs-keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="hljs-keyword">null</span>) &#123;<br>      idleCallback.run();<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> promoteAndExecute() &#123;<br>    //判定当前线程是否持有锁<br>    <span class="hljs-keyword">assert</span> (!Thread.holdsLock(<span class="hljs-keyword">this</span>));<br><br>    List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">boolean</span> isRunning;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      <br>      <span class="hljs-keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;<br>        AsyncCall asyncCall = i.next();<br>        //正在运行的异步请求不能超过 64个<br>        <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="hljs-keyword">break</span>; // Max capacity.<br>        //在同一个Host下的异步请求不能超过5个<br>        <span class="hljs-keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="hljs-keyword">continue</span>; // Host max capacity.<br><br>        i.remove();<br>        //CAS<br>        asyncCall.callsPerHost().incrementAndGet();<br>        //添加至异步执行队列<br>        executableCalls.add(asyncCall);<br>        //添加至正在执行异步请求队列<br>        runningAsyncCalls.add(asyncCall);<br>      &#125;<br>      isRunning = runningCallsCount() &gt; 0;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0, size = executableCalls.size(); i &lt; size; i++) &#123;<br>      AsyncCall asyncCall = executableCalls.get(i);<br>      //执行异步请求<br>      asyncCall.executeOn(executorService());<br>    &#125;<br><br>    return isRunning;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Dispatcher</code>是一个任务调度器，内部维护了三个双端队列：</p>
<ul>
<li><code>readyAsyncCalls</code>：准备执行的异步请求。<em>已经超过请求上限的异步请求就会放在该队列中。</em></li>
<li><code>runningAsyncCalls</code>：正在执行的异步请求。<em>不超过请求上限时，异步请求会加入到该队列中，超过时，依然放到<code>readyAsyncCalls</code>中。</em></li>
<li><code>runningSyncCalls</code>：正在执行的同步请求。<em>直接把同步请求添加到该队列中。</em></li>
</ul>
<p>通过<code>Dispatcher</code>中的<code>executorService</code>去执行对应请求。</p>
<h3 id="处理Request请求——通过拦截器"><a href="#处理Request请求——通过拦截器" class="headerlink" title="处理Request请求——通过拦截器"></a>处理<code>Request</code>请求——通过拦截器</h3><p><img src="/images/OkHttp-处理Request请求.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-处理Request请求"></p>
<blockquote>
<p>通过<code>Dispatcher</code>执行完请求后，返回回调结果前，需要通过<code>getResponseWithInterceptorChain()</code>通过层层责任链的执行来获得最终的请求结果。</p>
<p><strong>通过责任链模式将请求一层层的通过拦截器进行处理。</strong></p>
</blockquote>
<figure class="highlight java"><figcaption><span>RealCall.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">Response getResponseWithInterceptorChain() <span class="hljs-keyword">throws</span> IOException &#123;<br>    // Build a full stack of interceptors.<br>    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();<br>    //加入用户自定义的拦截器<br>    interceptors.addAll(client.interceptors());<br>    //重试和重定向拦截器<br>    interceptors.add(new RetryAndFollowUpInterceptor(client));<br>    //转化用户请求为网络请求<br>    interceptors.add(new BridgeInterceptor(client.cookieJar()));<br>    //负责读取缓存以及更新缓存<br>    interceptors.add(new CacheInterceptor(client.internalCache()));<br>    //与服务器建立连接<br>    interceptors.add(new ConnectInterceptor(client));<br>    <span class="hljs-keyword">if</span> (!forWebSocket) &#123;<br>       //用户自定义的网络拦截器<br>      interceptors.addAll(client.networkInterceptors());<br>    &#125;<br>    //从服务器读取响应的数据<br>    interceptors.add(new CallServerInterceptor(forWebSocket));<br><br>    Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, <span class="hljs-keyword">null</span>, 0,<br>        originalRequest, <span class="hljs-keyword">this</span>, client.connectTimeoutMillis(),<br>        client.readTimeoutMillis(), client.writeTimeoutMillis());<br><br>    <span class="hljs-keyword">boolean</span> calledNoMoreExchanges = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      //链式调用拦截器，最终返回 Response<br>      Response response = chain.proceed(originalRequest);<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;<br>        closeQuietly(response);<br>        throw new IOException("Canceled");<br>      &#125;<br>      return response;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      calledNoMoreExchanges = <span class="hljs-keyword">true</span>;<br>      throw transmitter.noMoreExchanges(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;<br>        transmitter.noMoreExchanges(<span class="hljs-keyword">null</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>在获得响应结果之前，需要对用户设置的原始请求转换为实际的网络请求，然后通过一系列拦截器，直到最终得到结果，采用<strong>链式调用</strong>保证这些拦截器的执行顺序。</p>
<h4 id="OkHttp拦截器"><a href="#OkHttp拦截器" class="headerlink" title="OkHttp拦截器"></a>OkHttp拦截器</h4><blockquote>
<p>所有的拦截器都实现了<code>Interceptor</code>接口，支持用户去自定义拦截器，只要实现<code>Interceptor</code>接口即可。</p>
<p>拦截器可以 用来<em>监控、改写和重试HTTP访问</em>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> interface Interceptor &#123;<br>  //主要实现该接口，控制返回结果<br>  Response intercept(Chain chain) <span class="hljs-keyword">throws</span> IOException;<br><br>  interface Chain &#123;<br>    <br>    Request request();<br><br>    Response proceed(Request request) <span class="hljs-keyword">throws</span> IOException;<br><br>    //返回Request执行后的返回结果<br>    @Nullable Connection connection();<br><br>    Call call();<br><br>    <span class="hljs-keyword">int</span> connectTimeoutMillis();<br><br>    Chain withConnectTimeout(<span class="hljs-keyword">int</span> timeout, TimeUnit unit);<br><br>    <span class="hljs-keyword">int</span> readTimeoutMillis();<br><br>    Chain withReadTimeout(<span class="hljs-keyword">int</span> timeout, TimeUnit unit);<br><br>    <span class="hljs-keyword">int</span> writeTimeoutMillis();<br><br>    Chain withWriteTimeout(<span class="hljs-keyword">int</span> timeout, TimeUnit unit);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="ApplicationInterceptor"><a href="#ApplicationInterceptor" class="headerlink" title="ApplicationInterceptor"></a><code>ApplicationInterceptor</code></h5><p><img src="/images/OkHttp-ApplicationInterceptor.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-ApplicationInterceptor"></p>
<blockquote>
<p>该拦截器会被第一个执行，此处得到的<code>Request</code>为最原始状态。但是最终得到的<code>Response</code>是最终的结果。</p>
</blockquote>
<p>引用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client = new OkHttpClient.Builder()<br>    .addInterceptor(new LoggingInterceptor())<br>    .build();<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>ApplicationInterceptor</code>适用于在请求前统一添加一些公共参数，例如<code>App的版本号，系统信息</code>等。</p>
<p>也可用于对返回的<code>Response</code>进行加工。</p>
</blockquote>
<p><code>ApplicationInterceptor</code>有以下特定：</p>
<ul>
<li>不需要关心后续拦截器进行的操作，因为是会被第一个执行的，只要关心返回结果即可。</li>
<li>只会被响应一次，即使强制缓存获取</li>
<li>可以对后续的拦截器调用进行拦截或者进行多次调用——<strong>通过<code>Chain.proceed()</code>进行控制</strong></li>
</ul>
<h5 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a><code>RetryAndFollowUpInterceptor</code></h5><p><img src="/images/OkHttp-RetryAndFollowUpInterceptor.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-RetryAndFollowUpInterceptor"></p>
<blockquote>
<p>负责失败重试和重定向的拦截器。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class RetryAndFollowUpInterceptor implements Interceptor &#123;<br>    @Override <span class="hljs-keyword">public</span> Response intercept(Chain chain) <span class="hljs-keyword">throws</span> IOException &#123;<br>    //从自定义拦截器 那里传递下来的请求<br>    Request request = chain.request();<br>    RealInterceptorChain realChain = (RealInterceptorChain) chain;<br>    //获取事件监听器<br>    Transmitter transmitter = realChain.transmitter();<br>    //初始化 重定向次数<br>    <span class="hljs-keyword">int</span> followUpCount = 0;<br>    Response priorResponse = <span class="hljs-keyword">null</span>;<br>    //开启死循环 进行重试操作<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      transmitter.prepareToConnect(request);<br>      //请求取消<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;<br>        throw new IOException("Canceled");<br>      &#125;<br><br>      Response response;<br>      <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        //向下调用 下一个拦截器——BridgeInterceptor<br>        response = realChain.proceed(request, transmitter, <span class="hljs-keyword">null</span>);<br>        success = <span class="hljs-keyword">true</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (RouteException e) &#123;<br>        // 不需要重试 则抛出异常<br>        <span class="hljs-keyword">if</span> (!recover(e.getLastConnectException(), transmitter, <span class="hljs-keyword">false</span>, request)) &#123;<br>          throw e.getFirstConnectException();<br>        &#125;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        // 无法与服务端建立连接<br>        <span class="hljs-keyword">boolean</span> requestSendStarted = !(e <span class="hljs-keyword">instanceof</span> ConnectionShutdownException);<br>        <span class="hljs-keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) throw e;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        // The network call threw an exception. Release any resources.<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>          //释放资源<br>          transmitter.exchangeDoneDueToException();<br>        &#125;<br>      &#125;<br><br>      // Attach the prior response <span class="hljs-keyword">if</span> it exists. Such responses never have a body.<br>      <span class="hljs-keyword">if</span> (priorResponse != <span class="hljs-keyword">null</span>) &#123;<br>        response = response.newBuilder()<br>            .priorResponse(priorResponse.newBuilder()<br>                    .body(<span class="hljs-keyword">null</span>)<br>                    .build())<br>            .build();<br>      &#125;<br><br>      Exchange exchange = Internal.instance.exchange(response);<br>      Route route = exchange != <span class="hljs-keyword">null</span> ? exchange.connection().route() : <span class="hljs-keyword">null</span>;<br>      //根据返回的 response的Code 判断是否需要进行重定向<br>      Request followUp = followUpRequest(response, route);<br><br>      <span class="hljs-keyword">if</span> (followUp == <span class="hljs-keyword">null</span>) &#123;<br>        //释放资源<br>        <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span> &amp;&amp; exchange.isDuplex()) &#123;<br>          transmitter.timeoutEarlyExit();<br>        &#125;<br>        return response;<br>      &#125;<br><br>      RequestBody followUpBody = followUp.body();<br>      <span class="hljs-keyword">if</span> (followUpBody != <span class="hljs-keyword">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;<br>        return response;<br>      &#125;<br><br>      closeQuietly(response.body());<br>      <span class="hljs-keyword">if</span> (transmitter.hasExchange()) &#123;<br>        exchange.detachWithViolence();<br>      &#125;<br><br>      //超出重定向次数<br>      <span class="hljs-keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;<br>        throw new ProtocolException("Too many follow-up requests: " + followUpCount);<br>      &#125;<br>      //获取重定向结果 赋予 request继续向下请求<br>      request = followUp;<br>      priorResponse = response;<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> recover(IOException e, Transmitter transmitter,<br>      <span class="hljs-keyword">boolean</span> requestSendStarted, Request userRequest) &#123;<br>    // 未开启重试 retryOnConnectionFailure(<span class="hljs-keyword">false</span>)<br>    <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure()) return <span class="hljs-keyword">false</span>;<br>    // 只允许发送一次 isOneShot()&#123;return <span class="hljs-keyword">true</span>;&#125;<br>    <span class="hljs-keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return <span class="hljs-keyword">false</span>;<br>    // 发生异常<br>    <span class="hljs-keyword">if</span> (!isRecoverable(e, requestSendStarted)) return <span class="hljs-keyword">false</span>;<br>    // 设置不允许重试<br>    <span class="hljs-keyword">if</span> (!transmitter.canRetry()) return <span class="hljs-keyword">false</span>;<br>    return <span class="hljs-keyword">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>尝试执行下一个拦截器，即<code>BridgeInterceptor</code></li>
<li>抛出异常，需要根据以下情况去判断是否需要重试：<ul>
<li>客户端是否开启  <code>retryOnConnectionFailure</code></li>
<li><code>RequestBody.isOneShot()</code>返回值</li>
<li>判断异常类型，除了<code>ConnectionShutdownException</code>被中断情况外的<code>IOException</code>的子类，都不会进行重试</li>
</ul>
</li>
<li>根据Response返回的响应码<code>code</code>进行处理</li>
</ol>
</blockquote>
<figure class="highlight java"><figcaption><span>RetryAndFollowUpInterceptor.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Request followUpRequest(Response userResponse, @Nullable Route route) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (userResponse == <span class="hljs-keyword">null</span>) throw new IllegalStateException();<br>    <span class="hljs-keyword">int</span> responseCode = userResponse.code();<br><br>    <span class="hljs-keyword">final</span> String method = userResponse.request().method();<br>    <span class="hljs-keyword">switch</span> (responseCode) &#123;<br>      // 407 需要进行代理认证<br>      <span class="hljs-keyword">case</span> HTTP_PROXY_AUTH:<br>        Proxy selectedProxy = route != <span class="hljs-keyword">null</span><br>            ? route.proxy()<br>            : client.proxy();<br>        <span class="hljs-keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;<br>          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code <span class="hljs-keyword">while</span> not using proxy");<br>        &#125;<br>        return client.proxyAuthenticator().authenticate(route, userResponse);<br>      // 401 未经认证<br>      <span class="hljs-keyword">case</span> HTTP_UNAUTHORIZED:<br>        return client.authenticator().authenticate(route, userResponse);<br>      // 301 永久重定向  302 临时重定向  只有GET、HEAD请求方法才有效<br>      <span class="hljs-keyword">case</span> HTTP_PERM_REDIRECT:<br>      <span class="hljs-keyword">case</span> HTTP_TEMP_REDIRECT:<br>        // "If the 307 or 308 status code is received in response to a request other than GET<br>        // or HEAD, the user agent MUST NOT automatically redirect the request"<br>        <span class="hljs-keyword">if</span> (!method.equals("GET") &amp;&amp; !method.equals("HEAD")) &#123;<br>          return <span class="hljs-keyword">null</span>;<br>        &#125;<br>        // fall-through<br>      <br>      <span class="hljs-keyword">case</span> HTTP_MULT_CHOICE:// 300  多个重定向地址<br>      <span class="hljs-keyword">case</span> HTTP_MOVED_PERM:// 301 永久移除 指向了新的位置<br>      <span class="hljs-keyword">case</span> HTTP_MOVED_TEMP://302  临时移除<br>      <span class="hljs-keyword">case</span> HTTP_SEE_OTHER://303 查看其他位置<br>        // 开发者是否允许重定向<br>        <span class="hljs-keyword">if</span> (!client.followRedirects()) return <span class="hljs-keyword">null</span>;<br>        //重定向后的实际地址<br>        String location = userResponse.header("Location");<br>        <span class="hljs-keyword">if</span> (location == <span class="hljs-keyword">null</span>) return <span class="hljs-keyword">null</span>;<br>        HttpUrl url = userResponse.request().url().resolve(location);<br><br>        // Don't follow redirects to unsupported protocols.<br>        <span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) return <span class="hljs-keyword">null</span>;<br><br>        // If configured, don't follow redirects between SSL and non-SSL.<br>        <span class="hljs-keyword">boolean</span> sameScheme = url.scheme().equals(userResponse.request().url().scheme());<br>        <span class="hljs-keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) return <span class="hljs-keyword">null</span>;<br><br>        // Most redirects don't include a request body.<br>        Request.Builder requestBuilder = userResponse.request().newBuilder();<br>        <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;<br>          <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> maintainBody = HttpMethod.redirectsWithBody(method);<br>          <span class="hljs-keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;<br>            requestBuilder.method("GET", <span class="hljs-keyword">null</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            RequestBody requestBody = maintainBody ? userResponse.request().body() : <span class="hljs-keyword">null</span>;<br>            requestBuilder.method(method, requestBody);<br>          &#125;<br>          <span class="hljs-keyword">if</span> (!maintainBody) &#123;<br>            requestBuilder.removeHeader("Transfer-Encoding");<br>            requestBuilder.removeHeader("Content-Length");<br>            requestBuilder.removeHeader("Content-Type");<br>          &#125;<br>        &#125;<br><br>        // When redirecting across hosts, drop all authentication headers. This<br>        // is potentially annoying to the application layer since they have no<br>        // way to retain them.<br>        <span class="hljs-keyword">if</span> (!sameConnection(userResponse.request().url(), url)) &#123;<br>          requestBuilder.removeHeader("Authorization");<br>        &#125;<br><br>        return requestBuilder.url(url).build();<br>      //408 超时<br>      <span class="hljs-keyword">case</span> HTTP_CLIENT_TIMEOUT:<br>        // 408's are rare in practice, but some servers like HAProxy use <span class="hljs-keyword">this</span> response code. The<br>        // spec says that we may repeat the request without modifications. Modern browsers also<br>        // repeat the request (even non-idempotent ones.)<br>        <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure()) &#123;<br>          // The application layer has directed us not to retry the request.<br>          return <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        RequestBody requestBody = userResponse.request().body();<br>        <span class="hljs-keyword">if</span> (requestBody != <span class="hljs-keyword">null</span> &amp;&amp; requestBody.isOneShot()) &#123;<br>          return <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (userResponse.priorResponse() != <span class="hljs-keyword">null</span><br>            &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;<br>          // We attempted to retry and got another timeout. Give up.<br>          return <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (retryAfter(userResponse, 0) &gt; 0) &#123;<br>          return <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        return userResponse.request();<br>      //503 服务端不可用<br>      <span class="hljs-keyword">case</span> HTTP_UNAVAILABLE:<br>        <span class="hljs-keyword">if</span> (userResponse.priorResponse() != <span class="hljs-keyword">null</span><br>            &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;<br>          // We attempted to retry and got another timeout. Give up.<br>          return <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == 0) &#123;<br>          // specifically received an instruction to retry without delay<br>          return userResponse.request();<br>        &#125;<br><br>        return <span class="hljs-keyword">null</span>;<br><br>      <span class="hljs-keyword">default</span>:<br>        return <span class="hljs-keyword">null</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>followUpRequest()</code>对<code>Response</code>返回的<code>code</code>进行对应操作，在触发到重定向相关的code<code>3XX</code>时，需要对应的转换<code>Request</code>使用获取到的重定向后地址进行请求。</p>
<blockquote>
<p>由源码可知，可以重试的最大次数为<strong>20</strong>次，可以通过<code>retryOnConnectionFailure(true)</code>设置支持重试。但是不支持自定义重试次数，若需要自定义重试次数，需要自定义拦截器去实现。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> RetryInterceptor(<span class="hljs-keyword">var</span> maxRetry: <span class="hljs-built_in">Int</span>/*最大重试次数*/) : Interceptor &#123;<br>        //当前重试次数<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> retryNum = 0<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> intercept(chain: Interceptor.Chain): Response &#123;<br>            <span class="hljs-keyword">val</span> request = chain.request()<br>            <span class="hljs-keyword">var</span> response = chain.proceed(request)<br><br>            <span class="hljs-keyword">while</span> (!response.isSuccessful &amp;&amp; retryNum &lt; maxRetry) &#123;<br>                retryNum++<br>                response = chain.proceed(request)<br>            &#125;<br>            return response<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a><code>BridgeInterceptor</code></h5><p><img src="/images/OkHttp-BridgeInterceptor.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-BridgeInterceptor"></p>
<blockquote>
<p>用以将用户的请求转换为向服务器的请求，之后再把服务器返回的数据转换成用户直观的数据。<strong>主要是对Header进行处理</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class BridgeInterceptor implements Interceptor &#123;<br>    @Override <span class="hljs-keyword">public</span> Response intercept(Chain chain) <span class="hljs-keyword">throws</span> IOException &#123;<br>    Request userRequest = chain.request();<br>    Request.Builder requestBuilder = userRequest.newBuilder();<br>    //重构用户请求 为 服务器请求格式<br>    RequestBody body = userRequest.body();<br>    //如果存在Body<br>    <span class="hljs-keyword">if</span> (body != <span class="hljs-keyword">null</span>) &#123;<br>      //对Header进行调整<br>      MediaType contentType = body.contentType();<br>      <span class="hljs-keyword">if</span> (contentType != <span class="hljs-keyword">null</span>) &#123;<br>        requestBuilder.header("Content-Type", contentType.toString());<br>      &#125;<br><br>      <span class="hljs-keyword">long</span> contentLength = body.contentLength();<br>      <span class="hljs-keyword">if</span> (contentLength != -1) &#123;<br>        requestBuilder.header("Content-Length", Long.toString(contentLength));<br>        requestBuilder.removeHeader("Transfer-Encoding");<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        requestBuilder.header("Transfer-Encoding", "chunked");<br>        requestBuilder.removeHeader("Content-Length");<br>      &#125;<br>    &#125;<br>    //设置Header中的 host<br>    <span class="hljs-keyword">if</span> (userRequest.header("Host") == <span class="hljs-keyword">null</span>) &#123;<br>      requestBuilder.header("Host", hostHeader(userRequest.url(), <span class="hljs-keyword">false</span>));<br>    &#125;<br><br>    //设置 connection : Keep-Alive 保持长连接模式<br>    <span class="hljs-keyword">if</span> (userRequest.header("Connection") == <span class="hljs-keyword">null</span>) &#123;<br>      requestBuilder.header("Connection", "Keep-Alive");<br>    &#125;<br><br>    // If we add an "Accept-Encoding: gzip" header field we're responsible <span class="hljs-keyword">for</span> also decompressing<br>    // the transfer stream.<br>    <span class="hljs-keyword">boolean</span> transparentGzip = <span class="hljs-keyword">false</span>;<br>    //默认使用Gzip压缩<br>    <span class="hljs-keyword">if</span> (userRequest.header("Accept-Encoding") == <span class="hljs-keyword">null</span> &amp;&amp; userRequest.header("Range") == <span class="hljs-keyword">null</span>) &#123;<br>      transparentGzip = <span class="hljs-keyword">true</span>;<br>      requestBuilder.header("Accept-Encoding", "gzip");<br>    &#125;<br>    //设置 Cookie信息<br>    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());<br>    <span class="hljs-keyword">if</span> (!cookies.isEmpty()) &#123;<br>      requestBuilder.header("Cookie", cookieHeader(cookies));<br>    &#125;<br>    //设置UA<br>    <span class="hljs-keyword">if</span> (userRequest.header("User-Agent") == <span class="hljs-keyword">null</span>) &#123;<br>      requestBuilder.header("User-Agent", Version.userAgent());<br>    &#125;<br>    //传递至下一个拦截器处理<br>    Response networkResponse = chain.proceed(requestBuilder.build());<br><br>    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());<br><br>    Response.Builder responseBuilder = networkResponse.newBuilder()<br>        .request(userRequest);<br>    //如果服务器支持Gzip压缩，需要进行解压操作<br>    <span class="hljs-keyword">if</span> (transparentGzip<br>        &amp;&amp; "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))<br>        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;<br>      GzipSource responseBody = new GzipSource(networkResponse.body().source());<br>      Headers strippedHeaders = networkResponse.headers().newBuilder()<br>          .removeAll("Content-Encoding")<br>          .removeAll("Content-Length")<br>          .build();<br>      responseBuilder.headers(strippedHeaders);<br>      String contentType = networkResponse.header("Content-Type");<br>      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));<br>    &#125;<br><br>    return responseBuilder.build();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>GZip</code>：是一种压缩技术，可以改进Web应用的性能，将请求体明显的减少其大小，如果服务器也支持该格式，就会返回对应格式的内容，客户端需要进行解压操作，可以明显的减少流量消耗。</p>
</blockquote>
<p><code>BridgeInterceptor</code>主要执行了以下3步：</p>
<ul>
<li><p>用户请求转换为网络请求</p>
<p>在原来<code>Request</code>上添加了很多<code>Header</code>，例如<code>Content-Type(定义网络文件的类型和网页的编码)、Content-Length(请求体内容长度)、Transfer-Encoding(请求体的大小)与Content-Length互斥、Accept-Encoding(编码格式)</code>。</p>
<p>未设置<code>Accept-Encoding</code>默认为<code>gzip</code>。</p>
</li>
<li><p>执行转换后的网络请求</p>
<p><code>chain.proceed(requestBuilder.build())</code></p>
</li>
<li><p>服务器返回的响应结果转换为用户响应结果</p>
<p>根据上一步获得<code>Response</code>后，需要再次转化为用户直观格式。主要在于服务端返回的信息里是否设置了<code>Accept-Encoding:gzip</code>，设置了则需要进行解压过程，获取最终结果。</p>
</li>
</ul>
<h5 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a><code>CacheInterceptor</code></h5><p><img src="/images/OkHttp-CacheInterceptor.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-CacheInterceptor"></p>
<blockquote>
<p>主要用于<strong>读取缓存以及更新缓存的</strong>，<strong>为了节省流量和提高响应速度</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class CacheInterceptor implements Interceptor &#123;<br>    @Override <span class="hljs-keyword">public</span> Response intercept(Chain chain) <span class="hljs-keyword">throws</span> IOException &#123;<br>    //根据请求的相关信息获取缓存<br>    Response cacheCandidate = cache != <span class="hljs-keyword">null</span><br>        ? cache.get(chain.request())<br>        : <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br>    //创建缓存策略<br>    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();①<br>    Request networkRequest = strategy.networkRequest;<br>    Response cacheResponse = strategy.cacheResponse;<br><br>    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;<br>      cache.trackResponse(strategy);<br>    &#125;<br>    //缓存无法使用，关闭获得的Response<br>    <span class="hljs-keyword">if</span> (cacheCandidate != <span class="hljs-keyword">null</span> &amp;&amp; cacheResponse == <span class="hljs-keyword">null</span>) &#123;<br>      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.<br>    &#125;<br><br>    // 根据策略，不使用网络且没有缓存的直接报错，返回504<br>    <span class="hljs-keyword">if</span> (networkRequest == <span class="hljs-keyword">null</span> &amp;&amp; cacheResponse == <span class="hljs-keyword">null</span>) &#123;<br>      return new Response.Builder()<br>          .request(chain.request())<br>          .protocol(Protocol.HTTP_1_1)<br>          .code(504)<br>          .message("Unsatisfiable Request (only-<span class="hljs-keyword">if</span>-cached)")<br>          .body(Util.EMPTY_RESPONSE)<br>          .sentRequestAtMillis(-1L)<br>          .receivedResponseAtMillis(System.currentTimeMillis())<br>          .build();<br>    &#125;<br><br>    // 直接返回缓存，不允许使用网络<br>    <span class="hljs-keyword">if</span> (networkRequest == <span class="hljs-keyword">null</span>) &#123;<br>      return cacheResponse.newBuilder()<br>          .cacheResponse(stripBody(cacheResponse))<br>          .build();<br>    &#125;<br><br>    Response networkResponse = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      //请求向下传递<br>      networkResponse = chain.proceed(networkRequest);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      // If we're crashing on I/O or otherwise, don't leak the cache body.<br>      <span class="hljs-keyword">if</span> (networkResponse == <span class="hljs-keyword">null</span> &amp;&amp; cacheCandidate != <span class="hljs-keyword">null</span>) &#123;<br>        closeQuietly(cacheCandidate.body());<br>      &#125;<br>    &#125;<br><br>    // 接受到服务器返回数据，如果返回code为 304 直接使用缓存结果<br>    <span class="hljs-keyword">if</span> (cacheResponse != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;<br>        Response response = cacheResponse.newBuilder()<br>            .headers(combine(cacheResponse.headers(), networkResponse.headers()))<br>            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())<br>            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())<br>            .cacheResponse(stripBody(cacheResponse))<br>            .networkResponse(stripBody(networkResponse))<br>            .build();<br>        networkResponse.body().close();<br><br>        // Update the cache after combining headers but before stripping the<br>        // Content-Encoding header (as performed by initContentStream()).<br>        cache.trackConditionalCacheHit();<br>        //更新当前存储的缓存信息<br>        cache.update(cacheResponse, response);<br>        return response;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        closeQuietly(cacheResponse.body());<br>      &#125;<br>    &#125;<br>    //读取服务器返回结果<br>    Response response = networkResponse.newBuilder()<br>        .cacheResponse(stripBody(cacheResponse))<br>        .networkResponse(stripBody(networkResponse))<br>        .build();<br>    //对数据进行缓存<br>    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;<br>        // Offer <span class="hljs-keyword">this</span> request to the cache.<br>        CacheRequest cacheRequest = cache.put(response);<br>        return cacheWritingResponse(cacheRequest, response);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          cache.remove(networkRequest);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>          // The cache cannot be written.<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    return response;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>CacheInterceptor</code>的执行流程如下所示：</p>
<ol>
<li>先行读取缓存数据</li>
<li>创建好对应的缓存策略：<code>强制缓存</code>、<code>对比缓存</code></li>
<li>根据缓存策略，不使用网络、也没有对应缓存，返回<code>504</code></li>
<li>根据缓存策略，不使用网络，存在缓存则直接返回</li>
<li>前面都没有返回结果，继续向下执行请求：<code>chain.proceed()</code></li>
<li>接受到对应网络结果，如果返回code为<code>304</code>，代表直接使用缓存并更新对应缓存信息</li>
<li>读取网络结果，对数据进行缓存</li>
<li>返回获取的网络结果</li>
</ol>
<p>具体的缓存策略请参考<a href="#OkHttp缓存机制">缓存策略</a></p>
<h5 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a><code>ConnectInterceptor</code></h5><p><img src="/images/OkHttp-ConnectInterceptor.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-ConnectInterceptor"></p>
<blockquote>
<p>真正与服务端建立连接，底层是通过<code>Socket</code>进行连接。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class ConnectInterceptor implements Interceptor &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> OkHttpClient client;<br><br>  @Override <span class="hljs-keyword">public</span> Response intercept(Chain chain) <span class="hljs-keyword">throws</span> IOException &#123;<br>    RealInterceptorChain realChain = (RealInterceptorChain) chain;<br>    Request request = realChain.request();<br>    Transmitter transmitter = realChain.transmitter();<br><br>    // We need the network to satisfy <span class="hljs-keyword">this</span> request. Possibly <span class="hljs-keyword">for</span> validating a conditional GET.<br>    <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals("GET");<br>    //建立连接<br>    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);<br>    //继续请求下一个拦截器<br>    return realChain.proceed(request, transmitter, exchange);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ConnectInterceptor</code>主要功能是建立与服务器的连接关系，通过<code>Transmitter.newExchange()</code>建立连接，建立完成后继续向下执行请求。</p>
<p>具体的连接过程可以参考<a href="# OkHttp连接机制">连接机制</a></p>
<h5 id="NetworkInterceptor"><a href="#NetworkInterceptor" class="headerlink" title="NetworkInterceptor"></a><code>NetworkInterceptor</code></h5><p><img src="/images/OkHttp-NetworkInterceptor.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-NetworkInterceptor"></p>
<blockquote>
<p>用户自定义的网络拦截器，处于第6个拦截器，前面经过了<code>RetryAndFolowUpInterceptor</code>的重定向过程以及<code>BridgeInterceptor</code>的请求头处理，在此处可以获取到更多的连接信息。</p>
</blockquote>
<p>引用代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient client = new OkHttpClient.Builder()<br>    .addNetworkInterceptor(new LoggingInterceptor())<br>    .build();<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>NetworkInterceptor</code>可以获取到最终请求的<code>Request</code>，以及获取到真正进行过网络请求的得到的<code>Response</code>，从而可以针对<code>Response</code>进行修改然后再回传到上层拦截器。</p>
</blockquote>
<p><code>NetworkInterceptor</code>主要有以下特点：</p>
<ul>
<li>可以操作经过<code>重定向、重试</code>得到的<code>Response</code></li>
<li>无法响应缓存数据的请求，因为<code>CacheInterceptor</code>执行在它之前</li>
<li>得到最终进行请求的<code>Request</code></li>
<li>可以获得连接信息</li>
</ul>
<h5 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a><code>CallServerInterceptor</code></h5><p><img src="/images/OkHttp-CallServerInterceptor.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-CallServerInterceptor"></p>
<blockquote>
<p>数据的写入过程，也就是客户端和服务端进行交互的过程，客户端发送数据，服务端返回数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class CallServerInterceptor implements Interceptor &#123;<br>@Override <span class="hljs-keyword">public</span> Response intercept(Chain chain) <span class="hljs-keyword">throws</span> IOException &#123;<br>    RealInterceptorChain realChain = (RealInterceptorChain) chain;<br>    Exchange exchange = realChain.exchange();<br>    Request request = realChain.request();<br><br>    <span class="hljs-keyword">long</span> sentRequestMillis = System.currentTimeMillis();<br>    //写入请求头<br>    exchange.writeRequestHeaders(request);<br><br>    <span class="hljs-keyword">boolean</span> responseHeadersStarted = <span class="hljs-keyword">false</span>;<br>    Response.Builder responseBuilder = <span class="hljs-keyword">null</span>;<br>    //判断当前是否有 请求体body<br>    <span class="hljs-keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="hljs-keyword">null</span>) &#123;<br>      // If there's a "Expect: 100-<span class="hljs-keyword">continue</span>" header on the request, wait <span class="hljs-keyword">for</span> a "HTTP/1.1 100<br>      // Continue" response before transmitting the request body. If we don't get that, return<br>      // what we did get (such as a 4xx response) without ever transmitting the request body.<br>      //如果是1XX的话 表示当前需要等服务端响应 <br>      <span class="hljs-keyword">if</span> ("100-<span class="hljs-keyword">continue</span>".equalsIgnoreCase(request.header("Expect"))) &#123;<br>        exchange.flushRequest();<br>        responseHeadersStarted = <span class="hljs-keyword">true</span>;<br>        exchange.responseHeadersStart();<br>        responseBuilder = exchange.readResponseHeaders(<span class="hljs-keyword">true</span>);<br>      &#125;<br><br>      <br>      <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-keyword">null</span>) &#123;<br>        //写入请求体<br>        <span class="hljs-keyword">if</span> (request.body().isDuplex()) &#123;<br>          // Prepare a duplex body so that the application can send a request body later.<br>          exchange.flushRequest();<br>          BufferedSink bufferedRequestBody = Okio.buffer(<br>              exchange.createRequestBody(request, <span class="hljs-keyword">true</span>));<br>          request.body().writeTo(bufferedRequestBody);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          // Write the request body <span class="hljs-keyword">if</span> the "Expect: 100-<span class="hljs-keyword">continue</span>" expectation was met.<br>          BufferedSink bufferedRequestBody = Okio.buffer(<br>              exchange.createRequestBody(request, <span class="hljs-keyword">false</span>));<br>          request.body().writeTo(bufferedRequestBody);<br>          bufferedRequestBody.close();<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        exchange.noRequestBody();<br>        <span class="hljs-keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;<br>          // If the "Expect: 100-<span class="hljs-keyword">continue</span>" expectation wasn't met, prevent the HTTP/1 connection<br>          // from being reused. Otherwise we're still obligated to transmit the request body to<br>          // leave the connection in a consistent state.<br>          exchange.noNewExchangesOnConnection();<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      exchange.noRequestBody();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (request.body() == <span class="hljs-keyword">null</span> || !request.body().isDuplex()) &#123;<br>        //结束请求<br>      exchange.finishRequest();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!responseHeadersStarted) &#123;<br>      exchange.responseHeadersStart();<br>    &#125;<br>    //得到响应头<br>    <span class="hljs-keyword">if</span> (responseBuilder == <span class="hljs-keyword">null</span>) &#123;<br>      responseBuilder = exchange.readResponseHeaders(<span class="hljs-keyword">false</span>);<br>    &#125;<br>    <br>    Response response = responseBuilder<br>        .request(request)<br>        .handshake(exchange.connection().handshake())<br>        .sentRequestAtMillis(sentRequestMillis)<br>        .receivedResponseAtMillis(System.currentTimeMillis())<br>        .build();<br>    //读取响应体内容<br>    <span class="hljs-keyword">int</span> code = response.code();<br>    <span class="hljs-keyword">if</span> (code == 100) &#123;<br>      // server sent a 100-<span class="hljs-keyword">continue</span> even though we did not request one.<br>      // <span class="hljs-keyword">try</span> again to read the actual response<br>      response = exchange.readResponseHeaders(<span class="hljs-keyword">false</span>)<br>          .request(request)<br>          .handshake(exchange.connection().handshake())<br>          .sentRequestAtMillis(sentRequestMillis)<br>          .receivedResponseAtMillis(System.currentTimeMillis())<br>          .build();<br><br>      code = response.code();<br>    &#125;<br><br>    exchange.responseHeadersEnd(response);<br>    //forWebSocket 表示为socket连接方式<br>    <span class="hljs-keyword">if</span> (forWebSocket &amp;&amp; code == 101) &#123;<br>      // Connection is upgrading, but we need to ensure interceptors see a non-<span class="hljs-keyword">null</span> response body.<br>      response = response.newBuilder()<br>          .body(Util.EMPTY_RESPONSE)<br>          .build();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      response = response.newBuilder()<br>          .body(exchange.openResponseBody(response))<br>          .build();<br>    &#125;<br>    // close表示关闭连接<br>    <span class="hljs-keyword">if</span> ("close".equalsIgnoreCase(response.request().header("Connection"))<br>        || "close".equalsIgnoreCase(response.header("Connection"))) &#123;<br>      exchange.noNewExchangesOnConnection();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123;<br>      throw new ProtocolException(<br>          "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());<br>    &#125;<br><br>    return response;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>CallServerInterceptor</code>主要执行了以下过程：</p>
<ul>
<li>写入请求头</li>
<li>写入请求体(如果存在)</li>
<li>获取状态行及响应头</li>
<li>获取响应体</li>
</ul>
<p><code>CallServerInterceptor</code>已经是最后一个拦截器了，接下来就是向上回溯并返回自己获得的<code>Response</code>。</p>
<blockquote>
<p>HTTP报文结构：</p>
<p><strong>请求报文</strong>：</p>
<p>请求行：声明请求方法、主机域名及协议版本</p>
<p>请求头：声明客户端的部分报文信息</p>
<p>请求体：存放客户端发送给服务器的数据</p>
<p><strong>响应报文</strong></p>
<p>状态行：声明HTTP协议版本、状态码及描述</p>
<p>响应头：声明服务端的部分报文信息</p>
<p>响应体：服务端返回客户端的数据</p>
</blockquote>
<h4 id="责任链模式串联"><a href="#责任链模式串联" class="headerlink" title="责任链模式串联"></a>责任链模式串联</h4><p>介绍完上述的拦截器后，接下来就是分析如何将这些拦截器进行串联调用。</p>
<figure class="highlight java"><figcaption><span>RealCall.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">Response getResponseWithInterceptorChain() <span class="hljs-keyword">throws</span> IOException &#123;<br>    // Build a full stack of interceptors.<br>    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();<br>    ...<br>    //构建责任链<br>    Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, <span class="hljs-keyword">null</span>, 0,<br>        originalRequest, <span class="hljs-keyword">this</span>, client.connectTimeoutMillis(),<br>        client.readTimeoutMillis(), client.writeTimeoutMillis());<br><br>    <span class="hljs-keyword">boolean</span> calledNoMoreExchanges = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      //开始从头链式调用拦截器<br>      Response response = chain.proceed(originalRequest);<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) &#123;<br>        closeQuietly(response);<br>        throw new IOException("Canceled");<br>      &#125;<br>      return response;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      calledNoMoreExchanges = <span class="hljs-keyword">true</span>;<br>      throw transmitter.noMoreExchanges(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (!calledNoMoreExchanges) &#123;<br>        transmitter.noMoreExchanges(<span class="hljs-keyword">null</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>实际执行链式调用的是<code>RealInterceptorChain</code>，由他负责责任链的执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class RealInterceptorChain implements Interceptor.Chain &#123;<br>    @Override <span class="hljs-keyword">public</span> Response proceed(Request request) <span class="hljs-keyword">throws</span> IOException &#123;<br>    return proceed(request, transmitter, exchange);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange)<br>      <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= interceptors.size()) throw new AssertionError();<br><br>    calls++;<br><br>    // 存在已经在使用的流，直接进行复用<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.exchange != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;<br>      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)<br>          + " must retain the same host and port");<br>    &#125;<br><br>    // If we already have a stream, confirm that <span class="hljs-keyword">this</span> is the only call to chain.proceed().<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.exchange != <span class="hljs-keyword">null</span> &amp;&amp; calls &gt; 1) &#123;<br>      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)<br>          + " must call proceed() exactly once");<br>    &#125;<br><br>    // 调用该链中的下一个拦截器 实质为 用户自定义的拦截器，不存在则为 RetryAndFollowUpInterceptor<br>    RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange,<br>        index + 1, request, call, connectTimeout, readTimeout, writeTimeout);<br>    Interceptor interceptor = interceptors.get(index);<br>    Response response = interceptor.intercept(next);<br><br>    // Confirm that the next interceptor made its required call to chain.proceed().<br>    <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span> &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;<br>      throw new IllegalStateException("network interceptor " + interceptor<br>          + " must call proceed() exactly once");<br>    &#125;<br><br>    // Confirm that the intercepted response isn't <span class="hljs-keyword">null</span>.<br>    <span class="hljs-keyword">if</span> (response == <span class="hljs-keyword">null</span>) &#123;<br>      throw new NullPointerException("interceptor " + interceptor + " returned <span class="hljs-keyword">null</span>");<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (response.body() == <span class="hljs-keyword">null</span>) &#123;<br>      throw new IllegalStateException(<br>          "interceptor " + interceptor + " returned a response with no body");<br>    &#125;<br><br>    return response;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>RealIntercrptor</code>为链式调用的起点，调用<code>proceed()</code>之后，继续调用下一层的拦截器，直到得到最终的Response。</p>
<p>后续的拦截器也是按照这个规则向下执行，内部都会调用到<code>chain.proceed()</code>直到没有调用为止。</p>
<p><strong>Request是按照定义的<code>interceptor</code>顺序向下执行，然后Response是逆向向上处理的。</strong></p>
<h3 id="获取请求结果Response"><a href="#获取请求结果Response" class="headerlink" title="获取请求结果Response"></a>获取请求结果<code>Response</code></h3><blockquote>
<p><code>Response</code>：返回HTTP请求响应结果，包含了状态码，响应正文等</p>
</blockquote>
<p>在<code>CallServerInterceptor</code>得到最初格式的<code>Response</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">//获得状态行及响应头  <br><span class="hljs-keyword">public</span> @Nullable Response.Builder readResponseHeaders(<span class="hljs-keyword">boolean</span> expectContinue) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      Response.Builder result = codec.readResponseHeaders(expectContinue);<br>      <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>        Internal.instance.initExchange(result, <span class="hljs-keyword">this</span>);<br>      &#125;<br>      return result;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      eventListener.responseFailed(call, e);<br>      trackFailure(e);<br>      throw e;<br>    &#125;<br>  &#125;<br>//获得响应正文<br><span class="hljs-keyword">public</span> ResponseBody openResponseBody(Response response) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      eventListener.responseBodyStart(call);<br>      String contentType = response.header("Content-Type");<br>      <span class="hljs-keyword">long</span> contentLength = codec.reportedContentLength(response);<br>      Source rawSource = codec.openResponseBodySource(response);<br>      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);<br>      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      eventListener.responseFailed(call, e);<br>      trackFailure(e);<br>      throw e;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><img src="/images/OkHttp执行流程.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp执行流程"></p>
<h2 id="OkHttp缓存机制"><a href="#OkHttp缓存机制" class="headerlink" title="OkHttp缓存机制"></a>OkHttp缓存机制</h2><h3 id="Http缓存"><a href="#Http缓存" class="headerlink" title="Http缓存"></a>Http缓存</h3><p><img src="/images/OkHttp-HTTP缓存机制.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-HTTP缓存机制"></p>
<blockquote>
<p>Http缓存是web性能优化的重要手段，缓存机制是依赖于<code>header</code>中的参数实现的，这些参数指定了缓存需要<em>从缓存中获取</em>还是<em>从服务端获取</em>。</p>
</blockquote>
<p>Http缓存有多种规则，根据是否需要重新向服务器发起请求来进行分类：</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><blockquote>
<p>当客户端第一次请求数据时，服务端在响应头会携带<strong>缓存规则信息</strong>，主要为两个字段：<strong>Expires</strong>、<strong>Cache-Control</strong></p>
<p>当再次请求数据时，如果符合缓存规则，则直接使用缓存数据，无需与服务端重新交互。</p>
</blockquote>
<p><img src="/images/强制缓存流程.png" srcset="/img/loading.gif" lazyload="" alt="强制缓存流程"></p>
<p>强制缓存在缓存未失效的情况下，可以直接使用缓存数据，接下来介绍<code>判断缓存数据是否失效</code>。<br>上文提到，强制缓存是根据两个Header字段进行判定的，这两个字段表示了<code>失效规则</code>。</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><del>Expires</del></h5><blockquote>
<p>服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。<br><em>这参数是HTTP1.0的东西了，现在主流的是HTTP1.1。</em><br>可能由于客户端时间没有与服务端时间同步而导致缓存命中的误差。</p>
</blockquote>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><blockquote>
<p>在HTTP1.1中替代<code>Expires</code>，功能与其一致。<br><code>Cache-Control</code>常见的取值有如下几种：</p>
<ul>
<li><code>private</code>：客户端可以进行缓存</li>
<li><code>public</code>：客户端以及代理服务器都可以进行缓存</li>
<li><code>max-age= XX</code>：缓存数据在 XX秒后失效</li>
<li><code>no-cache</code>：需要使用到<code>对比缓存</code></li>
<li><code>no-store</code>：所有内容都不进行缓存</li>
<li><code>s-maxage = XX</code>：限定缓存可以在代理服务器中存放多久</li>
</ul>
</blockquote>
<h4 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h4><blockquote>
<p>需要进行比较判断来确定是否使用缓存，当客户端第一次请求数据时，服务端会返回<strong>缓存标识</strong>以及数据给客户端，客户端对两者都要进行备份到缓存，当再次请求数据时，客户端会带上<strong>缓存标识</strong>发送给服务端，服务端对标识进行判断，返回code值。返回若为<strong>304</strong>，则继续使用缓存。</p>
</blockquote>
<p><img src="/images/对比缓存流程.png" srcset="/img/loading.gif" lazyload="" alt="对比缓存流程"></p>
<p>在<strong>缓存标识</strong>未失效时，可以继续使用缓存数据，每次都需要与服务端进行交互去验证<strong>缓存标识</strong>。<br>对比缓存也是依据两个Header字段进行判定的，这两个字段表示了<code>缓存标识</code>。</p>
<h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p><code>Last-Modified</code>：服务端返回给客户端，表示资源的最后修改时间。<br><code>If-Modified-Since</code>：客户端发给服务端，表示服务端上次返回的资源最后修改时间。<br>服务端接收到<code>If-Modified-Since</code>后，与被请求资源的最后修改时间进行比对。</p>
<ul>
<li>若大于，返回最新资源并返回code为200，客户端需要重新进行缓存</li>
<li>否则，说明资源无修改并返回code为304，客户端继续使用缓存数据</li>
</ul>
<h5 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h5><p><code>ETag</code>：服务端返回给客户端，表示当前资源在服务器的唯一标识。<br><code>If-None-Match</code>：客户端发送给服务端，表示服务端上次返回的资源唯一标识。<br>服务端接收到<code>If-None-Match</code>后，与被请求资源的唯一标识进行比对</p>
<ul>
<li>标识不同，表示资源被改动过，返回最新资源及设置code为200，客户端需要重新进行缓存</li>
<li>标识相同，表示资源未被改动，返回code为304，客户端继续使用缓存数据</li>
</ul>
<p>其中<code>ETag/If-None-Match</code>的优先级是高于<code>Last-Modified/If-Modified-Since</code>的</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<ul>
<li>强制缓存的优先级是高于对比缓存的</li>
<li>对于<code>强制缓存</code>，服务端会给予一个过期时间，在有效期内再次请求都只会使用缓存，不会请求服务端。</li>
<li>超过有效期就使用<code>对比缓存</code>策略，将服务端返回的<code>ETag/Last-Modified</code>发还给服务端进行验证，有效则继续使用缓存数据(<em>返回code为304</em>)，无效则重新获取并进行缓存(<em>返回code为200</em>)。</li>
</ul>
</blockquote>
<h3 id="缓存存储"><a href="#缓存存储" class="headerlink" title="缓存存储"></a>缓存存储</h3><p><img src="/images/OkHttp缓存实现.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp缓存实现"></p>
<p>介绍完毕Http的缓存机制后，接下来就是看<code>OkHttp</code>中的源码实现<br><figure class="highlight java"><figcaption><span>CacheStrategy.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CacheStrategy(Request networkRequest, Response cacheResponse) &#123;<br>  <span class="hljs-keyword">this</span>.networkRequest = networkRequest;<br>  <span class="hljs-keyword">this</span>.cacheResponse = cacheResponse;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>缓存策略主要通过<code>CacheStrategy</code>类实现，关键参数为<code>networkRequest(网络请求)</code>、<code>cacheResponse(缓存的响应结果)</code>。<br><code>CacheStrategy</code>通过工厂模式进行构建的，最终通过调用<code>getCandidate()</code>来生成不同模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> CacheStrategy getCandidate() &#123;<br>      // 没缓存直接进行重新请求<br>      <span class="hljs-keyword">if</span> (cacheResponse == <span class="hljs-keyword">null</span>) &#123;<br>        return new CacheStrategy(request, <span class="hljs-keyword">null</span>);<br>      &#125;<br><br>      // 如果是HTTPs且握手信息丢失进行重新请求<br>      <span class="hljs-keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="hljs-keyword">null</span>) &#123;<br>        return new CacheStrategy(request, <span class="hljs-keyword">null</span>);<br>      &#125;<br>      //判断缓存已经失效 重新进行请求<br>      <span class="hljs-keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;<br>        return new CacheStrategy(request, <span class="hljs-keyword">null</span>);<br>      &#125;<br>      // <br>      CacheControl requestCaching = request.cacheControl();<br>      <span class="hljs-keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;<br>        return new CacheStrategy(request, <span class="hljs-keyword">null</span>);<br>      &#125;<br><br>      CacheControl responseCaching = cacheResponse.cacheControl();<br>      //<br>      <span class="hljs-keyword">long</span> ageMillis = cacheResponseAge();<br>      <span class="hljs-keyword">long</span> freshMillis = computeFreshnessLifetime();<br><br>      <span class="hljs-keyword">if</span> (requestCaching.maxAgeSeconds() != -1) &#123;<br>        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));<br>      &#125;<br><br>      <span class="hljs-keyword">long</span> minFreshMillis = 0;<br>      <span class="hljs-keyword">if</span> (requestCaching.minFreshSeconds() != -1) &#123;<br>        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());<br>      &#125;<br><br>      <span class="hljs-keyword">long</span> maxStaleMillis = 0;<br>      <span class="hljs-keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) &#123;<br>        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());<br>      &#125;<br>      //处于强制缓存状态，直接返回缓存数据<br>      <span class="hljs-keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;<br>        Response.Builder builder = cacheResponse.newBuilder();<br>        <span class="hljs-keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;<br>          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");<br>        &#125;<br>        <span class="hljs-keyword">long</span> oneDayMillis = 24 * 60 * 60 * 1000L;<br>        <span class="hljs-keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;<br>          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");<br>        &#125;<br>        return new CacheStrategy(<span class="hljs-keyword">null</span>, builder.build());<br>      &#125;<br><br>      // Find a condition to add to the request. If the condition is satisfied, the response body<br>      // will not be transmitted.<br>      String conditionName;<br>      String conditionValue;<br>      <span class="hljs-keyword">if</span> (etag != <span class="hljs-keyword">null</span>) &#123;<br>        conditionName = "If-None-Match";<br>        conditionValue = etag;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastModified != <span class="hljs-keyword">null</span>) &#123;<br>        conditionName = "If-Modified-Since";<br>        conditionValue = lastModifiedString;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (servedDate != <span class="hljs-keyword">null</span>) &#123;<br>        conditionName = "If-Modified-Since";<br>        conditionValue = servedDateString;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        return new CacheStrategy(request, <span class="hljs-keyword">null</span>); // No condition! Make a regular request.<br>      &#125;<br>      //交由服务端去进行判断<br>      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();<br>      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);<br><br>      Request conditionalRequest = request.newBuilder()<br>          .headers(conditionalRequestHeaders.build())<br>          .build();<br>      return new CacheStrategy(conditionalRequest, cacheResponse);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>CacheStrategy</code>根据之前的缓存结果以及要发送的<code>request的header</code>计算缓存策略</p>
<table>
<thead>
<tr>
<th>networkRequest</th>
<th>cacheResponse</th>
<th>CacheStrategy</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td>null</td>
<td>不进行网络请求且缓存不存在或过期<br>返回504错误</td>
</tr>
<tr>
<td>null</td>
<td>not null</td>
<td>不进行网络请求但是存在缓存且有效<br>直接返回缓存数据</td>
</tr>
<tr>
<td>not null</td>
<td>null</td>
<td>进行网络请求且缓存不存在或过期<br>直接进行网络请求获取数据</td>
</tr>
<tr>
<td>not null</td>
<td>not null</td>
<td>进行网络请求，请求头包含<code>ETag/Last-Modified</code>且缓存存在<br>根据网络请求结果判断<br>返回304，使用缓存<br>返回200，使用请求数据且更新缓存</td>
</tr>
</tbody>
</table>
<h2 id="OkHttp连接机制"><a href="#OkHttp连接机制" class="headerlink" title="OkHttp连接机制"></a>OkHttp连接机制</h2><p>在<code>ConnectInterceptor</code>中进行了与服务端的连接，通过<code>Exchange</code>类进行连接。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Exchange newExchange(Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks) &#123;<br>  <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>    <span class="hljs-keyword">if</span> (noMoreExchanges) throw new IllegalStateException("released");<br>    <span class="hljs-keyword">if</span> (exchange != <span class="hljs-keyword">null</span>) throw new IllegalStateException("exchange != <span class="hljs-keyword">null</span>");<br>  &#125;<br>  //建立连接<br>  ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);<br>  Exchange result = new Exchange(<span class="hljs-keyword">this</span>, call, eventListener, exchangeFinder, codec);<br><br>  <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>    <span class="hljs-keyword">this</span>.exchange = result;<br>    <span class="hljs-keyword">this</span>.exchangeRequestDone = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">this</span>.exchangeResponseDone = <span class="hljs-keyword">false</span>;<br>    return result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="通过Socket连接服务端"><a href="#通过Socket连接服务端" class="headerlink" title="通过Socket连接服务端"></a>通过Socket连接服务端</h3><p>通过<code>ExchangeCodec.find()</code>来设置连接或者复用<br><figure class="highlight java"><figcaption><span>ExchangeCodec.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ExchangeCodec find(<br>      OkHttpClient client, Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks) &#123;<br>    <span class="hljs-keyword">int</span> connectTimeout = chain.connectTimeoutMillis();<br>    <span class="hljs-keyword">int</span> readTimeout = chain.readTimeoutMillis();<br>    <span class="hljs-keyword">int</span> writeTimeout = chain.writeTimeoutMillis();<br>    <span class="hljs-keyword">int</span> pingIntervalMillis = client.pingIntervalMillis();<br>    <span class="hljs-keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,<br>          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);<br>      return resultConnection.newCodec(client, chain);<br>    &#125; <span class="hljs-keyword">catch</span> (RouteException e) &#123;<br>      trackFailure();<br>      throw e;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      trackFailure();<br>      throw new RouteException(e);<br>    &#125;<br>  &#125;<br>  //返回一个健康的连接 <br>  <span class="hljs-keyword">private</span> RealConnection findHealthyConnection(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout,<br>      <span class="hljs-keyword">int</span> writeTimeout, <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled,<br>      <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,<br>          pingIntervalMillis, connectionRetryEnabled);<br><br>      // If <span class="hljs-keyword">this</span> is a brand new connection, we can skip the extensive health checks.<br>      <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>        <span class="hljs-keyword">if</span> (candidate.successCount == 0) &#123;<br>          return candidate;<br>        &#125;<br>      &#125;<br><br>      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it<br>      // isn't, take it out of the pool and start again.<br>      <span class="hljs-keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;<br>        candidate.noNewExchanges();<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      return candidate;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> RealConnection findConnection(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout, <span class="hljs-keyword">int</span> writeTimeout,<br>      <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">boolean</span> foundPooledConnection = <span class="hljs-keyword">false</span>;<br>    RealConnection result = <span class="hljs-keyword">null</span>;<br>    Route selectedRoute = <span class="hljs-keyword">null</span>;<br>    RealConnection releasedConnection;<br>    Socket toClose;<br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) throw new IOException("Canceled");<br>      hasStreamFailure = <span class="hljs-keyword">false</span>; // This is a fresh attempt.<br>      <br>      Route previousRoute = retryCurrentRoute()<br>          ? transmitter.connection.route()<br>          : <span class="hljs-keyword">null</span>;<br><br>      // Attempt to use an already-allocated connection. We need to be careful here because our<br>      // already-allocated connection may have been restricted from creating new exchanges.<br>      releasedConnection = transmitter.connection;<br>      toClose = transmitter.connection != <span class="hljs-keyword">null</span> &amp;&amp; transmitter.connection.noNewExchanges<br>          ? transmitter.releaseConnectionNoEvents()<br>          : <span class="hljs-keyword">null</span>;<br><br>      <span class="hljs-keyword">if</span> (transmitter.connection != <span class="hljs-keyword">null</span>) &#123;<br>        // We had an already-allocated connection and it's good.<br>        result = transmitter.connection;<br>        releasedConnection = <span class="hljs-keyword">null</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;<br>        // Attempt to get a connection from the pool.<br>        <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>)) &#123;<br>          foundPooledConnection = <span class="hljs-keyword">true</span>;<br>          result = transmitter.connection;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          selectedRoute = previousRoute;<br>        &#125;<br>      &#125;<br>    &#125;<br>    closeQuietly(toClose);<br><br>    <span class="hljs-keyword">if</span> (releasedConnection != <span class="hljs-keyword">null</span>) &#123;<br>      eventListener.connectionReleased(call, releasedConnection);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;<br>      eventListener.connectionAcquired(call, result);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>      // If we found an already-allocated or pooled connection, we're done.<br>      return result;<br>    &#125;<br><br>    // If we need a route selection, make one. This is a blocking operation.<br>    <span class="hljs-keyword">boolean</span> newRouteSelection = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span> &amp;&amp; (routeSelection == <span class="hljs-keyword">null</span> || !routeSelection.hasNext())) &#123;<br>      newRouteSelection = <span class="hljs-keyword">true</span>;<br>      routeSelection = routeSelector.next();<br>    &#125;<br><br>    List&lt;Route&gt; routes = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (transmitter.isCanceled()) throw new IOException("Canceled");<br><br>      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;<br>        // Now that we have a set of IP addresses, make another attempt at getting a connection from<br>        // the pool. This could match due to connection coalescing.<br>        routes = routeSelection.getAll();<br>        <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(<br>            address, transmitter, routes, <span class="hljs-keyword">false</span>)) &#123;<br>          foundPooledConnection = <span class="hljs-keyword">true</span>;<br>          result = transmitter.connection;<br>        &#125;<br>      &#125;<br>      //没有从连接池中获取到连接需要重新建立<br>      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;<br>        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span>) &#123;<br>          selectedRoute = routeSelection.next();<br>        &#125;<br><br>        // Create a connection and assign it to <span class="hljs-keyword">this</span> allocation immediately. This makes it possible<br>        // <span class="hljs-keyword">for</span> an asynchronous cancel() to interrupt the handshake we're about to <span class="hljs-keyword">do</span>.<br>        result = new RealConnection(connectionPool, selectedRoute);<br>        connectingConnection = result;<br>      &#125;<br>    &#125;<br><br>    // If we found a pooled connection on the 2nd time around, we're done.<br>    <span class="hljs-keyword">if</span> (foundPooledConnection) &#123;<br>      eventListener.connectionAcquired(call, result);<br>      return result;<br>    &#125;<br><br>    // Do TCP + TLS handshakes. This is a blocking operation.<br>    // 开始TCP三次握手以及TLS操作，为阻塞操作<br>    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,<br>        connectionRetryEnabled, call, eventListener);<br>    connectionPool.routeDatabase.connected(result.route());<br><br>    Socket socket = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      connectingConnection = <span class="hljs-keyword">null</span>;<br>      // Last attempt at connection coalescing, which only occurs <span class="hljs-keyword">if</span> we attempted multiple<br>      // concurrent connections to the same host.<br>      <span class="hljs-keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="hljs-keyword">true</span>)) &#123;<br>        // We lost the race! Close the connection we created and return the pooled connection.<br>        result.noNewExchanges = <span class="hljs-keyword">true</span>;<br>        socket = result.socket();<br>        result = transmitter.connection;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        //加入连接池 等待复用<br>        connectionPool.put(result);<br>        transmitter.acquireConnectionNoEvents(result);<br>      &#125;<br>    &#125;<br>    closeQuietly(socket);<br><br>    eventListener.connectionAcquired(call, result);<br>    return result;<br>  &#125;<br></code></pre></td></tr></table></figure></p>
<p>最终通过<code>Socket.connect()</code>进行连接。</p>
<h3 id="连接池-ConnectionPool"><a href="#连接池-ConnectionPool" class="headerlink" title="连接池(ConnectionPool)"></a>连接池(ConnectionPool)</h3><p><img src="/images/OkHttp-连接池 ConnectionPool.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-连接池 ConnectionPool"></p>
<blockquote>
<p>频繁的进行Socket连接(三次握手)和Socket断开(四次挥手)非常消耗网络资源以及时间。在HTTP1.1之后提供了<code>keep-alive</code>这个header，可以实现长连接，有效的降低了延迟并提升了处理速度。<br>连接池就是为了<strong>复用已存在连接</strong>，可以有效降低创建连接的开销。</p>
</blockquote>
<h4 id="连接池构造方法以及成员变量"><a href="#连接池构造方法以及成员变量" class="headerlink" title="连接池构造方法以及成员变量"></a>连接池构造方法以及成员变量</h4><figure class="highlight java"><figcaption><span>ConnectionPool.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class ConnectionPool &#123;<br>  //后台清理线程<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,<br>      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,<br>      new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp ConnectionPool", <span class="hljs-keyword">true</span>)); <br>    //最大的空闲连接数<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxIdleConnections;<br>    //连接最大持续时间<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> keepAliveDurationNs;<br>    //存储连接的双向队列<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;();<br>  <br>    <span class="hljs-keyword">public</span> ConnectionPool() &#123;<br>      <span class="hljs-keyword">this</span>(5, 5, TimeUnit.MINUTES);<br>    &#125;<br><br>  <span class="hljs-keyword">public</span> ConnectionPool(<span class="hljs-keyword">int</span> maxIdleConnections, <span class="hljs-keyword">long</span> keepAliveDuration, TimeUnit timeUnit) &#123;<br>    <span class="hljs-keyword">this</span>.maxIdleConnections = maxIdleConnections;<br>    <span class="hljs-keyword">this</span>.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);<br><br>    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.<br>    <span class="hljs-keyword">if</span> (keepAliveDuration &lt;= 0) &#123;<br>      throw new IllegalArgumentException("keepAliveDuration &lt;= 0: " + keepAliveDuration);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ConnectionPool</code>支持配置以下变量</p>
<ul>
<li><code>maxIdleConnections</code>：最大空闲连接数，默认<code>5</code></li>
<li><code>keepAliveDurationNs</code>：最大连接保持时间，默认<code>5min</code></li>
</ul>
<p><code>Connection</code>连接池中的<code>Connection</code>任一超出以上配置，就需要执行清理。</p>
<p>可以通过以下方法配置连接池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">OkHttpClient.Builder builder = new OkHttpClient.Builder()<br>        .connectionPool(new ConnectionPool()); //配置连接池<br></code></pre></td></tr></table></figure>
<h4 id="连接池加入连接"><a href="#连接池加入连接" class="headerlink" title="连接池加入连接"></a>连接池加入连接</h4><p><img src="/images/1345862-20200603214235374-1759578389.png" srcset="/img/loading.gif" lazyload="" alt="双端队列"></p>
<p>通过<code>connections</code>存储<code>Connection</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> put(RealConnection connection) &#123;<br>  <span class="hljs-keyword">assert</span> (Thread.holdsLock(<span class="hljs-keyword">this</span>));<br>  <span class="hljs-keyword">if</span> (!cleanupRunning) &#123;//当前清理线程没有运行<br>    cleanupRunning = <span class="hljs-keyword">true</span>;<br>    executor.execute(cleanupRunnable);//开启清理过程<br>  &#125;<br>  connections.add(connection);//加入队列<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在外部执行<code>put()</code>时，连接加入连接池，并且开启清理线程去清理那些超出配置的连接。</p>
<p>外部执行<code>put()</code>路径如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java">// ConnectInterceptor 连接拦截器，其中执行连接过程<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class ConnectInterceptor implements Interceptor &#123;<br>    @Override <span class="hljs-keyword">public</span> Response intercept(Chain chain) <span class="hljs-keyword">throws</span> IOException &#123;<br>    RealInterceptorChain realChain = (RealInterceptorChain) chain;<br>    Request request = realChain.request();<br>    StreamAllocation streamAllocation = realChain.streamAllocation();<br><br>    // We need the network to satisfy <span class="hljs-keyword">this</span> request. Possibly <span class="hljs-keyword">for</span> validating a conditional GET.<br>    <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals("GET");<br>    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);//建立新连接<br>    RealConnection connection = streamAllocation.connection();<br><br>    return realChain.proceed(request, streamAllocation, httpCodec, connection);<br>&#125;<br>  <br>// StreamAllocation <br>   <span class="hljs-keyword">public</span> HttpCodec newStream(<br>      OkHttpClient client, Interceptor.Chain chain, <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks) &#123;<br>       ...<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,<br>          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);//寻找可用的连接<br>      HttpCodec resultCodec = resultConnection.newCodec(client, chain, <span class="hljs-keyword">this</span>);<br><br>      <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>        codec = resultCodec;<br>        return resultCodec;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      throw new RouteException(e);<br>    &#125;<br>  &#125; <br>  <br>  <span class="hljs-keyword">private</span> RealConnection findHealthyConnection(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout,<br>      <span class="hljs-keyword">int</span> writeTimeout, <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled,<br>      <span class="hljs-keyword">boolean</span> doExtensiveHealthChecks) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,<br>          pingIntervalMillis, connectionRetryEnabled);<br>      ...<br><br>      return candidate;<br>    &#125;<br>  &#125;<br>  <br>   <span class="hljs-keyword">private</span> RealConnection findConnection(<span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout, <span class="hljs-keyword">int</span> writeTimeout,<br>      <span class="hljs-keyword">int</span> pingIntervalMillis, <span class="hljs-keyword">boolean</span> connectionRetryEnabled) <span class="hljs-keyword">throws</span> IOException &#123;<br>    ...<br>     <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (released) throw new IllegalStateException("released");<br>      <span class="hljs-keyword">if</span> (codec != <span class="hljs-keyword">null</span>) throw new IllegalStateException("codec != <span class="hljs-keyword">null</span>");<br>      <span class="hljs-keyword">if</span> (canceled) throw new IOException("Canceled");<br><br>      // Attempt to use an already-allocated connection. We need to be careful here because our<br>      // already-allocated connection may have been restricted from creating new streams.<br>      releasedConnection = <span class="hljs-keyword">this</span>.connection;<br>      toClose = releaseIfNoNewStreams();<br>      ...<br>      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;<br>        // Attempt to get a connection from the pool.<br>        Internal.instance.get(connectionPool, address, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>);//根据address从连接池中获取对应连接<br>        <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;<br>          foundPooledConnection = <span class="hljs-keyword">true</span>;<br>          result = connection;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          selectedRoute = route;<br>        &#125;<br>      &#125;<br>    &#125;<br>     ...<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>      // If we found an already-allocated or pooled connection, we're done.<br>      return result;<br>    &#125;  <br>     <br>     ...<br>       <br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      <span class="hljs-keyword">if</span> (canceled) throw new IOException("Canceled");<br><br>      <span class="hljs-keyword">if</span> (newRouteSelection) &#123;<br>        // Now that we have a set of IP addresses, make another attempt at getting a connection from<br>        // the pool. This could match due to connection coalescing.<br>        List&lt;Route&gt; routes = routeSelection.getAll();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0, size = routes.size(); i &lt; size; i++) &#123;<br>          Route route = routes.get(i);<br>          Internal.instance.get(connectionPool, address, <span class="hljs-keyword">this</span>, route);<br>          <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;<br>            foundPooledConnection = <span class="hljs-keyword">true</span>;<br>            result = connection;<br>            <span class="hljs-keyword">this</span>.route = route;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!foundPooledConnection) &#123;<br>        <span class="hljs-keyword">if</span> (selectedRoute == <span class="hljs-keyword">null</span>) &#123;<br>          selectedRoute = routeSelection.next();<br>        &#125;<br><br>        // Create a connection and assign it to <span class="hljs-keyword">this</span> allocation immediately. This makes it possible<br>        // <span class="hljs-keyword">for</span> an asynchronous cancel() to interrupt the handshake we're about to <span class="hljs-keyword">do</span>.<br>        route = selectedRoute;<br>        refusedStreamCount = 0;<br>        result = new RealConnection(connectionPool, selectedRoute);//连接池未找到对应连接，建立新连接<br>        acquire(result, <span class="hljs-keyword">false</span>);<br>      &#125;<br>    &#125;<br>     <br>     ...<br>    <br>    <span class="hljs-keyword">synchronized</span> (connectionPool) &#123;<br>      reportedAcquired = <span class="hljs-keyword">true</span>;<br><br>      // Pool the connection.<br>      Internal.instance.put(connectionPool, result);//将新建的连接加入到连接池内<br><br>      // If another multiplexed connection to the same address was created concurrently, then<br>      // release <span class="hljs-keyword">this</span> connection and acquire that one.<br>      <span class="hljs-keyword">if</span> (result.isMultiplexed()) &#123;<br>        socket = Internal.instance.deduplicate(connectionPool, address, <span class="hljs-keyword">this</span>);<br>        result = connection;<br>      &#125;<br>    &#125;<br>     <br>   &#125;<br>  <br>  //OkHttpClient<br>  <span class="hljs-keyword">public</span> class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>      Internal.instance = new Internal() &#123;<br>       ...<br>        @Override <span class="hljs-keyword">public</span> RealConnection get(ConnectionPool pool, Address address,<br>          StreamAllocation streamAllocation, Route route) &#123;<br>           return pool.get(address, streamAllocation, route);//从连接池获取连接<br>        &#125; <br>         <br>        @Override <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> put(ConnectionPool pool, RealConnection connection) &#123;<br>          pool.put(connection);//向连接池添加连接<br>        &#125;<br>       ...<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>通过<code>ConnectInterceptor.intercept()</code>去建立连接，向下调用到<code>StreamAllocation.newStream()</code></p>
<p>在<code>newStream()</code>中继续执行到<code>findConnection()</code>，其中主要执行了两步</p>
<ol>
<li>从<code>ConnectionPool</code>寻找是否存有当前<code>address</code>对应的连接，调用<code>ConnectionPool.get(XXX)</code>，存在就返回对应连接。</li>
<li>不存在对应连接，执行<code>new RealConnection()</code>新建连接，并调用<code>ConnectionPool.put()</code>存储新连接</li>
</ol>
<p>对应的<code>get()、put()</code>都是通过<code>Internal.instance</code>调用的，其中<code>Internal</code>是一个抽象类，具体实现类对应的就是<code>OkHttpClient</code>。</p>
<h4 id="连接池清理连接"><a href="#连接池清理连接" class="headerlink" title="连接池清理连接"></a>连接池清理连接</h4><p>在使用<code>连接池</code>时，初始化了一个<code>Executor</code>线程池，这个主要就是为了在清理无效连接时去开启清理线程用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">  /**<br>   * Background threads are used to cleanup expired connections. There will be at most a single<br>   * thread running per connection pool. The thread pool executor permits the pool itself to be<br>   * garbage collected.<br>   * 清理过期的连接，且保证最多只能运行一个清理线程。<br>   */<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,<br>      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,<br>      new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp ConnectionPool", <span class="hljs-keyword">true</span>));<br><br>//清理过期连接任务<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable cleanupRunnable = new Runnable() &#123;<br>    @Override <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> run() &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">long</span> waitNanos = cleanup(System.nanoTime());//返回下次需要清理连接的时间<br>        <span class="hljs-keyword">if</span> (waitNanos == -1) return;<br>        <span class="hljs-keyword">if</span> (waitNanos &gt; 0) &#123;<br>          <span class="hljs-keyword">long</span> waitMillis = waitNanos / 1000000L;<br>          waitNanos -= (waitMillis * 1000000L);<br>          <span class="hljs-keyword">synchronized</span> (ConnectionPool.<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              ConnectionPool.<span class="hljs-keyword">this</span>.wait(waitMillis, (<span class="hljs-keyword">int</span>) waitNanos);//阻塞等待<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>
<h5 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup()"></a>cleanup()</h5><p>内部主要执行的是<code>标记空闲连接</code>、<code>清理空闲连接</code>，<code>返回下次清理时间</code>这几步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> cleanup(<span class="hljs-keyword">long</span> now) &#123;<br>  <span class="hljs-keyword">int</span> inUseConnectionCount = 0;<br>  <span class="hljs-keyword">int</span> idleConnectionCount = 0;<br>  RealConnection longestIdleConnection = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;<br><br>  // Find either a connection to evict, or the time that the next eviction is due.<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;//遍历连接储存队列<br>      RealConnection connection = i.next();<br><br>      // If the connection is in use, keep searching.<br>      <span class="hljs-keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123;//标记正在使用的活跃连接<br>        inUseConnectionCount++;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      idleConnectionCount++;//非活跃标记为空闲连接<br><br>      // If the connection is ready to be evicted, we're done.<br>      <span class="hljs-keyword">long</span> idleDurationNs = now - connection.idleAtNanos;<br>      <span class="hljs-keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;<br>        longestIdleDurationNs = idleDurationNs;<br>        longestIdleConnection = connection;//得到最长空闲时间的连接<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (longestIdleDurationNs &gt;= <span class="hljs-keyword">this</span>.keepAliveDurationNs<br>        || idleConnectionCount &gt; <span class="hljs-keyword">this</span>.maxIdleConnections) &#123;<br>      // We've found a connection to evict. Remove it from the list, then close it below (outside<br>      // of the <span class="hljs-keyword">synchronized</span> block).<br>      // 空闲连接超过`maxIdleConnections`个或者空闲时间超过`keepAliveDurationNs`，需要清理该连接<br>      connections.remove(longestIdleConnection);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idleConnectionCount &gt; 0) &#123;<br>      // A connection will be ready to evict soon.<br>      // 返回最大空闲连接的到期时间，等待到达时间后进行清理<br>      return keepAliveDurationNs - longestIdleDurationNs;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inUseConnectionCount &gt; 0) &#123;<br>      // All connections are in use. It'll be at least the keep alive duration 'til we run again.<br>      // 所有都是活跃连接，返回最大空闲连接时间，等待到达时间后清理<br>      return keepAliveDurationNs;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      // No connections, idle or in use.<br>      // 当前不存在连接，直接返回 -1，不进行清理任务<br>      cleanupRunning = <span class="hljs-keyword">false</span>;<br>      return -1;<br>    &#125;<br>  &#125;<br>// 立即关闭过期连接<br>  closeQuietly(longestIdleConnection.socket());<br><br>  // Cleanup again immediately.<br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>cleanup()</code>执行流程如下：</p>
<ul>
<li>遍历<code>ConnectionPool</code>的<code>connections</code>，通过<code>pruneAndGetAllocationCount()</code>判断<code>connection</code>是否空闲</li>
<li>遍历完毕后，找到最长时间的空闲连接(<code>longestIdleConnection</code>)</li>
<li>得到<code>longestIdleConnection</code>后，先是比较当前的<code>idleConnectionCount</code>是否大于<code>maxIdleConnections</code>或者<code>longestIdleDurarionNs</code>是否大于<code>keepAliveDurationNs</code>，两者满足其一，则清理掉<code>longestIdleConnection</code></li>
<li>不满足其上条件，继续判断<code>idleConnectionCount &gt; 0</code>，表示当前存在空闲连接，就返回距离最大空闲连接时间差<code>keepAliveDurationNs - longestIdleDurationNs</code>，等待到时清理</li>
<li>不满足其上条件，继续判断<code>inUseConnectionCount &gt; 0</code>，表示当前都是活跃连接，返回<code>keepAliveDurationNs</code>，等待达到时间清理</li>
<li>以上条件都不满足，表示当前没有连接，直接返回<code>-1</code></li>
<li>存在<code>longestIdleConnection</code>，即调用<code>longestIdleConnection.socket().close()</code>关闭连接即可</li>
</ul>
<h5 id="pruneAndGetAllocationCount-Connection"><a href="#pruneAndGetAllocationCount-Connection" class="headerlink" title="pruneAndGetAllocationCount(Connection)"></a>pruneAndGetAllocationCount(Connection)</h5><p>判断当前连接是否正在活跃，采用了<strong>引用计数法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> pruneAndGetAllocationCount(RealConnection connection, <span class="hljs-keyword">long</span> now) &#123;<br>  //连接弱引用列表<br>  List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0; i &lt; references.size(); ) &#123;<br>    //获取引用连接<br>    Reference&lt;StreamAllocation&gt; reference = references.get(i);<br>    //不为<span class="hljs-keyword">null</span> ，表示当前连接尚未回收<br>    <span class="hljs-keyword">if</span> (reference.get() != <span class="hljs-keyword">null</span>) &#123;<br>      i++;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    // We've discovered a leaked allocation. This is an application bug.<br>    StreamAllocation.StreamAllocationReference streamAllocRef =<br>        (StreamAllocation.StreamAllocationReference) reference;<br>    String message = "A connection to " + connection.route().address().url()<br>        + " was leaked. Did you forget to close a response body?";<br>    Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);<br><br>    //移除引用<br>    references.remove(i);<br>    connection.noNewStreams = <span class="hljs-keyword">true</span>;<br><br>    // If <span class="hljs-keyword">this</span> was the last allocation, the connection is eligible <span class="hljs-keyword">for</span> immediate eviction.<br>    //所有引用都被移除，表示当前连接处于空闲<br>    <span class="hljs-keyword">if</span> (references.isEmpty()) &#123;<br>      connection.idleAtNanos = now - keepAliveDurationNs;<br>      return 0;<br>    &#125;<br>  &#125;<br><br>  return references.size();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>StreamAllocation</code>引用是在<code>StreamAllocation.acquire()</code>时加入的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> acquire(RealConnection connection, <span class="hljs-keyword">boolean</span> reportedAcquired) &#123;<br>  <span class="hljs-keyword">assert</span> (Thread.holdsLock(connectionPool));<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection != <span class="hljs-keyword">null</span>) throw new IllegalStateException();<br><br>  <span class="hljs-keyword">this</span>.connection = connection;<br>  <span class="hljs-keyword">this</span>.reportedAcquired = reportedAcquired;<br>  connection.allocations.add(new StreamAllocationReference(<span class="hljs-keyword">this</span>, callStackTrace));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过这种<code>引用计数法</code>来判断当前是否为空闲连接</p>
<h2 id="OkHttp-Cookie机制"><a href="#OkHttp-Cookie机制" class="headerlink" title="OkHttp-Cookie机制"></a>OkHttp-Cookie机制</h2><p><img src="/images/OkHttp-Cookie机制.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-Cookie机制"></p>
<p>使用方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">OkHttpClient.Builder()<br>  .//其他参数<br>  .cookieJar(<span class="hljs-keyword">object</span> : CookieJar &#123;<br>     <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> saveFromResponse(url:HttpUrl,cookies:MutableList&lt;Cookie&gt;)&#123;<br>       //从Response 获取Cookie信息 并存储到本地<br>     &#125;<br>    <br>     <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> loadForRequest(url:HttpUrl) : MutableList&lt;Cookie&gt; &#123;<br>       //根据url获取存储本地的Cookie信息 放到 Request请求中<br>     &#125;<br>  &#125;)<br></code></pre></td></tr></table></figure>
<p><code>Cookie</code>一般都会在请求中进行使用，多用于请求头的<code>Cookie</code>字段，大致可以猜测相关的处理位于<code>BridgeInterceptor</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java">//BridgeInterceptor.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class BridgeInterceptor implements Interceptor&#123;<br>  //这个也就是在 构建Client时放入的CookieJar对象<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CookieJar cookieJar;<br>  <br>    @Override <span class="hljs-keyword">public</span> Response intercept(Chain chain) <span class="hljs-keyword">throws</span> IOException &#123;<br>  ...<br>    //从配置的cookiejar中获取信息<br>     List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());<br>     <span class="hljs-keyword">if</span> (!cookies.isEmpty()) &#123;<br>       //在请求头中添加 Cookie请求头，携带Cookie参数<br>       requestBuilder.header("Cookie", cookieHeader(cookies));<br>     &#125;<br>  ...   <br>    //请求最后得到的 response结果<br>    Response networkResponse = chain.proceed(requestBuilder.build());<br>    //从rensponse中解析Cookie并缓存到 CookieJar中<br>    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());<br>      <br>    &#125;<br>&#125;<br><br>//HttpHeaders.java<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) &#123;<br>    <span class="hljs-keyword">if</span> (cookieJar == CookieJar.NO_COOKIES) return;<br><br>    List&lt;Cookie&gt; cookies = Cookie.parseAll(url, headers);<br>    <span class="hljs-keyword">if</span> (cookies.isEmpty()) return;<br>    //获取到Cookie对象 缓存中 CookieJar中<br>    cookieJar.saveFromResponse(url, cookies);<br>  &#125;<br><br>//Cookie.java<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Cookie&gt; parseAll(HttpUrl url, Headers headers) &#123;<br>    //从响应头中读取到 Set-Cookie字段，并转换成 Cookie对象<br>    List&lt;String&gt; cookieStrings = headers.values("Set-Cookie");<br>    List&lt;Cookie&gt; cookies = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0, size = cookieStrings.size(); i &lt; size; i++) &#123;<br>      Cookie cookie = Cookie.parse(url, cookieStrings.get(i));<br>      <span class="hljs-keyword">if</span> (cookie == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (cookies == <span class="hljs-keyword">null</span>) cookies = new ArrayList&lt;&gt;();<br>      cookies.add(cookie);<br>    &#125;<br><br>    return cookies != <span class="hljs-keyword">null</span><br>        ? Collections.unmodifiableList(cookies)<br>        : Collections.&lt;Cookie&gt;emptyList();<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>Cookie</code>原理简述：</p>
<blockquote>
<p>服务端返回的<code>Response</code>通过<code>Set-Cookie</code>响应头返回对应的<code>Cookie信息</code>，以便在下次进行请求时在<code>Request</code>的请求头中添加<code>Cookie</code>字段以携带Cookie信息。</p>
<p><code>OkHttp</code>通过<code>setCookieJar</code>对所有的<code>Cookie</code>文件进行管理。</p>
<ul>
<li><code>saveFromResponse()</code>：可以获取对应域名的Cookie信息</li>
<li><code>loadForRequest()</code>：可以在请求域名时添加Cookie信息</li>
</ul>
<p>可以通过一个全局的<code>CookieJar</code>类来实现应用内Cookie文件的管理。</p>
</blockquote>
<h2 id="OkHttp-DNS功能"><a href="#OkHttp-DNS功能" class="headerlink" title="OkHttp-DNS功能"></a>OkHttp-DNS功能</h2><h3 id="DNS介绍"><a href="#DNS介绍" class="headerlink" title="DNS介绍"></a>DNS介绍</h3><p><code>Domain Name System</code>：根据域名查出IP地址，是<code>HTTP协议</code>的前提，只有将域名正确的进行解析，得到IP地址后，才可以继续进行网络连接。</p>
<p>DNS服务器结构如下：</p>
<ul>
<li><code>根DNS服务器</code>：返回顶级DNS服务器的IP地址</li>
<li><code>顶级域DNS服务器</code>：返回权威DNS服务器的IP地址</li>
<li><code>权威DNS服务器</code>：返回对应主机的IP地址</li>
</ul>
<p><img src="/images/DNS服务器结构" srcset="/img/loading.gif" lazyload="" alt="img"></p>
<h4 id="LocalDNS"><a href="#LocalDNS" class="headerlink" title="LocalDNS"></a>LocalDNS</h4><p><img src="/images/OkHttp-LocalDNS.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-LocalDNS"></p>
<p><strong>运营商提供的DNS服务器</strong>，请求时优先查询<code>LocalDNS 缓存</code>，存在直接使用。不存在就需要从<code>根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威域名服务器</code>往上查询可用的<code>IP地址</code>。</p>
<p><img src="/images/DNS请求过程" srcset="/img/loading.gif" lazyload="" alt="img"></p>
<h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ol>
<li><p>不稳定</p>
<blockquote>
<p>DNS劫持或者服务器故障，导致解析服务不可用</p>
</blockquote>
</li>
<li><p>不准确</p>
<blockquote>
<p><code>LocalDNS调度</code>不一定是<strong>就近原则</strong>。某些运营商会把解析请求转发到其他运营商的<code>LocalDNS</code>服务器。</p>
<p>就会导致解析出的IP不是就近服务器，致使访问变慢甚至无法访问。</p>
</blockquote>
</li>
<li><p>不及时</p>
<blockquote>
<p>运营商可能修改DNS的<code>TTL(Time-To-Live，DNS缓存时间)</code>，导致DNS解析结构发生修改，但是在当前请求条件下尚未生效。</p>
</blockquote>
</li>
</ol>
<p><img src="/images/640-2236080." srcset="/img/loading.gif" lazyload="" alt="img"></p>
<h4 id="HttpDNS"><a href="#HttpDNS" class="headerlink" title="HttpDNS"></a>HttpDNS</h4><p><img src="/images/OkHttp-HTTPDNS.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-HTTPDNS"></p>
<p><code>HTTPDNS</code>利用<code>HTTP协议</code>与DNS服务交互，绕开了运营商<code>LocalDNS</code>服务，有效防止了域名劫持以及提高了域名解析成功率。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img src="/images/HTTPDNS原理.jpeg" srcset="/img/loading.gif" lazyload="" alt="img"></p>
<ol>
<li>客户端直接访问<code>HttpDNS</code>接口，获取域名在<code>HTTPDNS服务器</code>上的最优IP(从容灾方面考虑，还需要保留<code>LocalDNS</code>请求)</li>
<li>客户端获取到<code>IP</code>后，直接向该<code>IP</code>发起HTTP请求</li>
</ol>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ol>
<li>降低了<code>UnknownHostException</code>异常发生</li>
<li>调度精准，根据用户IP，精准获取域名对应IP</li>
<li>扩展性强，可以自定义域名对应IP规则</li>
</ol>
<h3 id="OkHttp-HttpDNS实现"><a href="#OkHttp-HttpDNS实现" class="headerlink" title="OkHttp-HttpDNS实现"></a>OkHttp-HttpDNS实现</h3><p>OkHttp提供了<code>Dns接口</code>，可以进行自定义拓展替代本身的<code>LocalDNS</code>解析方式</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//自定义DNS<br><span class="hljs-keyword">class</span> OptimizeLocalDNS : Dns&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> lookup(hostname: String): List&lt;InetAddress&gt; &#123;<br>        return DNSLookUpUtil.loadLocalDNS(hostname)<br>    &#125;<br>&#125;<br><br>//设置LocalDNS超时取消<br>        <span class="hljs-keyword">fun</span> loadLocalDNS(hostname: String, timeout: <span class="hljs-built_in">Long</span> = 10L): List&lt;InetAddress&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">val</span> task = FutureTask&lt;List&lt;InetAddress&gt;&gt;(Callable&lt;List&lt;InetAddress&gt;&gt; &#123;<br>                    //返回去重结果<br>                    InetAddress.getAllByName(hostname).toList().distinct()<br>                &#125;)<br>                Thread(task).start()<br>                return task.<span class="hljs-keyword">get</span>(timeout, TimeUnit.SECONDS)<br>            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            &#125;<br>            return listOf()<br>        &#125;<br><br>//设置自定义DNS<br>mOkHttpClient = httpBuilder<br>        .dns(OptimizeLocalDNS())<br>        .build();<br></code></pre></td></tr></table></figure>
<h3 id="OkHttp-DNS原理"><a href="#OkHttp-DNS原理" class="headerlink" title="OkHttp-DNS原理"></a>OkHttp-DNS原理</h3><p>配置的<code>dns()</code>初始使用位于<code>RetryAndFollowUpInterceptor.intercept()</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class RetryAndFollowUpInterceptor implements Interceptor &#123;<br>  ...<br>   @Override <span class="hljs-keyword">public</span> Response intercept(Chain chain) <span class="hljs-keyword">throws</span> IOException &#123;<br>    ...<br>        StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),<br>        createAddress(request.url()), call, eventListener, callStackTrace);<br>   &#125;<br>  <br>   <span class="hljs-keyword">private</span> Address createAddress(HttpUrl url) &#123;<br>    ...<br>    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),<br>        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),<br>        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());<br>  &#125;<br> <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>构造出一个<code>Address</code>对象，里面包含了<code>主机名(host)、端口(port)、DNS配置(DNS)、SSL配置(sslSocketFactory,certificatePinner)、代理设置</code></p>
<p>得到<code>Address</code>，通过<code>StreamAllocation</code>构造了<code>RouteSelector</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> StreamAllocation(ConnectionPool connectionPool, Address address, Call call,<br>    EventListener eventListener, Object callStackTrace) &#123;<br>  <span class="hljs-keyword">this</span>.connectionPool = connectionPool;<br>  <span class="hljs-keyword">this</span>.address = address;<br>  <span class="hljs-keyword">this</span>.call = call;<br>  <span class="hljs-keyword">this</span>.eventListener = eventListener;<br>  <span class="hljs-keyword">this</span>.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);<br>  <span class="hljs-keyword">this</span>.callStackTrace = callStackTrace;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>RouteSelector</code>主要为了<strong>Select Route(选择路由)，返回一个可用的<code>Route</code>对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> resetNextInetSocketAddress(Proxy proxy) <span class="hljs-keyword">throws</span> IOException &#123;<br>    // Clear the addresses. Necessary <span class="hljs-keyword">if</span> getAllByName() below <span class="hljs-keyword">throws</span>!<br>    inetSocketAddresses = new ArrayList&lt;&gt;();<br><br>    String socketHost;<br>    <span class="hljs-keyword">int</span> socketPort;<br>    <span class="hljs-keyword">if</span> (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) &#123;//存在代理<br>      socketHost = address.url().host();<br>      socketPort = address.url().port();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      SocketAddress proxyAddress = proxy.address();<br>      <span class="hljs-keyword">if</span> (!(proxyAddress <span class="hljs-keyword">instanceof</span> InetSocketAddress)) &#123;<br>        throw new IllegalArgumentException(<br>            "Proxy.address() is not an " + "InetSocketAddress: " + proxyAddress.getClass());<br>      &#125;<br>      InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;<br>      socketHost = getHostString(proxySocketAddress);<br>      socketPort = proxySocketAddress.getPort();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (socketPort &lt; 1 || socketPort &gt; 65535) &#123;<br>      throw new SocketException("No route to " + socketHost + ":" + socketPort<br>          + "; port is out of range");<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;//解析的直接为代理地址<br>      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      //dns开始解析监听<br>      eventListener.dnsStart(call, socketHost);<br><br>      // Try each address <span class="hljs-keyword">for</span> best behavior in mixed IPv4/IPv6 environments.<br>      List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);//通过配置的DNS去解析对应域名的IP列表<br>      <span class="hljs-keyword">if</span> (addresses.isEmpty()) &#123;<br>        throw new UnknownHostException(address.dns() + " returned no addresses <span class="hljs-keyword">for</span> " + socketHost);<br>      &#125;<br>      //dns解析结束监听<br>      eventListener.dnsEnd(call, socketHost, addresses);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = 0, size = addresses.size(); i &lt; size; i++) &#123;<br>        InetAddress inetAddress = addresses.get(i);<br>        inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p><code>resetNextInetSocketAddress()</code>返回<code>List&lt;InetSocketAddress&gt;</code>，区分了一下两种情况</p>
<ul>
<li>设置了<code>proxies</code>代理服务器，直接返回<code>InetSocketAddress(socketHost,socketPort)</code>代理服务器对应的地址和端口</li>
<li>未设置代理服务器，通过设置的<code>dns</code>去解析对应域名(<code>dns.lookup(host)</code>)得到<code>List&lt;InetAddress&gt;</code>对应的IP列表，在返回对应地址</li>
</ul>
<h2 id="OkHttp-HTTP2-0协议支持"><a href="#OkHttp-HTTP2-0协议支持" class="headerlink" title="OkHttp-HTTP2.0协议支持"></a>OkHttp-HTTP2.0协议支持</h2><p><img src="/images/OkHttp-HTTP2.0.png" srcset="/img/loading.gif" lazyload="" alt="OkHttp-HTTP2.0"></p>
<blockquote>
<p>基于<code>二进制分帧</code>、<code>首部压缩</code>和<code>服务端推送</code>进行分析</p>
</blockquote>
<p>//TODO</p>
<h2 id="OkHttp拓展"><a href="#OkHttp拓展" class="headerlink" title="OkHttp拓展"></a>OkHttp拓展</h2><h3 id="请求时间获取"><a href="#请求时间获取" class="headerlink" title="请求时间获取"></a>请求时间获取</h3><p><img src="/images/OkHttp解析节点" srcset="/img/loading.gif" lazyload="" alt="img"></p>
<p><code>EventListener</code>是OkHttp提供的监听回调，可以通过实现这个抽象类监听到网络请求各阶段的时间点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> class EventListener &#123;<br>   //请求相关回调<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> callStart(Call call) &#123;&#125; <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> callEnd(Call call) &#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> callFailed(Call call, IOException ioe) &#123;&#125;  <br>  <br>   //dns解析回调<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> dnsStart(Call call, String domainName) &#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> dnsEnd(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList) &#123;&#125;<br>  <br>   //请求连接相关回调<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy)&#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> connectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,@Nullable Protocol protocol) &#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,<br>      @Nullable Protocol protocol, IOException ioe) &#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> connectionAcquired(Call call, Connection connection)&#123;&#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> connectionReleased(Call call, Connection connection)&#123;&#125;<br>  <br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="DNS解析耗时"><a href="#DNS解析耗时" class="headerlink" title="DNS解析耗时"></a>DNS解析耗时</h4><p>只要监听<code>dnsStart()</code>和<code>dnsEnd()</code>之间的时间差即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> dnsStartTime;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> dnsDuration = -1L;    <br><br>@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> dnsStart(Call call, String domainName) &#123;<br>    <span class="hljs-keyword">super</span>.dnsStart(call, domainName);<br>    recordEventLog("dnsStart");<br>    dnsStartTime = System.nanoTime();<br>&#125;<br><br>@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> dnsEnd(Call call, String domainName, List&lt;InetAddress&gt; inetAddressList) &#123;<br>    <span class="hljs-keyword">super</span>.dnsEnd(call, domainName, inetAddressList);<br>    recordEventLog("dnsEnd");<br>    dnsDuration = (System.nanoTime() - dnsStartTime) / 1000000;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> getDnsDuration() &#123;<br>    return dnsDuration;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>dnsDuration</code>即为DNS解析耗时</p>
<h4 id="请求连接耗时"><a href="#请求连接耗时" class="headerlink" title="请求连接耗时"></a>请求连接耗时</h4><p>初始连接耗时</p>
<blockquote>
<p>使用Socket建立TCP连接，初始连接表示的就是<code>Socket建立连接的过程</code></p>
</blockquote>
<p>只要监听<code>connectStart()</code>和<code>connectEnd()</code>之间的时间差。</p>
<p>复用连接耗时</p>
<blockquote>
<p>OkHttp设置<code>ConnectionPool</code>，可以复用已存在的连接</p>
</blockquote>
<p>需要监听<code>connectAcquired()</code>和<code>connectReleased()</code>之间的时间差</p>
<h3 id="IP直连问题"><a href="#IP直连问题" class="headerlink" title="IP直连问题"></a>IP直连问题</h3><p>//TODO</p>
<h2 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h2><p><a href="https://juejin.im/post/5a704ed05188255a8817f4c9" target="_blank" rel="noopener">开源框架源码鉴赏：OkHttp</a><br><a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">彻底弄懂HTTP缓存机制及原理</a></p>
<p><a href="https://mp.weixin.qq.com/s/iaPtSF-twWz-AN66UJUBDg" target="_blank" rel="noopener">百度App网络深度优化系列《一》DNS优化</a></p>
<p><a href="https://juejin.im/post/6844903785232498696#heading-4" target="_blank" rel="noopener">HTTP2.0相关</a></p>
<p><a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener">HPACK算法</a></p>
<p><a href="https://sq.163yun.com/blog/article/188769987293102080" target="_blank" rel="noopener">HTTP/2首部压缩的OkHttp3实现</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/源码解析/">源码解析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/03/12/WebView相关知识/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">WebView相关知识</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/03/08/Retrofit简析/">
                        <span class="hidden-mobile">Retrofit简析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
