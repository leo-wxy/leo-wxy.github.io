

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  
    <meta name="description" content="基础概念 线程：进程中负责执行的执行单元，一个进程中至少有一个线程,操作系统能够进行调度的最小单位 进程：一个执行中的程序的实例 多线程：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU确定，因此多线程具有不确定性 线程池： 基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理，当有线程任务">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-线程池">
<meta property="og:url" content="http://example.com/2019/09/13/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.html">
<meta property="og:site_name" content="Wxy的个人博客">
<meta property="og:description" content="基础概念 线程：进程中负责执行的执行单元，一个进程中至少有一个线程,操作系统能够进行调度的最小单位 进程：一个执行中的程序的实例 多线程：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU确定，因此多线程具有不确定性 线程池： 基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理，当有线程任务">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0mind.png">
<meta property="og:image" content="http://example.com/images/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E6%B1%A0.png">
<meta property="og:image" content="http://example.com/images/582d1606d57ff99aa0e5f8fc59c7819329028.png">
<meta property="og:image" content="http://example.com/images/640">
<meta property="og:image" content="http://example.com/images/77441586f6b312a54264e3fcf5eebe2663494.png">
<meta property="og:image" content="http://example.com/images/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.png">
<meta property="og:image" content="http://example.com/images/03268b9dc49bd30bb63064421bb036bf90315.png">
<meta property="og:image" content="http://example.com/images/640-1293801.">
<meta property="article:published_time" content="2019-09-13T02:19:28.000Z">
<meta property="article:modified_time" content="2020-12-02T09:36:48.000Z">
<meta property="article:author" content="Leo-Wxy">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/images/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0mind.png">
  
  
  
  <title>Java-线程池 - Wxy的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":false};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 30vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wxy&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Java-线程池</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-09-13 10:19" pubdate>
          2019年9月13日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          25 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java-线程池</h1>
            
            
              <div class="markdown-body">
                
                <p><img src="/images/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0mind.png" srcset="/img/loading.gif" lazyload alt="Java线程池"></p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li><strong>线程</strong>：进程中负责执行的执行单元，一个进程中至少有一个线程,<strong>操作系统能够进行调度的最小单位</strong></li>
<li><strong>进程</strong>：一个执行中的程序的实例</li>
<li><strong>多线程</strong>：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU确定，因此多线程具有不确定性</li>
<li><strong>线程池</strong>： 基本思想是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理，当有线程任务时，从池中取一个，执行完成后线程对象回归池中，避免反复创建线程对象所带来的性能开销，节省系统资源。</li>
</ul>
<h3 id="线程池的概念"><a href="#线程池的概念" class="headerlink" title="线程池的概念"></a>线程池的概念</h3><p>在执行一个异步任务或并发任务时，往往会通过<code>new Thread()</code>方法去开启一个子线程去执行任务，等到子线程操作完成后在利用<code>Handler</code>切换至主线程。但是利用这种方法我们无法对自己创建的子线程进行有效的管理，然后由于过多的创建子线程，他们之间相互竞争会导致资源的过度占用。线程池的出现就是为了来对子线程进行管理。</p>
<h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h3><ul>
<li>**降低资源消耗。**通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>**提高响应速度。**当任务到达时，任务可以不需要等到线程创建就可以立即执行</li>
<li>**提高线程的可管理性。**线程是稀缺资源，大量创建会导致系统资源过度消耗且会降低系统的稳定性，线程池可以有效控制线程数，并进行统一的分配、调优和监控。</li>
</ul>
<h3 id="线程池的构造参数与对象成员变量"><a href="#线程池的构造参数与对象成员变量" class="headerlink" title="线程池的构造参数与对象成员变量"></a>线程池的构造参数与对象成员变量</h3><p><img src="/images/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="线程池构造参数"></p>
<p><code>Executors</code>提供了基础的四类线程池方法，最终都是通过<code>ThreadPoolExecutor</code>类完成。对于这个类的描述<code>他维护了一个线程池，对于提交Executor中的任务，不是创建新的线程而是使用池内的线程来执行任务。可以显著减少对于任务执行的开销。</code></p>
<ol>
<li><p>ThreadPoolExecutor构造函数介绍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure>

<p>参数介绍：</p>
<ul>
<li><p><strong><code>corePoolSize 核心线程数</code></strong> 表示线程池中的基本线程数量即核心线程数量。一般情况下核心线程会一直存活在线程池中，即便他们处于闲置状态。只有在<code>ThreadPoolExecutor的allowCoreThreadTimeOut设置为true</code>的时候，会有一个超时策略（超过设置好的超时时间，闲置的核心线程会被终止）。<strong>当创建的线程数小于corePoolSize时，不管有没有空闲线程都会创建新的线程</strong>。</p>
</li>
<li><p><strong><code>maximumPoolSize 最大线程数</code></strong>  表示线程池中允许的最大创建线程数，当活动的线程数达到数值后，后续新任务会被阻塞。<strong>使用有界队列时，未达到该值则会创建新的线程，使用无界队列时该值无效。</strong></p>
</li>
<li><p><strong><code>keepAliveTime 非核心线程闲置时的超时时长</code></strong> 表示空闲非核心线程的最大存活时间，一旦超过即被销毁。<strong>当<code>ThreadPoolExecutor的allowCoreThreadTimeOut设置为true</code>的时候，该参数也可作用于核心线程</strong></p>
</li>
<li><p><strong><code>unit 存活时间的时间单位</code></strong> 用于指定keepAliveTime参数的时间单位，为一个枚举类型。包含下列参数：<code>NANOSECONDS（纳秒）</code>,<code>MICROSECONDS（微秒）</code>,<code>MILLSECONDS（毫秒）</code>,<code>SECONDS（）秒</code>,<code>MINUTES（分）</code>,<code>HOURS（时）</code>,<code>DAYS（天）</code></p>
</li>
<li><p><strong><code>workQueue 线程池中的任务队列</code></strong> 该队列是<code>java.util.BlockingQueue&lt;E&gt;</code>的一个实例，是一种阻塞队列用来存放等待执行的任务。通过<code>execute()</code>方法将提交的Runnable对象存储进去。根据具体实现类的不同可以分为以下三种队列策略：</p>
<ul>
<li><code>容量为0即直接提交策略--SynchronousQueue</code>：等待队列容量为0 ，所有需要阻塞的任务必须等待池内的某个线程有空闲才可以继续执行，否则阻塞。<code>CachedThreadPool</code>使用该队列策略。</li>
<li><code>容量无限即无界队列策略--LinkedBlockingQueue</code>：等待队列的长度无穷大，在这种策略下不会出现多余corePoolSize的线程被创建，所以maximumPoolSize以及handler无效，因为不存在队列满的情况。不过也有缺点：<strong>线程的执行速度会比提交速度慢，会导致无界队列快速增长，直到系统资源耗尽。</strong><code>fixedThreadPool</code>采用了这种队列策略。</li>
<li><code>容量有限即有界队列策略--指定了容量的任何BlockingQueue</code>：等待队列的长度为限制长度，指定了容量后可以<strong>防止过多的资源被消耗</strong>。</li>
</ul>
</li>
<li><p><strong><code>threadFactory 线程工厂</code></strong>：是一个接口可以为线程池提供新线程的创建。由同一个threadFactory创建的线程同属于一个ThreadGroup，优先级都为Thread.NORM_PRIORITY，以及为非进程守护状态。默认都是采用<code>Executors.defaultThreadFactory()</code>返回值。</p>
</li>
<li><p><strong><code>handler 拒绝策略</code></strong>：当<strong>使用有界队列时且队列任务被填满后并且线程数也达到了最大值，就会触发拒绝策略</strong>。如果任务被拒绝执行，则会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法，默认调用<code>AbortPolicy</code>拒绝策略，也可以由用户自定义。JDK中定义了4种拒绝策略：</p>
<ul>
<li><p><code>AbortPolicy</code><strong>处理程序遭到拒绝则直接抛出<code>RejectedExecutionException</code>异常然后丢弃该任务。</strong></p>
<p>实现源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                                <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                                e.toString());<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>样例演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><br>        TestRunnable(<span class="hljs-type">int</span> id) &#123;<br>            <span class="hljs-built_in">this</span>.id = id;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.err.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 当前线程id=&quot;</span>+ <span class="hljs-built_in">this</span>.id);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abortPolicyDemo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">1</span>));<br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">2</span>));<br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">3</span>));<br>        threadPoolExecutor.shutdown();<br>    &#125;<br><br>运行结果：添加进程时直接抛出异常但是没有影响后续的进行<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@4b1210ee rejected from java.util.concurrent.ThreadPoolExecutor@4d7e1886[Running, <span class="hljs-type">pool</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, <span class="hljs-type">active</span> <span class="hljs-variable">threads</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, <span class="hljs-type">queued</span> <span class="hljs-variable">tasks</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, <span class="hljs-type">completed</span> <span class="hljs-variable">tasks</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>]<br>    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="hljs-number">2047</span>)<br>    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="hljs-number">823</span>)<br>    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="hljs-number">1369</span>)<br>    at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:<span class="hljs-number">112</span>)<br>    at threadpool.ThreadPoolDemo.abortPolicyDemo(ThreadPoolDemo.java:<span class="hljs-number">140</span>)<br>    at threadpool.ThreadPoolDemo.main(ThreadPoolDemo.java:<span class="hljs-number">13</span>)<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>CallerRunsPolicy</code><strong>在调用<code>execute</code>方法的调用者所在线程来执行被拒绝的任务，提供简单的反馈控制机制，可以减缓新任务的提交速度。</strong></p>
<p>实现源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates a &#123;<span class="hljs-doctag">@code</span> CallerRunsPolicy&#125;.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>                r.run();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>样例演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callerRunsPolicyDemo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">1</span>));<br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">2</span>));<br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">3</span>));<br>        threadPoolExecutor.shutdown();<br>    &#125;<br><br>运行结果：task2执行在了主线程，由于被拒绝执行所以在调用者线程执行了任务<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span><br>main 当前线程id=<span class="hljs-number">3</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>DiscardPolicy</code><strong>被拒绝即无法执行的任务被直接删除</strong></p>
<p>实现源码：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>              <span class="hljs-comment">/**</span><br><span class="hljs-comment">               * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardPolicy&#125;.</span><br><span class="hljs-comment">               */</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>              &#125;<br>          &#125;<br></code></pre></td></tr></table></figure>

<p>样例演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discardPolicyDemo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardPolicy());<br><br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">1</span>));<br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">2</span>));<br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">3</span>));<br>        threadPoolExecutor.shutdown();<br>    &#125;<br><br>运行结果：由于被拒绝执行在该策略下被直接抛弃<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>DiscardOldestPolicy</code><strong>判断线程池是否被关闭，没有则丢弃最老的一个请求，再尝试提交当前任务。</strong></p>
<p>实现源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardOldestPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * Creates a &#123;<span class="hljs-doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-keyword">public</span> <span class="hljs-title function_">DiscardOldestPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br>             <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>                 <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>                     e.getQueue().poll();<br>                     e.execute(r);<br>                 &#125;<br>             &#125;<br>         &#125;<br></code></pre></td></tr></table></figure>

<p>样例演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discardOldestPolicyDemo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());<br><br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">1</span>));<br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">2</span>));<br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">3</span>));<br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">4</span>));<br>        threadPoolExecutor.shutdown();<br>    &#125;<br><br>运行结果：???<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>CustomRejectPolicy 自定义拒绝策略</code><strong>可以用来记录运行日志或者记录无法处理的任务</strong></p>
<p>样例演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 自定义拒绝策略，实现RejectedExecutionHandler接口即可</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomRejectedPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;<br>            <span class="hljs-keyword">if</span> (!executor.isShutdown())&#123;<br>                    System.err.println(<span class="hljs-string">&quot;自定义异常日志记录:  &quot;</span>+  r.toString());<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customPolicyDemo</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomRejectedPolicy</span>());<br><br>    <span class="hljs-comment">//使用execute是因为使用submit时会被封装成RunnableFuture对象</span><br>        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">1</span>));<br>        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">2</span>));<br>        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">3</span>));<br>        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">4</span>));<br><br>        threadPoolExecutor.shutdown();<br>    &#125;<br><br>运行结果：由于<span class="hljs-number">4</span>号被拒绝，记录日志<br>自定义异常日志记录:  java.util.concurrent.FutureTask@4b1210ee<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">2</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> 当前线程id=<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>额外参数扩展 <code>allowCoreThreadTimeOut 允许核心线程过期 </code>默认值为false（线程池已不被使用，但是其中还有活着的线程，则该线程池无法被回收，会造成内存泄露）。所以用户可以显式调用<code>shutDown()</code>或者该值设置为true，则会被回收。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ThreadPoolExecutor的使用</p>
<p>向线程池提交一个任务的方式有两种：</p>
<ul>
<li><p><code>execute</code>：这种方法提交任务，是没有返回值的即无法判断在线程池中是否完成该任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestRunnable</span>(<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>submit</code>：使用<code>submit</code>方法提交任务时，会返回一个future，可以通过这个future来判断任务是否执行成功也可以根据<code>future的get()</code>方法获取返回值。<strong>若子线程任务没完成，<code>get()</code>方法会阻塞直到任务完成，若使用<code>get(long timeout,TimeUnit unit)</code>则会阻塞一段时间后返回，可能尚未完成任务。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;Integer&gt; future = fixedThreadPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>     <br>               <span class="hljs-meta">@Override</span><br>               <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                   System.err.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; , index = &quot;</span> + index);<br>                   <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>               &#125;<br>           &#125;);<br>     <br>           <span class="hljs-keyword">try</span> &#123;<br>               System.err.println(<span class="hljs-string">&quot;Future return :&quot;</span> + future.get().toString());<br>           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               e.printStackTrace();<br>           &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>线程池的关闭</p>
<p>线程池关闭方法有两种：</p>
<ul>
<li><p><code>shutdown()</code>：将线程池的状态置为SHUTDOWN状态，然后中断没有正在执行的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            checkShutdownAccess();<br>            advanceRunState(SHUTDOWN);<br>            interruptIdleWorkers();<br>            onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        tryTerminate();<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>shutdownNow()</code>：将线程池的状态设为STOP状态，中断所有任务包括执行中的线程，并返回等待执行的任务列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Runnable&gt; tasks;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            checkShutdownAccess();<br>            advanceRunState(STOP);<br>            interruptWorkers();<br>            tasks = drainQueue();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        tryTerminate();<br>        <span class="hljs-keyword">return</span> tasks;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>中断线程需要采用<code>interrput</code>方法，<strong>无法响应中断的任务可能永远无法终止。</strong></p>
<p>当需要立即中断所有线程并且不在乎任务是否执行完成时，可以使用<code>shutdownNow</code>方法。</p>
</li>
</ul>
</li>
<li><p>线程池的拓展</p>
<p><code>ThreadPoolExecutor</code>默认提供三个空方法，可以通过重写这三个方法来监控线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//任务执行前 记录任务开始前时间</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123; &#125;<br><span class="hljs-comment">//任务执行后 记录任务结束时间</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123; &#125;<br><span class="hljs-comment">//线程池关闭 记录线程池关闭事件以及执行过的线程数量</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">terminated</span><span class="hljs-params">()</span> &#123; &#125;<br></code></pre></td></tr></table></figure>

<p>样例演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span>&#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize, <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>            <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>            <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>            System.err.println(<span class="hljs-string">&quot;beforeExecute&quot;</span>+r.toString());<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>            <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>            System.err.println(<span class="hljs-string">&quot;afterExecute&quot;</span>+r.toString());<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">terminated</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.terminated();<br>            System.err.println(<span class="hljs-string">&quot;线程关闭&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="线程池的分类以及各自的特性"><a href="#线程池的分类以及各自的特性" class="headerlink" title="线程池的分类以及各自的特性"></a>线程池的分类以及各自的特性</h3><p><img src="/images/Java-%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" srcset="/img/loading.gif" lazyload alt="Java-常见线程池"></p>
<p>利用<code>Executors</code>类提供了四种不同的线程池，他们都是直接或者间接配置<code>ThreadPoolExecutor</code>来实现功能。下面分别介绍着四个线程池</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><code>newFixedThreadPool</code></h4><blockquote>
<p>创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程池的大小一旦达到最大值就不会发生变化，如果某个线程因为异常而结束，则会补充一个新进程。</p>
<p>由于只设置核心线程大小，所以可以<strong>更快的响应外界请求</strong></p>
<p>线程池的大小设置，可以使用<code>Runtime.getRuntime().availableProcessors()</code></p>
</blockquote>
<ul>
<li><p>实现源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 设置了核心线程，并且没有超时机制，使用LinkedBlockingQueue则任务队列大小是无上限的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>样例演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixedThreadPoolDemo</span><span class="hljs-params">()</span>&#123;<br>        ExecutorService fixedThreadPool= Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">6</span> ; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> index=i;<br>            fixedThreadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    System.err.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; , index = &quot;</span>+index);<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-keyword">try</span>&#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>运行结果：整个过程都在pool-<span class="hljs-number">1</span>的线程池中运行,然后复用线程<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">0</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> , index = <span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> , index = <span class="hljs-number">2</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">3</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> , index = <span class="hljs-number">4</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> , index = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>适用场景</p>
<p>用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。</p>
</li>
</ul>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><code>newCachedThreadPool</code></h4><blockquote>
<p>可根据需要创建新线程的线程池，但是在一起构造的线程可用时将重用他们。对于很多短期异步任务的程序而言，这类线程池可以提高性能。</p>
<p>如果现有线程没有可用的，则会创建一个新的线程并添加到池中，终止并从缓存中移除那些超过60s没有使用的线程。<strong>因此，长时间保持空闲的newCachedThreadPool线程池是不存在任何线程的，所以这时候几乎不占用系统资源。</strong></p>
</blockquote>
<ul>
<li><p>实现源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 核心线程数为0 线程最大为Int的最大值所以可以认定为线程池最大线程无限大，设置了超时时间为60s。任务队列采用了阻塞队列(必须池内有空闲线程才可以执行)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>样例演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cachedThreadPoolDemo</span><span class="hljs-params">()</span>&#123;<br>        ExecutorService cachedThreadPool= Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">6</span> ; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> index=i;<br>            cachedThreadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    System.err.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; , index = &quot;</span>+index);<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-keyword">try</span>&#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>运行结果：整个过程都在同一个线程pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>中执行，后面线程复用前面的线程<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">0</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">2</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">3</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">4</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>适用场景</p>
<p>并发执行大量短期的小任务，或者负载较轻的服务器</p>
</li>
</ul>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><code>newScheduledThreadPool</code></h4><blockquote>
<p>创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<ul>
<li><p>实现源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 核心线程数固定，非核心线程数为无限大，当非核心数处于闲置状态的时候会被立即回收</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>样例演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleThreadPoolDemo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledThreadPool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br>     <span class="hljs-comment">//延迟一定时间后执行Runnable任务</span><br>        scheduledThreadPool.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.err.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; delay 2s&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>     <span class="hljs-comment">//延迟一定时间后执行Callable任务</span><br>        scheduledThreadPool.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>     <span class="hljs-comment">//延迟一定时间（initialDelay）后,以(period)时间间隔执行任务</span><br>        scheduledThreadPool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.err.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; every 3s&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>     <span class="hljs-comment">//延迟一定时间（initialDelay）后,以(delay即上一个任务执行结束到下一个任务开始的间隔)执行</span><br>        scheduledThreadPool.scheduleWithFixedDelay(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.err.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; delay 3s&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>运行结果：<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> every 3s<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> delay 3s<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> delay 3s <span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> every 3s<br></code></pre></td></tr></table></figure>
</li>
<li><p>适用场景</p>
<p>用于需要多个后台线程执行周期任务，同时需要限制线程数量</p>
</li>
</ul>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><code>newSingleThreadExecutor</code></h4><blockquote>
<p>创建一个单线程池，该线程池中只有一个线程在工作，其他任务都会依次在任务中排列中等候依次执行，任务是串行执行的。此线程池保证所有的任务的执行顺序按照任务提交顺序执行(FIFO-先进先出)。</p>
</blockquote>
<ul>
<li><p>实现源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 只有一个核心线程，对任务队列没有大小限制，将所有外界任务统一到一个线程执行所有我们不需要处理线程同步的问题。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>样例演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">singleThreadPoolDemo</span><span class="hljs-params">()</span>&#123;<br>        ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i;<br>            singleThreadExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    System.err.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; , index = &quot;</span> + index);<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>运行结果：所有的任务都是在pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>中依次运行<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">0</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">2</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">3</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">4</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> , index = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>适用场景</p>
<p>用于串行执行任务的场景，每个任务需要顺序执行</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>newCachedThreadPool</th>
<th>newFixedThreadPool</th>
<th>newSingleThreadExecutor</th>
<th>newScheduledThreadPool</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize&#x2F;<br>maximumPoolSize</td>
<td>0&#x2F;Integer.MAX<br> <code>创建非核心线程</code>执行任务</td>
<td>n&#x2F;n<br><code>创建核心线程</code>执行任务</td>
<td>1&#x2F;1<br><code>只创建1个核心线程</code>执行任务</td>
<td>n&#x2F;Integer.MAX</td>
</tr>
<tr>
<td>workQueue</td>
<td>SynchronousQueue</td>
<td>LinkedBlockingQueue(Integer.MAX)</td>
<td>LinkedBlockingQueue(Integer.MAX)</td>
<td>DelayedQueue</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>60s<br />即使没有任务进来，线程也会被很快回收</td>
<td>0ms<br />没有任务的情况下，线程会一直被阻塞等待任务</td>
<td>0ms<br />没有任务的情况下，线程会一直被阻塞等待任务</td>
<td>10s</td>
</tr>
<tr>
<td>适用场景</td>
<td>并发执行大量短期的小任务，或者负载较轻的服务器</td>
<td>用于负载较重的服务器，合理的利用服务器资源</td>
<td>用于串行执行任务的场景，每个任务按照<strong>先来先执行</strong>的原则</td>
<td>用于执行后台周期性任务</td>
</tr>
<tr>
<td>缺点</td>
<td>最大线程数为<code>Integer.MAX</code>，导致创建大量请求，消耗服务器资源</td>
<td>等待队列长度为<code>Integer.MAX</code>，导致大量请求堆积，消耗服务器资源</td>
<td>最大线程数为<code>Integer.MAX</code>，导致创建大量请求，消耗服务器资源</td>
<td>等待队列长度为<code>Integer.MAX</code>，导致大量请求堆积，消耗服务器资源</td>
</tr>
</tbody></table>
<h3 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h3><blockquote>
<p>线程池的生命周期是<strong>伴随线程池的运行，由内部进行维护的</strong>。</p>
<p>由两个值进行维护</p>
<ul>
<li><code>runState</code>：运行状态</li>
<li><code>workerCount</code>：线程数量</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>

<p><code>ctl</code>结合两个关键参数，来保证运行状态的一致。</p>
<p>高三位：<code>runState</code>，低29位：<code>workerCount</code>，两个变量互相不干扰。</p>
<p><img src="/images/582d1606d57ff99aa0e5f8fc59c7819329028.png" srcset="/img/loading.gif" lazyload alt="图3 线程池生命周期"></p>
<table>
<thead>
<tr>
<th>运行状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING(<code>线程池运行状态</code>)</td>
<td>可以接受新任务，并且也能处理阻塞队列的任务</td>
</tr>
<tr>
<td>SHUTDOWN(<code>线程池关闭状态</code>)</td>
<td>不再接受新的任务，但是依然可以处理阻塞队列的任务</td>
</tr>
<tr>
<td>STOP(<code>线程池停止状态</code>)</td>
<td>不再处理阻塞队列的任务，并且中断正在进行的任务</td>
</tr>
<tr>
<td>TIDYING(<code>线程池正在终止状态</code>)</td>
<td>所有任务都已停止，<code>workerCount</code>为0</td>
</tr>
<tr>
<td>TERMINATED(<code>线程池终止状态</code>)</td>
<td>线程池已停止运行，所有工作线程都被销毁，所有任务都已被清空或执行完毕</td>
</tr>
</tbody></table>
<p>源码内部提供了如下方法去获取当前线程池的状态</p>
<figure class="highlight java"><figcaption><span>ThreadPoolExecutor.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="hljs-comment">//运行状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125; <span class="hljs-comment">//工作线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125; <span class="hljs-comment">//当前runstate与workercount的和</span><br></code></pre></td></tr></table></figure>

<p><img src="/images/640" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h3><p><img src="/images/77441586f6b312a54264e3fcf5eebe2663494.png" srcset="/img/loading.gif" lazyload alt="图2 ThreadPoolExecutor运行流程"></p>
<ol>
<li>判断<code>corePoolSize(核心线程数)</code>是否已到达，没到达则可以创建一个新线程执行任务</li>
<li>判断<code>workQueue(工作队列)</code>是否已满，没满则添加入阻塞队列等待执行</li>
<li>判断<code>maximumPoolSize(最大线程数)</code>是否已到达，没到达则创建一个新线程执行任务。</li>
<li>已经达到了<code>maximumPoolSize(最大线程数)</code>或者线程池不处于<code>RUNNABLE</code>状态，执行<code>handler(任务拒绝策略)</code></li>
</ol>
<h3 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h3><p><img src="/images/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="Java线程池原理"></p>
<h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><p>线程池通过调用<code>submit()</code>或<code>execute()</code>提交线程任务，其中<code>submit()</code>可以拿到线程执行结果，内部通过<code>execute()</code>实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>        <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//1.当前工作线程 &lt; 核心线程时</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>            <span class="hljs-comment">//直接创建新的Worker执行任务</span><br>            <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-comment">//重新获取运行状态</span><br>            c = ctl.get();<br>        &#125;<br>        <span class="hljs-comment">//2.线程池处于running状态，任务加入 工作队列</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>            <span class="hljs-comment">//线程不处于running状态，直接执行拒绝任务策略</span><br>            <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>                reject(command);<br>            <span class="hljs-comment">//当无可用工作线程时，创建新的工作线程执行任务</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>                addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-comment">//无法添加任务，可能线程池被终止，或者最大线程已经满了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>            <span class="hljs-comment">//执行拒绝策略</span><br>            reject(command);<br>    &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>为什么执行<code>isRunning()</code>两次？</p>
<p>多线程环境下，线程池状态时刻发生变化，很可能刚获取的线程池状态突然就发生改变了。</p>
<p>万一线程池处于非<code>RUNNING</code>状态，那么任务永远不会执行。</p>
</blockquote>
<p>添加任务都是通过<code>addWorker()</code>执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core<span class="hljs-comment">/*是否核心线程*/</span>)</span> &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// 当线程池处于 STOP、TIDYING、TERMINATED状态时，无法添加新任务</span><br>        <span class="hljs-comment">// 或者处于SHUTDOWN时，阻塞队列还有任务就需要继续执行完毕</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">//获取工作线程数量</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-comment">//比较工作线程数量，若超出不予执行</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//新建工作对象</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>              <span class="hljs-comment">//启动新任务</span><br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//线程启动失败，移除worker</span><br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>线程池处于<code>RUNNABLE状态</code>或者<code>SHUTDOWN状态并且阻塞队列还有任务</code>，需要添加新线程执行任务</li>
<li><code>Worker</code>封装了线程对象</li>
<li>线程启动失败，则移除对应<code>Worker</code></li>
</ol>
<h5 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a><code>Worker</code></h5><blockquote>
<p>内部封装了<code>线程</code>对象，并且本身也是一个<code>Runnable</code>对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>     <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>     <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br> &#123;<br><br>     <span class="hljs-comment">/** Worker实际执行的线程 */</span><br>     <span class="hljs-keyword">final</span> Thread thread;<br>     <span class="hljs-comment">/** 初始化的任务，可以为null */</span><br>     Runnable firstTask;<br>     <span class="hljs-comment">/** Per-thread task counter */</span><br>     <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>     Worker(Runnable firstTask) &#123;<br>         setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>         <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>         <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>     &#125;<br><br>     <span class="hljs-comment">/** Delegates main run loop to outer runWorker. */</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>         runWorker(<span class="hljs-built_in">this</span>);<br>     &#125;<br>  <br> ...<br> &#125;<br></code></pre></td></tr></table></figure>

<p><code>Worker</code>持有两个对象：</p>
<ul>
<li><code>thread</code>：用来执行任务</li>
<li><code>firstTask</code>：保存传入的第一个任务，如果该值非空，则优先执行该任务。若为空，就需要创建一个工作线程去执行<code>workQueue</code>中的任务</li>
</ul>
<p><code>Worker</code>继承了<code>AQS</code>来实现<code>独占锁</code>功能，可以保证线程的执行状态是正确的。</p>
<p>获取独占锁，表示<strong>当前线程正在执行中，任务不可以被中断</strong>。</p>
<p>未获取独占锁，表示<strong>当前线程没有处理任务，可以进行线程中断</strong>。中断后就可以安全的进行线程回收。</p>
<h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><p><code>addWorker()</code>添加任务完毕后，就需要执行任务<code>runWorker()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>        w.firstTask = <span class="hljs-literal">null</span>;<br>        w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">//存在firstTask则先执行，否则从getTasks()获取阻塞队列的任务</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>                w.lock();<br>                <span class="hljs-comment">//检测线程池状态</span><br>                <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                     (Thread.interrupted() &amp;&amp;<br>                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                    !wt.isInterrupted())<br>                    wt.interrupt();<br>                <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-comment">//可重写该方法监听任务执行状态</span><br>                    beforeExecute(wt, task);<br>                    <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                      <span class="hljs-comment">//执行任务</span><br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                       <span class="hljs-comment">//可重写该方法监听任务执行状态</span><br>                        afterExecute(task, thrown);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                    w.completedTasks++;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            completedAbruptly = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-comment">//线程池无任务可以执行</span><br>            processWorkerExit(w, completedAbruptly);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>若<code>firstTask</code>不为null，则优先执行<code>firstTak</code>。<code>fistTask</code>未设置时，从<code>getTasks()</code>获取<code>workQueue</code>中的任务去执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// 是否允许核心线程超时释放 或者 当前工作线程数大于核心线程</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimedout || wc &gt; corePoolSize;<br><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="hljs-comment">//等待 keepAliveTime 后释放线程</span><br>                workQueue.take(); <span class="hljs-comment">//使用take()获取任务，阻塞线程，直到拿到任务为止</span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>线程池里的线程从<code>workQueue阻塞队列</code>里拿任务，如果存在非核心线程且<code>workQueue</code>没有任务，非核心线程就会等到<code>keppAliveTime</code>时间后被释放。如果当前仅有核心线程存在时，设置了<code>allowCoreThreadTimedout(true)</code>，核心线程也会被释放。否则就会通过<code>take()</code>一致阻塞直到拿到任务为止。</p>
<p>核心线程不会被释放的原因：<strong>通过<code>workQueue.take()</code>一直阻塞线程</strong>。</p>
<br>

<p>核心线程与非核心线程的区别：</p>
<p>这两者之间并没有明显的标志区分，根据上面的代码可以发现，两者的区别在于<strong>核心线程可以无限等待获取任务(阻塞队列take())，非核心线程要限时获取任务(keepAliveTime之内)</strong>。核心线程其实指代的就是<code>0~corePoolSize</code>之间创建的线程，<code>corePoolSize~maximumPoolSie</code>表示的就是非核心线程。</p>
<p><img src="/images/03268b9dc49bd30bb63064421bb036bf90315.png" srcset="/img/loading.gif" lazyload alt="图7 Worker执行任务"></p>
<p>通过调用<code>execute(runnable)</code>传进去的<code>runnable</code>对象不是直接通过<code>new Thread(runnable).start()</code>的方式去执行，而是通过一个<strong>正在运行的线程</strong>去执行<code>runnable.run()</code>。根据上述源码中的<code>runWorker()</code>，在执行完<code>firstTask</code>后就会调用<code>getTask()</code>获取任务去执行，如果<code>getTask()</code>没有获取到任务，就会在等待<code>keepAliveTime</code>之后关闭非核心线程，核心线程通过<code>workQueue.take()</code>阻塞线程避免自身被回收。</p>
<h4 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h4><p><code>getTask()</code>获取不到任务时，执行<code>processWorkerExit()</code>进行线程回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        <span class="hljs-comment">//减少工作线程数</span><br>        decrementWorkerCount();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">//尝试终止线程池</span><br>    tryTerminate();<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>   <span class="hljs-comment">//线程池处于RUNNABLE或SHUTDOWN状态</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-comment">//根据是否配置 allowCoreThreadTimeout 来判断线程池的最小保留线程数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-comment">//阻塞队列还有任务的话，至少保留一个线程去执行任务</span><br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        <span class="hljs-comment">//因为线程中断，导致没有线程执行阻塞队列任务</span><br>        <span class="hljs-comment">//尝试新建线程去执行任务</span><br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h4><p>当线程池处于<code>非RUNNABLE</code>状态或者<code>workerCount &gt; maximumPoolSize</code>时，就会执行<code>reject(runnable)</code>拒绝策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>        <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>            <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>                <span class="hljs-keyword">return</span>;<br>            c = ctl.get();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>            <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="hljs-comment">//当前不是RUNNABLE，移除当前任务</span><br>                reject(command);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>                addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<span class="hljs-comment">//添加非核心线程失败，表示已经超出了maximumPoolSize</span><br>            reject(command);<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(Runnable command)</span> &#123;<br>        handler.rejectedExecution(command, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates an &#123;<span class="hljs-doctag">@code</span> AbortPolicy&#125;.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                                 <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                                 e.toString());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>通过自定义类实现<code>RejectedExecutionHandler</code>接口，执行对应的拒绝策略。默认拒绝策略是<code>AbortPolicy</code>。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/640-1293801." srcset="/img/loading.gif" lazyload alt="img"></p>
<p>线程里容纳了一定的<code>Worker(执行任务的线程)</code>。根据线程池状态的不同，有新任务加入时，执行不同的操作。</p>
<ul>
<li>核心线程未满(<code>workerCount &lt; corePoolSize</code>)，创建<code>核心线程</code>执行任务</li>
<li>核心线程已满(<code>workerCount&gt;= corePoolSize</code>)，将任务添加到<code>workQueue</code>中</li>
<li><code>workQueue</code>已满(<code>workerCount&lt; maximumPoolSize</code>)，创建<code>非核心线程</code>执行任务</li>
<li>最大任务队列已满(<code>workerCount = maximumPoolSize</code>)，执行<code>handler</code>拒绝策略</li>
</ul>
<p>线程执行任务时，先执行<code>Worker的firstTask</code>，后续从<code>getTask()</code>获取任务去执行，根据线程池的容量区间获取任务的方式也不同</p>
<ul>
<li>容量区间位于<code>0~corePoolSize(核心线程)</code>，执行<code>workQueue.take()</code>阻塞获取任务，不会被回收。<em>若设置<code>allowCoreThreadTimeout(true)</code>也会被回收</em></li>
<li>容量区间位于<code>corePoolSize~maximumPoolSize(非核心线程)</code>，执行<code>workQueue.poll(keepAliveTime)</code>获取任务，超出<code>keepAliveTime</code>该线程就会被回收</li>
</ul>
<h3 id="线程池中的线程策略"><a href="#线程池中的线程策略" class="headerlink" title="线程池中的线程策略"></a>线程池中的线程策略</h3><h4 id="增长策略"><a href="#增长策略" class="headerlink" title="增长策略"></a>增长策略</h4><p>默认情况下，线程池是根据任务先<strong>创建足够核心线程数的线程去执行任务</strong>，当核心线程满了时<strong>将任务放入等待队列</strong>。待队列满了的时候，继续<strong>创建新线程执行任务直到达到最大线程数停止</strong>。此时再进入新任务的话，那就只能<strong>执行拒绝策略或是抛出异常</strong>。</p>
<h4 id="收缩策略"><a href="#收缩策略" class="headerlink" title="收缩策略"></a>收缩策略</h4><p>当线程池内的线程数大于核心线程数并且当前存在空闲线程并且空闲线程的空闲时间大于<code>keepAliveTime</code>时，会对空闲线程进行回收，直到线程数量等于核心线程数(<code>corePoolSize</code>)为止。</p>
<h3 id="线程池的使用注意"><a href="#线程池的使用注意" class="headerlink" title="线程池的使用注意"></a>线程池的使用注意</h3><ol>
<li><p>线程池不要用<code>Executors</code>的方式去创建，应该利用<code>ThreadPoolExecutor</code>的方式，这样可以帮助更好理解实现方式以及避免资源消耗过度的问题。</p>
<p><strong><code>fixThreadPool以及singleThreadPool</code>,由于设置的等待队列长度为Integer.MAX_VALUE，导致大量请求堆积，消耗大量资源。</strong></p>
<p><strong><code>cachedThreadPool以及scheduledThreadPool</code>,由于运行允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的请求，消耗大量资源。</strong></p>
</li>
<li><p>针对具体情况去配置线程池参数，不同的任务类别应采用不同规模的线程池，任务类别分为3种：</p>
<ul>
<li><p><strong><code>CPU密集型任务(需要进行大量计算，处理)</code></strong>：线程池中线程个数尽量少，不应大于CPU核心数，避免出现每个线程都需要长时间使用但是线程过多去抢占资源。建议<code>corePoolSize</code>为<strong>n+1</strong></p>
</li>
<li><p><strong><code>IO密集型任务(主要时间都在IO，CPU空闲时间比较多)</code></strong>：线程池可以配置尽量多的线程，由于CPU大部分时间空闲，可以提高CPU的利用率。建议<code>corePoolSize</code>为<strong>2n</strong></p>
</li>
<li><p><strong><code>混合型任务</code></strong>：如果可以拆分，则拆分成一个CPU密集型以及IO密集型任务，只要执行任务效率相差不大。若相差太大则没必要拆分。</p>
</li>
</ul>
</li>
</ol>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><ol>
<li><p><code>submit()</code>和<code>execute()</code>区别</p>
<p><code>submit()</code>返回一个<code>future</code>，根据<code>future</code>可以判断任务是否完成–实现<code>Callable</code>接口</p>
<p><code>execute()</code>无返回值。只是执行了任务，不知道结果如何 – 实现<code>Runnable</code>接口</p>
</li>
<li><p><code>BlockingQueue</code>介绍</p>
<a href="/2018/12/24/Java-BockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/" title="Java-BockingQueue阻塞队列">Java-BockingQueue阻塞队列</a>
</li>
<li><p><code>AbstractQueuedSynchronizer</code>介绍</p>
<a href="/2020/09/13/Java-AbstractQueuedSynchronizer%E7%AE%80%E4%BB%8B/" title="Java-AbstractQueuedSynchronizer简介">Java-AbstractQueuedSynchronizer简介</a>
</li>
<li><p>为什么存在<code>newSingleThreadExecutor</code>?不能使用<code>newFixedThreadPool(1)</code>代替</p>
<p>再次对比一下两者的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*     </span><br><span class="hljs-comment">* Creates an Executor that uses a single worker thread operating</span><br><span class="hljs-comment">     * off an unbounded queue, and uses the provided ThreadFactory to</span><br><span class="hljs-comment">     * create a new thread when needed. Unlike the otherwise</span><br><span class="hljs-comment">     * equivalent &#123;@code newFixedThreadPool(1, threadFactory)&#125; the</span><br><span class="hljs-comment">     * returned executor is guaranteed not to be reconfigurable to use</span><br><span class="hljs-comment">     * additional threads.</span><br><span class="hljs-comment">       */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<span class="hljs-comment">//nThreads为1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="hljs-comment">//1 , 1</span><br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>两者之间最大的差异就在于包装类的区别：</p>
<ul>
<li><code>newSingleThreadExecutor</code>——FinalizableDelegatedExecutorService</li>
<li><code>newFixedThreadPool</code>——ThreadPoolExecutor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>           <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DelegatedExecutorService</span> &#123;<br>       FinalizableDelegatedExecutorService(ExecutorService executor) &#123;<br>           <span class="hljs-built_in">super</span>(executor);<br>       &#125;<br>       <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-built_in">super</span>.shutdown();<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatedExecutorService</span><br>           <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>       <span class="hljs-comment">// Android-added: @ReachabilitySensitive</span><br>       <span class="hljs-comment">// Needed for FinalizableDelegatedExecutorService below.</span><br>       <span class="hljs-meta">@ReachabilitySensitive</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService e;<br>       DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123; e.execute(command); &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123; e.shutdown(); &#125;<br>       <span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> e.shutdownNow(); &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> e.isShutdown(); &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> e.isTerminated(); &#125;<br>      ...<br>   &#125;<br>   <br></code></pre></td></tr></table></figure>

<p><code>DelegatedExecutorService</code>就是<code>ExecutorService接口实现类</code>的包装类，包装后的对象仅仅暴露<code>ExecutorService</code>接口方法，而<code>FinalizableDelegatedExecutorService</code>屏蔽了大多数实现方法，避免被强制转换时修改配置导致行为出现问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFixed</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>        ((ThreadPoolExecutor)s).setCorePoolSize(<span class="hljs-number">2</span>);<br>        System.err.println(<span class="hljs-string">&quot;ss &quot;</span>+((ThreadPoolExecutor) s).getCorePoolSize());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSingle</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>        ((ThreadPoolExecutor)s).setCorePoolSize(<span class="hljs-number">2</span>);<br>        System.err.println(<span class="hljs-string">&quot;ss&quot;</span>+((ThreadPoolExecutor) s).getCorePoolSize());<br>    &#125;<br><br>输出结果：<br>  ss <span class="hljs-number">2</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassCastException: java.util.concurrent.Executors$FinalizableDelegatedExecutorService cannot be cast to java.util.concurrent.ThreadPoolExecutor<br>	at thread.TestThreadPool.testSingle(TestThreadPool.java:<span class="hljs-number">31</span>)<br>	at thread.TestThreadPool.main(TestThreadPool.java:<span class="hljs-number">20</span>)<br><br></code></pre></td></tr></table></figure>

<p>观察上面的结果，可以看出<code>newSingleThreadExecutor</code>与<code>newFixedThreadPool</code>最大区别在于，前者不可配置参数，可以保证<strong>任务的串行执行</strong>，后者在运行的过程中可以通过强制类型转换得到<code>ThreadPoolExecutor</code>去进行参数的重新配置，导致<strong>任务可能变成并行执行</strong>。使应用的执行逻辑出现错误，导致应用异常。</p>
</li>
</ol>
<h3 id="内容引用"><a href="#内容引用" class="headerlink" title="内容引用"></a>内容引用</h3><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5bdbbc3d6fb9a0224a5e486f#heading-14">线程池</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HpMu_QI_N-J18fNJG96yzA">线程池深入解析</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java-线程池</div>
      <div>http://example.com/2019/09/13/Java-线程池/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Leo-Wxy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2019年9月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/09/24/Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%AD%A6%E4%B9%A0/" title="Java字节码学习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java字节码学习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/07/20/Android-%E5%B4%A9%E6%BA%83%E4%BC%98%E5%8C%96/" title="Android崩溃优化">
                        <span class="hidden-mobile">Android崩溃优化</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
