

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <title>Kotlin-协程 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.5","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Kotlin-协程">
              
                Kotlin-协程
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-04-12 15:11" pubdate>
        2019年4月12日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      144
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Kotlin-协程</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>协程本质上是<strong>轻量级的线程</strong>。</p>
</blockquote>
<h2 id="协程的概念"><a href="#协程的概念" class="headerlink" title="协程的概念"></a>协程的概念</h2><p>协程是一种<strong>非抢占式或协作式</strong>的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。避免在异步编程中使用大量的回调，同时相比于传统的多线程技术，更容易<em>提升系统的高并发处理能力。</em></p>
<p>线程和协程属于<strong>一对多</strong>关系，一个线程上允许存在多个协程。</p>
<blockquote>
<p>线程大多数的实现是映射到内核的线程，当线程中的代码逻辑在线程抢到CPU的时间片才可以执行，否则只能等待。而协程之所以<strong>轻量级</strong>，协程并不会映射到内核线程，调度可以在用户态搞定，任务之间调度并非抢占式。</p>
</blockquote>
<h2 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h2><pre><code class="hljs kotlin">GlobalScope.launch(Dispatchers.Main + ,start = CoroutineStart.DEFAULT)&#123;
  <span class="hljs-comment">// TODO</span>
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(
    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,<span class="hljs-comment">//协程作用域</span>
    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,<span class="hljs-comment">//协程启动方式</span>
    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span> <span class="hljs-comment">//协程内需要执行的操作</span>
)</span></span>: Job &#123;...&#125;</code></pre>
<h3 id="协程作用域-CoroutineScope"><a href="#协程作用域-CoroutineScope" class="headerlink" title="协程作用域(CoroutineScope)"></a>协程作用域(<code>CoroutineScope</code>)</h3><blockquote>
<p>在Android环境中，通常每个界面(Activity、Fragment)启动的协程(<code>Coroutine</code>)只在该界面有效，当退出界面时，协程执行的任务也没有意义。所以在设计<code>Coroutine</code>时会要求在<code>Scope</code>中执行，当<code>CoroutineScope</code>取消时，对应的<code>Coroutine</code>也需要自动取消。</p>
</blockquote>
<h4 id="阻塞协程作用域-runBlocking"><a href="#阻塞协程作用域-runBlocking" class="headerlink" title="阻塞协程作用域(runBlocking)"></a>阻塞协程作用域(<code>runBlocking</code>)</h4><blockquote>
<p>调用<code>runBlocking</code>的线程会被阻塞直到内部协程任务执行完毕</p>
</blockquote>
<pre><code class="hljs kotlin">runBlocking &#123;
    launch &#123;
        println(<span class="hljs-string">"Hello <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)
        delay(<span class="hljs-number">1000</span>)
    &#125;
&#125;
println(<span class="hljs-string">"world <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)

输出结果：
Hello <span class="hljs-number">1597924663541</span>
world <span class="hljs-number">1597924664551</span>
结果相差接近<span class="hljs-number">1</span>s</code></pre>
<p><strong>多用于单元测试代码中，不会用于实际的业务开发。就因为会堵塞当前线程</strong></p>
<h4 id="全局协程作用域-GlobalScope"><a href="#全局协程作用域-GlobalScope" class="headerlink" title="全局协程作用域(GlobalScope)"></a>全局协程作用域(<code>GlobalScope</code>)</h4><blockquote>
<p>作用于整个应用的生命周期中，并且无法被取消，在界面中使用，例如<code>Activity</code>中使用，就会导致内存泄露</p>
</blockquote>
<pre><code class="hljs kotlin">GlobalScope.launch(Dispatchers.Unconfined) &#123;
    println(<span class="hljs-string">"Hello <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)
    delay(<span class="hljs-number">1000</span>)
&#125;
println(<span class="hljs-string">"world <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)

输出结果：
Hello <span class="hljs-number">1597924937030</span>
world <span class="hljs-number">1597924937038</span>
结果接近</code></pre>
<p>通过<code>GlobalScope</code>创建的协程将不会有<code>父协程</code>，也被称为<code>根协程</code>。</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;
    <span class="hljs-comment">/**
     * Returns [EmptyCoroutineContext].
     */</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext
        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext <span class="hljs-comment">//返回一个上下文但并没有进行上下文关联，导致无法被取消</span>
&#125;</code></pre>
<h4 id="自定义协程作用域-CoroutineScope"><a href="#自定义协程作用域-CoroutineScope" class="headerlink" title="自定义协程作用域(: CoroutineScope)"></a>自定义协程作用域(<code>: CoroutineScope</code>)</h4><blockquote>
<p>自定义协程的作用域，就不会造成作用域过大导致的内存泄漏</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job()<span class="hljs-comment">//协程上下文</span>
<span class="hljs-keyword">val</span> coroutineScope = CoroutineScope(coroutineContext)<span class="hljs-comment">//自定义作用域</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;
  coroutineScope.launch&#123;
      println(<span class="hljs-string">"Hello <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)
      delay(<span class="hljs-number">1000</span>)
  &#125;
  println(<span class="hljs-string">"world <span class="hljs-subst">$&#123;System.currentTimeMillis()&#125;</span>"</span>)
  <span class="hljs-comment">//主动控制作用域的取消</span>
  coroutineScope.cancel()
&#125;</code></pre>
<p>自定义协程作用域最关键的就是<strong>定义CoroutineContext属性</strong>。</p>
<p>自定义<code>CoroutineContext</code>主要由两部分构成：<code>dispatcher</code>、<code>job</code>。</p>
<p><code>dispatcher</code>：用于指定协程默认使用的调度器(<em>后续会介绍</em>)</p>
<p><code>job</code>：可在任意时刻取消协程(<em>后续会介绍</em>)</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job()</code></pre>
<p>用<code>+</code>连接多个上下文，其中如果出现多个同类型的上下文，后面新添加的会成为使用的上下文，例如</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Unconfined + Job() + Dispatchers.IO
print(coroutineContext.toString())

输出结果：
[JobImpl&#123;Active&#125;@<span class="hljs-number">300f</span>fa5d, Dispatchers.IO] <span class="hljs-comment">//采用了新添加的调度器</span></code></pre>
<h4 id="系统提供协程作用域"><a href="#系统提供协程作用域" class="headerlink" title="系统提供协程作用域"></a>系统提供协程作用域</h4><h5 id="MainScope"><a href="#MainScope" class="headerlink" title="MainScope"></a>MainScope</h5><blockquote>
<p>为了方便开发使用，kotlin标准库中定义了<code>MainScope()</code>可以快速生成<code>CoroutineScope</code></p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-comment">//MainScope实现源码</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MainScope</span><span class="hljs-params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)

使用方式：
<span class="hljs-keyword">val</span> mainScope  = MainScope()

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
  mainScope.launch&#123;
    <span class="hljs-comment">//TODO</span>
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>&#123;
  mainScope.cancel()
&#125;</code></pre>
<h5 id="viewModelScope"><a href="#viewModelScope" class="headerlink" title="viewModelScope"></a>viewModelScope</h5><blockquote>
<p>在AndroidX中 引入了<code>viewModelScope</code>，当ViewModel销毁时会自动取消协程任务。</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-comment">//引用viewModelScope</span>
implementation <span class="hljs-string">"androidx.lifecycle:lifecycle-viewmodel-ktx:2.1.0-beta01:"</span> <span class="hljs-comment">//也可以引用更高版本</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewModel</span>:<span class="hljs-type">ViewModel</span></span>()&#123;
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
    viewModelScope.launch&#123;
      <span class="hljs-comment">//TODO </span>
    &#125;
  &#125;
&#125;</code></pre>
<p>简单源码解析：</p>
<pre><code class="hljs kotlin"><span class="hljs-comment">//lifecycle/lifecycle-viewmodel-ktx/src/main/java/androidx/lifecycle/ViewModel.kt</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> JOB_KEY = <span class="hljs-string">"androidx.lifecycle.ViewModelCoroutineScope.JOB_KEY"</span>

<span class="hljs-comment">/**
 * [CoroutineScope] tied to this [ViewModel].
 * This scope will be canceled when ViewModel will be cleared, i.e [ViewModel.onCleared] is called
 *
 * This scope is bound to
 * [Dispatchers.Main.immediate][kotlinx.coroutines.MainCoroutineDispatcher.immediate]
 */</span>
<span class="hljs-comment">//使用拓展方法</span>
<span class="hljs-keyword">val</span> ViewModel.viewModelScope: CoroutineScope
        <span class="hljs-keyword">get</span>() &#123;
            <span class="hljs-keyword">val</span> scope: CoroutineScope? = <span class="hljs-keyword">this</span>.getTag(JOB_KEY)
          <span class="hljs-comment">//缓存中读取 对应scope</span>
            <span class="hljs-keyword">if</span> (scope != <span class="hljs-literal">null</span>) &#123;
                <span class="hljs-keyword">return</span> scope
            &#125;
           <span class="hljs-comment">//对应了ViewModel内部的实现代码</span>
            <span class="hljs-keyword">return</span> setTagIfAbsent(JOB_KEY,
                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate))
        &#125;
<span class="hljs-comment">//自动取消 coroutineScope</span>
<span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloseableCoroutineScope</span></span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext = context

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123;
        coroutineContext.cancel()
    &#125;
&#125;</code></pre>
<p><code>viewModelScope</code>默认调度器为<code>Dispatchers.Main</code>，因为<code>ViewModel</code>与UI交互较为频繁，减少线程间的切换。</p>
<pre><code class="hljs kotlin"><span class="hljs-comment">//lifecycle/lifecycle-viewmodel/src/main/java/androidx/lifecycle/ViewModel.java</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; mBagOfTags = new HashMap&lt;&gt;();
<span class="hljs-comment">//同步存值</span>
    &lt;T&gt; T setTagIfAbsent(String key, T newValue) &#123;
        T previous;
        synchronized (mBagOfTags) &#123;
            previous = (T) mBagOfTags.<span class="hljs-keyword">get</span>(key);
            <span class="hljs-keyword">if</span> (previous == <span class="hljs-literal">null</span>) &#123;
                mBagOfTags.put(key, newValue);
            &#125;
        &#125;
        T result = previous == <span class="hljs-literal">null</span> ? newValue : previous;
        <span class="hljs-keyword">if</span> (mCleared) &#123;
            closeWithRuntimeException(result);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;

 <span class="hljs-meta">@MainThread</span>
<span class="hljs-comment">//销毁ViewModel</span>
    <span class="hljs-keyword">final</span> void clear() &#123;
        mCleared = <span class="hljs-literal">true</span>;
        <span class="hljs-comment">// Since clear() is final, this method is still called on mock objects</span>
        <span class="hljs-comment">// and in those cases, mBagOfTags is null. It'll always be empty though</span>
        <span class="hljs-comment">// because setTagIfAbsent and getTag are not final so we can skip</span>
        <span class="hljs-comment">// clearing it</span>
        <span class="hljs-keyword">if</span> (mBagOfTags != <span class="hljs-literal">null</span>) &#123;
            synchronized (mBagOfTags) &#123;
              <span class="hljs-comment">//读取缓存好的 viewModelScope对象</span>
                <span class="hljs-keyword">for</span> (Object value : mBagOfTags.values()) &#123;
                    <span class="hljs-comment">// see comment for the similar call in setTagIfAbsent</span>
                    closeWithRuntimeException(value);
                &#125;
            &#125;
        &#125;
        onCleared();
    &#125;

<span class="hljs-comment">//清理缓存对象 这也是CloseableCoroutineScope存在的原因</span>
 <span class="hljs-keyword">private</span> static void closeWithRuntimeException(Object obj) &#123;
        <span class="hljs-keyword">if</span> (obj instanceof Closeable) &#123;
            <span class="hljs-keyword">try</span> &#123;
                ((Closeable) obj).close();
            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                <span class="hljs-keyword">throw</span> new RuntimeException(e);
            &#125;
        &#125;
    &#125;</code></pre>
<h3 id="协程启动模式-CoroutineStart"><a href="#协程启动模式-CoroutineStart" class="headerlink" title="协程启动模式(CoroutineStart)"></a>协程启动模式(<code>CoroutineStart</code>)</h3><blockquote>
<p>控制协程创建后的调用规则</p>
</blockquote>
<h4 id="CoroutineStart-DEFAULT"><a href="#CoroutineStart-DEFAULT" class="headerlink" title="CoroutineStart.DEFAULT"></a>CoroutineStart.DEFAULT</h4><blockquote>
<p>协程的默认启动模式，为<code>饿汉式调用</code>，调用协程后，会立即进入调度状态(等待调度器初始化完毕)。</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;
    print(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">val</span> job = GlobalScope.launch &#123;
        print(<span class="hljs-number">2</span>)
        delay(<span class="hljs-number">1000</span>)
    &#125;
    print(<span class="hljs-number">3</span>)
    job.join()
    print(<span class="hljs-number">4</span>)
&#125;

输出结果：
<span class="hljs-number">123</span>(delay <span class="hljs-number">1000</span>ms)<span class="hljs-number">4</span></code></pre>
<p><strong>协程创建后，立即开始调度，在调度前如果协程被取消，将直接进入取消响应的状态。</strong></p>
<h4 id="CoroutineStart-LAZY"><a href="#CoroutineStart-LAZY" class="headerlink" title="CoroutineStart.LAZY"></a>CoroutineStart.LAZY</h4><blockquote>
<p><code>懒汉式调用</code>，<code>launch</code>后并不会有任何调度行为，协程也不会执行，直到调用执行时，协程才会执行。</p>
<p>只有主动调用<code>start、join、或await</code>后协程才会开始调度。</p>
<p><code>job.start()</code>：启动协程</p>
<p><code>job.join()</code>：启动协程并等待任务执行结束</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;
    print(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">val</span> job = coroutineScope.launch(start = CoroutineStart.LAZY) &#123;
        print(<span class="hljs-number">2</span>)
        delay(<span class="hljs-number">1000</span>)
    &#125;

    print(<span class="hljs-number">3</span>)
    job.start()
  <span class="hljs-comment">//job.join()</span>
    print(<span class="hljs-number">4</span>)
&#125;

输出结果：
job.start() <span class="hljs-number">1324</span> 没有延迟输出<span class="hljs-number">4</span>
job.join() <span class="hljs-number">1324</span> 延迟<span class="hljs-number">1</span>s后输出<span class="hljs-number">4</span></code></pre>
<p><strong>协程创建后，只有被需要使用时才会执行，例如调用<code>start、join</code>才会开始调度执行。</strong></p>
<h4 id="CoroutineStart-ATOMIC-实验版"><a href="#CoroutineStart-ATOMIC-实验版" class="headerlink" title="CoroutineStart.ATOMIC(实验版)"></a>CoroutineStart.ATOMIC(实验版)</h4><blockquote>
<p>协程创建后，立即开始调度，在<strong>协程执行到第一个挂起点之前不会响应<code>cancel</code>操作</strong></p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;
    print(<span class="hljs-number">1</span>)
  <span class="hljs-comment">//val job = GlobalScope.launch(start = CoroutineStart.DEFAULT) &#123;</span>
    <span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;
        print(<span class="hljs-number">2</span>)
        delay(<span class="hljs-number">1000</span>)
    &#125;
    job.cancel()
    print(<span class="hljs-number">3</span>)
    print(<span class="hljs-number">4</span>)
&#125;

输出结果：
DEFAULT：<span class="hljs-number">134</span> 由于在准备执行时触发了cancel，导致<span class="hljs-number">2</span>无法输出
ATOMIC：<span class="hljs-number">1324</span> ATOMIC在执行前不会响应到cancel，所以<span class="hljs-number">2</span>正常输出</code></pre>
<p><strong>ATOMIC将<code>调度</code>与<code>执行</code>合二为一，是一个原子化操作。</strong></p>
<p>升级版示例：</p>
<pre><code class="hljs kotlin">    print(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;
        print(<span class="hljs-number">2</span>)
        delay(<span class="hljs-number">1000</span>)
        print(<span class="hljs-number">5</span>)
    &#125;
    job.cancel()
    print(<span class="hljs-number">3</span>)
    print(<span class="hljs-number">4</span>)

输出结果：
<span class="hljs-number">1342</span> 
不输出<span class="hljs-number">5</span>的原因是：`ATOMIC`在第一个挂起点时忽略`cancel`，后续在执行挂起时,`cancel`	功能生效，导致后续无法输出，这里`delay`就是下一次的挂起操作。</code></pre>
<h4 id="CoroutineStart-UNDISPATCHED-实验版"><a href="#CoroutineStart-UNDISPATCHED-实验版" class="headerlink" title="CoroutineStart.UNDISPATCHED(实验版)"></a>CoroutineStart.UNDISPATCHED(实验版)</h4><blockquote>
<p>协程创建后立即在当前函数调用栈中执行，直到第一个挂起点？</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;
    println(<span class="hljs-string">"<span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span> 1"</span>)
    <span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123;
 <span class="hljs-comment">// val job = GlobalScope.launch(start = CoroutineStart.DEFAULT) &#123;</span>
        println(<span class="hljs-string">"<span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span> 2"</span>)
        delay(<span class="hljs-number">1000</span>)
        println(<span class="hljs-string">"<span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span> 5"</span>)
    &#125;

    println(<span class="hljs-string">"<span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span> 3"</span>)
    job.join()
    println(<span class="hljs-string">"<span class="hljs-subst">$&#123;Thread.currentThread()&#125;</span> 4"</span>)
&#125;

输出结果：
DEFAULT
Thread[main,<span class="hljs-number">5</span>,main] <span class="hljs-number">1</span>
Thread[main,<span class="hljs-number">5</span>,main] <span class="hljs-number">3</span>
Thread[DefaultDispatcher-worker-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main] <span class="hljs-number">2</span>
Thread[DefaultDispatcher-worker-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main] <span class="hljs-number">5</span>
Thread[DefaultDispatcher-worker-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main] <span class="hljs-number">4</span>

UNDISPATCHED
Thread[main,<span class="hljs-number">5</span>,main] <span class="hljs-number">1</span>
Thread[main,<span class="hljs-number">5</span>,main] <span class="hljs-number">2</span>
Thread[main,<span class="hljs-number">5</span>,main] <span class="hljs-number">3</span>
Thread[DefaultDispatcher-worker-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main] <span class="hljs-number">5</span>
Thread[DefaultDispatcher-worker-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main] <span class="hljs-number">4</span></code></pre>
<p>比较<code>DEFAULT</code>结果可见，在<code>UNDISPATCHED</code>条件下，未达到挂起点时，代码会执行在调用函数栈中，例如<code>UNDISPATCHED</code>的<code>print(2)</code>就输出在<code>Main</code>线程下。</p>
<table>
<thead>
<tr>
<th>CoroutineStart配置</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEFAULT</td>
<td>协程创建后立即执行</td>
</tr>
<tr>
<td>LAZY</td>
<td>协程创建后，等待需要调用时才会执行协程<br><code>start、join、await</code>等代码调用</td>
</tr>
<tr>
<td>ATOMIC</td>
<td>功能类似<code>DEFAULT</code>，但是在执行协程前无法被取消，直到执行到了第一个<code>suspend函数</code>,例如<code>delay()</code>就是个<code>suspend</code>函数</td>
</tr>
<tr>
<td>UNDISPATCHED</td>
<td>立即在当前线程执行协程，直到执行到了第一个<code>suspend函数</code></td>
</tr>
</tbody>
</table>
<h3 id="协程上下文-CoroutineContext"><a href="#协程上下文-CoroutineContext" class="headerlink" title="*协程上下文(CoroutineContext)"></a>*协程上下文(<code>CoroutineContext</code>)</h3><blockquote>
<p>本体是一个数据结构，可以看做是<code>map</code>，内部实现为<code>单链表</code></p>
<p><code>上下文</code>记录了协程所需信息：</p>
<ul>
<li>协程调度器：Dispatchers</li>
<li>执行任务：Job</li>
<li>协程名字：CoroutineName</li>
<li>协程异常处理：CoroutineExceptionHandler</li>
</ul>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job() + CoroutineName(<span class="hljs-string">"name"</span>)<span class="hljs-comment">//协程上下文</span></code></pre>
<h4 id="自定义上下文"><a href="#自定义上下文" class="headerlink" title="自定义上下文"></a>自定义上下文</h4><p>Kotlin提供了<code>AbstractCoroutineContextElement</code>可以快速实现自定义上下文，例如<code>CoroutineName</code>就是依赖这个实现的</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineName</span></span>(
    <span class="hljs-comment">/**
     * User-defined coroutine name.
     */</span>
    <span class="hljs-keyword">val</span> name: String
) : AbstractCoroutineContextElement(CoroutineName) &#123;
    <span class="hljs-comment">/**
     * Key for [CoroutineName] instance in the coroutine context.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;

    <span class="hljs-comment">/**
     * Returns a string representation of the object.
     */</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String = <span class="hljs-string">"CoroutineName(<span class="hljs-variable">$name</span>)"</span>
&#125;</code></pre>
<h4 id="协程上下文的父子关系"><a href="#协程上下文的父子关系" class="headerlink" title="协程上下文的父子关系"></a>协程上下文的父子关系</h4><blockquote>
<p>每个协程都会有一个父级对象，协程的父级对象的<code>上下文</code>也会和父级协程的<code>上下文</code>不一致。</p>
</blockquote>
<p>关系遵循如下公式</p>
<p><strong>父级上下文 = 默认值 + 继承的<code>CoroutineContext</code> + 参数</strong></p>
<p><code>默认值</code>：一些元素包含的默认值，例如默认<code>Dispatcher</code>就是<code>Dispatchers.Default</code></p>
<p><code>继承的CoroutineContext</code>：父协程的<code>CoroutineContenxt</code></p>
<p><code>参数</code>：后续子协程配置的参数，如上文所示组成部分，新添加的参数会覆盖前面的对应配置。</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testCoroutineContextExtend</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">val</span> parentContext: CoroutineContext = Dispatchers.Default + Job() + CoroutineName(<span class="hljs-string">"parent"</span>)
    <span class="hljs-keyword">val</span> parentScope = CoroutineScope(parentContext)
    parentScope.launch &#123;
        log(currentCoroutineContext().toString()) <span class="hljs-comment">//打印当前上下文内容</span>
        <span class="hljs-keyword">val</span> childContext = parentContext + Dispatchers.IO + CoroutineName(<span class="hljs-string">"child"</span>)
        <span class="hljs-keyword">val</span> job =  launch(childContext) &#123;
            log(currentCoroutineContext().toString())
        &#125;
    &#125;
&#125;

输出结果：
<span class="hljs-number">19</span>:<span class="hljs-number">29</span>:<span class="hljs-number">57</span>:<span class="hljs-number">497</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] [CoroutineName(parent), StandaloneCoroutine&#123;Active&#125;@<span class="hljs-number">4815</span>c1f8, Dispatchers.Default]
<span class="hljs-number">19</span>:<span class="hljs-number">29</span>:<span class="hljs-number">57</span>:<span class="hljs-number">500</span> [DefaultDispatcher-worker-<span class="hljs-number">2</span>] [CoroutineName(child), StandaloneCoroutine&#123;Active&#125;@<span class="hljs-number">2</span>ca2b65d, Dispatchers.IO]</code></pre>
<p>根据上述输出结果可得到<strong>后续的同类内容会覆盖前面的元素</strong>。</p>
<p><code>CoroutineContext</code>使用<strong>+</strong>进行元素的合并，加号右侧的元素会覆盖左侧的元素，最后得到一个新的<code>CoroutineContext</code>元素。</p>
<p>//TODO 后续会补充如何调用自定义上下文</p>
<h3 id="协程拦截器-ContinuationInterceptor"><a href="#协程拦截器-ContinuationInterceptor" class="headerlink" title="协程拦截器(ContinuationInterceptor)"></a>协程拦截器(<code>ContinuationInterceptor</code>)</h3><blockquote>
<p>协程拦截器也是<code>CoroutineContext</code>的一个实现，可以控制协程的执行流程，功能类似于<code>Okhttp的拦截器</code>。</p>
<p><code>协程拦截器</code>永远置于<code>CoroutineContext</code>组合的最后一位，保证不会被其他实现所覆盖。</p>
<p><strong>协程拦截器最多只能存在1个。</strong></p>
<!--如何配置多个拦截器？-->
</blockquote>
<pre><code class="hljs kotlin">class CustomInterceptor : ContinuationInterceptor &#123;
    override val key = ContinuationInterceptor

    override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt;  = CustomContinuation&lt;T&gt;(continuation)

    class CustomContinuation&lt;T&gt;(val continuation: Continuation&lt;T&gt;) : Continuation&lt;T&gt; &#123;
        override val context: CoroutineContext = continuation.context

        override fun resumeWith(result: Result&lt;T&gt;) &#123;
            println("result = $result")
            //对result进行多次处理，也可以联动成多个拦截器的处理
            //此处hook 返回值可对其进行修改或者拓展
            continuation.resumeWith(result)
        &#125;
    &#125;
&#125;

GlobalScope.launch(CustomInterceptor())&#123;
  //TODO ...
&#125;</code></pre>
<h3 id="协程调度器-CoroutineDispatcher"><a href="#协程调度器-CoroutineDispatcher" class="headerlink" title="协程调度器(CoroutineDispatcher)"></a>协程调度器(<code>CoroutineDispatcher</code>)</h3><blockquote>
<p>属于<code>CoroutineContext</code>的子类，同时实现了<code>ContinuationInterceptor</code>接口，通过拦截功能实现协程的调度。</p>
<p>调度器的主要目的<strong>切换执行线程</strong>。</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineDispatcher</span> :
    <span class="hljs-type">AbstractCoroutineContextElement</span></span>(ContinuationInterceptor), ContinuationInterceptor &#123;
  
      ... 
      <span class="hljs-comment">//此处切换任务执行线程</span>
      <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span>

 &#125;</code></pre>
<p>先了解源码中提供的调度器</p>
<h4 id="Dispatchers-Default"><a href="#Dispatchers-Default" class="headerlink" title="Dispatchers.Default"></a>Dispatchers.Default</h4><blockquote>
<p>默认协程调度器，适合处理后台计算，为<code>CPU密集型</code>任务调度器</p>
</blockquote>
<!--ForkJoinPool-->
<pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">object</span> Dispatchers &#123;
      <span class="hljs-meta">@JvmStatic</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-keyword">val</span> Default: CoroutineDispatcher = createDefaultDispatcher()
  ...
&#125;

<span class="hljs-keyword">internal</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDefaultDispatcher</span><span class="hljs-params">()</span></span>: CoroutineDispatcher =
    <span class="hljs-keyword">if</span> (useCoroutinesScheduler) DefaultScheduler <span class="hljs-keyword">else</span> CommonPool

<span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> DefaultScheduler : ExperimentalCoroutineDispatcher() &#123;
    <span class="hljs-keyword">val</span> IO: CoroutineDispatcher = LimitingDispatcher(
        <span class="hljs-keyword">this</span>,
        systemProp(IO_PARALLELISM_PROPERTY_NAME, <span class="hljs-number">64</span>.coerceAtLeast(AVAILABLE_PROCESSORS)),
        <span class="hljs-string">"Dispatchers.IO"</span>,
        TASK_PROBABLY_BLOCKING
    )

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span> &#123;
        <span class="hljs-keyword">throw</span> UnsupportedOperationException(<span class="hljs-string">"<span class="hljs-variable">$DEFAULT_DISPATCHER_NAME</span> cannot be closed"</span>)
    &#125;

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String = DEFAULT_DISPATCHER_NAME

    <span class="hljs-meta">@InternalCoroutinesApi</span>
    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">"UNUSED"</span>)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toDebugString</span><span class="hljs-params">()</span></span>: String = <span class="hljs-keyword">super</span>.toString()
&#125;</code></pre>
<h4 id="Dispatchers-IO（仅JVM可用）"><a href="#Dispatchers-IO（仅JVM可用）" class="headerlink" title="Dispatchers.IO（仅JVM可用）"></a>Dispatchers.IO（仅JVM可用）</h4><blockquote>
<p>IO调度器，适合执行IO相关操作，例如读写文件，为<code>IO密集型</code>任务调度器</p>
</blockquote>
<p>IO仅在JVM上有定义，基于<code>Default</code>调度器，并实现了独立的队列和限制，因此<code>Default与IO</code>切换不会触发线程切换。</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;
    log(<span class="hljs-string">"1"</span>)
    <span class="hljs-keyword">val</span> job = GlobalScope.async(Dispatchers.IO) &#123;
        log(<span class="hljs-number">2</span>)
        withContext(Dispatchers.Default)&#123;
            log(<span class="hljs-number">3</span>)
            withContext(Dispatchers.IO)&#123;
                log(<span class="hljs-number">4</span>)
                withContext(Dispatchers.Default)&#123;
                    log(<span class="hljs-number">5</span>)
                    <span class="hljs-number">123</span>
                &#125;
            &#125;
        &#125;
    &#125;
    log(job.await())
&#125;

输出结果：
<span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">564</span> [main] <span class="hljs-number">1</span>
<span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">581</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">2</span>
<span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">586</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">3</span>
<span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">586</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">4</span>
<span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">587</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">5</span> <span class="hljs-comment">//切换过程中一直在同一线程</span>
<span class="hljs-number">13</span>:<span class="hljs-number">26</span>:<span class="hljs-number">04</span>:<span class="hljs-number">588</span> [DefaultDispatcher-worker-<span class="hljs-number">2</span>] <span class="hljs-number">123</span></code></pre>
<p><code>Default</code>与<code>IO</code>调度器对任务的执行做了优化，可以保证线程执行效率较高。</p>
<p>主要原理为：Kotlin实现了<code>CoroutineScheduler</code>，支持抢占任务。</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineScheduler</span></span>(
    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> corePoolSize: <span class="hljs-built_in">Int</span>,
    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> maxPoolSize: <span class="hljs-built_in">Int</span>,
    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> idleWorkerKeepAliveNs: <span class="hljs-built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,
    <span class="hljs-meta">@JvmField</span> <span class="hljs-keyword">val</span> schedulerName: String = DEFAULT_SCHEDULER_NAME
) : Executor, Closeable &#123;
  ...
  <span class="hljs-comment">//CPU密集任务队列</span>
    <span class="hljs-meta">@JvmField</span>
    <span class="hljs-keyword">val</span> globalCpuQueue = GlobalQueue()
  <span class="hljs-comment">//IO密集任务队列</span>
    <span class="hljs-meta">@JvmField</span>
    <span class="hljs-keyword">val</span> globalBlockingQueue = GlobalQueue()
  
  ...
      <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(block: <span class="hljs-type">Runnable</span>, taskContext: <span class="hljs-type">TaskContext</span> = NonBlockingContext, tailDispatch: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>)</span></span> &#123;
        trackTask() <span class="hljs-comment">// this is needed for virtual time support</span>
        <span class="hljs-keyword">val</span> task = createTask(block, taskContext)
        <span class="hljs-comment">// try to submit the task to the local queue and act depending on the result</span>
        <span class="hljs-keyword">val</span> currentWorker = currentWorker()
        <span class="hljs-comment">//任务优先插入本地队列中执行</span>
        <span class="hljs-keyword">val</span> notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)
        <span class="hljs-comment">//本地队列已满，就将任务插入到全局队列中</span>
        <span class="hljs-keyword">if</span> (notAdded != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">if</span> (!addToGlobalQueue(notAdded)) &#123;
                <span class="hljs-comment">// Global queue is closed in the last step of close/shutdown -- no more tasks should be accepted</span>
                <span class="hljs-keyword">throw</span> RejectedExecutionException(<span class="hljs-string">"<span class="hljs-variable">$schedulerName</span> was terminated"</span>)
            &#125;
        &#125;
      ...
    &#125;
  <span class="hljs-comment">//执行的任务</span>
   <span class="hljs-keyword">internal</span> <span class="hljs-keyword">inner</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>() : Thread() &#123;
      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> = runWorker()
     <span class="hljs-comment">//执行任务</span>
     <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runWorker</span><span class="hljs-params">()</span></span> &#123;
            <span class="hljs-keyword">var</span> rescanned = <span class="hljs-literal">false</span>
            <span class="hljs-keyword">while</span> (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) &#123;
              <span class="hljs-comment">//从队列中找到任务</span>
                <span class="hljs-keyword">val</span> task = findTask(mayHaveLocalTasks)
              ...
            &#125;
   &#125;
    <span class="hljs-comment">//找到本地队列任务</span>
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findTask</span><span class="hljs-params">(scanLocalQueue: <span class="hljs-type">Boolean</span>)</span></span>: Task? &#123;
            <span class="hljs-comment">//获取CPU控制权</span>
            <span class="hljs-keyword">if</span> (tryAcquireCpuPermit()) <span class="hljs-keyword">return</span> findAnyTask(scanLocalQueue)
            <span class="hljs-comment">// If we can't acquire a CPU permit -- attempt to find blocking task</span>
            <span class="hljs-keyword">val</span> task = <span class="hljs-keyword">if</span> (scanLocalQueue) &#123;
                localQueue.poll() ?: globalBlockingQueue.removeFirstOrNull()
            &#125; <span class="hljs-keyword">else</span> &#123;
                globalBlockingQueue.removeFirstOrNull()
            &#125;
           <span class="hljs-comment">//从其他队列获取任务执行</span>
            <span class="hljs-keyword">return</span> task ?: trySteal(blockingOnly = <span class="hljs-literal">true</span>)
        &#125;

     <span class="hljs-comment">//从其他队列获取任务</span>
     <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">trySteal</span><span class="hljs-params">(blockingOnly: <span class="hljs-type">Boolean</span>)</span></span>: Task? &#123;
            assert &#123; localQueue.size == <span class="hljs-number">0</span> &#125;
            <span class="hljs-keyword">val</span> created = createdWorkers
            <span class="hljs-comment">// 0 to await an initialization and 1 to avoid excess stealing on single-core machines</span>
            <span class="hljs-keyword">if</span> (created &lt; <span class="hljs-number">2</span>) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
            &#125;

            <span class="hljs-keyword">var</span> currentIndex = nextInt(created)
            <span class="hljs-keyword">var</span> minDelay = <span class="hljs-built_in">Long</span>.MAX_VALUE
            repeat(created) &#123;
                ++currentIndex
                <span class="hljs-keyword">if</span> (currentIndex &gt; created) currentIndex = <span class="hljs-number">1</span>
                <span class="hljs-keyword">val</span> worker = workers[currentIndex]
                <span class="hljs-keyword">if</span> (worker !== <span class="hljs-literal">null</span> &amp;&amp; worker !== <span class="hljs-keyword">this</span>) &#123;
                    assert &#123; localQueue.size == <span class="hljs-number">0</span> &#125;
                  <span class="hljs-comment">//从其他工作线程中获取任务来执行</span>
                    <span class="hljs-keyword">val</span> stealResult = <span class="hljs-keyword">if</span> (blockingOnly) &#123;
                        localQueue.tryStealBlockingFrom(victim = worker.localQueue)
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        localQueue.tryStealFrom(victim = worker.localQueue)
                    &#125;
                    <span class="hljs-keyword">if</span> (stealResult == TASK_STOLEN) &#123;
                        <span class="hljs-keyword">return</span> localQueue.poll()
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stealResult &gt; <span class="hljs-number">0</span>) &#123;
                        minDelay = min(minDelay, stealResult)
                    &#125;
                &#125;
            &#125;
            minDelayUntilStealableTaskNs = <span class="hljs-keyword">if</span> (minDelay != <span class="hljs-built_in">Long</span>.MAX_VALUE) minDelay <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        &#125;
  
&#125;</code></pre>
<p>总体设计分为三步：</p>
<ol>
<li>优先任务放在本地线程中，放在<code>Worker</code>中的<code>LocalQueue</code>中</li>
<li>使用双重队列<code>GlobalCpuQueue(CPU密集任务队列)</code>、<code>GlobalBlockingQueue(IO密集任务队列)</code>，<code>LocalQueue</code>满后，任务会放到对应全局队列中</li>
<li>当<code>LocalQueue</code>和<code>GlobalQueue</code>中的任务执行完时，会从其他正在执行任务的<code>Worker</code>中获取他的<code>LocalQueue</code>的任务放到自己的<code>LocalQueue</code>中执行。</li>
</ol>
<p>这三步可以保证<strong>线程资源的充分利用，减少了多线程的切换开销，提高了使用效率</strong>。实现参考的是<code>ForkJoinPool</code>。</p>
<h4 id="Dispatchers-Main"><a href="#Dispatchers-Main" class="headerlink" title="Dispatchers.Main"></a>Dispatchers.Main</h4><blockquote>
<p>UI调度器，根据执行平台不同会初始化为对应平台UI线程的调度器</p>
<p>在Android中，就会通过<code>Handler</code>调度到<code>UI线程</code>执行任务</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-comment">//加载各个平台下定义的`MainDispatcherFactory`</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadMainDispatcher</span><span class="hljs-params">()</span></span>: MainCoroutineDispatcher &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-keyword">val</span> factories = <span class="hljs-keyword">if</span> (FAST_SERVICE_LOADER_ENABLED) &#123;
                FastServiceLoader.loadMainDispatcherFactory()
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// We are explicitly using the</span>
                <span class="hljs-comment">// `ServiceLoader.load(MyClass::class.java, MyClass::class.java.classLoader).iterator()`</span>
                <span class="hljs-comment">// form of the ServiceLoader call to enable R8 optimization when compiled on Android.</span>
                ServiceLoader.load(
                        MainDispatcherFactory::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>,
                        <span class="hljs-type">MainDispatcherFactory::class.java.classLoader</span></span>
                ).iterator().asSequence().toList()
            &#125;
            <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">"ConstantConditionIf"</span>)</span>
            factories.maxBy &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)
                ?: createMissingDispatcher()
        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;
            <span class="hljs-comment">// Service loader can throw an exception as well</span>
            createMissingDispatcher(e)
        &#125;
    &#125;</code></pre>
<p>拿Android举例，分析下如何实现<code>Dispatchers.Main</code>功能</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadMainDispatcherFactory</span><span class="hljs-params">()</span></span>: List&lt;MainDispatcherFactory&gt; &#123;
    <span class="hljs-keyword">val</span> clz = MainDispatcherFactory::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span></span>
    <span class="hljs-keyword">if</span> (!ANDROID_DETECTED) &#123;
        <span class="hljs-keyword">return</span> load(clz, clz.classLoader)
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">val</span> result = ArrayList&lt;MainDispatcherFactory&gt;(<span class="hljs-number">2</span>)
      <span class="hljs-comment">//加载对应类名的类</span>
        createInstanceOf(clz, <span class="hljs-string">"kotlinx.coroutines.android.AndroidDispatcherFactory"</span>)?.apply &#123; result.add(<span class="hljs-keyword">this</span>) &#125;
        createInstanceOf(clz, <span class="hljs-string">"kotlinx.coroutines.test.internal.TestMainDispatcherFactory"</span>)?.apply &#123; result.add(<span class="hljs-keyword">this</span>) &#125;
        result
    &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;
        <span class="hljs-comment">// Fallback to the regular SL in case of any unexpected exception</span>
        load(clz, clz.classLoader)
    &#125;
&#125;</code></pre>
<p>Android下的实现</p>
<pre><code class="hljs kotlin"><span class="hljs-comment">//在Android编译完成后，可以读取到该类</span>
<span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidDispatcherFactory</span> : <span class="hljs-type">MainDispatcherFactory &#123;</span></span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createDispatcher</span><span class="hljs-params">(allFactories: <span class="hljs-type">List</span>&lt;<span class="hljs-type">MainDispatcherFactory</span>&gt;)</span></span> = HandlerContext(Looper.getMainLooper().asHandler(async = <span class="hljs-literal">true</span>), <span class="hljs-string">"Main"</span>)
&#125;
<span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerContext</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler: Handler,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> invokeImmediately: <span class="hljs-built_in">Boolean</span>
) : HandlerDispatcher(), Delay &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(
        handler: Handler,
        name: String? = <span class="hljs-literal">null</span>
    ) : <span class="hljs-keyword">this</span>(handler, name, <span class="hljs-literal">false</span>)

    <span class="hljs-comment">//android中需要向主looper进行提交调度</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isDispatchNeeded</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;
        <span class="hljs-keyword">return</span> !invokeImmediately || Looper.myLooper() != handler.looper
    &#125;

    <span class="hljs-comment">//通过持有主线程looper的handler进行调度</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, block: <span class="hljs-type">Runnable</span>)</span></span> &#123;
        handler.post(block)
    &#125;
    ...
&#125;</code></pre>
<p>Android的<code>Dispatchers.Main</code>通过<code>Handler</code>将任务放到主线程中执行。</p>
<h4 id="Dispatchers-Unconfined"><a href="#Dispatchers-Unconfined" class="headerlink" title="Dispatchers.Unconfined"></a>Dispatchers.Unconfined</h4><blockquote>
<p>在协程体中，遇到第一个挂起函数前的代码运行在原线程中，执行挂起函数后，就运行在子线程中，</p>
</blockquote>
<h4 id="自定义调度器"><a href="#自定义调度器" class="headerlink" title="自定义调度器"></a>自定义调度器</h4><blockquote>
<p><code>Default</code>和<code>IO</code>的底层实现都依赖了<code>线程池</code>，执行到<code>挂起函数</code>时还是会发生线程的切换。可以通过自定义调度器减少这类切换的发生。</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myDispatcher= Executors.newSingleThreadExecutor&#123; r -&gt; Thread(r, <span class="hljs-string">"MyThread"</span>) &#125;.asCoroutineDispatcher() <span class="hljs-comment">//转换线程池到 Dispatcher</span>

<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
  GlobalScope.launch(myDispatcher)&#123;
    <span class="hljs-comment">//TODO </span>
  &#125;
  
  <span class="hljs-comment">//任务执行完毕后关闭线程池，避免内存泄漏</span>
  myDispatcher.close() 
  
&#125;</code></pre>
<h3 id="协程执行任务-Job"><a href="#协程执行任务-Job" class="headerlink" title="协程执行任务(Job)"></a>协程执行任务(<code>Job</code>)</h3><blockquote>
<p><code>Job</code>用于处理协程。封装了协程需要执行的代码逻辑，并且拥有简单的生命周期。</p>
<p><strong>负责管理协程的声明周期。</strong></p>
</blockquote>
<p>主要有以下几个生命周期：</p>
<ul>
<li><code>New</code> 新建任务</li>
<li><code>Active</code> 任务活跃</li>
<li><code>Completing</code> 任务完成中</li>
<li><code>Cancelling</code> 任务取消中</li>
<li><code>Cancelled</code> 任务已取消</li>
<li><code>Completed</code> 任务已完成</li>
</ul>
<span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Job生命周期.jpg" srcset="/img/loading.gif" class="full-image" alt="ViewTree" title="ViewTree"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p><code>Job.join()</code>：中断与当前<code>Job</code>关联的协程，直到所有<code>子Job</code>执行完成，所关联的协程才可以继续执行。</p>
<p><code>join()</code>由<code>suspend</code>修饰，所以必须在协程内部被调用。</p>
<h4 id="SupervisorJob"><a href="#SupervisorJob" class="headerlink" title="SupervisorJob"></a><code>SupervisorJob</code></h4><p>使用<code>Job</code>时，若发生异常会导致异常进行传递，导致<code>父任务及兄弟任务都会被取消</code>。</p>
<p><code>SupervisorJob</code>针对异常传播情况进行处理，当发生异常时，只会影响自身，其他任务不受影响。</p>
<p><strong><code>SupervisorJob</code>只有在<code>supervisorScope</code>或者<code>CoroutineScope(SupervisorJob())</code>内执行可以生效。</strong></p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> scope = CoroutineScope(SupervisorJob())

scope.launch&#123;
  launch&#123;
     <span class="hljs-comment">//child 1</span>
  &#125;
  
  launch&#123;
    <span class="hljs-comment">// child 2</span>
  &#125;
&#125;

若 child1 发生异常 child2可以继续运行。</code></pre>
<h3 id="协程构造器-Coroutine-Builders"><a href="#协程构造器-Coroutine-Builders" class="headerlink" title="协程构造器(Coroutine Builders)"></a>协程构造器(<code>Coroutine Builders</code>)</h3><blockquote>
<p>配置完上述的<code>启动模式、调度器、上下文</code>之后，就要开始构造一个<code>协程</code>。</p>
</blockquote>
<p>协程提供了几个通用的构造器</p>
<h4 id="launch"><a href="#launch" class="headerlink" title="launch"></a><code>launch</code></h4><blockquote>
<p>默认构建一个新的协程，并返回一个<code>Job</code>对象，可以对该<code>Job</code>进行操作，例如<code>start()、join()</code>启动协程,<code>cancel()</code>取消该协程。</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> job = GlobalScope.launch&#123;
  <span class="hljs-comment">//TODO ...</span>
&#125;
job.cancel()</code></pre>
<p><code>Job</code>代表了协程本身，封装了协程需要执行的代码逻辑，并且拥有简单的生命周期。</p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a><code>async</code></h4><blockquote>
<p>创建一个协程后，会返回一个<code>Deferred&lt;T&gt;</code>对象，可以通过该对象调用<code>await()</code>获取返回值。</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> job = GlobalScope.async(Dispatchers.IO) &#123;
	log(<span class="hljs-number">2</span>)
  delay(<span class="hljs-number">1000</span>)
  <span class="hljs-number">123</span>
&#125;
<span class="hljs-keyword">val</span> result = job.await()</code></pre>
<p><code>async</code>允许<strong>并行的允许多个子线程任务</strong>。减少请求的耗时。</p>
<p><code>Deferred</code>提供了<code>await()</code>，用<code>suspend</code>修饰，需要获取<code>Deferred</code>对象的结果时，调用<code>await()</code>等待执行结果返回。</p>
<h3 id="协程异常处理-Coroutine-Exception"><a href="#协程异常处理-Coroutine-Exception" class="headerlink" title="协程异常处理(Coroutine Exception)"></a>协程异常处理(<code>Coroutine Exception</code>)</h3><p>以下是会导致协程异常发生的测试代码</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = <span class="hljs-number">1</span>
<span class="hljs-comment">//模拟产生异常方法</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span> =
    suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;
        <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) &#123;
            continuation.resume(a)
        &#125; <span class="hljs-keyword">else</span> &#123;
            continuation.resumeWithException(IllegalArgumentException(<span class="hljs-string">"haha"</span>))
        &#125;
    &#125;

<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args:<span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>&#123;
    <span class="hljs-keyword">val</span> dispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher();
    coroutineScope.launch(dispatcher) &#123;
        log(<span class="hljs-number">1</span>)
        <span class="hljs-comment">//创建子协程</span>
        <span class="hljs-keyword">val</span> job = coroutineScope.async &#123;
            test2()
        &#125;
        job.join()
        log(<span class="hljs-number">2</span>)
    &#125;
    log(<span class="hljs-number">3</span>)
    dispatcher.close()
&#125;

输出结果：
[main] <span class="hljs-number">3</span>
[pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] <span class="hljs-number">1</span>
Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"pool-1-thread-1"</span> java.lang.IllegalArgumentException: haha

Process finished with exit code <span class="hljs-number">0</span> <span class="hljs-comment">//程序终止</span></code></pre>
<p>有以下两种手段来对异常进行捕获处理</p>
<h4 id="局部异常捕获"><a href="#局部异常捕获" class="headerlink" title="局部异常捕获"></a>局部异常捕获</h4><blockquote>
<p>这部分主要涉及到<code>协程作用域</code>的概念，根据上面对<code>协程作用域</code>的描述，主要分为<code>GlobalScope</code>以及<code>自定义CoroutineScope</code>两种。</p>
<p>对于这两种<code>协程作用域</code>异常传播也有不同的形式。</p>
</blockquote>
<h5 id="不传播异常"><a href="#不传播异常" class="headerlink" title="不传播异常"></a>不传播异常</h5><p>上面提到过<code>GlobalScope</code>为全局作用域，本身不存在父协程，发生异常后，只会输出异常信息，不会对运行产生影响。</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span> &#123;
    coroutineScope.launch &#123;
        log(<span class="hljs-number">1</span>)
        <span class="hljs-keyword">val</span> job = GlobalScope.launch &#123;
            <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"11"</span>)
        &#125;
        log(<span class="hljs-number">2</span>)
        delay(<span class="hljs-number">1000</span>)
        log(<span class="hljs-number">3</span>)
    &#125;
    delay(<span class="hljs-number">1000</span>)
    log(<span class="hljs-number">4</span>)
&#125;

输出结果：
<span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">29</span>:<span class="hljs-number">623</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">1</span>
<span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">29</span>:<span class="hljs-number">625</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">2</span>
Global Exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">catch</span> and msg = <span class="hljs-number">11</span>
Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"DefaultDispatcher-worker-3"</span> java.lang.NullPointerException: <span class="hljs-number">11</span>
	at com.webrtc.lib_licode_adaptation.MyClassKt$test5$<span class="hljs-number">2</span>$job$<span class="hljs-number">1</span>.invokeSuspend(MyClass.kt:<span class="hljs-number">183</span>)
<span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">632</span> [kotlinx.coroutines.DefaultExecutor] <span class="hljs-number">4</span>
<span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">632</span> [DefaultDispatcher-worker-<span class="hljs-number">3</span>] <span class="hljs-number">3</span>

Process finished with exit code <span class="hljs-number">0</span></code></pre>
<p>使用<code>GlobalScope</code>启动协程，发生异常时，不会影响外部协程的运行。</p>
<h5 id="传播异常"><a href="#传播异常" class="headerlink" title="传播异常"></a>传播异常</h5><blockquote>
<p><strong>将异常主动往外抛到启动顶层协程所在的线程。</strong></p>
<p>主要采用<code>try{..}catch{...}</code>方式进行异常捕获</p>
</blockquote>
<p><code>coroutineScope</code></p>
<blockquote>
<p>协程默认作用域，在该作用域内当自身执行任务失败的时候，触发双向传播。</p>
<p><strong>子协程异常&lt;=&gt;父协程异常</strong></p>
</blockquote>
<p>示例：</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span> &#123;
    log(<span class="hljs-number">1</span>)
    coroutineScope &#123;
        <span class="hljs-comment">// 启动一个子协程</span>
        launch &#123;
            <span class="hljs-keyword">try</span> &#123;
                delay(<span class="hljs-number">1000</span>)
                println(<span class="hljs-string">"3"</span>)
            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;
                println(e.message)
            &#125;
        &#125;
        delay(<span class="hljs-number">100</span>)
        <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"111"</span>)
        println(<span class="hljs-string">"3"</span>)
    &#125;
&#125;

输出结果：
<span class="hljs-number">10</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46</span>:<span class="hljs-number">738</span> [main] <span class="hljs-number">1</span>
Parent job <span class="hljs-keyword">is</span> Cancelling <span class="hljs-comment">//由于父协程异常，导致子协程的执行取消</span>
Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.NullPointerException: <span class="hljs-number">111</span></code></pre>
<p><img src="/Users/wxy/myblog/blog/source/images/640.gif" srcset="/img/loading.gif" alt="img"></p>
<p><code>supervisorScope</code></p>
<blockquote>
<p>在作用域内当自身执行任务失败的时候，只会向下传播关闭子协程，不会影响父协程及其他同级协程的运行。</p>
<p><strong>父协程异常-&gt;子线程异常，子协程异常不影响父协程</strong></p>
<p><code>supervisorScope</code>使用<code>SupervisorJob</code></p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SupervisorJobImpl</span></span>(parent: Job?) : JobImpl(parent) &#123;
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">childCancelled</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//子协程不影响父协程</span>
&#125;</code></pre>
<p>示例：</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span> &#123;
    println(<span class="hljs-number">1</span>)
    supervisorScope &#123;
        println(<span class="hljs-string">"2"</span>)
        <span class="hljs-comment">// 启动一个子协程</span>
        launch &#123;
            <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">"111"</span>)<span class="hljs-comment">// 故意让子协程出现异常</span>
        &#125;
        delay(<span class="hljs-number">100</span>)
        println(<span class="hljs-string">"3"</span>)
    &#125;
    println(<span class="hljs-string">"4"</span>)
&#125;

输出结果：
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"DefaultDispatcher-worker-1"</span> java.lang.NullPointerException: <span class="hljs-number">111</span>
...
<span class="hljs-number">3</span>
<span class="hljs-number">4</span></code></pre>
<p><code>supervisorScope</code>内子协程的异常不影响父协程的继续运行。</p>
<p><img src="/Users/wxy/myblog/blog/source/images/640.png" srcset="/img/loading.gif" alt="img"></p>
<h4 id="全局异常捕获"><a href="#全局异常捕获" class="headerlink" title="全局异常捕获"></a>全局异常捕获</h4><blockquote>
<p>类似<code>Java</code>，协程也提供了捕获全局异常(<code>未声明捕获异常</code>)的方式。</p>
</blockquote>
<p><code>Java</code>的全局异常捕获方式：</p>
<pre><code class="hljs java">Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> UncaughtExceptionHandler() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;
        <span class="hljs-comment">//TODO 异常处理</span>
    &#125;
&#125;);</code></pre>
<h5 id="协程内全局异常捕获方式（针对协程作用域内未捕获的异常）"><a href="#协程内全局异常捕获方式（针对协程作用域内未捕获的异常）" class="headerlink" title="协程内全局异常捕获方式（针对协程作用域内未捕获的异常）"></a>协程内全局异常捕获方式（<code>针对协程作用域内未捕获的异常</code>）</h5><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;
        log(<span class="hljs-string">"Throws an exception with message: <span class="hljs-subst">$&#123;throwable.message&#125;</span>"</span>)
    &#125;
    log(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">val</span> job = coroutineScope.launch(exceptionHandler) &#123;
        log(<span class="hljs-number">3</span>)
        <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">"Hey!"</span>)
    &#125;
    log(<span class="hljs-number">2</span>)
  <span class="hljs-comment">//避免执行过程中 进程中断，导致输出结果不一致</span>
    delay(<span class="hljs-number">1000</span>)
&#125;

输出结果：
<span class="hljs-number">15</span>:<span class="hljs-number">31</span>:<span class="hljs-number">47</span>:<span class="hljs-number">846</span> [main] <span class="hljs-number">1</span>
<span class="hljs-number">15</span>:<span class="hljs-number">31</span>:<span class="hljs-number">47</span>:<span class="hljs-number">927</span> [main] <span class="hljs-number">2</span>
<span class="hljs-number">15</span>:<span class="hljs-number">31</span>:<span class="hljs-number">47</span>:<span class="hljs-number">929</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">3</span>
<span class="hljs-number">15</span>:<span class="hljs-number">31</span>:<span class="hljs-number">47</span>:<span class="hljs-number">933</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] Throws an exception with message: Hey! <span class="hljs-comment">//捕获到异常</span>

Process finished with exit code <span class="hljs-number">0</span></code></pre>
<p>上述代码调用了<code>launch</code>的构造方式，<code>async</code>的输出结果会如何？</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;
        log(<span class="hljs-string">"Throws an exception with message: <span class="hljs-subst">$&#123;throwable.message&#125;</span>"</span>)
    &#125;
    log(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">val</span> job = coroutineScope.async(exceptionHandler) &#123;
        log(<span class="hljs-number">3</span>)
        <span class="hljs-number">4</span>
        <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">"Hey!"</span>)
    &#125;
    log(<span class="hljs-number">2</span>)
    log(job.await())
    delay(<span class="hljs-number">1000</span>)
&#125;

输出结果：
<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">14</span>:<span class="hljs-number">980</span> [main] <span class="hljs-number">1</span>
<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">013</span> [main] <span class="hljs-number">2</span>
<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">015</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">3</span>
Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.ArithmeticException: Hey!
	at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$<span class="hljs-number">1</span>.invokeSuspend(MyClass.kt:<span class="hljs-number">171</span>)</code></pre>
<p><code>async</code>直接抛出未捕获异常，导致当前进程执行中断</p>
<p>针对<code>launch</code>和<code>async</code>的不同表现，需要从源码层面进行分析</p>
<pre><code class="hljs kotlin">`launch`执行指向以下代码
<span class="hljs-comment">// kotlinx.coroutines.BuildersKt</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CoroutineScope.<span class="hljs-title">launch</span><span class="hljs-params">(
    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,
    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,<span class="hljs-comment">//启动方式</span>
    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">Unit</span>
)</span></span>: Job &#123;
    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)
    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span>
        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)
    coroutine.start(start, coroutine, block)
    <span class="hljs-keyword">return</span> coroutine
&#125;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandaloneCoroutine</span></span>(
    parentContext: CoroutineContext,
    active: <span class="hljs-built_in">Boolean</span>
) : AbstractCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt;(parentContext, active) &#123;
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleJobException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;
        handleCoroutineException(context, exception)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleCoroutineException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> &#123;
    <span class="hljs-comment">// Invoke an exception handler from the context if present</span>
    <span class="hljs-comment">//若context存在 ExceptionHandler 则会对异常进行处理</span>
    <span class="hljs-keyword">try</span> &#123;
        context[CoroutineExceptionHandler]?.let &#123;
            it.handleException(context, exception)
            <span class="hljs-keyword">return</span>
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (t: Throwable) &#123;
        handleCoroutineExceptionImpl(context, handlerException(exception, t))
        <span class="hljs-keyword">return</span>
    &#125;
    <span class="hljs-comment">// If a handler is not present in the context or an exception was thrown, fallback to the global handler</span>
    handleCoroutineExceptionImpl(context, exception)
&#125;

`async`执行指向如下代码
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> CoroutineScope.<span class="hljs-title">async</span><span class="hljs-params">(
    context: <span class="hljs-type">CoroutineContext</span> = EmptyCoroutineContext,
    start: <span class="hljs-type">CoroutineStart</span> = CoroutineStart.DEFAULT,
    block: <span class="hljs-type">suspend</span> <span class="hljs-type">CoroutineScope</span>.() -&gt; <span class="hljs-type">T</span>
)</span></span>: Deferred&lt;T&gt; &#123;
    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)
    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)
        LazyDeferredCoroutine(newContext, block) <span class="hljs-keyword">else</span>
        DeferredCoroutine&lt;T&gt;(newContext, active = <span class="hljs-literal">true</span>)
    coroutine.start(start, coroutine, block)
    <span class="hljs-keyword">return</span> coroutine
&#125;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeferredCoroutine</span>&lt;<span class="hljs-type">T</span>&gt;</span>(
    parentContext: CoroutineContext,
    active: <span class="hljs-built_in">Boolean</span>
) : AbstractCoroutine&lt;T&gt;(parentContext, active), Deferred&lt;T&gt;, SelectClause1&lt;T&gt; &#123;
  <span class="hljs-comment">//没有对 exception进行处理，导致全局异常无法处理</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getCompleted</span><span class="hljs-params">()</span></span>: T = getCompletedInternal() <span class="hljs-keyword">as</span> T
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T = awaitInternal() <span class="hljs-keyword">as</span> T
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> onAwait: SelectClause1&lt;T&gt; <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">this</span>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">registerSelectClause1</span><span class="hljs-params">(select: <span class="hljs-type">SelectInstance</span>&lt;<span class="hljs-type">R</span>&gt;, block: <span class="hljs-type">suspend</span> (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span> =
        registerSelectClause1Internal(select, block)
&#125;</code></pre>
<p>综上所述：<strong>在全局异常处理下，只有用<code>launch</code>启动的协程才可以捕获异常，而<code>async</code>不能被捕获异常，会继续抛出异常。</strong></p>
<h5 id="真·全局异常捕获方式"><a href="#真·全局异常捕获方式" class="headerlink" title="真·全局异常捕获方式"></a>真·全局异常捕获方式</h5><p>上述实现的<code>ExceptionHandler</code>只能在协程内使用，而无法处理其他协程的异常情况。需要使用<code>ServiceLoader</code>来实现全局协程异常捕获</p>
<p>实现全局的异常捕获需要如下几步：</p>
<ol>
<li><p>新建全局<code>ExceptionHandler</code>类</p>
<pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionHandler</span> : <span class="hljs-type">CoroutineExceptionHandler&#123;</span></span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleException</span><span class="hljs-params">(context: <span class="hljs-type">CoroutineContext</span>, exception: <span class="hljs-type">Throwable</span>)</span></span> &#123;
        print(<span class="hljs-string">"Global Exception is catch and msg = <span class="hljs-subst">$&#123;exception.message&#125;</span>"</span>)
    &#125;
&#125;</code></pre>
</li>
</ol>
<ol start="2">
<li><p><code>classpath</code>中注册该类</p>
<p>在<code>src/main</code>目录下新建<code>resources/META-INF/</code>文件夹，然后新建文件命名为<code>kotlinx.coroutines.CoroutineExceptionHandler</code>，文件内写入</p>
<pre><code class="hljs undefined">com.XX<span class="hljs-class">.<span class="hljs-keyword">lib</span>.<span class="hljs-title">GlobalExceptionHandler</span></span></code></pre>
<p>目录结构如下：</p>
<p>src</p>
<p>​    -main</p>
<p>​        -java</p>
<p>​        -resources</p>
<p>​            -META-INF</p>
<p>​                -services</p>
<p>​                    -kotlinx.coroutines.CoroutineExceptionHandler</p>
</li>
<li><p>测试效果</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;
        print(<span class="hljs-string">"Throws an exception with message: <span class="hljs-subst">$&#123;throwable.message&#125;</span>"</span>)
    &#125;
    log(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">val</span> job = coroutineScope.launch() &#123; <span class="hljs-comment">//exceptionHandler配置</span>
        log(<span class="hljs-number">3</span>)
        <span class="hljs-keyword">throw</span> ArithmeticException(<span class="hljs-string">"Hey!"</span>)
    &#125;
    log(<span class="hljs-number">2</span>)
  <span class="hljs-comment">//避免执行过程中 进程中断，导致输出结果不一致</span>
    delay(<span class="hljs-number">1000</span>)
&#125;

输出结果：
<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">14</span>:<span class="hljs-number">980</span> [main] <span class="hljs-number">1</span>
<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">013</span> [main] <span class="hljs-number">2</span>
<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">015</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">3</span>
Global Exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">catch</span> and msg = Hey!
Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.ArithmeticException: Hey!
	at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$<span class="hljs-number">1</span>.invokeSuspend(MyClass.kt:<span class="hljs-number">171</span>)

若配置了exceptionHandler就会覆盖Global的配置
输出如下内容：
<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">14</span>:<span class="hljs-number">980</span> [main] <span class="hljs-number">1</span>
<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">013</span> [main] <span class="hljs-number">2</span>
<span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">15</span>:<span class="hljs-number">015</span> [DefaultDispatcher-worker-<span class="hljs-number">1</span>] <span class="hljs-number">3</span>
Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.ArithmeticException: Hey!
	at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$<span class="hljs-number">1</span>.invokeSuspend(MyClass.kt:<span class="hljs-number">171</span>)</code></pre>
<p><strong>全局异常捕获的配置只对<code>launch</code>有效，<code>async</code>无效。</strong></p>
<p><code>真·全局异常捕获</code>不支持<code>JS以及Native</code>平台。</p>
<p>拓展：</p>
<ol>
<li><p>SPI机制</p>
<blockquote>
<p>全称为<code>Service Provider Interface</code>，JDK内置的一种服务提供发现机制，主要源码在<code>java,util.ServiceLoader</code>。</p>
</blockquote>
<p>使用时需要在<code>META-INF/services</code>创建和服务同名的<strong>全限定名</strong>相同的文件(例如<em>com.xx.xx.service</em>)，在文件中写入<strong>服务提供者</strong>的全限定名(例如<em>com.xxx.xx.XXService</em>)。</p>
<p>实现原理：</p>
<ol>
<li>调用<code>ServiceLaoder.load()</code>创建新的<code>ServiceLoader</code></li>
<li>再通过迭代器获取对象实例<ul>
<li>判断<code>providers</code>是否缓存实例对象，若存在则返回</li>
<li>不存在，则执行类的装载过程：<ol>
<li>读取<code>META-INF/services</code>的配置文件，获得需要被实例化类的名称</li>
<li>反射调用<code>Class.forName()</code>并调用<code>instance()</code>进行类实例化。<strong>需要对应类必须存在一个无参构造方法。</strong></li>
<li>实例化对象存到<code>providers</code>缓存对象中并返回实例对象。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>无法按需加载，只能通过遍历的方式获取全部接口实现类</li>
<li>无法直接获取实例对象，只能通过遍历匹配对应实现类</li>
<li>并发<code>serviceLoader</code>是不安全的</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p><strong>协程内部异常处理流程</strong></p>
<ul>
<li>在作用域内使用<code>try..catch</code>可以直接捕获子线程中的异常</li>
<li>如果未设置异常捕获，则会走<code>全局异常捕获流程</code>(<strong>只在<code>launch</code>创建协程下生效</strong>)<ul>
<li>若设置<code>CoroutineExceptionHandler</code>则处理</li>
<li>没配置，向<code>GlobalExceptionHandler</code>进行处理，该配置时全局的，对所有协程任务生效</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>异常传播不同作用域表现</strong></p>
<ul>
<li><code>GlobalScope</code>：异常不会向外传递，因为已经是<code>根协程</code></li>
<li><code>coroutineScope</code>：异常进行<code>双向传递</code>，父协程和子协程都会被取消</li>
<li><code>supervisorScope</code>：异常进行<code>单向传递</code>，只有父协程向子协程传递异常，子协程会被取消，父协程不受影响</li>
</ul>
</li>
<li><p><code>launch/join</code>和<code>async/await</code>表现不同</p>
<p><code>launch/join</code>关注的是<strong>任务是否执行完成</strong>，<code>async/await</code>关注的是<strong>任务的执行结果</strong>，所以在局部异常捕获的时候，两种创建方式的异常捕获也会有区别</p>
</li>
<li><p><strong>全局的异常处理器(CoroutineExceptionHandler)只会对父协程生效，子协程的异常最后还是会传递到根协程进行处理。</strong>非<code>supervisorScope</code>条件下。</p>
</li>
</ol>
<h3 id="协程取消-Coroutine-Cancel"><a href="#协程取消-Coroutine-Cancel" class="headerlink" title="协程取消(Coroutine Cancel)"></a>协程取消(<code>Coroutine Cancel</code>)</h3><blockquote>
<p>取消针对<code>Job</code>而设的，调用<code>cancel()</code>可以取消正在运行的协程。</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-comment">//官方示例代码</span>
<span class="hljs-keyword">val</span> job = launch &#123;
    repeat(<span class="hljs-number">1000</span>) &#123; i -&gt;
        println(<span class="hljs-string">"I'm sleeping <span class="hljs-variable">$i</span> ..."</span>)
        delay(<span class="hljs-number">500L</span>)
    &#125;
&#125;
delay(<span class="hljs-number">1300L</span>) <span class="hljs-comment">// 等待一段时间</span>
println(<span class="hljs-string">"main: I'm tired of waiting!"</span>)
job.cancel() <span class="hljs-comment">// 取消 job</span>
job.join() <span class="hljs-comment">// 等待 job 结束</span>
println(<span class="hljs-string">"main: Now I can quit."</span>)</code></pre>
<p>上述代码是最基础的<code>cancel</code>使用方式</p>
<h4 id="协程之间的关系"><a href="#协程之间的关系" class="headerlink" title="协程之间的关系"></a>协程之间的关系</h4><blockquote>
<p>协程之间是存在着父子关系的，<strong>取消父协程时，也会取消所有子协程！</strong></p>
</blockquote>
<p>主要有以下三种关系：</p>
<h5 id="父协程调用cancel-主动或者触发异常结束时，会立即取消所有子协程；子协程调用cancel-不影响父协程及兄弟协程执行。"><a href="#父协程调用cancel-主动或者触发异常结束时，会立即取消所有子协程；子协程调用cancel-不影响父协程及兄弟协程执行。" class="headerlink" title="父协程调用cancel()主动或者触发异常结束时，会立即取消所有子协程；子协程调用cancel()不影响父协程及兄弟协程执行。"></a>父协程调用<code>cancel()</code>主动或者触发异常结束时，会立即取消所有子协程；子协程调用<code>cancel()</code>不影响父协程及兄弟协程执行。</h5><pre><code class="hljs kotlin">基础调用流程
Job.cancel() =&gt; JobImpl.cancel() =&gt; JobSupport.cancelImpl() =&gt; JobSupport.notifyCancelling()

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">notifyCancelling</span><span class="hljs-params">(list: <span class="hljs-type">NodeList</span>, cause: <span class="hljs-type">Throwable</span>)</span></span> &#123;
        <span class="hljs-comment">// first cancel our own children</span>
        onCancelling(cause)
        notifyHandlers&lt;JobCancellingNode&lt;*&gt;&gt;(list, cause)
        <span class="hljs-comment">// then cancel parent</span>
        cancelParent(cause) <span class="hljs-comment">// tentative cancellation -- does not matter if there is no parent</span>
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancelParent</span><span class="hljs-params">(cause: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;
        <span class="hljs-comment">// Is scoped coroutine -- don't propagate, will be rethrown</span>
        <span class="hljs-keyword">if</span> (isScopedCoroutine) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>

        <span class="hljs-keyword">val</span> isCancellation = cause <span class="hljs-keyword">is</span> CancellationException
        <span class="hljs-keyword">val</span> parent = parentHandle
        <span class="hljs-comment">// No parent -- ignore CE, report other exceptions.</span>
        <span class="hljs-keyword">if</span> (parent === <span class="hljs-literal">null</span> || parent === NonDisposableHandle) &#123;
            <span class="hljs-keyword">return</span> isCancellation
        &#125;
        <span class="hljs-comment">//调用所有子协程进行取消任务，子线程也会收到 CancellException</span>
        <span class="hljs-keyword">return</span> parent.childCancelled(cause) || isCancellation
    &#125;</code></pre>
<h5 id="父协程必须等到所有子协程完成-执行完成-或-取消-才算完成"><a href="#父协程必须等到所有子协程完成-执行完成-或-取消-才算完成" class="headerlink" title="父协程必须等到所有子协程完成(执行完成 或 取消)才算完成"></a>父协程必须等到所有子协程完成(执行完成 或 取消)才算完成</h5><h5 id="子协程抛出未捕获的异常时，默认情况下会取消父协程-CancellationException除外"><a href="#子协程抛出未捕获的异常时，默认情况下会取消父协程-CancellationException除外" class="headerlink" title="子协程抛出未捕获的异常时，默认情况下会取消父协程(CancellationException除外)"></a>子协程抛出未捕获的异常时，默认情况下会取消父协程(<code>CancellationException除外</code>)</h5><h4 id="只有可取消的协程代码，才可以被取消"><a href="#只有可取消的协程代码，才可以被取消" class="headerlink" title="只有可取消的协程代码，才可以被取消"></a>只有可取消的协程代码，才可以被取消</h4><blockquote>
<p>协程的代码必须与外界配合，才能够被取消！</p>
</blockquote>
<p>目前只有<code>kotlinx.coroutines</code>中的所有挂起函数都是<strong>可取消的</strong>。这些挂起函数会检查协程是否被取消，并在被取消时抛出<code>CancellationException</code>异常。</p>
<p>例如<code>delay()、yield()</code>这些预置的挂起函数，或者封装的挂起函数都是可以被取消的。</p>
<h5 id="delay"><a href="#delay" class="headerlink" title="delay()"></a>delay()</h5><blockquote>
<p>让协程挂起，而且不会阻塞CPU。</p>
<!--Thread.sleep 让出CPU，不会释放锁。wait会释放锁，等待notify进行唤醒-->
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>)</span></span> &#123;
    <span class="hljs-keyword">if</span> (timeMillis &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// don't delay</span>
    <span class="hljs-keyword">return</span> suspendCancellableCoroutine <span class="hljs-symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; -&gt;
        <span class="hljs-comment">//将任务放到</span>
        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)
    &#125;
&#125;

<span class="hljs-comment">//默认延迟线程池</span>
<span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> CoroutineContext.delay: Delay <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">get</span>(ContinuationInterceptor) <span class="hljs-keyword">as</span>? Delay ?: DefaultDelay

<span class="hljs-comment">//EventLoopImplBase</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleResumeAfterDelay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>, continuation: <span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">Unit</span>&gt;)</span></span> &#123;
        <span class="hljs-keyword">val</span> timeNanos = delayToNanos(timeMillis)<span class="hljs-comment">//设置执行时间</span>
        <span class="hljs-keyword">if</span> (timeNanos &lt; MAX_DELAY_NS) &#123;
            <span class="hljs-keyword">val</span> now = nanoTime()
            DelayedResumeTask(now + timeNanos, continuation).also &#123; task -&gt; <span class="hljs-comment">//按照延时添加任务</span>
                continuation.disposeOnCancellation(task)
                schedule(now, task)
            &#125;
        &#125;
    &#125;</code></pre>
<p>关键点就在于<code>suspendCancellableCoroutine</code>提供了普通函数的挂起转换</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">suspendCancellableCoroutine</span><span class="hljs-params">(
    <span class="hljs-keyword">crossinline</span> block: (<span class="hljs-type">CancellableContinuation</span>&lt;<span class="hljs-type">T</span>&gt;) -&gt; <span class="hljs-type">Unit</span>
)</span></span>: T =
    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;
        <span class="hljs-keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)
        <span class="hljs-comment">/*
         * For non-atomic cancellation we setup parent-child relationship immediately
         * in case when `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but
         * properly supports cancellation.
         */</span>
        cancellable.initCancellability()
        block(cancellable)
        cancellable.getResult()
    &#125;</code></pre>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h5><blockquote>
<p>挂起当前协程，然后将协程分发到<code>Dispatcher</code>的队列，可以让该协程所在线程或线程池可以运行其他协程逻辑，然后等待<code>Disapcher</code>空闲的时候继续执行原来协程。</p>
<!--Thread.yield() 让出CPU调度，只能让 同优先级的线程有执行机会-->
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> dispatcher = Executors.newFixedThreadPool(<span class="hljs-number">2</span>).asCoroutineDispatcher()  
coroutineScope.launch(dispatcher)&#123;
            launch &#123; <span class="hljs-comment">//协程1</span>
                repeat(<span class="hljs-number">3</span>) &#123;
                    log(<span class="hljs-string">"job1 repeat <span class="hljs-variable">$it</span> times"</span>)
                    yield() <span class="hljs-comment">//让协程2得以执行</span>
                &#125;
            &#125;
            launch &#123; <span class="hljs-comment">//协程2</span>
                repeat(<span class="hljs-number">3</span>) &#123;
                    log(<span class="hljs-string">"job2 repeat <span class="hljs-variable">$it</span> times"</span>)
<span class="hljs-comment">//                    yield()</span>
                &#125;
            &#125;
    &#125;
delay(<span class="hljs-number">1000</span>)
dispatcher.close()

输出结果：
<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">808</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>] job1 repeat <span class="hljs-number">0</span> times
<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">809</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] job2 repeat <span class="hljs-number">0</span> times
<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">809</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] job2 repeat <span class="hljs-number">1</span> times
<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">809</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] job2 repeat <span class="hljs-number">2</span> times
<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">809</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] job1 repeat <span class="hljs-number">1</span> times
<span class="hljs-number">19</span>:<span class="hljs-number">28</span>:<span class="hljs-number">30</span>:<span class="hljs-number">809</span> [pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>] job1 repeat <span class="hljs-number">2</span> times</code></pre>
<p><code>yield()</code>相关源码</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> = suspendCoroutineUninterceptedOrReturn <span class="hljs-symbol">sc@</span> &#123; uCont -&gt;
    <span class="hljs-keyword">val</span> context = uCont.context
    context.checkCompletion()
    ...
    COROUTINE_SUSPENDED
&#125;</code></pre>
<h5 id="suspendCoroutineUninterceptedOrReturn"><a href="#suspendCoroutineUninterceptedOrReturn" class="headerlink" title="*suspendCoroutineUninterceptedOrReturn"></a>*suspendCoroutineUninterceptedOrReturn</h5><p>根据上面两个源码发现，转换挂起函数的关键在于<code>suspendCoroutineUninterceptedOrReturn</code>，只要实现了该函数，就可以转换为可被取消的挂起函数</p>
<p>通常做转换的时候，可以使用系统提供的两个转换函数</p>
<ul>
<li><code>suspendCoroutine</code></li>
<li><code>suspendCancellableCoroutine</code></li>
</ul>
<p>这两者都调用了<code>suspendCoroutineUninterceptedOrReturn</code>函数</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> aa = <span class="hljs-number">0</span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ttt</span><span class="hljs-params">()</span></span> = suspendCancellableCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; cancellableContinuation -&gt;
    <span class="hljs-keyword">if</span> (aa == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">//执行完毕抛出结果</span>
        cancellableContinuation.resume(<span class="hljs-number">1</span>) &#123;
            <span class="hljs-comment">// 执行过程异常捕获</span>
            log(<span class="hljs-string">"aaa <span class="hljs-subst">$&#123;it.message&#125;</span>"</span>)
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        cancellableContinuation.resumeWithException(IllegalArgumentException(<span class="hljs-string">"123"</span>))
    &#125;

    cancellableContinuation.invokeOnCancellation &#123;
       <span class="hljs-comment">//协程任务执行cancel时，回调该方法</span>
        log(<span class="hljs-string">"我被取消了"</span>)
    &#125;
&#125;</code></pre>
<h4 id="取消计算代码-使用isActive判断"><a href="#取消计算代码-使用isActive判断" class="headerlink" title="取消计算代码(使用isActive判断)"></a>取消计算代码(使用<code>isActive</code>判断)</h4><blockquote>
<p>如果协程正处在某个计算过程当中，并且不进行检查状态的取消，那它就是无法被取消的。</p>
</blockquote>
<p>对于这种情况有两种处理方式：</p>
<ol>
<li>周期性调用挂起函数(<code>采用上面的手段得到挂起函数</code>)，检查协程是否被取消</li>
<li>显式检查协程是否被取消</li>
</ol>
<p>在这一节，采用的就是第二种方案取消协程。</p>
<pre><code class="hljs kotlin">suspend fun test9() &#123;
    val startTime = System.currentTimeMillis()
    val dispatcher = Executors.newFixedThreadPool(3).asCoroutineDispatcher()
    val job = coroutineScope.launch(dispatcher) &#123;
        var nextPrintTime = startTime
        var i = 0
        while (isActive) &#123; // 一个浪费 CPU 的计算任务循环
            // 每秒打印信息 2 次
            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;
                i++
                log(i)
                nextPrintTime += 500L
            &#125;
        &#125;
    &#125;
    delay(1300L) // 等待一段时间
    println("main: I'm tired of waiting!")
    job.cancelAndJoin() // 取消 job, 并等待它结束
    println("main: Now I can quit.")
    dispatcher.close()
&#125;

输出结果：
19:30:01:805 [pool-1-thread-1] 1
19:30:02:292 [pool-1-thread-1] 2
19:30:02:792 [pool-1-thread-1] 3
main: I'm tired of waiting!
main: Now I can quit.</code></pre>
<p>相关源码</p>
<pre><code class="hljs kotlin">JobSupport.cancelImpl() =&gt; JobSupport.makeCancelling() =&gt; JobSupport.tryMakeCancelling()

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryMakeCancelling</span><span class="hljs-params">(state: <span class="hljs-type">Incomplete</span>, rootCause: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;
        assert &#123; state !<span class="hljs-keyword">is</span> Finishing &#125; <span class="hljs-comment">// only for non-finishing states</span>
        assert &#123; state.isActive &#125; <span class="hljs-comment">// only for active states</span>
        <span class="hljs-comment">// get state's list or else promote to list to correctly operate on child lists</span>
        <span class="hljs-keyword">val</span> list = getOrPromoteCancellingList(state) ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        <span class="hljs-comment">// Create cancelling state (with rootCause!)</span>
        <span class="hljs-keyword">val</span> cancelling = Finishing(list, <span class="hljs-literal">false</span>, rootCause)
        <span class="hljs-keyword">if</span> (!_state.compareAndSet(state, cancelling)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        <span class="hljs-comment">// Notify listeners</span>
        notifyCancelling(list, rootCause)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Finishing</span></span>(
        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> list: NodeList,
        isCompleting: <span class="hljs-built_in">Boolean</span>,
        rootCause: Throwable?
    ) : SynchronizedObject(), Incomplete &#123;
      
      ...
       <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = rootCause == <span class="hljs-literal">null</span> <span class="hljs-comment">// !isCancelling 此处isActive就变为false</span>
    &#125;</code></pre>
<h4 id="禁止取消"><a href="#禁止取消" class="headerlink" title="禁止取消"></a>禁止取消</h4><blockquote>
<p>当任务被取消时，挂起函数会收到<code>CancellationException</code>后续如果需要执行一些其他的挂起函数任务将无法执行。</p>
</blockquote>
<p>可以通过对挂起函数调用<code>withContext(NonCancellable)</code>进行包含，保证挂起函数正常执行</p>
<pre><code class="hljs kotlin">suspend fun test9() &#123;
    val startTime = System.currentTimeMillis()
    val dispatcher = Executors.newFixedThreadPool(3).asCoroutineDispatcher()
    val job = coroutineScope.launch(dispatcher) &#123;
        try &#123;
            var nextPrintTime = startTime
            var i = 0
            //按道理 这边会被取消，因为设置了 NonCancellable导致任务无法被取消
            withContext(NonCancellable)&#123;
                log("111")
                delay(2000)
            &#125;
        &#125;
        finally &#123;
                withContext(NonCancellable)&#123;
                    delay(1000)
                &#125;
                log("111")
        &#125;
    &#125;
    delay(1300L) // 等待一段时间
    println("main: I'm tired of waiting!")
    job.cancelAndJoin() // 取消 job, 并等待它结束
    println("main: Now I can quit.")
    dispatcher.close()
&#125;

输出结果：
20:31:35:163 [pool-1-thread-1] 111
main: I'm tired of waiting!
20:31:38:173 [pool-1-thread-3] 111  //间隔大概3s
main: Now I can quit.</code></pre>
<p><code>NonCancellable</code>就是一个普通的对象</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> NonCancellable : AbstractCoroutineContextElement(Job), Job &#123;
 ...
      <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = <span class="hljs-literal">true</span> <span class="hljs-comment">//永远为true</span>
&#125;</code></pre>
<h4 id="超时取消"><a href="#超时取消" class="headerlink" title="超时取消"></a>超时取消</h4><blockquote>
<p>大部分取消协程的原因都是<strong>超出了预期的执行时间</strong>，此时就会去触发取消的操作。</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testTimeout</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">try</span> &#123;
        withTimeout(<span class="hljs-number">1300</span>) &#123;
            repeat(<span class="hljs-number">5</span>) &#123;
                delay(<span class="hljs-number">500</span>)
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;
        log(<span class="hljs-string">"e.msg = <span class="hljs-subst">$&#123;e.message&#125;</span>"</span>) <span class="hljs-comment">//捕获超时异常</span>
    &#125; <span class="hljs-keyword">finally</span> &#123;
        log(<span class="hljs-string">"job cancelled"</span>) <span class="hljs-comment">//任务取消后，可以做一些其他工作</span>
    &#125;
    delay(<span class="hljs-number">1000</span>)
&#125;

输出结果：
<span class="hljs-number">13</span>:<span class="hljs-number">25</span>:<span class="hljs-number">54</span>:<span class="hljs-number">484</span> [kotlinx.coroutines.DefaultExecutor] e.msg = Timed <span class="hljs-keyword">out</span> waiting <span class="hljs-keyword">for</span> <span class="hljs-number">1300</span> ms
<span class="hljs-number">13</span>:<span class="hljs-number">25</span>:<span class="hljs-number">54</span>:<span class="hljs-number">485</span> [kotlinx.coroutines.DefaultExecutor] job cancelled</code></pre>
<p>执行超过<code>timeout</code>的时候，会抛出<code>TimeoutCancellationException</code>异常</p>
<p>上述<code>withTimeout()</code>超时时会抛出异常，系统另外提供了<code>withTimeoutOrNull()</code>超时的时候不会抛出异常，而是返回一个null</p>
<h3 id="协程挂起-suspend"><a href="#协程挂起-suspend" class="headerlink" title="协程挂起(suspend)"></a>协程挂起(<code>suspend</code>)</h3><p>在上节<code>协程取消</code>中，说到取消协程的一个要求就是<code>必须为可被取消的协程代码</code>，里面就有讲到转换成<code>挂起函数</code>就可以被取消。</p>
<blockquote>
<p>把协程当成一个任务，运行在某个线程之上，该任务是可以中止也可以被继续恢复执行。</p>
<p><code>协程挂起</code>指的就是<em>任务的中止，而且不会阻塞当前的线程。</em></p>
<p><code>协程挂起</code>的条件是<em>在协程调用<code>挂起函数</code>时，才可以被挂起</em>。</p>
</blockquote>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><h5 id="续体接口-Continuation"><a href="#续体接口-Continuation" class="headerlink" title="续体接口(Continuation)"></a>续体接口(<code>Continuation</code>)</h5><blockquote>
<p>作为协程调用<code>挂起函数</code>时的回调，<code>挂起函数</code>执行结束后通过使用该接口唤醒调用者。</p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-meta">@SinceKotlin(<span class="hljs-meta-string">"1.3"</span>)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Continuation</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;
    <span class="hljs-comment">/**
     * The context of the coroutine that corresponds to this continuation.
     * 定义的协程上下文
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> context: CoroutineContext

    <span class="hljs-comment">/**
     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the
     * return value of the last suspension point.
     * 执行完毕回调，回调成功或失败的结果
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resumeWith</span><span class="hljs-params">(result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>
&#125;
<span class="hljs-comment">//提供拓展函数，支持直接调用成功或失败回调</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resume</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Unit</span> =
    resumeWith(Result.success(value))

<span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Continuation<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">resumeWithException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>)</span></span>: <span class="hljs-built_in">Unit</span> =
    resumeWith(Result.failure(exception))</code></pre>
<p><code>Continuation</code>作为<code>挂起函数</code>调用时的一个<code>隐式参数</code>传入，封装了协程恢复后的执行代码逻辑。</p>
<h5 id="挂起函数-suspend-function"><a href="#挂起函数-suspend-function" class="headerlink" title="挂起函数(suspend function)"></a>挂起函数(<code>suspend function</code>)</h5><blockquote>
<p> <code>suspend</code>修饰挂起函数，可以通过调用其他<code>挂起函数</code>执行代码，而且<strong>不阻塞当前执行线程</strong>。</p>
<p><code>挂起函数</code>的运行可以被中止，运行<code>挂起函数</code>的线程可以去执行其他任务。</p>
<p><strong>挂起函数无法被其他常规函数调用！</strong></p>
</blockquote>
<pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
  ...
&#125;</code></pre>
<p>上述实例为<code>挂起函数</code>。</p>
<p>当<code>挂起函数</code>在一个协程中被调用时，该挂起函数内部会增加一个参数<code>Continuation</code>，类似下面的代码</p>
<pre><code class="hljs java"><span class="hljs-function">fun <span class="hljs-title">test</span><span class="hljs-params">(contimuation:Continuation)</span></span>&#123;
  ...
&#125;</code></pre>
<p>这种转换被称为<strong>CPS（续体传递风格）</strong>，每个<code>挂起函数</code>或<code>挂起Lambda表达式</code>都会附加一个<code>Continuation</code>参数，在外界调用<code>挂起函数</code>时隐式入参。 </p>
<h2 id="协程的原理"><a href="#协程的原理" class="headerlink" title="协程的原理"></a>协程的原理</h2><p>上述的基础概念已基本涵盖协程的整套执行流程，后面会在<a href="/2020/09/04/Kotlin协程原理/" title="Kotlin协程原理">Kotlin协程原理</a> 串联整体流程。</p>
<h2 id="协程在Android中的应用"><a href="#协程在Android中的应用" class="headerlink" title="协程在Android中的应用"></a>协程在Android中的应用</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="CPU上下文"><a href="#CPU上下文" class="headerlink" title="CPU上下文"></a>CPU上下文</h3><blockquote>
<p><strong>CPU寄存器和程序计数器</strong>，这两者都是CPU在运行任务前，都必须的依赖环境。</p>
<p><code>CPU寄存器</code>：CPU内置的容量小、但速度极快的内存</p>
<p><code>程序计数器</code>：存储CPU正在执行的指令位置，或即将执行的下一条指令位置</p>
</blockquote>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><blockquote>
<p>把前一个任务的<code>CPU上下文</code>保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后在跳转到程序计数器所指的新位置，运行新任务。</p>
<p>被保存的上下文会存储到<em>系统内核</em>中，在任务被重新调度时重新加载。</p>
</blockquote>
<h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><blockquote>
<p>从一个进程切换到另一个进程运行。</p>
</blockquote>
<p>进程的运行空间分为：</p>
<ul>
<li><code>内核空间</code>：具有最高权限，可以访问进程间的所有资源。（进程运行其中称为<strong>内核态</strong>。）</li>
<li><code>用户空间</code>：只能访问受限资源，不能直接访问内存等硬件设备，必须通过<strong>系统调用</strong>陷入到内核中，才能访问所有资源。（进程运行其中为<strong>用户态</strong>。）</li>
</ul>
<p><code>系统调用(system-call)</code>：进程从<code>用户态</code>到<code>内核态</code>的转变，需要通过<code>系统调用</code>实现。过程如下：</p>
<ul>
<li>保存CPU寄存器里原来用户态的指令位</li>
<li>为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置</li>
<li>跳转到内核态执行内核任务</li>
<li>系统调用结束后，CPU寄存器需要回复到原来保存的用户态，然后再切换到用户空间，继续运行线程。</li>
</ul>
<p><code>系统调用</code>过程中，总共发生了<code>两次CPU上下文切换</code>(用户态-&gt;内核态-&gt;用户态)。</p>
<h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><blockquote>
<p>从一个线程切换到另一个线程执行。</p>
</blockquote>
<p><strong>线程时调度的基本单位，进程这是资源拥有的基本单位。</strong>内核中的任务调度，实际调度对象为线程；进程只是给线程提供了<code>虚拟内存、全局变量</code>等资源。</p>
<p>线程发生上下文切换时，还需要保存线程所拥有的私有数据，例如栈、寄存器等。</p>
<p>线程上下文切换场景：</p>
<ul>
<li>切换的线程不处于同一进程中，因为资源不共享，执行的流程同<code>进程上下文切换</code>。</li>
<li>切换的线程处于同一进程中，资源是共享的，公共资源就不需要进行切换，只要切换线程的私有数据。</li>
</ul>
<h4 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h4><blockquote>
<p>中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。打断进程时，只需要保留当前进程的运行状态，中断执行结束后，继续从愿状态运行。</p>
</blockquote>
<p>中断上下文切换不涉及进程的用户态，在中断触发时，只需要保存内核态中断服务程序所必需的状态。例如<code>CPU寄存器、内核堆栈、硬件中断参数等</code>。</p>
<p><strong>中断上下文切换比进程上下文切换拥有更高的优先级，两者不会在同一CPU上同时发生。</strong></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/6844903858368413704" target="_blank" rel="noopener">viewModelScope简易介绍</a></p>
<p><a href="https://blog.csdn.net/weixin_42063726/article/details/106198068" target="_blank" rel="noopener">Kotlin-调度器介绍</a></p>
<p><a href="https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html" target="_blank" rel="noopener">协程官方文档</a></p>
<p><a href="http://zhoukaibo.com/2019/03/16/java-spi-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/" target="_blank" rel="noopener">SPI机制</a></p>
<p><a href="https://github.com/Kotlin-zh/KEEP/blob/master/proposals/coroutines.md" target="_blank" rel="noopener">Kotlin协程设计思路</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652055127&amp;idx=2&amp;sn=283de8250bfc8a7bd8287a7aadad1339&amp;chksm=808c8612b7fb0f047702c2101d27f4de42363ae5dd462be977ec897c7ae6a36e57b94675750a&amp;scene=178#rd" target="_blank" rel="noopener">揭秘suspend修饰符</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Kotlin/">Kotlin</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/04/17/AOP学习笔记-APT/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">AOP学习笔记-APT</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/04/01/Flutter学习大纲/">
                        <span class="hidden-mobile">Flutter学习大纲</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>







  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
