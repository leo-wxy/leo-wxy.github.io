

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#11527b">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>Kotlin-协程 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/atom-one-light.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.7","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Kotlin-协程">
              
                Kotlin-协程
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-04-12 15:11" pubdate>
        2020年4月12日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      143
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Kotlin-协程</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>协程本质上是<strong>轻量级的线程</strong>。</p>
</blockquote>
<h2 id="协程的概念"><a href="#协程的概念" class="headerlink" title="协程的概念"></a>协程的概念</h2><p>协程是一种<strong>非抢占式或协作式</strong>的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。避免在异步编程中使用大量的回调，同时相比于传统的多线程技术，更容易<em>提升系统的高并发处理能力。</em></p>
<p>线程和协程属于<strong>一对多</strong>关系，一个线程上允许存在多个协程。</p>
<blockquote>
<p>线程大多数的实现是映射到内核的线程，当线程中的代码逻辑在线程抢到CPU的时间片才可以执行，否则只能等待。而协程之所以<strong>轻量级</strong>，协程并不会映射到内核线程，调度可以在用户态搞定，任务之间调度并非抢占式。</p>
</blockquote>
<h2 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>  //引入协程库<br>      implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9'<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">GlobalScope.launch(Dispatchers.Main + ,start = CoroutineStart.DEFAULT)&#123;<br>  // TODO<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">fun</span> CoroutineScope.launch(<br>    context: CoroutineContext = EmptyCoroutineContext,//协程作用域<br>    start: CoroutineStart = CoroutineStart.DEFAULT,//协程启动方式<br>    block: suspend CoroutineScope.() -&gt; <span class="hljs-built_in">Unit</span> //协程内需要执行的操作<br>): Job &#123;...&#125;<br></code></pre></td></tr></table></figure>
<h3 id="协程作用域-CoroutineScope"><a href="#协程作用域-CoroutineScope" class="headerlink" title="协程作用域(CoroutineScope)"></a>协程作用域(<code>CoroutineScope</code>)</h3><blockquote>
<p>在Android环境中，通常每个界面(Activity、Fragment)启动的协程(<code>Coroutine</code>)只在该界面有效，当退出界面时，协程执行的任务也没有意义。所以在设计<code>Coroutine</code>时会要求在<code>Scope</code>中执行，当<code>CoroutineScope</code>取消时，对应的<code>Coroutine</code>也需要自动取消。</p>
</blockquote>
<h4 id="阻塞协程作用域-runBlocking"><a href="#阻塞协程作用域-runBlocking" class="headerlink" title="阻塞协程作用域(runBlocking)"></a>阻塞协程作用域(<code>runBlocking</code>)</h4><blockquote>
<p>调用<code>runBlocking</code>的线程会被阻塞直到内部协程任务执行完毕</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">runBlocking &#123;<br>    launch &#123;<br>        println("Hello $&#123;System.currentTimeMillis()&#125;")<br>        delay(1000)<br>    &#125;<br>&#125;<br>println("world $&#123;System.currentTimeMillis()&#125;")<br><br>输出结果：<br>Hello 1597924663541<br>world 1597924664551<br>结果相差接近1s<br></code></pre></td></tr></table></figure>
<p><strong>多用于单元测试代码中，不会用于实际的业务开发。就因为会堵塞当前线程</strong></p>
<h4 id="全局协程作用域-GlobalScope"><a href="#全局协程作用域-GlobalScope" class="headerlink" title="全局协程作用域(GlobalScope)"></a>全局协程作用域(<code>GlobalScope</code>)</h4><blockquote>
<p>作用于整个应用的生命周期中，并且无法被取消，在界面中使用，例如<code>Activity</code>中使用，就会导致内存泄露</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">GlobalScope.launch(Dispatchers.Unconfined) &#123;<br>    println("Hello $&#123;System.currentTimeMillis()&#125;")<br>    delay(1000)<br>&#125;<br>println("world $&#123;System.currentTimeMillis()&#125;")<br><br>输出结果：<br>Hello 1597924937030<br>world 1597924937038<br>结果接近<br></code></pre></td></tr></table></figure>
<p>通过<code>GlobalScope</code>创建的协程将不会有<code>父协程</code>，也被称为<code>根协程</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> GlobalScope : CoroutineScope &#123;<br>    /**<br>     * Returns [EmptyCoroutineContext].<br>     */<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext<br>        <span class="hljs-keyword">get</span>() = EmptyCoroutineContext //返回一个上下文但并没有进行上下文关联，导致无法被取消<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="自定义协程作用域-CoroutineScope"><a href="#自定义协程作用域-CoroutineScope" class="headerlink" title="自定义协程作用域(: CoroutineScope)"></a>自定义协程作用域(<code>: CoroutineScope</code>)</h4><blockquote>
<p>自定义协程的作用域，就不会造成作用域过大导致的内存泄漏</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job()//协程上下文<br><span class="hljs-keyword">val</span> coroutineScope = CoroutineScope(coroutineContext)//自定义作用域<br><br><span class="hljs-keyword">fun</span> main(args:Array&lt;String&gt;)&#123;<br>  coroutineScope.launch&#123;<br>      println("Hello $&#123;System.currentTimeMillis()&#125;")<br>      delay(1000)<br>  &#125;<br>  println("world $&#123;System.currentTimeMillis()&#125;")<br>  //主动控制作用域的取消<br>  coroutineScope.cancel()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>自定义协程作用域最关键的就是<strong>定义CoroutineContext属性</strong>。</p>
<p>自定义<code>CoroutineContext</code>主要由两部分构成：<code>dispatcher</code>、<code>job</code>。</p>
<p><code>dispatcher</code>：用于指定协程默认使用的调度器(<em>后续会介绍</em>)</p>
<p><code>job</code>：可在任意时刻取消协程(<em>后续会介绍</em>)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job()<br></code></pre></td></tr></table></figure>
<p>用<code>+</code>连接多个上下文，其中如果出现多个同类型的上下文，后面新添加的会成为使用的上下文，例如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Unconfined + Job() + Dispatchers.IO<br>print(coroutineContext.toString())<br><br>输出结果：<br>[JobImpl&#123;Active&#125;@300ffa5d, Dispatchers.IO] //采用了新添加的调度器<br></code></pre></td></tr></table></figure>
<h4 id="系统提供协程作用域"><a href="#系统提供协程作用域" class="headerlink" title="系统提供协程作用域"></a>系统提供协程作用域</h4><h5 id="MainScope"><a href="#MainScope" class="headerlink" title="MainScope"></a>MainScope</h5><blockquote>
<p>为了方便开发使用，kotlin标准库中定义了<code>MainScope()</code>可以快速生成<code>CoroutineScope</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//MainScope实现源码<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">fun</span> MainScope(): CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)<br><br>使用方式：<br><span class="hljs-keyword">val</span> mainScope  = MainScope()<br><br><span class="hljs-keyword">fun</span> test()&#123;<br>  mainScope.launch&#123;<br>    //TODO<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">fun</span> onDestroy()&#123;<br>  mainScope.cancel()<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="viewModelScope"><a href="#viewModelScope" class="headerlink" title="viewModelScope"></a>viewModelScope</h5><blockquote>
<p>在AndroidX中 引入了<code>viewModelScope</code>，当ViewModel销毁时会自动取消协程任务。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//引用viewModelScope<br>implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.1.0-beta01:" //也可以引用更高版本<br><br><span class="hljs-keyword">class</span> MyViewModel:ViewModel()&#123;<br>  <span class="hljs-keyword">fun</span> test()&#123;<br>    viewModelScope.launch&#123;<br>      //TODO <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>简单源码解析：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//lifecycle/lifecycle-viewmodel-ktx/src/main/java/androidx/lifecycle/ViewModel.kt<br><br><span class="hljs-keyword">private</span> const <span class="hljs-keyword">val</span> JOB_KEY = "androidx.lifecycle.ViewModelCoroutineScope.JOB_KEY"<br><br>/**<br> * [CoroutineScope] tied to this [ViewModel].<br> * This scope will be canceled <span class="hljs-keyword">when</span> ViewModel will be cleared, i.e [ViewModel.onCleared] <span class="hljs-keyword">is</span> called<br> *<br> * This scope <span class="hljs-keyword">is</span> bound to<br> * [Dispatchers.Main.immediate][kotlinx.coroutines.MainCoroutineDispatcher.immediate]<br> */<br>//使用拓展方法<br><span class="hljs-keyword">val</span> ViewModel.viewModelScope: CoroutineScope<br>        <span class="hljs-keyword">get</span>() &#123;<br>            <span class="hljs-keyword">val</span> scope: CoroutineScope? = this.getTag(JOB_KEY)<br>          //缓存中读取 对应scope<br>            <span class="hljs-keyword">if</span> (scope != <span class="hljs-literal">null</span>) &#123;<br>                return scope<br>            &#125;<br>           //对应了ViewModel内部的实现代码<br>            return setTagIfAbsent(JOB_KEY,<br>                CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate))<br>        &#125;<br>//自动取消 coroutineScope<br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> CloseableCoroutineScope(context: CoroutineContext) : Closeable, CoroutineScope &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext = context<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> close() &#123;<br>        coroutineContext.cancel()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>viewModelScope</code>默认调度器为<code>Dispatchers.Main</code>，因为<code>ViewModel</code>与UI交互较为频繁，减少线程间的切换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//lifecycle/lifecycle-viewmodel/src/main/java/androidx/lifecycle/ViewModel.java<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; mBagOfTags = new HashMap&lt;&gt;();<br>//同步存值<br>    &lt;T&gt; T setTagIfAbsent(String key, T newValue) &#123;<br>        T previous;<br>        synchronized (mBagOfTags) &#123;<br>            previous = (T) mBagOfTags.<span class="hljs-keyword">get</span>(key);<br>            <span class="hljs-keyword">if</span> (previous == <span class="hljs-literal">null</span>) &#123;<br>                mBagOfTags.put(key, newValue);<br>            &#125;<br>        &#125;<br>        T result = previous == <span class="hljs-literal">null</span> ? newValue : previous;<br>        <span class="hljs-keyword">if</span> (mCleared) &#123;<br>            closeWithRuntimeException(result);<br>        &#125;<br>        return result;<br>    &#125;<br><br> @MainThread<br>//销毁ViewModel<br>    <span class="hljs-keyword">final</span> void clear() &#123;<br>        mCleared = <span class="hljs-literal">true</span>;<br>        // Since clear() <span class="hljs-keyword">is</span> <span class="hljs-keyword">final</span>, this method <span class="hljs-keyword">is</span> still called on mock objects<br>        // and <span class="hljs-keyword">in</span> those cases, mBagOfTags <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>. It'll always be empty though<br>        // because setTagIfAbsent and getTag are not <span class="hljs-keyword">final</span> so we can skip<br>        // clearing it<br>        <span class="hljs-keyword">if</span> (mBagOfTags != <span class="hljs-literal">null</span>) &#123;<br>            synchronized (mBagOfTags) &#123;<br>              //读取缓存好的 viewModelScope对象<br>                <span class="hljs-keyword">for</span> (Object value : mBagOfTags.values()) &#123;<br>                    // see comment <span class="hljs-keyword">for</span> the similar call <span class="hljs-keyword">in</span> setTagIfAbsent<br>                    closeWithRuntimeException(value);<br>                &#125;<br>            &#125;<br>        &#125;<br>        onCleared();<br>    &#125;<br><br>//清理缓存对象 这也是CloseableCoroutineScope存在的原因<br> <span class="hljs-keyword">private</span> static void closeWithRuntimeException(Object obj) &#123;<br>        <span class="hljs-keyword">if</span> (obj instanceof Closeable) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ((Closeable) obj).close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">throw</span> new RuntimeException(e);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="协程启动模式-CoroutineStart"><a href="#协程启动模式-CoroutineStart" class="headerlink" title="协程启动模式(CoroutineStart)"></a>协程启动模式(<code>CoroutineStart</code>)</h3><blockquote>
<p>控制协程创建后的调用规则</p>
</blockquote>
<h4 id="CoroutineStart-DEFAULT"><a href="#CoroutineStart-DEFAULT" class="headerlink" title="CoroutineStart.DEFAULT"></a>CoroutineStart.DEFAULT</h4><blockquote>
<p>协程的默认启动模式，为<code>饿汉式调用</code>，调用协程后，会立即进入调度状态(等待调度器初始化完毕)。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test1()&#123;<br>    print(1)<br>    <span class="hljs-keyword">val</span> job = GlobalScope.launch &#123;<br>        print(2)<br>        delay(1000)<br>    &#125;<br>    print(3)<br>    job.join()<br>    print(4)<br>&#125;<br><br>输出结果：<br>123(delay 1000ms)4<br></code></pre></td></tr></table></figure>
<p><strong>协程创建后，立即开始调度，在调度前如果协程被取消，将直接进入取消响应的状态。</strong></p>
<h4 id="CoroutineStart-LAZY"><a href="#CoroutineStart-LAZY" class="headerlink" title="CoroutineStart.LAZY"></a>CoroutineStart.LAZY</h4><blockquote>
<p><code>懒汉式调用</code>，<code>launch</code>后并不会有任何调度行为，协程也不会执行，直到调用执行时，协程才会执行。</p>
<p>只有主动调用<code>start、join、或await</code>后协程才会开始调度。</p>
<p><code>job.start()</code>：启动协程</p>
<p><code>job.join()</code>：启动协程并等待任务执行结束</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test1()&#123;<br>    print(1)<br>    <span class="hljs-keyword">val</span> job = coroutineScope.launch(start = CoroutineStart.LAZY) &#123;<br>        print(2)<br>        delay(1000)<br>    &#125;<br><br>    print(3)<br>    job.start()<br>  //job.join()<br>    print(4)<br>&#125;<br><br>输出结果：<br>job.start() 1324 没有延迟输出4<br>job.join() 1324 延迟1s后输出4<br></code></pre></td></tr></table></figure>
<p><strong>协程创建后，只有被需要使用时才会执行，例如调用<code>start、join</code>才会开始调度执行。</strong></p>
<h4 id="CoroutineStart-ATOMIC-实验版"><a href="#CoroutineStart-ATOMIC-实验版" class="headerlink" title="CoroutineStart.ATOMIC(实验版)"></a>CoroutineStart.ATOMIC(实验版)</h4><blockquote>
<p>协程创建后，立即开始调度，在<strong>协程执行到第一个挂起点之前不会响应<code>cancel</code>操作</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test1()&#123;<br>    print(1)<br>  //<span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.DEFAULT) &#123;<br>    <span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;<br>        print(2)<br>        delay(1000)<br>    &#125;<br>    job.cancel()<br>    print(3)<br>    print(4)<br>&#125;<br><br>输出结果：<br>DEFAULT：134 由于在准备执行时触发了cancel，导致2无法输出<br>ATOMIC：1324 ATOMIC在执行前不会响应到cancel，所以2正常输出<br></code></pre></td></tr></table></figure>
<p><strong>ATOMIC将<code>调度</code>与<code>执行</code>合二为一，是一个原子化操作。</strong></p>
<p>升级版示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">    print(1)<br>    <span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.ATOMIC) &#123;<br>        print(2)<br>        delay(1000)<br>        print(5)<br>    &#125;<br>    job.cancel()<br>    print(3)<br>    print(4)<br><br>输出结果：<br>1342 <br>不输出5的原因是：`ATOMIC`在第一个挂起点时忽略`cancel`，后续在执行挂起时,`cancel`	功能生效，导致后续无法输出，这里`delay`就是下一次的挂起操作。<br></code></pre></td></tr></table></figure>
<h4 id="CoroutineStart-UNDISPATCHED-实验版"><a href="#CoroutineStart-UNDISPATCHED-实验版" class="headerlink" title="CoroutineStart.UNDISPATCHED(实验版)"></a>CoroutineStart.UNDISPATCHED(实验版)</h4><blockquote>
<p>协程创建后立即在当前函数调用栈中执行，直到第一个挂起点？</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test1()&#123;<br>    println("$&#123;Thread.currentThread()&#125; 1")<br>    <span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) &#123;<br> // <span class="hljs-keyword">val</span> job = GlobalScope.launch(start = CoroutineStart.DEFAULT) &#123;<br>        println("$&#123;Thread.currentThread()&#125; 2")<br>        delay(1000)<br>        println("$&#123;Thread.currentThread()&#125; 5")<br>    &#125;<br><br>    println("$&#123;Thread.currentThread()&#125; 3")<br>    job.join()<br>    println("$&#123;Thread.currentThread()&#125; 4")<br>&#125;<br><br>输出结果：<br>DEFAULT<br>Thread[main,5,main] 1<br>Thread[main,5,main] 3<br>Thread[DefaultDispatcher-worker-1,5,main] 2<br>Thread[DefaultDispatcher-worker-1,5,main] 5<br>Thread[DefaultDispatcher-worker-1,5,main] 4<br><br>UNDISPATCHED<br>Thread[main,5,main] 1<br>Thread[main,5,main] 2<br>Thread[main,5,main] 3<br>Thread[DefaultDispatcher-worker-1,5,main] 5<br>Thread[DefaultDispatcher-worker-1,5,main] 4<br></code></pre></td></tr></table></figure>
<p>比较<code>DEFAULT</code>结果可见，在<code>UNDISPATCHED</code>条件下，未达到挂起点时，代码会执行在调用函数栈中，例如<code>UNDISPATCHED</code>的<code>print(2)</code>就输出在<code>Main</code>线程下。</p>
<table>
<thead>
<tr>
<th>CoroutineStart配置</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEFAULT</td>
<td>协程创建后立即执行</td>
</tr>
<tr>
<td>LAZY</td>
<td>协程创建后，等待需要调用时才会执行协程<br><code>start、join、await</code>等代码调用</td>
</tr>
<tr>
<td>ATOMIC</td>
<td>功能类似<code>DEFAULT</code>，但是在执行协程前无法被取消，直到执行到了第一个<code>suspend函数</code>,例如<code>delay()</code>就是个<code>suspend</code>函数</td>
</tr>
<tr>
<td>UNDISPATCHED</td>
<td>立即在当前线程执行协程，直到执行到了第一个<code>suspend函数</code></td>
</tr>
</tbody>
</table>
<h3 id="协程上下文-CoroutineContext"><a href="#协程上下文-CoroutineContext" class="headerlink" title="*协程上下文(CoroutineContext)"></a>*协程上下文(<code>CoroutineContext</code>)</h3><blockquote>
<p>本体是一个数据结构，可以看做是<code>map</code>，内部实现为<code>单链表</code></p>
<p><code>上下文</code>记录了协程所需信息：</p>
<ul>
<li>协程调度器：Dispatchers</li>
<li>执行任务：Job</li>
<li>协程名字：CoroutineName</li>
<li>协程异常处理：CoroutineExceptionHandler</li>
</ul>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> coroutineContext : CoroutineContext = Dispatchers.Main + Job() + CoroutineName("name")//协程上下文<br></code></pre></td></tr></table></figure>
<h4 id="自定义上下文"><a href="#自定义上下文" class="headerlink" title="自定义上下文"></a>自定义上下文</h4><p>Kotlin提供了<code>AbstractCoroutineContextElement</code>可以快速实现自定义上下文，例如<code>CoroutineName</code>就是依赖这个实现的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> CoroutineName(<br>    /**<br>     * User-defined coroutine name.<br>     */<br>    <span class="hljs-keyword">val</span> name: String<br>) : AbstractCoroutineContextElement(CoroutineName) &#123;<br>    /**<br>     * Key <span class="hljs-keyword">for</span> [CoroutineName] instance <span class="hljs-keyword">in</span> the coroutine context.<br>     */<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> Key : CoroutineContext.Key&lt;CoroutineName&gt;<br><br>    /**<br>     * Returns a string representation of the <span class="hljs-keyword">object</span>.<br>     */<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> toString(): String = "CoroutineName($name)"<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="协程上下文的父子关系"><a href="#协程上下文的父子关系" class="headerlink" title="协程上下文的父子关系"></a>协程上下文的父子关系</h4><blockquote>
<p>每个协程都会有一个父级对象，协程的父级对象的<code>上下文</code>也会和父级协程的<code>上下文</code>不一致。</p>
</blockquote>
<p>关系遵循如下公式</p>
<p><strong>父级上下文 = 默认值 + 继承的<code>CoroutineContext</code> + 参数</strong></p>
<p><code>默认值</code>：一些元素包含的默认值，例如默认<code>Dispatcher</code>就是<code>Dispatchers.Default</code></p>
<p><code>继承的CoroutineContext</code>：父协程的<code>CoroutineContenxt</code></p>
<p><code>参数</code>：后续子协程配置的参数，如上文所示组成部分，新添加的参数会覆盖前面的对应配置。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> testCoroutineContextExtend() &#123;<br>    <span class="hljs-keyword">val</span> parentContext: CoroutineContext = Dispatchers.Default + Job() + CoroutineName("parent")<br>    <span class="hljs-keyword">val</span> parentScope = CoroutineScope(parentContext)<br>    parentScope.launch &#123;<br>        log(currentCoroutineContext().toString()) //打印当前上下文内容<br>        <span class="hljs-keyword">val</span> childContext = parentContext + Dispatchers.IO + CoroutineName("child")<br>        <span class="hljs-keyword">val</span> job =  launch(childContext) &#123;<br>            log(currentCoroutineContext().toString())<br>        &#125;<br>    &#125;<br>&#125;<br><br>输出结果：<br>19:29:57:497 [DefaultDispatcher-worker-1] [CoroutineName(parent), StandaloneCoroutine&#123;Active&#125;@4815c1f8, Dispatchers.Default]<br>19:29:57:500 [DefaultDispatcher-worker-2] [CoroutineName(child), StandaloneCoroutine&#123;Active&#125;@2ca2b65d, Dispatchers.IO]<br></code></pre></td></tr></table></figure>
<p>根据上述输出结果可得到<strong>后续的同类内容会覆盖前面的元素</strong>。</p>
<p><code>CoroutineContext</code>使用<strong>+</strong>进行元素的合并，加号右侧的元素会覆盖左侧的元素，最后得到一个新的<code>CoroutineContext</code>元素。</p>
<p>//TODO 后续会补充如何调用自定义上下文</p>
<h3 id="协程拦截器-ContinuationInterceptor"><a href="#协程拦截器-ContinuationInterceptor" class="headerlink" title="协程拦截器(ContinuationInterceptor)"></a>协程拦截器(<code>ContinuationInterceptor</code>)</h3><blockquote>
<p>协程拦截器也是<code>CoroutineContext</code>的一个实现，可以控制协程的执行流程，功能类似于<code>Okhttp的拦截器</code>。</p>
<p><code>协程拦截器</code>永远置于<code>CoroutineContext</code>组合的最后一位，保证不会被其他实现所覆盖。</p>
<p><strong>协程拦截器最多只能存在1个。</strong></p>
<!--如何配置多个拦截器？-->
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> CustomInterceptor : ContinuationInterceptor &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key = ContinuationInterceptor<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt;  = CustomContinuation&lt;T&gt;(continuation)<br><br>    <span class="hljs-keyword">class</span> CustomContinuation&lt;T&gt;(<span class="hljs-keyword">val</span> continuation: Continuation&lt;T&gt;) : Continuation&lt;T&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> context: CoroutineContext = continuation.context<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> resumeWith(result: Result&lt;T&gt;) &#123;<br>            println("result = $result")<br>            //对result进行多次处理，也可以联动成多个拦截器的处理<br>            //此处hook 返回值可对其进行修改或者拓展<br>            continuation.resumeWith(result)<br>        &#125;<br>    &#125;<br>&#125;<br><br>GlobalScope.launch(CustomInterceptor())&#123;<br>  //TODO ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="协程调度器-CoroutineDispatcher"><a href="#协程调度器-CoroutineDispatcher" class="headerlink" title="协程调度器(CoroutineDispatcher)"></a>协程调度器(<code>CoroutineDispatcher</code>)</h3><blockquote>
<p>属于<code>CoroutineContext</code>的子类，同时实现了<code>ContinuationInterceptor</code>接口，通过拦截功能实现协程的调度。</p>
<p>调度器的主要目的<strong>切换执行线程</strong>。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> CoroutineDispatcher :<br>    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123;<br>  <br>      ... <br>      //此处切换任务执行线程<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">fun</span> dispatch(context: CoroutineContext, block: Runnable)<br><br> &#125;<br></code></pre></td></tr></table></figure>
<p>先了解源码中提供的调度器</p>
<h4 id="Dispatchers-Default"><a href="#Dispatchers-Default" class="headerlink" title="Dispatchers.Default"></a>Dispatchers.Default</h4><blockquote>
<p>默认协程调度器，适合处理后台计算，为<code>CPU密集型</code>任务调度器</p>
</blockquote>
<!--ForkJoinPool-->
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> actual <span class="hljs-keyword">object</span> Dispatchers &#123;<br>      @JvmStatic<br>    <span class="hljs-keyword">public</span> actual <span class="hljs-keyword">val</span> Default: CoroutineDispatcher = createDefaultDispatcher()<br>  ...<br>&#125;<br><br><span class="hljs-keyword">internal</span> actual <span class="hljs-keyword">fun</span> createDefaultDispatcher(): CoroutineDispatcher =<br>    <span class="hljs-keyword">if</span> (useCoroutinesScheduler) DefaultScheduler <span class="hljs-keyword">else</span> CommonPool<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> DefaultScheduler : ExperimentalCoroutineDispatcher() &#123;<br>    <span class="hljs-keyword">val</span> IO: CoroutineDispatcher = LimitingDispatcher(<br>        this,<br>        systemProp(IO_PARALLELISM_PROPERTY_NAME, 64.coerceAtLeast(AVAILABLE_PROCESSORS)),<br>        "Dispatchers.IO",<br>        TASK_PROBABLY_BLOCKING<br>    )<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> close() &#123;<br>        <span class="hljs-keyword">throw</span> UnsupportedOperationException("$DEFAULT_DISPATCHER_NAME cannot be closed")<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> toString(): String = DEFAULT_DISPATCHER_NAME<br><br>    @InternalCoroutinesApi<br>    @Suppress("UNUSED")<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">fun</span> toDebugString(): String = <span class="hljs-keyword">super</span>.toString()<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Dispatchers-IO（仅JVM可用）"><a href="#Dispatchers-IO（仅JVM可用）" class="headerlink" title="Dispatchers.IO（仅JVM可用）"></a>Dispatchers.IO（仅JVM可用）</h4><blockquote>
<p>IO调度器，适合执行IO相关操作，例如读写文件，为<code>IO密集型</code>任务调度器</p>
</blockquote>
<p>IO仅在JVM上有定义，基于<code>Default</code>调度器，并实现了独立的队列和限制，因此<code>Default与IO</code>切换不会触发线程切换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test2()&#123;<br>    log("1")<br>    <span class="hljs-keyword">val</span> job = GlobalScope.async(Dispatchers.IO) &#123;<br>        log(2)<br>        withContext(Dispatchers.Default)&#123;<br>            log(3)<br>            withContext(Dispatchers.IO)&#123;<br>                log(4)<br>                withContext(Dispatchers.Default)&#123;<br>                    log(5)<br>                    123<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    log(job.await())<br>&#125;<br><br>输出结果：<br>13:26:04:564 [main] 1<br>13:26:04:581 [DefaultDispatcher-worker-1] 2<br>13:26:04:586 [DefaultDispatcher-worker-1] 3<br>13:26:04:586 [DefaultDispatcher-worker-1] 4<br>13:26:04:587 [DefaultDispatcher-worker-1] 5 //切换过程中一直在同一线程<br>13:26:04:588 [DefaultDispatcher-worker-2] 123<br></code></pre></td></tr></table></figure>
<p><code>Default</code>与<code>IO</code>调度器对任务的执行做了优化，可以保证线程执行效率较高。</p>
<p>主要原理为：Kotlin实现了<code>CoroutineScheduler</code>，支持抢占任务。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> CoroutineScheduler(<br>    @JvmField <span class="hljs-keyword">val</span> corePoolSize: <span class="hljs-built_in">Int</span>,<br>    @JvmField <span class="hljs-keyword">val</span> maxPoolSize: <span class="hljs-built_in">Int</span>,<br>    @JvmField <span class="hljs-keyword">val</span> idleWorkerKeepAliveNs: <span class="hljs-built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,<br>    @JvmField <span class="hljs-keyword">val</span> schedulerName: String = DEFAULT_SCHEDULER_NAME<br>) : Executor, Closeable &#123;<br>  ...<br>  //CPU密集任务队列<br>    @JvmField<br>    <span class="hljs-keyword">val</span> globalCpuQueue = GlobalQueue()<br>  //IO密集任务队列<br>    @JvmField<br>    <span class="hljs-keyword">val</span> globalBlockingQueue = GlobalQueue()<br>  <br>  ...<br>      <span class="hljs-keyword">fun</span> dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span>) &#123;<br>        trackTask() // this <span class="hljs-keyword">is</span> needed <span class="hljs-keyword">for</span> virtual time support<br>        <span class="hljs-keyword">val</span> task = createTask(block, taskContext)<br>        // <span class="hljs-keyword">try</span> to submit the task to the local queue and act depending on the result<br>        <span class="hljs-keyword">val</span> currentWorker = currentWorker()<br>        //任务优先插入本地队列中执行<br>        <span class="hljs-keyword">val</span> notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)<br>        //本地队列已满，就将任务插入到全局队列中<br>        <span class="hljs-keyword">if</span> (notAdded != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!addToGlobalQueue(notAdded)) &#123;<br>                // Global queue <span class="hljs-keyword">is</span> closed <span class="hljs-keyword">in</span> the last step of close/shutdown -- no more tasks should be accepted<br>                <span class="hljs-keyword">throw</span> RejectedExecutionException("$schedulerName was terminated")<br>            &#125;<br>        &#125;<br>      ...<br>    &#125;<br>  //执行的任务<br>   <span class="hljs-keyword">internal</span> inner <span class="hljs-keyword">class</span> Worker <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>() : Thread() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> run() = runWorker()<br>     //执行任务<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> runWorker() &#123;<br>            <span class="hljs-keyword">var</span> rescanned = <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">while</span> (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) &#123;<br>              //从队列中找到任务<br>                <span class="hljs-keyword">val</span> task = findTask(mayHaveLocalTasks)<br>              ...<br>            &#125;<br>   &#125;<br>    //找到本地队列任务<br>    <span class="hljs-keyword">fun</span> findTask(scanLocalQueue: <span class="hljs-built_in">Boolean</span>): Task? &#123;<br>            //获取CPU控制权<br>            <span class="hljs-keyword">if</span> (tryAcquireCpuPermit()) return findAnyTask(scanLocalQueue)<br>            // If we can't acquire a CPU permit -- attempt to find blocking task<br>            <span class="hljs-keyword">val</span> task = <span class="hljs-keyword">if</span> (scanLocalQueue) &#123;<br>                localQueue.poll() ?: globalBlockingQueue.removeFirstOrNull()<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                globalBlockingQueue.removeFirstOrNull()<br>            &#125;<br>           //从其他队列获取任务执行<br>            return task ?: trySteal(blockingOnly = <span class="hljs-literal">true</span>)<br>        &#125;<br><br>     //从其他队列获取任务<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> trySteal(blockingOnly: <span class="hljs-built_in">Boolean</span>): Task? &#123;<br>            assert &#123; localQueue.size == 0 &#125;<br>            <span class="hljs-keyword">val</span> created = createdWorkers<br>            // 0 to await an initialization and 1 to avoid excess stealing on single-core machines<br>            <span class="hljs-keyword">if</span> (created &lt; 2) &#123;<br>                return <span class="hljs-literal">null</span><br>            &#125;<br><br>            <span class="hljs-keyword">var</span> currentIndex = nextInt(created)<br>            <span class="hljs-keyword">var</span> minDelay = <span class="hljs-built_in">Long</span>.MAX_VALUE<br>            repeat(created) &#123;<br>                ++currentIndex<br>                <span class="hljs-keyword">if</span> (currentIndex &gt; created) currentIndex = 1<br>                <span class="hljs-keyword">val</span> worker = workers[currentIndex]<br>                <span class="hljs-keyword">if</span> (worker !== <span class="hljs-literal">null</span> &amp;&amp; worker !== this) &#123;<br>                    assert &#123; localQueue.size == 0 &#125;<br>                  //从其他工作线程中获取任务来执行<br>                    <span class="hljs-keyword">val</span> stealResult = <span class="hljs-keyword">if</span> (blockingOnly) &#123;<br>                        localQueue.tryStealBlockingFrom(victim = worker.localQueue)<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        localQueue.tryStealFrom(victim = worker.localQueue)<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (stealResult == TASK_STOLEN) &#123;<br>                        return localQueue.poll()<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stealResult &gt; 0) &#123;<br>                        minDelay = min(minDelay, stealResult)<br>                    &#125;<br>                &#125;<br>            &#125;<br>            minDelayUntilStealableTaskNs = <span class="hljs-keyword">if</span> (minDelay != <span class="hljs-built_in">Long</span>.MAX_VALUE) minDelay <span class="hljs-keyword">else</span> 0<br>            return <span class="hljs-literal">null</span><br>        &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>总体设计分为三步：</p>
<ol>
<li>优先任务放在本地线程中，放在<code>Worker</code>中的<code>LocalQueue</code>中</li>
<li>使用双重队列<code>GlobalCpuQueue(CPU密集任务队列)</code>、<code>GlobalBlockingQueue(IO密集任务队列)</code>，<code>LocalQueue</code>满后，任务会放到对应全局队列中</li>
<li>当<code>LocalQueue</code>和<code>GlobalQueue</code>中的任务执行完时，会从其他正在执行任务的<code>Worker</code>中获取他的<code>LocalQueue</code>的任务放到自己的<code>LocalQueue</code>中执行。</li>
</ol>
<p>这三步可以保证<strong>线程资源的充分利用，减少了多线程的切换开销，提高了使用效率</strong>。实现参考的是<code>ForkJoinPool</code>。</p>
<h4 id="Dispatchers-Main"><a href="#Dispatchers-Main" class="headerlink" title="Dispatchers.Main"></a>Dispatchers.Main</h4><blockquote>
<p>UI调度器，根据执行平台不同会初始化为对应平台UI线程的调度器</p>
<p>在Android中，就会通过<code>Handler</code>调度到<code>UI线程</code>执行任务</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//加载各个平台下定义的`MainDispatcherFactory`<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> loadMainDispatcher(): MainCoroutineDispatcher &#123;<br>        return <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> factories = <span class="hljs-keyword">if</span> (FAST_SERVICE_LOADER_ENABLED) &#123;<br>                FastServiceLoader.loadMainDispatcherFactory()<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                // We are explicitly using the<br>                // `ServiceLoader.load(MyClass::<span class="hljs-keyword">class</span>.java, MyClass::<span class="hljs-keyword">class</span>.java.classLoader).iterator()`<br>                // form of the ServiceLoader call to enable R8 optimization <span class="hljs-keyword">when</span> compiled on Android.<br>                ServiceLoader.load(<br>                        MainDispatcherFactory::<span class="hljs-keyword">class</span>.java,<br>                        MainDispatcherFactory::<span class="hljs-keyword">class</span>.java.classLoader<br>                ).iterator().asSequence().toList()<br>            &#125;<br>            @Suppress("ConstantConditionIf")<br>            factories.maxBy &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)<br>                ?: createMissingDispatcher()<br>        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;<br>            // Service loader can <span class="hljs-keyword">throw</span> an exception <span class="hljs-keyword">as</span> well<br>            createMissingDispatcher(e)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>拿Android举例，分析下如何实现<code>Dispatchers.Main</code>功能</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">fun</span> loadMainDispatcherFactory(): List&lt;MainDispatcherFactory&gt; &#123;<br>    <span class="hljs-keyword">val</span> clz = MainDispatcherFactory::<span class="hljs-keyword">class</span>.java<br>    <span class="hljs-keyword">if</span> (!ANDROID_DETECTED) &#123;<br>        return load(clz, clz.classLoader)<br>    &#125;<br><br>    return <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">val</span> result = ArrayList&lt;MainDispatcherFactory&gt;(2)<br>      //加载对应类名的类<br>        createInstanceOf(clz, "kotlinx.coroutines.android.AndroidDispatcherFactory")?.apply &#123; result.add(this) &#125;<br>        createInstanceOf(clz, "kotlinx.coroutines.test.<span class="hljs-keyword">internal</span>.TestMainDispatcherFactory")?.apply &#123; result.add(this) &#125;<br>        result<br>    &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;<br>        // Fallback to the regular SL <span class="hljs-keyword">in</span> case of any unexpected exception<br>        load(clz, clz.classLoader)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Android下的实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//在Android编译完成后，可以读取到该类<br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> AndroidDispatcherFactory : MainDispatcherFactory &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> createDispatcher(allFactories: List&lt;MainDispatcherFactory&gt;) = HandlerContext(Looper.getMainLooper().asHandler(async = <span class="hljs-literal">true</span>), "Main")<br>&#125;<br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> HandlerContext <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> handler: Handler,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String?,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> invokeImmediately: <span class="hljs-built_in">Boolean</span><br>) : HandlerDispatcher(), Delay &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<br>        handler: Handler,<br>        name: String? = <span class="hljs-literal">null</span><br>    ) : this(handler, name, <span class="hljs-literal">false</span>)<br><br>    //android中需要向主looper进行提交调度<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> isDispatchNeeded(context: CoroutineContext): <span class="hljs-built_in">Boolean</span> &#123;<br>        return !invokeImmediately || Looper.myLooper() != handler.looper<br>    &#125;<br><br>    //通过持有主线程looper的handler进行调度<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> dispatch(context: CoroutineContext, block: Runnable) &#123;<br>        handler.post(block)<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Android的<code>Dispatchers.Main</code>通过<code>Handler</code>将任务放到主线程中执行。</p>
<h4 id="Dispatchers-Unconfined"><a href="#Dispatchers-Unconfined" class="headerlink" title="Dispatchers.Unconfined"></a>Dispatchers.Unconfined</h4><blockquote>
<p>在协程体中，遇到第一个挂起函数前的代码运行在原线程中，执行挂起函数后，就运行在子线程中，</p>
</blockquote>
<h4 id="自定义调度器"><a href="#自定义调度器" class="headerlink" title="自定义调度器"></a>自定义调度器</h4><blockquote>
<p><code>Default</code>和<code>IO</code>的底层实现都依赖了<code>线程池</code>，执行到<code>挂起函数</code>时还是会发生线程的切换。可以通过自定义调度器减少这类切换的发生。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myDispatcher= Executors.newSingleThreadExecutor&#123; r -&gt; Thread(r, "MyThread") &#125;.asCoroutineDispatcher() //转换线程池到 Dispatcher<br><br>suspend <span class="hljs-keyword">fun</span> test()&#123;<br>  GlobalScope.launch(myDispatcher)&#123;<br>    //TODO <br>  &#125;<br>  <br>  //任务执行完毕后关闭线程池，避免内存泄漏<br>  myDispatcher.close() <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="协程执行任务-Job"><a href="#协程执行任务-Job" class="headerlink" title="协程执行任务(Job)"></a>协程执行任务(<code>Job</code>)</h3><blockquote>
<p><code>Job</code>用于处理协程。封装了协程需要执行的代码逻辑，并且拥有简单的生命周期。</p>
<p><strong>负责管理协程的声明周期。</strong></p>
</blockquote>
<p>主要有以下几个生命周期：</p>
<ul>
<li><code>New</code> 新建任务</li>
<li><code>Active</code> 任务活跃</li>
<li><code>Completing</code> 任务完成中</li>
<li><code>Cancelling</code> 任务取消中</li>
<li><code>Cancelled</code> 任务已取消</li>
<li><code>Completed</code> 任务已完成</li>
</ul>
{% fullimage  /images/Job生命周期.jpg,ViewTree,ViewTree%}
<p><code>Job.join()</code>：中断与当前<code>Job</code>关联的协程，直到所有<code>子Job</code>执行完成，所关联的协程才可以继续执行。</p>
<p><code>join()</code>由<code>suspend</code>修饰，所以必须在协程内部被调用。</p>
<h4 id="SupervisorJob"><a href="#SupervisorJob" class="headerlink" title="SupervisorJob"></a><code>SupervisorJob</code></h4><p>使用<code>Job</code>时，若发生异常会导致异常进行传递，导致<code>父任务及兄弟任务都会被取消</code>。</p>
<p><code>SupervisorJob</code>针对异常传播情况进行处理，当发生异常时，只会影响自身，其他任务不受影响。</p>
<p><strong><code>SupervisorJob</code>只有在<code>supervisorScope</code>或者<code>CoroutineScope(SupervisorJob())</code>内执行可以生效。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> scope = CoroutineScope(SupervisorJob())<br><br>scope.launch&#123;<br>  launch&#123;<br>     //child 1<br>  &#125;<br>  <br>  launch&#123;<br>    // child 2<br>  &#125;<br>&#125;<br><br>若 child1 发生异常 child2可以继续运行。<br></code></pre></td></tr></table></figure>
<h3 id="协程构造器-Coroutine-Builders"><a href="#协程构造器-Coroutine-Builders" class="headerlink" title="协程构造器(Coroutine Builders)"></a>协程构造器(<code>Coroutine Builders</code>)</h3><blockquote>
<p>配置完上述的<code>启动模式、调度器、上下文</code>之后，就要开始构造一个<code>协程</code>。</p>
</blockquote>
<p>协程提供了几个通用的构造器</p>
<h4 id="launch"><a href="#launch" class="headerlink" title="launch"></a><code>launch</code></h4><blockquote>
<p>默认构建一个新的协程，并返回一个<code>Job</code>对象，可以对该<code>Job</code>进行操作，例如<code>start()、join()</code>启动协程,<code>cancel()</code>取消该协程。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> job = GlobalScope.launch&#123;<br>  //TODO ...<br>&#125;<br>job.cancel()<br></code></pre></td></tr></table></figure>
<p><code>Job</code>代表了协程本身，封装了协程需要执行的代码逻辑，并且拥有简单的生命周期。</p>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a><code>async</code></h4><blockquote>
<p>创建一个协程后，会返回一个<code>Deferred&lt;T&gt;</code>对象，可以通过该对象调用<code>await()</code>获取返回值。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> job = GlobalScope.async(Dispatchers.IO) &#123;<br>	log(2)<br>  delay(1000)<br>  123<br>&#125;<br><span class="hljs-keyword">val</span> result = job.await()<br></code></pre></td></tr></table></figure>
<p><code>async</code>允许<strong>并行的允许多个子线程任务</strong>。减少请求的耗时。</p>
<p><code>Deferred</code>提供了<code>await()</code>，用<code>suspend</code>修饰，需要获取<code>Deferred</code>对象的结果时，调用<code>await()</code>等待执行结果返回。</p>
<h3 id="协程异常处理-Coroutine-Exception"><a href="#协程异常处理-Coroutine-Exception" class="headerlink" title="协程异常处理(Coroutine Exception)"></a>协程异常处理(<code>Coroutine Exception</code>)</h3><p>以下是会导致协程异常发生的测试代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = 1<br>//模拟产生异常方法<br>suspend <span class="hljs-keyword">fun</span> test3() =<br>    suspendCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; continuation -&gt;<br>        <span class="hljs-keyword">if</span> (a == 0) &#123;<br>            continuation.resume(a)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            continuation.resumeWithException(IllegalArgumentException("haha"))<br>        &#125;<br>    &#125;<br><br>suspend <span class="hljs-keyword">fun</span> main(args:Array&lt;String&gt;)&#123;<br>    <span class="hljs-keyword">val</span> dispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher();<br>    coroutineScope.launch(dispatcher) &#123;<br>        log(1)<br>        //创建子协程<br>        <span class="hljs-keyword">val</span> job = coroutineScope.async &#123;<br>            test2()<br>        &#125;<br>        job.join()<br>        log(2)<br>    &#125;<br>    log(3)<br>    dispatcher.close()<br>&#125;<br><br>输出结果：<br>[main] 3<br>[pool-1-thread-1] 1<br>Exception <span class="hljs-keyword">in</span> thread "pool-1-thread-1" java.lang.IllegalArgumentException: haha<br><br>Process finished with exit code 0 //程序终止<br></code></pre></td></tr></table></figure>
<p>有以下两种手段来对异常进行捕获处理</p>
<h4 id="局部异常捕获"><a href="#局部异常捕获" class="headerlink" title="局部异常捕获"></a>局部异常捕获</h4><blockquote>
<p>这部分主要涉及到<code>协程作用域</code>的概念，根据上面对<code>协程作用域</code>的描述，主要分为<code>GlobalScope</code>以及<code>自定义CoroutineScope</code>两种。</p>
<p>对于这两种<code>协程作用域</code>异常传播也有不同的形式。</p>
</blockquote>
<h5 id="不传播异常"><a href="#不传播异常" class="headerlink" title="不传播异常"></a>不传播异常</h5><p>上面提到过<code>GlobalScope</code>为全局作用域，本身不存在父协程，发生异常后，只会输出异常信息，不会对运行产生影响。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test5() &#123;<br>    coroutineScope.launch &#123;<br>        log(1)<br>        <span class="hljs-keyword">val</span> job = GlobalScope.launch &#123;<br>            <span class="hljs-keyword">throw</span> NullPointerException("11")<br>        &#125;<br>        log(2)<br>        delay(1000)<br>        log(3)<br>    &#125;<br>    delay(1000)<br>    log(4)<br>&#125;<br><br>输出结果：<br>20:02:29:623 [DefaultDispatcher-worker-1] 1<br>20:02:29:625 [DefaultDispatcher-worker-1] 2<br>Global Exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">catch</span> and msg = 11<br>Exception <span class="hljs-keyword">in</span> thread "DefaultDispatcher-worker-3" java.lang.NullPointerException: 11<br>	at com.webrtc.lib_licode_adaptation.MyClassKt$test5$2$job$1.invokeSuspend(MyClass.kt:183)<br>20:02:30:632 [kotlinx.coroutines.DefaultExecutor] 4<br>20:02:30:632 [DefaultDispatcher-worker-3] 3<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure>
<p>使用<code>GlobalScope</code>启动协程，发生异常时，不会影响外部协程的运行。</p>
<h5 id="传播异常"><a href="#传播异常" class="headerlink" title="传播异常"></a>传播异常</h5><blockquote>
<p><strong>将异常主动往外抛到启动顶层协程所在的线程。</strong></p>
<p>主要采用<code>try{..}catch{...}</code>方式进行异常捕获</p>
</blockquote>
<p><code>coroutineScope</code></p>
<blockquote>
<p>协程默认作用域，在该作用域内当自身执行任务失败的时候，触发双向传播。</p>
<p><strong>子协程异常&lt;=&gt;父协程异常</strong></p>
</blockquote>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test7() &#123;<br>    log(1)<br>    coroutineScope &#123;<br>        // 启动一个子协程<br>        launch &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                delay(1000)<br>                println("3")<br>            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>                println(e.message)<br>            &#125;<br>        &#125;<br>        delay(100)<br>        <span class="hljs-keyword">throw</span> NullPointerException("111")<br>        println("3")<br>    &#125;<br>&#125;<br><br>输出结果：<br>10:15:46:738 [main] 1<br>Parent job <span class="hljs-keyword">is</span> Cancelling //由于父协程异常，导致子协程的执行取消<br>Exception <span class="hljs-keyword">in</span> thread "main" java.lang.NullPointerException: 111<br></code></pre></td></tr></table></figure>
<p><img src="/images/640.gif" srcset="/img/loading.gif" alt="img"></p>
<p><code>supervisorScope</code></p>
<blockquote>
<p>在作用域内当自身执行任务失败的时候，只会向下传播关闭子协程，不会影响父协程及其他同级协程的运行。</p>
<p><strong>父协程异常-&gt;子线程异常，子协程异常不影响父协程</strong></p>
<p><code>supervisorScope</code>使用<code>SupervisorJob</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> SupervisorJobImpl(parent: Job?) : JobImpl(parent) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> childCancelled(cause: Throwable): <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span> //子协程不影响父协程<br>&#125;<br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test7() &#123;<br>    println(1)<br>    supervisorScope &#123;<br>        println("2")<br>        // 启动一个子协程<br>        launch &#123;<br>            <span class="hljs-keyword">throw</span> NullPointerException("111")// 故意让子协程出现异常<br>        &#125;<br>        delay(100)<br>        println("3")<br>    &#125;<br>    println("4")<br>&#125;<br><br>输出结果：<br>1<br>2<br>Exception <span class="hljs-keyword">in</span> thread "DefaultDispatcher-worker-1" java.lang.NullPointerException: 111<br>...<br>3<br>4<br></code></pre></td></tr></table></figure>
<p><code>supervisorScope</code>内子协程的异常不影响父协程的继续运行。</p>
<p><img src="/images/640.png" srcset="/img/loading.gif" alt="img"></p>
<h4 id="全局异常捕获"><a href="#全局异常捕获" class="headerlink" title="全局异常捕获"></a>全局异常捕获</h4><blockquote>
<p>类似<code>Java</code>，协程也提供了捕获全局异常(<code>未声明捕获异常</code>)的方式。</p>
</blockquote>
<p><code>Java</code>的全局异常捕获方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() &#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> uncaughtException(Thread t, Throwable e) &#123;<br>        //TODO 异常处理<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h5 id="协程内全局异常捕获方式（针对协程作用域内未捕获的异常）"><a href="#协程内全局异常捕获方式（针对协程作用域内未捕获的异常）" class="headerlink" title="协程内全局异常捕获方式（针对协程作用域内未捕获的异常）"></a>协程内全局异常捕获方式（<code>针对协程作用域内未捕获的异常</code>）</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test4() &#123;<br>    <span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;<br>        log("Throws an exception with message: $&#123;throwable.message&#125;")<br>    &#125;<br>    log(1)<br>    <span class="hljs-keyword">val</span> job = coroutineScope.launch(exceptionHandler) &#123;<br>        log(3)<br>        <span class="hljs-keyword">throw</span> ArithmeticException("Hey!")<br>    &#125;<br>    log(2)<br>  //避免执行过程中 进程中断，导致输出结果不一致<br>    delay(1000)<br>&#125;<br><br>输出结果：<br>15:31:47:846 [main] 1<br>15:31:47:927 [main] 2<br>15:31:47:929 [DefaultDispatcher-worker-1] 3<br>15:31:47:933 [DefaultDispatcher-worker-1] Throws an exception with message: Hey! //捕获到异常<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure>
<p>上述代码调用了<code>launch</code>的构造方式，<code>async</code>的输出结果会如何？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test4() &#123;<br>    <span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;<br>        log("Throws an exception with message: $&#123;throwable.message&#125;")<br>    &#125;<br>    log(1)<br>    <span class="hljs-keyword">val</span> job = coroutineScope.async(exceptionHandler) &#123;<br>        log(3)<br>        4<br>        <span class="hljs-keyword">throw</span> ArithmeticException("Hey!")<br>    &#125;<br>    log(2)<br>    log(job.await())<br>    delay(1000)<br>&#125;<br><br>输出结果：<br>16:04:14:980 [main] 1<br>16:04:15:013 [main] 2<br>16:04:15:015 [DefaultDispatcher-worker-1] 3<br>Exception <span class="hljs-keyword">in</span> thread "main" java.lang.ArithmeticException: Hey!<br>	at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$1.invokeSuspend(MyClass.kt:171)<br></code></pre></td></tr></table></figure>
<p><code>async</code>直接抛出未捕获异常，导致当前进程执行中断</p>
<p>针对<code>launch</code>和<code>async</code>的不同表现，需要从源码层面进行分析</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">`launch`执行指向以下代码<br>// kotlinx.coroutines.BuildersKt<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">fun</span> CoroutineScope.launch(<br>    context: CoroutineContext = EmptyCoroutineContext,<br>    start: CoroutineStart = CoroutineStart.DEFAULT,//启动方式<br>    block: suspend CoroutineScope.() -&gt; <span class="hljs-built_in">Unit</span><br>): Job &#123;<br>    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)<br>    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)<br>        LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword">else</span><br>        StandaloneCoroutine(newContext, active = <span class="hljs-literal">true</span>)<br>    coroutine.start(start, coroutine, block)<br>    return coroutine<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> StandaloneCoroutine(<br>    parentContext: CoroutineContext,<br>    active: <span class="hljs-built_in">Boolean</span><br>) : AbstractCoroutine&lt;<span class="hljs-built_in">Unit</span>&gt;(parentContext, active) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> handleJobException(exception: Throwable): <span class="hljs-built_in">Boolean</span> &#123;<br>        handleCoroutineException(context, exception)<br>        return <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">fun</span> handleCoroutineException(context: CoroutineContext, exception: Throwable) &#123;<br>    // Invoke an exception handler from the context <span class="hljs-keyword">if</span> present<br>    //若context存在 ExceptionHandler 则会对异常进行处理<br>    <span class="hljs-keyword">try</span> &#123;<br>        context[CoroutineExceptionHandler]?.let &#123;<br>            it.handleException(context, exception)<br>            return<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (t: Throwable) &#123;<br>        handleCoroutineExceptionImpl(context, handlerException(exception, t))<br>        return<br>    &#125;<br>    // If a handler <span class="hljs-keyword">is</span> not present <span class="hljs-keyword">in</span> the context or an exception was thrown, fallback to the global handler<br>    handleCoroutineExceptionImpl(context, exception)<br>&#125;<br><br>`async`执行指向如下代码<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">fun</span> &lt;T&gt; CoroutineScope.async(<br>    context: CoroutineContext = EmptyCoroutineContext,<br>    start: CoroutineStart = CoroutineStart.DEFAULT,<br>    block: suspend CoroutineScope.() -&gt; T<br>): Deferred&lt;T&gt; &#123;<br>    <span class="hljs-keyword">val</span> newContext = newCoroutineContext(context)<br>    <span class="hljs-keyword">val</span> coroutine = <span class="hljs-keyword">if</span> (start.isLazy)<br>        LazyDeferredCoroutine(newContext, block) <span class="hljs-keyword">else</span><br>        DeferredCoroutine&lt;T&gt;(newContext, active = <span class="hljs-literal">true</span>)<br>    coroutine.start(start, coroutine, block)<br>    return coroutine<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> DeferredCoroutine&lt;T&gt;(<br>    parentContext: CoroutineContext,<br>    active: <span class="hljs-built_in">Boolean</span><br>) : AbstractCoroutine&lt;T&gt;(parentContext, active), Deferred&lt;T&gt;, SelectClause1&lt;T&gt; &#123;<br>  //没有对 exception进行处理，导致全局异常无法处理<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> getCompleted(): T = getCompletedInternal() <span class="hljs-keyword">as</span> T<br>    <span class="hljs-keyword">override</span> suspend <span class="hljs-keyword">fun</span> await(): T = awaitInternal() <span class="hljs-keyword">as</span> T<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> onAwait: SelectClause1&lt;T&gt; <span class="hljs-keyword">get</span>() = this<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> &lt;R&gt; registerSelectClause1(select: SelectInstance&lt;R&gt;, block: suspend (T) -&gt; R) =<br>        registerSelectClause1Internal(select, block)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>综上所述：<strong>在全局异常处理下，只有用<code>launch</code>启动的协程才可以捕获异常，而<code>async</code>不能被捕获异常，会继续抛出异常。</strong></p>
<h5 id="真·全局异常捕获方式"><a href="#真·全局异常捕获方式" class="headerlink" title="真·全局异常捕获方式"></a>真·全局异常捕获方式</h5><p>上述实现的<code>ExceptionHandler</code>只能在协程内使用，而无法处理其他协程的异常情况。需要使用<code>ServiceLoader</code>来实现全局协程异常捕获</p>
<p>实现全局的异常捕获需要如下几步：</p>
<ol>
<li><p>新建全局<code>ExceptionHandler</code>类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> GlobalExceptionHandler : CoroutineExceptionHandler&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptionHandler<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> handleException(context: CoroutineContext, exception: Throwable) &#123;<br>        print("Global Exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">catch</span> and msg = $&#123;exception.message&#125;")<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>classpath</code>中注册该类</p>
<p>在<code>src/main</code>目录下新建<code>resources/META-INF/</code>文件夹，然后新建文件命名为<code>kotlinx.coroutines.CoroutineExceptionHandler</code>，文件内写入</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">com</span>.XX.lib.GlobalExceptionHandler<br></code></pre></td></tr></table></figure>
<p>目录结构如下：</p>
<p>src</p>
<p>​    -main</p>
<p>​        -java</p>
<p>​        -resources</p>
<p>​            -META-INF</p>
<p>​                -services</p>
<p>​                    -kotlinx.coroutines.CoroutineExceptionHandler</p>
</li>
<li><p>测试效果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test4() &#123;<br>    <span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, throwable -&gt;<br>        print("Throws an exception with message: $&#123;throwable.message&#125;")<br>    &#125;<br>    log(1)<br>    <span class="hljs-keyword">val</span> job = coroutineScope.launch() &#123; //exceptionHandler配置<br>        log(3)<br>        <span class="hljs-keyword">throw</span> ArithmeticException("Hey!")<br>    &#125;<br>    log(2)<br>  //避免执行过程中 进程中断，导致输出结果不一致<br>    delay(1000)<br>&#125;<br><br>输出结果：<br>16:04:14:980 [main] 1<br>16:04:15:013 [main] 2<br>16:04:15:015 [DefaultDispatcher-worker-1] 3<br>Global Exception <span class="hljs-keyword">is</span> <span class="hljs-keyword">catch</span> and msg = Hey!<br>Exception <span class="hljs-keyword">in</span> thread "main" java.lang.ArithmeticException: Hey!<br>	at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$1.invokeSuspend(MyClass.kt:171)<br><br>若配置了exceptionHandler就会覆盖Global的配置<br>输出如下内容：<br>16:04:14:980 [main] 1<br>16:04:15:013 [main] 2<br>16:04:15:015 [DefaultDispatcher-worker-1] 3<br>Exception <span class="hljs-keyword">in</span> thread "main" java.lang.ArithmeticException: Hey!<br>	at com.webrtc.lib_licode_adaptation.MyClassKt$test4$job$1.invokeSuspend(MyClass.kt:171)<br></code></pre></td></tr></table></figure>
<p><strong>全局异常捕获的配置只对<code>launch</code>有效，<code>async</code>无效。</strong></p>
<p><code>真·全局异常捕获</code>不支持<code>JS以及Native</code>平台。</p>
<p>拓展：</p>
<ol>
<li><p>SPI机制</p>
<blockquote>
<p>全称为<code>Service Provider Interface</code>，JDK内置的一种服务提供发现机制，主要源码在<code>java.util.ServiceLoader</code>。</p>
</blockquote>
<p>使用时需要在<code>META-INF/services</code>创建和服务同名的<strong>全限定名</strong>相同的文件(例如<em>com.xx.xx.service</em>)，在文件中写入<strong>服务提供者</strong>的全限定名(例如<em>com.xxx.xx.XXService</em>)。</p>
<p>实现原理：</p>
<ol>
<li>调用<code>ServiceLaoder.load()</code>创建新的<code>ServiceLoader</code></li>
<li>再通过迭代器获取对象实例<ul>
<li>判断<code>providers</code>是否缓存实例对象，若存在则返回</li>
<li>不存在，则执行类的装载过程：<ol>
<li>读取<code>META-INF/services</code>的配置文件，获得需要被实例化类的名称</li>
<li>反射调用<code>Class.forName()</code>并调用<code>instance()</code>进行类实例化。<strong>需要对应类必须存在一个无参构造方法。</strong></li>
<li>实例化对象存到<code>providers</code>缓存对象中并返回实例对象。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>无法按需加载，只能通过遍历的方式获取全部接口实现类</li>
<li>无法直接获取实例对象，只能通过遍历匹配对应实现类</li>
<li>并发<code>serviceLoader</code>是不安全的</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p><strong>协程内部异常处理流程</strong></p>
<ul>
<li>在作用域内使用<code>try..catch</code>可以直接捕获子线程中的异常</li>
<li>如果未设置异常捕获，则会走<code>全局异常捕获流程</code>(<strong>只在<code>launch</code>创建协程下生效</strong>)<ul>
<li>若设置<code>CoroutineExceptionHandler</code>则处理</li>
<li>没配置，向<code>GlobalExceptionHandler</code>进行处理，该配置是全局的，对所有协程任务生效</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>异常传播不同作用域表现</strong></p>
<ul>
<li><code>GlobalScope</code>：异常不会向外传递，因为已经是<code>根协程</code></li>
<li><code>coroutineScope</code>：异常进行<code>双向传递</code>，父协程和子协程都会被取消</li>
<li><code>supervisorScope</code>：异常进行<code>单向传递</code>，只有父协程向子协程传递异常，子协程会被取消，父协程不受影响</li>
</ul>
</li>
<li><p><code>launch/join</code>和<code>async/await</code>表现不同</p>
<p><code>launch/join</code>关注的是<strong>任务是否执行完成</strong>，<code>async/await</code>关注的是<strong>任务的执行结果</strong>，所以在局部异常捕获的时候，两种创建方式的异常捕获也会有区别</p>
</li>
<li><p><strong>全局的异常处理器(CoroutineExceptionHandler)只会对父协程生效，子协程的异常最后还是会传递到根协程进行处理。</strong>非<code>supervisorScope</code>条件下。</p>
</li>
</ol>
<h3 id="协程取消-Coroutine-Cancel"><a href="#协程取消-Coroutine-Cancel" class="headerlink" title="协程取消(Coroutine Cancel)"></a>协程取消(<code>Coroutine Cancel</code>)</h3><blockquote>
<p>取消针对<code>Job</code>而设的，调用<code>cancel()</code>可以取消正在运行的协程。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">//官方示例代码<br><span class="hljs-keyword">val</span> job = launch &#123;<br>    repeat(1000) &#123; i -&gt;<br>        println("I'm sleeping $i ...")<br>        delay(500L)<br>    &#125;<br>&#125;<br>delay(1300L) // 等待一段时间<br>println("main: I'm tired of waiting!")<br>job.cancel() // 取消 job<br>job.join() // 等待 job 结束<br>println("main: Now I can quit.")<br></code></pre></td></tr></table></figure>
<p>上述代码是最基础的<code>cancel</code>使用方式</p>
<h4 id="协程之间的关系"><a href="#协程之间的关系" class="headerlink" title="协程之间的关系"></a>协程之间的关系</h4><blockquote>
<p>协程之间是存在着父子关系的，<strong>取消父协程时，也会取消所有子协程！</strong></p>
</blockquote>
<p>主要有以下三种关系：</p>
<h5 id="父协程调用cancel-主动或者触发异常结束时，会立即取消所有子协程；子协程调用cancel-不影响父协程及兄弟协程执行。"><a href="#父协程调用cancel-主动或者触发异常结束时，会立即取消所有子协程；子协程调用cancel-不影响父协程及兄弟协程执行。" class="headerlink" title="父协程调用cancel()主动或者触发异常结束时，会立即取消所有子协程；子协程调用cancel()不影响父协程及兄弟协程执行。"></a>父协程调用<code>cancel()</code>主动或者触发异常结束时，会立即取消所有子协程；子协程调用<code>cancel()</code>不影响父协程及兄弟协程执行。</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">基础调用流程<br>Job.cancel() =&gt; JobImpl.cancel() =&gt; JobSupport.cancelImpl() =&gt; JobSupport.notifyCancelling()<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> notifyCancelling(list: NodeList, cause: Throwable) &#123;<br>        // first cancel our own children<br>        onCancelling(cause)<br>        notifyHandlers&lt;JobCancellingNode&lt;*&gt;&gt;(list, cause)<br>        // then cancel parent<br>        cancelParent(cause) // tentative cancellation -- does not matter <span class="hljs-keyword">if</span> there <span class="hljs-keyword">is</span> no parent<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> cancelParent(cause: Throwable): <span class="hljs-built_in">Boolean</span> &#123;<br>        // Is scoped coroutine -- don't propagate, will be rethrown<br>        <span class="hljs-keyword">if</span> (isScopedCoroutine) return <span class="hljs-literal">true</span><br><br>        <span class="hljs-keyword">val</span> isCancellation = cause <span class="hljs-keyword">is</span> CancellationException<br>        <span class="hljs-keyword">val</span> parent = parentHandle<br>        // No parent -- ignore CE, report other exceptions.<br>        <span class="hljs-keyword">if</span> (parent === <span class="hljs-literal">null</span> || parent === NonDisposableHandle) &#123;<br>            return isCancellation<br>        &#125;<br>        //调用所有子协程进行取消任务，子线程也会收到 CancellException<br>        return parent.childCancelled(cause) || isCancellation<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="父协程必须等到所有子协程完成-执行完成-或-取消-才算完成"><a href="#父协程必须等到所有子协程完成-执行完成-或-取消-才算完成" class="headerlink" title="父协程必须等到所有子协程完成(执行完成 或 取消)才算完成"></a>父协程必须等到所有子协程完成(执行完成 或 取消)才算完成</h5><h5 id="子协程抛出未捕获的异常时，默认情况下会取消父协程-CancellationException除外"><a href="#子协程抛出未捕获的异常时，默认情况下会取消父协程-CancellationException除外" class="headerlink" title="子协程抛出未捕获的异常时，默认情况下会取消父协程(CancellationException除外)"></a>子协程抛出未捕获的异常时，默认情况下会取消父协程(<code>CancellationException除外</code>)</h5><h4 id="只有可取消的协程代码，才可以被取消"><a href="#只有可取消的协程代码，才可以被取消" class="headerlink" title="只有可取消的协程代码，才可以被取消"></a>只有可取消的协程代码，才可以被取消</h4><blockquote>
<p>协程的代码必须与外界配合，才能够被取消！</p>
</blockquote>
<p>目前只有<code>kotlinx.coroutines</code>中的所有挂起函数都是<strong>可取消的</strong>。这些挂起函数会检查协程是否被取消，并在被取消时抛出<code>CancellationException</code>异常。</p>
<p>例如<code>delay()、yield()</code>这些预置的挂起函数，或者封装的挂起函数都是可以被取消的。</p>
<h5 id="delay"><a href="#delay" class="headerlink" title="delay()"></a>delay()</h5><blockquote>
<p>让协程挂起，而且不会阻塞CPU。</p>
<!--Thread.sleep 让出CPU，不会释放锁。wait会释放锁，等待notify进行唤醒-->
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> suspend <span class="hljs-keyword">fun</span> delay(timeMillis: <span class="hljs-built_in">Long</span>) &#123;<br>    <span class="hljs-keyword">if</span> (timeMillis &lt;= 0) return // don't delay<br>    return suspendCancellableCoroutine sc@ &#123; cont: CancellableContinuation&lt;<span class="hljs-built_in">Unit</span>&gt; -&gt;<br>        //将任务放到<br>        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)<br>    &#125;<br>&#125;<br><br>//默认延迟线程池<br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">val</span> CoroutineContext.delay: Delay <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">get</span>(ContinuationInterceptor) <span class="hljs-keyword">as</span>? Delay ?: DefaultDelay<br><br>//EventLoopImplBase<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">fun</span> scheduleResumeAfterDelay(timeMillis: <span class="hljs-built_in">Long</span>, continuation: CancellableContinuation&lt;<span class="hljs-built_in">Unit</span>&gt;) &#123;<br>        <span class="hljs-keyword">val</span> timeNanos = delayToNanos(timeMillis)//设置执行时间<br>        <span class="hljs-keyword">if</span> (timeNanos &lt; MAX_DELAY_NS) &#123;<br>            <span class="hljs-keyword">val</span> now = nanoTime()<br>            DelayedResumeTask(now + timeNanos, continuation).also &#123; task -&gt; //按照延时添加任务<br>                continuation.disposeOnCancellation(task)<br>                schedule(now, task)<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>关键点就在于<code>suspendCancellableCoroutine</code>提供了普通函数的挂起转换</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> suspend <span class="hljs-keyword">inline</span> <span class="hljs-keyword">fun</span> &lt;T&gt; suspendCancellableCoroutine(<br>    <span class="hljs-keyword">crossinline</span> block: (CancellableContinuation&lt;T&gt;) -&gt; <span class="hljs-built_in">Unit</span><br>): T =<br>    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;<br>        <span class="hljs-keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)<br>        /*<br>         * For non-atomic cancellation we setup parent-child relationship immediately<br>         * <span class="hljs-keyword">in</span> case <span class="hljs-keyword">when</span> `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but<br>         * properly supports cancellation.<br>         */<br>        cancellable.initCancellability()<br>        block(cancellable)<br>        cancellable.getResult()<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h5><blockquote>
<p>挂起当前协程，然后将协程分发到<code>Dispatcher</code>的队列，可以让该协程所在线程或线程池可以运行其他协程逻辑，然后等待<code>Disapcher</code>空闲的时候继续执行原来协程。</p>
<!--Thread.yield() 让出CPU调度，只能让 同优先级的线程有执行机会-->
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> dispatcher = Executors.newFixedThreadPool(2).asCoroutineDispatcher()  <br>coroutineScope.launch(dispatcher)&#123;<br>            launch &#123; //协程1<br>                repeat(3) &#123;<br>                    log("job1 repeat $it times")<br>                    yield() //让协程2得以执行<br>                &#125;<br>            &#125;<br>            launch &#123; //协程2<br>                repeat(3) &#123;<br>                    log("job2 repeat $it times")<br>//                    yield()<br>                &#125;<br>            &#125;<br>    &#125;<br>delay(1000)<br>dispatcher.close()<br><br>输出结果：<br>19:28:30:808 [pool-1-thread-2] job1 repeat 0 times<br>19:28:30:809 [pool-1-thread-1] job2 repeat 0 times<br>19:28:30:809 [pool-1-thread-1] job2 repeat 1 times<br>19:28:30:809 [pool-1-thread-1] job2 repeat 2 times<br>19:28:30:809 [pool-1-thread-1] job1 repeat 1 times<br>19:28:30:809 [pool-1-thread-1] job1 repeat 2 times<br></code></pre></td></tr></table></figure>
<p><code>yield()</code>相关源码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> suspend <span class="hljs-keyword">fun</span> yield(): <span class="hljs-built_in">Unit</span> = suspendCoroutineUninterceptedOrReturn sc@ &#123; uCont -&gt;<br>    <span class="hljs-keyword">val</span> context = uCont.context<br>    context.checkCompletion()<br>    ...<br>    COROUTINE_SUSPENDED<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="suspendCoroutineUninterceptedOrReturn"><a href="#suspendCoroutineUninterceptedOrReturn" class="headerlink" title="*suspendCoroutineUninterceptedOrReturn"></a>*suspendCoroutineUninterceptedOrReturn</h5><p>根据上面两个源码发现，转换挂起函数的关键在于<code>suspendCoroutineUninterceptedOrReturn</code>，只要实现了该函数，就可以转换为可被取消的挂起函数</p>
<p>通常做转换的时候，可以使用系统提供的两个转换函数</p>
<ul>
<li><code>suspendCoroutine</code></li>
<li><code>suspendCancellableCoroutine</code></li>
</ul>
<p>这两者都调用了<code>suspendCoroutineUninterceptedOrReturn</code>函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> aa = 0<br>suspend <span class="hljs-keyword">fun</span> ttt() = suspendCancellableCoroutine&lt;<span class="hljs-built_in">Int</span>&gt; &#123; cancellableContinuation -&gt;<br>    <span class="hljs-keyword">if</span> (aa == 0) &#123;<br>        //执行完毕抛出结果<br>        cancellableContinuation.resume(1) &#123;<br>            // 执行过程异常捕获<br>            log("aaa $&#123;it.message&#125;")<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cancellableContinuation.resumeWithException(IllegalArgumentException("123"))<br>    &#125;<br><br>    cancellableContinuation.invokeOnCancellation &#123;<br>       //协程任务执行cancel时，回调该方法<br>        log("我被取消了")<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="取消计算代码-使用isActive判断"><a href="#取消计算代码-使用isActive判断" class="headerlink" title="取消计算代码(使用isActive判断)"></a>取消计算代码(使用<code>isActive</code>判断)</h4><blockquote>
<p>如果协程正处在某个计算过程当中，并且不进行检查状态的取消，那它就是无法被取消的。</p>
</blockquote>
<p>对于这种情况有两种处理方式：</p>
<ol>
<li>周期性调用挂起函数(<code>采用上面的手段得到挂起函数</code>)，检查协程是否被取消</li>
<li>显式检查协程是否被取消</li>
</ol>
<p>在这一节，采用的就是第二种方案取消协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test9() &#123;<br>    <span class="hljs-keyword">val</span> startTime = System.currentTimeMillis()<br>    <span class="hljs-keyword">val</span> dispatcher = Executors.newFixedThreadPool(3).asCoroutineDispatcher()<br>    <span class="hljs-keyword">val</span> job = coroutineScope.launch(dispatcher) &#123;<br>        <span class="hljs-keyword">var</span> nextPrintTime = startTime<br>        <span class="hljs-keyword">var</span> i = 0<br>        <span class="hljs-keyword">while</span> (isActive) &#123; // 一个浪费 CPU 的计算任务循环<br>            // 每秒打印信息 2 次<br>            <span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;<br>                i++<br>                log(i)<br>                nextPrintTime += 500L<br>            &#125;<br>        &#125;<br>    &#125;<br>    delay(1300L) // 等待一段时间<br>    println("main: I'm tired of waiting!")<br>    job.cancelAndJoin() // 取消 job, 并等待它结束<br>    println("main: Now I can quit.")<br>    dispatcher.close()<br>&#125;<br><br>输出结果：<br>19:30:01:805 [pool-1-thread-1] 1<br>19:30:02:292 [pool-1-thread-1] 2<br>19:30:02:792 [pool-1-thread-1] 3<br>main: I'm tired of waiting!<br>main: Now I can quit.<br></code></pre></td></tr></table></figure>
<p>相关源码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">JobSupport.cancelImpl() =&gt; JobSupport.makeCancelling() =&gt; JobSupport.tryMakeCancelling()<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> tryMakeCancelling(state: Incomplete, rootCause: Throwable): <span class="hljs-built_in">Boolean</span> &#123;<br>        assert &#123; state !<span class="hljs-keyword">is</span> Finishing &#125; // only <span class="hljs-keyword">for</span> non-finishing states<br>        assert &#123; state.isActive &#125; // only <span class="hljs-keyword">for</span> active states<br>        // <span class="hljs-keyword">get</span> state's list or <span class="hljs-keyword">else</span> promote to list to correctly operate on child lists<br>        <span class="hljs-keyword">val</span> list = getOrPromoteCancellingList(state) ?: return <span class="hljs-literal">false</span><br>        // Create cancelling state (with rootCause!)<br>        <span class="hljs-keyword">val</span> cancelling = Finishing(list, <span class="hljs-literal">false</span>, rootCause)<br>        <span class="hljs-keyword">if</span> (!_state.compareAndSet(state, cancelling)) return <span class="hljs-literal">false</span><br>        // Notify listeners<br>        notifyCancelling(list, rootCause)<br>        return <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> Finishing(<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> list: NodeList,<br>        isCompleting: <span class="hljs-built_in">Boolean</span>,<br>        rootCause: Throwable?<br>    ) : SynchronizedObject(), Incomplete &#123;<br>      <br>      ...<br>       <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = rootCause == <span class="hljs-literal">null</span> // !isCancelling 此处isActive就变为<span class="hljs-literal">false</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="禁止取消"><a href="#禁止取消" class="headerlink" title="禁止取消"></a>禁止取消</h4><blockquote>
<p>当任务被取消时，挂起函数会收到<code>CancellationException</code>后续如果需要执行一些其他的挂起函数任务将无法执行。</p>
</blockquote>
<p>可以通过对挂起函数调用<code>withContext(NonCancellable)</code>进行包含，保证挂起函数正常执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test9() &#123;<br>    <span class="hljs-keyword">val</span> startTime = System.currentTimeMillis()<br>    <span class="hljs-keyword">val</span> dispatcher = Executors.newFixedThreadPool(3).asCoroutineDispatcher()<br>    <span class="hljs-keyword">val</span> job = coroutineScope.launch(dispatcher) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">var</span> nextPrintTime = startTime<br>            <span class="hljs-keyword">var</span> i = 0<br>            //按道理 这边会被取消，因为设置了 NonCancellable导致任务无法被取消<br>            withContext(NonCancellable)&#123;<br>                log("111")<br>                delay(2000)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>                withContext(NonCancellable)&#123;<br>                    delay(1000)<br>                &#125;<br>                log("111")<br>        &#125;<br>    &#125;<br>    delay(1300L) // 等待一段时间<br>    println("main: I'm tired of waiting!")<br>    job.cancelAndJoin() // 取消 job, 并等待它结束<br>    println("main: Now I can quit.")<br>    dispatcher.close()<br>&#125;<br><br>输出结果：<br>20:31:35:163 [pool-1-thread-1] 111<br>main: I'm tired of waiting!<br>20:31:38:173 [pool-1-thread-3] 111  //间隔大概3s<br>main: Now I can quit.<br></code></pre></td></tr></table></figure>
<p><code>NonCancellable</code>就是一个普通的对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> NonCancellable : AbstractCoroutineContextElement(Job), Job &#123;<br> ...<br>      <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> isActive: <span class="hljs-built_in">Boolean</span> <span class="hljs-keyword">get</span>() = <span class="hljs-literal">true</span> //永远为<span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="超时取消"><a href="#超时取消" class="headerlink" title="超时取消"></a>超时取消</h4><blockquote>
<p>大部分取消协程的原因都是<strong>超出了预期的执行时间</strong>，此时就会去触发取消的操作。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> testTimeout() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        withTimeout(1300) &#123;<br>            repeat(5) &#123;<br>                delay(500)<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>        log("e.msg = $&#123;e.message&#125;") //捕获超时异常<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        log("job cancelled") //任务取消后，可以做一些其他工作<br>    &#125;<br>    delay(1000)<br>&#125;<br><br>输出结果：<br>13:25:54:484 [kotlinx.coroutines.DefaultExecutor] e.msg = Timed <span class="hljs-keyword">out</span> waiting <span class="hljs-keyword">for</span> 1300 ms<br>13:25:54:485 [kotlinx.coroutines.DefaultExecutor] job cancelled<br></code></pre></td></tr></table></figure>
<p>执行超过<code>timeout</code>的时候，会抛出<code>TimeoutCancellationException</code>异常</p>
<p>上述<code>withTimeout()</code>超时时会抛出异常，系统另外提供了<code>withTimeoutOrNull()</code>超时的时候不会抛出异常，而是返回一个null</p>
<h3 id="协程挂起-suspend"><a href="#协程挂起-suspend" class="headerlink" title="协程挂起(suspend)"></a>协程挂起(<code>suspend</code>)</h3><p>在上节<code>协程取消</code>中，说到取消协程的一个要求就是<code>必须为可被取消的协程代码</code>，里面就有讲到转换成<code>挂起函数</code>就可以被取消。</p>
<blockquote>
<p>把协程当成一个任务，运行在某个线程之上，该任务是可以中止也可以被继续恢复执行。</p>
<p><code>协程挂起</code>指的就是<em>任务的中止，而且不会阻塞当前的线程。</em></p>
<p><code>协程挂起</code>的条件是<em>在协程调用<code>挂起函数</code>时，才可以被挂起</em>。</p>
</blockquote>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><h5 id="续体接口-Continuation"><a href="#续体接口-Continuation" class="headerlink" title="续体接口(Continuation)"></a>续体接口(<code>Continuation</code>)</h5><blockquote>
<p>作为协程调用<code>挂起函数</code>时的回调，<code>挂起函数</code>执行结束后通过使用该接口唤醒调用者。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">@SinceKotlin("1.3")<br><span class="hljs-keyword">public</span> interface Continuation&lt;<span class="hljs-keyword">in</span> T&gt; &#123;<br>    /**<br>     * The context of the coroutine that corresponds to this continuation.<br>     * 定义的协程上下文<br>     */<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> context: CoroutineContext<br><br>    /**<br>     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] <span class="hljs-keyword">as</span> the<br>     * return value of the last suspension point.<br>     * 执行完毕回调，回调成功或失败的结果<br>     */<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">fun</span> resumeWith(result: Result&lt;T&gt;)<br>&#125;<br>//提供拓展函数，支持直接调用成功或失败回调<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">fun</span> &lt;T&gt; Continuation&lt;T&gt;.resume(value: T): <span class="hljs-built_in">Unit</span> =<br>    resumeWith(Result.success(value))<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">fun</span> &lt;T&gt; Continuation&lt;T&gt;.resumeWithException(exception: Throwable): <span class="hljs-built_in">Unit</span> =<br>    resumeWith(Result.failure(exception))<br></code></pre></td></tr></table></figure>
<p><code>Continuation</code>作为<code>挂起函数</code>调用时的一个<code>隐式参数</code>传入，封装了协程恢复后的执行代码逻辑。</p>
<h5 id="挂起函数-suspend-function"><a href="#挂起函数-suspend-function" class="headerlink" title="挂起函数(suspend function)"></a>挂起函数(<code>suspend function</code>)</h5><blockquote>
<p> <code>suspend</code>修饰挂起函数，可以通过调用其他<code>挂起函数</code>执行代码，而且<strong>不阻塞当前执行线程</strong>。</p>
<p><code>挂起函数</code>的运行可以被中止，运行<code>挂起函数</code>的线程可以去执行其他任务。</p>
<p><strong>挂起函数无法被其他常规函数调用！</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">suspend <span class="hljs-keyword">fun</span> test()&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述实例为<code>挂起函数</code>。</p>
<p>当<code>挂起函数</code>在一个协程中被调用时，该挂起函数内部会增加一个参数<code>Continuation</code>，类似下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">fun test(contimuation:Continuation)&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种转换被称为<strong>CPS（续体传递风格）</strong>，每个<code>挂起函数</code>或<code>挂起Lambda表达式</code>都会附加一个<code>Continuation</code>参数，在外界调用<code>挂起函数</code>时隐式入参。 </p>
<h2 id="协程的原理"><a href="#协程的原理" class="headerlink" title="协程的原理"></a>协程的原理</h2><p>上述的基础概念已基本涵盖协程的整套执行流程，后面会在<a href="/2020/09/04/Kotlin协程原理/" title="Kotlin协程原理">Kotlin协程原理</a> 串联整体流程。</p>
<h2 id="协程在Android中的应用"><a href="#协程在Android中的应用" class="headerlink" title="协程在Android中的应用"></a>协程在Android中的应用</h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="CPU上下文"><a href="#CPU上下文" class="headerlink" title="CPU上下文"></a>CPU上下文</h3><blockquote>
<p><strong>CPU寄存器和程序计数器</strong>，这两者都是CPU在运行任务前，都必须的依赖环境。</p>
<p><code>CPU寄存器</code>：CPU内置的容量小、但速度极快的内存</p>
<p><code>程序计数器</code>：存储CPU正在执行的指令位置，或即将执行的下一条指令位置</p>
</blockquote>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><blockquote>
<p>把前一个任务的<code>CPU上下文</code>保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后在跳转到程序计数器所指的新位置，运行新任务。</p>
<p>被保存的上下文会存储到<em>系统内核</em>中，在任务被重新调度时重新加载。</p>
</blockquote>
<h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><blockquote>
<p>从一个进程切换到另一个进程运行。</p>
</blockquote>
<p>进程的运行空间分为：</p>
<ul>
<li><code>内核空间</code>：具有最高权限，可以访问进程间的所有资源。（进程运行其中称为<strong>内核态</strong>。）</li>
<li><code>用户空间</code>：只能访问受限资源，不能直接访问内存等硬件设备，必须通过<strong>系统调用</strong>陷入到内核中，才能访问所有资源。（进程运行其中为<strong>用户态</strong>。）</li>
</ul>
<p><code>系统调用(system-call)</code>：进程从<code>用户态</code>到<code>内核态</code>的转变，需要通过<code>系统调用</code>实现。过程如下：</p>
<ul>
<li>保存CPU寄存器里原来用户态的指令位</li>
<li>为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置</li>
<li>跳转到内核态执行内核任务</li>
<li>系统调用结束后，CPU寄存器需要回复到原来保存的用户态，然后再切换到用户空间，继续运行线程。</li>
</ul>
<p><code>系统调用</code>过程中，总共发生了<code>两次CPU上下文切换</code>(用户态-&gt;内核态-&gt;用户态)。</p>
<h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><blockquote>
<p>从一个线程切换到另一个线程执行。</p>
</blockquote>
<p><strong>线程时调度的基本单位，进程这是资源拥有的基本单位。</strong>内核中的任务调度，实际调度对象为线程；进程只是给线程提供了<code>虚拟内存、全局变量</code>等资源。</p>
<p>线程发生上下文切换时，还需要保存线程所拥有的私有数据，例如栈、寄存器等。</p>
<p>线程上下文切换场景：</p>
<ul>
<li>切换的线程不处于同一进程中，因为资源不共享，执行的流程同<code>进程上下文切换</code>。</li>
<li>切换的线程处于同一进程中，资源是共享的，公共资源就不需要进行切换，只要切换线程的私有数据。</li>
</ul>
<h4 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h4><blockquote>
<p>中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。打断进程时，只需要保留当前进程的运行状态，中断执行结束后，继续从愿状态运行。</p>
</blockquote>
<p>中断上下文切换不涉及进程的用户态，在中断触发时，只需要保存内核态中断服务程序所必需的状态。例如<code>CPU寄存器、内核堆栈、硬件中断参数等</code>。</p>
<p><strong>中断上下文切换比进程上下文切换拥有更高的优先级，两者不会在同一CPU上同时发生。</strong></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.im/post/6844903858368413704" target="_blank" rel="noopener">viewModelScope简易介绍</a></p>
<p><a href="https://blog.csdn.net/weixin_42063726/article/details/106198068" target="_blank" rel="noopener">Kotlin-调度器介绍</a></p>
<p><a href="https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html" target="_blank" rel="noopener">协程官方文档</a></p>
<p><a href="http://zhoukaibo.com/2019/03/16/java-spi-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9/" target="_blank" rel="noopener">SPI机制</a></p>
<p><a href="https://github.com/Kotlin-zh/KEEP/blob/master/proposals/coroutines.md" target="_blank" rel="noopener">Kotlin协程设计思路</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652055127&amp;idx=2&amp;sn=283de8250bfc8a7bd8287a7aadad1339&amp;chksm=808c8612b7fb0f047702c2101d27f4de42363ae5dd462be977ec897c7ae6a36e57b94675750a&amp;scene=178#rd" target="_blank" rel="noopener">揭秘suspend修饰符</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Kotlin/">Kotlin</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/05/02/JVM相关合集整理/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM相关合集整理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/03/31/TCP-IP协议相关/">
                        <span class="hidden-mobile">TCP/IP协议相关</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>









  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
