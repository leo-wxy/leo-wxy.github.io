<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>JVM相关合集整理 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/dracula.min.css">


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">



<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                JVM相关合集整理
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-05-02 10:02">
                    2020年5月2日 上午
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    3.3k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    36
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <blockquote>
<p>本章主要针对JVM基础知识的整理以及拓展</p>
</blockquote>
<h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><!--1.8前后有差异，需要列出来-->
<blockquote>
<p>JVM在执行Java程序的过程中会把管理的内存分为若干个不同的数据区域。</p>
<p><strong>JDK1.8前后分区略有不同</strong></p>
</blockquote>
<div align="center"><br><img style="margin-right:30px" src="/images/jvm/jvm1.8前.jpg" srcset="/img/loading.gif" width="35%" alt="JDK 1.8之前"><img style="margin-left:30px" src="/images/jvm/jvm1.8.jpg" srcset="/img/loading.gif" width="50%" alt="JDK1.8之后"><br></div>



<p>根据上述两图，运行时数据区域按照<code>线程是否私有</code>分为两部分：</p>
<ul>
<li><code>线程私有</code>：程序计数器、虚拟机栈、本地方法栈</li>
<li><code>线程共享</code>：堆、方法区</li>
</ul>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote>
<p><strong>线程私有</strong>，当前线程所执行的字节码的<code>行号指示器</code>，记录当前线程执行的位置。</p>
</blockquote>
<p>程序计数器主要有两个作用：</p>
<ol>
<li>字节码解释器通过改变<code>程序计数器</code>来依次读取指令，从而实现代码的流程控制</li>
<li>在多线程的情况下，<code>程序计数器</code>用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到何处。<ul>
<li>线程执行Java方法时，计数器记录了<code>当前正在执行的字节码指令地址</code>。</li>
<li>线程执行Native方法时，计数器值为<code>Undefined</code>。</li>
</ul>
</li>
</ol>
<p><strong><code>程序计数器</code>是唯一一个不会出现<code>OutOfMemory</code>的内存区域，它的生命周期随着线程的创建而创建，随线程的结束而死亡。</strong></p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote>
<p><strong>线程私有</strong>，描述<code>Java方法执行的内存模型</code>，每次方法调用的数据都是通过栈传递的。</p>
</blockquote>
<p>Java内存可以粗糙的分为<strong>堆内存(Heap)</strong>和<strong>栈内存(Stack)</strong>，栈内存位于虚拟机栈上。</p>
<p><strong>栈内存</strong>：存储<code>局部变量</code>和<code>方法调用</code></p>
<p><strong>堆内存</strong>：存储<code>Java中的对象(无论成员变量、局部变量、类变量)</code></p>
<p><em>如果局部变量是<code>基本数据类型</code>，那局部变量的值存储于栈上；若局部变量是<code>对象</code>，该变量的引用存在于栈上，但是对象存储于堆中。</em></p>
<blockquote>
<p>基本数据类型：<code>boolean、byte、char、short、int、float、long、double</code></p>
</blockquote>
<p><br></p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><code>虚拟机栈</code>由一个个<strong>栈帧</strong>组成，<code>栈帧</code>也叫<code>过程活动记录</code>，是用于支持虚拟机调用/执行程序方法的数据结构，记录了每一个方法从调用直至执行完成的过程。<em>栈帧随着方法的调用而创建，执行完成而销毁。</em></p>
<p><code>栈帧</code>主要由以下四部分组成：</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/栈帧结构.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-异常指令" title="操作指令-异常指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><blockquote>
<p>用于存储方法参数和定义在方法体的局部变量，包含了编译器可知的各种基本数据类型、对象引用、returnAddress类型。</p>
</blockquote>
<p>局部变量表的大小在编译期就已经确定了，对应了字节码中<code>Code属性表中的max_locals</code>。</p>
<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><blockquote>
<p>通过入栈、出栈操作来完成一次数据访问，本质是一个<strong>临时数据存储区域</strong>。</p>
<p>是一个后入先出栈(LIFO)</p>
</blockquote>
<p>操作数栈的大小在编译期已经确定，对应字节码中的<code>Code属性表中的max_stacks</code></p>
<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><blockquote>
<p>为了支持方法调用过程中的动态连接，调用编译期无法被确定的方法。</p>
<p><strong>在运行期将符号引用转换为所在内存地址的直接引用。</strong></p>
</blockquote>
<p>静态链接：被调用的目标方法在编译期可知且运行期保持不变时，那么这种情况下调用方法的符号引用可以转换为直接引用。</p>
<h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5><blockquote>
<p>记录方法被调用的位置，可以在方法执行结束后回到被调用处继续向下执行程序。</p>
</blockquote>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ul>
<li><strong>正常退出</strong>：方法中的代码正常执行完成，或者遇到任意一个方法返回的字节码指令(<code>return</code>)并退出，将返回值传递给上层的方法调用者，没有抛出任何异常。</li>
<li><strong>异常退出</strong>：执行方法过程中出现异常，并且没有处理该异常，导致方法退出。</li>
</ul>
<p>一般方法退出正常值为<code>调用者的PC计数器数值</code>。</p>
<p><br></p>
<p>在<code>虚拟机栈</code>会出现两种异常情况：</p>
<ul>
<li><code>StackOverflowError</code>：请求栈深度超出虚拟机栈说允许的深度时抛出</li>
<li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote>
<p><strong>线程私有</strong>，虚拟机执行Native方法的服务，和<code>虚拟机栈</code>功能类似。</p>
</blockquote>
<p>在<code>本地方法栈</code>会出现两种异常情况：</p>
<ul>
<li><code>StackOverflowError</code>：请求栈深度超出虚拟机栈说允许的深度时抛出</li>
<li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li>
</ul>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><strong>Java堆</strong></h3><blockquote>
<p><strong>线程共享</strong></p>
<p>JVM所管理内存中的最大一块，该区域唯一目的是<strong>存放对象实例</strong>，几乎所有对象实例都在这里分配内存。</p>
<p>因此他也是垃圾收集管理的主要区域，因此也被称作<code>GC堆</code>。</p>
</blockquote>
<p>由于现在基本都采用分代垃圾回收算法，按照对象存储时间的不同，还可以细分为<code>新生代(分为Eden和Survivor，大致比例为8:1:1)</code>和<code>老年代</code>。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/Java堆结构.jpg" srcset="/img/loading.gif" class="full-image" alt="Java堆结构" title="Java堆结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>在<code>Java堆</code>中会出现以下异常情况：</p>
<ul>
<li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li>
</ul>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>JVM堆内存溢出后，其他线程是否继续正常工作？</p>
<p>发生OOM之后会不会影响其他线程正常工作需要具体的场景分析。一般情况下，发生OOM的现场都会被终结，然后该线程持有的对象占用就会被GC，释放内存。</p>
<h3 id="方法区-版本区别较大"><a href="#方法区-版本区别较大" class="headerlink" title="方法区(版本区别较大)"></a>方法区(版本区别较大)</h3><blockquote>
<p><strong>线程共享</strong></p>
<p>用于存储<code>已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据</code>。</p>
<p><code>方法区</code>还有一个别名叫做<code>Non-Heap</code>，可以与上述的<code>Java堆</code>进行区分。</p>
</blockquote>
<h4 id="JDK-1-8前"><a href="#JDK-1-8前" class="headerlink" title="JDK 1.8前"></a>JDK 1.8前</h4><p>那时<code>方法区</code>也被称为<code>永久代</code>，GC在该区域是比较少出现的，但是不代表不进行GC操作。常见的异常为<code>java.lang.OutOfMemoryError:PermGen space</code>表示了<code>永久代异常信息</code>。</p>
<h4 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h4><p>这时<code>永久代</code>已被移除，代替它的是<code>元空间(meta space)</code>，<code>元空间</code>位于<code>直接内存</code>中，因此<code>元空间</code>的最大占用就是系统的内存空间，用户可通过<code>-XX:MetaspaceSize</code>设置<code>元空间</code>最大占用，避免占用过量内存。</p>
<h4 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h4><ul>
<li>由于<code>永久代</code>内存经常会溢出，导致OOM发生，因此JVM开发者希望这块内存可以被更灵活的管理，减少OOM错误的出现。</li>
<li><code>永久代</code>会为GC带来不必要的复杂度，并且回收效率偏低。</li>
<li><code>永久代</code>的大小难以确定，太小容易造成<code>方法区</code>发生OOM</li>
</ul>
<p>在<code>方法区</code>会出现两种异常情况：</p>
<ul>
<li><code>StackOverflowError</code>：请求栈深度超出虚拟机栈说允许的深度时抛出</li>
<li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li>
</ul>
<h4 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h4><p>如何使方法区发生OOM?</p>
<p>借助<code>CGLib</code>这类字节码技术，不断动态生成新类，新方法。或者使用不同的ClassLoader去加载同一个类(<code>不同的ClassLoader加载的同一个类也是不同的</code>)</p>
<ul>
<li><p>JDK1.8之前</p>
<p>可以通过配置<code>-XX:Maxpermsize</code>设置一个较小的值</p>
</li>
<li><p>JDK1.8</p>
<p>上述方法由于移除了<code>永久代</code>无法生效，可以通过配置<code>-XX:MetaspaceSize</code>一个较小的值，也可以模拟这个异常。</p>
</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><!--String.intern()来举例-->
<blockquote>
<p>Java中常量池的概念主要有三个：</p>
<ul>
<li><code>字符串常量池</code></li>
<li><code>Class文件常量池</code></li>
<li><code>运行时常量池</code></li>
</ul>
<p>其中<code>Class文件常量池</code>存在于class文件中，不受JDK版本影响。</p>
<p><code>字符串常量池</code>在JDK1.6前位于<code>方法区</code>中，之后的版本存在于<code>Java堆</code>上</p>
<p><code>运行时常量池</code>在JDk1.7前位于<code>方法区</code>中，之后的版本存在于<code>元空间</code>上</p>
</blockquote>
<h4 id="Class文件常量池-Class-Constant-Pool"><a href="#Class文件常量池-Class-Constant-Pool" class="headerlink" title="Class文件常量池(Class Constant Pool)"></a>Class文件常量池(<code>Class Constant Pool</code>)</h4><blockquote>
<p>class文件除了包含<code>类的版本、字段、方法、接口等描述信息</code>外，还有一项信息就是<code>Class文件常量池</code>，用于存放编译器生成的<code>各种字面量和符号引用</code>。</p>
</blockquote>
<h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><blockquote>
<p>接近Java语言层面的常量</p>
</blockquote>
<ul>
<li><p>文本字符串</p>
<div class="hljs"><pre><code class="hljs java">public String s = "abc";//其中abc为字面量

对应字节码常量池数据为
#31 = Utf8               abc</code></pre></div>
</li>
<li><p>8种基本类型的值</p>
<div class="hljs"><pre><code class="hljs java">public int value = 1;

对应字节码常量池数据为
#7 = Utf8               value
#8 = Utf8               I</code></pre></div>
<p>常量池只保留了字段描述符(I)和字段名称(value)，字面量不存在于常量池中。</p>
</li>
<li><p>用<code>final</code>修饰的成员变量，包括<code>静态变量、实例变量，局部变量</code></p>
<div class="hljs"><pre><code class="hljs java">public final static int f = 2;//其中2为字面量

对应字节码常量池数据为
#11 = Integer               2</code></pre></div>
</li>
</ul>
<h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><blockquote>
<p>用一组符号描述所引用的目标，符号可以是任何形式的字面量。</p>
</blockquote>
<ul>
<li><p>类和接口的全限定名</p>
<div class="hljs"><pre><code class="hljs java">public String s = "abc";

对应字节码常量池数据为
#5 = Class              #10            // java/lang/String
#10 = Utf8              Ljava/lang/String;</code></pre></div>
<p>其中<code>String</code>对应全限定名为<code>java/lang/String</code>存储于常量池中</p>
<p><strong>主要用于在运行时解析得到类的直接引用</strong></p>
</li>
</ul>
<ul>
<li><p>字段的名称和描述符</p>
<p>字段：类或接口中声明的变量，包括类级别变量和实例级的变量</p>
<div class="hljs"><pre><code class="hljs java">public int value = 1;

对应字节码常量池数据为
#4 = Fieldref           #5.#32         // JavaBasicKnowledge/JavaBean.value:I
 #5 = Class              #33            // JavaBasicKnowledge/JavaBean
 #32 = NameAndType       #7:#8          // value:I

 #7 = Utf8               value
 #8 = Utf8               I</code></pre></div>
<p><em>对于方法中的局部变量名，class常量池中仅仅保存字段名</em></p>
<div class="hljs"><pre><code class="hljs java">public void XX(int v)&#123;
   int temp = 3;
&#125;

对应字节码常量池数据为
 #23 = Utf8               v
 #24 = Utf8               temp</code></pre></div>
</li>
</ul>
<ul>
<li><p>方法的名称和描述符</p>
<p>保存的是<code>方法名、参数类型+返回值</code></p>
<div class="hljs"><pre><code class="hljs java">public void XX(int v)&#123;
...
&#125;

对应字节码常量池数据为
  #21 = Utf8               XX  //方法名
  #22 = Utf8               (I)V //参数类型+返回值</code></pre></div>
</li>
</ul>
<h4 id="字符串常量池-String-Constant-Pool"><a href="#字符串常量池-String-Constant-Pool" class="headerlink" title="字符串常量池(String Constant Pool)"></a>字符串常量池(<code>String Constant Pool</code>)</h4><blockquote>
<p>在JDK1.7及之后版本中，<code>字符串常量池</code>被移动到<code>Java堆</code>中(可能是因为方法区的内存空间太小)。</p>
<ul>
<li><p>JDK1.7之前</p>
<p><code>字符串常量池</code>的位置在<code>方法区</code>，此时存储的是<strong>字符串对象</strong>。</p>
</li>
<li><p>JDK1.7及之后</p>
<p>字符串常量池中的内容是在类加载完成，经过<code>验证、准备</code>阶段之后在<code>Java堆</code>中生成字符串对象实例，然后将该对象实例引用值存在<code>字符串常量池</code>中。<strong>字符串常量池中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间进行存放的。</strong></p>
</li>
</ul>
</blockquote>
<p>在HotSpot VM里实现的<code>String Pool</code>对应一个<code>StringTable</code>类，实际是一个Hash表，默认值大小长度为<code>1009</code>(如果放入过多，导致Hash冲突使链表变长，导致查询性能大幅下降)。该<code>StringTable</code>在每个VM的实例只有一份，被所有的类共享。</p>
<p>在JDK1.7版本中，<code>StringTable</code>长度可以通过配置参数指定——<code>-XX:StringTableSize=${num}</code>指定长度。</p>
<h5 id="创建字符串对象"><a href="#创建字符串对象" class="headerlink" title="创建字符串对象"></a>创建字符串对象</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 编译期就已经确定该字面量，会直接进入class文件常量池中，在字符串常量池中会保存一个引用</span>
String s0 = <span class="hljs-string">"Hello"</span>;
<span class="hljs-comment">// 调用了String的构造函数，创建的字符串对象是在堆内存上</span>
String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Hello"</span>);</code></pre></div>
<h5 id="字面量何时进入常量池"><a href="#字面量何时进入常量池" class="headerlink" title="字面量何时进入常量池"></a>字面量何时进入常量池</h5><ol>
<li>加载类的时候，那些字面量会进入到当前类的<code>运行时常量池</code>，不会进入全局的<code>字符串常量池</code>中</li>
<li>当字面量赋值的时候，会翻译成字节码中的<code>ldc</code>指令，将常量从常量池中推送至栈顶。</li>
</ol>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><blockquote>
<p>在JDK1.7及之后的版本已将<code>运行时常量池</code>从<code>方法区</code>移了出来，在<code>Java堆</code>中开辟一块区域存放运行时常量池。</p>
<p>为了<strong>存储class文件常量池中的符号信息</strong>，在<code>解析</code>的时候会去查询<code>字符串常量池</code>，以保证运行时常量池所引用的字符串与<code>字符串常量池</code>中是一致的。</p>
</blockquote>
<p>JVM在执行某个类的时候，必须经过<strong>加载、链接(验证，准备，解析)、初始化</strong>过程。</p>
<p>当类执行<code>加载</code>过程后，JVM将<code>class常量池</code>中的内容存放到<code>运行时常量池</code>中，已知<code>class文件常量池</code>中存储的内容是<code>字面量与符号引用</code>。</p>
<p><code>准备</code>阶段在<code>Java堆</code>中生成字符串的实例对象，将生成的实例对象引用放置于<code>字符串常量池</code>。</p>
<p><code>解析</code>阶段将<code>class文件常量池</code>中的<code>符号引用</code>翻译成<code>直接引用</code>也是存储于<code>运行时常量池</code>中。</p>
<h5 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h5><p>Java规范并不要求常量只在运行时才能产生，也就是表示<em>运行时常量池的内容不一定都来自于class文件常量池</em>，在运行时可以通过代码生成常量放置于<code>运行时常量池</code>中，例如<code>String.intern()</code></p>
<h5 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h5><blockquote>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h2 id="Java对象创建过程以及访问方式"><a href="#Java对象创建过程以及访问方式" class="headerlink" title="Java对象创建过程以及访问方式"></a>Java对象创建过程以及访问方式</h2><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h2 id="JVM内存分配策略"><a href="#JVM内存分配策略" class="headerlink" title="JVM内存分配策略"></a>JVM内存分配策略</h2><h2 id="JVM垃圾回收机制-GC"><a href="#JVM垃圾回收机制-GC" class="headerlink" title="JVM垃圾回收机制(GC)"></a>JVM垃圾回收机制(GC)</h2><h2 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h2><h2 id="Class文件结构-字节码"><a href="#Class文件结构-字节码" class="headerlink" title="Class文件结构(字节码)"></a>Class文件结构(字节码)</h2><h2 id="DVM-amp-ART-Android虚拟机"><a href="#DVM-amp-ART-Android虚拟机" class="headerlink" title="DVM&amp;ART(Android虚拟机)"></a>DVM&amp;ART(Android虚拟机)</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://cloud.tencent.com/developer/article/1450501" target="_blank" rel="noopener">彻底弄懂Java中的常量池</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JVM/">JVM</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/05/02/Java线程相关合集整理/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java线程相关合集整理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/03/31/TCP-IP协议相关/">
                        <span class="hidden-mobile">TCP/IP协议相关</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
