<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content="">
  <title>JVM相关合集整理 - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css">


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">



<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                JVM相关合集整理
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-05-02 10:02">
                    2020年5月2日 上午
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    16.1k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    178
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <blockquote>
<p>本章主要针对JVM基础知识的整理以及拓展</p>
</blockquote>
<h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><!--1.8前后有差异，需要列出来-->
<blockquote>
<p>JVM在执行Java程序的过程中会把管理的内存分为若干个不同的数据区域。</p>
<p><strong>JDK1.8前后分区略有不同</strong></p>
</blockquote>
<div align="center"><br><img style="margin-right:30px" src="/images/jvm/jvm1.8前.jpg" srcset="/img/loading.gif" width="35%" alt="JDK 1.8之前"><img style="margin-left:30px" src="/images/jvm/jvm1.8.jpg" srcset="/img/loading.gif" width="50%" alt="JDK1.8之后"><br></div>



<p>根据上述两图，运行时数据区域按照<code>线程是否私有</code>分为两部分：</p>
<ul>
<li><code>线程私有</code>：程序计数器、虚拟机栈、本地方法栈</li>
<li><code>线程共享</code>：堆、方法区</li>
</ul>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote>
<p><strong>线程私有</strong>，当前线程所执行的字节码的<code>行号指示器</code>，记录当前线程执行的位置。</p>
</blockquote>
<p>程序计数器主要有两个作用：</p>
<ol>
<li>字节码解释器通过改变<code>程序计数器</code>来依次读取指令，从而实现代码的流程控制</li>
<li>在多线程的情况下，<code>程序计数器</code>用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到何处。<ul>
<li>线程执行Java方法时，计数器记录了<code>当前正在执行的字节码指令地址</code>。</li>
<li>线程执行Native方法时，计数器值为<code>Undefined</code>。</li>
</ul>
</li>
</ol>
<p><strong><code>程序计数器</code>是唯一一个不会出现<code>OutOfMemory</code>的内存区域，它的生命周期随着线程的创建而创建，随线程的结束而死亡。</strong></p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote>
<p><strong>线程私有</strong>，描述<code>Java方法执行的内存模型</code>，每次方法调用的数据都是通过栈传递的。</p>
</blockquote>
<p>Java内存可以粗糙的分为<strong>堆内存(Heap)</strong>和<strong>栈内存(Stack)</strong>，栈内存位于虚拟机栈上。</p>
<p><strong>栈内存</strong>：存储<code>局部变量</code>和<code>方法调用</code></p>
<p><strong>堆内存</strong>：存储<code>Java中的对象(无论成员变量、局部变量、类变量)</code></p>
<p><em>如果局部变量是<code>基本数据类型</code>，那局部变量的值存储于栈上；若局部变量是<code>对象</code>，该变量的引用存在于栈上，但是对象存储于堆中。</em></p>
<blockquote>
<p>基本数据类型：<code>boolean、byte、char、short、int、float、long、double</code></p>
</blockquote>
<p><br></p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><code>虚拟机栈</code>由一个个<strong>栈帧</strong>组成，<code>栈帧</code>也叫<code>过程活动记录</code>，是用于支持虚拟机调用/执行程序方法的数据结构，记录了每一个方法从调用直至执行完成的过程。<em>栈帧随着方法的调用而创建，执行完成而销毁。</em></p>
<p><code>栈帧</code>主要由以下四部分组成：</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/栈帧结构.png" srcset="/img/loading.gif" class="full-image" alt="操作指令-异常指令" title="操作指令-异常指令"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><blockquote>
<p>用于存储方法参数和定义在方法体的局部变量，包含了编译器可知的各种基本数据类型、对象引用、returnAddress类型。</p>
</blockquote>
<p>局部变量表的大小在编译期就已经确定了，对应了字节码中<code>Code属性表中的max_locals</code>。</p>
<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><blockquote>
<p>通过入栈、出栈操作来完成一次数据访问，本质是一个<strong>临时数据存储区域</strong>。</p>
<p>是一个后入先出栈(LIFO)</p>
</blockquote>
<p>操作数栈的大小在编译期已经确定，对应字节码中的<code>Code属性表中的max_stacks</code></p>
<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><blockquote>
<p>为了支持方法调用过程中的动态连接，调用编译期无法被确定的方法。</p>
<p><strong>在运行期将符号引用转换为所在内存地址的直接引用。</strong></p>
</blockquote>
<p>静态链接：被调用的目标方法在编译期可知且运行期保持不变时，那么这种情况下调用方法的符号引用可以转换为直接引用。</p>
<h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5><blockquote>
<p>记录方法被调用的位置，可以在方法执行结束后回到被调用处继续向下执行程序。</p>
</blockquote>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ul>
<li><strong>正常退出</strong>：方法中的代码正常执行完成，或者遇到任意一个方法返回的字节码指令(<code>return</code>)并退出，将返回值传递给上层的方法调用者，没有抛出任何异常。</li>
<li><strong>异常退出</strong>：执行方法过程中出现异常，并且没有处理该异常，导致方法退出。</li>
</ul>
<p>一般方法退出正常值为<code>调用者的PC计数器数值</code>。</p>
<p><br></p>
<p>在<code>虚拟机栈</code>会出现两种异常情况：</p>
<ul>
<li><code>StackOverflowError</code>：请求栈深度超出虚拟机栈说允许的深度时抛出</li>
<li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote>
<p><strong>线程私有</strong>，虚拟机执行Native方法的服务，和<code>虚拟机栈</code>功能类似。</p>
</blockquote>
<p>在<code>本地方法栈</code>会出现两种异常情况：</p>
<ul>
<li><code>StackOverflowError</code>：请求栈深度超出虚拟机栈说允许的深度时抛出</li>
<li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li>
</ul>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><strong>Java堆</strong></h3><blockquote>
<p><strong>线程共享</strong></p>
<p>JVM所管理内存中的最大一块，该区域唯一目的是<strong>存放对象实例</strong>，几乎所有对象实例都在这里分配内存。</p>
<p>因此他也是垃圾收集管理的主要区域，因此也被称作<code>GC堆</code>。</p>
</blockquote>
<p>由于现在基本都采用分代垃圾回收算法，按照对象存储时间的不同，还可以细分为<code>新生代(分为Eden和Survivor，大致比例为8:1:1)</code>和<code>老年代</code>。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/Java堆结构.jpg" srcset="/img/loading.gif" class="full-image" alt="Java堆结构" title="Java堆结构"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>在<code>Java堆</code>中会出现以下异常情况：</p>
<ul>
<li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li>
</ul>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>JVM堆内存溢出后，其他线程是否继续正常工作？</p>
<p>发生OOM之后会不会影响其他线程正常工作需要具体的场景分析。一般情况下，发生OOM的现场都会被终结，然后该线程持有的对象占用就会被GC，释放内存。</p>
<h3 id="方法区-版本区别较大"><a href="#方法区-版本区别较大" class="headerlink" title="方法区(版本区别较大)"></a>方法区(版本区别较大)</h3><blockquote>
<p><strong>线程共享</strong></p>
<p>用于存储<code>已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据</code>。</p>
<p><code>方法区</code>还有一个别名叫做<code>Non-Heap</code>，可以与上述的<code>Java堆</code>进行区分。</p>
</blockquote>
<h4 id="JDK-1-8前"><a href="#JDK-1-8前" class="headerlink" title="JDK 1.8前"></a>JDK 1.8前</h4><p>那时<code>方法区</code>也被称为<code>永久代</code>，GC在该区域是比较少出现的，但是不代表不进行GC操作。常见的异常为<code>java.lang.OutOfMemoryError:PermGen space</code>表示了<code>永久代异常信息</code>。</p>
<h4 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h4><p>这时<code>永久代</code>已被移除，代替它的是<code>元空间(meta space)</code>，<code>元空间</code>位于<code>直接内存</code>中，因此<code>元空间</code>的最大占用就是系统的内存空间，用户可通过<code>-XX:MetaspaceSize</code>设置<code>元空间</code>最大占用，避免占用过量内存。</p>
<h4 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h4><ul>
<li>由于<code>永久代</code>内存经常会溢出，导致OOM发生，因此JVM开发者希望这块内存可以被更灵活的管理，减少OOM错误的出现。</li>
<li><code>永久代</code>会为GC带来不必要的复杂度，并且回收效率偏低。</li>
<li><code>永久代</code>的大小难以确定，太小容易造成<code>方法区</code>发生OOM</li>
</ul>
<p>在<code>方法区</code>会出现两种异常情况：</p>
<ul>
<li><code>StackOverflowError</code>：请求栈深度超出虚拟机栈说允许的深度时抛出</li>
<li><code>OutOfMemoryError</code>：无法申请到足够的内存时抛出</li>
</ul>
<h4 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h4><p>如何使方法区发生OOM?</p>
<p>借助<code>CGLib</code>这类字节码技术，不断动态生成新类，新方法。或者使用不同的ClassLoader去加载同一个类(<code>不同的ClassLoader加载的同一个类也是不同的</code>)</p>
<ul>
<li><p>JDK1.8之前</p>
<p>可以通过配置<code>-XX:Maxpermsize</code>设置一个较小的值</p>
</li>
<li><p>JDK1.8</p>
<p>上述方法由于移除了<code>永久代</code>无法生效，可以通过配置<code>-XX:MetaspaceSize</code>一个较小的值，也可以模拟这个异常。</p>
</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><!--String.intern()来举例-->
<blockquote>
<p>Java中常量池的概念主要有三个：</p>
<ul>
<li><code>字符串常量池</code></li>
<li><code>Class文件常量池</code></li>
<li><code>运行时常量池</code></li>
</ul>
<p>其中<code>Class文件常量池</code>存在于class文件中，不受JDK版本影响。</p>
<p><code>字符串常量池</code>在JDK1.6前位于<code>方法区</code>中，之后的版本存在于<code>Java堆</code>上</p>
<p><code>运行时常量池</code>在JDk1.7前位于<code>方法区</code>中，之后的版本存在于<code>元空间</code>上</p>
</blockquote>
<h4 id="Class文件常量池-Class-Constant-Pool"><a href="#Class文件常量池-Class-Constant-Pool" class="headerlink" title="Class文件常量池(Class Constant Pool)"></a>Class文件常量池(<code>Class Constant Pool</code>)</h4><blockquote>
<p>class文件除了包含<code>类的版本、字段、方法、接口等描述信息</code>外，还有一项信息就是<code>Class文件常量池</code>，用于存放编译器生成的<code>各种字面量和符号引用</code>。</p>
</blockquote>
<h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><blockquote>
<p>接近Java语言层面的常量</p>
</blockquote>
<ul>
<li><p>文本字符串</p>
<div class="hljs"><pre><code class="hljs java">public String s = "abc";//其中abc为字面量

对应字节码常量池数据为
#31 = Utf8               abc</code></pre></div>
</li>
<li><p>8种基本类型的值</p>
<div class="hljs"><pre><code class="hljs java">public int value = 1;

对应字节码常量池数据为
#7 = Utf8               value
#8 = Utf8               I</code></pre></div>
<p>常量池只保留了字段描述符(I)和字段名称(value)，字面量不存在于常量池中。</p>
</li>
<li><p>用<code>final</code>修饰的成员变量，包括<code>静态变量、实例变量，局部变量</code></p>
<div class="hljs"><pre><code class="hljs java">public final static int f = 2;//其中2为字面量

对应字节码常量池数据为
#11 = Integer               2</code></pre></div>
</li>
</ul>
<h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><blockquote>
<p>用一组符号描述所引用的目标，符号可以是任何形式的字面量。</p>
</blockquote>
<ul>
<li><p>类和接口的全限定名</p>
<div class="hljs"><pre><code class="hljs java">public String s = "abc";

对应字节码常量池数据为
#5 = Class              #10            // java/lang/String
#10 = Utf8              Ljava/lang/String;</code></pre></div>
<p>其中<code>String</code>对应全限定名为<code>java/lang/String</code>存储于常量池中</p>
<p><strong>主要用于在运行时解析得到类的直接引用</strong></p>
</li>
</ul>
<ul>
<li><p>字段的名称和描述符</p>
<p>字段：类或接口中声明的变量，包括类级别变量和实例级的变量</p>
<div class="hljs"><pre><code class="hljs java">public int value = 1;

对应字节码常量池数据为
#4 = Fieldref           #5.#32         // JavaBasicKnowledge/JavaBean.value:I
 #5 = Class              #33            // JavaBasicKnowledge/JavaBean
 #32 = NameAndType       #7:#8          // value:I

 #7 = Utf8               value
 #8 = Utf8               I</code></pre></div>
<p><em>对于方法中的局部变量名，class常量池中仅仅保存字段名</em></p>
<div class="hljs"><pre><code class="hljs java">public void XX(int v)&#123;
   int temp = 3;
&#125;

对应字节码常量池数据为
 #23 = Utf8               v
 #24 = Utf8               temp</code></pre></div>
</li>
</ul>
<ul>
<li><p>方法的名称和描述符</p>
<p>保存的是<code>方法名、参数类型+返回值</code></p>
<div class="hljs"><pre><code class="hljs java">public void XX(int v)&#123;
...
&#125;

对应字节码常量池数据为
  #21 = Utf8               XX  //方法名
  #22 = Utf8               (I)V //参数类型+返回值</code></pre></div>
</li>
</ul>
<h4 id="字符串常量池-String-Constant-Pool"><a href="#字符串常量池-String-Constant-Pool" class="headerlink" title="字符串常量池(String Constant Pool)"></a>字符串常量池(<code>String Constant Pool</code>)</h4><blockquote>
<p>在JDK1.7及之后版本中，<code>字符串常量池</code>被移动到<code>Java堆</code>中(可能是因为方法区的内存空间太小)。</p>
<ul>
<li><p>JDK1.7之前</p>
<p><code>字符串常量池</code>的位置在<code>方法区</code>，此时存储的是<strong>字符串对象</strong>。</p>
</li>
<li><p>JDK1.7及之后</p>
<p>字符串常量池中的内容是在类加载完成，经过<code>验证、准备</code>阶段之后在<code>Java堆</code>中生成字符串对象实例，然后将该对象实例引用值存在<code>字符串常量池</code>中。<strong>字符串常量池中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间进行存放的。</strong></p>
</li>
</ul>
</blockquote>
<p>在HotSpot VM里实现的<code>String Pool</code>对应一个<code>StringTable</code>类，实际是一个Hash表，默认值大小长度为<code>1009</code>(如果放入过多，导致Hash冲突使链表变长，导致查询性能大幅下降)。该<code>StringTable</code>在每个VM的实例只有一份，被所有的类共享。</p>
<p>在JDK1.7版本中，<code>StringTable</code>长度可以通过配置参数指定——<code>-XX:StringTableSize=${num}</code>指定长度。</p>
<h5 id="创建字符串对象"><a href="#创建字符串对象" class="headerlink" title="创建字符串对象"></a>创建字符串对象</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 编译期就已经确定该字面量，会直接进入class文件常量池中，在字符串常量池中会保存一个引用</span>
String s0 = <span class="hljs-string">"Hello"</span>;
<span class="hljs-comment">// 调用了String的构造函数，创建的字符串对象是在堆内存上</span>
String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Hello"</span>);</code></pre></div>
<h5 id="字面量何时进入常量池"><a href="#字面量何时进入常量池" class="headerlink" title="字面量何时进入常量池"></a>字面量何时进入常量池</h5><ol>
<li>加载类的时候，那些字面量会进入到当前类的<code>运行时常量池</code>，不会进入全局的<code>字符串常量池</code>中</li>
<li>当字面量赋值的时候，会翻译成字节码中的<code>ldc</code>指令，将常量从常量池中推送至栈顶。</li>
</ol>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><blockquote>
<p>在JDK1.7及之后的版本已将<code>运行时常量池</code>从<code>方法区</code>移了出来，在<code>Java堆</code>中开辟一块区域存放运行时常量池。</p>
<p>为了<strong>存储class文件常量池中的符号信息</strong>，在<code>解析</code>的时候会去查询<code>字符串常量池</code>，以保证运行时常量池所引用的字符串与<code>字符串常量池</code>中是一致的。</p>
</blockquote>
<p>JVM在执行某个类的时候，必须经过<strong>加载、链接(验证，准备，解析)、初始化</strong>过程。</p>
<p>当类执行<code>加载</code>过程后，JVM将<code>class常量池</code>中的内容存放到<code>运行时常量池</code>中，已知<code>class文件常量池</code>中存储的内容是<code>字面量与符号引用</code>。</p>
<p><code>准备</code>阶段在<code>Java堆</code>中生成字符串的实例对象，将生成的实例对象引用放置于<code>字符串常量池</code>。</p>
<p><code>解析</code>阶段将<code>class文件常量池</code>中的<code>符号引用</code>翻译成<code>直接引用</code>也是存储于<code>运行时常量池</code>中。</p>
<h5 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h5><p>Java规范并不要求常量只在运行时才能产生，也就是表示<em>运行时常量池的内容不一定都来自于class文件常量池</em>，在运行时可以通过代码生成常量放置于<code>运行时常量池</code>中，例如<code>String.intern()</code></p>
<h5 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h5><blockquote>
<ul>
<li><p>JDK 1.7之前</p>
<p><code>intern</code>的处理是：<strong>先判断字符串是否存在于<code>字符串常量池</code>中，如果存在直接返回该常量；如果没有找到，则将字符串常量加入到<code>字符串常量池</code>中。</strong></p>
</li>
<li><p>JDK 1.7及之后</p>
<p><code>intern</code>的处理是：先判断字符串是否存在于<code>字符串常量池</code>中，如果存在直接返回该常量；如果没找到，表示该字符串常量在堆中，然后把<code>Java堆</code>该对象的引用加入到<code>字符串常量池</code>中，以后别人拿到的就是该字符串常量的引用，实际字符串存在于堆中。</p>
</li>
</ul>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><blockquote>
<p>直接内存并不是JVM的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，可能导致OOM的出现。</p>
</blockquote>
<p>在JDK1.4新加入了<code>NIO</code>类，引入一种基于<code>通道(Channel)</code>和<code>缓冲区(Buffer)</code>的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存在<code>Java堆</code>的对象作为这块内存的应用进行操作。</p>
<h2 id="Java对象创建过程以及访问方式"><a href="#Java对象创建过程以及访问方式" class="headerlink" title="Java对象创建过程以及访问方式"></a>Java对象创建过程以及访问方式</h2><h3 id="Java对象创建过程"><a href="#Java对象创建过程" class="headerlink" title="Java对象创建过程"></a>Java对象创建过程</h3><p>在Java语言层面上，创建对象只需要调用<code>new</code>关键字。</p>
<p>在JVM中，实际需要执行以下几步：</p>
<h4 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h4><p>遇到一条<code>new</code>指令时，先检查指令对应的参数是否在<code>常量池</code>中可以定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，需要执行相应的<code>类加载过程</code>。</p>
<h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p><code>类加载检查</code>通过后，JVM将为新生对象<code>分配内存</code>，对象所需大小在类加载完成后便可以确定。</p>
<p>这块内存由<code>Java堆</code>划分出来。内存的分配方式由<strong>Java堆中内存是否规整</strong>决定，而<code>内存是否规整</code>由<strong>采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<ul>
<li><p><strong>指针碰撞</strong></p>
<blockquote>
<p><code>Java堆内存规整</code>，把指针向空闲空间挪动对象大小的距离</p>
</blockquote>
<p>对应GC收集器：Serial、ParNew</p>
<p><strong>关键看GC收集器采用了<code>标记-整理、标记-压缩、复制</code>算法进行回收</strong></p>
</li>
<li><p><strong>空闲列表</strong></p>
<blockquote>
<p><code>Java堆内存不规整</code>，虚拟机维护一个列表记录内存块中的可用区域，在分配内存的时候，找到一块儿足够大的空间划分给对象实例</p>
</blockquote>
<p>对应GC收集器：CMS</p>
<p><strong>关键看GC收集器采用了<code>标记-清除</code>算法进行回收</strong></p>
</li>
</ul>
<h5 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h5><p>创建对象是一个很频繁的事情，就会涉及一个很重要的问题——<strong>线程安全</strong>。作为虚拟机来讲，必须要保证线程安全，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><p><strong>CAS+失败重试</strong></p>
<blockquote>
<p>CAS是乐观锁的一种实现方式</p>
<p>乐观锁：假设没有冲突而去完成某项操作，若发生冲突就重试直到成功为止。</p>
</blockquote>
<p>采用这种方式可以保证更新操作的原子性。</p>
</li>
<li><p><strong>TLAB</strong>(本地线程分配缓存)</p>
<blockquote>
<p>每个线程预先在<code>Java堆</code>中分配一块内存，JVM在给对象分配内存时，首先在<code>TLAB</code>分配。如果分配的对象大于<code>TLAB</code>的剩余内存或<code>TLAB</code>内存已用尽时，再采用上述CAS方式进行内存分配。</p>
</blockquote>
</li>
</ul>
<h4 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h4><p><strong>内存分配完成时，虚拟机需要将分配到的内存空间初始化为零值(不包括对象头)。</strong>这一步操作可以保证对象的实例字段在代码中可以不赋值就直接使用，程序也可以访问到这些字段的数据类型所对应的零值。</p>
<h4 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h4><p><code>初始化零值</code>完成后，<strong>虚拟机要对对象进行必要的设置</strong>。将<code>类的元数据信息、对象的哈希码、对象的GC分代年龄</code>等信息，存放到<code>对象头</code>中。另外根据虚拟机运行状态的不同，如是否启用偏向锁等，对象头都会进行存储。</p>
<p>可以在<code>对象内存布局</code>这节看到对象头相关内容。</p>
<h4 id="执行-lt-init-gt-方法"><a href="#执行-lt-init-gt-方法" class="headerlink" title="执行&lt;init&gt;方法"></a>执行<code>&lt;init&gt;</code>方法</h4><p>从虚拟机角度来说，一个新的对象已经产生了。从代码角度来说，对象才刚开始创建，在执行<code>&lt;init&gt;</code>方法之前，所有的字段都还为零。一般执行完<code>new</code>指令后会接着执行<code>&lt;init&gt;</code>方法，把对象按照意愿进行初始化，这时就产生了一个真正可用的对象。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/Jvm对象创建过程.png" srcset="/img/loading.gif" class="full-image" alt="Jvm对象创建过程" title="Jvm对象创建过程"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>对象内存布局分为以下三块区域：</p>
<h4 id="对象头-Header"><a href="#对象头-Header" class="headerlink" title="对象头(Header)"></a>对象头(Header)</h4><p>必须先了解 HotSpot虚拟机的对象(<strong>对象头部分</strong>)的内存布局：分为两部分</p>
<h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5><p>存储自身的运行时数据，如：<code>HashCode、GC分代年龄和锁信息</code>，这部分数据的长度在32和64位中的JVM中分别为32bit和64bit。<strong>它是实现轻量级锁和偏向锁的关键。</strong></p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/MarkWord.png" srcset="/img/loading.gif" class="full-image" alt="Mark Word" title="Mark Word"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h5 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h5><p>存储指向方法区对象类型数据的指针，如果是数组对象的话，额外会存储数据的长度。JVM通过这个指针来确定该对象是哪个类的实例。</p>
<h4 id="实例数据-Instance-Data"><a href="#实例数据-Instance-Data" class="headerlink" title="实例数据(Instance Data)"></a>实例数据(Instance Data)</h4><p>对象真正存储的有效信息，即在代码里面所定义的各种类型的字段内容。</p>
<h4 id="对齐填充-Padding"><a href="#对齐填充-Padding" class="headerlink" title="对齐填充(Padding)"></a>对齐填充(Padding)</h4><p>并非必然存在的，也没有特别的含义，仅仅起着<strong>占位符</strong>的作用。</p>
<h3 id="Java对象访问方式"><a href="#Java对象访问方式" class="headerlink" title="Java对象访问方式"></a>Java对象访问方式</h3><p>Java程序通过栈上的refrence数据来操作堆上的具体对象。</p>
<h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p><code>Java堆</code>可能会划分一块内存作为句柄池，refrence存储的就是<code>对象的句柄地址</code>，句柄中包含了对象的实例数据与类型数据的各自具体地址信息。</p>
 <span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/get_object_by_handle.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p><strong>refrence中存储的稳定句柄地址，在对象被移动时(例如GC时)只会改变句柄中的实例数据指针，refrence本身不需要修改。</strong></p>
<h4 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h4><p><code>Java堆</code>中对象的内存布局就必须考虑如何设置访问类型数据的相关信息，refrence直接存储的就是<code>对象地址</code>。</p>
 <span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/get_object_direct.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="流程图"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p><strong>最大好处就是速度快，节省了一次指针定位的时间开销。</strong>在HotSpot虚拟机中很常用。</p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><blockquote>
<p>JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为虚拟机的类加载机制。</p>
</blockquote>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载、验证、准备、解析、初始化、使用、卸载</strong>七个阶段，其中<code>准备、解析、初始化</code>称为<strong>连接</strong>。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/class_lifecycle.png" srcset="/img/loading.gif" class="full-image" alt="类的生命周期" title="类的生命周期"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><blockquote>
<p>由JVM自带的类加载器(<code>BootstrapClassLoader根加载器、ExtensionClassLoader拓展加载器、ApplicationClassLoader应用加载器</code>)所加载的类，在虚拟机的生命周期中，都不会被卸载。</p>
<p><strong>只有由用户自定义的类加载器所加载的类是可以被卸载的。</strong></p>
</blockquote>
<p>类卸载的触发条件：</p>
<ul>
<li>该类所有的实例都已被GC，在JVM中不存在任何该类的实例</li>
<li>加载该类的ClassLoader也被GC</li>
<li>该类的Class对象没有被任何地方调用，反射也无法访问该类</li>
</ul>
<p>执行类卸载后，在方法区的二进制数据会被卸载。</p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><blockquote>
<p>类加载过程包括上述的五步：<code>加载、验证、准备、解析、初始化</code>。</p>
</blockquote>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><blockquote>
<p>JVM找到class文件问生成字节流，然后根据字节流创建java.lang.class对象的过程。</p>
</blockquote>
<p>JVM在此过程需要完成三件事：</p>
<ul>
<li>通过一个类的 <code>全限定名(包名+类名)</code>来查找.class文件，并生成二进制字节流(<strong>使用ClassLoader进行加载</strong>)。其中字节码来源不一定是.class文件，也可以是jar包、zip包，甚至是来源于网络的字节流。</li>
<li>将字节流所代表的静态存储结构转化为JVM的特定的数据结构，并存储在<code>方法区</code></li>
<li>在内存中创建一个<code>java.lang.Class</code>类型的对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p>一个非数组类的加载阶段(加载阶段获取二进制字节流的动作)是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式(重写类加载器的<code>findClass()</code>或<code>loadClass()</code>)。</p>
<p>对于数组类而言，数组类本身不通过类加载器创建，由JVM直接在内存中动态创建。</p>
<h5 id="加载时机"><a href="#加载时机" class="headerlink" title="加载时机"></a>加载时机</h5><p>一个项目经过编译之后，往往会产生大量.class文件，程序运行时，JVM不会一次性将这些文件全部加载到内存中，而是有一定的加载时机去进行加载操作。</p>
<h6 id="隐式装载"><a href="#隐式装载" class="headerlink" title="隐式装载"></a>隐式装载</h6><p>在程序运行过程中，当碰到通过<code>new</code>生成对象时，系统会隐式调用ClassLoader装载对应class到内存中(<code>loadClass()</code>)</p>
<div class="hljs"><pre><code class="hljs jaba">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</code></pre></div>
<h6 id="显示装载"><a href="#显示装载" class="headerlink" title="显示装载"></a>显示装载</h6><p>在编写源代码时，主动调用<code>Class.forName()</code>也会进行class装载操作。执行时会默认调用静态代码块<code>static{...}</code>以及分配静态变量存储空间</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; forName(String name, <span class="hljs-comment">/*要加载的Class名字*/</span>
										 <span class="hljs-keyword">boolean</span> initialize,<span class="hljs-comment">/*默认为true,是否需要初始化-调用静态代码快及静态变量初始化*/</span>
                               ClassLoader loader<span class="hljs-comment">/*指定ClassLoader进行加载*/</span>)</code></pre></div>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><blockquote>
<p>确保.class文件的字节流中包含的信息符合虚拟机规范的全部要求，并且不会危及虚拟机本身的安全。</p>
</blockquote>
<p>若代码被反复验证和使用过，可以通过配置<code>-XVerify:none</code>关闭大部分的验证措施，缩短加载时间</p>
<p>主要包含以下四个方面的验证：</p>
<h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><blockquote>
<p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p>
</blockquote>
<p>这一阶段可能包含以下验证点：</p>
<ul>
<li>是否以魔数<code>0xCAFEBABE</code>开头</li>
<li>主次Java版本号是否在当前JVM接受范围内</li>
<li>…</li>
</ul>
<h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><blockquote>
<p>对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java语言规范的要求</p>
</blockquote>
<p>这一阶段可能包含以下验证点：</p>
<ul>
<li>这个类是否有父类(除了 java.lang.Object外，都应该有父类)</li>
<li>这个类是否继承了不允许被继承的类(被final修饰的类)</li>
<li>…</li>
</ul>
<h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><blockquote>
<p>通过数据流分析和控制流分析，确定程序语义是合法、符合逻辑的</p>
</blockquote>
<p>这一阶段可能包含以下验证点：</p>
<ul>
<li>任意时刻操作数栈的数据类型与指令代码序列都配合工作</li>
<li>任何跳转指令都不会跳到方法体以外的的字节码指令中</li>
<li>…</li>
</ul>
<h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><blockquote>
<p>发生于JVM将<code>符号引用</code>转换<code>直接引用</code>的时候。</p>
<p>对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验。通俗来说就是，该类是否缺少或者被禁止访问她依赖的某些外部类、方法、字段等资源。</p>
</blockquote>
<p>这一阶段可能包含以下验证点：</p>
<ul>
<li>符号引中通过字符串描述的全限定名能否找到对应的类</li>
<li>在指定类是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>
<li>…</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><blockquote>
<p>正式为类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置为变量初始值(<code>零值</code>)的阶段，不包括实例变量。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">100</span>;</code></pre></div>
<p>在准备阶段，JVM会为value分配内存，并将其设置为0。真正的100需要在初始化阶段进行设置。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>reference</td>
<td>Null</td>
</tr>
</tbody>
</table>
<p>以上是通常情况下初始值是<code>零值</code>，还是会存在一些特殊情况——静态常量。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">100</span>;</code></pre></div>
<p>此时value的初始值就为100。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><blockquote>
<p>把常量池中的符号引用转换为直接引用，也就是具体的内存地址。JVM会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。</p>
</blockquote>
<h5 id="符号引用-1"><a href="#符号引用-1" class="headerlink" title="符号引用"></a>符号引用</h5><p>以一组符号描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。</p>
<h5 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h5><p>直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。<strong>对象真正的内存地址</strong></p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote>
<p>类加载的最后一个步骤，直到这一步，JVM才真正开始执行类中编写的Java代码。</p>
<p><strong>执行类构造器<clinit>()的过程，并真正初始化类变量(前面准备过程的零值在此时被赋予真正的值)</clinit></strong></p>
</blockquote>
<h5 id="初始化执行时机"><a href="#初始化执行时机" class="headerlink" title="初始化执行时机"></a>初始化执行时机</h5><p>JVM规范严格规定类class初始化的时机，主要有以下几种情况：</p>
<ul>
<li><p>虚拟机启动时，初始化包含<code>main()</code>的主类</p>
</li>
<li><p>遇到<code>new(创建对象实例)、getstatic(读取类静态字段)、putstatic(设置类静态字段)、invokestatic(调用类的静态方法)</code>这四条字节码指令时，如果目标对象没有经过初始化，需要执行初始化操作</p>
</li>
<li><p>当需要对类进行反射调用时，如果类型没有进行初始化，需要执行初始化操作</p>
</li>
<li><p>当初始化子类的时候，发现父类还没有进行初始化，需要执行父类的初始化操作</p>
</li>
<li><p>在第一次调用<code>java.lang.invoke.MethodHandle</code>实例时，需要初始化MethodHandle指向方法所在的类。<em>JDK7之后</em></p>
</li>
<li><p>当一个接口中定义了JDK8新加入的默认方法(<code>default</code>关键字修饰)，如果实现了这个接口的类进行初始化，那么接口需要执行初始化操作</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DefaultInterface</span> </span>&#123;
    <span class="hljs-comment">//默认接口方法</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
        System.err.println(<span class="hljs-string">"Default Interface Method"</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>
</li>
</ul>
<p>以上6种情况在JVM中被称为<strong>主动引用</strong>，除此之外的其他应用方式都被称为<strong>被动引用</strong>，不会出发Class的初始化操作。</p>
<p>例如以下几种情况：</p>
<ul>
<li><p>通过子类调用父类的静态变量，不会导致子类初始化</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>&#123;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">static</span> &#123;
    System.out.println(<span class="hljs-string">"Parent"</span>);
  &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;
  <span class="hljs-keyword">static</span> &#123;
    System.out.println(<span class="hljs-string">"Child"</span>);
  &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
    Child.value = <span class="hljs-number">2</span>;
  &#125;
&#125;

日志输出
java NonInitTest
Parent</code></pre></div>
<p>只有直接定义这个字段的类才会被初始化，所以子类不会进行初始化。</p>
</li>
<li><p>静态常量引用时，不会出发定义常量类的初始化</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstClass</span></span>&#123;
  <span class="hljs-keyword">static</span> &#123;
    System.out.println(<span class="hljs-string">"Const"</span>);
  &#125;
  
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String value =<span class="hljs-string">"Value"</span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
    System.out.println(ConstClass.value);
  &#125;
&#125;

日志输出
Value</code></pre></div>
<p>常量实际在编译阶段直接存储在Test类的常量池中，已于ConstClass无关，所以不会导致初始化。</p>
</li>
</ul>
<h5 id="Class初始化和对象的创建顺序"><a href="#Class初始化和对象的创建顺序" class="headerlink" title="Class初始化和对象的创建顺序"></a>Class初始化和对象的创建顺序</h5><p>在代码中使用<code>new</code>创建对象实例时，类中<code>静态代码块、非静态代码块、构造函数</code>之间的执行顺序是如何的？</p>
<div class="hljs"><pre><code class="hljs java">Parent.java
 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String value = <span class="hljs-string">"Parent"</span>;

    <span class="hljs-keyword">static</span> &#123;
        System.err.println(<span class="hljs-string">"Parent Static Block"</span>);
    &#125;

    &#123;
        System.err.println(<span class="hljs-string">"Parent non-static Block"</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Parent</span><span class="hljs-params">()</span></span>&#123;
        System.err.println(<span class="hljs-string">"Parent Constructor"</span>);
    &#125;
&#125;


Child.java

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span></span>&#123;
    <span class="hljs-keyword">static</span> &#123;
        System.err.println(<span class="hljs-string">"Child Static Block"</span>);
    &#125;

    &#123;
        System.err.println(<span class="hljs-string">"Child Non-Static Block"</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Child</span><span class="hljs-params">()</span></span>&#123;
        System.err.println(<span class="hljs-string">"Child Constructor"</span>);
    &#125;
&#125;

Test.java

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Parent p =<span class="hljs-keyword">new</span> Child();
        System.err.println(<span class="hljs-string">"~~~~~~~~~~"</span>);
        p = <span class="hljs-keyword">new</span> Child();
    &#125;
&#125;</code></pre></div>
<p>输出内容为</p>
<div class="hljs"><pre><code class="hljs java">Parent Static Block
Child Static Block
Parent non-<span class="hljs-keyword">static</span> Block
Parent Constructor
Child Non-Static Block
Child Constructor
~~~~~~~~~~
Parent non-<span class="hljs-keyword">static</span> Block
Parent Constructor
Child Non-Static Block
Child Constructor</code></pre></div>
<p>按照上述输出内容，可以总结初始化顺序为：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-number">1</span>.父类静态变量和静态代码块
<span class="hljs-number">2</span>.子类静态变量和静态代码块
<span class="hljs-number">3</span>.父类普通成员变量和普通代码块
<span class="hljs-number">4</span>.父类的构造函数
<span class="hljs-number">5</span>.子类普通成员变量和普通代码块
<span class="hljs-number">6</span>.子类的构造函数</code></pre></div>
<p>基础规则：<strong>静态变量/静态代码块 -&gt; 普通变量/普通代码块 -&gt; 构造函数</strong>。</p>
<p>特殊情况</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticTest</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        staticFun();
    &#125;
    <span class="hljs-comment">//特殊之处</span>
    <span class="hljs-keyword">static</span> StaticTest st = <span class="hljs-keyword">new</span> StaticTest();

    <span class="hljs-keyword">static</span> &#123;
        System.err.println(<span class="hljs-string">"1"</span>);
    &#125;

    &#123;
        System.err.println(<span class="hljs-string">"2"</span>);
    &#125;

    StaticTest() &#123;
        System.err.println(<span class="hljs-string">"3"</span>);
        System.err.println(<span class="hljs-string">"a"</span> + a + <span class="hljs-string">" b"</span> + b);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticFun</span><span class="hljs-params">()</span> </span>&#123;
        System.err.println(<span class="hljs-string">"4"</span>);
    &#125;

    <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">100</span>;
&#125;</code></pre></div>
<p>TODO：需要好好分析流程。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><!--包括Android加载器-->
<p>在Java程序启动的时候，并不会一次性加载程序中所有的.class文件，而是在程序运行的过程中，动态加载相应的类到内存中。</p>
<p><strong>同一个类使用不同的类加载器，得到的类也是不一样的。</strong></p>
<h4 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h4><ul>
<li><p>启动类加载器(BootstrapClassLoader)</p>
<p>由C/C++语言编写的，本身属于虚拟机的一部分，无法在Java代码获取他的引用。可以以<code>null</code>代表引导类加载器。</p>
<p>负责加载存放在&lt;JAVA_HOME&gt;\lib目录，或者被-Xbootclasspath参数所指定路径的类库</p>
</li>
</ul>
<ul>
<li><p>拓展类加载器(ExtensionClassLoader)/PlatformClassLoader(JDK9后改名)</p>
<p>由Java语言编写，可以直接在程序中使用</p>
<p>负责加载&lt;JAVA_HOME&gt;\lib\ext目录中，或者被java.ext.dirs所指定的路径中的所有类库</p>
</li>
</ul>
<ul>
<li><p>应用程序/系统类加载器(ApplicationClassLoader)</p>
<p>负责加载用户类路径(<code>java.class.path</code>)上所有的类库，我们自己编写的代码以及使用的第三方jar通常由他进行加载。</p>
<p><strong>若没有自定义类加载器，默认由他进行类加载。</strong></p>
</li>
</ul>
<ul>
<li><p>自定义类加载器(CustomClassLoader)</p>
<p>上述三种加载器只能加载特定目录下的class文件，如果需要加载特殊位置下的jar包或类时(磁盘上的class)，就需要继承<code>java.lang.ClassLoader</code>去实现功能。</p>
<p>自定义ClassLoader步骤如下：</p>
<ol>
<li>自定义一个类继承<code>ClassLoader</code></li>
<li>重写<code>findClass()</code></li>
<li>在<code>findClass()</code>中，调用<code>defineClass()</code>将字节码转换成Class对象并返回</li>
</ol>
<p>伪代码如下：</p>
<div class="hljs"><pre><code class="hljs java">Class CustomClassLoader extends ClassLoader&#123;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function">Class <span class="hljs-title">findClass</span><span class="hljs-params">(String name)</span></span>&#123;
    <span class="hljs-comment">//获得字节码</span>
    <span class="hljs-keyword">byte</span>[] code = loadClassData(name);
    <span class="hljs-comment">//根据字节码获得Class对象</span>
    <span class="hljs-keyword">return</span> defineClass(name,code);
  &#125;
  
  <span class="hljs-comment">//这里是获得Class的字节码数组</span>
  <span class="hljs-keyword">byte</span>[] loadClassData(String name)&#123;
    
  &#125;
&#125;</code></pre></div>
</li>
</ul>
<h4 id="双亲委托模型"><a href="#双亲委托模型" class="headerlink" title="双亲委托模型"></a>双亲委托模型</h4><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/parent_loader.png" srcset="/img/loading.gif" class="full-image" alt="alt" title="双亲委托模型"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<blockquote>
<p>当类加载器收到类加载请求时，通常都是先委托给父类加载器进行加载，因此所有的类加载请求最终都会传送到最顶层的<code>启动类加载器</code>中，只有当父加载器无法完成这个加载请求时，子加载器才会去进行类加载过程。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent; 
<span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)
        <span class="hljs-keyword">throws</span> ClassNotFoundException
    &#123;
        <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;
            <span class="hljs-comment">// 首先，检查请求的类是否已经被加载过</span>
            Class&lt;?&gt; c = findLoadedClass(name);
            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-keyword">long</span> t0 = System.nanoTime();
                <span class="hljs-keyword">try</span> &#123;
                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//父加载器不为空，调用父加载器loadClass()方法处理</span>
                        c = parent.loadClass(name, <span class="hljs-keyword">false</span>);
                    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span>
                        c = findBootstrapClassOrNull(name);
                    &#125;
                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;
                   <span class="hljs-comment">//抛出异常说明父类加载器无法完成加载请求</span>
                &#125;

                <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-keyword">long</span> t1 = System.nanoTime();
                    <span class="hljs-comment">//自己尝试加载</span>
                    c = findClass(name);
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (resolve) &#123;
                resolveClass(c);
            &#125;
            <span class="hljs-keyword">return</span> c;
        &#125;
    &#125;</code></pre></div>
<p>按照源码分析，双亲委托模型总共4步：</p>
<ol>
<li>判断class是否被加载，已加载直接返回class</li>
<li>class未被加载且<code>parent(父加载器)</code>不为空，父加载器进行加载class</li>
<li><code>parent(父加载器)</code>为空，直接调用<code>BootstrapClassLoader</code>加载class</li>
<li>如果<code>parent</code>或<code>Bootstrap</code>都未加载成功，则调用当前classLoader继续尝试加载class</li>
</ol>
<h5 id="双亲委托模型好处"><a href="#双亲委托模型好处" class="headerlink" title="双亲委托模型好处"></a>双亲委托模型好处</h5><ul>
<li><strong>避免类的重复加载</strong>，若class已被加载直接从缓存读取</li>
<li><strong>保证类加载的安全</strong>，避免核心API被篡改，无论哪一个类加载去加载核心类(例<code>java.lang.Object</code>)，最终都会由<code>BootstrapClassLoader</code>进行加载。</li>
</ul>
<h5 id="破坏模型"><a href="#破坏模型" class="headerlink" title="破坏模型"></a>破坏模型</h5><blockquote>
<p><code>双亲委托机制</code>只是Java推荐的机制，并不是强制的机制，可以通过一些手段破坏该模型</p>
</blockquote>
<p>可以通过继承<code>java.lang.ClassLoader</code>实现自己的类加载器</p>
<ul>
<li>保持<code>双亲委托模型</code>，只要重写<code>findClass()</code></li>
<li>破坏<code>双亲委托模型</code>，需要重写<code>loadClass()</code></li>
</ul>
<h4 id="Android类加载器"><a href="#Android类加载器" class="headerlink" title="Android类加载器"></a>Android类加载器</h4><!--dex2oat dexopt过程-->
<blockquote>
<p>本质上，Android和传统的JVM是一样，也要通过<code>ClassLoader</code>加载目标类到内存，但是加载细节略有差别。</p>
<p>基本运行方式：<code>传入dex文件，然后进行优化，保存优化后的dex文件(odex)到optimizedDirectory目录</code></p>
</blockquote>
<p>Android无法直接运行<code>.class文件</code>，会将所有的<code>.class文件</code>转换<code>.dex</code>文件，Android通过自定义的<code>BaseDexClassLoader</code>加载<code>dex文件</code>，也会通过继承<code>BaseDexClassLoader</code>实现特定功能的子类。</p>
<h5 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a>BaseDexClassLoader</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseDexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseDexClassLoader</span><span class="hljs-params">(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Stub!"</span>);
    &#125;
    ...
&#125;</code></pre></div>
<ul>
<li><p>dexPath</p>
<p>包含目标类或资源的<code>apk,dex,jar文件的路径，也可以是SD卡的路径</code>，存在多个路径时使用<code>;</code>分割</p>
</li>
<li><p>optimizedDirectory</p>
<p>优化后dex文件(<code>odex</code>)存在的目录，可以为null，<em>Android8.0之后，该参数被废弃</em></p>
</li>
<li><p>librarySearchPath</p>
<p>存放目标文件使用的native库，存在多个路径使用<code>;</code>分割</p>
</li>
<li><p>parent</p>
<p>父加载器</p>
</li>
</ul>
<h5 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h5><blockquote>
<p>加载Android系统类和应用程序的类，在<code>Dalvik</code>只能加载已安装的apk的dex文件(<code>/data/app</code>)，在ART没有这个限制。</p>
<p><strong>支持加载外部的dex/apk文件</strong></p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PathClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDexClassLoader</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, ClassLoader parent)</span> </span>&#123;
        <span class="hljs-keyword">super</span>((String)<span class="hljs-keyword">null</span>, (File)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, (ClassLoader)<span class="hljs-keyword">null</span>);
        ...
    &#125;
  
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathClassLoader</span><span class="hljs-params">(String dexPath, String libraryPath, ClassLoader parent)</span> </span>&#123;
        <span class="hljs-keyword">super</span>((String)<span class="hljs-keyword">null</span>, (File)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, (ClassLoader)<span class="hljs-keyword">null</span>);
        ...
    &#125;
&#125;</code></pre></div>
<p><code>PathClassLoader</code>传入的<code>optimizedDictory</code>为空，表示只能加载系统默认位置(<code>/data/dalvik-cache/</code>)的<code>odex</code>文件。</p>
<h5 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h5><blockquote>
<p><strong>支持加载外部的dex/apk文件</strong>，但是可以配置<code>optimizedDirectory</code>指定<code>odex</code>存放位置。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DexClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseDexClassLoader</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DexClassLoader</span><span class="hljs-params">(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)</span> </span>&#123;
        <span class="hljs-keyword">super</span>((String)<span class="hljs-keyword">null</span>, (File)<span class="hljs-keyword">null</span>, (String)<span class="hljs-keyword">null</span>, (ClassLoader)<span class="hljs-keyword">null</span>);
      ...
    &#125;
&#125;</code></pre></div>
<p>可以支持<code>BaseDexClassLoader</code>配置的所有参数。</p>
<h3 id="Android类加载过程"><a href="#Android类加载过程" class="headerlink" title="Android类加载过程"></a>Android类加载过程</h3><a href="/2019/12/19/Android-Art类加载过程/" title="Android-Art类加载过程">Android-Art类加载过程</a>
<h2 id="JVM垃圾回收机制-GC"><a href="#JVM垃圾回收机制-GC" class="headerlink" title="JVM垃圾回收机制(GC)"></a>JVM垃圾回收机制(GC)</h2><blockquote>
<p>GC：自动管理回收不再引用的内存数据</p>
<p>JVM内存运行时区域分为5部分，其中<code>程序计数器、虚拟机栈、本地方法栈</code>3个区域<strong>随线程生而生，随线程灭而灭</strong>，是不需要考虑内存回收的问题，内存自然会回收。<code>Java堆和方法区</code>不一样，只有在程序运行期间才知道创建哪些对象，这部分内存的分配和回收是动态的，主要在这两部分触发GC。</p>
</blockquote>
<h3 id="对象是否已死-什么是垃圾"><a href="#对象是否已死-什么是垃圾" class="headerlink" title="对象是否已死(什么是垃圾)"></a>对象是否已死(什么是<code>垃圾</code>)</h3><p>堆中几乎存放所有的对象实例，垃圾回收(GC)前的第一步是判断哪些对象已经死亡(不再被任何途径引用的对象)。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><blockquote>
<p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；引用失效，计数器减1；任何时候计数器为0的对象就是不可能在被使用的。</p>
</blockquote>
<p><code>引用计数法</code>虽然需要占用额外的内存空间来进行计数，但是<strong>原理简单，效率也高</strong>。</p>
<p>但是主流的Java虚拟机里面都没有使用该方法，主要原因是<strong>必须配合大量额外处理才能保证正确的工作，例如无法解决对象之间相互循环引用的问题</strong>。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote>
<p>通过一系列称为<code>GC Roots</code>的根对象作为起始点，从这些节点开始搜索，搜索过程走过的路径称为<strong>引用链</strong>，如果一个对象到<code>GC Roots</code>没有任何引用链相连的话，则证明此对象是不可用的。</p>
</blockquote>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_reachability_analysis.png" srcset="/img/loading.gif" class="full-image" alt="可达性分析算法" title="可达性分析算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>可以作为<code>GC Roots</code>的对象类型：</p>
<ul>
<li>虚拟机栈中的引用对象(局部变量表)</li>
<li>方法区中静态属性引用的对象(字符串常量池中的引用)，常量引用的对象</li>
<li>本地方法栈中JNI所引用的对象</li>
</ul>
<h3 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h3><p>一般会在以下两种情况下触发GC</p>
<ol>
<li><code>Allocation Failure</code>：如果内存剩余可用空间不足导致对象内存分配失败，系统会触发一次GC</li>
<li><code>System.gc()</code>：开发者可主动调用该API触发一次GC</li>
</ol>
<h3 id="四大引用类型-Java堆"><a href="#四大引用类型-Java堆" class="headerlink" title="四大引用类型(Java堆)"></a>四大引用类型(Java堆)</h3><table>
<thead>
<tr>
<th>引用类型</th>
<th>GC时机</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>不会被回收</td>
<td>对象一般状态</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足时(即将OOM时)</td>
<td>内存敏感的高速缓存</td>
</tr>
<tr>
<td>弱引用</td>
<td>触发GC时</td>
<td>对象缓存</td>
</tr>
<tr>
<td>虚引用</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="强引用Strong-Reference"><a href="#强引用Strong-Reference" class="headerlink" title="强引用Strong Reference"></a>强引用<code>Strong Reference</code></h4><blockquote>
<p>在程序代码间普遍存在的引用赋值。<strong>无论何种情况，只要存在强引用关系，就永远不会被垃圾回收器回收。即使发生OOM。</strong></p>
<p><strong>强引用也是造成Java内存泄露的原因之一。</strong></p>
</blockquote>
<p>对于一个普通的对象，如果没有其他的引用关系，若显式的将对象赋值为null，就可以认为该对象可以被回收。</p>
<p><em>设置对象为null，不代表对象会被立即回收，具体回收时机需要看垃圾收集策略。</em></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
  Object o1 = <span class="hljs-keyword">new</span> Object();
  Object o2 = o1;
  o1= <span class="hljs-keyword">null</span>;
  System.gc();
  System.out.println(o1);  <span class="hljs-comment">//null</span>
  System.out.println(o2);  <span class="hljs-comment">//java.lang.Object@XX</span>
&#125;</code></pre></div>
<h4 id="软引用Soft-Reference"><a href="#软引用Soft-Reference" class="headerlink" title="软引用Soft Reference"></a>软引用<code>Soft Reference</code></h4><blockquote>
<p>描述一些还有用，但并未必需的对象。对于<code>软引用</code>关联的对象，在系统即将发生<code>OOM</code>之前，会把这些对象进行GC，如果GC完毕还没有充足空间，就抛出OOM异常。</p>
<p><strong>实现内存敏感的高速缓存。</strong></p>
<p><em>只有系统内存不足时才会被回收，其他情况下等效强引用。</em></p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
   Object o1 = <span class="hljs-keyword">new</span> Object();
   SoftReference&lt;Object&gt; s1 = <span class="hljs-keyword">new</span> SoftReference&lt;Object&gt;(o1);
   System.out.println(o1);
   System.out.println(s1.get());

   o1 = <span class="hljs-keyword">null</span>;
   System.gc();

   System.out.println(o1); <span class="hljs-comment">// null</span>
   System.out.println(s1.get()); <span class="hljs-comment">//java.lang.Object@XX</span>
&#125;

<span class="hljs-comment">//JVM配置`-Xms5m -Xmx5m`</span>
<span class="hljs-comment">//试图new一个大对象，使内存不足产生OOM，看软引用回收情况</span>
...
  <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>]；
  ...
  
  此时会去试图回收软引用对象。</code></pre></div>
<h4 id="弱引用Weak-Reference"><a href="#弱引用Weak-Reference" class="headerlink" title="弱引用Weak Reference"></a>弱引用<code>Weak Reference</code></h4><blockquote>
<p>弱引用也是描述非必须对象，但强度比<code>软引用</code>更弱一些，被弱引用关联的对象只能生存在下一次GC前。</p>
<p><strong>无论内存是否足够，弱引用关联的对象都会被回收。</strong></p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Object o1 = <span class="hljs-keyword">new</span> Object();
        WeakReference&lt;Object&gt; w1 = <span class="hljs-keyword">new</span> WeakReference&lt;Object&gt;(o1);

        System.out.println(o1);
        System.out.println(w1.get());

        o1 = <span class="hljs-keyword">null</span>;
        System.gc();

        System.out.println(o1); <span class="hljs-comment">//null</span>
        System.out.println(w1.get()); <span class="hljs-comment">//null</span>
    &#125;</code></pre></div>
<p><code>WeakHashMap</code>就是<code>弱引用</code>的一个使用实例</p>
<p>其中<code>key</code>为弱引用类型，当key不在引用时，对应的key/value也会被移除</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    WeakHashMap&lt;String,String&gt; weakHashMap = <span class="hljs-keyword">new</span> WeakHashMap&lt;&gt;();
    String key = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"111"</span>);
    <span class="hljs-comment">//String key ="111";</span>

    String value= <span class="hljs-string">"value"</span>;

    weakHashMap.put(key,value);
    System.err.println(weakHashMap);<span class="hljs-comment">// &#123;111=value&#125;</span>

    key = <span class="hljs-keyword">null</span>;
    System.gc();
    System.err.println(key); <span class="hljs-comment">//null</span>
    System.err.println(weakHashMap); <span class="hljs-comment">//&#123;&#125;</span>
&#125;</code></pre></div>
<p>当使用<code>String key = “111”</code>时，本质引用的对象已经变成<code>字符串常量池</code>中的对象，这部分的回收无法被GC处理。也导致了<code>weakHashMap</code>对象不为空。</p>
<h4 id="虚引用Phantom-Reference"><a href="#虚引用Phantom-Reference" class="headerlink" title="虚引用Phantom Reference"></a>虚引用<code>Phantom Reference</code></h4><blockquote>
<p>最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对生存时间构成影响，也无法通过<code>虚引用</code>来取得一个对象实例。</p>
<p>主要用于<code>跟踪对象垃圾回收的状态，在这个对象被回收时可以收到一个系统通知或者后续添加进一步的处理。</code></p>
</blockquote>
<p><code>虚引用</code>必须与<code>引用队列</code>联合使用，当准备回收一个对象时，发现对象存在<code>虚引用</code>，就会在回收对象之前把<code>虚引用</code>加入关联的<code>引用队列</code>中，可以根据<code>引用队列</code>是否已加入<code>虚引用</code>来判断被引用的对象是否要被回收。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        Object o1 = <span class="hljs-keyword">new</span> Object();
        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;Object&gt;();
        PhantomReference&lt;Object&gt; phantomReference = <span class="hljs-keyword">new</span> PhantomReference&lt;Object&gt;(o1,referenceQueue);

        System.out.println(o1); <span class="hljs-comment">//java.lang.Object@xxx</span>
        System.out.println(referenceQueue.poll()); <span class="hljs-comment">//null</span>
        System.out.println(phantomReference.get()); <span class="hljs-comment">//null</span>

        o1 = <span class="hljs-keyword">null</span>;
        System.gc();
        Thread.sleep(<span class="hljs-number">3000</span>);

        System.out.println(o1); <span class="hljs-comment">//null </span>
        System.out.println(referenceQueue.poll()); <span class="hljs-comment">//引用队列中 java.lang.PhantomReference@xxx</span>
        System.out.println(phantomReference.get());<span class="hljs-comment">//null</span>
    &#125;</code></pre></div>
<h4 id="引用队列Reference-Queue"><a href="#引用队列Reference-Queue" class="headerlink" title="引用队列Reference Queue"></a>引用队列<code>Reference Queue</code></h4><blockquote>
<p>配合引用工作的，当GC准备回收一个对象时，如果发现对象被<code>软引用或弱引用或虚引用</code>包装，就会在回收对象前将引用加入到<code>引用队列</code>中。</p>
<p><strong>如果一个引用(软引用、弱引用、虚引用)存在引用队列中，则表示该引用指向的对象已被回收。</strong></p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    ReferenceQueue&lt;String&gt; referenceQueue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();
    String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"11"</span>);
    WeakReference&lt;String&gt; weakReference = <span class="hljs-keyword">new</span> WeakReference&lt;String&gt;(s,referenceQueue);
    s= <span class="hljs-keyword">null</span>;
    System.gc();
    System.err.println(s); <span class="hljs-comment">//null</span>
    <span class="hljs-comment">//被回收了对象</span>
    System.err.println(weakReference.isEnqueued()); <span class="hljs-comment">//true</span>
    System.err.println(referenceQueue.poll()); <span class="hljs-comment">//java.lang.ref.WeakReference@5e481248</span>
&#125;</code></pre></div>
<p><code>ReferenceQueue</code>是一个先进先出的队列。</p>
<h4 id="引用-Reference"><a href="#引用-Reference" class="headerlink" title="引用 Reference"></a>引用 <code>Reference</code></h4><p>上面的<code>弱引用、软引用、虚引用</code>都是<code>java.lang.ref.Reference</code>的直接子类。</p>
<p><code>Reference</code>主要存在四种状态</p>
<ul>
<li><p>Active</p>
<p>新创建的实例为<code>Active</code>状态</p>
</li>
<li><p>Pending</p>
<p>当实例等待进入<code>引用队列</code>时，处于<code>Pending</code>状态。未注册<code>引用队列</code>时永远不会处于此状态</p>
</li>
<li><p>Enqueued</p>
<p>当实例进入<code>引用队列</code>时，处于<code>Enqueued</code>状态。未注册<code>引用队列</code>时永远不会处于此状态</p>
</li>
<li><p>Inactive</p>
<p>该引用实例指向的实际对象一定已被回收。引用实例未注册<code>引用队列</code>直接从<code>Active</code>状态进入到<code>Inactive</code>状态。</p>
</li>
</ul>
<h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>例如<code>Leakcanary</code>，内部主要原理就是：<code>弱引用+引用队列</code>。</p>
<p>在一个Activity执行完<code>onDestroy()</code>后，用<code>WeakReference</code>引用<code>Activity</code>，再将引用对象与<code>ReferenceQueue</code>关联。这时再从<code>ReferenceQueue</code>中查看是否存在该弱引用对象</p>
<p>如果存在，执行一次手动GC，再次移除引用，如果弱引用不存在，则这次执行结束。</p>
<p>如果不存在，执行一次手动GC，再次查看是否存在弱引用对象，如果不存在则表示已发生内存泄露。</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><blockquote>
<p>方法区的GC性价比比较低，方法区的回收条件比较苛刻，比较少用。</p>
</blockquote>
<p>方法区的垃圾收集主要回收两部分内容：</p>
<h4 id="废弃常量"><a href="#废弃常量" class="headerlink" title="废弃常量"></a>废弃常量</h4><p>如果常量池中存在字符串<code>wxy</code>，但是当前没有任何String对象引用该字符串常量。就表示了当前这个常量处于废弃状态，当发生内存回收的时候而且有必要进行方法区回收，就会清理<code>wxy</code>出常量池。</p>
<h4 id="无用类"><a href="#无用类" class="headerlink" title="无用类"></a>无用类</h4><p>需要同时满足以下三个条件：</p>
<ul>
<li>该类所有的实例都已被回收，Java堆中已不存在该类的任何实例</li>
<li>加载该类的类加载器已被回收，所以必须是<strong>自定义加载器去加载</strong></li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，也无法在任何地方被反射访问。</li>
</ul>
<p>GC可以对满足上述三个条件的无用类进行回收，但不是必然会进行回收。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><blockquote>
<p>最基础的收集算法</p>
</blockquote>
<p>算法分为两个阶段：</p>
<ul>
<li><p>标记(Mark)</p>
<p><code>标记所有需要回收的对象</code>。找到内存中所有的GC Root对象，然后找到与上述对象没有关联的对象(<code>需要回收的垃圾</code>)。</p>
</li>
<li><p>清除(Sweep)</p>
<p><code>回收掉所有被标记的对象</code>。</p>
</li>
</ul>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_mark_sweep.png " srcset="/img/loading.gif" class="full-image" alt="标记-清除算法" title="标记-清除算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>优点：</p>
<ul>
<li>实现简单，不需要移动对象</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>执行效率不稳定</code>。如果存在大部分需要回收的对象，导致标记、清除两个动作执行效率降低。</li>
<li><code>内存碎片问题</code>。清除过程后会产生大量不连续的内存碎片，导致下次分配大对象时没有连续内存导致再次触发GC。</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将可用内存分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，将剩下的对象复制到另一块内存上。然后再清理已使用过的另一块内存，完成GC。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_copying.png" srcset="/img/loading.gif" class="full-image" alt="整理算法" title="整理算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>优点：</p>
<ul>
<li>按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>可用内存减少一半</code>。对象存活率较高时会频繁进行复制。</li>
</ul>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><blockquote>
<p><code>标记-清除算法</code>的升级版</p>
</blockquote>
<p>算法分为两个阶段：</p>
<ul>
<li><p>标记(Mark)</p>
<p><code>标记所有需要回收的对象</code>。找到内存中所有的GC Root对象，然后找到与上述对象没有关联的对象(<code>需要回收的垃圾</code>)。</p>
</li>
<li><p>整理(Compact)</p>
<p><code>移动剩余存活对象到内存的某一端</code>。然后直接清理边界外的内存对象。</p>
</li>
</ul>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_mark_compact.png" srcset="/img/loading.gif" class="full-image" alt="标记-整理算法" title="标记-整理算法"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>优点：</p>
<ul>
<li>避免内存碎片的产生 <em>相比于标记-清除算法</em></li>
<li>高效利用内存空间 <em>相比于复制算法</em></li>
</ul>
<p>缺点：</p>
<ul>
<li>移动对象的过程必须全程暂停用户应用程序(<strong>STW-Stop The World</strong>)，降低了效率。</li>
</ul>
<h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="*分代收集理论"></a>*分代收集理论</h4><blockquote>
<p>主流JVM使用的垃圾收集算法</p>
</blockquote>
<p>根据对象存活的周期不同，把堆内存划分几块，一般分为<strong>新生代</strong>和<strong>老年代</strong>。根据不同年代的特点使用不同的垃圾收集算法。</p>
<p><strong>对于新创建的对象会在<code>新生代</code>分配内存，此区域的对象生命周期一般较短。如果经过多次回收仍然存活下来，则将他们转移到<code>老年代</code>中。</strong></p>
<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><blockquote>
<p>新生成的对象优先存放<code>新生代</code>，新生代对象朝生夕死，存活率很低，所以回收效率很高。</p>
<p>新生代经常要进行一些复制操作，所以一般采用<strong>复制算法</strong>进行回收。</p>
</blockquote>
<p>新生代继续分为3部分：<code>Eden、From Survivor、To Survivor</code>。这三部分并非均分，而是按照<strong>8:1:1</strong>的比例进行划分。</p>
<p>新生代GC过程如下：</p>
<ol>
<li>绝大多数新创建对象都会先存放在<code>Eden</code>区</li>
<li>当<code>Eden</code>区满时，会执行一次GC(<strong>Minor GC</strong>)，清除<code>Eden</code>区的垃圾对象，将存活的对象复制到<code>From Survivor</code>区</li>
<li>当<code>From Survivor</code>区满时，会执行一次<code>Minor GC</code>，将存活的对象复制到<code>To Survivor</code>区。<em>如果存在可以<code>晋升</code>的对象会直接放到<code>老年代</code>中。</em></li>
<li>将<code>From Survivor</code>与<code>To Survivor</code>区域进行切换。<em>每次切换过程中即GC过后，对象的年龄+1，直到达到<code>晋升年龄阈值(一般为15)</code>之后，对象被放到老年代。——<code>长期存活的对象直接进入老年代</code></em></li>
</ol>
<p><code>晋升年龄阈值</code>：该值的大小影响着对象在<code>新生代</code>中的停留时间，可以通过<code>-XX:MaxTenuringThreshold</code>配置数值。</p>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><blockquote>
<p>在新生代经历了N次(<code>晋升年龄阈值</code>)回收之后仍然存活的对象，就会放入<code>老年代</code>。</p>
<p><code>老年代</code>的内存一般比<code>新生代</code>大(大概比例为2:1)，可以存放更多的对象。</p>
<p><em>如果对象比较大(<code>升入老年代对象大小</code>)，并且新生代无法存放，则这个大对象会被直接分配<code>老年代</code>上。——<code>大对象直接进入老年代</code>。</em></p>
<p><code>老年代</code>通常使用<code>标记-清除、标记-整理</code>算法进行GC。</p>
</blockquote>
<p><code>升入老年代对象大小</code>：如果新生代的对象需要分配一块较大连续内存空间才可以存放，且该大小大于该值，则直接在<code>老年代</code>进行内存分配，可以通过<code>-XX:PretenureSizeThreshold</code>配置数值。</p>
<p><code>老年代</code>发生的GC称为<code>Major GC</code>，针对<code>老年代</code>的GC操作，通常伴随一次<code>Minor GC</code></p>
<p>在某些虚拟机中，还有<code>Full GC</code>，针对<code>新生代与老年代</code>的GC，回收整个堆的内存。发生时，会导致长时间停顿。</p>
<p><br></p>
<p><code>老年代</code>有时候会引用<code>新生代</code>对象，当执行<code>Minor GC</code>时可能就需要查询<code>老年代</code>的引用情况。导致GC过程低效。</p>
<p>所以老年代会维护一个<code>Card table</code>，记录老年代所引用的新生代对象信息，在发生<code>Minor GC</code>时，只要检查<code>Card table</code>即可。</p>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_java_heap_memory.png" srcset="/img/loading.gif" class="full-image" alt="Java堆内存" title="Java堆内存"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_collectors.png" srcset="/img/loading.gif" class="full-image" alt="垃圾收集器" title="垃圾收集器"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><blockquote>
<p><strong>最基本，发展历史最悠久的收集器。</strong></p>
<p>是一个<code>单线程</code>工作的收集器，只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是进行垃圾回收时，必须停止其他所有工作线程(<code>Stop The World</code>)，直到收集结束。</p>
</blockquote>
<p><strong>新生代采用<code>复制算法</code>，老年代采用<code>标记-整理算法</code>。</strong></p>
<p>优点：</p>
<ul>
<li>简单而高效</li>
<li>没有线程交互的开销，可以获得最高的单线程收集效率</li>
</ul>
<p>缺点：</p>
<ul>
<li>Stop The World可能时间过长</li>
</ul>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><blockquote>
<p>其实就是<code>Serial收集器</code>的多线程版本，不同的就是使用多线程进行垃圾收集</p>
</blockquote>
<p><strong>新生代采用<code>复制算法</code>，老年代采用<code>标记-整理算法</code>。</strong></p>
<p>除了<code>Serial收集器</code>以外，只有它可以和<code>CMS收集器</code>配合工作。</p>
<p>默认开启的收集线程数与CPU数一致。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="*CMS收集器"></a>*CMS收集器</h4><blockquote>
<p>以<code>获取最短回收停顿时间</code>为目标的收集器。</p>
<p>基于<code>标记-清除</code>算法实现。整体上来说是<code>内存回收线程</code>与<code>用户线程</code>并发执行。</p>
<p>应用于<code>老年代</code>的垃圾收集器。</p>
</blockquote>
<p>运作过程比较复杂，分为以下4步：</p>
<ol>
<li><p><code>初始标记</code></p>
<p>暂停所有其他线程，并记录下与GC Roots关联的对象。<strong>触发Stop-The-World</strong></p>
</li>
<li><p><code>并发标记</code></p>
<p>从GC Roots直接关联对象开始遍历整个对象图的过程(<code>GC Roots Tracing</code>)。这个过程耗时较长但不用停顿用户线程，主要跟踪记录发生引用更新的地方。</p>
</li>
<li><p><code>重新标记</code></p>
<p>为了修正<code>并发标记</code>期间，因用户线程继续运行而导致标记产生变动的对象的标记记录。<strong>触发Stop-The-World</strong></p>
</li>
<li><p><code>并发清除</code></p>
<p>清理删除掉在标记阶段判断的垃圾对象，可以与用户线程一起工作。</p>
</li>
</ol>
<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/jvm/gc_collectors_CMS.png" srcset="/img/loading.gif" class="full-image" alt="CMS" title="CMS"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p>优点：</p>
<ul>
<li>并发收集</li>
<li>低停顿</li>
</ul>
<p>缺点：</p>
<ul>
<li>对CPU资源非常敏感</li>
<li>无法处理<code>浮动垃圾</code></li>
<li>产生大量内存碎片(由于<code>标记-清除算法</code>的实现)</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="*G1收集器"></a>*G1收集器</h4><blockquote>
<p>主要面向服务器的垃圾收集器，以极高概率满足GC、停顿时间要求的同时，还具备高吞吐量性能特征。</p>
</blockquote>
<p>具备如下特点：</p>
<ul>
<li><p><strong>并行与并发</strong></p>
<p>使用多个CPU缩短<code>STW</code>时间，还可以通过并发的方式让Java程序继续运行。</p>
</li>
<li><p><strong>分代收集</strong></p>
<p>分代概念在<code>G1收集器</code>中进行了保留，但<code>G1</code>可以直接管理新生代和老年代，然后采用不同的方式去管理。</p>
</li>
<li><p><strong>空间整合</strong></p>
<p>整体基于<code>标记-整理算法</code>，局部(两个Region之间)采用了<code>复制算法</code></p>
</li>
<li><p><strong>可预测的停顿</strong></p>
<p>除了追求低停顿外，还可以建立可预测的时间模型，用户去指定期望停顿时间。</p>
</li>
</ul>
<p>运作过程分为以下4步：</p>
<ol>
<li><p><code>初始标记</code></p>
<p>标记一下与GC Roots直接关联的对象。<strong>需要停顿线程</strong></p>
</li>
<li><p><code>并发标记</code></p>
<p>从GC Roots对象开始对堆中对象进行可达性分析，找出需要回收的对象。</p>
</li>
<li><p><code>最终标记</code></p>
<p>修正<code>并发标记</code>期间因为用户线程继续运行导致标记发生变动的对象。<strong>需要停顿线程</strong></p>
</li>
<li><p><code>筛选回收</code></p>
<p>对各个Region的回收价值和成本进行排序，根据用户指定<code>期望停顿时间</code>制定回收计划。然后把决定回收的那部分Region存活对象复制到空Region中，再清理旧Region空间。</p>
<p><strong>必须暂停用户线程，因为涉及到对象的移动。</strong></p>
</li>
</ol>
<p><code>Region</code></p>
<p>Java堆的内存布局被划分为多个大小相等的区域(<code>Region</code>)，虽然保留了分代概念，但<code>新生代</code>与<code>老年代</code>都变成了<code>Region</code>的集合。</p>
<p><code>G1收集器</code>认为大小超过<code>Region</code>容量一半的对象判定为<code>大对象</code>，存放于<code>Humongous</code>区域。</p>
<p><code>可停顿的时间模型</code></p>
<p>在后台维护了一个优先列表，每次根据用户设置的<code>期望停顿时间</code>，优先选择回收价值(<code>回收获得的空间大小以及回收所需时间的经验值</code>)最大的Region。</p>
<p><code>记忆集(Remembered Set)</code></p>
<p>每个<code>Region</code>都会存在一个<code>记忆集</code>，里面记录下别的<code>Region</code>指向自己的指针并标记这些指针分别在哪些页卡的范围之内。</p>
<p>通常约占Heap大小的20%或者更高。</p>
<h4 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h4><blockquote>
<p>在JDK 11中加入的低延迟垃圾收集器。</p>
</blockquote>
<p>主要新增了两项新技术</p>
<ul>
<li><p>着色指针</p>
<p>将少量额外的信息存储在指针上，在对象的内存发生变化的时候，指针颜色就会发生变化。就能知道当前对象状态</p>
</li>
<li><p>读屏障</p>
<p>由于<code>着色指针</code>的存在，程序访问对象的时候可以轻易知道对象的存储状态，若发现指针变色，则会触发<code>读屏障</code>，会更新指针并重新返回结果，虽然存在一定的耗费但是可以达到与用户线程并发的效果。</p>
</li>
</ul>
<blockquote>
<p>与标记对象的传统算法相比。ZGC在指针上做标记，并在访问指针时加入<code>读屏障</code>，比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就先把指针更新为有效地址再返回，永远只会有单个对象读取时有概率被减速(需要更新指针地址)，而不会再发生Stop-The-World。</p>
</blockquote>
<h2 id="JVM内存分配策略"><a href="#JVM内存分配策略" class="headerlink" title="JVM内存分配策略"></a>JVM内存分配策略</h2><ul>
<li><p>对象优先在<code>Eden区</code>分配</p>
<blockquote>
<p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次<code>Minor GC</code>。</p>
<p>每次GC后，对象依然存在就会进入<code>两块Survivor区内</code>。</p>
</blockquote>
</li>
<li><p>大对象直接进入<code>老年代</code></p>
<blockquote>
<p> 大对象：那种很长的字符串或者元素数量很多的数据。<strong>需要连续内存空间的Java对象。</strong></p>
</blockquote>
</li>
<li><p>长期存活的对象直接进入<code>老年代</code></p>
<blockquote>
<p>每经过一次<code>Minor GC</code>仍然存活的对象，并且能被<code>Survivor</code>容纳，其对象年龄就会+1，当达到<code>晋升年龄阈值</code>对象就会晋升到<code>老年代</code>。</p>
<p><code>晋升年龄阈值</code>：默认为15，通过<code>-XX:MaxTenuringThreshold</code>进行配置。</p>
</blockquote>
</li>
<li><p>动态对象年龄判定</p>
<blockquote>
<p>为了更好适应不同的内存情况，不一定对象达到年龄阈值才能晋升老年代。</p>
<p>如果在<code>survivor区</code>相同年龄的对象大小总和超过<code>Survivor</code>空间的一半，所有年龄大于或等于该年龄的对象都可以直接晋升老年代。</p>
</blockquote>
</li>
<li><p>空间分配担保</p>
<blockquote>
<p>如果<code>survivor</code>没有足够空间存放在<code>Eden区</code>存活对象，这些对象将通过<code>分配担保机制</code>直接进入老年代。</p>
</blockquote>
</li>
</ul>
<h2 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h2><h3 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h3><h4 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h4><p>线程是CPU调度的最小单位。</p>
<p>由于CPU的发展，执行速度越来越快，内存与CPU的执行差距会越来越大，导致数据的交互需要等待较长时间。</p>
<p>因此，为了提升CPU的使用效率，在CPU中添加了<code>高速缓存(cache)</code>作为内存与CPU之间的缓冲：<em>将运算需要的数据复制到Cache中，让运算能快速进行，当运算完成之后，将运算结果刷回主内存，这样CPU就无需等待内存读写完毕。</em></p>
<p>由于每个CPU都有自己的<code>cache</code>，当多个CPU共同操作一块主内存时，可能导致各自<code>cache</code>中的数据不一致，发生<strong>缓存一致性</strong>问题。</p>
<p>为了解决<code>缓存一致性</code>的问题，需要各个处理器访问缓存时遵循一些协议，在读写时要根据协议来进行操作，这类协议有<strong>MESI</strong>、<code>MSI</code>、<code>MOSI</code>等。</p>
<h4 id="MESI-缓存一致性协议"><a href="#MESI-缓存一致性协议" class="headerlink" title="MESI(缓存一致性协议)"></a>MESI(缓存一致性协议)</h4><blockquote>
<p> 当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态。<br>因此当其他CPU需要读取这个变量时，发现自己缓存变量的缓存行无效时，就需要从主内存中重新获取变量值。</p>
</blockquote>
<p>上面介绍到<em>每个处理器都会去检测自己的缓存变量是否有效？</em>，这个检测机制就是通过<strong>嗅探</strong>来实现的。</p>
<p><code>嗅探</code>：每个处理器都会去检测<code>主内存</code>上的数据来判断自己的缓存数据是否有效，当CPU发现缓存数据对应的内存地址发生修改时，就意味着缓存数据已经无效，需要做以下几步：</p>
<ul>
<li>将当前CPU的缓存行设置无效</li>
<li>当CPU需要操作该数据时，就需要重新从主内存中读取数据</li>
<li>读取完毕后更新自己的缓存对象</li>
</ul>
<p><code>嗅探</code>需要持续的从主内存检测数据并且通过<code>CAS</code>进行循环获取，导致<strong>占用的总线带宽较高</strong>。这也被称之为<strong>总线风暴</strong>。</p>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>为了使CPU的运算单元能够尽量被充分利用，CPU会对输入的代码进行重排序处理，也就是<code>处理器优化</code>。</p>
<h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a><code>as-if-serial</code></h4><blockquote>
<p>不管怎么重排序，都不允许单线程下的程序执行结果发生改变。</p>
</blockquote>
<p>编译器、runtime和CPU都必须遵守<code>as-if-serial</code>协议。</p>
<p>一般重排序分为以下三种：</p>
<ul>
<li>编译器优化的重排序</li>
<li>指令级并行的重排序</li>
<li>内存系统的重排序</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>描述了Java程序中各种变量(<code>线程共享变量</code>)的访问规则，屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各种平台都能达到一致的内存访问效果。</p>
<h3 id="主要目的"><a href="#主要目的" class="headerlink" title="主要目的"></a>主要目的</h3><p>定义程序中各种变量的访问规则，关注的是<code>虚拟机中把变量值存储到内存中和从内存中取出变量值这样的底层细节</code>。</p>
<p>此处的<code>变量</code>指的是<code>实例字段、静态字段和构成诉诸对象的元素</code>，不包括<code>局部变量</code>。</p>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/JVM-JMM.png" srcset="/img/loading.gif" class="full-image" alt="线程-主内存-工作内存的交互关系" title="线程-主内存-工作内存的交互关系"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span>
<p><strong>主内存</strong>：所有的变量都存储于此</p>
<p><strong>工作内存</strong>：每条线程都存在自己的<code>工作内存</code>，保存了该线程使用<code>变量的主内存副本</code>。线程对变量所有的操作都必须在<code>工作内存</code>中进行，无法直接操作<code>主内存</code>数据。不同线程之间也不能互相访问<code>工作内存</code>中的变量，线程间传值都需要通过<code>主内存</code>中转完成。</p>
<h3 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3><blockquote>
<p>JMM模型具有以下特征：<strong>原子性、可见性、有序性</strong>。</p>
</blockquote>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote>
<p>对基本数据类型的变量读取和赋值操作都是<code>原子性</code>操作，<strong>这些操作不可被中断，要么执行，要么不执行。</strong></p>
</blockquote>
<p>可以通过<code>synchronized</code>和<code>Lock</code>实现<code>原子性</code>，因为两者能够<strong>保证同一时刻只有一个线程访问该代码块</strong>。</p>
<p><code>原子性</code>操作包括：</p>
<ul>
<li>除<code>long</code>和<code>double</code>之外的基本数据类型赋值和读取操作，如果需要保证原子性需要加上<code>volatile</code>关键字修饰</li>
<li>所有引用<code>refrence</code>的赋值操作</li>
<li><code>java.util.concurrent.atomic.*</code>包下的操作，例如<code>AtomicInteger</code></li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote>
<p>当一个线程修改了共享变量的值，其他线程能够立即得知这个修改，<strong>修改后的值立即更新到主内存中，在其他线程读取时，会重新从主内存获取值</strong>。</p>
</blockquote>
<p><code>volatile</code>可以保证<code>可见性</code>，具体参考<a href="#volatile">volatile</a></p>
<p><code>synchronized</code>和<code>Lock</code>也可以保证<code>可见性</code>，可以保证<strong>同一时刻只有一个线程访问共享资源，并在其释放锁之前将修改变量更新到主内存中</strong>。</p>
<p><code>final</code>也可以实现<code>可见性</code>，对象一旦初始化完成，其他线程都可以该值。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote>
<p>如果在本线程内观察，所有的操作都是有序的；——<code>as-if-serial</code></p>
<p>如果其他线程观察，所有操作都是无序的。——<code>指令重排序</code></p>
<p><strong>程序代码按照先后顺序执行。</strong></p>
</blockquote>
<p><code>volatile</code>可以保证<code>有序性</code>，具体参考<a href="#volatile">volatile</a></p>
<p><code>synchronized</code>和<code>Lock</code>也可以保证<code>有序性</code>，可以保证<strong>同一时刻只有一个线程能执行同步代码，线程可以顺序执行代码</strong>。</p>
<h3 id="Happens-Before-先行发生-原则"><a href="#Happens-Before-先行发生-原则" class="headerlink" title="Happens-Before(先行发生)原则"></a>Happens-Before(先行发生)原则</h3><p>JMM天生具有一定的<code>有序性</code>，不需要任何手段保证有序性，通常这个称为<strong>happens-before(先行发生)原则</strong>。</p>
<blockquote>
<p>用于描述两个操作的内存可见性，通过保证可见性的机制可以让应用程序免于数据竞争干扰。</p>
<p><strong>如果一个操作的执行结果需要另一操作可见，那么这俩操作必须存在Happen-before关系。</strong></p>
</blockquote>
<p>主要有以下几条规则：</p>
<h4 id="程序次序规则"><a href="#程序次序规则" class="headerlink" title="程序次序规则"></a>程序次序规则</h4><p>按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。<em>需要考虑分支、循环等结构。</em></p>
<h4 id="管程锁定规则"><a href="#管程锁定规则" class="headerlink" title="管程锁定规则"></a>管程锁定规则</h4><p>一个锁的<code>unlock</code>操作先行发生于<code>lock</code>操作</p>
<h4 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h4><p>对<code>volatile</code>修饰的变量的写操作先行发生于读操作</p>
<h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><p><code>Thread</code>的<code>start()</code>先行发生于此线程的每一个动作。</p>
<h4 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h4><p><code>Thread</code>的<code>interrupt()</code>先行发生于线程中断检测代码<code>Thread.interrupted()</code></p>
<h4 id="线程终止规则"><a href="#线程终止规则" class="headerlink" title="线程终止规则"></a>线程终止规则</h4><p><code>Thread</code>的所有操作都先行发生于此线程的终止检测，例如<code>Thread.join()，Thread.isAlive()</code></p>
<h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><p>对象的初始化完成先行发生于<code>finalize()</code>执行</p>
<blockquote>
<p><code>finalize</code>：垃圾回收器准备释放内存的时候，会先调用<code>finalize()</code>，可以在执行的时候做点工作。</p>
</blockquote>
<h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><p>如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><a href="/2018/12/17/volatile关键字分析/" title="volatile关键字分析">volatile关键字分析</a>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h2 id="Class文件结构-字节码"><a href="#Class文件结构-字节码" class="headerlink" title="Class文件结构(字节码)"></a>Class文件结构(字节码)</h2><h2 id="DVM-amp-ART-Android虚拟机"><a href="#DVM-amp-ART-Android虚拟机" class="headerlink" title="DVM&amp;ART(Android虚拟机)"></a>DVM&amp;ART(Android虚拟机)</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://cloud.tencent.com/developer/article/1450501" target="_blank" rel="noopener">彻底弄懂Java中的常量池</a></p>
<p><a href="https://www.cnblogs.com/gxyandwmm/p/9495923.html" target="_blank" rel="noopener">字符串常量池相关问题</a></p>
<p><a href="https://juejin.im/post/5ec73c99f265da770c0ee3b1#heading-8" target="_blank" rel="noopener">Java四大引用</a></p>
<p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">Java应用的GC优化</a></p>
<p><a href="https://mp.weixin.qq.com/s/KUCs_BJUNfMMCO1T3_WAjw" target="_blank" rel="noopener">ZGC基础概念</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JVM/">JVM</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/05/02/Java线程相关合集整理/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java线程相关合集整理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/03/31/TCP-IP协议相关/">
                        <span class="hidden-mobile">TCP/IP协议相关</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















</body>
</html>
