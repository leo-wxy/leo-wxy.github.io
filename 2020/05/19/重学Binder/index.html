

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#9b868d">
  <meta name="description" content="如果我没有见过光明，那我本可以忍受黑暗">
  <meta name="author" content="Leo-Wxy">
  <meta name="keywords" content>
  <title>重学Binder - Wxy的个人博客</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    
      
      <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css">
    
  

  
    <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">
  



<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"leo-wxy.github.io","root":"/","version":"1.8.5","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null},"tajs":null}};
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Wxy's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="重学Binder">
              
                重学Binder
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-05-19 10:22" pubdate>
        2020年5月19日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      157
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">重学Binder</h1>
            
            <div class="markdown-body">
              <!--基于先前的学习内容，重新进行Binder理论知识的整理-->
<h2 id="Linux传统的进程间通信原理"><a href="#Linux传统的进程间通信原理" class="headerlink" title="Linux传统的进程间通信原理"></a>Linux传统的进程间通信原理</h2><p><img src="/images/Linux-IPC-Basics.png" srcset="/img/loading.gif" alt="Linux进程结构"></p>
<h3 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h3><blockquote>
<p>保护系统中进程互不干扰。在操作系统中，进程之间数据是不互通的，相互之间无法访问数据，保证数据的安全星。</p>
</blockquote>
<p>在<code>进程隔离</code>的条件下，需要通过<code>IPC(Inter Process Communication)机制</code>进行进程间的通信。</p>
<h3 id="进程空间划分"><a href="#进程空间划分" class="headerlink" title="进程空间划分"></a>进程空间划分</h3><blockquote>
<p>操作系统的核心是<strong>内核</strong>，独立于普通的应用程序，可以访问受保护的内存空间以及底层的硬件设备。</p>
</blockquote>
<p>为了使用户进程不能操作内核，保证内核的安全性。所以操作系统将虚拟空间划分为两部分：</p>
<ul>
<li><p><strong>内核空间</strong>(一般占1GB)</p>
<p>系统内核运行的空间</p>
</li>
<li><p><strong>用户空间</strong>(一般占3GB)</p>
<p>用于用户程序执行的空间</p>
</li>
</ul>
<p><strong>用户空间在不同进程之间不能共享，内核空间是各个进程之间共享的。</strong></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><blockquote>
<p>用户空间的权限低于内核空间，导致用户空间无法直接访问内核资源(例如文件操作、网络访问等)，就需要借助<strong>系统调用</strong>实现内核资源访问。</p>
</blockquote>
<p><strong>系统调用</strong>是用户空间访问内核的唯一方式，保证了所有资源访问都是在内核的控制下进行，避免用户程序对系统资源的越级访问，提升系统的安全和稳定性。</p>
<p>Linux采用两级保护机制：</p>
<ul>
<li>0级供系统内核使用</li>
<li>3级供用户程序使用</li>
</ul>
<p>当进程使用<code>系统调用</code>执行内核代码时，进程就进入了<strong>内核态</strong>，此时处理器处于<code>0级·</code>；当进程执行自己的代码时，进程就进入<strong>用户态</strong>，此时处理器位于<code>3级·</code>。</p>
<p><code>系统调用</code>主要通过以下两个函数实现：</p>
<ul>
<li><code>copy_from_user</code>：将数据从用户空间拷贝到内核空间</li>
<li><code>copy_to_user</code>：将数据从内核空间拷贝到用户空间</li>
</ul>
<h3 id="传统IPC功能实现"><a href="#传统IPC功能实现" class="headerlink" title="传统IPC功能实现"></a>传统IPC功能实现</h3><p><img src="/images/Linux-IPC.png" srcset="/img/loading.gif" alt="Linux-IPC"></p>
<ol>
<li>发送进程通过<code>系统调用 copy_from_user·</code>把自己的<code>内存缓存区(发送进程)</code>的数据拷贝到<code>内核缓存区</code>中</li>
<li>内核程序通过<code>系统调用 copy_to_user</code>把内核缓存区的数据拷贝到接收进程的<code>内存缓存区</code>中</li>
</ol>
<p>传统IPC通信过程中暴露了两个明显的缺点：</p>
<ol>
<li><strong>性能低下</strong>，需要经历两次数据拷贝过程：<code>发送进程内存缓存区 -&gt; 内核缓存区 -&gt; 接收进程内存缓存区</code></li>
<li><strong>空间、时间浪费</strong>，接收方需要事先开辟一块内存空间准备接受发送方的数据，由于不能确定数据的大小。所以只能开辟一块较大的空间(<code>空间浪费</code>)或者先行获取发送数据的大小(<code>时间浪费</code>)。</li>
</ol>
<h3 id="传统Linux进程通信手段"><a href="#传统Linux进程通信手段" class="headerlink" title="传统Linux进程通信手段"></a>传统Linux进程通信手段</h3><ul>
<li>管道</li>
<li>消息队列</li>
<li><strong>共享内存</strong>：无需复制，共享缓冲区直接附加到进程的虚拟地址，速度快。<em>但是无法解决进程间同步问题</em></li>
<li><strong>套接字(Socket)</strong>：接口通用，但是传输效率低，主要用于不同机器间的通信</li>
<li><strong>信号量(semaphore)</strong>：作为一种锁机制，防止某进程正在访问共享资源时，其他进程也在访问该资源。</li>
<li>信号</li>
</ul>
<h2 id="Binder基本原理"><a href="#Binder基本原理" class="headerlink" title="Binder基本原理"></a>Binder基本原理</h2><h3 id="动态内核可加载模块"><a href="#动态内核可加载模块" class="headerlink" title="动态内核可加载模块"></a>动态内核可加载模块</h3><p><code>模块</code>是具有独立功能的程序，可以被单独编译但是无法独立运行。利用<code>动态内核可加载模块</code>机制，动态的添加一个内核模块到内核空间内，用户进程就可以通过这个模块实现通信。</p>
<p><strong>在Android系统中，加载进内核空间的模块就是<code>Binder驱动</code>。</strong></p>
<h3 id="内存映射-mmap"><a href="#内存映射-mmap" class="headerlink" title="内存映射-mmap"></a>内存映射-mmap</h3><p><code>Binder驱动</code>添加完毕后，就需要开始进程间通信。接下来就需要用到<code>mmap()——内存映射</code>。</p>
<p><code>mmap</code>用于文件或者其他对象映射进内存，通常用在有物理介质的文件系统上的，比如磁盘之类。</p>
<p>在Binder中，通过<code>mmap</code>将用户空间内的一块内存区域映射进内存空间，当映射关系建立完毕后，任何一方对内存区域的改动都会被反映到另一方。</p>
<p>Binder建立了一个虚拟设备<code>/dev/binder</code>，然后在内核空间创建了一块数据接收的缓冲区，这块<code>数据接收缓冲区</code>与<code>内核缓冲区</code>和<code>接收数据的用户空间</code>建立映射，减少了一次<em>数据拷贝</em>。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><img src="/images/Binder-IPC.png" srcset="/img/loading.gif" alt="Binder流程"></p>
<ol>
<li><code>Binder驱动</code>在<code>内核空间</code>建立一个<code>数据接收缓存区</code></li>
<li>接着在<code>内核空间</code>开辟一块<code>内核缓存区</code>，建立起<code>内核缓存区和内核数据接收缓存区</code>之间的映射关系，以及<code>数据接收缓存区和用户空间</code>的映射关系</li>
<li>发送方进程通过<code>系统调用copy_from_user</code>将数据复制到<code>内核缓存区</code>，由于各自之间存在映射，等价于<code>直接把数据传递到了接收进程</code>。</li>
</ol>
<h3 id="Binder优势"><a href="#Binder优势" class="headerlink" title="Binder优势"></a>Binder优势</h3><ul>
<li><p>性能</p>
<blockquote>
<p>Linux上的通信方式例如<code>管道、Socket</code>都需要复制两次数据。而Binder只要一次</p>
<p>拷贝两次过程：发送方数据通过<code>系统调用copy_from_user</code>拷贝到<code>内核缓存区</code>，再由<code>内核缓存区</code>调用<code>系统调用copy_to_user</code>拷贝至接收方。</p>
<p>Binder执行过程：在内核中建立数<code>据接收缓存区</code>，发送方数据通过<code>系统调用copy_from_user</code>拷贝到<code>内核缓存区</code>，此时<code>内核缓存区</code>已与<code>数据接收缓存区</code>和<code>接收进程数据缓存区</code>建立映射，相当于发送方的数据直接到接收方。</p>
</blockquote>
</li>
<li><p>安全性</p>
<blockquote>
<p>传统的Linux通信是不包含通信双方的身份验证，Binder自带身份验证，提高了安全性。</p>
<p><a href="#Binder权限验证">Binder权限验证</a></p>
</blockquote>
</li>
<li><p>稳定性</p>
<blockquote>
<p>Binder基于CS架构，Client的需求都交与Server去完成，职责明确。</p>
</blockquote>
</li>
</ul>
<h2 id="Binder通信模型"><a href="#Binder通信模型" class="headerlink" title="Binder通信模型"></a>Binder通信模型</h2><p><img src="/images/Binder通信模型.png" srcset="/img/loading.gif" alt="Binder通信模型"></p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><blockquote>
<p>客户端进程</p>
</blockquote>
<p><code>Client</code>负责向<code>Service Mananger</code>查询所需Service，并且获得一个<code>Binder代理对象</code>，再通过<code>Binder代理对象</code>向<code>Server</code>发起请求</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><blockquote>
<p>服务端进程</p>
</blockquote>
<p><code>Server</code>进程启动时，会通过<code>Binder驱动</code>注册自身的服务到<code>Service Manager</code>中，并且启动一个<code>Binder线程池</code>，用来接收<code>Client</code>的请求。</p>
<h3 id="Service-Manager"><a href="#Service-Manager" class="headerlink" title="Service Manager"></a>Service Manager</h3><blockquote>
<p>服务的管理者，指代的是<code>Native</code>层的<code>ServiceManager</code>，是整个 Binder通信机制的 大管家，也是Android进程间通信的守护进程。</p>
</blockquote>
<p>主要有以下功能</p>
<ul>
<li><code>Service</code>通过<code>Binder驱动</code>向<code>ServiceManager</code>注册Binder，表示可以对外提供服务。</li>
<li><code>Client</code>通过<code>Binder驱动</code>从<code>ServiceManager</code>获取Binder的引用。</li>
</ul>
<p><code>Service Manager</code>就是一个进程，内部维护了一张表，维护了<code>名字+Binder实体的引用</code>。</p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p><code>Service Manager</code>进程是在开机时启动的</p>
<ol>
<li>init进程解析<code>servicemanager.rc</code>之后，找到对应可执行程序<code>/system/bin/servicemanager</code></li>
<li>继续执行到<code>service_manager.c</code>的<code>main()</code></li>
</ol>
<pre><code class="hljs c"><span class="hljs-comment">//frameworks/native/cmds/servicemanager/service_manager.c</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span>
</span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span>
    <span class="hljs-keyword">union</span> selinux_callback cb;
    <span class="hljs-keyword">char</span> *driver;

    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>) &#123;
        driver = argv[<span class="hljs-number">1</span>];
    &#125; <span class="hljs-keyword">else</span> &#123;
        driver = <span class="hljs-string">"/dev/binder"</span>;
    &#125;

    bs = binder_open(driver, <span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);

    <span class="hljs-keyword">if</span> (binder_become_context_manager(bs)) &#123;
        ALOGE(<span class="hljs-string">"cannot become context manager (%s)\n"</span>, strerror(errno));
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
  
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> VENDORSERVICEMANAGER</span>
    sehandle = selinux_android_vendor_service_context_handle();
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    sehandle = selinux_android_service_context_handle();
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    selinux_status_open(<span class="hljs-literal">true</span>);

    binder_loop(bs, svcmgr_handler);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<h5 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open()"></a>binder_open()</h5><blockquote>
<p>打开设备驱动，位置为<code>/dev/binder</code></p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-comment">//frameworks/native/cmds/servicemanager/binder.c</span>
<span class="hljs-function">struct binder_state *<span class="hljs-title">binder_open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* driver, <span class="hljs-keyword">size_t</span> mapsize)</span>
</span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_state</span> *<span class="hljs-title">bs</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_version</span> <span class="hljs-title">vers</span>;</span>

    bs = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*bs));
    <span class="hljs-keyword">if</span> (!bs) &#123;
        errno = ENOMEM;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    &#125;
   <span class="hljs-comment">//打开Binder设备驱动</span>
    bs-&gt;fd = <span class="hljs-built_in">open</span>(driver, O_RDWR | O_CLOEXEC);

    bs-&gt;mapsize = mapsize;
  <span class="hljs-comment">//进行内存映射</span>
    bs-&gt;mapped = mmap(<span class="hljs-literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">return</span> bs;

fail_map:
    <span class="hljs-built_in">close</span>(bs-&gt;fd);
fail_open:
    <span class="hljs-built_in">free</span>(bs);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
&#125;</code></pre>
<p><code>bidner_open()</code>总共执行了三步：</p>
<ol>
<li><code>open()</code>打开<code>/dev/binder</code>设备节点，最终调用到内核中的<code>binder驱动</code>，同样执行到<code>binder_open()</code>，创建了<code>binder_proc</code>，再放入<code>binder_procs</code>中</li>
<li>调用<code>mmap()</code>进行内存映射，映射大小为<code>128k</code>，主要在<code>binder驱动</code>创建<code>Binder_buffer</code>对象</li>
<li>返回<code>binder_state</code>，记录着如下变量：<ul>
<li>fd：打开了<code>/dev/binder</code>的文件描述符</li>
<li>mapsize：内存映射大小</li>
<li>mapped：内存映射地址</li>
</ul>
</li>
</ol>
<h5 id="binder-become-context-manager"><a href="#binder-become-context-manager" class="headerlink" title="binder_become_context_manager()"></a>binder_become_context_manager()</h5><blockquote>
<p>注册成为大管家。</p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binder_become_context_manager</span><span class="hljs-params">(struct binder_state *bs)</span>
</span>&#123;
    <span class="hljs-keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="hljs-number">0</span>);
&#125;</code></pre>
<p>通过<code>ioctl</code>向<code>binder驱动</code>发出<code>BINDER_SET_CONTEXT_MGR</code>请求，成为上下文的管理者。</p>
<p><strong>向Binder驱动注册，它的handle句柄固定为0.</strong>这个binder的引用固定为0。</p>
<p>一个Server若要向<code>Service Manager</code>注册自己的Binder就必需通过0这个引用号和<code>Service Manager</code>的Binder通信。<em>所有需要注册自己的Server对于Service Manager来说都是Client</em></p>
<h5 id="binder-loop"><a href="#binder-loop" class="headerlink" title="binder_loop()"></a>binder_loop()</h5><blockquote>
<p>不断循环，等待客户请求</p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-comment">//frameworks/native/cmds/servicemanager/binder.c</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">binder_loop</span><span class="hljs-params">(struct binder_state *bs, binder_handler func)</span>
</span>&#123;
    <span class="hljs-keyword">int</span> res;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_write_read</span> <span class="hljs-title">bwr</span>;</span>
    <span class="hljs-keyword">uint32_t</span> readbuf[<span class="hljs-number">32</span>];

    bwr.write_size = <span class="hljs-number">0</span>;
    bwr.write_consumed = <span class="hljs-number">0</span>;
    bwr.write_buffer = <span class="hljs-number">0</span>;

    readbuf[<span class="hljs-number">0</span>] = BC_ENTER_LOOPER;
  <span class="hljs-comment">//向Binder驱动发送 BC_ENTER_LOOPER 协议，让Service Manager进入循环状态</span>
    binder_write(bs, readbuf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>));

    <span class="hljs-keyword">for</span> (;;) &#123;
        bwr.read_size = <span class="hljs-keyword">sizeof</span>(readbuf);
        bwr.read_consumed = <span class="hljs-number">0</span>;
       <span class="hljs-comment">//读取Binder的数据 就会写到 readbuf中，此时就可以进行解析操作</span>
        bwr.read_buffer = (<span class="hljs-keyword">uintptr_t</span>) readbuf;
       <span class="hljs-comment">//使Service Manager进入内核态</span>
        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
       <span class="hljs-comment">//等待解析Client的请，收到消息切换用户态</span>
        res = binder_parse(bs, <span class="hljs-number">0</span>, (<span class="hljs-keyword">uintptr_t</span>) readbuf, bwr.read_consumed, func);
    &#125;
&#125;</code></pre>
<p><code>Service Manager</code>通过<code>binder_write()</code>向<code>binder驱动</code>发送<code>BC_ENTER_LOOPER</code>协议，然后<code>Service Manager</code>进入循环状态。开启for循环，接着通过<code>ioctl()</code>发送<code>BINDER_WRITE_READ</code>请求到<code>Binder驱动</code>，使<code>Service Manager</code>进入<code>内核态</code>，开始等待<code>Client</code>发起请求。未收到请求时，处于等待状态。收到请求后调用<code>binder_parse()</code>解析接收到的请求并切换到<code>用户态</code>。</p>
<p><code>BINDER_WRITE_READ</code>：向<code>Binder驱动</code>进行<code>读取或写入操作</code>，参数分为两部分<code>write_size</code>和<code>read_size</code></p>
<ul>
<li><code>write_size</code>不为空，取出<code>write_buffer</code>的数据写入到<code>Binder</code>里。</li>
<li><code>read_size</code>不为空，<code>Binder</code>写数据到<code>read_buffer</code>。<code>read_buffer</code>没有数据，就处于等待状态。</li>
</ul>
<p><code>binder_write()</code></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binder_write</span><span class="hljs-params">(struct binder_state *bs, <span class="hljs-keyword">void</span> *data, <span class="hljs-keyword">size_t</span> len)</span>
</span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_write_read</span> <span class="hljs-title">bwr</span>;</span>
    <span class="hljs-keyword">int</span> res;

    bwr.write_size = len;
    bwr.write_consumed = <span class="hljs-number">0</span>;
    bwr.write_buffer = (<span class="hljs-keyword">uintptr_t</span>) data;
    bwr.read_size = <span class="hljs-number">0</span>;
    bwr.read_consumed = <span class="hljs-number">0</span>;
    bwr.read_buffer = <span class="hljs-number">0</span>;
    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
    <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">"binder_write: ioctl failed (%s)\n"</span>,
                strerror(errno));
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre>
<p><code>binder_write()</code>实质调用<code>ioctl()</code>，负责的是向<code>Binder驱动</code>写入数据。除了<code>BC_ENTER_LOOP</code>，还有其他类型的命令(<code>以BC_开头</code>)</p>
<p><code>BC</code>可以<strong>理解为向Binder写入数据</strong>。</p>
<pre><code class="hljs c"><span class="hljs-keyword">enum</span> binder_driver_command_protocol &#123;
  BC_TRANSACTION = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">0</span>, struct binder_transaction_data), <span class="hljs-comment">//Client向Server 发送请求数据，向Binder写入请求数据</span>
  BC_REPLY = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">1</span>, struct binder_transaction_data), <span class="hljs-comment">//Server 向Client 返回数据，向Binder写入回复数据</span>
  BC_ACQUIRE_RESULT = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">2</span>, __s32),
  BC_FREE_BUFFER = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">3</span>, <span class="hljs-keyword">binder_uintptr_t</span>),<span class="hljs-comment">//释放一块mmap映射的内存</span>
  BC_INCREFS = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">4</span>, __u32),
  BC_ACQUIRE = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">5</span>, __u32),
  BC_RELEASE = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">6</span>, __u32),
  BC_DECREFS = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">7</span>, __u32),
  BC_INCREFS_DONE = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">8</span>, struct binder_ptr_cookie),
  BC_ACQUIRE_DONE = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">9</span>, struct binder_ptr_cookie),
  BC_ATTEMPT_ACQUIRE = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">10</span>, struct binder_pri_desc),
  BC_REGISTER_LOOPER = _IO(<span class="hljs-string">'c'</span>, <span class="hljs-number">11</span>),
  BC_ENTER_LOOPER = _IO(<span class="hljs-string">'c'</span>, <span class="hljs-number">12</span>),
  BC_EXIT_LOOPER = _IO(<span class="hljs-string">'c'</span>, <span class="hljs-number">13</span>),
  BC_REQUEST_DEATH_NOTIFICATION = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">14</span>, struct binder_handle_cookie),
  BC_CLEAR_DEATH_NOTIFICATION = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">15</span>, struct binder_handle_cookie),
  BC_DEAD_BINDER_DONE = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">16</span>, <span class="hljs-keyword">binder_uintptr_t</span>),
  BC_TRANSACTION_SG = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">17</span>, struct binder_transaction_data_sg),
  BC_REPLY_SG = _IOW(<span class="hljs-string">'c'</span>, <span class="hljs-number">18</span>, struct binder_transaction_data_sg),
&#125;;</code></pre>
<p><code>binder_parse()</code></p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binder_parse</span><span class="hljs-params">(struct binder_state *bs, struct binder_io *bio,
                 <span class="hljs-keyword">uintptr_t</span> ptr, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, binder_handler func)</span>
</span>&#123;
    <span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">uintptr_t</span> <span class="hljs-built_in">end</span> = ptr + (<span class="hljs-keyword">uintptr_t</span>) <span class="hljs-built_in">size</span>;

    <span class="hljs-keyword">while</span> (ptr &lt; <span class="hljs-built_in">end</span>) &#123;
        <span class="hljs-keyword">switch</span>(cmd) &#123;
       ...
        <span class="hljs-keyword">case</span> BR_TRANSACTION: &#123;
          <span class="hljs-comment">//当前是Binder驱动向 ServiceManager 发送请求数据，例如获取服务、注册服务</span>
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_transaction_data</span> *<span class="hljs-title">txn</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">binder_transaction_data</span> *) <span class="hljs-title">ptr</span>;</span>
            <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">end</span> - ptr) &lt; <span class="hljs-keyword">sizeof</span>(*txn)) &#123;
                ALOGE(<span class="hljs-string">"parse: txn too small!\n"</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
            &#125;
            binder_dump_txn(txn);
            <span class="hljs-keyword">if</span> (func) &#123; <span class="hljs-comment">//func 指的就是 ServiceManager初始化的时候 传进来的 svcmgr_handler 函数</span>
                <span class="hljs-keyword">unsigned</span> rdata[<span class="hljs-number">256</span>/<span class="hljs-number">4</span>];
                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>;</span>
                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">reply</span>;</span>
                <span class="hljs-keyword">int</span> res;

                bio_init(&amp;reply, rdata, <span class="hljs-keyword">sizeof</span>(rdata), <span class="hljs-number">4</span>);
                bio_init_from_txn(&amp;msg, txn);
                res = func(bs, txn, &amp;msg, &amp;reply);
                <span class="hljs-keyword">if</span> (txn-&gt;flags &amp; TF_ONE_WAY) &#123;
                    binder_free_buffer(bs, txn-&gt;data.ptr.<span class="hljs-built_in">buffer</span>);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.<span class="hljs-built_in">buffer</span>, res);<span class="hljs-comment">//返回应答数据</span>
                &#125;
            &#125;
            ptr += <span class="hljs-keyword">sizeof</span>(*txn);
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">case</span> BR_REPLY: &#123;
          <span class="hljs-comment">//当前是Binder驱动 向 ServiceManager发送 回复数据</span>
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_transaction_data</span> *<span class="hljs-title">txn</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">binder_transaction_data</span> *) <span class="hljs-title">ptr</span>;</span>
            <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">end</span> - ptr) &lt; <span class="hljs-keyword">sizeof</span>(*txn)) &#123;
                ALOGE(<span class="hljs-string">"parse: reply too small!\n"</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
            &#125;
            binder_dump_txn(txn);
            <span class="hljs-keyword">if</span> (bio) &#123;
                bio_init_from_txn(bio, txn);
                bio = <span class="hljs-number">0</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">/* todo FREE BUFFER */</span>
            &#125;
            ptr += <span class="hljs-keyword">sizeof</span>(*txn);
            r = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">case</span> BR_DEAD_BINDER: &#123;
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_death</span> *<span class="hljs-title">death</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">binder_death</span> *)(<span class="hljs-title">uintptr_t</span>) *(<span class="hljs-title">binder_uintptr_t</span> *)<span class="hljs-title">ptr</span>;</span>
            ptr += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">binder_uintptr_t</span>);
            death-&gt;func(bs, death-&gt;ptr);
            <span class="hljs-keyword">break</span>;
        &#125;
        ...
    &#125;

    <span class="hljs-keyword">return</span> r;
&#125;</code></pre>
<p><code>binder_parse()</code>负责解析<code>read_buffer</code>读取到的数据。</p>
<p><code>binder_parse()</code>主要就是解析<code>BR_</code>开头的指令，上面重要的就是<code>BR_TRANSACTION</code>和<code>BR_REPLY</code>。除此之外还有其他的<code>BR_</code>指令</p>
<p><code>BR</code>可以<strong>理解为从Binder读取数据</strong>。</p>
<pre><code class="hljs c"><span class="hljs-keyword">enum</span> binder_driver_return_protocol &#123;
  BR_ERROR = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">0</span>, __s32),<span class="hljs-comment">//发生内部错误</span>
  BR_OK = _IO(<span class="hljs-string">'r'</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">//操作完成</span>
  BR_TRANSACTION = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">2</span>, struct binder_transaction_data), <span class="hljs-comment">//读取请求数据，从Binder读取请求数据 然后发送到Server</span>
  BR_REPLY = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">3</span>, struct binder_transaction_data), <span class="hljs-comment">//读取回复数据，从Binder读取回复数据 然后发送到Client</span>
  BR_ACQUIRE_RESULT = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">4</span>, __s32),
  BR_DEAD_REPLY = _IO(<span class="hljs-string">'r'</span>, <span class="hljs-number">5</span>), <span class="hljs-comment">//对方进程或线程已死</span>
  BR_TRANSACTION_COMPLETE = _IO(<span class="hljs-string">'r'</span>, <span class="hljs-number">6</span>),
  BR_INCREFS = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">7</span>, struct binder_ptr_cookie),
  BR_ACQUIRE = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">8</span>, struct binder_ptr_cookie),
  BR_RELEASE = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">9</span>, struct binder_ptr_cookie),
  BR_DECREFS = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">10</span>, struct binder_ptr_cookie),
  BR_ATTEMPT_ACQUIRE = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">11</span>, struct binder_pri_ptr_cookie),
  BR_NOOP = _IO(<span class="hljs-string">'r'</span>, <span class="hljs-number">12</span>),
  BR_SPAWN_LOOPER = _IO(<span class="hljs-string">'r'</span>, <span class="hljs-number">13</span>),
  BR_FINISHED = _IO(<span class="hljs-string">'r'</span>, <span class="hljs-number">14</span>),
  BR_DEAD_BINDER = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">15</span>, <span class="hljs-keyword">binder_uintptr_t</span>),<span class="hljs-comment">//向持有Binder引用的进程通知Binder已死</span>
  BR_CLEAR_DEATH_NOTIFICATION_DONE = _IOR(<span class="hljs-string">'r'</span>, <span class="hljs-number">16</span>, <span class="hljs-keyword">binder_uintptr_t</span>),
  BR_FAILED_REPLY = _IO(<span class="hljs-string">'r'</span>, <span class="hljs-number">17</span>),
&#125;;</code></pre>
<p>其中<code>BR_TRANSACTION</code>需要进行特殊处理，实现<code>对外提供服务</code>功能。例如提供<code>获取服务、注册服务功能</code>。<em>后面会简单的讲解</em></p>
<p>当<code>binder_parse()</code>收到<code>BR_TRANSACTION</code>之后，就会执行到<code>svcmgr_handler()</code></p>
<pre><code class="hljs c"><span class="hljs-comment">//frameworks/native/cmds/servicemanager/service_manager.c</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">svcmgr_handler</span><span class="hljs-params">(struct binder_state *bs,
                   struct binder_transaction_data *txn,
                   struct binder_io *msg,
                   struct binder_io *reply)</span>
</span>&#123; 
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">svcinfo</span> *<span class="hljs-title">si</span>;</span><span class="hljs-comment">//记录着 服务信息</span>
    <span class="hljs-keyword">uint16_t</span> *s;
    <span class="hljs-keyword">size_t</span> len;
    <span class="hljs-keyword">uint32_t</span> handle;
    <span class="hljs-keyword">uint32_t</span> strict_policy;  
  ...
    <span class="hljs-keyword">switch</span>(txn-&gt;code) &#123;
    <span class="hljs-keyword">case</span> SVC_MGR_GET_SERVICE:
    <span class="hljs-keyword">case</span> SVC_MGR_CHECK_SERVICE:<span class="hljs-comment">//获取服务 一般是Client发起获取服务请求</span>
        s = bio_get_string16(msg, &amp;len);<span class="hljs-comment">//服务名</span>
        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);<span class="hljs-comment">//获取对应服务</span>
        <span class="hljs-keyword">if</span> (!handle)
            <span class="hljs-keyword">break</span>;
        bio_put_ref(reply, handle);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> SVC_MGR_ADD_SERVICE:<span class="hljs-comment">//添加服务 一般是Server发起注册服务请求</span>
        s = bio_get_string16(msg, &amp;len);
        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        handle = bio_get_ref(msg);
        allow_isolated = bio_get_uint32(msg) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        dumpsys_priority = bio_get_uint32(msg);
        <span class="hljs-keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority,
                           txn-&gt;sender_pid))<span class="hljs-comment">//注册服务</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> SVC_MGR_LIST_SERVICES: &#123; <span class="hljs-comment">//列举所有注册的服务</span>
        <span class="hljs-keyword">uint32_t</span> n = bio_get_uint32(msg);
        <span class="hljs-keyword">uint32_t</span> req_dumpsys_priority = bio_get_uint32(msg);

        <span class="hljs-keyword">if</span> (!svc_can_list(txn-&gt;sender_pid, txn-&gt;sender_euid)) &#123;
            ALOGE(<span class="hljs-string">"list_service() uid=%d - PERMISSION DENIED\n"</span>,
                    txn-&gt;sender_euid);
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        si = svclist;
        <span class="hljs-comment">// walk through the list of services n times skipping services that</span>
        <span class="hljs-comment">// do not support the requested priority</span>
        <span class="hljs-keyword">while</span> (si) &#123;
            <span class="hljs-keyword">if</span> (si-&gt;dumpsys_priority &amp; req_dumpsys_priority) &#123;
                <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
                n--;
            &#125;
            si = si-&gt;next;
        &#125;
        <span class="hljs-keyword">if</span> (si) &#123;
            bio_put_string16(reply, si-&gt;name);
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
    <span class="hljs-keyword">default</span>:
        ALOGE(<span class="hljs-string">"unknown code %d\n"</span>, txn-&gt;code);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;

    bio_put_uint32(reply, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p><code>svcmgr_handler()</code>主要提供服务相关的功能，根据不同的<code>code</code>有对应的功能：</p>
<ul>
<li><code>SVG_MGR_GET_SERVICE</code>，<code>SVC_MGR_CHECK_SERVICE</code>：获取服务</li>
<li><code>SVC_MGR_ADD_SERVICE</code>：注册服务</li>
<li><code>SVC_MGR_LIST_SERVICES</code>：列举所有服务</li>
</ul>
<p><code>Service Manager</code>存储的是一个<code>svclist</code>的一个链表结构，里面存储的对象为<code>svcinfo</code></p>
<pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">svcinfo</span>
&#123;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">svcinfo</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//下一个注册服务</span>
    <span class="hljs-keyword">uint32_t</span> handle; <span class="hljs-comment">//服务的 句柄</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_death</span> <span class="hljs-title">death</span>;</span>
    <span class="hljs-keyword">int</span> allow_isolated;
    <span class="hljs-keyword">uint32_t</span> dumpsys_priority;
    <span class="hljs-keyword">size_t</span> len;
    <span class="hljs-keyword">uint16_t</span> name[<span class="hljs-number">0</span>]; <span class="hljs-comment">//服务名</span>
&#125;;</code></pre>
<p><img src="/images/5-2-2.start_service_manager.jpg" srcset="/img/loading.gif" alt="ServiceManager启动过程"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>ServiceManager</code>启动过程主要执行以下几步：</p>
<ol>
<li><code>binder_open()</code>：打开驱动，<code>/dev/binder</code></li>
<li><code>binder_become_context_manager()</code>：成为管家，并准备进入循环</li>
<li><code>binder_loop()</code>：开启循环，等待新消息并处理</li>
</ol>
<h4 id="获取Service-Manager代理对象"><a href="#获取Service-Manager代理对象" class="headerlink" title="获取Service Manager代理对象"></a>获取Service Manager代理对象</h4><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/binder/IServiceManager.cpp</span>
[[clang::no_destroy]] <span class="hljs-keyword">static</span> sp&lt;IServiceManager&gt; gDefaultServiceManager;

<span class="hljs-function">sp&lt;IServiceManager&gt; <span class="hljs-title">defaultServiceManager</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (gDefaultServiceManager != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> gDefaultServiceManager;

    &#123;
        AutoMutex _l(gDefaultServiceManagerLock);
        <span class="hljs-keyword">while</span> (gDefaultServiceManager == <span class="hljs-literal">NULL</span>) &#123;
            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(
                ProcessState::self()-&gt;getContextObject(<span class="hljs-literal">NULL</span>));
            <span class="hljs-keyword">if</span> (gDefaultServiceManager == <span class="hljs-literal">NULL</span>)
                sleep(<span class="hljs-number">1</span>);
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> gDefaultServiceManager;
&#125;</code></pre>
<p><code>gDefaultServiceManager</code>的创建过程主要分为以下几步：</p>
<h5 id="ProcessState-self"><a href="#ProcessState-self" class="headerlink" title="ProcessState::self()"></a><code>ProcessState::self()</code></h5><blockquote>
<p>用于创建<code>ProcessState</code>对象，每个进程有且只有一个</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/binder/ProcessState.cpp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_MAX_BINDER_THREADS 15</span>

<span class="hljs-function">sp&lt;ProcessState&gt; <span class="hljs-title">ProcessState::self</span><span class="hljs-params">()</span>
</span>&#123;
    Mutex::Autolock _l(gProcessMutex);
    <span class="hljs-keyword">if</span> (gProcess != <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//采用单例模式，保证只有一个</span>
        <span class="hljs-keyword">return</span> gProcess;
    &#125;
    gProcess = <span class="hljs-keyword">new</span> ProcessState(DEFAULT_BINDER_VM_SIZE);<span class="hljs-comment">//实例化ProcessState</span>
    <span class="hljs-keyword">return</span> gProcess;
&#125;

ProcessState::ProcessState(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *driver)
    : mDriverName(String8(driver))
    , mDriverFD(open_driver(driver)) <span class="hljs-comment">//1⃣️ 打开binder驱动</span>
    , mVMStart(MAP_FAILED)
    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)
    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)
    , mExecutingThreadsCount(<span class="hljs-number">0</span>)
    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)
    , mStarvationStartTimeMs(<span class="hljs-number">0</span>)
    , mThreadPoolStarted(<span class="hljs-literal">false</span>)
    , mThreadPoolSeq(<span class="hljs-number">1</span>)
    , mCallRestriction(CallRestriction::NONE)
&#123;

    <span class="hljs-keyword">if</span> (mDriverFD &gt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">//3⃣️ 通过mmap 在 binder驱动映射一块内存，用来接收事务</span>
        mVMStart = mmap(<span class="hljs-literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (mVMStart == MAP_FAILED) &#123;
            <span class="hljs-comment">// *sigh*</span>
            ALOGE(<span class="hljs-string">"Using %s failed: unable to mmap transaction memory.\n"</span>, mDriverName.c_str());
            close(mDriverFD);
            mDriverFD = <span class="hljs-number">-1</span>;
            mDriverName.clear();
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">open_driver</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *driver)</span>
</span>&#123;
    <span class="hljs-keyword">int</span> fd = open(driver, O_RDWR | O_CLOEXEC);
    <span class="hljs-keyword">if</span> (fd &gt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">int</span> vers = <span class="hljs-number">0</span>;
      <span class="hljs-comment">//获取Binder驱动版本</span>
        <span class="hljs-keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);
        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;
            ALOGE(<span class="hljs-string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));
            close(fd);
            fd = <span class="hljs-number">-1</span>;
        &#125;

        <span class="hljs-keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;
      <span class="hljs-comment">//2⃣️ 通过 ioctl为 binder驱动设置 最大线程数，默认为15</span>
        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);
        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;
            ALOGE(<span class="hljs-string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        ALOGW(<span class="hljs-string">"Opening '%s' failed: %s\n"</span>, driver, strerror(errno));
    &#125;
    <span class="hljs-keyword">return</span> fd;
&#125;</code></pre>
<p><code>ProcessState</code>可以保证每个进程打开<code>binder设备</code>一次，通过<code>mDriverFd</code>记录<code>binder驱动</code>的fd，可以用于后续访问Binder设备。</p>
<p><code>ProcessState</code>的初始化过程主要执行了以下几步：</p>
<ol>
<li>1⃣️<code>open_driver()</code>：打开<code>binder驱动</code>设备，并且验证binder驱动版本是否一致。</li>
<li>2⃣️<code>ioctl()</code>：为<code>binder驱动</code>设置最大线程数，默认为<code>15</code>。加上主binder线程，所以最多为<code>16</code>个。</li>
<li>3⃣️<code>mmap()</code>：在<code>binder驱动</code>中分配一块<code>1016KB</code>大小的空间，用于处理事务。</li>
</ol>
<h5 id="getContextObject"><a href="#getContextObject" class="headerlink" title="getContextObject()"></a><code>getContextObject()</code></h5><blockquote>
<p>主要为了获取<code>BpBinder对象</code></p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ProcessState::getContextObject</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="hljs-comment">/*caller*/</span>)</span>
</span>&#123;
  <span class="hljs-comment">//打开handle 为 0 的IBinder对象</span>
    sp&lt;IBinder&gt; context = getStrongProxyForHandle(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">return</span> context;
&#125;</code></pre>
<p>获取<code>handle==0</code>的IBinder对象，实际就是<code>ServiceManager</code>的<code>BpBinder</code>对象。</p>
<pre><code class="hljs cpp"><span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ProcessState::getStrongProxyForHandle</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> handle)</span>
</span>&#123;
    sp&lt;IBinder&gt; result;

    AutoMutex _l(mLock);
   <span class="hljs-comment">//根据 handle 查找对应的 handle_entry</span>
    handle_entry* e = lookupHandleLocked(handle);

    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">nullptr</span>) &#123;
        IBinder* b = e-&gt;binder;
        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">nullptr</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="hljs-keyword">this</span>)) &#123;
            <span class="hljs-keyword">if</span> (handle == <span class="hljs-number">0</span>) &#123;

                IPCThreadState* ipc = IPCThreadState::self();

                CallRestriction originalCallRestriction = ipc-&gt;getCallRestriction();
                ipc-&gt;setCallRestriction(CallRestriction::NONE);

                Parcel data;
              <span class="hljs-comment">//验证binder是否就绪</span>
                <span class="hljs-keyword">status_t</span> status = ipc-&gt;transact(
                        <span class="hljs-number">0</span>, IBinder::PING_TRANSACTION, data, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);

                ipc-&gt;setCallRestriction(originalCallRestriction);

                <span class="hljs-keyword">if</span> (status == DEAD_OBJECT)
                   <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
            &#125;
           <span class="hljs-comment">//handle值对应的 IBinder不存在或无效时，新建一个 BpBinder对象</span>
            b = BpBinder::create(handle);
            e-&gt;binder = b;
            <span class="hljs-keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();
            result = b;
        &#125; <span class="hljs-keyword">else</span> &#123;
            result.force_set(b);
            e-&gt;refs-&gt;decWeak(<span class="hljs-keyword">this</span>);
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> result;
&#125;</code></pre>
<p><code>getContextObj()</code>主要执行了以下几步：</p>
<ol>
<li><code>getStrongProxyforHandle()</code>：获取<code>handle==0</code>的IBinder对象</li>
<li><code>IPCThreadState::self()-&gt;transact()</code>：向<code>Binder驱动</code>传递对象，判断<code>Binder驱动</code>是否就绪</li>
<li><code>BpBinder::create()</code>：创建<code>ServiceManager</code>的<code>BpBinder</code>对象</li>
</ol>
<h5 id="interface-cast"><a href="#interface-cast" class="headerlink" title="interface_cast()"></a><code>interface_cast()</code></h5><blockquote>
<p>创建BpServiceManager对象</p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-comment">// IInterface.h</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> sp&lt;INTERFACE&gt; <span class="hljs-title">interface_cast</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span>
</span>&#123;
    <span class="hljs-keyword">return</span> INTERFACE::asInterface(obj);
  <span class="hljs-comment">//等价于 IServiceManager::asInterface</span>
&#125;</code></pre>
<p><code>interface_cast()</code>是一个模板函数，经过操作后最后得到</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">const</span> android::String16 <span class="hljs-title">IServiceManager::descriptor</span><span class="hljs-params">(“android.os.IServiceManager”)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">const</span> android::String16&amp; <span class="hljs-title">IServiceManager::getInterfaceDescriptor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>&#123;
     <span class="hljs-keyword">return</span> IServiceManager::descriptor;
&#125;

 <span class="hljs-function">android::sp&lt;IServiceManager&gt; <span class="hljs-title">IServiceManager::asInterface</span><span class="hljs-params">(<span class="hljs-keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)</span>
</span>&#123;
       android::sp&lt;IServiceManager&gt; intr;
        <span class="hljs-keyword">if</span>(obj != <span class="hljs-literal">NULL</span>) &#123;
           intr = <span class="hljs-keyword">static_cast</span>&lt;IServiceManager *&gt;(
               obj-&gt;queryLocalInterface(IServiceManager::descriptor).get());
           <span class="hljs-keyword">if</span> (intr == <span class="hljs-literal">NULL</span>) &#123;
               intr = <span class="hljs-keyword">new</span> BpServiceManager(obj); <span class="hljs-comment">//创建BpServiceManager对象</span>
            &#125;
        &#125;
       <span class="hljs-keyword">return</span> intr;
&#125;</code></pre>
<p>此时初始化<code>BpServiceManager</code>对象</p>
<pre><code class="hljs cpp">    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BpServiceManager</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span>
        : BpInterface&lt;IServiceManager&gt;<span class="hljs-params">(impl)</span>
    </span>&#123;
    &#125;

<span class="hljs-comment">// IInterface.h</span>
<span class="hljs-keyword">inline</span> BpRefBase&lt;IServiceManager&gt;::BpInterface(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; remote)
    :BpRefBase(remote)
&#123;    &#125;

<span class="hljs-comment">// Binder.cpp</span>
BpRefBase::BpRefBase(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; o)
    : mRemote(o.get()), mRefs(<span class="hljs-literal">NULL</span>), mState(<span class="hljs-number">0</span>)
&#123;
    extendObjectLifetime(OBJECT_LIFETIME_WEAK);
    <span class="hljs-keyword">if</span> (mRemote) &#123;
        mRemote-&gt;incStrong(<span class="hljs-keyword">this</span>);
        mRefs = mRemote-&gt;createWeak(<span class="hljs-keyword">this</span>);
    &#125;
&#125;</code></pre>
<p><code>BpServiceManager</code>初始化过程中，依次调用<code>BpRefBase</code>，<code>BpRefBase</code>，<code>BpServiceManager</code>的构造函数，赋予BpRefBase的mRemote的值为BpBinder(0)。</p>
<p>最后可知<strong>defaultServiceManager 等价于 new BpServiceManager(new BpBinder(0))</strong></p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="/images/5-2-4-get_service_manager.jpg" srcset="/img/loading.gif" alt="获取ServiceManager代理"></p>
<ul>
<li>open: 创建binder_proc</li>
<li>BINDER_SET_MAX_THREADS: 设置proc-&gt;max_threads</li>
<li>mmap: 创建创建binder_buffer</li>
</ul>
<h5 id="javaObjectForIBinder"><a href="#javaObjectForIBinder" class="headerlink" title="javaObjectForIBinder()"></a><code>javaObjectForIBinder()</code></h5><blockquote>
<p>主要为了获取<code>BinderProxy</code>对象</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/base/core/jni/android_util_Binder.cpp</span>
<span class="hljs-comment">//负责创建一个 BinderProxy对象</span>
<span class="hljs-function">jobject <span class="hljs-title">javaObjectForIBinder</span><span class="hljs-params">(JNIEnv* env, <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span>
</span>&#123;

    BinderProxyNativeData* nativeData = <span class="hljs-keyword">new</span> BinderProxyNativeData();
    nativeData-&gt;mOrgue = <span class="hljs-keyword">new</span> DeathRecipientList;
    nativeData-&gt;mObject = val;

    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,
            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());
    <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) &#123;
        <span class="hljs-comment">// In the exception case, getInstance still took ownership of nativeData.</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    &#125;
    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);
    <span class="hljs-keyword">if</span> (actualNativeData == nativeData) &#123;
        <span class="hljs-comment">// Created a new Proxy</span>
        <span class="hljs-keyword">uint32_t</span> numProxies = gNumProxies.fetch_add(<span class="hljs-number">1</span>, <span class="hljs-built_in">std</span>::memory_order_relaxed);
        <span class="hljs-keyword">uint32_t</span> numLastWarned = gProxiesWarned.load(<span class="hljs-built_in">std</span>::memory_order_relaxed);
        <span class="hljs-keyword">if</span> (numProxies &gt;= numLastWarned + PROXY_WARN_INTERVAL) &#123;
            <span class="hljs-comment">// Multiple threads can get here, make sure only one of them gets to</span>
            <span class="hljs-comment">// update the warn counter.</span>
            <span class="hljs-keyword">if</span> (gProxiesWarned.compare_exchange_strong(numLastWarned,
                        numLastWarned + PROXY_WARN_INTERVAL, <span class="hljs-built_in">std</span>::memory_order_relaxed)) &#123;
                ALOGW(<span class="hljs-string">"Unexpectedly many live BinderProxies: %d\n"</span>, numProxies);
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">delete</span> nativeData;
    &#125;

    <span class="hljs-keyword">return</span> object;
&#125;</code></pre>
<p>执行完成后<code>BinderInternal.getContextObject()</code>得到<code>BinderProxy</code></p>
<p>继续调用到<code>ServiceManagerNative.asInterface()</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//frameworks/base/core/java/android/os/ServiceManagerNative.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IServiceManager <span class="hljs-title">asInterface</span><span class="hljs-params">(IBinder obj)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;

        <span class="hljs-comment">// ServiceManager is never local</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceManagerProxy(obj);
    &#125;</code></pre>
<p>等价于最后生成的代理对象就是<code>ServiceManagerProxy</code>。</p>
<h4 id="Service-Manager-注册服务"><a href="#Service-Manager-注册服务" class="headerlink" title="Service Manager 注册服务"></a>Service Manager 注册服务</h4><blockquote>
<p>Service 向 Service Manager 注册服务</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//ServiceManager.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addService</span><span class="hljs-params">(String name, IBinder service, <span class="hljs-keyword">boolean</span> allowIsolated,
            <span class="hljs-keyword">int</span> dumpPriority)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            getIServiceManager().addService(name, service, allowIsolated, dumpPriority);
        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
            Log.e(TAG, <span class="hljs-string">"error in addService"</span>, e);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IServiceManager <span class="hljs-title">getIServiceManager</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (sServiceManager != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> sServiceManager;
        &#125;

        <span class="hljs-comment">// Find the service manager</span>
        sServiceManager = ServiceManagerNative
                .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));
        <span class="hljs-keyword">return</span> sServiceManager;
    &#125;</code></pre>
<p><code>sServiceManager</code>最后得到的就是上节中的<code>BpServiceManager</code>对象</p>
<pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/binder/IServiceManager.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">status_t</span> <span class="hljs-title">addService</span><span class="hljs-params">(<span class="hljs-keyword">const</span> String16&amp; name, <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; service,
                                <span class="hljs-keyword">bool</span> allowIsolated, <span class="hljs-keyword">int</span> dumpsysPriority)</span> </span>&#123;
        Parcel data, reply;
        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
        data.writeString16(name);<span class="hljs-comment">//服务的name</span>
        data.writeStrongBinder(service);<span class="hljs-comment">//具体 服务</span>
        data.writeInt32(allowIsolated ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
        data.writeInt32(dumpsysPriority);
  <span class="hljs-comment">//remote 表示 BpBinder对象</span>
        <span class="hljs-keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);
        <span class="hljs-keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;
    &#125;</code></pre>
<p><code>addService()</code>具体就是向<code>Service Manager</code>注册服务，将相关数据封装到<code>Parcel</code>对象。</p>
<p>接下来通过<code>BpBinder</code>调用<code>transact()</code>传输数据</p>
<pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/binder/BpBinder.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">BpBinder::transact</span><span class="hljs-params">(
    <span class="hljs-keyword">uint32_t</span> code, <span class="hljs-keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-keyword">uint32_t</span> flags)</span>
</span>&#123;
    <span class="hljs-comment">// Once a binder has died, it will never come back to life.</span>
    <span class="hljs-keyword">if</span> (mAlive) &#123;
        <span class="hljs-keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);
        <span class="hljs-keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> status;
    &#125;

    <span class="hljs-keyword">return</span> DEAD_OBJECT;
&#125;</code></pre>
<h5 id="IPCThreadState-gt-transact"><a href="#IPCThreadState-gt-transact" class="headerlink" title="IPCThreadState-&gt;transact"></a>IPCThreadState-&gt;transact</h5><blockquote>
<p>初始化IPCThreadState之后，向<code>Binder驱动</code>发送数据</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/binder/IPCThreadState.cpp</span>
<span class="hljs-function">IPCThreadState* <span class="hljs-title">IPCThreadState::self</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (gHaveTLS) &#123;
restart:
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_key_t</span> k = gTLS;
        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);
        <span class="hljs-keyword">if</span> (st) <span class="hljs-keyword">return</span> st;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IPCThreadState;<span class="hljs-comment">//初始IPCThreadState</span>
    &#125;

    pthread_mutex_lock(&amp;gTLSMutex);
    <span class="hljs-keyword">if</span> (!gHaveTLS) &#123;
        <span class="hljs-keyword">int</span> key_create_value = pthread_key_create(&amp;gTLS, threadDestructor);
        <span class="hljs-keyword">if</span> (key_create_value != <span class="hljs-number">0</span>) &#123;
            pthread_mutex_unlock(&amp;gTLSMutex);
            ALOGW(<span class="hljs-string">"IPCThreadState::self() unable to create TLS key, expect a crash: %s\n"</span>,
                    strerror(key_create_value));
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
        gHaveTLS = <span class="hljs-literal">true</span>;
    &#125;
    pthread_mutex_unlock(&amp;gTLSMutex);
    <span class="hljs-keyword">goto</span> restart;
&#125;

IPCThreadState::IPCThreadState()
    : mProcess(ProcessState::self()),
      mStrictModePolicy(<span class="hljs-number">0</span>),
      mLastTransactionBinderFlags(<span class="hljs-number">0</span>)
&#123;
    pthread_setspecific(gTLS, <span class="hljs-keyword">this</span>);
    clearCaller();
    mIn.setDataCapacity(<span class="hljs-number">256</span>);
    mOut.setDataCapacity(<span class="hljs-number">256</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IPCThreadState::clearCaller</span><span class="hljs-params">()</span>
</span>&#123;
    mCallingPid = getpid(); <span class="hljs-comment">//初始化PID</span>
    mCallingUid = getuid(); <span class="hljs-comment">//初始化UID</span>
&#125;</code></pre>
<p>每个线程都有一个<code>IPCThreadState</code>，内部包含如下参数：</p>
<ul>
<li><code>mIn</code>：接收来自Binder设备的数据</li>
<li><code>mOut</code>：存储发送Binder设备的数据</li>
<li><code>mProcess</code>：当前进程的<code>ProcessState</code></li>
<li><code>mCallingPid</code>：当前进程的Pid</li>
<li><code>mCallingUid</code>：当前进程的Uid</li>
</ul>
<p>接下来执行<code>transact()</code>传输数据</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">IPCThreadState::transact</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> handle,
                                  <span class="hljs-keyword">uint32_t</span> code, <span class="hljs-keyword">const</span> Parcel&amp; data,
                                  Parcel* reply, <span class="hljs-keyword">uint32_t</span> flags)</span>
</span>&#123;
    <span class="hljs-keyword">status_t</span> err;

    flags |= TF_ACCEPT_FDS;
   <span class="hljs-comment">//传输数据</span>
    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="hljs-literal">NULL</span>);

    <span class="hljs-keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="hljs-number">0</span>) &#123;

        <span class="hljs-keyword">if</span> (reply) &#123;
          <span class="hljs-comment">//等待响应</span>
            err = waitForResponse(reply);
        &#125; <span class="hljs-keyword">else</span> &#123;
          <span class="hljs-comment">//直接返回null</span>
            Parcel fakeReply;
            err = waitForResponse(&amp;fakeReply);
        &#125;
      
        IF_LOG_TRANSACTIONS() &#123;
            TextOutput::Bundle _b(alog);
            alog &lt;&lt; <span class="hljs-string">"BR_REPLY thr "</span> &lt;&lt; (<span class="hljs-keyword">void</span>*)pthread_self() &lt;&lt; <span class="hljs-string">" / hand "</span>
                &lt;&lt; handle &lt;&lt; <span class="hljs-string">": "</span>;
            <span class="hljs-keyword">if</span> (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; <span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">else</span> alog &lt;&lt; <span class="hljs-string">"(none requested)"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">//直接返回null</span>
        err = waitForResponse(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
    &#125;

    <span class="hljs-keyword">return</span> err;
&#125;</code></pre>
<p><code>transact()</code>主要过程：</p>
<ol>
<li><p>执行<code>writeTransactionData()</code>向<code>Parcel</code>中的<code>mOut</code>写入数据</p>
<p>写入的数据主要是<code>BC_TRANSACTION</code>协议以及<code>binder_transaction_data</code>数据。</p>
</li>
<li><p>执行<code>waitForResponse()</code>循环执行，等待应答消息。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">IPCThreadState::waitForResponse</span><span class="hljs-params">(Parcel *reply, <span class="hljs-keyword">status_t</span> *acquireResult)</span>
</span>&#123;
    <span class="hljs-keyword">int32_t</span> cmd;
    <span class="hljs-keyword">int32_t</span> err;
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;
        <span class="hljs-keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="hljs-keyword">break</span>;
        ...
        <span class="hljs-keyword">if</span> (mIn.dataAvail() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;

        cmd = mIn.readInt32();
        <span class="hljs-keyword">switch</span> (cmd) &#123;
            <span class="hljs-keyword">case</span> BR_TRANSACTION_COMPLETE:
            <span class="hljs-comment">//如果是 oneway 的请求方式，直接结束即可</span>
                <span class="hljs-keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="hljs-keyword">goto</span> finish;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> BR_DEAD_REPLY: ...
            <span class="hljs-keyword">case</span> BR_FAILED_REPLY: ...
            <span class="hljs-keyword">case</span> BR_ACQUIRE_RESULT: ...
            <span class="hljs-keyword">case</span> BR_REPLY: ...
              <span class="hljs-comment">//完整的执行一次通信过程</span>
                <span class="hljs-keyword">goto</span> finish;

            <span class="hljs-keyword">default</span>:
                err = executeCommand(cmd);
                <span class="hljs-keyword">if</span> (err != NO_ERROR) <span class="hljs-keyword">goto</span> finish;
                <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
    ...
    <span class="hljs-keyword">return</span> err;
&#125;</code></pre>
</li>
</ol>
<h5 id="IPCThreadState-talkWithDrive"><a href="#IPCThreadState-talkWithDrive" class="headerlink" title="IPCThreadState.talkWithDrive()"></a>IPCThreadState.talkWithDrive()</h5><blockquote>
<p>负责与 <code>Binder驱动</code>进行通信</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">IPCThreadState::talkWithDriver</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> doReceive)</span>
</span>&#123;
    ...
    binder_write_read bwr;
    <span class="hljs-comment">//当mDataSize &lt;= mDataPos，则有数据可读</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="hljs-number">0</span>;

    bwr.write_size = outAvail;
    bwr.write_buffer = (<span class="hljs-keyword">uintptr_t</span>)mOut.data(); <span class="hljs-comment">// mData地址</span>

    <span class="hljs-keyword">if</span> (doReceive &amp;&amp; needRead) &#123;
        <span class="hljs-comment">//接收数据缓冲区信息的填充。如果以后收到数据，就直接填在mIn中。</span>
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (<span class="hljs-keyword">uintptr_t</span>)mIn.data();
    &#125; <span class="hljs-keyword">else</span> &#123;
        bwr.read_size = <span class="hljs-number">0</span>;
        bwr.read_buffer = <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-comment">//当读缓冲和写缓冲都为空，则直接返回</span>
    <span class="hljs-keyword">if</span> ((bwr.write_size == <span class="hljs-number">0</span>) &amp;&amp; (bwr.read_size == <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> NO_ERROR;

    bwr.write_consumed = <span class="hljs-number">0</span>;
    bwr.read_consumed = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">status_t</span> err;
    <span class="hljs-keyword">do</span> &#123;
        <span class="hljs-comment">//通过ioctl不停的读写操作，跟Binder Driver进行通信</span>
        <span class="hljs-keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="hljs-number">0</span>)
            err = NO_ERROR;
        ...
    &#125; <span class="hljs-keyword">while</span> (err == -EINTR);
    ...
    <span class="hljs-keyword">return</span> err;
&#125;</code></pre>
<h5 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl()"></a>binder_ioctl()</h5><blockquote>
<p>与<code>Binder驱动进行通信</code></p>
</blockquote>
<ul>
<li>binder_ioctl()过程解析ioctl参数BINDER_WRITE_READ，则调用binder_ioctl_write_read()方法；</li>
<li>binder_ioctl_write_read()过程将用户空间binder_write_read结构体拷贝到内核空间, 写缓存中存在数据，则调用binder_thread_write()方法；</li>
<li>binder_thread_write()过程解析到传输协议为BC_TRANSACTION，则调用binder_transaction()方法；</li>
<li>binder_transaction()过程将用户空间binder_transaction_data结构体拷贝到内核空间，内核创建一个binder_transaction结构体，</li>
</ul>
<p><img src="/images/5-3-5-add_service.jpg" srcset="/img/loading.gif" alt="服务注册过程"></p>
<h5 id="binder-parse"><a href="#binder-parse" class="headerlink" title="binder_parse()"></a>binder_parse()</h5><blockquote>
<p>解析<code>Binder驱动</code>返回的数据</p>
</blockquote>
<p>前面讲到<code>Service Manager</code>的启动时，就介绍到在<code>binder_loop()</code>中负责接收消息，收到消息后通过<code>binder_parse</code>进行解析。</p>
<p>收到的指令为<code></code></p>
<pre><code class="hljs cpp"><span class="hljs-keyword">case</span> BR_TRANSACTION: &#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_transaction_data</span> *<span class="hljs-title">txn</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">binder_transaction_data</span> *) <span class="hljs-title">ptr</span>;</span>
    <span class="hljs-keyword">if</span> ((end - ptr) &lt; <span class="hljs-keyword">sizeof</span>(*txn)) &#123;
        ALOGE(<span class="hljs-string">"parse: txn too small!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
    binder_dump_txn(txn);
    <span class="hljs-keyword">if</span> (func) &#123;
        <span class="hljs-keyword">unsigned</span> rdata[<span class="hljs-number">256</span>/<span class="hljs-number">4</span>];
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">msg</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_io</span> <span class="hljs-title">reply</span>;</span>
        <span class="hljs-keyword">int</span> res;

        bio_init(&amp;reply, rdata, <span class="hljs-keyword">sizeof</span>(rdata), <span class="hljs-number">4</span>);
        bio_init_from_txn(&amp;msg, txn);
        res = func(bs, txn, &amp;msg, &amp;reply);
        <span class="hljs-keyword">if</span> (txn-&gt;flags &amp; TF_ONE_WAY) &#123;
            binder_free_buffer(bs, txn-&gt;data.ptr.buffer);
        &#125; <span class="hljs-keyword">else</span> &#123;
            binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);
        &#125;
    &#125;
    ptr += <span class="hljs-keyword">sizeof</span>(*txn);
    <span class="hljs-keyword">break</span>;
&#125;</code></pre>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">svcmgr_handler</span><span class="hljs-params">(struct binder_state *bs,
                   struct binder_transaction_data *txn,
                   struct binder_io *msg,
                   struct binder_io *reply)</span>
</span>&#123;
  ...
        <span class="hljs-keyword">case</span> SVC_MGR_ADD_SERVICE:
        s = bio_get_string16(msg, &amp;len);
        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        handle = bio_get_ref(msg);
        allow_isolated = bio_get_uint32(msg) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        dumpsys_priority = bio_get_uint32(msg);
        <span class="hljs-keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority,
                           txn-&gt;sender_pid))
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">break</span>;

  
&#125;</code></pre>
<h5 id="do-add-service"><a href="#do-add-service" class="headerlink" title="do_add_service()"></a>do_add_service()</h5><blockquote>
<p>向Service Manager添加服务</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_add_service</span><span class="hljs-params">(struct binder_state *bs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *s, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">uint32_t</span> handle,
                   <span class="hljs-keyword">uid_t</span> uid, <span class="hljs-keyword">int</span> allow_isolated, <span class="hljs-keyword">uint32_t</span> dumpsys_priority, <span class="hljs-keyword">pid_t</span> spid)</span> </span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">svcinfo</span> *<span class="hljs-title">si</span>;</span>

    <span class="hljs-comment">//ALOGI("add_service('%s',%x,%s) uid=%d\n", str8(s, len), handle,</span>
    <span class="hljs-comment">//        allow_isolated ? "allow_isolated" : "!allow_isolated", uid);</span>

    <span class="hljs-keyword">if</span> (!handle || (len == <span class="hljs-number">0</span>) || (len &gt; <span class="hljs-number">127</span>))
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">if</span> (!svc_can_register(s, len, spid, uid)) &#123;
        ALOGE(<span class="hljs-string">"add_service('%s',%x) uid=%d - PERMISSION DENIED\n"</span>,
             str8(s, len), handle, uid);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;

    si = find_svc(s, len);
    <span class="hljs-keyword">if</span> (si) &#123;
        <span class="hljs-keyword">if</span> (si-&gt;handle) &#123;
            ALOGE(<span class="hljs-string">"add_service('%s',%x) uid=%d - ALREADY REGISTERED, OVERRIDE\n"</span>,
                 str8(s, len), handle, uid);
            svcinfo_death(bs, si);
        &#125;
        si-&gt;handle = handle;
    &#125; <span class="hljs-keyword">else</span> &#123;
        si = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*si) + (len + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));
        <span class="hljs-keyword">if</span> (!si) &#123;
            ALOGE(<span class="hljs-string">"add_service('%s',%x) uid=%d - OUT OF MEMORY\n"</span>,
                 str8(s, len), handle, uid);
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        si-&gt;handle = handle;
        si-&gt;len = len;
        <span class="hljs-built_in">memcpy</span>(si-&gt;name, s, (len + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));
        si-&gt;name[len] = <span class="hljs-string">'\0'</span>;
        si-&gt;death.func = (<span class="hljs-keyword">void</span>*) svcinfo_death;
        si-&gt;death.ptr = si;
        si-&gt;allow_isolated = allow_isolated;
        si-&gt;dumpsys_priority = dumpsys_priority;
        si-&gt;next = svclist;<span class="hljs-comment">//svcList保存服务</span>
        svclist = si;
    &#125;

    binder_acquire(bs, handle);
    binder_link_to_death(bs, handle, &amp;si-&gt;death);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<h4 id="Java-注册服务"><a href="#Java-注册服务" class="headerlink" title="Java 注册服务"></a>Java 注册服务</h4><p>上面讲的都是Native层的相关过程，接下来简单分析下<code>Java层 如何注册服务</code></p>
<p>一般都是通过<code>ServiceManager.addService()</code>去在<code>Service Manager</code>注册服务，这一类方式主要面向的是<code>系统服务</code>。</p>
<p><code>系统服务</code>相关的分析完毕后，会简单介绍开发者自定义Service的注册过程。</p>
<p>注册服务的操作都是由<code>Server</code>执行的，所以下面的流程基本都是在<code>Server端操作的</code>。</p>
<h5 id="系统服务-SystemServer-注册服务"><a href="#系统服务-SystemServer-注册服务" class="headerlink" title="系统服务(SystemServer) 注册服务"></a>系统服务(SystemServer) 注册服务</h5><blockquote>
<p>系统服务：一般指的是由<code>SystemServer</code>进程启动的服务，例如<code>InputManagerService</code>、<code>WindowManagerService</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//SystemServer.java</span>
            inputManager = <span class="hljs-keyword">new</span> InputManagerService(context);
            ServiceManager.addService(Context.INPUT_SERVICE, inputManager,
                    <span class="hljs-comment">/* allowIsolated= */</span> <span class="hljs-keyword">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</code></pre>
<p>都是通过<code>ServiceManager.addService()</code>进行注册</p>
<pre><code class="hljs java"><span class="hljs-comment">//core/java/android/os/ServiceManager.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addService</span><span class="hljs-params">(String name, IBinder service, <span class="hljs-keyword">boolean</span> allowIsolated,
            <span class="hljs-keyword">int</span> dumpPriority)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            getIServiceManager().addService(name, service, allowIsolated, dumpPriority);
        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
            Log.e(TAG, <span class="hljs-string">"error in addService"</span>, e);
        &#125;
    &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IServiceManager <span class="hljs-title">getIServiceManager</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (sServiceManager != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> sServiceManager;
        &#125;

        <span class="hljs-comment">// Find the service manager</span>
        sServiceManager = ServiceManagerNative
                .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));
        <span class="hljs-keyword">return</span> sServiceManager;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IServiceManager <span class="hljs-title">asInterface</span><span class="hljs-params">(IBinder obj)</span>
    </span>&#123;
      <span class="hljs-comment">//obj 为 BinderProxy对象</span>
        <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        IServiceManager in =
            (IServiceManager)obj.queryLocalInterface(descriptor);
        <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> in;
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceManagerProxy(obj);
    &#125;</code></pre>
<p>前面有讲到具体的处理过程，这边直接贴一个结论：</p>
<p><code>sServiceManager</code>最后得到的是<code>ServiceManagerProxy</code>对象，且<code>IBinder</code>对象为<code>BinderProxy</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//core/java/android/os/ServiceManagerNative.java</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceManagerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IServiceManager</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceManagerProxy</span><span class="hljs-params">(IBinder remote)</span> </span>&#123;
        mRemote = remote;
    &#125;    

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addService</span><span class="hljs-params">(String name, IBinder service, <span class="hljs-keyword">boolean</span> allowIsolated, <span class="hljs-keyword">int</span> dumpPriority)</span>
            <span class="hljs-keyword">throws</span> RemoteException </span>&#123;
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IServiceManager.descriptor);
        data.writeString(name);
        data.writeStrongBinder(service);
        data.writeInt(allowIsolated ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
        data.writeInt(dumpPriority);
  <span class="hljs-comment">//mRemote为 BinderProxy对象</span>
        mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, <span class="hljs-number">0</span>);
        reply.recycle();
        data.recycle();
    &#125;</code></pre>
<h6 id="writeStrongBinder"><a href="#writeStrongBinder" class="headerlink" title="writeStrongBinder()"></a><code>writeStrongBinder()</code></h6><blockquote>
<p>将<code>Binder实体</code>写入<code>Parcel</code>中，就可以传递到对端。</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeStrongBinder</span><span class="hljs-params">(IBinder val)</span> </span>&#123;
    nativeWriteStrongBinder(mNativePtr, val);
&#125;</code></pre>
<pre><code class="hljs c"><span class="hljs-comment">//core/jni/android_os_Parcel.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">android_os_Parcel_writeStrongBinder</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</span>
</span>&#123;
    Parcel* parcel = <span class="hljs-keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);
    <span class="hljs-keyword">if</span> (parcel != <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">status_t</span> err = parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object));
        <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;
            signalExceptionForError(env, clazz, err);
        &#125;
    &#125;
&#125;</code></pre>
<p><code>ibinderForJavaObject()</code></p>
<blockquote>
<p>将<code>Binder(Java)</code>转化成<code>Binder(c++)</code>对象</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-comment">//core/jni/android_util_Binder.cpp</span>
<span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">ibinderForJavaObject</span><span class="hljs-params">(JNIEnv* env, jobject obj)</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;

    <span class="hljs-comment">// Java层的Binder对象</span>
    <span class="hljs-keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123;
        JavaBBinderHolder* jbh = (JavaBBinderHolder*)
            env-&gt;GetLongField(obj, gBinderOffsets.mObject);
        <span class="hljs-keyword">return</span> jbh-&gt;get(env, obj);
    &#125;

    <span class="hljs-comment">// Java层的BinderProxy对象</span>
    <span class="hljs-keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123;
        <span class="hljs-keyword">return</span> getBPNativeData(env, obj)-&gt;mObject;
    &#125;

    ALOGW(<span class="hljs-string">"ibinderForJavaObject: %p is not a Binder object"</span>, obj);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
&#125;</code></pre>
<pre><code class="hljs cpp"><span class="hljs-function">sp&lt;JavaBBinder&gt; <span class="hljs-title">get</span><span class="hljs-params">(JNIEnv* env, jobject obj)</span>
</span>&#123;
    AutoMutex _l(mLock);
    sp&lt;JavaBBinder&gt; b = mBinder.promote();
    <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">NULL</span>) &#123;
        b = <span class="hljs-keyword">new</span> JavaBBinder(env, obj);
        mBinder = b;
        ALOGV(<span class="hljs-string">"Creating JavaBinder %p (refs %p) for Object %p, weakCount=%"</span> PRId32 <span class="hljs-string">"\n"</span>,
             b.get(), b-&gt;getWeakRefs(), obj, b-&gt;getWeakRefs()-&gt;getWeakCount());
    &#125;

    <span class="hljs-keyword">return</span> b;
&#125;</code></pre>
<p><code>iBinderForJavaObject()</code>最后转换出一个<code>JavaBBinder</code>对象</p>
<p><img src="/images/Java-Binder与Native-Binder" srcset="/img/loading.gif" alt="Java-Binder与Native-Binder"></p>
<p><code>parcel-&gt;writeStrongBinder()</code></p>
<pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/binder/Parcel.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Parcel::writeStrongBinder</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span>
</span>&#123;
    <span class="hljs-keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="hljs-keyword">this</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">flatten_binder</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;ProcessState&gt;&amp; <span class="hljs-comment">/*proc*/</span>,
    <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span>
</span>&#123;
    flat_binder_object obj;

    <span class="hljs-keyword">if</span> (IPCThreadState::self()-&gt;backgroundSchedulingDisabled()) &#123;
        <span class="hljs-comment">/* minimum priority for all nodes is nice 0 */</span>
        obj.flags = FLAT_BINDER_FLAG_ACCEPTS_FDS;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">/* minimum priority for all nodes is MAX_NICE(19) */</span>
        obj.flags = <span class="hljs-number">0x13</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;
    &#125;

    <span class="hljs-keyword">if</span> (binder != <span class="hljs-literal">NULL</span>) &#123;
        IBinder *local = binder-&gt;localBinder();<span class="hljs-comment">//本地bidner对象</span>
        <span class="hljs-keyword">if</span> (!local) &#123;
            BpBinder *proxy = binder-&gt;remoteBinder();<span class="hljs-comment">//远程Binder对象</span>
            <span class="hljs-keyword">if</span> (proxy == <span class="hljs-literal">NULL</span>) &#123;
                ALOGE(<span class="hljs-string">"null proxy"</span>);
            &#125;
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> handle = proxy ? proxy-&gt;handle() : <span class="hljs-number">0</span>;
            obj.hdr.type = BINDER_TYPE_HANDLE;
            obj.binder = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Don't pass uninitialized stack data to a remote process */</span>
            obj.handle = handle;
            obj.cookie = <span class="hljs-number">0</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            obj.hdr.type = BINDER_TYPE_BINDER;
            obj.binder = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span>&gt;(local-&gt;getWeakRefs());
            obj.cookie = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span>&gt;(local);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        obj.hdr.type = BINDER_TYPE_BINDER;
        obj.binder = <span class="hljs-number">0</span>;
        obj.cookie = <span class="hljs-number">0</span>;
    &#125;

  <span class="hljs-comment">//写入 flat_binder_object到 out</span>
    <span class="hljs-keyword">return</span> finish_flatten_binder(binder, obj, out);
&#125;</code></pre>
<p><code>writeStrongBinder()</code>负责转换<code>IBinder</code>对象到<code>flat_bidner_object</code></p>
<h6 id="mRemote-transact-ADD-SERVICE-TRANSACTION"><a href="#mRemote-transact-ADD-SERVICE-TRANSACTION" class="headerlink" title="mRemote.transact(ADD_SERVICE_TRANSACTION)"></a><code>mRemote.transact(ADD_SERVICE_TRANSACTION)</code></h6><blockquote>
<p>通过<code>BinderProxy</code>传输<code>Binder对象</code>到<code>Binder驱动</code></p>
</blockquote>
<pre><code class="hljs java">mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, <span class="hljs-number">0</span>);</code></pre>
<pre><code class="hljs java"><span class="hljs-comment">//core/java/android/os/Binder.java</span>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinderProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBinder</span> </span>&#123;
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, Parcel data, Parcel reply, <span class="hljs-keyword">int</span> flags)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;
        <span class="hljs-comment">//检测 data 的数据是否大于 800k</span>
        Binder.checkParcel(<span class="hljs-keyword">this</span>, code, data, <span class="hljs-string">"Unreasonably large binder buffer"</span>);


        <span class="hljs-keyword">try</span> &#123;
          <span class="hljs-comment">//通过Native层 向 Binder驱动传递消息</span>
            <span class="hljs-keyword">return</span> transactNative(code, data, reply, flags);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-keyword">if</span> (tracingEnabled) &#123;
                Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);
            &#125;
        &#125;
    &#125;
  
&#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transactNative</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, Parcel data, Parcel reply,
            <span class="hljs-keyword">int</span> flags)</span> <span class="hljs-keyword">throws</span> RemoteException</span>;</code></pre>
<pre><code class="hljs cpp"><span class="hljs-comment">//core/jni/android_util_Binder.cpp</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> jboolean <span class="hljs-title">android_os_BinderProxy_transact</span><span class="hljs-params">(JNIEnv* env, jobject obj,
        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="hljs-comment">// throws RemoteException</span>
</span>&#123;

  <span class="hljs-comment">//解析传递数据</span>
    Parcel* data = parcelForJavaObject(env, dataObj);
  <span class="hljs-comment">//解析返回数据</span>
    Parcel* reply = parcelForJavaObject(env, replyObj);

  <span class="hljs-comment">//target 为 BpBinder</span>
    IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get();

    <span class="hljs-comment">//printf("Transact from Java code to %p sending: ", target); data-&gt;print();</span>
  <span class="hljs-comment">//向 Binder驱动发送数据</span>
    <span class="hljs-keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);
    <span class="hljs-comment">//if (reply) printf("Transact from Java code to %p received: ", target); reply-&gt;print();</span>

    signalExceptionForError(env, obj, err, <span class="hljs-literal">true</span> <span class="hljs-comment">/*canThrowRemoteException*/</span>, data-&gt;dataSize());
    <span class="hljs-keyword">return</span> JNI_FALSE;
&#125;


<span class="hljs-function">BinderProxyNativeData* <span class="hljs-title">getBPNativeData</span><span class="hljs-params">(JNIEnv* env, jobject obj)</span> </span>&#123;
    <span class="hljs-keyword">return</span> (BinderProxyNativeData *) env-&gt;GetLongField(obj, gBinderProxyOffsets.mNativeData);
&#125;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinderProxyNativeData</span> &#123;</span>
    <span class="hljs-comment">// Both fields are constant and not null once javaObjectForIBinder returns this as</span>
    <span class="hljs-comment">// part of a BinderProxy.</span>

    <span class="hljs-comment">// The native IBinder proxied by this BinderProxy.</span>
    sp&lt;IBinder&gt; mObject;

    <span class="hljs-comment">// Death recipients for mObject. Reference counted only because DeathRecipients</span>
    <span class="hljs-comment">// hold a weak reference that can be temporarily promoted.</span>
    sp&lt;DeathRecipientList&gt; mOrgue;  <span class="hljs-comment">// Death recipients for mObject.</span>
&#125;;</code></pre>
<p>继续执行的就是<a href="#IPCThreadState-&gt;transact">IPCThreadState-&gt;transact</a></p>
<h6 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h6><p><code>ServiceManager.addService()</code>主要执行了以下几步：</p>
<ol>
<li><code>Parcel.obtain()</code>：构建Native层的<code>Parcel</code>对象</li>
<li><code>parcel.writeStrongBinder()</code>：构造<code>JavaBBinder</code>对象写入到<code>falt_binder_object</code>，准备传到<code>Binder驱动</code></li>
<li><code>BpBinder.transact(ADD_SERVICE_TRANSACTION)</code>：通过<code>IPCThreadState.talkWithDriver()</code>发送数据到<code>Binder驱动</code></li>
</ol>
<h5 id="自定义服务-CustomServer-注册服务"><a href="#自定义服务-CustomServer-注册服务" class="headerlink" title="自定义服务(CustomServer) 注册服务"></a>自定义服务(CustomServer) 注册服务</h5><h4 id="Service-Manager-获取服务"><a href="#Service-Manager-获取服务" class="headerlink" title="Service Manager 获取服务"></a>Service Manager 获取服务</h4><blockquote>
<p>Client 向 Service Manager 获取服务</p>
</blockquote>
<p><code>获取服务</code>流程大致与<code>注册服务</code>流程一致</p>
<p>只是最后执行的<code>do_find_service()</code>方法，从<code>Service Manager</code>获取注册的服务。</p>
<p><img src="/images/5-4-2-get_service.jpg" srcset="/img/loading.gif" alt="查询服务"></p>
<h4 id="Java-获取服务"><a href="#Java-获取服务" class="headerlink" title="Java 获取服务"></a>Java 获取服务</h4><blockquote>
<p>一般通过<code>ServiceManager.getService()</code>获取服务</p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//core/java/android/os/ServiceManager.java</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IBinder <span class="hljs-title">getService</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
          <span class="hljs-comment">//缓存直接获取</span>
            IBinder service = sCache.get(name);
            <span class="hljs-keyword">if</span> (service != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-keyword">return</span> service;
            &#125; <span class="hljs-keyword">else</span> &#123;
              
                <span class="hljs-keyword">return</span> Binder.allowBlocking(rawGetService(name));
            &#125;
        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;
            Log.e(TAG, <span class="hljs-string">"error in getService"</span>, e);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IBinder <span class="hljs-title">rawGetService</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start = sStatLogger.getTime();

        <span class="hljs-keyword">final</span> IBinder binder = getIServiceManager().getService(name);
      ...
         &#125;</code></pre>
<p><code>getIServiceManager()</code>最后指向的就是<code>ServiceManagerProxy</code></p>
<pre><code class="hljs java"><span class="hljs-comment">//core/java/android/os/ServiceManagerNative.java</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> IBinder <span class="hljs-title">getService</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IServiceManager.descriptor);
        data.writeString(name);
        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, <span class="hljs-number">0</span>);
      <span class="hljs-comment">//读取Binder对象</span>
        IBinder binder = reply.readStrongBinder();
        reply.recycle();
        data.recycle();
        <span class="hljs-keyword">return</span> binder;
    &#125;</code></pre>
<h5 id="mRemote-transact-GET-SERVICE-TRANSACTION"><a href="#mRemote-transact-GET-SERVICE-TRANSACTION" class="headerlink" title="mRemote.transact(GET_SERVICE_TRANSACTION)"></a><code>mRemote.transact(GET_SERVICE_TRANSACTION)</code></h5><p>通过<code>IPCThreadState.talkWithDriver()</code>发送数据<code>GET_SERVICE_TRANSACTION</code>到<code>Binder驱动</code></p>
<h5 id="readStrongBinder"><a href="#readStrongBinder" class="headerlink" title="readStrongBinder()"></a><code>readStrongBinder()</code></h5><p>基本就是<code>writeStrongBinder()</code>的逆向过程</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> jobject <span class="hljs-title">android_os_Parcel_readStrongBinder</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jlong nativePtr)</span>
</span>&#123;
    Parcel* parcel = <span class="hljs-keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);
    <span class="hljs-keyword">if</span> (parcel != <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-keyword">return</span> javaObjectForIBinder(env, parcel-&gt;readStrongBinder());
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
&#125;</code></pre>
<pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/native/libs/binder/Parcel.cpp</span>
<span class="hljs-function">sp&lt;IBinder&gt; <span class="hljs-title">Parcel::readStrongBinder</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>&#123;
    sp&lt;IBinder&gt; val;
    <span class="hljs-comment">// Note that a lot of code in Android reads binders by hand with this</span>
    <span class="hljs-comment">// method, and that code has historically been ok with getting nullptr</span>
    <span class="hljs-comment">// back (while ignoring error codes).</span>
    readNullableStrongBinder(&amp;val);
    <span class="hljs-keyword">return</span> val;
&#125;

<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Parcel::readNullableStrongBinder</span><span class="hljs-params">(sp&lt;IBinder&gt;* val)</span> <span class="hljs-keyword">const</span>
</span>&#123;
    <span class="hljs-keyword">return</span> unflattenBinder(val);
&#125;

<span class="hljs-function"><span class="hljs-keyword">status_t</span> <span class="hljs-title">Parcel::unflattenBinder</span><span class="hljs-params">(sp&lt;IBinder&gt;* out)</span> <span class="hljs-keyword">const</span>
</span>&#123;
    <span class="hljs-keyword">const</span> flat_binder_object* flat = readObject(<span class="hljs-literal">false</span>);

    <span class="hljs-keyword">if</span> (flat) &#123;
        <span class="hljs-keyword">switch</span> (flat-&gt;hdr.type) &#123;
            <span class="hljs-keyword">case</span> BINDER_TYPE_BINDER: &#123;
                sp&lt;IBinder&gt; binder = <span class="hljs-keyword">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);
                <span class="hljs-keyword">return</span> finishUnflattenBinder(binder, out);
            &#125;
            <span class="hljs-keyword">case</span> BINDER_TYPE_HANDLE: &#123;
                sp&lt;IBinder&gt; binder =
                    ProcessState::self()-&gt;getStrongProxyForHandle(flat-&gt;handle);
                <span class="hljs-keyword">return</span> finishUnflattenBinder(binder, out);
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> BAD_TYPE;
&#125;</code></pre>
<p>从<code>flat_binder_obj</code>读取得到<code>IBinder</code>对象，实质就是<code>BpBinder</code>对象</p>
<pre><code class="hljs cpp"><span class="hljs-comment">//core/jni/android_util_Binder.cpp</span>
<span class="hljs-function">jobject <span class="hljs-title">javaObjectForIBinder</span><span class="hljs-params">(JNIEnv* env, <span class="hljs-keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (val == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;

    <span class="hljs-keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;
        <span class="hljs-comment">// It's a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span>
        jobject object = <span class="hljs-keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();
        LOGDEATH(<span class="hljs-string">"objectForBinder %p: it's our own %p!\n"</span>, val.get(), object);
        <span class="hljs-keyword">return</span> object;
    &#125;

    <span class="hljs-comment">// For the rest of the function we will hold this lock, to serialize</span>
    <span class="hljs-comment">// looking/creation/destruction of Java proxies for native Binder proxies.</span>
    AutoMutex _l(gProxyLock);

    BinderProxyNativeData* nativeData = gNativeDataCache;
    <span class="hljs-keyword">if</span> (nativeData == <span class="hljs-literal">nullptr</span>) &#123;
        nativeData = <span class="hljs-keyword">new</span> BinderProxyNativeData();
    &#125;
    <span class="hljs-comment">// gNativeDataCache is now logically empty.</span>
    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,
            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());
    <span class="hljs-keyword">if</span> (env-&gt;ExceptionCheck()) &#123;
        <span class="hljs-comment">// In the exception case, getInstance still took ownership of nativeData.</span>
        gNativeDataCache = <span class="hljs-literal">nullptr</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    &#125;
    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);
    <span class="hljs-keyword">if</span> (actualNativeData == nativeData) &#123;
        <span class="hljs-comment">// New BinderProxy; we still have exclusive access.</span>
        nativeData-&gt;mOrgue = <span class="hljs-keyword">new</span> DeathRecipientList;
        nativeData-&gt;mObject = val;
        gNativeDataCache = <span class="hljs-literal">nullptr</span>;
        ++gNumProxies;
        <span class="hljs-keyword">if</span> (gNumProxies &gt;= gProxiesWarned + PROXY_WARN_INTERVAL) &#123;
            ALOGW(<span class="hljs-string">"Unexpectedly many live BinderProxies: %d\n"</span>, gNumProxies);
            gProxiesWarned = gNumProxies;
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// nativeData wasn't used. Reuse it the next time.</span>
        gNativeDataCache = nativeData;
    &#125;

    <span class="hljs-keyword">return</span> object;
&#125;</code></pre>
<p>经过<code>javaObjectForIBinder()</code>之后转换<code>BpBinder</code>对象到<code>BinderProxy</code>对象.</p>
<p>通过<code>ServiceManager.getService()</code>最后<code>Client</code>持有的就是<code>BinderProxy</code>对象。</p>
<h3 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h3><p><em>下面源码分析基于<code>android-goldfish-4.4-dev</code>内核版本</em></p>
<blockquote>
<p>Android专用，主要以<code>misc</code>设备进行注册，节点是<code>/dev/binder</code>，直接操作设备内存。</p>
</blockquote>
<p><code>Binder驱动</code>源码位于<code>内核</code>，具体代码路径位于<code>/drivers/android/binder.c</code></p>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><h5 id="Binder初始化-binder-init"><a href="#Binder初始化-binder-init" class="headerlink" title="Binder初始化-binder_init()"></a>Binder初始化-binder_init()</h5><blockquote>
<p>注册misc设备</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-comment">//drivers/android/binder.c</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">binder_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>&#123;
	<span class="hljs-keyword">int</span> ret;
	<span class="hljs-keyword">char</span> *device_name, *device_names;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_device</span> *<span class="hljs-title">device</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> *<span class="hljs-title">tmp</span>;</span>

	binder_alloc_shrinker_init();

	atomic_set(&amp;binder_transaction_log.cur, ~<span class="hljs-number">0U</span>);
	atomic_set(&amp;binder_transaction_log_failed.cur, ~<span class="hljs-number">0U</span>);
  <span class="hljs-comment">//构建工作队列</span>
	binder_deferred_workqueue = create_singlethread_workqueue(<span class="hljs-string">"binder"</span>);
	<span class="hljs-keyword">if</span> (!binder_deferred_workqueue)
		<span class="hljs-keyword">return</span> -ENOMEM;

	<span class="hljs-keyword">while</span> ((device_name = strsep(&amp;device_names, <span class="hljs-string">","</span>))) &#123;
    <span class="hljs-comment">//注册bidner设备</span>
		ret = init_binder_device(device_name);
		<span class="hljs-keyword">if</span> (ret)
			<span class="hljs-keyword">goto</span> err_init_binder_device_failed;
	&#125;

	<span class="hljs-keyword">return</span> ret;
  
  <span class="hljs-comment">//执行过程异常处理</span></code></pre>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">init_binder_device</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span>
</span>&#123;
	<span class="hljs-keyword">int</span> ret;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_device</span> *<span class="hljs-title">binder_device</span>;</span>

	binder_device-&gt;miscdev.fops = &amp;binder_fops;
	binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;
	binder_device-&gt;miscdev.name = name;

	binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;
	binder_device-&gt;context.name = name;
	mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock);

  <span class="hljs-comment">//注册misc设备</span>
	ret = misc_register(&amp;binder_device-&gt;miscdev);

	hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);

	<span class="hljs-keyword">return</span> ret;
&#125;</code></pre>
<p>通过<code>misc_register</code>注册Binder设备，具体配置如下：</p>
<pre><code class="hljs cpp">miscdev.fops = &amp;binder_fops;
miscdev.minor = MISC_DYNAMIC_MINOR;
miscdev.name = name <span class="hljs-comment">//name为以下三个 binder hwbinder cdvbinder</span>
  
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> struct file_operations binder_fops = &#123;
	.owner = THIS_MODULE,
	.poll = binder_poll,
	.unlocked_ioctl = binder_ioctl,
	.compat_ioctl = binder_ioctl,
	.mmap = binder_mmap,
	.open = binder_open,
	.flush = binder_flush,
	.release = binder_release,
&#125;;</code></pre>
<h5 id="打开Binder设备-binder-open"><a href="#打开Binder设备-binder-open" class="headerlink" title="打开Binder设备-binder_open()"></a>打开Binder设备-binder_open()</h5><blockquote>
<p>打开binder驱动设备</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binder_open</span><span class="hljs-params">(struct inode *nodp, struct file *filp)</span>
</span>&#123;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_proc</span> *<span class="hljs-title">proc</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_device</span> *<span class="hljs-title">binder_dev</span>;</span>

	binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="hljs-string">"binder_open: %d:%d\n"</span>,
		     current-&gt;group_leader-&gt;pid, current-&gt;pid);

	proc = kzalloc(<span class="hljs-keyword">sizeof</span>(*proc), GFP_KERNEL);
	<span class="hljs-keyword">if</span> (proc == <span class="hljs-literal">NULL</span>)
		<span class="hljs-keyword">return</span> -ENOMEM;
	spin_lock_init(&amp;proc-&gt;inner_lock);
	spin_lock_init(&amp;proc-&gt;outer_lock);
	get_task_struct(current-&gt;group_leader);
	proc-&gt;tsk = current-&gt;group_leader;
	INIT_LIST_HEAD(&amp;proc-&gt;todo);
  <span class="hljs-comment">//记录进程优先级</span>
	<span class="hljs-keyword">if</span> (binder_supported_policy(current-&gt;policy)) &#123;
		proc-&gt;default_priority.sched_policy = current-&gt;policy;
		proc-&gt;default_priority.prio = current-&gt;normal_prio;
	&#125; <span class="hljs-keyword">else</span> &#123;
		proc-&gt;default_priority.sched_policy = SCHED_NORMAL;
		proc-&gt;default_priority.prio = NICE_TO_PRIO(<span class="hljs-number">0</span>);
	&#125;

	binder_dev = container_of(filp-&gt;private_data, struct binder_device,
				  miscdev);
	proc-&gt;context = &amp;binder_dev-&gt;context;
	binder_alloc_init(&amp;proc-&gt;alloc);

	binder_stats_created(BINDER_STAT_PROC);
	proc-&gt;pid = current-&gt;group_leader-&gt;pid;
	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);
	INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads);
	filp-&gt;private_data = proc;

	mutex_lock(&amp;binder_procs_lock);
	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);<span class="hljs-comment">//创建好的binder_proc对象插入到 binder_procs中</span>
	mutex_unlock(&amp;binder_procs_lock);


	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>创建<code>binder_proc</code>对象，并保存当前进程信息，内部结构如下：</p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_proc</span> &#123;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">proc_node</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">threads</span>;</span> <span class="hljs-comment">//对应的binder线程</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">nodes</span>;</span> <span class="hljs-comment">//binder节点</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">refs_by_desc</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">refs_by_node</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">waiting_threads</span>;</span>
	<span class="hljs-keyword">int</span> pid;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tsk</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">deferred_work_node</span>;</span>
	<span class="hljs-keyword">int</span> deferred_work;
	<span class="hljs-keyword">bool</span> is_dead;

	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">todo</span>;</span><span class="hljs-comment">//当前进程的任务</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_stats</span> <span class="hljs-title">stats</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">delivered_death</span>;</span>
	<span class="hljs-keyword">int</span> max_threads; <span class="hljs-comment">//最大并发线程数</span>
	<span class="hljs-keyword">int</span> requested_threads;
	<span class="hljs-keyword">int</span> requested_threads_started;
	<span class="hljs-keyword">int</span> tmp_ref;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_priority</span> <span class="hljs-title">default_priority</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">debugfs_entry</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_alloc</span> <span class="hljs-title">alloc</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_context</span> *<span class="hljs-title">context</span>;</span>
	<span class="hljs-keyword">spinlock_t</span> inner_lock;
	<span class="hljs-keyword">spinlock_t</span> outer_lock;
&#125;;</code></pre>
<p><img src="/images/binder_procs.png" srcset="/img/loading.gif" alt="binder_procs"></p>
<h5 id="Binder内存映射-binder-mmap"><a href="#Binder内存映射-binder-mmap" class="headerlink" title="Binder内存映射-binder_mmap()"></a>Binder内存映射-binder_mmap()</h5><blockquote>
<p>首先申内核申请虚拟地址空间，申请一块与用户虚拟内存(<code>*vma</code>)相同大小的内存；<br>再申请一个1个page大小的物理内存，再将同一块物理内存分别映射到<code>内核虚拟地址空间</code>和<code>用户虚拟内存空间</code>。</p>
<p>从而实现了用户空间和内核空间的<code>buffer</code>同步操作。</p>
</blockquote>
<pre><code class="hljs c"><span class="hljs-comment">//drivers/android/binder.c</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binder_mmap</span><span class="hljs-params">(struct file *filp<span class="hljs-comment">/*Bidner驱动的fd*/</span>, struct vm_area_struct *vma<span class="hljs-comment">/*用户虚拟内存*/</span>)</span>
</span>&#123;
	<span class="hljs-keyword">int</span> ret;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_proc</span> *<span class="hljs-title">proc</span> = <span class="hljs-title">filp</span>-&gt;<span class="hljs-title">private_data</span>;</span>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *failure_string;

  <span class="hljs-comment">//保证映射内存大小不会超过4M</span>
	<span class="hljs-keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)
		vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;

	vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;
	vma-&gt;vm_ops = &amp;binder_vm_ops;
	vma-&gt;vm_private_data = proc;

  
	ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma);

	<span class="hljs-keyword">return</span> ret;
&#125;</code></pre>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binder_alloc_mmap_handler</span><span class="hljs-params">(struct binder_alloc *alloc,
			      struct vm_area_struct *vma)</span>
</span>&#123;
	mutex_lock(&amp;binder_alloc_mmap_lock);
	<span class="hljs-keyword">if</span> (alloc-&gt;<span class="hljs-built_in">buffer</span>) &#123;
		ret = -EBUSY;
		failure_string = <span class="hljs-string">"already mapped"</span>;
		<span class="hljs-keyword">goto</span> err_already_mapped;
	&#125;
<span class="hljs-comment">//分配一个连续的内核虚拟空间</span>
	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);
  ...
    <span class="hljs-comment">//分配物理页的指针数组</span>
	alloc-&gt;pages = kzalloc(<span class="hljs-keyword">sizeof</span>(alloc-&gt;pages[<span class="hljs-number">0</span>]) *
				   ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE),
			       GFP_KERNEL);
	<span class="hljs-keyword">if</span> (alloc-&gt;pages == <span class="hljs-literal">NULL</span>) &#123;
		ret = -ENOMEM;
		failure_string = <span class="hljs-string">"alloc page array"</span>;
		<span class="hljs-keyword">goto</span> err_alloc_pages_failed;
	&#125;
	alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;

	<span class="hljs-built_in">buffer</span> = kzalloc(<span class="hljs-keyword">sizeof</span>(*<span class="hljs-built_in">buffer</span>), GFP_KERNEL);
	<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">buffer</span>) &#123;
		ret = -ENOMEM;
		failure_string = <span class="hljs-string">"alloc buffer struct"</span>;
		<span class="hljs-keyword">goto</span> err_alloc_buf_struct_failed;
	&#125;

	<span class="hljs-built_in">buffer</span>-&gt;data = alloc-&gt;<span class="hljs-built_in">buffer</span>;
	list_add(&amp;<span class="hljs-built_in">buffer</span>-&gt;entry, &amp;alloc-&gt;buffers);
	<span class="hljs-built_in">buffer</span>-&gt;<span class="hljs-built_in">free</span> = <span class="hljs-number">1</span>;
  <span class="hljs-comment">//</span>
	binder_insert_free_buffer(alloc, <span class="hljs-built_in">buffer</span>);
  <span class="hljs-comment">//异步可用空间大小为 buffer总大小的一半</span>
	alloc-&gt;free_async_space = alloc-&gt;buffer_size / <span class="hljs-number">2</span>;
	barrier();
	alloc-&gt;vma = vma;
	alloc-&gt;vma_vm_mm = vma-&gt;vm_mm;
	<span class="hljs-comment">/* Same as mmgrab() in later kernel versions */</span>
	atomic_inc(&amp;alloc-&gt;vma_vm_mm-&gt;mm_count);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    
  
&#125;</code></pre>
<p>当把同一块物理页面同时映射到进程空间和内核空间时，当需要在两者之间传递数据时，只需要其中任意一方把数据拷贝到物理页面，另一方直接读取即可，也就是说，数据的跨进程传递，只需要一次拷贝就可以完成。</p>
<h5 id="Binder内存管理-binder-ioctl"><a href="#Binder内存管理-binder-ioctl" class="headerlink" title="Binder内存管理-binder_ioctl()"></a>Binder内存管理-binder_ioctl()</h5><blockquote>
<p>负责在两个进程间收发<code>IPC 数据</code>和<code>IPC Reply</code>数据。</p>
</blockquote>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">binder_ioctl</span><span class="hljs-params">(struct file *filp<span class="hljs-comment">/*binder驱动的fd*/</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd<span class="hljs-comment">/*ioctl命令*/</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg<span class="hljs-comment">/*数据类型*/</span>)</span>
</span>&#123;
...
<span class="hljs-keyword">switch</span> (cmd) &#123;
	<span class="hljs-keyword">case</span> BINDER_WRITE_READ:
		ret = binder_ioctl_write_read(filp, cmd, arg, thread);
		<span class="hljs-keyword">if</span> (ret)
			<span class="hljs-keyword">goto</span> err;
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> BINDER_SET_MAX_THREADS: &#123;
		<span class="hljs-keyword">int</span> max_threads;

		<span class="hljs-keyword">if</span> (copy_from_user(&amp;max_threads, ubuf,
				   <span class="hljs-keyword">sizeof</span>(max_threads))) &#123;
			ret = -EINVAL;
			<span class="hljs-keyword">goto</span> err;
		&#125;
		binder_inner_proc_lock(proc);
		proc-&gt;max_threads = max_threads;
		binder_inner_proc_unlock(proc);
		<span class="hljs-keyword">break</span>;
	&#125;
	<span class="hljs-keyword">case</span> BINDER_SET_CONTEXT_MGR:
		ret = binder_ioctl_set_ctx_mgr(filp);
		<span class="hljs-keyword">if</span> (ret)
			<span class="hljs-keyword">goto</span> err;
		<span class="hljs-keyword">break</span>;
    
&#125;
  
&#125;</code></pre>
<p><code>binder驱动</code>将业务分为多种不同的命令，再根据具体的命令执行不同的业务。常用命令有以下几种：</p>
<ul>
<li><p><strong><code>BINDER_WRITE_READ</code></strong>：负责收发<code>Binder IPC</code>数据</p>
<p>使用场景：<code>Service Manager</code>通过发送<code>BINDER_WRITE_READ</code>命令向<code>Binder驱动</code>读写数据</p>
</li>
<li><p><code>BINDER_SET_MAX_THREADS</code>：设置进程最大binder线程个数</p>
<p>使用场景：在<code>ProcessState</code>初始化的时候，会设置当前进程支持的最大个数，默认为15，设置的命令为<code>BINDER_SET_MAX_THREADS</code></p>
</li>
<li><p><code>BINDER_SET_CONTEXT_MGR</code>：设置Service Manager为大管家。</p>
<p>使用场景：ServiceManager启动过程中调用<code>binder_become_context_manager()</code>命令为<code>BINDER_SET_CONTEXT_MGR</code></p>
</li>
</ul>
<p>使用最频繁的就是<code>BINDER_WRITE_READ</code>，下面简单的分析一下流程：</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">binder_ioctl</span><span class="hljs-params">(struct file *filp, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)</span>
</span>&#123;
  ...
	<span class="hljs-keyword">switch</span> (cmd) &#123;
	<span class="hljs-keyword">case</span> BINDER_WRITE_READ:
		ret = binder_ioctl_write_read(filp, cmd, arg, thread);
		<span class="hljs-keyword">if</span> (ret)
			<span class="hljs-keyword">goto</span> err;
		<span class="hljs-keyword">break</span>;
      ...
  
&#125;</code></pre>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binder_ioctl_write_read</span><span class="hljs-params">(struct file *filp,
				<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg,
				struct binder_thread *thread)</span>
</span>&#123;
	<span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_proc</span> *<span class="hljs-title">proc</span> = <span class="hljs-title">filp</span>-&gt;<span class="hljs-title">private_data</span>;</span>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size = _IOC_SIZE(cmd);
	<span class="hljs-keyword">void</span> __user *ubuf = (<span class="hljs-keyword">void</span> __user *)arg;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_write_read</span> <span class="hljs-title">bwr</span>;</span>

	<span class="hljs-keyword">if</span> (size != <span class="hljs-keyword">sizeof</span>(struct binder_write_read)) &#123;
		ret = -EINVAL;
		<span class="hljs-keyword">goto</span> out;
	&#125;
  <span class="hljs-comment">//从用户空间拷贝数据到 bwr(内核空间)</span>
	<span class="hljs-keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="hljs-keyword">sizeof</span>(bwr))) &#123;
		ret = -EFAULT;
		<span class="hljs-keyword">goto</span> out;
	&#125;
  
	<span class="hljs-keyword">if</span> (bwr.write_size &gt; <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">//存在写数据时，执行binder写操作</span>
		ret = binder_thread_write(proc, thread,
					  bwr.write_buffer,
					  bwr.write_size,
					  &amp;bwr.write_consumed);
		trace_binder_write_done(ret);
		<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;
			bwr.read_consumed = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr)))
				ret = -EFAULT;
			<span class="hljs-keyword">goto</span> out;
		&#125;
	&#125;
  
	<span class="hljs-keyword">if</span> (bwr.read_size &gt; <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">//存在读数据，执行binder读操作</span>
		ret = binder_thread_read(proc, thread, bwr.read_buffer,
					 bwr.read_size,
					 &amp;bwr.read_consumed,
					 filp-&gt;f_flags &amp; O_NONBLOCK);
		trace_binder_read_done(ret);
		binder_inner_proc_lock(proc);
		<span class="hljs-keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo))
			binder_wakeup_proc_ilocked(proc);
		binder_inner_proc_unlock(proc);
		<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;
			<span class="hljs-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr)))
				ret = -EFAULT;
			<span class="hljs-keyword">goto</span> out;
		&#125;
	&#125;

  <span class="hljs-comment">//将内核数据 bwr 拷贝回 用户空间</span>
	<span class="hljs-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr))) &#123;
		ret = -EFAULT;
		<span class="hljs-keyword">goto</span> out;
	&#125;
out:
	<span class="hljs-keyword">return</span> ret;
&#125;</code></pre>
<p><code>binder_write_read</code>时<code>内核层</code>定义的结构</p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">binder_write_read</span> &#123;</span><span class="hljs-comment">//用在binder内部</span>
	<span class="hljs-keyword">binder_size_t</span>		write_size;	<span class="hljs-comment">//用户空间写入数据的size</span>
	<span class="hljs-keyword">binder_size_t</span>		write_consumed;	<span class="hljs-comment">//Binder读取了多少数据</span>
	<span class="hljs-keyword">binder_uintptr_t</span>	write_buffer;<span class="hljs-comment">//用户空间写入数据</span>
	<span class="hljs-keyword">binder_size_t</span>		read_size;	<span class="hljs-comment">//binder写入数据的size</span>
	<span class="hljs-keyword">binder_size_t</span>		read_consumed;	<span class="hljs-comment">//用户空间读取了多少数据</span>
	<span class="hljs-keyword">binder_uintptr_t</span>	read_buffer; <span class="hljs-comment">//Binder写入数据</span>
&#125;;</code></pre>
<p><img src="/images/binder_transaction_data.jpg" srcset="/img/loading.gif" alt="binder_transaction_data"></p>
<p><code>binder_ioctl_write_read()</code>主要执行以下几步：</p>
<ol>
<li>通过<code>copy_from_user()</code>拷贝<code>用户空间数据</code>到<code>内核空间</code></li>
<li>存在<code>write_size &gt; 0</code>，意味着外部有数据传入，需要执行<code>binder_thread_write()</code>，读取外部传入数据</li>
<li>存在<code>read_size &gt; 0</code>，意味着有数据要传出，需要执行<code>binder_thread_read()</code>，写入数据准备传到外部</li>
<li>最后执行<code>copy_to_user()</code>拷贝<code>内核空间数据</code>到<code>用户空间</code></li>
</ol>
<p><img src="/images/Binder_binder_ioctl_write_read.png" srcset="/img/loading.gif" alt="Binder_write_read过程"></p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/Binder驱动加载过程.png" srcset="/img/loading.gif" alt="Binder驱动加载"></p>
<h2 id="Binder通信过程"><a href="#Binder通信过程" class="headerlink" title="Binder通信过程"></a>Binder通信过程</h2><p><img src="/images/binder_ipc_process.jpg" srcset="/img/loading.gif" alt="binder_ipc_process"></p>
<h3 id="Binder权限验证"><a href="#Binder权限验证" class="headerlink" title="Binder权限验证"></a>Binder权限验证</h3><p><code>进程A</code>通过Binder调用<code>进程B</code>，然后<code>进程B</code>又Binder调用<code>进程C</code>，此时进程C中的<code>IPCThreadState</code>存储的就是<code>进程A</code>的<code>PID和UID</code>。此时假如<code>进程B</code>想调用<code>进程C</code>，就会抛出异常<code>Bad call: specified package com.providers.xxx under uid 10032 but it is really 10001</code>。</p>
<p>上述流程就是<code>Binder权限验证</code>的流程。</p>
<p><code>在被调用时进程回去检测是否与自身IPCThreadState存储的uid与pid一致，只有一致才会请求成功。否则抛出异常</code></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> origId = Binder.clearCallingIdentity();
<span class="hljs-comment">//远程调用过程</span>
Binder.restoreCallingIdentity(origId);</code></pre>
<p><code>clearCallingIndetity()</code></p>
<blockquote>
<p>在当前线程中重置到来的IPC标识(<code>uid/pid</code>)，然后设置<code>mCallingUid</code>和<code>mCallingPid</code>为当前进程的值</p>
</blockquote>
<p><code>restoreCallingIdentity(id)</code></p>
<blockquote>
<p>还原前面存储的初始调用者的<code>mCallingPid</code>和<code>mCallingUid</code></p>
</blockquote>
<h2 id="Binder拓展知识"><a href="#Binder拓展知识" class="headerlink" title="Binder拓展知识"></a>Binder拓展知识</h2><h3 id="Binder传输数据上限，以及超出会如何？"><a href="#Binder传输数据上限，以及超出会如何？" class="headerlink" title="Binder传输数据上限，以及超出会如何？"></a>Binder传输数据上限，以及超出会如何？</h3><blockquote>
<p>Binder传输数据的最大限制为<code>1016KB</code>(默认情况下)，如果是异步执行，最多只有<code>508KB</code>。</p>
</blockquote>
<p>调用<code>mmap</code>映射的大小就为<code>1016KB</code>，如果超出这块区域，<code>Binder驱动</code>就无法处理Binder调用，然后会抛出<code>DeadObjectException</code>异常。</p>
<h3 id="每个进程最大Binder线程数，以及超出会如何？"><a href="#每个进程最大Binder线程数，以及超出会如何？" class="headerlink" title="每个进程最大Binder线程数，以及超出会如何？"></a>每个进程最大Binder线程数，以及超出会如何？</h3><blockquote>
<p>每个进程最多可以运行<code>16</code>个Binder线程</p>
</blockquote>
<p>当所有的16个binder线程都在工作时，就会出现线程饥饿状态。如果此时有新的binder线程请求，就会进入阻塞状态。</p>
<h3 id="oneway的作用"><a href="#oneway的作用" class="headerlink" title="oneway的作用"></a><code>oneway</code>的作用</h3><p><strong>异步调用和串行化处理</strong></p>
<ul>
<li><code>异步调用</code>:应用向<code>Binder驱动</code>发送数据后不需要挂起线程等待<code>Binder驱动</code>的回复，接收到<code>BR_TRANSACTION_COMPLETE</code>之后就直接结束。</li>
<li><code>串行化处理</code>：所有<code>oneway</code>方法不会同时执行，<code>Binder驱动</code>会进行串行化处理，保证一个个执行。</li>
</ul>
<blockquote>
<p><code>oneway</code>都是需要等待<code>BR_TRANSACTION_COMPLETE</code>消息。</p>
<p>不过<code>oneway</code>的请求方式在收到<code>BR_TRANSACTION_COMPLETE</code>消息后，立即返回；</p>
<p><code>非oneway</code>的请求方式，还需要等到<code>BR_REPLY</code>之后才返回。此时<code>线程就会处于Sleep状态</code>，底层调用的就是<code>wait_event_interruptible()</code></p>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">//XX.aidl</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IXX</span> </span>&#123;
  <span class="hljs-comment">//定义该方法调用 为 oneway</span>
  <span class="hljs-function">oneway <span class="hljs-keyword">void</span> <span class="hljs-title">xx</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.hacktivesecurity.com/index.php?controller=post&amp;action=view&amp;id_post=48" target="_blank" rel="noopener">Binder介绍</a></p>
<p><a href="http://gityuan.com/" target="_blank" rel="noopener">Binder系列讲解</a></p>
<p><a href="https://www.cnblogs.com/samchen2009/p/3316001.html" target="_blank" rel="noopener">图解Android - Binder 和 Service</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/05/30/View的刷新机制/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Android屏幕的刷新机制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/05/02/Java线程相关合集整理/">
                        <span class="hidden-mobile">Java线程相关合集整理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>







  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
